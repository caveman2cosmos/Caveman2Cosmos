// unit.cpp


#include "FProfiler.h"

#include "CvGameCoreDLL.h"
#include "CvArea.h"
#include "CvBuildingInfo.h"
#include "CvCity.h"
#include "CvEventReporter.h"
#include "CvGameAI.h"
#include "CvGlobals.h"
#include "CvImprovementInfo.h"
#include "CvInfos.h"
#include "CvUnitCombatInfo.h"
#include "CvTraitInfo.h"
#include "CvOutcomeList.h"
#include "CvMap.h"
#include "CvPlayerAI.h"
#include "CvPlot.h"
#include "CvPopupInfo.h"
#include "CvPython.h"
#include "CvSelectionGroup.h"
#include "CvTeamAI.h"
#include "CvUnit.h"
#include "CvUnitSelectionCriteria.h"
#include "CvViewport.h"
#include "CvDLLEngineIFaceBase.h"
#include "CvDLLInterfaceIFaceBase.h"
#include "CvDLLEntity.h"
#include "CvDLLEntityIFaceBase.h"
#include "CvDLLFAStarIFaceBase.h"
#include "CvDLLUtilityIFaceBase.h"
#include "CyPlot.h"
#include "CyUnit.h"
#include "CvDLLButtonPopup.h"
#ifdef USE_OLD_PATH_GENERATOR
#include "FAStarNode.h"
#endif

static CvEntity* g_dummyEntity = NULL;
static CvUnit*	 g_dummyUnit = NULL;
static int		 g_numEntities = 0;
static int		 g_dummyUsage = 0;
static bool		 g_bUseDummyEntities = false;

//	static buffers allocated once and used during read and write only
int*	CvUnit::g_paiTempPromotionFreeCount = NULL;
int*	CvUnit::g_paiTempAfflictOnAttackCount = NULL;
int*	CvUnit::g_paiTempCureAfflictionCount = NULL;
int*	CvUnit::g_paiTempCureAfflictionTypeCount = NULL;
int*	CvUnit::g_paiTempAfflictionLineCount = NULL;
int*	CvUnit::g_paiTempAfflictionTurnCount = NULL;
int*	CvUnit::g_paiTempAfflictionTurnTypeCount = NULL;
int*	CvUnit::g_paiTempAfflictionHitCount = NULL;
int*	CvUnit::g_paiTempAfflictionTolerance = NULL;
int*	CvUnit::g_paiTempTrapImmunityUnitCombatCount = NULL;
int*	CvUnit::g_paiTempTargetUnitCombatCount = NULL;
int*	CvUnit::g_paiTempExtraTrapDisableUnitCombatType = NULL;
int*	CvUnit::g_paiTempExtraTrapAvoidanceUnitCombatType = NULL;
int*	CvUnit::g_paiTempExtraTrapTriggerUnitCombatType = NULL;
int*	CvUnit::g_paiTempAfflictionTypeTolerance = NULL;
int*	CvUnit::g_paiTempFortitudeModifierTypeAmount = NULL;
int*	CvUnit::g_paiTempFortitudeModifierAmount = NULL;
int*	CvUnit::g_paiTempTrapSetWithPromotionCount = NULL;
int*	CvUnit::g_paiTempPromotionFromTraitCount = NULL;
int*	CvUnit::g_paiTempAfflictOnAttackTypeProbability = NULL;
int*	CvUnit::g_paiTempAfflictOnAttackTypeCount = NULL;
int*	CvUnit::g_paiTempAfflictOnAttackTypeImmediateCount = NULL;
int*	CvUnit::g_paiTempAfflictOnAttackTypeMeleeCount = NULL;
int*	CvUnit::g_paiTempAfflictOnAttackTypeDistanceCount = NULL;
int*	CvUnit::g_paiTempAfflictOnAttackTypeAttemptedCount = NULL;
int*	CvUnit::g_paiTempDistanceAttackCommunicability = NULL;
bool*	CvUnit::g_pabTempValidBuildUp = NULL;
int*	CvUnit::g_paiTempExtraUnitCombatModifier = NULL;
bool*	CvUnit::g_pabTempHasPromotion = NULL;
bool*	CvUnit::g_pabTempHasUnitCombat = NULL;
int*	CvUnit::g_paiTempExtraFlankingStrengthbyUnitCombatType = NULL;
int*	CvUnit::g_paiTempExtraWithdrawVSUnitCombatType = NULL;
int*	CvUnit::g_paiTempExtraPursuitVSUnitCombatType = NULL;
int*	CvUnit::g_paiTempExtraRepelVSUnitCombatType = NULL;
int*	CvUnit::g_paiTempExtraKnockbackVSUnitCombatType = NULL;
int*	CvUnit::g_paiTempExtraPunctureVSUnitCombatType = NULL;
int*	CvUnit::g_paiTempExtraArmorVSUnitCombatType = NULL;
int*	CvUnit::g_paiTempExtraDodgeVSUnitCombatType = NULL;
int*	CvUnit::g_paiTempExtraPrecisionVSUnitCombatType = NULL;
int*	CvUnit::g_paiTempExtraCriticalVSUnitCombatType = NULL;
int*	CvUnit::g_paiTempExtraRoundStunVSUnitCombatType = NULL;
int*	CvUnit::g_paiTempHealUnitCombatTypeVolume = NULL;
int*	CvUnit::g_paiTempHealUnitCombatTypeAdjacentVolume = NULL;
int*	CvUnit::g_paiTempHealAsDamage = NULL;
bool	CvUnit::m_staticsInitialized = false;

bool CvUnit::isDummyEntity(const CvEntity* entity)
{
	return (entity == g_dummyEntity);
}

bool CvUnit::isRealEntity(const CvEntity* entity)
{
	return (entity != NULL && entity != g_dummyEntity);
}

// Public Functions...
#pragma warning( disable : 4355 )
CvUnit::CvUnit(bool bIsDummy) : m_GameObject(this),
m_Properties(this)
{
	m_aiExtraDomainModifier = new int[NUM_DOMAIN_TYPES];
	m_aiExtraVisibilityIntensity = new int[GC.getNumInvisibleInfos()];
	m_aiExtraInvisibilityIntensity = new int[GC.getNumInvisibleInfos()];
	m_aiExtraVisibilityIntensityRange = new int[GC.getNumInvisibleInfos()];
	m_aiExtraVisibilityIntensitySameTile = new int[GC.getNumInvisibleInfos()];
	m_aiNegatesInvisibleCount = new int[GC.getNumInvisibleInfos()];
	m_aExtraInvisibleTerrains.clear();
	m_aExtraInvisibleFeatures.clear();
	m_aExtraInvisibleImprovements.clear();
	m_aExtraVisibleTerrains.clear();
	m_aExtraVisibleFeatures.clear();
	m_aExtraVisibleImprovements.clear();
	m_aExtraVisibleTerrainRanges.clear();
	m_aExtraVisibleFeatureRanges.clear();
	m_aExtraVisibleImprovementRanges.clear();

	m_iMaxMoveCacheTurn = -1;

	if (g_dummyUnit == NULL && !bIsDummy)
	{
		g_dummyUnit = new CvUnitAI(true);

		if (GC.getENABLE_DYNAMIC_UNIT_ENTITIES())
		{
			g_bUseDummyEntities = true;
		}
	}

	if (!g_bUseDummyEntities)
	{
		CvDLLEntity::createUnitEntity(this); // create and attach entity to unit
	}
	else if (g_dummyEntity == NULL)
	{
		CvDLLEntity::createUnitEntity(this); // create and attach entity to unit

		g_dummyEntity = getEntity();
	}
	else
	{
		setEntity(g_dummyEntity);
		g_dummyUsage++;
	}

	bGraphicsSetup = false;

	reset(0, NO_UNIT, NO_PLAYER, true);

	if (!m_staticsInitialized)
	{
		//	Allocate static buffers to be used during read and write
		g_paiTempPromotionFreeCount = new int[GC.getNumPromotionInfos()];
		g_paiTempAfflictOnAttackCount = new int[GC.getNumPromotionInfos()];
		g_paiTempCureAfflictionCount = new int[GC.getNumPromotionInfos()];
		g_paiTempCureAfflictionTypeCount = new int[GC.getNumPromotionLineInfos()];
		g_paiTempAfflictionLineCount = new int[GC.getNumPromotionLineInfos()];
		g_paiTempAfflictionTurnCount = new int[GC.getNumPromotionInfos()];
		g_paiTempAfflictionTurnTypeCount = new int[GC.getNumPromotionLineInfos()];
		g_paiTempAfflictionHitCount = new int[GC.getNumPromotionInfos()];
		g_paiTempAfflictionTolerance = new int[GC.getNumPromotionInfos()];
		g_paiTempTrapImmunityUnitCombatCount = new int[GC.getNumUnitCombatInfos()]();
		g_paiTempTargetUnitCombatCount = new int[GC.getNumUnitCombatInfos()]();
		g_paiTempExtraTrapDisableUnitCombatType = new int[GC.getNumUnitCombatInfos()]();
		g_paiTempExtraTrapAvoidanceUnitCombatType = new int[GC.getNumUnitCombatInfos()]();
		g_paiTempExtraTrapTriggerUnitCombatType = new int[GC.getNumUnitCombatInfos()]();
		g_paiTempAfflictionTypeTolerance = new int[GC.getNumPromotionLineInfos()];
		g_paiTempFortitudeModifierTypeAmount = new int[GC.getNumPromotionInfos()];
		g_paiTempFortitudeModifierAmount = new int[GC.getNumPromotionLineInfos()];
		g_paiTempTrapSetWithPromotionCount = new int[GC.getNumPromotionInfos()];
		g_paiTempPromotionFromTraitCount = new int [GC.getNumPromotionInfos()];
		g_paiTempAfflictOnAttackTypeProbability = new int[GC.getNumPromotionLineInfos()];
		g_paiTempAfflictOnAttackTypeCount = new int[GC.getNumPromotionLineInfos()];
		g_paiTempAfflictOnAttackTypeImmediateCount = new int[GC.getNumPromotionLineInfos()];
		g_paiTempAfflictOnAttackTypeMeleeCount = new int[GC.getNumPromotionLineInfos()];
		g_paiTempAfflictOnAttackTypeDistanceCount = new int[GC.getNumPromotionLineInfos()];
		g_paiTempAfflictOnAttackTypeAttemptedCount = new int[GC.getNumPromotionLineInfos()];
		g_paiTempDistanceAttackCommunicability = new int[GC.getNumPromotionLineInfos()];
		g_pabTempValidBuildUp = new bool[GC.getNumPromotionLineInfos()];
		g_paiTempExtraUnitCombatModifier = new int[GC.getNumUnitCombatInfos()];
		g_pabTempHasPromotion = new bool[GC.getNumPromotionInfos()];
		g_pabTempHasUnitCombat = new bool[GC.getNumUnitCombatInfos()];
		g_paiTempExtraFlankingStrengthbyUnitCombatType = new int[GC.getNumUnitCombatInfos()];
		g_paiTempExtraWithdrawVSUnitCombatType = new int[GC.getNumUnitCombatInfos()];
		g_paiTempExtraPursuitVSUnitCombatType = new int[GC.getNumUnitCombatInfos()];
		g_paiTempExtraRepelVSUnitCombatType = new int[GC.getNumUnitCombatInfos()];
		g_paiTempExtraKnockbackVSUnitCombatType = new int[GC.getNumUnitCombatInfos()];
		g_paiTempExtraPunctureVSUnitCombatType = new int[GC.getNumUnitCombatInfos()];
		g_paiTempExtraArmorVSUnitCombatType = new int[GC.getNumUnitCombatInfos()];
		g_paiTempExtraDodgeVSUnitCombatType = new int[GC.getNumUnitCombatInfos()];
		g_paiTempExtraPrecisionVSUnitCombatType = new int[GC.getNumUnitCombatInfos()];
		g_paiTempExtraCriticalVSUnitCombatType = new int[GC.getNumUnitCombatInfos()];
		g_paiTempExtraRoundStunVSUnitCombatType = new int[GC.getNumUnitCombatInfos()];
		g_paiTempHealUnitCombatTypeVolume = new int[GC.getNumUnitCombatInfos()]();
		g_paiTempHealUnitCombatTypeAdjacentVolume = new int[GC.getNumUnitCombatInfos()]();
		g_paiTempHealAsDamage = new int[GC.getNumUnitCombatInfos()];

		m_staticsInitialized = true;
	}
}


CvUnit::~CvUnit()
{
	if (!isUsingDummyEntities())
	{
		// Don't need to remove entity when the app is shutting down, or crash can occur
		if (!gDLL->GetDone() && GC.IsGraphicsInitialized())
		{
			gDLL->getEntityIFace()->RemoveUnitFromBattle(this);
			CvDLLEntity::removeEntity(); // remove entity from engine
		}
		CvDLLEntity::destroyEntity(); // delete CvUnitEntity and detach from us
	}
	SAFE_DELETE_ARRAY(m_aiExtraDomainModifier);
	SAFE_DELETE_ARRAY(m_aiExtraVisibilityIntensity);
	SAFE_DELETE_ARRAY(m_aiExtraInvisibilityIntensity);
	SAFE_DELETE_ARRAY(m_aiExtraVisibilityIntensityRange);
	SAFE_DELETE_ARRAY(m_aiExtraVisibilityIntensitySameTile);
	SAFE_DELETE_ARRAY(m_aiNegatesInvisibleCount);
	SAFE_DELETE(m_commander);
	SAFE_DELETE(m_commodore);
	SAFE_DELETE(m_worker);
}


bool CvUnit::isUsingDummyEntities() const
{
	const CvEntity* entity = getEntity();

	return entity && g_dummyEntity == entity;
}

void CvUnit::reloadEntity(bool bForceLoad)
{
	const bool bNeedsRealEntity =
	(
		!g_bUseDummyEntities || bForceLoad
		||
		plot() && plot()->isActiveVisible(false)
		&&
		(plot()->getCenterUnit(false) == this || getOwner() == GC.getGame().getActivePlayer())
	);

	//OutputDebugString(CvString::format("reloadEntity for %08lx\n", this).c_str());
	if (!IsSelected())
	{
		if (!isUsingDummyEntities())
		{
			// Destroy old entity, don't need to remove entity when the app is shutting down, or crash can occur
			if (!gDLL->GetDone() && GC.IsGraphicsInitialized())
			{
				gDLL->getEntityIFace()->RemoveUnitFromBattle(this);
				CvDLLEntity::removeEntity(); // remove entity from engine
			}
			CvDLLEntity::destroyEntity(); // delete CvUnitEntity and detach from us
			g_numEntities--;

			setEntity(NULL);
		}
		else if (bNeedsRealEntity)
		{
			g_dummyUsage--;

			setEntity(NULL);
		}

		if (!getEntity())
		{
			if (g_bUseDummyEntities)
			{
				if (bNeedsRealEntity)
				{
					// Create and attach entity to unit
					CvDLLEntity::createUnitEntity(this);
					g_numEntities++;
					bGraphicsSetup = false;
				}
				else
				{
					setEntity(g_dummyEntity);
					g_dummyUsage++;
				}

				// Log every now and again in non final release builds
				if (g_numEntities%100 == 0)
				{
					OutputDebugString(CvString::format("Dummy unit entity usage: %d, real %d\n", g_dummyUsage, g_numEntities).c_str());
				}
			}
			else if (plot())
			{
				// Create and attach entity to unit
				CvDLLEntity::createUnitEntity(this);
				bGraphicsSetup = false;
			}
		}

		if (!bGraphicsSetup && bNeedsRealEntity && plot())
		{
			setupGraphical();
			bGraphicsSetup = true;
		}
	}
	else OutputDebugString("Reload of selected unit\n");
}

void CvUnit::changeIdentity(UnitTypes eUnit)
{
	reset(getID(), eUnit, getOwner(), false, true);
	//	Same id is now a differnt unit - make sure no old cached path info
	//	gets used for it
	CvPlot::NextCachePathEpoch();
}

void CvUnit::init(int iID, UnitTypes eUnit, UnitAITypes eUnitAI, PlayerTypes eOwner, int iX, int iY, DirectionTypes eFacingDirection, int iBirthmark)
{
	PROFILE_EXTRA_FUNC();
	FASSERT_BOUNDS(0, GC.getNumUnitInfos(), eUnit);

	//	If the current viewport is not yet initialized center it on the first unit created for the active player
	if (GC.getGame().getActivePlayer() == eOwner
	&& GC.getCurrentViewport()->getState() == VIEWPORT_MODE_UNINITIALIZED
	&& UNIT_BIRTHMARK_TEMP_UNIT != iBirthmark)
	{
		GC.getCurrentViewport()->setOffsetToShow(iX, iY);
	}
	//--------------------------------
	// Init saved data
	reset(iID, eUnit, eOwner);

	// Koshling -  moved this earlier to get unitAI set up so that
	// constraint checking on the unitAI can work more uniformly
	AI_init(eUnitAI, iBirthmark);

	if (eFacingDirection == NO_DIRECTION)
		m_eFacingDirection = DIRECTION_SOUTH;
	else m_eFacingDirection = eFacingDirection;

	//--------------------------------
	// Init containers

	//--------------------------------
	// Init pre-setup() data
	//GC.getGame().logOOSSpecial(13, getID(), iX, iY);
	setXY(iX, iY, false, true, false, false, true);

	//TB OOS fix - POSSIBLE that this represents a fix but I consider it a longshot since they should really mean the same thing (-1)
	if (!getGroup())
	{
		::MessageBox(
			NULL, getGroupID() == FFreeList::INVALID_INDEX ?
				"Unit with NULL group ID after set position in init\n"
				:
				"Unit with no group after set position in init\n",
			"CvGameCoreDLL Diagnostics", MB_OK
		);
	}
	// ! TB

	if (iBirthmark != UNIT_BIRTHMARK_TEMP_UNIT)
	{
		if (plot()->getPlotCity())
		{
			setCityOfOrigin(plot()->getPlotCity());
		}

		if (m_pUnitInfo->getNumBuilds() > 0)
		{
			m_worker = new UnitCompWorker();
		}
		const int iNumNames = m_pUnitInfo->getNumUnitNames();

		if (GC.getGame().getUnitCreatedCount(getUnitType()) < iNumNames)
		{
			const int iOffset = GC.getGame().getSorenRandNum(iNumNames, "Unit name selection");

			for (int iI = 0; iI < iNumNames; iI++)
			{
				CvWString szName = gDLL->getText(m_pUnitInfo->getUnitNames((iI + iOffset) % iNumNames));

				if (!GC.getGame().isGreatPersonBorn(szName))
				{
					setName(szName);
					GC.getGame().addGreatPersonBornName(szName);
					break;
				}
			}
		}
		setGameTurnCreated(GC.getGame().getGameTurn());
		calcUpkeep100(); // This updates total upkeep on the player level too

		GC.getGame().incrementUnitCreatedCount(eUnit);
		GET_PLAYER(eOwner).changeUnitCount(eUnit, 1);

		if (eUnitAI == UNITAI_SUBDUED_ANIMAL)
		{
			GET_PLAYER(eOwner).NoteAnimalSubdued();
		}

		if (m_pUnitInfo->getNukeRange() != -1)
		{
			GET_PLAYER(eOwner).changeNumNukeUnits(1);
		}

		if (isMilitaryBranch())
		{
			GET_PLAYER(eOwner).changeNumMilitaryUnits(1);
		}

		doSetUnitCombats();
		doSetFreePromotions(true);
		doSetDefaultStatuses();

		// Cache initial healer values
		for (int iI = m_pUnitInfo->getNumHealUnitCombatTypes() - 1; iI > -1; iI--)
		{
			const HealUnitCombat& data = m_pUnitInfo->getHealUnitCombatType(iI);

			changeHealUnitCombatTypeVolume(data.eUnitCombat, data.iHeal);
			changeHealUnitCombatTypeAdjacentVolume(data.eUnitCombat, data.iAdjacentHeal);
		}

		if (GC.getGame().isOption(GAMEOPTION_COMBAT_SIZE_MATTERS))
		{
			setSMValues();

			// if unit doesn't have a group rank, it doesn't count as a SM unit at all
			if (groupRank() > 0)
			{
				GET_PLAYER(eOwner).changeUnitCountSM(eUnit, intPow(3, groupRank()-1));
			}
		}
		else
		{
			GET_PLAYER(eOwner).changeAssets(m_pUnitInfo->getAssetValue());
			GET_PLAYER(eOwner).changeUnitPower(m_pUnitInfo->getPowerValue());
		}
		//--------------------------------
		// Init non-saved data
		setupGraphical();

		//--------------------------------
		// Init other game data
		plot()->updateCenterUnit();

		plot()->setFlagDirty(true);

		if (getDomainType() == DOMAIN_LAND && baseCombatStr() > 0
		&& (GC.getGame().getBestLandUnit() == NO_UNIT || baseCombatStrNonGranular() > GC.getGame().getBestLandUnitCombat()))
		{
			GC.getGame().setBestLandUnit(getUnitType());
		}

		if (eOwner == GC.getGame().getActivePlayer())
		{
			gDLL->getInterfaceIFace()->setDirty(GameData_DIRTY_BIT, true);
		}

		if (isWorldUnit(eUnit))
		{
			for (int iI = 0; iI < MAX_PLAYERS; iI++)
			{
				if (GET_PLAYER((PlayerTypes)iI).isAlive())
				{

					if (GET_TEAM(getTeam()).isHasMet(GET_PLAYER((PlayerTypes)iI).getTeam()))
					{
						AddDLLMessage(
							(PlayerTypes) iI, false, GC.getEVENT_MESSAGE_TIME(),
							gDLL->getText("TXT_KEY_MISC_SOMEONE_CREATED_UNIT", GET_PLAYER(eOwner).getNameKey(), getNameKey()),
							"AS2D_WONDER_UNIT_BUILD", MESSAGE_TYPE_MAJOR_EVENT, getButton(),
							GC.getCOLOR_UNIT_TEXT(), getX(), getY(), true, true
						);
					}
					else
					{
						AddDLLMessage(
							(PlayerTypes) iI, false, GC.getEVENT_MESSAGE_TIME(),
							gDLL->getText("TXT_KEY_MISC_UNKNOWN_CREATED_UNIT", getNameKey()),
							"AS2D_WONDER_UNIT_BUILD", MESSAGE_TYPE_MAJOR_EVENT, getButton(),
							GC.getCOLOR_UNIT_TEXT()
						);
					}
				}
			}
			GC.getGame().addReplayMessage(
				REPLAY_MESSAGE_MAJOR_EVENT, eOwner,
				gDLL->getText("TXT_KEY_MISC_SOMEONE_CREATED_UNIT", GET_PLAYER(eOwner).getNameKey(), getNameKey()),
				getX(), getY(), GC.getCOLOR_UNIT_TEXT()
			);
		}
		setGGExperienceEarnedTowardsType();

		if (GC.getGame().isOption(GAMEOPTION_COMBAT_HIDE_SEEK))
		{
			setHasAnyInvisibility();
		}
		establishBuildups();

		CvEventReporter::getInstance().unitCreated(this);
	}
}


// FUNCTION: reset()
// Initializes data members that are serialized.
void CvUnit::reset(int iID, UnitTypes eUnit, PlayerTypes eOwner, bool bConstructorCall, bool bIdentityChange)
{
	PROFILE_EXTRA_FUNC();
	clearCityOfOrigin();

	m_iHealUnitCombatCount = 0;

	m_iDCMBombRange = 0;
	m_iDCMBombAccuracy = 0;

	m_iID = iID;
	if (!bIdentityChange)
	{
		m_iGroupID = FFreeList::INVALID_INDEX;
	}
	m_iHotKeyNumber = -1;
	m_iX = INVALID_PLOT_COORD;
	m_iY = INVALID_PLOT_COORD;
	m_iLastMoveTurn = 0;
	m_iReconX = INVALID_PLOT_COORD;
	m_iReconY = INVALID_PLOT_COORD;
	m_iGameTurnCreated = 0;
	m_iDamage = 0;
	m_iMoves = 0;
	m_iExperience = 0;
	m_iLevel = 1;
	m_iCargo = 0;
	m_iSMCargo = 0;
	m_iAttackPlotX = INVALID_PLOT_COORD;
	m_iAttackPlotY = INVALID_PLOT_COORD;
	m_iCombatTimer = 0;
	m_iCombatFirstStrikes = 0;
	m_iFortifyTurns = 0;
	m_iBuildUpTurns = 0;
	m_iBlitzCount = 0;
	m_iRBombardForceAbilityCount = 0;
	m_iAmphibCount = 0;
	m_iRiverCount = 0;
	m_iEnemyRouteCount = 0;
	m_iAlwaysHealCount = 0;
	m_iHillsDoubleMoveCount = 0;
	m_iImmuneToFirstStrikesCount = 0;
	m_iAlwaysInvisibleCount = 0;

	m_iDefensiveVictoryMoveCount = 0;
	m_iFreeDropCount = 0;
	m_iOffensiveVictoryMoveCount = 0;

	m_iOneUpCount = 0;
	m_iPillageCultureCount = 0;
	m_iPillageEspionageCount = 0;
	m_iPillageMarauderCount = 0;
	m_iPillageOnMoveCount = 0;
	m_iPillageOnVictoryCount = 0;
	m_iPillageResearchCount = 0;
	m_iAirCombatLimitChange = 0;
	m_iCelebrityHappy = 0;
	m_iCollateralDamageLimitChange = 0;
	m_iCollateralDamageMaxUnitsChange = 0;
	m_iCombatLimitChange = 0;
	m_iExtraDropRange = 0;

	m_iSurvivorChance = 0;
	m_iVictoryAdjacentHeal = 0;
	m_iVictoryHeal = 0;
	m_iVictoryStackHeal = 0;

	m_iExtraVisibilityRange = 0;
	m_iExtraMoves = 0;
	m_iExtraMoveDiscount = 0;
	m_iExtraAirRange = 0;
	m_iExtraIntercept = 0;
	m_iExtraEvasion = 0;
	m_iExtraFirstStrikes = 0;
	m_iExtraChanceFirstStrikes = 0;
	m_iExtraWithdrawal = 0;
	//TB Combat Mods Begin
	m_iExtraAttackCombatModifier = 0;
	m_iExtraDefenseCombatModifier = 0;
	m_iExtraPursuit = 0;
	m_iExtraEarlyWithdraw = 0;
	m_iExtraVSBarbs = 0;
	m_iExtraReligiousCombatModifier = 0;
	m_iExtraArmor = 0;
	m_iExtraPuncture = 0;
	m_iExtraOverrun = 0;
	m_iExtraRepel = 0;
	m_iExtraFortRepel = 0;
	m_iExtraRepelRetries = 0;
	m_iExtraUnyielding = 0;
	m_iExtraKnockback = 0;
	m_iExtraKnockbackRetries = 0;
	m_iStampedeCount = 0;
	m_iAttackOnlyCitiesCount = 0;
	m_iIgnoreNoEntryLevelCount = 0;
	m_iIgnoreZoneofControlCount = 0;
	m_iFliesToMoveCount = 0;
	m_iExtraStrAdjperRnd = 0;
	m_iExtraStrAdjperAtt = 0;
	m_iExtraStrAdjperDef = 0;
	m_iExtraWithdrawAdjperAtt = 0;
	m_iExtraUnnerve = 0;
	m_iExtraEnclose = 0;
	m_iExtraLunge = 0;
	m_iExtraDynamicDefense = 0;
	m_iExtraStrength = 0;
	m_iSMStrength = 0;
	m_iAnimalIgnoresBordersCount = 0;
	m_iOnslaughtCount = 0;
	m_iExtraFortitude = 0;
#ifdef STRENGTH_IN_NUMBERS
	m_iExtraFrontSupportPercent = 0;
	m_iExtraShortRangeSupportPercent = 0;
	m_iExtraMediumRangeSupportPercent = 0;
	m_iExtraLongRangeSupportPercent = 0;
	m_iExtraFlankSupportPercent = 0;
	m_iSupportCount = 0;
	m_iAttackFromPlotX = INVALID_PLOT_COORD;
	m_iAttackFromPlotY = INVALID_PLOT_COORD;
#endif // STRENGTH_IN_NUMBERS
	m_iExtraDodgeModifier = 0;
	m_iExtraPrecisionModifier = 0;
	m_iExtraPowerShots = 0;
	m_iExtraPowerShotCombatModifier = 0;
	m_iExtraPowerShotPunctureModifier = 0;
	m_iExtraPowerShotPrecisionModifier = 0;
	m_iExtraPowerShotCriticalModifier = 0;
	m_iExtraCriticalModifier = 0;
	m_iExtraEndurance = 0;
	m_iColdDamage = 0;
	m_iDealColdDamageCount = 0;
	m_iColdImmuneCount = 0;
	m_iCombatPowerShots = 0;
	m_iCombatKnockbacks = 0;
	m_iCombatRepels = 0;
	m_iExtraRoundStunProb = 0;
	m_iCombatStuns = 0;
	m_iExtraPoisonProbabilityModifier = 0;
	m_iRetrainsAvailable = 0;
	m_iQualityBaseTotal = 0;
	m_iGroupBaseTotal = 0;
	m_iSizeBaseTotal = 0;
	m_iExtraQuality = 0;
	m_iExtraGroup = 0;
	m_iExtraSize = 0;
	m_iSMCargoVolume = 0;
	m_iSMExtraCargoVolume = 0;
	m_iSMCargoVolumeModifier = 0;
	m_iCannotMergeSplitCount = 0;

	m_iExtraCaptureProbabilityModifier = 0;
	m_iExtraCaptureResistanceModifier = 0;

	m_iExtraBreakdownChance = 0;
	m_iExtraBreakdownDamage = 0;
	m_iExtraTaunt = 0;
	m_iExtraCombatModifierPerSizeMore = 0;
	m_iExtraCombatModifierPerSizeLess = 0;
	m_iExtraCombatModifierPerVolumeMore = 0;
	m_iExtraCombatModifierPerVolumeLess = 0;
	m_iExtraMaxHP = 0;
	m_iExtraStrengthModifier = 0;
	m_iExtraDamageModifier = 0;
	m_iExtraUpkeep100 = 0;
	m_iUpkeepModifier = 0;
	m_iUpkeepMultiplierSM = 0;
	m_iUpkeep100 = 0;
	m_iSMAssetValue = 0;
	m_iSMPowerValue = 0;
	m_iSMHPValue = 0;
	m_iExtraRBombardDamage = 0;
	m_iExtraRBombardDamageLimit = 0;
	m_iExtraRBombardDamageMaxUnits = 0;
	m_iExtraDCMBombRange = 0;
	m_iExtraDCMBombAccuracy = 0;
	m_iBaseRBombardDamage = 0;
	m_iBaseRBombardDamageLimit = 0;
	m_iBaseRBombardDamageMaxUnits = 0;
	m_iBaseDCMBombRange = 0;
	m_iBaseDCMBombAccuracy = 0;
	m_iBombardDirectCount = 0;
	//TB Combat Mods End
	m_iExtraCollateralDamage = 0;
	m_iExtraBombardRate = 0;
	m_iSMBombardRate = 0;
	m_iSMAirBombBaseRate = 0;
	m_iSMBaseWorkRate = 0;
	m_iSMRevoltProtection = 0;
	m_iExtraEnemyHeal = 0;
	m_iExtraNeutralHeal = 0;
	m_iExtraFriendlyHeal = 0;
	m_iSameTileHeal = 0;
	m_iAdjacentTileHeal = 0;
	m_iExtraCombatPercent = 0;
	m_iExtraCityAttackPercent = 0;
	m_iExtraCityDefensePercent = 0;
	m_iExtraHillsAttackPercent = 0;
	m_iExtraHillsDefensePercent = 0;

	m_iRevoltProtection = 0;
	m_iCollateralDamageProtection = 0;
	m_iPillageChange = 0;
	m_iUpgradeDiscount = 0;
	m_iExperiencePercent = 0;
	m_iKamikazePercent = 0;
	m_eFacingDirection = DIRECTION_SOUTH;
	m_iImmobileTimer = 0;

	m_bCanRespawn = false; // Koshling - intentionally not saved - m_bCanrespawn should never persist in saves
	// as it is used only within a combat round and set upon unit death IF the unit has outstanding oneUpCount.
	// In some circumstances an autosave can save a state where the unit has just been respawned,
	// but m_bCanRespawn has not yet been reset at the start of the next turn, which leaves it bugged in the next turn's combat.

	m_bSurvivor = false;
	m_bMadeAttack = false;
	//TB Combat Mods (Att&DefCounters)
	m_iRoundCount = 0;
	m_iAttackCount = 0;
	m_iDefenseCount = 0;
	//TB Combat Mods end
	m_bMadeInterception = false;
	m_bPromotionReady = false;
	m_bDeathDelay = false;
	m_bInfoBarDirty = false;
	m_bBlockading = false;
	m_bAirCombat = false;
	m_bHasBuildUp = false;
	m_bInhibitMerge = false;
	m_bInhibitSplit = false;
	m_bIsBuildUp = false;
	m_bIsReligionLocked = false;

	m_iCanMovePeaksCount = 0;
	// Koshling - enhanced mountaineering mode to differentiate between ability to move through
	// mountains, and ability to lead a stack through mountains
	m_iCanLeadThroughPeaksCount = 0;

	if (eUnit != NO_UNIT)
	{
		m_movementCharacteristicsHash = GC.getUnitInfo(eUnit).getZobristValue();
	}

	m_iSleepTimer = 0;
	//@MOD Commanders/Commodores: reset parameters
	m_iCommanderID = -1;
	m_iCommodoreID = -1;
	m_iUsedCommanderID = -1;
	m_iUsedCommodoreID = -1;
	m_eOriginalOwner = eOwner;
	m_eNewDomainCargo = NO_DOMAIN;
	m_eNewSpecialCargo = NO_SPECIALUNIT;
	m_eNewSMNotSpecialCargo = NO_SPECIALUNIT;
	m_eSpecialUnit = NO_SPECIALUNIT;
	m_eSleepType = NO_MISSION;
	m_iZoneOfControlCount = 0;
	m_iExcileCount = 0;
	m_iPassageCount = 0;
	m_iNoNonOwnedCityEntryCount = 0;
	m_iBarbCoExistCount = 0;
	m_iBlendIntoCityCount = 0;
	m_iUpgradeAnywhereCount = 0;
	m_bAutoPromoting = false;
	m_bAutoUpgrading = false;
	m_iHiddenNationalityCount = 0;
	m_bHasHNCapturePromotion = false;
	m_bHasAnyInvisibility = false;
	m_bRevealed = false;
	m_shadowUnit.reset();

	m_eOwner = eOwner;
	m_eCapturingPlayer = NO_PLAYER;
	m_eUnitType = eUnit;
	m_eReligionType = NO_RELIGION;
	m_pUnitInfo = (NO_UNIT != m_eUnitType) ? &GC.getUnitInfo(m_eUnitType) : NULL;
	m_iBaseCombat = (NO_UNIT != m_eUnitType) ? m_pUnitInfo->getCombat() : 0;
	m_eLeaderUnitType = NO_UNIT;
	m_eGGExperienceEarnedTowardsType = NO_UNIT;
	m_iCargoCapacity = 0;
	m_iSMCargoCapacity = 0;
	m_iExtraSelfHealModifier = 0;
	m_iExtraNumHealSupport = 0;
	m_iHealSupportUsed = 0;
	m_iExtraInsidiousness = 0;
	m_iExtraInvestigation = 0;
	m_iNoSelfHealCount = 0;
	m_iDebugCount = 0;
	m_iAssassinCount = 0;
	m_iExtraStealthStrikes = 0;
	m_iExtraStealthCombatModifier = 0;
	m_iStealthDefenseCount = 0;
	m_iOnlyDefensiveCount = 0;
	m_iNoInvisibilityCount = 0;
	m_iNoCaptureCount = 0;
	m_iExtraTrapDamageMax = 0;
	m_iExtraTrapDamageMin = 0;
	m_iExtraTrapComplexity = 0;
	m_iExtraNumTriggers = 0;
	m_iNumTimesTriggered = 0;
	m_iTriggerBeforeAttackCount = 0;
	m_iExtraNoDefensiveBonusCount = 0;
	m_iExtraGatherHerdCount = 0;
	m_bIsArmed = false;
	m_eCurrentBuildUpType = NO_PROMOTIONLINE;

	m_eCapturingUnit.reset();
	m_combatUnit.reset();
	m_transportUnit.reset();
#ifdef STRENGTH_IN_NUMBERS
	//TB Combat Mods begin
	afIUnit.reset();
	afIIUnit.reset();
	asrIUnit.reset();
	asrIIUnit.reset();
	amrIUnit.reset();
	amrIIUnit.reset();
	alrIUnit.reset();
	alrIIUnit.reset();
	aflIUnit.reset();
	aflIIUnit.reset();
	dfIUnit.reset();
	dfIIUnit.reset();
	dsrIUnit.reset();
	dsrIIUnit.reset();
	dmrIUnit.reset();
	dmrIIUnit.reset();
	dlrIUnit.reset();
	dlrIIUnit.reset();
	dflIUnit.reset();
	dflIIUnit.reset();
	//TB Combat Mods end
#endif // STRENGTH_IN_NUMBERS

	for (int iI = 0; iI < NUM_DOMAIN_TYPES; iI++)
	{
		m_aiExtraDomainModifier[iI] = 0;
	}

	for (int iI = 0; iI < GC.getNumInvisibleInfos(); iI++)
	{
		m_aiExtraVisibilityIntensity[iI] = 0;
		m_aiExtraInvisibilityIntensity[iI] = 0;
		m_aiExtraVisibilityIntensityRange[iI] = 0;
		m_aiExtraVisibilityIntensitySameTile[iI] = 0;
		m_aiNegatesInvisibleCount[iI] = 0;
	}

	m_aExtraInvisibleTerrains.clear();
	m_aExtraInvisibleFeatures.clear();
	m_aExtraInvisibleImprovements.clear();
	m_aExtraVisibleTerrains.clear();
	m_aExtraVisibleFeatures.clear();
	m_aExtraVisibleImprovements.clear();
	m_aExtraVisibleTerrainRanges.clear();
	m_aExtraVisibleFeatureRanges.clear();
	m_aExtraVisibleImprovementRanges.clear();
	m_szName.clear();
	m_szScriptData = "";

	m_aExtraAidChanges.clear();

	if (!bConstructorCall)
	{
		FAssertMsg((0 < GC.getNumPromotionInfos()), "GC.getNumPromotionInfos() is not greater than zero but an array is being allocated in CvUnit::reset");

		m_promotionKeyedInfo.clear();
		m_promotionLineKeyedInfo.clear();
		m_terrainKeyedInfo.clear();
		m_featureKeyedInfo.clear();
		m_unitCombatKeyedInfo.clear();

		if (!bIdentityChange)
		{
			AI_reset(NO_UNITAI, true);
		}
	}
	m_pPlayerInvestigated = NO_PLAYER;
	m_Properties.clear();

	// Toffer - UnitComponents
	m_commander = NULL;
	m_commodore = NULL;
	m_worker = NULL;
}

CvUnit& CvUnit::operator=(const CvUnit& other)
{
	m_iHealUnitCombatCount = other.m_iHealUnitCombatCount;
	m_iDCMBombRange = other.m_iDCMBombRange;
	m_iDCMBombAccuracy = other.m_iDCMBombAccuracy;
	//m_iID = other.m_iID;
	//if (!bIdentityChange)
	//{
	//	m_iGroupID = other.m_iGroupID;
	//}
	m_iHotKeyNumber = other.m_iHotKeyNumber;
	//m_iX = other.m_iX;
	//m_iY = other.m_iY;
	m_iLastMoveTurn = other.m_iLastMoveTurn;
	m_iReconX = other.m_iReconX;
	m_iReconY = other.m_iReconY;
	m_iGameTurnCreated = other.m_iGameTurnCreated;
	m_iDamage = other.m_iDamage;
	m_iMoves = other.m_iMoves;
	m_iExperience = other.m_iExperience;
	m_iLevel = other.m_iLevel;
	m_iCargo = other.m_iCargo;
	m_iSMCargo = other.m_iSMCargo;
	m_iAttackPlotX = other.m_iAttackPlotX;
	m_iAttackPlotY = other.m_iAttackPlotY;
	m_iCombatTimer = other.m_iCombatTimer;
	m_iCombatFirstStrikes = other.m_iCombatFirstStrikes;
	m_iFortifyTurns = other.m_iFortifyTurns;
	m_iBuildUpTurns = other.m_iBuildUpTurns;
	m_iBlitzCount = other.m_iBlitzCount;
	m_iRBombardForceAbilityCount = other.m_iRBombardForceAbilityCount;
	m_iAmphibCount = other.m_iAmphibCount;
	m_iRiverCount = other.m_iRiverCount;
	m_iEnemyRouteCount = other.m_iEnemyRouteCount;
	m_iAlwaysHealCount = other.m_iAlwaysHealCount;
	m_iHillsDoubleMoveCount = other.m_iHillsDoubleMoveCount;
	m_iImmuneToFirstStrikesCount = other.m_iImmuneToFirstStrikesCount;
	m_iAlwaysInvisibleCount = other.m_iAlwaysInvisibleCount;
	m_iDefensiveVictoryMoveCount = other.m_iDefensiveVictoryMoveCount;
	m_iFreeDropCount = other.m_iFreeDropCount;
	m_iOffensiveVictoryMoveCount = other.m_iOffensiveVictoryMoveCount;
	m_iOneUpCount = other.m_iOneUpCount;
	m_iPillageCultureCount = other.m_iPillageCultureCount;
	m_iPillageEspionageCount = other.m_iPillageEspionageCount;
	m_iPillageMarauderCount = other.m_iPillageMarauderCount;
	m_iPillageOnMoveCount = other.m_iPillageOnMoveCount;
	m_iPillageOnVictoryCount = other.m_iPillageOnVictoryCount;
	m_iPillageResearchCount = other.m_iPillageResearchCount;
	m_iAirCombatLimitChange = other.m_iAirCombatLimitChange;
	m_iCelebrityHappy = other.m_iCelebrityHappy;
	m_iCollateralDamageLimitChange = other.m_iCollateralDamageLimitChange;
	m_iCollateralDamageMaxUnitsChange = other.m_iCollateralDamageMaxUnitsChange;
	m_iCombatLimitChange = other.m_iCombatLimitChange;
	m_iExtraDropRange = other.m_iExtraDropRange;
	m_iSurvivorChance = other.m_iSurvivorChance;
	m_iVictoryAdjacentHeal = other.m_iVictoryAdjacentHeal;
	m_iVictoryHeal = other.m_iVictoryHeal;
	m_iVictoryStackHeal = other.m_iVictoryStackHeal;
	m_iExtraVisibilityRange = other.m_iExtraVisibilityRange;
	m_iExtraMoves = other.m_iExtraMoves;
	m_iExtraMoveDiscount = other.m_iExtraMoveDiscount;
	m_iExtraAirRange = other.m_iExtraAirRange;
	m_iExtraIntercept = other.m_iExtraIntercept;
	m_iExtraEvasion = other.m_iExtraEvasion;
	m_iExtraFirstStrikes = other.m_iExtraFirstStrikes;
	m_iExtraChanceFirstStrikes = other.m_iExtraChanceFirstStrikes;
	m_iExtraWithdrawal = other.m_iExtraWithdrawal;
	m_iExtraAttackCombatModifier = other.m_iExtraAttackCombatModifier;
	m_iExtraDefenseCombatModifier = other.m_iExtraDefenseCombatModifier;
	m_iExtraPursuit = other.m_iExtraPursuit;
	m_iExtraEarlyWithdraw = other.m_iExtraEarlyWithdraw;
	m_iExtraVSBarbs = other.m_iExtraVSBarbs;
	m_iExtraReligiousCombatModifier = other.m_iExtraReligiousCombatModifier;
	m_iExtraArmor = other.m_iExtraArmor;
	m_iExtraPuncture = other.m_iExtraPuncture;
	m_iExtraOverrun = other.m_iExtraOverrun;
	m_iExtraRepel = other.m_iExtraRepel;
	m_iExtraFortRepel = other.m_iExtraFortRepel;
	m_iExtraRepelRetries = other.m_iExtraRepelRetries;
	m_iExtraUnyielding = other.m_iExtraUnyielding;
	m_iExtraKnockback = other.m_iExtraKnockback;
	m_iExtraKnockbackRetries = other.m_iExtraKnockbackRetries;
	m_iStampedeCount = other.m_iStampedeCount;
	m_iAttackOnlyCitiesCount = other.m_iAttackOnlyCitiesCount;
	m_iIgnoreNoEntryLevelCount = other.m_iIgnoreNoEntryLevelCount;
	m_iIgnoreZoneofControlCount = other.m_iIgnoreZoneofControlCount;
	m_iFliesToMoveCount = other.m_iFliesToMoveCount;
	m_iExtraStrAdjperRnd = other.m_iExtraStrAdjperRnd;
	m_iExtraStrAdjperAtt = other.m_iExtraStrAdjperAtt;
	m_iExtraStrAdjperDef = other.m_iExtraStrAdjperDef;
	m_iExtraWithdrawAdjperAtt = other.m_iExtraWithdrawAdjperAtt;
	m_iExtraUnnerve = other.m_iExtraUnnerve;
	m_iExtraEnclose = other.m_iExtraEnclose;
	m_iExtraLunge = other.m_iExtraLunge;
	m_iExtraDynamicDefense = other.m_iExtraDynamicDefense;
	m_iExtraStrength = other.m_iExtraStrength;
	m_iSMStrength = other.m_iSMStrength;
	m_iAnimalIgnoresBordersCount = other.m_iAnimalIgnoresBordersCount;
	m_iOnslaughtCount = other.m_iOnslaughtCount;
	m_iExtraFortitude = other.m_iExtraFortitude;
#ifdef STRENGTH_IN_NUMBERS
	m_iExtraFrontSupportPercent = other.m_iExtraFrontSupportPercent;
	m_iExtraShortRangeSupportPercent = other.m_iExtraShortRangeSupportPercent;
	m_iExtraMediumRangeSupportPercent = other.m_iExtraMediumRangeSupportPercent;
	m_iExtraLongRangeSupportPercent = other.m_iExtraLongRangeSupportPercent;
	m_iExtraFlankSupportPercent = other.m_iExtraFlankSupportPercent;
	m_iSupportCount = other.m_iSupportCount;
	m_iAttackFromPlotX = other.m_iAttackFromPlotX;
	m_iAttackFromPlotY = other.m_iAttackFromPlotY;
#endif // STRENGTH_IN_NUMBERS
	m_iExtraDodgeModifier = other.m_iExtraDodgeModifier;
	m_iExtraPrecisionModifier = other.m_iExtraPrecisionModifier;
	m_iExtraPowerShots = other.m_iExtraPowerShots;
	m_iExtraPowerShotCombatModifier = other.m_iExtraPowerShotCombatModifier;
	m_iExtraPowerShotPunctureModifier = other.m_iExtraPowerShotPunctureModifier;
	m_iExtraPowerShotPrecisionModifier = other.m_iExtraPowerShotPrecisionModifier;
	m_iExtraPowerShotCriticalModifier = other.m_iExtraPowerShotCriticalModifier;
	m_iExtraCriticalModifier = other.m_iExtraCriticalModifier;
	m_iExtraEndurance = other.m_iExtraEndurance;
	m_iColdDamage = other.m_iColdDamage;
	m_iDealColdDamageCount = other.m_iDealColdDamageCount;
	m_iColdImmuneCount = other.m_iColdImmuneCount;
	m_iCombatPowerShots = other.m_iCombatPowerShots;
	m_iCombatKnockbacks = other.m_iCombatKnockbacks;
	m_iCombatRepels = other.m_iCombatRepels;
	m_iExtraRoundStunProb = other.m_iExtraRoundStunProb;
	m_iCombatStuns = other.m_iCombatStuns;
	m_iExtraPoisonProbabilityModifier = other.m_iExtraPoisonProbabilityModifier;
	m_iRetrainsAvailable = other.m_iRetrainsAvailable;
	m_iQualityBaseTotal = other.m_iQualityBaseTotal;
	m_iGroupBaseTotal = other.m_iGroupBaseTotal;
	m_iSizeBaseTotal = other.m_iSizeBaseTotal;
	m_iExtraQuality = other.m_iExtraQuality;
	m_iExtraGroup = other.m_iExtraGroup;
	m_iExtraSize = other.m_iExtraSize;
	m_iSMCargoVolume = other.m_iSMCargoVolume;
	m_iSMExtraCargoVolume = other.m_iSMExtraCargoVolume;
	m_iSMCargoVolumeModifier = other.m_iSMCargoVolumeModifier;
	m_iCannotMergeSplitCount = other.m_iCannotMergeSplitCount;
	m_iExtraCaptureProbabilityModifier = other.m_iExtraCaptureProbabilityModifier;
	m_iExtraCaptureResistanceModifier = other.m_iExtraCaptureResistanceModifier;
	m_iExtraBreakdownChance = other.m_iExtraBreakdownChance;
	m_iExtraBreakdownDamage = other.m_iExtraBreakdownDamage;
	m_iExtraTaunt = other.m_iExtraTaunt;
	m_iExtraCombatModifierPerSizeMore = other.m_iExtraCombatModifierPerSizeMore;
	m_iExtraCombatModifierPerSizeLess = other.m_iExtraCombatModifierPerSizeLess;
	m_iExtraCombatModifierPerVolumeMore = other.m_iExtraCombatModifierPerVolumeMore;
	m_iExtraCombatModifierPerVolumeLess = other.m_iExtraCombatModifierPerVolumeLess;
	m_iExtraMaxHP = other.m_iExtraMaxHP;
	m_iExtraStrengthModifier = other.m_iExtraStrengthModifier;
	m_iExtraDamageModifier = other.m_iExtraDamageModifier;
	m_iExtraUpkeep100 = other.m_iExtraUpkeep100;
	m_iUpkeepModifier = other.m_iUpkeepModifier;
	m_iUpkeepMultiplierSM = other.m_iUpkeepMultiplierSM;
	m_iUpkeep100 = other.m_iUpkeep100;
	m_iSMAssetValue = other.m_iSMAssetValue;
	m_iSMPowerValue = other.m_iSMPowerValue;
	m_iSMHPValue = other.m_iSMHPValue;
	m_iExtraRBombardDamage = other.m_iExtraRBombardDamage;
	m_iExtraRBombardDamageLimit = other.m_iExtraRBombardDamageLimit;
	m_iExtraRBombardDamageMaxUnits = other.m_iExtraRBombardDamageMaxUnits;
	m_iExtraDCMBombRange = other.m_iExtraDCMBombRange;
	m_iExtraDCMBombAccuracy = other.m_iExtraDCMBombAccuracy;
	m_iBaseRBombardDamage = other.m_iBaseRBombardDamage;
	m_iBaseRBombardDamageLimit = other.m_iBaseRBombardDamageLimit;
	m_iBaseRBombardDamageMaxUnits = other.m_iBaseRBombardDamageMaxUnits;
	m_iBaseDCMBombRange = other.m_iBaseDCMBombRange;
	m_iBaseDCMBombAccuracy = other.m_iBaseDCMBombAccuracy;
	m_iBombardDirectCount = other.m_iBombardDirectCount;
	m_iExtraCollateralDamage = other.m_iExtraCollateralDamage;
	m_iExtraBombardRate = other.m_iExtraBombardRate;
	m_iSMBombardRate = other.m_iSMBombardRate;
	m_iSMAirBombBaseRate = other.m_iSMAirBombBaseRate;
	m_iSMBaseWorkRate = other.m_iSMBaseWorkRate;
	m_iSMRevoltProtection = other.m_iSMRevoltProtection;
	m_iExtraEnemyHeal = other.m_iExtraEnemyHeal;
	m_iExtraNeutralHeal = other.m_iExtraNeutralHeal;
	m_iExtraFriendlyHeal = other.m_iExtraFriendlyHeal;
	m_iSameTileHeal = other.m_iSameTileHeal;
	m_iAdjacentTileHeal = other.m_iAdjacentTileHeal;
	m_iExtraCombatPercent = other.m_iExtraCombatPercent;
	m_iExtraCityAttackPercent = other.m_iExtraCityAttackPercent;
	m_iExtraCityDefensePercent = other.m_iExtraCityDefensePercent;
	m_iExtraHillsAttackPercent = other.m_iExtraHillsAttackPercent;
	m_iExtraHillsDefensePercent = other.m_iExtraHillsDefensePercent;
	m_iRevoltProtection = other.m_iRevoltProtection;
	m_iCollateralDamageProtection = other.m_iCollateralDamageProtection;
	m_iPillageChange = other.m_iPillageChange;
	m_iUpgradeDiscount = other.m_iUpgradeDiscount;
	m_iExperiencePercent = other.m_iExperiencePercent;
	m_iKamikazePercent = other.m_iKamikazePercent;
	m_eFacingDirection = other.m_eFacingDirection;
	m_iImmobileTimer = other.m_iImmobileTimer;
	m_bCanRespawn = other.m_bCanRespawn;
	m_bSurvivor = other.m_bSurvivor;
	m_bMadeAttack = other.m_bMadeAttack;
	m_iRoundCount = other.m_iRoundCount;
	m_iAttackCount = other.m_iAttackCount;
	m_iDefenseCount = other.m_iDefenseCount;
	m_bMadeInterception = other.m_bMadeInterception;
	m_bPromotionReady = other.m_bPromotionReady;
	m_bDeathDelay = other.m_bDeathDelay;
	m_bInfoBarDirty = other.m_bInfoBarDirty;
	m_bBlockading = other.m_bBlockading;
	m_bAirCombat = other.m_bAirCombat;
	m_bHasBuildUp = other.m_bHasBuildUp;
	m_bInhibitMerge = other.m_bInhibitMerge;
	m_bInhibitSplit = other.m_bInhibitSplit;
	m_bIsBuildUp = other.m_bIsBuildUp;
	m_bIsReligionLocked = other.m_bIsReligionLocked;
	m_iCanMovePeaksCount = other.m_iCanMovePeaksCount;
	m_iCanLeadThroughPeaksCount = other.m_iCanLeadThroughPeaksCount;
	m_movementCharacteristicsHash = other.m_movementCharacteristicsHash;
	m_iSleepTimer = other.m_iSleepTimer;
	m_iCommanderID = other.m_iCommanderID;
	m_iCommodoreID = other.m_iCommodoreID;
	m_iUsedCommanderID = other.m_iUsedCommanderID;
	m_iUsedCommodoreID = other.m_iUsedCommodoreID;
	m_eOriginalOwner = other.m_eOriginalOwner;
	m_eNewDomainCargo = other.m_eNewDomainCargo;
	m_eNewSpecialCargo = other.m_eNewSpecialCargo;
	m_eNewSMNotSpecialCargo = other.m_eNewSMNotSpecialCargo;
	m_eSpecialUnit = other.m_eSpecialUnit;
	m_eSleepType = other.m_eSleepType;
	m_iZoneOfControlCount = other.m_iZoneOfControlCount;
	m_iExcileCount = other.m_iExcileCount;
	m_iPassageCount = other.m_iPassageCount;
	m_iNoNonOwnedCityEntryCount = other.m_iNoNonOwnedCityEntryCount;
	m_iBarbCoExistCount = other.m_iBarbCoExistCount;
	m_iBlendIntoCityCount = other.m_iBlendIntoCityCount;
	m_iUpgradeAnywhereCount = other.m_iUpgradeAnywhereCount;
	m_bAutoPromoting = other.m_bAutoPromoting;
	m_bAutoUpgrading = other.m_bAutoUpgrading;
	m_iHiddenNationalityCount = other.m_iHiddenNationalityCount;
	m_bHasHNCapturePromotion = other.m_bHasHNCapturePromotion;
	m_bHasAnyInvisibility = other.m_bHasAnyInvisibility;
	m_bRevealed = other.m_bRevealed;
	m_shadowUnit = other.m_shadowUnit;
	m_eOwner = other.m_eOwner;
	m_eCapturingPlayer = other.m_eCapturingPlayer;
	m_eUnitType = other.m_eUnitType;
	m_eReligionType = other.m_eReligionType;
	m_pUnitInfo = other.m_pUnitInfo;
	m_iBaseCombat = other.m_iBaseCombat;
	m_eLeaderUnitType = other.m_eLeaderUnitType;
	m_eGGExperienceEarnedTowardsType = other.m_eGGExperienceEarnedTowardsType;
	m_iCargoCapacity = other.m_iCargoCapacity;
	m_iSMCargoCapacity = other.m_iSMCargoCapacity;
	m_iExtraSelfHealModifier = other.m_iExtraSelfHealModifier;
	m_iExtraNumHealSupport = other.m_iExtraNumHealSupport;
	m_iHealSupportUsed = other.m_iHealSupportUsed;
	m_iExtraInsidiousness = other.m_iExtraInsidiousness;
	m_iExtraInvestigation = other.m_iExtraInvestigation;
	m_iNoSelfHealCount = other.m_iNoSelfHealCount;
	m_iDebugCount = other.m_iDebugCount;
	m_iAssassinCount = other.m_iAssassinCount;
	m_iExtraStealthStrikes = other.m_iExtraStealthStrikes;
	m_iExtraStealthCombatModifier = other.m_iExtraStealthCombatModifier;
	m_iStealthDefenseCount = other.m_iStealthDefenseCount;
	m_iOnlyDefensiveCount = other.m_iOnlyDefensiveCount;
	m_iNoInvisibilityCount = other.m_iNoInvisibilityCount;
	m_iNoCaptureCount = other.m_iNoCaptureCount;
	m_iExtraTrapDamageMax = other.m_iExtraTrapDamageMax;
	m_iExtraTrapDamageMin = other.m_iExtraTrapDamageMin;
	m_iExtraTrapComplexity = other.m_iExtraTrapComplexity;
	m_iExtraNumTriggers = other.m_iExtraNumTriggers;
	m_iNumTimesTriggered = other.m_iNumTimesTriggered;
	m_iTriggerBeforeAttackCount = other.m_iTriggerBeforeAttackCount;
	m_iExtraNoDefensiveBonusCount = other.m_iExtraNoDefensiveBonusCount;
	m_iExtraGatherHerdCount = other.m_iExtraGatherHerdCount;
	m_bIsArmed = other.m_bIsArmed;
	m_eCurrentBuildUpType = other.m_eCurrentBuildUpType;
	m_eCapturingUnit = other.m_eCapturingUnit;
	m_combatUnit = other.m_combatUnit;
	m_transportUnit = other.m_transportUnit;
#ifdef STRENGTH_IN_NUMBERS
	afIUnit = other.afIUnit;
	afIIUnit = other.afIIUnit;
	asrIUnit = other.asrIUnit;
	asrIIUnit = other.asrIIUnit;
	amrIUnit = other.amrIUnit;
	amrIIUnit = other.amrIIUnit;
	alrIUnit = other.alrIUnit;
	alrIIUnit = other.alrIIUnit;
	aflIUnit = other.aflIUnit;
	aflIIUnit = other.aflIIUnit;
	dfIUnit = other.dfIUnit;
	dfIIUnit = other.dfIIUnit;
	dsrIUnit = other.dsrIUnit;
	dsrIIUnit = other.dsrIIUnit;
	dmrIUnit = other.dmrIUnit;
	dmrIIUnit = other.dmrIIUnit;
	dlrIUnit = other.dlrIUnit;
	dlrIIUnit = other.dlrIIUnit;
	dflIUnit = other.dflIUnit;
	dflIIUnit = other.dflIIUnit;
#endif // STRENGTH_IN_NUMBERS

	m_aExtraInvisibleTerrains = other.m_aExtraInvisibleTerrains;
	m_aExtraInvisibleFeatures = other.m_aExtraInvisibleFeatures;
	m_aExtraInvisibleImprovements = other.m_aExtraInvisibleImprovements;
	m_aExtraVisibleTerrains = other.m_aExtraVisibleTerrains;
	m_aExtraVisibleFeatures = other.m_aExtraVisibleFeatures;
	m_aExtraVisibleImprovements = other.m_aExtraVisibleImprovements;
	m_aExtraVisibleTerrainRanges = other.m_aExtraVisibleTerrainRanges;
	m_aExtraVisibleFeatureRanges = other.m_aExtraVisibleFeatureRanges;
	m_aExtraVisibleImprovementRanges = other.m_aExtraVisibleImprovementRanges;
	m_szName = other.m_szName;
	m_szScriptData = other.m_szScriptData;
	m_aExtraAidChanges = other.m_aExtraAidChanges;

	if (!other.m_promotionKeyedInfo.empty())
		m_promotionKeyedInfo = other.m_promotionKeyedInfo;

	if (!other.m_promotionLineKeyedInfo.empty())
		m_promotionLineKeyedInfo = other.m_promotionLineKeyedInfo;

	if (!other.m_terrainKeyedInfo.empty())
		m_terrainKeyedInfo = other.m_terrainKeyedInfo;

	if (!other.m_featureKeyedInfo.empty())
		m_featureKeyedInfo = other.m_featureKeyedInfo;

	if (!other.m_unitCombatKeyedInfo.empty())
		m_unitCombatKeyedInfo = other.m_unitCombatKeyedInfo;

	m_pPlayerInvestigated = other.m_pPlayerInvestigated;
	m_Properties = other.m_Properties;

	if (other.m_commander)
	{
		SAFE_DELETE(m_commander);
		m_commander = new UnitCompCommander(this, m_pUnitInfo);
		*m_commander = *other.m_commander;
	}
	if (other.m_commodore)
    {
    	SAFE_DELETE(m_commodore);
    	m_commodore = new UnitCompCommodore(this, m_pUnitInfo);
    	*m_commodore = *other.m_commodore;
    }
	if (other.m_worker)
	{
		SAFE_DELETE(m_worker);
		m_worker = new UnitCompWorker();
		*m_worker = *other.m_worker;
	}

	return *this;
}

//////////////////////////////////////
// graphical only setup
//////////////////////////////////////
void CvUnit::setupGraphical()
{
	PROFILE_FUNC();

	if (!GC.IsGraphicsInitialized() || !isInViewport())
	{
		return;
	}

	if (!isUsingDummyEntities())
	{
		CvDLLEntity::setup();
	}

	if (getGroup()->getActivityType() == ACTIVITY_INTERCEPT)
	{
		airCircle(true);
	}
	else
	{
		/* billw - This forces multi-unit graphics to update.
			If it isn't done then only 1 unit shows up, then the rest appear 10s or more later.
			I tried every other command on the CvDLLEntityIFaceBase to trigger update
			of these graphics (I didn't test every animation and mission type though),
			but only found this one that actually works.
		*/
		ExecuteMove(0, false);

		/* TEST CODE (billw 21/9/2019) >>>>>>
		// Anyone can remove this later if no problems show up with using ExecuteMode(0, false) above

		static int mode = 1;
		switch (mode)
		{
			case 0: ExecuteMove(0, false); break;
			case 1: SetPosition(plot()); break;
			case 2: {
				static AnimationTypes eAnim = NONE_ANIMATION;
				static float fSpeed = 1.0f;
				static bool bQueue = false;
				static int iLayer = 0;
				static float fStartPct = 0.0f;
				static float fEndPct = 1.0f;
				PlayAnimation(eAnim, fSpeed, bQueue, iLayer, fStartPct, fEndPct);
				break;
			};
			case 3: setVisible(true); break;
			case 4: setVisible(false); setVisible(true); break;
			case 5: gDLL->getEntityIFace()->updatePosition(getEntity()); break;
			case 6: MoveTo(plot()); break;
			case 7: QueueMove(plot()); break;
			case 8: {
				static MissionTypes eMission = NO_MISSION;
				NotifyEntity(eMission);
				break;
			}
			case 9: gDLL->getEntityIFace()->updateGraphicEra(getUnitEntity()); break;
			case 10: gDLL->getEntityIFace()->showPromotionGlow(getUnitEntity(), true); break;
			case 11: gDLL->getEntityIFace()->updateEnemyGlow(getUnitEntity()); break;
			case 12: gDLL->getEntityIFace()->updatePromotionLayers(getUnitEntity()); break;
			case 13: gDLL->getEntityIFace()->StopAnimation(getEntity()); break;
			default: break;
		};
		<<<<< TEST CODE */
	}
}


// Toffer - 04.04.20
// bKillOriginal is only used by worldbuilder at this time, when duplicating unit and changing unit owner.
// Reason is that delayed death does not happen before exiting worldbuilder, and
// it's messy to have a bunch of units on the map marked for death with no idea which ones that are marked.
// Also reduce the amount of code needed to process to duplicate a unit, as it doesn't have to call convert twice when keeping the original.
void CvUnit::convert(CvUnit* pUnit, const bool bKillOriginal)
{
	PROFILE_FUNC();

	setFortifyTurns(0);

	if (GC.getGame().isOption(GAMEOPTION_COMBAT_SIZE_MATTERS))
	{
		int iTotalGroupOffset = 0;
		int iTotalQualityOffset = 0;

		for (int iI = GC.getNumPromotionInfos() - 1; iI > -1; iI--)
		{
			const PromotionTypes ePromoX = static_cast<PromotionTypes>(iI);
			const CvPromotionInfo& kPromo = GC.getPromotionInfo(ePromoX);
			PromotionLineTypes eLine = kPromo.getPromotionLine();
			bool bIsBuildup = false;
			if (eLine != NO_PROMOTIONLINE)
			{
				const CvPromotionLineInfo& kLine = GC.getPromotionLineInfo(eLine);
				bIsBuildup = kLine.isBuildUp();
			}
			if (pUnit->isHasPromotion(ePromoX) && !bIsBuildup)
			{
				if (GC.getPromotionInfo(ePromoX).getGroupChange() != 0)
				{
					iTotalGroupOffset += GC.getPromotionInfo(ePromoX).getGroupChange();
				}
				else if (GC.getPromotionInfo(ePromoX).getQualityChange() != 0)
				{
					iTotalQualityOffset += GC.getPromotionInfo(ePromoX).getQualityChange();
				}
				else if (!isHasPromotion(ePromoX)) //see note below on this situation with true for bDying
				{
					setHasPromotion(ePromoX, true, pUnit->isPromotionFree(ePromoX), true);
				}
			}
		}

		const bool bNormalizedGroup = CvUnit::normalizeUnitPromotions(this, iTotalGroupOffset,
			bind(&CvUnit::isGroupUpgradePromotion, this, _2),
			bind(&CvUnit::isGroupDowngradePromotion, this, _2)
		);
		FAssertMsg(bNormalizedGroup, "Could not apply required number of group promotions on converted unit");

		const bool bNormalizedQuality = CvUnit::normalizeUnitPromotions(this, iTotalQualityOffset,
			bind(&CvUnit::isQualityUpgradePromotion, this, _2),
			bind(&CvUnit::isQualityDowngradePromotion, this, _2)
		);
		FAssertMsg(bNormalizedQuality, "Could not apply required number of quality promotions on converted unit");
	}
	else
	{
		for (int iI = GC.getNumPromotionInfos() - 1; iI > -1; iI--)
		{
			const PromotionTypes ePromoX = static_cast<PromotionTypes>(iI);

			if (pUnit->isHasPromotion(ePromoX) && !isHasPromotion(ePromoX))
			{
				// TB - bDying is set to true to temporarily avoid obsoletion checks until AFTER all promos are assigned
				// as sometimes promos would be lost because prereqs simply weren't assigned yet due to the order in which they were established.
				setHasPromotion(ePromoX, true, pUnit->isPromotionFree(ePromoX), true);
			}
		}
	}
	//TB Combat Mod end

	if (pUnit->getCityOfOrigin() != NULL)
	{
		setCityOfOrigin(pUnit->getCityOfOrigin());
	}
	setGameTurnCreated(pUnit->getGameTurnCreated());

	const int iCurrentHPCap = pUnit->getMaxHP()-1;
	setDamage(std::min(iCurrentHPCap, pUnit->getDamage()));
	//TB Combat Mod next line
	setColdDamage(std::min(iCurrentHPCap, pUnit->getColdDamage()));
	setMoves(pUnit->getMoves());
	setImmobileTimer(pUnit->getImmobileTimer());

	m_eOriginalOwner = pUnit->getOriginalOwner();
	m_eNewDomainCargo = pUnit->getDomainCargo();
	m_eNewSpecialCargo = pUnit->getSpecialCargo();
	m_eNewSMNotSpecialCargo = pUnit->getSMNotSpecialCargo();
	m_eSpecialUnit = pUnit->getSpecialUnitType();
	m_eSleepType = NO_MISSION;
	m_iHiddenNationalityCount = pUnit->getHiddenNationalityCount();
	setAutoPromoting(pUnit->isAutoPromoting());
	setAutoUpgrading(pUnit->isAutoUpgrading());
	m_eCurrentBuildUpType = NO_PROMOTIONLINE;

	setLevel(pUnit->getLevel());
	const int iOldModifier = std::max(1, 100 + GET_PLAYER(pUnit->getOwner()).getLevelExperienceModifier());
	const int iOurModifier = std::max(1, 100 + GET_PLAYER(getOwner()).getLevelExperienceModifier());
	setExperience(std::max(0, pUnit->getExperience() * iOurModifier / iOldModifier));

	setName(pUnit->getNameNoDesc());

	if (pUnit->isDescInName() && getBugOptionBOOL("MiscHover__UpdateUnitNameOnUpgrade", true, "BUG_UPDATE_UNIT_NAME_ON_UPGRADE"))
	{
		CvWString szUnitType(pUnit->getDescription());

		m_szName.replace(m_szName.find(szUnitType), szUnitType.length(), getDescription());
	}

	if (pUnit->getLeaderUnitType() != NO_UNIT)
	{
		setLeaderUnitType(pUnit->getLeaderUnitType());
	}

	if (GC.getGame().isOption(GAMEOPTION_COMBAT_HIDE_SEEK))
	{
		setHasAnyInvisibility();
	}

	CvUnit* pTransportUnit = pUnit->getTransportUnit();
	if (pTransportUnit != NULL)
	{
		pUnit->setTransportUnit(NULL);
		setTransportUnit(pTransportUnit);
	}

	std::vector<CvUnit*> aCargoUnits;
	pUnit->getCargoUnits(aCargoUnits);
	pUnit->validateCargoUnits();
	foreach_(CvUnit* pCargo, aCargoUnits)
	{
		// Check cargo types and capacity when upgrading transports
		if (GC.getGame().isOption(GAMEOPTION_COMBAT_SIZE_MATTERS))
		{
			if (cargoSpaceAvailable(pCargo->getSpecialUnitType(), pCargo->getDomainType()) > pCargo->getCargoVolume())
			{
				pCargo->setTransportUnit(NULL);
				pCargo->setTransportUnit(this);
			}
			else
			{
				pCargo->setTransportUnit(NULL);
				pCargo->jumpToNearestValidPlot();
			}
		}
		else if (cargoSpaceAvailable(pCargo->getSpecialUnitType(), pCargo->getDomainType()) > 0)
		{
			pCargo->setTransportUnit(NULL);
			pCargo->setTransportUnit(this);
		}
		else
		{
			pCargo->setTransportUnit(NULL);
			pCargo->jumpToNearestValidPlot();
		}
	}
	validateCargoUnits();

	if (bKillOriginal)
	{
		pUnit->getGroup()->AI_setMissionAI(MISSIONAI_DELIBERATE_KILL, NULL, NULL);
		pUnit->kill(true);
	}
}


void CvUnit::kill(bool bDelay, PlayerTypes ePlayer, bool bMessaged)
{
	// If it's already dead (but delayed death in process) don't try to re-kill it.
	if (bDelay && m_bDeathDelay)
	{
		return;
	}
	killUnconditional(bDelay, ePlayer, bMessaged);
}

void CvUnit::killUnconditional(bool bDelay, PlayerTypes ePlayer, bool bMessaged)
{
	PROFILE_FUNC();

	deselect(!bDelay);

	/* Toffer - Evaluate if double messaging actually take place...
	if (m_combatResult.bDeathMessaged)
	{
		bMessaged = true;
	}
	*/
	const PlayerTypes eOwner = getOwner();
	CvPlayerAI& owner = GET_PLAYER(eOwner);

	CvPlot* pPlot = plot();

	if (pPlot)
	{
		if (hasCargo())
		{
			foreach_(CvUnit* unitX, pPlot->units())
			{
				if (unitX == this || unitX->getTransportUnit() != this)
				{
					continue;
				}
				if (unitX->isDelayedDeath())
				{
					// Should mean that we are on the second kill pass of transporting unit (this),
					// i.e. this cargo unit (unitX) already failed to survive on the first kill pass where bDelay=True.
					FAssertMsg(!bDelay, "bDelay should in theory always be false here... I think");
					unitX->kill(bDelay, NO_PLAYER, true);
					continue;
				}

				/* Toffer ToDo - revise
				if (getCaptureUnitType() != NO_UNIT && getCapturingPlayer() != NO_PLAYER
				&& unitX->getCaptureUnitType() != NO_UNIT && !GET_PLAYER(getCapturingPlayer()).isNPC()
				&& GC.getGame().getSorenRandNum(2, "50% prefer safe capture over deadly escape.") == 0)
				{
					unitX->setCapturingPlayer(getCapturingPlayer());
					unitX->setCapturingUnit(getCapturingUnit());
					unitX->kill(bDelay, ePlayer, bMessaged);
					continue;
				}
				*/
				if (GC.getGame().getSorenRandNum(pPlot->isWater() ? 5 : 2, "Unit Survives Drowning") == 0)
				{
					bool bSurvived = false;
					std::vector<const CvPlot*> validPlots;

					foreach_(const CvPlot* pAdjacentPlot, plot()->adjacent())
					{
						if (unitX->canMoveThrough(pAdjacentPlot, false))
						{
							validPlots.push_back(pAdjacentPlot);
							bSurvived = true;
						}
					}
					if (bSurvived)
					{
						const CvPlot* rescuePlot = validPlots[GC.getGame().getSorenRandNum(validPlots.size(), "Event pick plot")];

						FAssertMsg(rescuePlot, "rescuePlot is expected to be a valid plot!");
						unitX->setXY(rescuePlot->getX(), rescuePlot->getY());
						unitX->setDamage(GC.getGame().getSorenRandNum(std::min(unitX->getMaxHP() * 2/3, unitX->getHP()), "Survival Damage"), NO_PLAYER);
						AddDLLMessage(
							unitX->getOwner(), false, GC.getEVENT_MESSAGE_TIME(),
							gDLL->getText("TXT_KEY_MISC_UNIT_SURVIVED_TRANSPORT_SINKING", unitX->getNameKey(), getNameKey()),
							NULL, MESSAGE_TYPE_MINOR_EVENT
						);
						continue;
					}
				}
				AddDLLMessage(
					eOwner, true, GC.getEVENT_MESSAGE_TIME(),
					gDLL->getText("TXT_KEY_MISC_UNIT_DROWNED", unitX->getNameKey()),
					GC.getEraInfo(GC.getGame().getCurrentEra()).getAudioUnitDefeatScript(),
					MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_RED(), getX(), getY()
				);
				unitX->kill(bDelay, ePlayer, true);
			}
		}

		if (ePlayer != NO_PLAYER)
		{
			CvEventReporter::getInstance().unitKilled(this, ePlayer);

			if (NO_UNIT != getLeaderUnitType() || GC.getUnitInfo(getUnitType()).getMaxGlobalInstances() == 1)
			{
				for (int iI = 0; iI < MAX_PC_PLAYERS; iI++)
				{
					if (GET_PLAYER((PlayerTypes)iI).isAlive())
					{
						AddDLLMessage(
							(PlayerTypes)iI, true, GC.getEVENT_MESSAGE_TIME(),
							gDLL->getText("TXT_KEY_MISC_GENERAL_KILLED", getNameKey()),
							GC.getEraInfo(GC.getGame().getCurrentEra()).getAudioUnitDefeatScript(),
							MESSAGE_TYPE_MAJOR_EVENT, NULL, GC.getCOLOR_RED(), getX(), getY()
						);
					}
				}
			}
		}

		if (isWorker())
		{
			CvCity* city = owner.getCity(m_worker->getAssignedCity());
			if (city)
			{
				OutputDebugString(CvString::format("Worker at (%d,%d) killed with mission for city %S\n", getX(), getY(), city->getName().GetCString()).c_str());
				city->setWorkerHave(getID(), false);
			}
		}

		if (bDelay)
		{
			m_bDeathDelay = true;
			return;
		}
		{
			const CvCity* pCapitalCity = owner.getCapitalCity();
			if (pCapitalCity)
			{
				if (isCanRespawn() && pCapitalCity->plot() != plot())
				{
					//GC.getGame().logOOSSpecial(14, getID(), pCapitalCity->getX(), pCapitalCity->getY());
					setXY(pCapitalCity->getX(), pCapitalCity->getY(), false, false, false);
					setDamage(getMaxHP() * 9/10);
					changeOneUpCount(-1);
					AddDLLMessage(
						eOwner, true, GC.getEVENT_MESSAGE_TIME(),
						gDLL->getText("TXT_KEY_MISC_BATTLEFIELD_EVAC", getNameKey()),
						"AS2D_POSITIVE_DINK", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_GREEN(), getX(), getY()
					);
					m_bDeathDelay = false;
					return;
				}
				if (isSurvivor())
				{
					setDamage(getMaxHP() - std::max(1,(getSurvivorChance() / 1000)));
					AddDLLMessage(
						eOwner, true, GC.getEVENT_MESSAGE_TIME(),
						gDLL->getText("TXT_KEY_MISC_YOUR_UNIT_IS_HARDCORE", getNameKey()),
						"AS2D_POSITIVE_DINK", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_GREEN(), getX(), getY()
					);
					m_bDeathDelay = false;
					//	Only applies to THIS combat - it might be attacked again the same turn
					setSurvivor(false);
					return;
				}
			}
		}
		if (isMadeAttack() && nukeRange() != -1)
		{
			CvPlot* pTarget = getAttackPlot();
			if (pTarget)
			{
				pTarget->nukeExplosion(nukeRange(), this);
				setAttackPlot(NULL, false);
			}
		}
		finishMoves();
		m_iDamage = getMaxHP(); // Toffer - Makes isDead() True

		// XXX this is NOT a hack, without it, the game crashes.
		if (!isUsingDummyEntities() && isInViewport())
		{
			gDLL->getEntityIFace()->RemoveUnitFromBattle(this);
		}

		FAssertMsg(!isCombat(), "isCombat did not return false as expected");

		if (getTransportUnit())
		{
			setTransportUnit(NULL);
		}
		setReconPlot(NULL);
		setBlockading(false);
		/*
		if (isZoneOfControl())
		{
			foreach_(CvPlot* pAdjacentPlot, plot()->adjacent())
			{
				pAdjacentPlot->clearZoneOfControlCache();
			}
		}
		*/
		FAssertMsg(!getAttackPlot(), "The current unit instance's attack plot is expected to be NULL");
		FAssertMsg(!getCombatUnit(), "The current unit instance's combat unit is expected to be NULL");
	}

	owner.changeUnitUpkeep(-getUpkeep100(), isMilitaryBranch());

	owner.changeUnitCount(m_eUnitType, -1);
	if (GC.getGame().isOption(GAMEOPTION_COMBAT_SIZE_MATTERS)
	// if unit doesn't have a group rank, it doesn't count as a SM unit at all
	&& groupRank() > 0)
	{
		owner.changeUnitCountSM(m_eUnitType, -intPow(3, groupRank()-1));
	}

	if (m_pUnitInfo->getNukeRange() != -1)
	{
		owner.changeNumNukeUnits(-1);
	}

	if (isMilitaryBranch())
	{
		owner.changeNumMilitaryUnits(-1);
	}

	owner.changeAssets(-assetValueTotal());
	owner.changeUnitPower(-getPowerValueTotal());

	if (pPlot)
	{
		OutputDebugString(CvString::format("Unit %S of player %S killed\n", getName().GetCString(), owner.getCivilizationDescription(0)).c_str());

		owner.AI_changeNumAIUnits(AI_getUnitAIType(), -1);
		AI_killed(); // Update AI counts for this unit

		setCommander(false);
		setCommodore(false);
		setXY(INVALID_PLOT_COORD, INVALID_PLOT_COORD, true);
		joinGroup(NULL, false, false);

		const PlayerTypes eCapturingPlayer = getCapturingPlayer();
		const UnitTypes eCaptureUnitType = getCaptureUnitType();

		if (eCapturingPlayer != NO_PLAYER && eCaptureUnitType != NO_UNIT && !GET_PLAYER(eCapturingPlayer).isNPC())
		{
			CvUnit* pkCapturedUnit = (
				GET_PLAYER(eCapturingPlayer).initUnit(
					eCaptureUnitType, pPlot->getX(), pPlot->getY(),
					NO_UNITAI, NO_DIRECTION,
					GC.getGame().getSorenRandNum(10000, "AI Unit Birthmark")
				)
			);
			if (pkCapturedUnit)
			{
				CvEventReporter::getInstance().unitCaptured(eOwner, getUnitType(), pkCapturedUnit);

				if (getCapturingUnit() && getCapturingUnit()->isHiddenNationality())
				{
					pkCapturedUnit->doHNCapture();
				}
				AddDLLMessage(
					eCapturingPlayer, true, GC.getEVENT_MESSAGE_TIME(),
					gDLL->getText("TXT_KEY_MISC_YOU_CAPTURED_UNIT", GC.getUnitInfo(eCaptureUnitType).getTextKeyWide()),
					"AS2D_UNITCAPTURE", MESSAGE_TYPE_INFO, pkCapturedUnit->getButton(), GC.getCOLOR_GREEN(), pPlot->getX(), pPlot->getY()
				);
				// Add a captured mission
				addMission(CvMissionDefinition(MISSION_CAPTURED, pPlot, pkCapturedUnit));

				pkCapturedUnit->finishMoves();

				if (!GET_PLAYER(eCapturingPlayer).isHumanPlayer())
				{
					pPlot = pkCapturedUnit->plot();
					if (pPlot && !pPlot->isCity(false)
					&& GC.getDefineINT("AI_CAN_DISBAND_UNITS") && GET_PLAYER(eCapturingPlayer).AI_getPlotDanger(pPlot))
					{
						pkCapturedUnit->kill(false, NO_PLAYER, true);
					}
				}
			}
		}
		owner.deleteUnit(getID());
	}
}


void CvUnit::NotifyEntity(MissionTypes eMission)
{
	if ( !isUsingDummyEntities() && isInViewport() )
	{
		gDLL->getEntityIFace()->NotifyEntity(getUnitEntity(), eMission);
	}
}


void CvUnit::doTurn()
{
	PROFILE("CvUnit::doTurn()");

	FAssertMsg(!isDead(), "isDead did not return false as expected");
	FAssertMsg(getGroup() != NULL, "getGroup() is not expected to be equal with NULL");

	if (isCommander())
	{
		m_commander->restoreControlPoints();
	}
    if (isCommodore())
	{
		m_commodore->restoreControlPoints();
	}
	gDLL->getInterfaceIFace()->setDirty(InfoPane_DIRTY_BIT, true);

	m_bRevealed = false;
	if (m_bHasHNCapturePromotion && getOwner() == plot()->getOwner())
	{
		removeHNCapturePromotion();
	}

	if (getInsidiousnessTotal(true) > 0)
	{
		if (plot()->isCity(false))
		{
			doInsidiousnessVSInvestigationCheck();
		}
		else if (m_pPlayerInvestigated != NO_PLAYER)
		{
			doRemoveInvestigatedPromotionCheck();
		}
	}

	testPromotionReady();
	if (isBlockading())
	{
		collectBlockadeGold();
	}

	if (isSpy() && isIntruding() && !isCargo())
	{
		const TeamTypes eTeam = plot()->getTeam();

		if (NO_TEAM != eTeam)
		{
			if (GET_TEAM(getTeam()).isOpenBorders(eTeam))
			{
				testSpyIntercepted(plot()->getOwner(), GC.getDefineINT("ESPIONAGE_SPY_NO_INTRUDE_INTERCEPT_MOD"));
			}
			else
			{
				testSpyIntercepted(plot()->getOwner(), GC.getDefineINT("ESPIONAGE_SPY_INTERCEPT_MOD"));
			}
		}
	}

	if (baseCombatStr() > 0)
	{
		if (plot()->getFeatureTurnDamage() != 0)
		{
			changeDamagePercent(plot()->getFeatureTurnDamage(), NO_PLAYER);
			//Calvitix, Terrain Damage gives XP
			if (isHurt() && plot()->getTerrainType() != NO_TERRAIN)
			{
				changeExperience100(4, 2000);
			}
		}

		if (plot()->getTerrainTurnDamage(this) != 0)
		{
			changeDamagePercent(plot()->getTerrainTurnDamage(this), NO_PLAYER);
			//TB Combat Mod
			if (GC.getTerrainInfo(plot()->getTerrainType()).isColdDamage())
			{
				changeColdDamage(plot()->getTerrainTurnDamage(this));
			}
			//TB Combat Mod
			//Calvitix, Terrain Damage gives XP
			if (isHurt() && plot()->getTerrainType() != NO_TERRAIN)
			{
				changeExperience100(2,2500);
			}
		}
	}

	const bool bHasMoved = hasMoved();
	const bool bHeal = ((bHasMoved && isAlwaysHeal()) || !bHasMoved);

#ifdef OUTBREAKS_AND_AFFLICTIONS
	if (GC.getGame().isOption(GAMEOPTION_COMBAT_OUTBREAKS_AND_AFFLICTIONS))
	{
		doAffliction(bHeal);
	}
#endif

	if (bHeal && isHurt())
	{
		doHeal();
	}

	if (!bHasMoved)
	{
		setFortifyTurns(getFortifyTurns() + 1);

		if (isBuildUp())
		{
			incrementBuildUp();
		}
	}

	if (isCanRespawn())
	{
		setCanRespawn(false);
	}

	if (isSurvivor())
	{
		setSurvivor(false);
	}

	if (isSpy() && m_iSleepTimer > 0 && getFortifyTurns() == GC.getMAX_FORTIFY_TURNS())
	{
		getGroup()->setActivityType(ACTIVITY_AWAKE);
		m_iSleepTimer = 0;
	}

	changeImmobileTimer(-1);
	//TB Combat Mods (Att&DefCounter)
	if (getAttackCount()>0)
	{
		int AttackCountResetVal = -(getAttackCount());
		changeAttackCount(AttackCountResetVal);
	}
	if (getDefenseCount()>0)
	{
		int DefenseCountResetVal = -(getDefenseCount());
		changeDefenseCount(DefenseCountResetVal);
	}
	//TB Combat Mods (Att&DefCounter) end

	setMadeAttack(false);
	setMadeInterception(false);

	setReconPlot(NULL);

	if (isExcile() && (plot()->getOwner() == getOwner() || plot()->getOwner() == getOriginalOwner()))
	{
		jumpToNearestValidPlot(false);
	}
	setMoves(0);
}


void CvUnit::updateAirStrike(CvPlot* pPlot, bool bFinish)
{
	if (!bFinish)
	{
		if (isInBattle())
		{
			return;
		}

		if (canNuke())
		{
			kill(true, NO_PLAYER, true);
			return;
		}

		if (airStrike(pPlot) && pPlot->isVisibleToWatchingHuman())
		{
			setCombatTimer(GC.getMissionInfo(MISSION_AIRSTRIKE).getTime());
			GC.getGame().incrementTurnTimer(getCombatTimer());

			addMission(CvAirMissionDefinition(MISSION_AIRSTRIKE, pPlot, this, NULL, getCombatTimer() * gDLL->getSecsPerTurn()));

			return;
		}
	}

	CvUnit *pDefender = getCombatUnit();
	if (pDefender)
	{
		pDefender->setCombatUnit(NULL);
	}
	setCombatUnit(NULL);
	setAttackPlot(NULL, false);

	if (isSuicide() && !isDead())
	{
		kill(true);
	}
}

void CvUnit::resolveAirCombat(CvUnit* pInterceptor, CvPlot* pPlot, CvAirMissionDefinition& kBattle)
{
	PROFILE_EXTRA_FUNC();
	CvWString szBuffer;

	int iTheirStrength = (DOMAIN_AIR == pInterceptor->getDomainType() ? pInterceptor->airCurrCombatStr(this) : pInterceptor->currCombatStr(NULL, NULL));
	int iOurStrength = (DOMAIN_AIR == getDomainType() ? airCurrCombatStr(pInterceptor) : currCombatStr(NULL, NULL));
	int iTotalStrength = iOurStrength + iTheirStrength;
	if (0 == iTotalStrength)
	{
		FErrorMsg("error");
		return;
	}

/********************************************************************************/
/* 	BETTER_BTS_AI_MOD						10/19/08	Roland J & jdog5000	*/
/* 																			*/
/* 	Combat mechanics														*/
/********************************************************************************/
	/*
	int iOurOdds = (100 * iOurStrength) / std::max(1, iTotalStrength);

	int iOurRoundDamage = (pInterceptor->currInterceptionProbability() * GC.getDefineINT("MAX_INTERCEPTION_DAMAGE")) / 100;
	int iTheirRoundDamage = (currInterceptionProbability() * GC.getDefineINT("MAX_INTERCEPTION_DAMAGE")) / 100;
	if (getDomainType() == DOMAIN_AIR)
	{
		iTheirRoundDamage = std::max(GC.getDefineINT("MIN_INTERCEPTION_DAMAGE"), iTheirRoundDamage);
	}

	//original BTS code
	int iTheirDamage = 0;
	int iOurDamage = 0;

	for (int iRound = 0; iRound < GC.getDefineINT("INTERCEPTION_MAX_ROUNDS"); ++iRound)
	*/
	// For air v air, more rounds and factor in strength for per round damage
	int iOurOdds = (100 * iOurStrength) / std::max(1, iTotalStrength);
	int iMaxRounds = 0;
	int iOurRoundDamage = 0;
	int iTheirRoundDamage = 0;

	// Air v air is more like standard combat
	// Round damage in this case will now depend on strength and interception probability
	if( GC.getBBAI_AIR_COMBAT() && (DOMAIN_AIR == pInterceptor->getDomainType() && DOMAIN_AIR == getDomainType()) )
	{
		int iBaseDamage = GC.getDefineINT("AIR_COMBAT_DAMAGE");
		int iOurFirepower = ((airMaxCombatStr(pInterceptor) + iOurStrength + 1) / 2);
		int iTheirFirepower = ((pInterceptor->airMaxCombatStr(this) + iTheirStrength + 1) / 2);

		int iStrengthFactor = ((iOurFirepower + iTheirFirepower + 1) / 2);

		int iTheirInterception = std::max(pInterceptor->maxInterceptionProbability(),2*GC.getDefineINT("MIN_INTERCEPTION_DAMAGE"));
		int iOurInterception = std::max(maxInterceptionProbability(),2*GC.getDefineINT("MIN_INTERCEPTION_DAMAGE"));

		iOurRoundDamage = std::max(1, ((iBaseDamage * (iTheirFirepower + iStrengthFactor) * iTheirInterception) / ((iOurFirepower + iStrengthFactor) * 100)));
		iTheirRoundDamage = std::max(1, ((iBaseDamage * (iOurFirepower + iStrengthFactor) * iOurInterception) / ((iTheirFirepower + iStrengthFactor) * 100)));

		iMaxRounds = 2*GC.getDefineINT("INTERCEPTION_MAX_ROUNDS") - 1;
	}
	else
	{
		iOurRoundDamage = (pInterceptor->currInterceptionProbability() * GC.getDefineINT("MAX_INTERCEPTION_DAMAGE")) / 100;
		iTheirRoundDamage = (currInterceptionProbability() * GC.getDefineINT("MAX_INTERCEPTION_DAMAGE")) / 100;
		if (getDomainType() == DOMAIN_AIR)
		{
			iTheirRoundDamage = std::max(GC.getDefineINT("MIN_INTERCEPTION_DAMAGE"), iTheirRoundDamage);
		}

		iMaxRounds = GC.getDefineINT("INTERCEPTION_MAX_ROUNDS");
	}

	int iTheirDamage = 0;
	int iOurDamage = 0;

	for (int iRound = 0; iRound < iMaxRounds; ++iRound)
/********************************************************************************/
/* 	BETTER_BTS_AI_MOD						END								*/
/********************************************************************************/
	{
		if (GC.getGame().getSorenRandNum(100, "Air combat") < iOurOdds)
		{
			if (DOMAIN_AIR == pInterceptor->getDomainType())
			{
				iTheirDamage += iTheirRoundDamage;
				pInterceptor->changeDamage(iTheirRoundDamage, getOwner());
				//TB Combat Mod begin
				if (dealsColdDamage())
				{
					pInterceptor->changeColdDamage(iTheirRoundDamage);
				}
				//TB Combat Mod end
				if (pInterceptor->isDead())
				{
					break;
				}
#ifdef OUTBREAKS_AND_AFFLICTIONS
				//here we go with afflict on attack
				if (GC.getGame().isOption(GAMEOPTION_COMBAT_OUTBREAKS_AND_AFFLICTIONS))
				{
					for (int iI = 0; iI < GC.getNumPromotionLineInfos(); iI++)
					{
						if (GC.getPromotionLineInfo((PromotionLineTypes)iI).isAffliction() && !GC.getPromotionLineInfo((PromotionLineTypes)iI).isCritical())
						{
							PromotionLineTypes eAfflictionLine = ((PromotionLineTypes)iI);
							if (hasAfflictOnAttackType(eAfflictionLine) && isAfflictOnAttackTypeDistance(eAfflictionLine))
							{
								int iAttackersPoisonChance = getAfflictOnAttackTypeProbability(eAfflictionLine) - pInterceptor->fortitudeTotal() - pInterceptor->getUnitAfflictionTolerance(eAfflictionLine);

								if (GC.getGame().getSorenRandNum(100, "AttackersPoisonRoll") < iAttackersPoisonChance)
								{
									pInterceptor->afflict(eAfflictionLine, true, this);
								}
							}
						}
					}
				}
#endif // OUTBREAKS_AND_AFFLICTIONS
			}
		}
		else
		{
			iOurDamage += iOurRoundDamage;
			changeDamage(iOurRoundDamage, pInterceptor->getOwner());
			//TB Combat Mod begin
			if (pInterceptor->dealsColdDamage())
			{
				changeColdDamage(iOurRoundDamage);
			}
			//TB Combat Mod end
			if (isDead())
			{
				break;
			}
#ifdef OUTBREAKS_AND_AFFLICTIONS
			if (GC.getGame().isOption(GAMEOPTION_COMBAT_OUTBREAKS_AND_AFFLICTIONS))
			{
				for (int iI = 0; iI < GC.getNumPromotionLineInfos(); iI++)
				{
					if (GC.getPromotionLineInfo((PromotionLineTypes)iI).isAffliction() && !GC.getPromotionLineInfo((PromotionLineTypes)iI).isCritical())
					{
						PromotionLineTypes eAfflictionLine = ((PromotionLineTypes)iI);
						if (pInterceptor->hasAfflictOnAttackType(eAfflictionLine) && pInterceptor->isAfflictOnAttackTypeDistance(eAfflictionLine))
						{
							int iAttackersPoisonChance = pInterceptor->getAfflictOnAttackTypeProbability(eAfflictionLine) - fortitudeTotal() - getUnitAfflictionTolerance(eAfflictionLine);

							if (GC.getGame().getSorenRandNum(100, "AttackersPoisonRoll") < iAttackersPoisonChance)
							{
								afflict(eAfflictionLine, true, pInterceptor);
							}
						}
					}
				}
			}
#endif // OUTBREAKS_AND_AFFLICTIONS
		}
	}

	if (isDead())
	{
		if (iTheirRoundDamage > 0)
		{
			int iExperience = pInterceptor->defenseXPValue();
			iExperience = (iExperience * iOurStrength) / std::max(1, iTheirStrength);
			iExperience = range(iExperience, GC.getMIN_EXPERIENCE_PER_COMBAT(), GC.getMAX_EXPERIENCE_PER_COMBAT());
			pInterceptor->changeExperience(iExperience, pInterceptor->maxXPValue(this), true, pPlot->getOwner() == pInterceptor->getOwner(), true);
		}
	}
	else if (pInterceptor->isDead())
	{
		int iExperience = attackXPValue();
		iExperience = (iExperience * iTheirStrength) / std::max(1, iOurStrength);
		iExperience = range(iExperience, GC.getMIN_EXPERIENCE_PER_COMBAT(), GC.getMAX_EXPERIENCE_PER_COMBAT());
		changeExperience(iExperience, maxXPValue(pInterceptor), true, pPlot->getOwner() == getOwner(), true);
	}
	else if (iOurDamage > 0)
	{
		if (iTheirRoundDamage > 0)
		{
			pInterceptor->changeExperience100(getExperiencefromWithdrawal(iOurOdds) * 10 / 100, 100 * pInterceptor->maxXPValue(this), true, pPlot->getOwner() == pInterceptor->getOwner(), true);
		}
	}
	else if (iTheirDamage > 0)
	{
		changeExperience100(getExperiencefromWithdrawal(iOurOdds) * 10 / 100, 100 * maxXPValue(pInterceptor), true, pPlot->getOwner() == getOwner(), true);
	}

	kBattle.setDamage(BATTLE_UNIT_ATTACKER, iOurDamage);
	kBattle.setDamage(BATTLE_UNIT_DEFENDER, iTheirDamage);
}


void CvUnit::updateAirCombat(bool bQuick)
{
	CvUnit* pInterceptor = NULL;
	bool bFinish = false;

	FAssert(getDomainType() == DOMAIN_AIR || getDropRange() > 0);

	if (getCombatTimer() > 0)
	{
		changeCombatTimer(-1);

		if (getCombatTimer() > 0)
		{
			return;
		}
		bFinish = true;
	}

	CvPlot* pPlot = getAttackPlot();
	if (pPlot == NULL)
	{
		return;
	}

	if (bFinish)
	{
		pInterceptor = getCombatUnit();
	}
	else
	{
		pInterceptor = bestInterceptor(pPlot);
	}


	if (!pInterceptor)
	{
		setAttackPlot(NULL, false);
		setCombatUnit(NULL);
		return;
	}

	//if not finished and not fighting yet, set up combat damage and mission
	if (!bFinish)
	{
		if (!isInBattle())
		{
			if (plot()->isBattle() || pPlot->isBattle())
			{
				return;
			}

			setMadeAttack(true);

			setCombatUnit(pInterceptor, true, bQuick);
			pInterceptor->setCombatUnit(this, false, bQuick);
		}

		FAssertMsg(pInterceptor != NULL, "Defender is not assigned a valid value");

		FAssertMsg(plot()->isBattle(), "Current unit instance plot is not fighting as expected");
		FAssertMsg(pInterceptor->plot()->isBattle(), "pPlot is not fighting as expected");

		CvAirMissionDefinition kAirMission(getDomainType() == DOMAIN_AIR ? MISSION_AIRSTRIKE : MISSION_PARADROP, pPlot, this, pInterceptor, GC.getMissionInfo(MISSION_AIRSTRIKE).getTime() * gDLL->getSecsPerTurn());
		resolveAirCombat(pInterceptor, pPlot, kAirMission);

		if (!bQuick && isCombatVisible(pInterceptor))
		{
			setCombatTimer(GC.getMissionInfo(MISSION_AIRSTRIKE).getTime());
			GC.getGame().incrementTurnTimer(getCombatTimer());
			addMission(kAirMission);
		}
		else bFinish = true;

		changeMoves(GC.getMOVE_DENOMINATOR());
		if (DOMAIN_AIR != pInterceptor->getDomainType())
		{
			pInterceptor->setMadeInterception(true);
		}

		if (isDead())
		{

			CvWString szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_SHOT_DOWN_ENEMY", pInterceptor->getNameKey(), getNameKey(), getVisualCivAdjective(pInterceptor->getTeam()));
			AddDLLMessage(pInterceptor->getOwner(), false, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_INTERCEPT", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_GREEN(), pPlot->getX(), pPlot->getY(), true, true);

			szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_UNIT_SHOT_DOWN", getNameKey(), pInterceptor->getNameKey());
			AddDLLMessage(getOwner(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_INTERCEPTED", MESSAGE_TYPE_INFO, pInterceptor->getButton(), GC.getCOLOR_RED(), pPlot->getX(), pPlot->getY());
		}
		else if (kAirMission.getDamage(BATTLE_UNIT_ATTACKER) > 0)
		{

			CvWString szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_HURT_ENEMY_AIR", pInterceptor->getNameKey(), getNameKey(), -(kAirMission.getDamage(BATTLE_UNIT_ATTACKER)), getVisualCivAdjective(pInterceptor->getTeam()));
			AddDLLMessage(pInterceptor->getOwner(), false, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_INTERCEPT", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_GREEN(), pPlot->getX(), pPlot->getY(), true, true);

			szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_AIR_UNIT_HURT", getNameKey(), pInterceptor->getNameKey(), -(kAirMission.getDamage(BATTLE_UNIT_ATTACKER)));
			AddDLLMessage(getOwner(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_INTERCEPTED", MESSAGE_TYPE_INFO, pInterceptor->getButton(), GC.getCOLOR_RED(), pPlot->getX(), pPlot->getY());
		}

		if (pInterceptor->isDead())
		{

			CvWString szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_SHOT_DOWN_ENEMY", getNameKey(), pInterceptor->getNameKey(), pInterceptor->getVisualCivAdjective(getTeam()));
			AddDLLMessage(getOwner(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_INTERCEPT", MESSAGE_TYPE_INFO, pInterceptor->getButton(), GC.getCOLOR_GREEN(), pPlot->getX(), pPlot->getY(), true, true);

			szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_UNIT_SHOT_DOWN", pInterceptor->getNameKey(), getNameKey());
			AddDLLMessage(pInterceptor->getOwner(), false, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_INTERCEPTED", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_RED(), pPlot->getX(), pPlot->getY());
		}
		else if (kAirMission.getDamage(BATTLE_UNIT_DEFENDER) > 0)
		{

			CvWString szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_DAMAGED_ENEMY_AIR", getNameKey(), pInterceptor->getNameKey(), -(kAirMission.getDamage(BATTLE_UNIT_DEFENDER)), pInterceptor->getVisualCivAdjective(getTeam()));
			AddDLLMessage(getOwner(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_INTERCEPT", MESSAGE_TYPE_INFO, pInterceptor->getButton(), GC.getCOLOR_GREEN(), pPlot->getX(), pPlot->getY(), true, true);

			szBuffer = gDLL->getText("TXT_KEY_MISC_YOUR_AIR_UNIT_DAMAGED", pInterceptor->getNameKey(), getNameKey(), -(kAirMission.getDamage(BATTLE_UNIT_DEFENDER)));
			AddDLLMessage(pInterceptor->getOwner(), false, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_INTERCEPTED", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_RED(), pPlot->getX(), pPlot->getY());
		}

		if (0 == kAirMission.getDamage(BATTLE_UNIT_ATTACKER) + kAirMission.getDamage(BATTLE_UNIT_DEFENDER))
		{

			CvWString szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_ABORTED_ENEMY_AIR", pInterceptor->getNameKey(), getNameKey(), getVisualCivAdjective(getTeam()));
			AddDLLMessage(pInterceptor->getOwner(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_INTERCEPT", MESSAGE_TYPE_INFO, pInterceptor->getButton(), GC.getCOLOR_GREEN(), pPlot->getX(), pPlot->getY(), true, true);

			szBuffer = gDLL->getText("TXT_KEY_MISC_YOUR_AIR_UNIT_ABORTED", getNameKey(), pInterceptor->getNameKey());
			AddDLLMessage(getOwner(), false, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_INTERCEPTED", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_RED(), pPlot->getX(), pPlot->getY());
		}
	}

	if (bFinish)
	{
		setAttackPlot(NULL, false);
		setCombatUnit(NULL);
		pInterceptor->setCombatUnit(NULL);

		if (!isDead() && isSuicide())
		{
			kill(true);
		}
	}
}

namespace {
	bool unitsAtWar(const TeamTypes ourTeam, const CvUnit* theirUnit)
	{
		return GET_TEAM(theirUnit->getTeam()).isAtWar(ourTeam);
	}

	bool plotHasEnemy(const TeamTypes ourTeam, const CvPlot* ignorePlot, const CvPlot* plot)
	{
		return plot != ignorePlot && algo::any_of(plot->units(), bind(unitsAtWar, ourTeam, _1));
	}

	bool plotHasAdjacentEnemy(const TeamTypes ourTeam, const CvPlot* ignorePlot, const CvPlot* plot)
	{
		return algo::any_of(plot->adjacent(), bind(plotHasEnemy, ourTeam, ignorePlot, _1));
	}

	bool canWithdrawToPlot(const CvUnit* withdrawingUnit, const CvPlot* toPlot)
	{
		return withdrawingUnit->canEnterPlot(toPlot)
			&& !plotHasEnemy(withdrawingUnit->getTeam(), withdrawingUnit->plot(), toPlot)
			// && !plotHasAdjacentEnemy(withdrawingUnit.getTeam(), *withdrawingUnit.plot(), toPlot)
			;
	}

	bst::optional<CvPlot*> selectWithdrawPlot(bool bSamePlotCombat, const CvUnit* withdrawingUnit)
	{
		if (bSamePlotCombat)
		{
			return withdrawingUnit->plot();
		}

		return algo::find_if(withdrawingUnit->plot()->adjacent(), bind(canWithdrawToPlot, withdrawingUnit, _1));
	}
}

void CvUnit::resolveCombat(CvUnit* pDefender, CvPlot* pPlot, CvBattleDefinition& kBattle, bool bSamePlot)
{
	PROFILE_FUNC();

	CombatDetails cdAttackerDetails;
	CombatDetails cdDefenderDetails;

	AI_setPredictedHitPoints(-1);
	pDefender->AI_setPredictedHitPoints(-1);
	int iAttackerStrength = currCombatStr(NULL, NULL, &cdAttackerDetails);
	int iAttackerFirepower = currFirepower(NULL, NULL);
	int iDefenderStrength = 0;
	int iAttackerDamage = 0;
	int iDefenderDamage = 0;
	int iDefenderOdds = 0;

	bool bAttackerWithdrawn = false;
	//TB Combat Mods Begin
	m_combatResult.bAttackerPursued = false;
	m_combatResult.bDefenderPursued = false;
	m_combatResult.bAttackerPursuedSustain = false;
	m_combatResult.bDefenderPursuedSustain = false;
	m_combatResult.bAttackerRepelled = false;
	m_combatResult.bAttackerRefusedtoYield = false;
	m_combatResult.bDefenderRefusedtoYield = false;
	m_combatResult.bDefenderKnockedBack = false;
	m_combatResult.bAttackerStampedes = false;
	m_combatResult.bAttackerWithdraws = false;
	m_combatResult.bAttackerOnslaught = false;
	m_combatResult.bAttackerInjured = false;
	m_combatResult.bDefenderInjured = false;
	m_combatResult.bDeathMessaged = true;
	m_combatResult.bDefenderHitAttackerWithDistanceAttack = false;
	m_combatResult.bAttackerHitDefenderWithDistanceAttack = false;
	m_combatResult.bNeverMelee = true;
	int temporarypursuit = 0;
	int iDefenderDodge = pDefender->dodgeVSOpponentProbTotal(this);
	int iDefenderPrecision = pDefender->precisionVSOpponentProbTotal(this);
	int iAttackerDodge = dodgeVSOpponentProbTotal(pDefender);
	int iAttackerPrecision = precisionVSOpponentProbTotal(pDefender);
	bool bBreakdown = false;
	int iDefenderFirstStrikes = pDefender->getCombatFirstStrikes();
	int iAttackerFirstStrikes = getCombatFirstStrikes();
	//TB Combat Mods End
	bool bAttackerHasLostNoHP = true;
	int iAttackerInitialDamage = getDamage();
	int iDefenderInitialDamage = pDefender->getDamage();
	int iDefenderCombatRoll = 0;
	int iAttackerCombatRoll = 0;
	int WithdrawalRollResult = 0;
	int DefenderWithdrawalRollResult = 0;
	int RepelRollResult = 0;
	int PursuitRollResult = 0;
	int iAttackerHitModifier = 0;
	int iDefenderHitModifier = 0;
	int iAttackerOdds = 0;
	int	iDefenderHitChance = 0;
	int	iAttackerHitChance = 0;
	int iInitialDefXP = pDefender->getExperience100();
	int iInitialAttXP = getExperience100();
	int iInitialAttGGXP = GET_PLAYER(getOwner()).getCombatExperience();
	int iInitialDefGGXP = GET_PLAYER(pDefender->getOwner()).getCombatExperience();
	const bool bDynamicXP = GC.getGame().isModderGameOption(MODDERGAMEOPTION_IMPROVED_XP);

	getDefenderCombatValues(*pDefender, pPlot, iAttackerStrength, iAttackerFirepower, iDefenderOdds, iDefenderStrength, iAttackerDamage, iDefenderDamage, &cdDefenderDetails, pDefender);
	int iInitialAttackerStrength = iAttackerStrength;
	int iInitialDefenderStrength = iDefenderStrength;
#ifdef OUTBREAKS_AND_AFFLICTIONS
	//TB Combat Mods Begin
	for (int iI = 0; iI < GC.getNumPromotionLineInfos(); iI++)
	{
		if (hasAfflictOnAttackType((PromotionLineTypes)iI))
		{
			setAfflictOnAttackTypeAttemptedCount((PromotionLineTypes)iI, 0);
		}
		if (pDefender->hasAfflictOnAttackType((PromotionLineTypes)iI))
		{
			pDefender->setAfflictOnAttackTypeAttemptedCount((PromotionLineTypes)iI, 0);
		}
	}
#endif
	//  Determine Attack Withdraw odds
	int iHitLimitThem = pDefender->getMaxHP() - combatLimit(pDefender);

	int iNeededRoundsUs = (iDefenderDamage == 0 ? MAX_INT : (std::max(0, pDefender->getHP() - iHitLimitThem) + iDefenderDamage - 1 ) / iDefenderDamage);
	int iNeededRoundsThem = (iAttackerDamage == 0 ? MAX_INT : (std::max(0, getHP()) + iAttackerDamage - 1 ) / iAttackerDamage);
	int iAttackerWithdraw = withdrawVSOpponentProbTotal(pDefender, pPlot);
	int iDefenderPursuit = pDefender->pursuitVSOpponentProbTotal(this);
	int iAttackerEarly = earlyWithdrawTotal();

	int AdjustedAttWithdrawalstep1 = iAttackerWithdraw - iDefenderPursuit;
	int AdjustedAttWithdrawalstep2 = std::min(100, AdjustedAttWithdrawalstep1);
	int AdjustedAttWithdrawal = std::max(0, AdjustedAttWithdrawalstep2);

	int expectedrndcnt = std::min(iNeededRoundsUs, iNeededRoundsThem);
	int expectedrnds = ((expectedrndcnt * iAttackerEarly)/100);

	int y = AdjustedAttWithdrawal;
	int z = AdjustedAttWithdrawal;
	int Time;
	for (Time = 0; Time < expectedrnds; ++Time)
	{
		z += ((AdjustedAttWithdrawal * y)/100);
		y = ((AdjustedAttWithdrawal * (100 - z))/100);	//	Prob next round is prob per round times prob you haven't already
	}

	int EvaluatedAttWithdrawOdds = z;


	int iAttackerKnockback = knockbackVSOpponentProbTotal(pDefender);
	int iDefenderUnyielding = pDefender->unyieldingTotal();
	int iAttackerKnockbackTries = knockbackRetriesTotal();

	int AdjustedKnockbackstep1 = iAttackerKnockback - iDefenderUnyielding;
	int AdjustedKnockbackstep2 = ((AdjustedKnockbackstep1 > 100) ? 100 : AdjustedKnockbackstep1);
	int AdjustedKnockback = ((AdjustedKnockbackstep2 < 0) ? 0 : AdjustedKnockbackstep2);

	y = AdjustedKnockback;
	z = AdjustedKnockback;

	for (Time = 0; Time < iAttackerKnockbackTries; ++Time)
	{
		z += ((AdjustedKnockback * y)/100);
		y = ((AdjustedKnockback * (100 - z))/100);	//	Prob next round is prob per round times prob you haven't already
	}

	int EvaluatedKnockbackOdds = z;
	//Original: int iAttackerKillOdds = iDefenderOdds * (100 - withdrawalProbability()) / 100;
	int iAttackerKillOdds = iDefenderOdds * (100 - (EvaluatedAttWithdrawOdds)) / 100;

	iAttackerKillOdds *= (100 - (EvaluatedKnockbackOdds));
	iAttackerKillOdds /= 100;
	//TB Combat Mods End

	if (isHuman() || pDefender->isHuman())
	{
		//Added ST
		CyArgsList pyArgsCD;
		pyArgsCD.add(gDLL->getPythonIFace()->makePythonObject(&cdAttackerDetails));
		pyArgsCD.add(gDLL->getPythonIFace()->makePythonObject(&cdDefenderDetails));
		pyArgsCD.add(getCombatOdds(this, pDefender));
		CvEventReporter::getInstance().genericEvent("combatLogCalc", pyArgsCD.makeFunctionArgs());
	}

	collateralCombat(pPlot, pDefender);

	int iCloseCombatRoundNum = -1;
	//bool bTryMobileWithdraw = false;	//if unit will be trying to withdraw from a plot it occupies
	//if (pPlot->getNumDefenders(pDefender->getOwner()) == 1 && pDefender->baseMoves() > baseMoves())	//must be faster than attacker
	//{
	//	bTryMobileWithdraw = true;
	//}
	int iWinningOdds = getCombatOdds(this, pDefender);
	bool bDefenderSkirmish = false; //iWinningOdds > 60;
	m_combatResult.bDefenderWithdrawn = false;
	m_combatResult.pPlot = NULL;
	m_combatResult.iTurnCount++;
	//Compile the Repel values only once as necessary
	int iDefenderRepel = pDefender->repelVSOpponentProbTotal(this);
	int iAttackerUnyielding = unyieldingTotal();

	int AdjustedRepelstep1 = iDefenderRepel - iAttackerUnyielding;
	int AdjustedRepelstep2 = ((AdjustedRepelstep1 > 100) ? 100 : AdjustedRepelstep1);
	int AdjustedRepel = ((AdjustedRepelstep2 < 0) ? 0 : AdjustedRepelstep2);
	bool bNoFurtherDamagetoDefender = false;


	int iDefenderWithdraw = pDefender->withdrawVSOpponentProbTotal(this, pPlot);
	int iAttackerPursuit = pursuitVSOpponentProbTotal(pDefender);
	int iDefenderEarlyWithdraw = pDefender->earlyWithdrawTotal();

	int AdjustedDefWithdrawstep1 = iDefenderWithdraw - iAttackerPursuit;
	int AdjustedDefWithdrawstep2 = ((AdjustedDefWithdrawstep1 > 100) ? 100 : AdjustedDefWithdrawstep1);
	int AdjustedDefWithdraw = ((AdjustedDefWithdrawstep2 < 0) ? 0 : AdjustedDefWithdrawstep2);

	bool bVanillaCombat = GC.getGame().isOption(GAMEOPTION_COMBAT_VANILLA_ENGINE);
	if (bVanillaCombat)
	{
		iAttackerStrength = currCombatStr(NULL, NULL, &cdAttackerDetails);
		iAttackerFirepower = currFirepower(NULL, NULL);
		getDefenderCombatValues(*pDefender, pPlot, iAttackerStrength, iAttackerFirepower, iDefenderOdds, iDefenderStrength, iAttackerDamage, iDefenderDamage, &cdDefenderDetails, pDefender);
		iDefenderHitChance = std::max(5, iDefenderOdds + ((iDefenderHitModifier * iDefenderOdds)/100));
		iAttackerHitChance = std::max(5, iAttackerOdds + ((iAttackerHitModifier * iAttackerOdds)/100));
	}

	while (true)
	{
		//TB Combat Mods (StrAdjperRnd) begin
		changeRoundCount(1);
		pDefender->changeRoundCount(1);
		if (!bVanillaCombat)
		{
			iAttackerStrength = currCombatStr(NULL, NULL, &cdAttackerDetails);
			iAttackerFirepower = currFirepower(NULL, NULL);
			getDefenderCombatValues(*pDefender, pPlot, iAttackerStrength, iAttackerFirepower, iDefenderOdds, iDefenderStrength, iAttackerDamage, iDefenderDamage, &cdDefenderDetails, pDefender);
			iDefenderHitChance = std::max(5, iDefenderOdds + ((iDefenderHitModifier * iDefenderOdds)/100));
			iAttackerHitChance = std::max(5, iAttackerOdds + ((iAttackerHitModifier * iAttackerOdds)/100));
		}

		//Check if this is a Breakdown Attack round and adjust the local bool so as to avoid reprocessing the Breakdown check multiple times per round.
		if (isBreakdownCombat(pPlot, bSamePlot) && /*getCombatFirstStrikes() == 0 &&*/ pDefender->getCombatFirstStrikes() == 0)
		{
			bBreakdown = true;
		}
		else
		{
			bBreakdown = false;
		}
		//TB Combat Mods (StrAdjperRnd) end

		//TB Combat Mods begin
		if (getCombatPowerShots() > 0)
		{
			iAttackerPrecision += powerShotPrecisionModifierTotal();
		}
		if (pDefender->getCombatPowerShots() > 0)
		{
			iDefenderPrecision += pDefender->powerShotPrecisionModifierTotal();
		}
		iAttackerHitModifier = iAttackerPrecision - iDefenderDodge;
		iDefenderHitModifier = iDefenderPrecision - iAttackerDodge;
		iAttackerOdds = std::max((GC.getCOMBAT_DIE_SIDES() - iDefenderOdds), 0);
		iDefenderCombatRoll = GC.getGame().getSorenRandNum(GC.getCOMBAT_DIE_SIDES(), "DefenderCombatRoll");
		iAttackerCombatRoll = GC.getGame().getSorenRandNum(GC.getCOMBAT_DIE_SIDES(), "AttackerCombatRoll");
		WithdrawalRollResult = GC.getGame().getSorenRandNum(100, "Withdrawal");
		DefenderWithdrawalRollResult = GC.getGame().getSorenRandNum(100, "DefenderWithdrawal");
		RepelRollResult = GC.getGame().getSorenRandNum(100, "Repel");
		PursuitRollResult = GC.getGame().getSorenRandNum(100, "Pursuit");
		//Breakdown attack round?  If so we make the damage the defender would be dealt 0 and the chance of the attcker
		//hitting absolute so as to get through all normal checks to roll the chance for damaging the defenses while the
		//unit really does not engage in any counterattack against the defender.
		//TB Breakdown Adjustment: Finding this is probably not appropriate.  Better to allow actual combat to take place though
		//we may need to reduce the strengths on Rams some...  I'll probably end up making this more what I was looking for
		//when I get into the H2H/Distance mechanism.
		//if (bBreakdown)
		//{
		//	iDefenderDamage = 0;
		//	iAttackerHitChance = 10000;
		//}

		//TB Combat Mods (Breakdown) begin
		//Changes: No longer requires any particular combat result to make happen - previously attacker had to hit and since it had originally been setup to always hit so long as first strikes weren't taking place, the ram was rarely doing much damage.
		//I had made all rams immune to first strike though I'd prefer not to at this point... I can take that away now and allow the first strike rounds to take place as intended.
		if (bBreakdown)
		{
			resolveBreakdownAttack(pPlot, AdjustedRepel);
			changeExperience100(10, MAX_INT, false, false, true);
		}
		bool bNeitherRanged = (!pDefender->isRanged() && !isRanged());
		bool bDefenderRangedbutOutofFS = (pDefender->isRanged() && pDefender->getCombatFirstStrikes() < 1);
		bool bDefenderNotRanged = (pDefender->isRanged());
		bool bAttackerRangedbutOutofFS = (pDefender->isRanged() && pDefender->getCombatFirstStrikes() < 1);
		bool bAttackerNotRanged = (isRanged());
		if (bNeitherRanged ||
			((bDefenderRangedbutOutofFS || bDefenderNotRanged) &&
			(bAttackerRangedbutOutofFS || bAttackerNotRanged)))
		{
			m_combatResult.bNeverMelee = false;
		}
		//Defender's attack round
		if (pDefender->getCombatStuns() == 0 && iDefenderCombatRoll < iDefenderHitChance)
		{
			if (getCombatFirstStrikes() == 0)
			{
				// TB Combat Mods Begin
				//	Attacker Attempts Withdrawal
				if ((getDamage() + iAttackerDamage) >= withdrawalHP(getMaxHP(), iAttackerEarly) && iAttackerWithdraw > 0)
				{
					if (WithdrawalRollResult < AdjustedAttWithdrawal)
					{
						flankingStrikeCombat(pPlot, iAttackerStrength, iAttackerFirepower, iAttackerKillOdds, iDefenderDamage, pDefender);
						bAttackerWithdrawn = true;

						if (!bDynamicXP)
						{
							changeExperience100(getExperiencefromWithdrawal(AdjustedAttWithdrawal) * 10 / 100, 100 * maxXPValue(pDefender), true, pPlot->getOwner() == getOwner(), true);

							int iExperience = 100 * pDefender->defenseXPValue() * iInitialAttackerStrength / iInitialDefenderStrength;
							iExperience = range(iExperience, 100 * GC.getMIN_EXPERIENCE_PER_COMBAT(), 100 * GC.getMAX_EXPERIENCE_PER_COMBAT());
							pDefender->changeExperience100(iExperience, 100 * pDefender->maxXPValue(this), true, pPlot->getOwner() == pDefender->getOwner(), true);
						}

// BUG - Combat Events - start
						CvEventReporter::getInstance().combatRetreat(this, pDefender);
						m_combatResult.bAttackerWithdraws = true;
						m_combatResult.bDeathMessaged = false;
// BUG - Combat Events - end
						break;
					}
					else if ((WithdrawalRollResult < iAttackerWithdraw) && (WithdrawalRollResult > AdjustedAttWithdrawal))
					{
						if ((getDamage() + iAttackerDamage) < getMaxHP())
						{
							m_combatResult.bAttackerPursuedSustain = true;
						}
						else
						{
							m_combatResult.bAttackerPursued = true;
						}
					}
				}
				//TB Combat Mod (Afflict) begin
				if (iAttackerDamage > 0)
				{
					m_combatResult.bAttackerInjured = true;
				}
				//TB Combat Mod (Afflict) end
				changeDamage(iAttackerDamage, pDefender->getOwner());
				//TB Combat Mod begin
				checkForStun(iAttackerDamage, pDefender);
#ifdef OUTBREAKS_AND_AFFLICTIONS
				checkForCritical(iAttackerDamage, pDefender);
#endif
				if (pDefender->dealsColdDamage())
				{
					changeColdDamage(iAttackerDamage);
				}
				//TB Combat Mod end

				bAttackerHasLostNoHP = false;

				if (pDefender->getCombatFirstStrikes() > 0 && pDefender->isRanged())
				{
					kBattle.addFirstStrikes(BATTLE_UNIT_DEFENDER, 1);
					kBattle.addDamage(BATTLE_UNIT_ATTACKER, BATTLE_TIME_RANGED, iAttackerDamage);
				}

				cdAttackerDetails.iCurrHitPoints = getHP();

				if (isHuman() || pDefender->isHuman())
				{
					CyArgsList pyArgs;
					pyArgs.add(gDLL->getPythonIFace()->makePythonObject(&cdAttackerDetails));
					pyArgs.add(gDLL->getPythonIFace()->makePythonObject(&cdDefenderDetails));
					pyArgs.add(1);
					pyArgs.add(iAttackerDamage);
					CvEventReporter::getInstance().genericEvent("combatLogHit", pyArgs.makeFunctionArgs());
				}
				//TB Combat Mods Begin (Repel)
				//within the 'after attacker's first strikes segment'


				if (pDefender->getCombatRepels() > 0)
				{
					if (RepelRollResult < AdjustedRepel)
					{
						m_combatResult.bAttackerRepelled = true;
						m_combatResult.bDeathMessaged = false;

						if (!bDynamicXP)
						{
							pDefender->changeExperience100(getExperiencefromWithdrawal(AdjustedRepel) * 15 / 100, 100 * pDefender->maxXPValue(this), true, pPlot->getOwner() == getOwner(), true);
						}
						break;
					}
					else if (RepelRollResult < iDefenderRepel && RepelRollResult > AdjustedRepel)
					{
						if ((pDefender->getDamage() + iDefenderDamage) < pDefender->getMaxHP())
						{
							m_combatResult.bAttackerRefusedtoYieldSustain = true;
						}
						else
						{
							m_combatResult.bAttackerRefusedtoYield = true;
						}
					}
				}
				if (pDefender->getCombatFirstStrikes() > 0 && pDefender->isRanged())
				{
					m_combatResult.bDefenderHitAttackerWithDistanceAttack = true;
				}
#ifdef OUTBREAKS_AND_AFFLICTIONS
				if (GC.getGame().isOption(GAMEOPTION_COMBAT_OUTBREAKS_AND_AFFLICTIONS))
				{
					PROFILE("CvUnit::resolveCombat.Afflictions");

					for (int iI = 0; iI < GC.getNumPromotionLineInfos(); iI++)
					{
						if (GC.getPromotionLineInfo((PromotionLineTypes)iI).isAffliction() && !GC.getPromotionLineInfo((PromotionLineTypes)iI).isCritical())
						{
							PromotionLineTypes eAfflictionLine = ((PromotionLineTypes)iI);
							if (pDefender->hasAfflictOnAttackType(eAfflictionLine) &&
								pDefender->isAfflictOnAttackTypeImmediate(eAfflictionLine) &&
								pDefender->isAfflictOnAttackTypeAttempted(eAfflictionLine) == false)
							{
								bool bDistanceQualified = ((pDefender->getCombatFirstStrikes() > 0 && pDefender->isAfflictOnAttackTypeDistance(eAfflictionLine) && pDefender->isRanged()) ||
															((pDefender->getCombatFirstStrikes() < 1 || !pDefender->isRanged()) && pDefender->isAfflictOnAttackTypeMelee(eAfflictionLine) && !(getCombatFirstStrikes() > 0 && isRanged())));
								if (bDistanceQualified)
								{
									int iDefendersPoisonChance = pDefender->getAfflictOnAttackTypeProbability(eAfflictionLine) - fortitudeTotal() - getUnitAfflictionTolerance(eAfflictionLine);
									if (GC.getGame().getSorenRandNum(100, "DefendersPoisonRoll") < iDefendersPoisonChance)
									{
										afflict(eAfflictionLine, true, pDefender);
									}
									pDefender->changeAfflictOnAttackTypeAttemptedCount(eAfflictionLine, 1);
								}
							}
						}
					}
				}
#endif // OUTBREAKS_AND_AFFLICTIONS
			}
		}
		//Attacker's attack round
		if (getCombatStuns() == 0 && ((bVanillaCombat && iDefenderCombatRoll >= iDefenderHitChance) || (iAttackerCombatRoll < iAttackerHitChance)))
		{
			if (pDefender->getCombatFirstStrikes() == 0)
			{
				if (GC.getGame().isModderGameOption(MODDERGAMEOPTION_DEFENDER_WITHDRAW))
				{
					iCloseCombatRoundNum++;
				}
				//TB Combat Mods Begin
				//Attacker attempts withdrawal due to combatlimit
				if ((std::min(pDefender->getMaxHP(), pDefender->getDamage() + iDefenderDamage) > combatLimit(pDefender)) && (PursuitRollResult > pDefender->pursuitVSOpponentProbTotal(this)))
				{
					if (!bBreakdown || getDamage() > combatLimit(this))
					{
						if (!bDynamicXP)
						{
							int iWithdrawOdds = 100 - pDefender->pursuitVSOpponentProbTotal(this);
							changeExperience100(getExperiencefromWithdrawal(iWithdrawOdds), 100 * maxXPValue(pDefender), true, pPlot->getOwner() == getOwner(), true);
							int iExperience = 100 * pDefender->defenseXPValue() * iInitialAttackerStrength / iInitialDefenderStrength;
							iExperience = range(iExperience, 100 * GC.getMIN_EXPERIENCE_PER_COMBAT(), 100 * GC.getMAX_EXPERIENCE_PER_COMBAT());
							pDefender->changeExperience100(iExperience, 100 * pDefender->maxXPValue(this), true, pPlot->getOwner() == pDefender->getOwner(), true);
						}

						if (temporarypursuit == 0)
						{
							m_combatResult.bDeathMessaged = false;
							pDefender->setDamage(combatLimit(pDefender), getOwner());
							if (dealsColdDamage())
							{
								pDefender->setColdDamage(combatLimit(pDefender));
							}
						}
						temporarypursuit = 0;
						break;
					}
					else
					{
						bNoFurtherDamagetoDefender = true;
					}
				}
				else if ((std::min(pDefender->getMaxHP(), pDefender->getDamage() + iDefenderDamage) > combatLimit(pDefender)) && (PursuitRollResult < pDefender->pursuitVSOpponentProbTotal(this)) && pDefender->pursuitVSOpponentProbTotal(this) > 0)
				{
					if (!bBreakdown || getDamage() > combatLimit(this))
					{
						temporarypursuit += 1;
						m_combatResult.bAttackerPursuedSustain = true;
					}
				}
				// Current Code (Defender Attempts Withdrawal):

				if  ((!pPlot->isCity(true, pDefender->getTeam()) || bSamePlot) && GC.getGame().isModderGameOption(MODDERGAMEOPTION_DEFENDER_WITHDRAW) && ((pDefender->getDamage() + iDefenderDamage) >= withdrawalHP(pDefender->getMaxHP(), iDefenderEarlyWithdraw) || bDefenderSkirmish) && !isSuicide() && iCloseCombatRoundNum > 0 && pDefender->withdrawVSOpponentProbTotal(this, pPlot) > 0)	//can not to escape at close combat round 1
				{
					if (DefenderWithdrawalRollResult < AdjustedDefWithdraw)
					{
						bst::optional<CvPlot*> withdrawPlot = selectWithdrawPlot(bSamePlot, pDefender);
						if (withdrawPlot)
						{
							m_combatResult.pPlot = *withdrawPlot;
							m_combatResult.bDefenderWithdrawn = true;
							m_combatResult.bDeathMessaged = false;

							if (bDynamicXP)
							{
								doDynamicXP(pDefender, pPlot, iAttackerInitialDamage, iWinningOdds, iDefenderInitialDamage);
							}
							else
							{
								pDefender->changeExperience100(getExperiencefromWithdrawal(AdjustedDefWithdraw) * 10 / 100, 100 * pDefender->maxXPValue(this), true, pPlot->getOwner() == pDefender->getOwner(), true);
								changeExperience100(10, 100 * maxXPValue(pDefender), true, pPlot->getOwner() == getOwner(), true);
							}
							return;
						}
					}
					else if (DefenderWithdrawalRollResult < iDefenderWithdraw && DefenderWithdrawalRollResult > AdjustedDefWithdraw)
					{
						if ((pDefender->getDamage() + iDefenderDamage) < pDefender->getMaxHP())
						{
							m_combatResult.bDefenderPursuedSustain = true;
						}
						else
						{
							m_combatResult.bDefenderPursued = true;
						}
					}
				}

//TB Combat Mods End

				//TB Combat Mods (Afflict) begin
				if (iDefenderDamage > 0)
				{
					if (!bNoFurtherDamagetoDefender)
					{
						m_combatResult.bDefenderInjured = true;
						pDefender->changeDamage(iDefenderDamage, getOwner());
					}
				}
				//TB Combat Mods (Afflict) end
				//TB Combat Mods Begin
				if (!bBreakdown)
				{
					pDefender->checkForStun(iDefenderDamage, this);
#ifdef OUTBREAKS_AND_AFFLICTIONS
					pDefender->checkForCritical(iDefenderDamage, this);
#endif
					if (dealsColdDamage())
					{
						pDefender->changeColdDamage(iDefenderDamage);
					}
				}
				//TB Combat Mods End

				if (getCombatFirstStrikes() > 0 && isRanged())
				{
					kBattle.addFirstStrikes(BATTLE_UNIT_ATTACKER, 1);
					kBattle.addDamage(BATTLE_UNIT_DEFENDER, BATTLE_TIME_RANGED, iDefenderDamage);
				}

				cdDefenderDetails.iCurrHitPoints=pDefender->getHP();

				if (isHuman() || pDefender->isHuman())
				{
					CyArgsList pyArgs;
					pyArgs.add(gDLL->getPythonIFace()->makePythonObject(&cdAttackerDetails));
					pyArgs.add(gDLL->getPythonIFace()->makePythonObject(&cdDefenderDetails));
					pyArgs.add(0);
					pyArgs.add(iDefenderDamage);
					CvEventReporter::getInstance().genericEvent("combatLogHit", pyArgs.makeFunctionArgs());
				}

				//TB Combat Mods (Knockback and attacker affliction)
				if (!bBreakdown && !pDefender->isDead())
				{
					if (!bSamePlot)
					{
						int KnockbackRollResult = GC.getGame().getSorenRandNum(100, "Knockback");

						if (getCombatKnockbacks() > 0)
						{
							if (KnockbackRollResult < AdjustedKnockback)
							{
								m_combatResult.bDefenderKnockedBack = true;
								m_combatResult.bDeathMessaged = false;
								m_combatResult.pPlot = selectWithdrawPlot(bSamePlot, pDefender).get_value_or(nullptr);

								if (bDynamicXP)
								{
									doDynamicXP(pDefender, pPlot, iAttackerInitialDamage, iWinningOdds, iDefenderInitialDamage);
								}
								else changeExperience100(getExperiencefromWithdrawal(AdjustedKnockback) * 15 / 100, 100 * maxXPValue(pDefender), true, pPlot->getOwner() == getOwner(), true);
								return;
							}
							else if ((KnockbackRollResult < iAttackerKnockback) && (KnockbackRollResult > AdjustedKnockback))
							{
								if ((pDefender->getDamage() + iDefenderDamage) < getMaxHP())
								{
									m_combatResult.bDefenderRefusedtoYieldSustain = true;
								}
								else
								{
									m_combatResult.bDefenderRefusedtoYield = true;
								}
							}
						}
					}
					if (getCombatFirstStrikes() > 0 && isRanged())
					{
						m_combatResult.bAttackerHitDefenderWithDistanceAttack = true;
					}
#ifdef OUTBREAKS_AND_AFFLICTIONS
					if (GC.getGame().isOption(GAMEOPTION_COMBAT_OUTBREAKS_AND_AFFLICTIONS))
					{
						for (int iI = 0; iI < GC.getNumPromotionLineInfos(); iI++)
						{
							if (GC.getPromotionLineInfo((PromotionLineTypes)iI).isAffliction() && !GC.getPromotionLineInfo((PromotionLineTypes)iI).isCritical())
							{
								PromotionLineTypes eAfflictionLine = ((PromotionLineTypes)iI);
								if (hasAfflictOnAttackType(eAfflictionLine) &&
									isAfflictOnAttackTypeImmediate(eAfflictionLine) &&
									isAfflictOnAttackTypeAttempted(eAfflictionLine) == false)
								{
									bool bDistanceQualified = ((getCombatFirstStrikes() > 0 && isAfflictOnAttackTypeDistance(eAfflictionLine) && isRanged()) ||
															((getCombatFirstStrikes() < 1 || !isRanged()) && isAfflictOnAttackTypeMelee(eAfflictionLine) && !(pDefender->getCombatFirstStrikes() > 0 && pDefender->isRanged())));
									if (bDistanceQualified)
									{
										int iAttackersPoisonChance = getAfflictOnAttackTypeProbability(eAfflictionLine) - pDefender->fortitudeTotal() - pDefender->getUnitAfflictionTolerance(eAfflictionLine);

										if (GC.getGame().getSorenRandNum(100, "AttackersPoisonRoll") < iAttackersPoisonChance)
										{
											pDefender->afflict(eAfflictionLine, true, this);
										}
										changeAfflictOnAttackTypeAttemptedCount(eAfflictionLine, 1);
									}
								}
							}
						}
					}
#endif // OUTBREAKS_AND_AFFLICTIONS
				}
			}
		}
		//TB Combat Mods begin
		if (pDefender->getCombatFirstStrikes() == 0 && getCombatPowerShots() > 0)
		{
			if (!bBreakdown)
			{
				changeCombatPowerShots(-1);
			}
		}

		if (getCombatFirstStrikes() == 0 && pDefender->getCombatPowerShots() > 0)
		{
			pDefender->changeCombatPowerShots(-1);
		}

		if ((getCombatKnockbacks() > 0) && (pDefender->getCombatFirstStrikes() == 0))
		{
			if (!bBreakdown && !bSamePlot)
			{
				changeCombatKnockbacks(-1);
			}
		}

		if ((pDefender->getCombatRepels() > 0) && (getCombatFirstStrikes() == 0))
		{
			pDefender->changeCombatRepels(-1);
		}

		if (getCombatStuns() > 0)
		{
			if (!bBreakdown)
			{
				changeCombatStuns(-1);
			}
		}

		if (pDefender->getCombatStuns() > 0)
		{
			pDefender->changeCombatStuns(-1);
		}
		//TB Combat Mods end
		if (pDefender->getCombatStuns() == 0 && getCombatFirstStrikes() > 0)
		{
			changeCombatFirstStrikes(-1);
		}

		if (getCombatStuns() == 0 && pDefender->getCombatFirstStrikes() > 0)
		{
			pDefender->changeCombatFirstStrikes(-1);
		}

		if (isDead() || pDefender->isDead())
		{
			if (isDead())
			{
				if (!bDynamicXP)
				{
					int iExperience = pDefender->defenseXPValue() * iInitialAttackerStrength / iInitialDefenderStrength;
					iExperience = range(iExperience, GC.getMIN_EXPERIENCE_PER_COMBAT(), GC.getMAX_EXPERIENCE_PER_COMBAT());
					pDefender->changeExperience(iExperience, pDefender->maxXPValue(this), true, pPlot->getOwner() == pDefender->getOwner(), true);
				}
				// Koshling - add rolling history of combat results to allow the AI to adapt to what it sees happening
				pPlot->area()->recordCombatDeath(getOwner(), getUnitType(), pDefender->getUnitType());
			}
			else
			{
				//TB Note: Place again in the successful withdrawal segment if its not already there.  This may need debugging as well based on reports.
				flankingStrikeCombat(pPlot, iAttackerStrength, iAttackerFirepower, iAttackerKillOdds, iDefenderDamage, pDefender);

				if (!bDynamicXP)
				{
					int iExperience = attackXPValue() * iInitialDefenderStrength / std::max(1, iInitialAttackerStrength);
					iExperience = range(iExperience, GC.getMIN_EXPERIENCE_PER_COMBAT(), GC.getMAX_EXPERIENCE_PER_COMBAT());
					changeExperience(iExperience, maxXPValue(pDefender), true, pPlot->getOwner() == getOwner(), true);
				}
				// Koshling - add rolling history of combat results to allow the AI to adapt to what it sees happening
				pPlot->area()->recordCombatDeath(pDefender->getOwner(), pDefender->getUnitType(), getUnitType());
			}
			break;
		}
	}

	bool bPromotion = false;
	bool bDefPromotion = false;
	//TB Note: for both doBattleFieldPromotions and doDynamicXP, the iWinningOdds needs adjusted by YOUR ability to withdraw - if you have withdrawn at least.  Check the instance there.
	int iNonLethalAttackWinChance = std::max(0, std::max(AdjustedAttWithdrawal, AdjustedKnockback));
	int iNonLethalDefenseWinChance = std::max(0, std::max(AdjustedDefWithdraw, AdjustedRepel));
	doBattleFieldPromotions(
		pDefender, cdDefenderDetails, pPlot,
		bAttackerHasLostNoHP, bAttackerWithdrawn,
		iAttackerInitialDamage, iWinningOdds,
		iInitialAttXP, iInitialAttGGXP, iDefenderInitialDamage,
		iInitialDefXP, iInitialDefGGXP, bPromotion, bDefPromotion,
		iNonLethalAttackWinChance, iNonLethalDefenseWinChance,
		iDefenderFirstStrikes, iAttackerFirstStrikes
	);
	if (bDynamicXP)
	{
		doDynamicXP(pDefender, pPlot, iAttackerInitialDamage, iWinningOdds, iDefenderInitialDamage, bPromotion, bDefPromotion);
	}
}


void CvUnit::updateCombat(CvUnit* pSelectedDefender, bool bSamePlot, bool bStealth, bool bNoCache)
{
	PROFILE_FUNC();

	/*GC.getGame().logOOSSpecial(6, getID(), getDamage());*/

	bool bFinish = false;

	if (getCombatTimer() > 0)
	{
		changeCombatTimer(-1);

		if (getCombatTimer() > 0)
		{
			/*GC.getGame().logOOSSpecial(7, getID(), getDamage());*/
			return;
		}
		bFinish = true;
	}

	CvPlot* pPlot = getAttackPlot();

	if (!pPlot)
	{
		/*GC.getGame().logOOSSpecial(8, getID(), getDamage());*/
		return;
	}

	if (getDomainType() == DOMAIN_AIR)
	{
		updateAirStrike(pPlot, bFinish);
		/*GC.getGame().logOOSSpecial(9, getID(), getDamage());*/
		return;
	}

	CvUnit* pDefender = NULL;

	if (bFinish)
	{
		pDefender = getCombatUnit();
	}
	else if (!pSelectedDefender)
	{
		pDefender = pPlot->getBestDefender(NO_PLAYER, getOwner(), this, true, false, false, false, bStealth || bNoCache);
	}
	else pDefender = pSelectedDefender;


	if (!pDefender)
	{
		setAttackPlot(NULL, false);
		setCombatUnit(NULL);

		if (!bSamePlot)
		{
			getGroup()->groupMove(pPlot, true, (canAdvance(pPlot, 0) ? this : NULL));
		}
		/*GC.getGame().logOOSSpecial(10, getID(), getDamage());*/
		return;
	}
	//check if quick combat
	const bool bQuick = bSamePlot || !isCombatVisible(pDefender);

	const bool bHuman = isHuman();
	const bool bHumanDefender = pDefender->isHuman();

	const PlayerTypes eAttacker = getVisualOwner(pDefender->getTeam());
	const PlayerTypes eDefender = pDefender->getVisualOwner(getTeam());

	//if not finished and not fighting yet, set up combat damage and mission
	CvUnit* firstAttacker = NULL;
	if (!bFinish)
	{
		if (!isInBattle())
		{
			PROFILE("CvUnit::updateCombat.StartFight");

			//TB Combat Mods (Att&DefCounters)
			if (getRoundCount() > 0)
			{
				changeRoundCount(-getRoundCount());
			}
			if (pDefender->getRoundCount() > 0)
			{
				pDefender->changeRoundCount(-pDefender->getRoundCount());
			}
			changeAttackCount(1);
			//TB Combat Mods end
			if (!bSamePlot)
			{
				//rotate to face plot
				DirectionTypes newDirection = estimateDirection(this->plot(), pDefender->plot());
				if (newDirection != NO_DIRECTION)
				{
					setFacingDirection(newDirection);
				}

				//rotate enemy to face us
				newDirection = estimateDirection(pDefender->plot(), this->plot());
				if (newDirection != NO_DIRECTION)
				{
					pDefender->setFacingDirection(newDirection);
				}
			}

			const bool bStealthAttack = isInvisible(GET_PLAYER(pDefender->getOwner()).getTeam(), false, false) || pDefender->plot() == plot();
			if (bStealthAttack)
			{
				if (bHuman)
				{
					AddDLLMessage(
						getOwner(), false, GC.getEVENT_MESSAGE_TIME(),
						gDLL->getText("TXT_KEY_MISC_STEALTH_ATTACK_OWNER", getNameKey(), GET_PLAYER(eDefender).getNameKey(), pDefender->getNameKey()),
						"AS2D_EXPOSED", MESSAGE_TYPE_MINOR_EVENT, getButton(), GC.getCOLOR_UNIT_TEXT(), getX(), getY(), true, true
					);
				}
				if (bHumanDefender)
				{
					AddDLLMessage(
						pDefender->getOwner(), false, GC.getEVENT_MESSAGE_TIME(),
						gDLL->getText("TXT_KEY_MISC_STEALTH_ATTACK", GET_PLAYER(eAttacker).getNameKey(), getNameKey(), pDefender->getNameKey()),
						"AS2D_EXPOSED", MESSAGE_TYPE_MINOR_EVENT, getButton(), GC.getCOLOR_UNIT_TEXT(), getX(), getY(), true, true
					);
				}
			}
			bool bStealthDefense = false;
			if (bStealthAttack || bStealth)
			{
				const bool bLieInWait = !isInvisible(GET_PLAYER(pDefender->getOwner()).getTeam(), false, false) && pDefender->plot() == plot();

				bStealthDefense = bStealth || bLieInWait;
				if (bStealthDefense && bLieInWait)
				{

					if (bHumanDefender)
					{
						AddDLLMessage(
							pDefender->getOwner(), false, GC.getEVENT_MESSAGE_TIME(),
							gDLL->getText("TXT_KEY_MISC_STEALTH_LIE_IN_WAIT_OWNER", pDefender->getNameKey(), GET_PLAYER(getOwner()).getNameKey(), getNameKey()),
							"AS2D_EXPOSED", MESSAGE_TYPE_MINOR_EVENT, getButton(), GC.getCOLOR_UNIT_TEXT(), getX(), getY(), true, true
						);
					}
					if (bHuman)
					{
						AddDLLMessage(
							getOwner(), false, GC.getEVENT_MESSAGE_TIME(),
							gDLL->getText("TXT_KEY_MISC_STEALTH_LIE_IN_WAIT", GET_PLAYER(eAttacker).getNameKey(), getNameKey(), pDefender->getNameKey()),
							"AS2D_EXPOSED", MESSAGE_TYPE_MINOR_EVENT, getButton(), GC.getCOLOR_UNIT_TEXT(), getX(), getY(), true, true
						);
					}
				}
			}
			m_combatResult.bStealthDefense = bStealthDefense && pDefender->plot() != plot();//Note this information is transferred to bStealthDefense during bFinish routine to help define whether units should lose movement or not.
			//TBMaybeproblem : I'd like to elminate this from attackers in a stealth defense situation - they shouldn't be counted as having attacked for being ambushed.
			if (!canStampede() && !canOnslaught() && !bStealthDefense)
			{
				setMadeAttack(true);
			}
			if (getCombatUnit())
			{
				FErrorMsg("Not expected, though this code is a mess and need a full overhaul");
				getCombatUnit()->setCombatUnit(NULL);
			}
			setCombatUnit(pDefender, true, bQuick, bStealthAttack, bStealthDefense);

			firstAttacker = pDefender->getCombatUnit();

			pDefender->setCombatUnit(this, false, bQuick, bStealthAttack, bStealthDefense);
			//TB Combat Mods (Att&DefCounters)
			pDefender->changeDefenseCount(1);
			//TB Combat Mods end

			if (!firstAttacker)
			{
				pDefender->getGroup()->clearMissionQueue();
			}

			if (!bQuick
			&& !firstAttacker
			&& gDLL->getInterfaceIFace()->isCombatFocus()
			&& plot()->isInViewport()
			&& pDefender->isInViewport())
			{ // TBMaybeproblem - is it possible that all this should happen to setup the combat on a surprise defense?
				// It is not currently doing so, perhaps because of fear of the revealed unit not being visible yet?
				DirectionTypes directionType = directionXY(plot(), pPlot);
				//								N			NE				E				SE					S				SW					W				NW
				NiPoint2 directions[8] = {NiPoint2(0, 1), NiPoint2(1, 1), NiPoint2(1, 0), NiPoint2(1, -1), NiPoint2(0, -1), NiPoint2(-1, -1), NiPoint2(-1, 0), NiPoint2(-1, 1)};
				NiPoint3 attackDirection = NiPoint3(directions[directionType].x, directions[directionType].y, 0);
				float plotSize = GC.getPLOT_SIZE();
				NiPoint3 lookAtPoint(plot()->getPoint().x + plotSize / 2 * attackDirection.x, plot()->getPoint().y + plotSize / 2 * attackDirection.y, (plot()->getPoint().z + pPlot->getPoint().z) / 2);
				attackDirection.Unitize();
				gDLL->getInterfaceIFace()->lookAt(lookAtPoint, (((getOwner() != GC.getGame().getActivePlayer()) || gDLL->getGraphicOption(GRAPHICOPTION_NO_COMBAT_ZOOM)) ? CAMERALOOKAT_BATTLE : CAMERALOOKAT_BATTLE_ZOOM_IN), attackDirection);
			}
			else if (bHumanDefender)
			{
				if (BARBARIAN_PLAYER != eAttacker)
				{
					AddDLLMessage(
						pDefender->getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
						gDLL->getText("TXT_KEY_MISC_YOU_UNITS_UNDER_ATTACK", GET_PLAYER(getOwner()).getNameKey()),
						"AS2D_COMBAT", MESSAGE_TYPE_DISPLAY_ONLY, getButton(), GC.getCOLOR_RED(), pPlot->getX(), pPlot->getY(), true
					);
				}
				else
				{
					AddDLLMessage(
						pDefender->getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
						gDLL->getText("TXT_KEY_MISC_YOU_UNITS_UNDER_ATTACK_UNKNOWN"),
						"AS2D_COMBAT", MESSAGE_TYPE_DISPLAY_ONLY, getButton(), GC.getCOLOR_RED(), pPlot->getX(), pPlot->getY(), true
					);
				}
			}
			//Damage to Attacking Unit from City Defenses
			if (pPlot->isCity(false) && !bSamePlot)
			{
				std::vector<UnitCombatTypes> damagableUnitCombatTypes;

				CvCity* pCity = pPlot->getPlotCity();
				for (std::map<UnitCombatTypes, UnitCombatKeyedInfo>::iterator it = m_unitCombatKeyedInfo.begin(), end = m_unitCombatKeyedInfo.end(); it != end; ++it)
				{
					if (it->second.m_bHasUnitCombat && pCity->canDamageAttackingUnitCombat(it->first))
					{
						damagableUnitCombatTypes.push_back(it->first);
					}
				}
				if (damagableUnitCombatTypes.size() > 0)
				{
					checkCityAttackDefensesDamage(pCity, damagableUnitCombatTypes);
				}
			}
		}
		FAssertMsg(pDefender, "Defender is not assigned a valid value");
		FAssertMsg(plot()->isBattle(), "Current unit instance plot is not fighting as expected");
		FAssertMsg(pPlot->isBattle(), "pPlot is not fighting as expected");

		if (!pDefender->canDefend())
		{
			if (!bQuick)
			{
				addMission(CvMissionDefinition(MISSION_SURRENDER, pPlot, this, pDefender, getCombatTimer() * gDLL->getSecsPerTurn()));

				// Surrender mission
				setCombatTimer(GC.getMissionInfo(MISSION_SURRENDER).getTime());

				GC.getGame().incrementTurnTimer(getCombatTimer());
			}
			else bFinish = true;

			// Kill them!
			pDefender->setDamage(pDefender->getMaxHP());
		}
		//	Need to check the attacker has not already died in the attempt (on building defenses)
		else if (!isDead())
		{
			PROFILE("CvUnit::updateCombat.CanDefend");

			//USE commanders here (so their command points will be decreased) for attacker and defender:
			this->tryUseCommander();
			pDefender->tryUseCommander();

            //USE commodore here (so their command points will be decreased) for attacker and defender:
			this->tryUseCommodore();
           	pDefender->tryUseCommodore();

			CvBattleDefinition kBattle(pPlot, this, pDefender);

			//	Koshling - save pre-combat helath so we can use health loss as
			//	a basis for more granular war weariness
			setupPreCombatDamage();
			pDefender->setupPreCombatDamage();

			resolveCombat(pDefender, pPlot, kBattle, bSamePlot);

			if (!bQuick)
			{
				kBattle.setDamage(BATTLE_UNIT_ATTACKER, BATTLE_TIME_END, getDamage());
				kBattle.setDamage(BATTLE_UNIT_DEFENDER, BATTLE_TIME_END, pDefender->getDamage());
				if (!bSamePlot)
				{
					kBattle.setAdvanceSquare(canAdvance(pPlot, pDefender->isDead() ? 0 : 1));
				}

				if (isRanged() && pDefender->isRanged())
				{
					kBattle.setDamage(BATTLE_UNIT_ATTACKER, BATTLE_TIME_RANGED, kBattle.getDamage(BATTLE_UNIT_ATTACKER, BATTLE_TIME_END));
					kBattle.setDamage(BATTLE_UNIT_DEFENDER, BATTLE_TIME_RANGED, kBattle.getDamage(BATTLE_UNIT_DEFENDER, BATTLE_TIME_END));
				}
				else
				{
					kBattle.addDamage(BATTLE_UNIT_ATTACKER, BATTLE_TIME_RANGED, kBattle.getDamage(BATTLE_UNIT_ATTACKER, BATTLE_TIME_BEGIN));
					kBattle.addDamage(BATTLE_UNIT_DEFENDER, BATTLE_TIME_RANGED, kBattle.getDamage(BATTLE_UNIT_DEFENDER, BATTLE_TIME_BEGIN));
				}

				const int iTurns = planBattle(kBattle);
				kBattle.setMissionTime(iTurns * gDLL->getSecsPerTurn());

				setCombatTimer(firstAttacker ? std::max(firstAttacker->getCombatTimer() + 1, iTurns) : iTurns);

				GC.getGame().incrementTurnTimer(iTurns);

				//TB Debug: Without plot set, this routine ended up causing a crash at addMission below.

				if (pPlot->isActiveVisible(false) && !pDefender->isUsingDummyEntities())
				{
					//TB sameplot?
					ExecuteMove(0.5f, true);
					addMission(kBattle);
				}
			}
			else if (m_combatResult.bStealthDefense)
			{
				// Stealth defense is initialized in the bFinish section,
				//	so the previous fight should wrap up before this next combat does so.
				//	so add one to the timer for it to be queued for the next round of quick combat.
				setCombatTimer(1);
				GC.getGame().incrementTurnTimer(1);
			}
			else bFinish = true; // No need to update timers for quick combat
		}
		else bFinish = true; //Attacker died before it could even engage
	}

	if (bFinish)
	{
		PROFILE("CvUnit::updateCombat.Finish");

		const bool bStealthDefense = m_combatResult.bStealthDefense;
#ifdef STRENGTH_IN_NUMBERS
		//TB Combat Mod begin
		if (GC.getGame().isOption(GAMEOPTION_COMBAT_STRENGTH_IN_NUMBERS))
		{
			ClearSupports();
		}
#endif // STRENGTH_IN_NUMBERS

#ifdef OUTBREAKS_AND_AFFLICTIONS
		//TB Combat Mod (Afflict) begin
		if (GC.getGame().isOption(GAMEOPTION_COMBAT_OUTBREAKS_AND_AFFLICTIONS))
		{
			for (int iI = 0; iI < GC.getNumPromotionLineInfos(); iI++)
			{
				if (m_combatResult.bAttackerInjured
				&&
				(
					pDefender->isDead()
					|| m_combatResult.bDefenderWithdrawn
					|| m_combatResult.bDefenderKnockedBack
					|| m_combatResult.bAttackerRepelled
					|| m_combatResult.bAttackerWithdraws
				)
				&& GC.getPromotionLineInfo((PromotionLineTypes)iI).isAffliction()
				&& !GC.getPromotionLineInfo((PromotionLineTypes)iI).isCritical())
				{
					const PromotionLineTypes eAfflictionLine = (PromotionLineTypes)iI;

					if (pDefender->hasAfflictOnAttackType(eAfflictionLine)
					&& !pDefender->isAfflictOnAttackTypeAttempted(eAfflictionLine)
					// Distance Qualifier
					&&
					(
						m_combatResult.bDefenderHitAttackerWithDistanceAttack
						&& pDefender->isAfflictOnAttackTypeDistance(eAfflictionLine)
						|| pDefender->isAfflictOnAttackTypeMelee(eAfflictionLine)
						&& !m_combatResult.bNeverMelee
					))
					{
						const int iDefendersPoisonChance =
						(
							pDefender->getAfflictOnAttackTypeProbability(eAfflictionLine)
							- fortitudeTotal() - getUnitAfflictionTolerance(eAfflictionLine)
						);
						if (GC.getGame().getSorenRandNum(100, "DefendersPoisonRoll") < iDefendersPoisonChance)
						{
							afflict(eAfflictionLine, true, pDefender);
						}
						pDefender->setAfflictOnAttackTypeAttemptedCount(eAfflictionLine, 1);
					}
					//Battle proximity communicability affliction spread
					if (!m_combatResult.bNeverMelee && pDefender->hasAfflictionLine(eAfflictionLine) && GC.getPromotionLineInfo(eAfflictionLine).getCommunicability() > 0 && !GC.getPromotionLineInfo(eAfflictionLine).isNoSpreadonBattle())
					{
						const int iDefendersChancetoAfflict = getChancetoContract(eAfflictionLine) + pDefender->worsenedProbabilitytoAfflict(eAfflictionLine);

						if (GC.getGame().getSorenRandNum(100, "DefenderCauseContractRoll") < iDefendersChancetoAfflict)
						{
							afflict(eAfflictionLine, false, pDefender);
						}
					}
				}
				if (m_combatResult.bDefenderInjured
				&&
				(
					isDead()
					|| m_combatResult.bDefenderWithdrawn
					|| m_combatResult.bDefenderKnockedBack
					|| m_combatResult.bAttackerRepelled
					|| m_combatResult.bAttackerWithdraws
				)
				&& GC.getPromotionLineInfo((PromotionLineTypes)iI).isAffliction()
				&& !GC.getPromotionLineInfo((PromotionLineTypes)iI).isCritical())
				{
					const PromotionLineTypes eAfflictionLine = (PromotionLineTypes)iI;
					if (hasAfflictOnAttackType(eAfflictionLine)
					&& !isAfflictOnAttackTypeAttempted(eAfflictionLine)
					&&
					(
						m_combatResult.bDefenderHitAttackerWithDistanceAttack
						&& isAfflictOnAttackTypeDistance(eAfflictionLine)
						|| isAfflictOnAttackTypeMelee(eAfflictionLine)
						&& !m_combatResult.bNeverMelee
					))
					{
						const int iAttackersPoisonChance =
						(
							getAfflictOnAttackTypeProbability(eAfflictionLine)
							- pDefender->fortitudeTotal()
							- pDefender->getUnitAfflictionTolerance(eAfflictionLine)
						);
						if (GC.getGame().getSorenRandNum(100, "AttackersPoisonRoll") < iAttackersPoisonChance)
						{
							pDefender->afflict(eAfflictionLine, true, this);
						}
						setAfflictOnAttackTypeAttemptedCount(eAfflictionLine, 1);
					}
					//Communicability exposure
					if (!m_combatResult.bNeverMelee && hasAfflictionLine(eAfflictionLine) && GC.getPromotionLineInfo(eAfflictionLine).getCommunicability() > 0 && !GC.getPromotionLineInfo(eAfflictionLine).isNoSpreadonBattle())
					{
						const int iAttackersChancetoAfflict = pDefender->getChancetoContract(eAfflictionLine) + worsenedProbabilitytoAfflict(eAfflictionLine);

						if (GC.getGame().getSorenRandNum(100, "AttackerCauseContractRoll") < iAttackersChancetoAfflict)
						{
							pDefender->afflict(eAfflictionLine, false, this);
						}
					}
				}
			}
		}
		//TB Combat Mod (Afflict) end
#endif // OUTBREAKS_AND_AFFLICTIONS

		//TB Combat Mod (Stampede/Onslaught)
		if (pDefender->isDead() || m_combatResult.bDefenderWithdrawn || m_combatResult.bDefenderKnockedBack || m_combatResult.bAttackerRepelled || m_combatResult.bAttackerWithdraws)
		{
			if (!bSamePlot && canStampede() && pPlot->getNumVisiblePotentialEnemyDefenders(this) > 1)
			{
				m_combatResult.bAttackerStampedes = true;
			}
			if (!bSamePlot && canOnslaught() && (getDamage() == 0) && pPlot->getNumVisiblePotentialEnemyDefenders(this) > 1)
			{
				m_combatResult.bAttackerOnslaught = true;
			}
		}
		if (isDead() || pDefender->isDead() || m_combatResult.bDefenderWithdrawn || m_combatResult.bDefenderKnockedBack || m_combatResult.bAttackerRepelled || m_combatResult.bAttackerWithdraws)
		{
			//Sustain Reports
			//Pursuit Reports
			if (m_combatResult.bAttackerPursuedSustain)
			{
				if (bHuman)
				{

					if (BARBARIAN_PLAYER != eDefender)
					{
						AddDLLMessage(
							getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
							gDLL->getText("TXT_KEY_MISC_ATTACKER_PURSUED_SUSTAIN_HUMAN", getNameKey(), pDefender->getVisualCivAdjective(pDefender->getTeam()), pDefender->getNameKey()),
							"AS2D_OUR_WITHDRAWL", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_YELLOW(), pPlot->getX(), pPlot->getY()
						);
					}
					else
					{
						AddDLLMessage(
							getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
							gDLL->getText("TXT_KEY_MISC_ATTACKER_PURSUED_SUSTAIN_HUMAN_HIDDEN", getNameKey(), pDefender->getNameKey()),
							"AS2D_OUR_WITHDRAWL", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_YELLOW(), pPlot->getX(), pPlot->getY()
						);
					}
				}
				if (bHumanDefender)
				{

					if (BARBARIAN_PLAYER != eAttacker)
					{
						AddDLLMessage(
							pDefender->getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
							gDLL->getText("TXT_KEY_MISC_ATTACKER_PURSUED_SUSTAIN", getVisualCivAdjective(getTeam()), getNameKey(), pDefender->getNameKey()),
							"AS2D_OUR_WITHDRAWL", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_GREEN(), pPlot->getX(), pPlot->getY()
						);
					}
					else
					{
						AddDLLMessage(
							pDefender->getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
							gDLL->getText("TXT_KEY_MISC_ATTACKER_PURSUED_SUSTAIN_HIDDEN", getNameKey(), pDefender->getNameKey()),
							"AS2D_OUR_WITHDRAWL", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_GREEN(), pPlot->getX(), pPlot->getY()
						);
					}
				}
				m_combatResult.bAttackerPursuedSustain = false;
			}
			if (m_combatResult.bDefenderPursuedSustain)
			{
				if (bHuman)
				{
					if (BARBARIAN_PLAYER != eDefender)
					{
						AddDLLMessage(
							getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
							gDLL->getText(
								"TXT_KEY_MISC_DEFENDER_PURSUED_SUSTAIN_HUMAN",
								getNameKey(), pDefender->getVisualCivAdjective(pDefender->getTeam()), pDefender->getNameKey()
							),
							"AS2D_OUR_WITHDRAWL", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_GREEN(), pPlot->getX(), pPlot->getY()
						);
					}
					else
					{
						AddDLLMessage(
							getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
							gDLL->getText("TXT_KEY_MISC_DEFENDER_PURSUED_SUSTAIN_HUMAN_HIDDEN", getNameKey(), pDefender->getNameKey()),
							"AS2D_OUR_WITHDRAWL", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_GREEN(), pPlot->getX(), pPlot->getY()
						);
					}
				}
				if (bHumanDefender)
				{

					if (BARBARIAN_PLAYER != eAttacker)
					{
						AddDLLMessage(
							pDefender->getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
							gDLL->getText("TXT_KEY_MISC_DEFENDER_PURSUED_SUSTAIN", pDefender->getNameKey(), getVisualCivAdjective(getTeam()), getNameKey()),
							"AS2D_OUR_WITHDRAWL", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_YELLOW(), pPlot->getX(), pPlot->getY()
						);
					}
					else
					{
						AddDLLMessage(
							pDefender->getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
							gDLL->getText("TXT_KEY_MISC_DEFENDER_PURSUED_SUSTAIN_HIDDEN", pDefender->getNameKey(),getNameKey()),
							"AS2D_OUR_WITHDRAWL", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_YELLOW(), pPlot->getX(), pPlot->getY()
						);
					}
				}
				m_combatResult.bDefenderPursuedSustain = false;
			}

			//Unyielding Reports
			if (m_combatResult.bAttackerRefusedtoYieldSustain)
			{
				if (bHuman)
				{
					if (BARBARIAN_PLAYER != eAttacker)
					{
						AddDLLMessage(
							getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
							gDLL->getText(
								"TXT_KEY_MISC_ATTACKER_UNYIELDING_SUSTAIN_HUMAN",
								getNameKey(), getVisualCivAdjective(pDefender->getTeam()), pDefender->getNameKey()
							),
							"AS2D_OUR_WITHDRAWL", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_GREEN(), pPlot->getX(), pPlot->getY()
						);
					}
					else
					{
						AddDLLMessage(
							getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
							gDLL->getText("TXT_KEY_MISC_ATTACKER_UNYIELDING_SUSTAIN_HUMAN_HIDDEN", getNameKey(), pDefender->getNameKey()),
							"AS2D_OUR_WITHDRAWL", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_GREEN(), pPlot->getX(), pPlot->getY()
						);
					}
				}
				if (bHumanDefender)
				{
					if (BARBARIAN_PLAYER != eAttacker)
					{
						AddDLLMessage(
							pDefender->getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
							gDLL->getText("TXT_KEY_MISC_ATTACKER_UNYIELDING_SUSTAIN", getVisualCivAdjective(getTeam()), pDefender->getNameKey(), getNameKey()),
							"AS2D_OUR_WITHDRAWL", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_YELLOW(), pPlot->getX(), pPlot->getY()
						);
					}
					else
					{
						AddDLLMessage(
							pDefender->getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
							gDLL->getText("TXT_KEY_MISC_ATTACKER_UNYIELDING_SUSTAIN_HIDDEN", pDefender->getNameKey(), getNameKey()),
							"AS2D_OUR_WITHDRAWL", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_YELLOW(), pPlot->getX(), pPlot->getY()
						);
					}
				}
				m_combatResult.bAttackerRefusedtoYieldSustain = false;
			}
			if (m_combatResult.bDefenderRefusedtoYieldSustain)
			{
				if (bHuman)
				{

					if (BARBARIAN_PLAYER != eDefender)
					{
						AddDLLMessage(
							getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
							gDLL->getText("TXT_KEY_MISC_DEFENDER_UNYIELDING_SUSTAIN_HUMAN", getNameKey(), getVisualCivAdjective(pDefender->getTeam()), pDefender->getNameKey()),
							"AS2D_OUR_WITHDRAWL", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_YELLOW(), pPlot->getX(), pPlot->getY()
						);
					}
					else
					{
						AddDLLMessage(
							getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
							gDLL->getText("TXT_KEY_MISC_DEFENDER_UNYIELDING_SUSTAIN_HUMAN_HIDDEN", getNameKey(), pDefender->getNameKey()),
							"AS2D_OUR_WITHDRAWL", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_YELLOW(), pPlot->getX(), pPlot->getY()
						);
					}
				}
				if (bHumanDefender)
				{

					if (BARBARIAN_PLAYER != eAttacker)
					{
						AddDLLMessage(
							pDefender->getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
							gDLL->getText("TXT_KEY_MISC_DEFENDER_UNYIELDING_SUSTAIN", pDefender->getNameKey(), getVisualCivAdjective(getTeam()), getNameKey()),
							"AS2D_OUR_WITHDRAWL", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_GREEN(), pPlot->getX(), pPlot->getY()
						);
					}
					else
					{
						AddDLLMessage(
							pDefender->getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
							gDLL->getText("TXT_KEY_MISC_DEFENDER_UNYIELDING_SUSTAIN_HIDDEN", pDefender->getNameKey(), getNameKey()),
							"AS2D_OUR_WITHDRAWL", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_GREEN(), pPlot->getX(), pPlot->getY()
						);
					}
				}
				m_combatResult.bDefenderRefusedtoYieldSustain = false;
			}
		}
		//TB Combat Mods End
		//end the combat mission if this code executes first
		if (!isUsingDummyEntities() && isInViewport())
		{
			gDLL->getEntityIFace()->RemoveUnitFromBattle(this);
		}
		if (!pDefender->isUsingDummyEntities() && pDefender->isInViewport())
		{
			gDLL->getEntityIFace()->RemoveUnitFromBattle(pDefender);
		}
		setAttackPlot(NULL, false);
		setCombatUnit(NULL);
		pDefender->setCombatUnit(NULL);

		NotifyEntity(MISSION_DAMAGE);
		pDefender->NotifyEntity(MISSION_DAMAGE);

		if (isDead())
		{
			if (isNPC())
			{
				GET_PLAYER(pDefender->getOwner()).changeWinsVsBarbs(1);
			}

			if (!isHiddenNationality() && !pDefender->isHiddenNationality())
			{
				const int attackerWarWearinessChangeTimes100 = std::max(1, 100 * GC.getDefineINT("WW_UNIT_KILLED_ATTACKING") * (getMaxHP() - getPreCombatDamage()) / getMaxHP());
				GET_TEAM(getTeam()).changeWarWearinessTimes100(pDefender->getTeam(), *pPlot, attackerWarWearinessChangeTimes100);

				const int defenderWarWearinessChangeTimes100 = 100*GC.getDefineINT("WW_KILLED_UNIT_DEFENDING")*(pDefender->getDamage() - pDefender->getPreCombatDamage())/pDefender->getMaxHP();
				GET_TEAM(pDefender->getTeam()).changeWarWearinessTimes100(getTeam(), *pPlot, defenderWarWearinessChangeTimes100);

				GET_TEAM(pDefender->getTeam()).AI_changeWarSuccess(getTeam(), GC.getDefineINT("WAR_SUCCESS_DEFENDING"));
			}

			const int iInfluenceRatio = GC.isIDW_ENABLED() ? pDefender->doVictoryInfluence(this, false, false) : 0;

			if (bHuman)
			{
				CvWString szBuffer;

				if (m_combatResult.bAttackerPursued)
				{
					szBuffer = gDLL->getText("TXT_KEY_MISC_PURSUIT_VICTIM", getNameKey(), pDefender->getNameKey());
				}
				else if (m_combatResult.bAttackerRefusedtoYield)
				{
					szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_UNYIELDING_UNIT_DIED_ATTACKING", getNameKey(), pDefender->getNameKey());
				}
				else if (m_combatResult.bDefenderRefusedtoYield)
				{
					szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_UNIT_DIED_ATTACKING_UNYIELDING", getNameKey(), pDefender->getNameKey());
				}
				else szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_UNIT_DIED_ATTACKING", getNameKey(), pDefender->getNameKey());

				if (iInfluenceRatio > 0)
				{
					szBuffer = szBuffer + CvString::format(" %s: -%.1f%%", gDLL->getText("TXT_KEY_TILE_INFLUENCE").GetCString(), ((float)iInfluenceRatio)/10);
				}
				AddDLLMessage(
					getOwner(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer,
					GC.getEraInfo(GC.getGame().getCurrentEra()).getAudioUnitDefeatScript(),
					MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_RED(), pPlot->getX(), pPlot->getY()
				);
			}
			LOG_UNIT_BLOCK(3, {
				CvWString StrunitAIType = GC.getUnitAIInfo(AI_getUnitAIType()).getType();
				CvWString StrUnitName = m_szName;
				if (StrUnitName.length() == 0)
				{
					StrUnitName = getName(0).GetCString();
				}
				logBBAI("	Player %d Unit ID %d, %S of Type %S at (%d,%d) [stack size %d] died.", getOwner(), getID(), StrUnitName.GetCString(), StrunitAIType.GetCString(), getX(), getY(), getGroup()->getNumUnits());
			});



			if (bHumanDefender)
			{
				CvWString szBuffer;

				if (m_combatResult.bAttackerPursued)
				{
					szBuffer = gDLL->getText("TXT_KEY_MISC_PURSUIT_SUCCESS", getNameKey(), pDefender->getNameKey());
				}
				else if (m_combatResult.bAttackerRefusedtoYield)
				{
					szBuffer = gDLL->getText("TXT_KEY_MISC_UNYIELDING_ATTACKER_YOU_KILLED", getNameKey(), pDefender->getNameKey());
				}
				else if (m_combatResult.bDefenderRefusedtoYield)
				{
					szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_KILLED_ATTACKER_WHILEUNYIELDING", getNameKey(), pDefender->getNameKey());
				}
				else if (BARBARIAN_PLAYER != eAttacker)
				{
					szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_KILLED_ENEMY_UNIT", pDefender->getNameKey(), getNameKey(), getVisualCivAdjective(pDefender->getTeam()));
				}
				else szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_KILLED_ENEMY_UNIT_HIDDEN", pDefender->getNameKey(), getNameKey());

				if (iInfluenceRatio > 0)
				{
					szBuffer = szBuffer + CvString::format(" %s: +%.1f%%", gDLL->getText("TXT_KEY_TILE_INFLUENCE").GetCString(), ((float)iInfluenceRatio)/10);
				}
				AddDLLMessage(
					pDefender->getOwner(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer,
					GC.getEraInfo(GC.getGame().getCurrentEra()).getAudioUnitVictoryScript(),
					MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_GREEN(), pPlot->getX(), pPlot->getY()
				);
			}

			int iUnitsHealed = 0;
			if (pDefender->getVictoryAdjacentHeal() > 0
			&& GC.getGame().getSorenRandNum(100, "Field Hospital Die Roll") <= pDefender->getVictoryAdjacentHeal())
			{
				foreach_(const CvPlot* pLoopPlot, pPlot->adjacent() | filtered(CvPlot::fn::area() == pPlot->area()))
				{
					foreach_(CvUnit* pLoopUnit, pLoopPlot->units())
					{
						if (pLoopUnit->getTeam() == pDefender->getTeam() && pLoopUnit->isHurt())
						{
							iUnitsHealed++;
							pLoopUnit->doHeal();
						}
					}
				}
			}

			if (pDefender->getVictoryStackHeal() > 0
			&& GC.getGame().getSorenRandNum(100, "Field Surgeon Die Roll") <= pDefender->getVictoryStackHeal())
			{
				foreach_(CvUnit* pLoopUnit, pPlot->units())
				{
					if (pLoopUnit->getTeam() == pDefender->getTeam() && pLoopUnit->isHurt())
					{
						iUnitsHealed++;
						pLoopUnit->doHeal();
					}
				}
			}
			else if (pDefender->getVictoryHeal() > 0 && pDefender->isHurt()
			&& GC.getGame().getSorenRandNum(100, "Field Medic Die Roll") <= pDefender->getVictoryHeal())
			{
				pDefender->doHeal();
			}

			if (iUnitsHealed > 1)
			{
				if (bHuman)
				{
					if (BARBARIAN_PLAYER != eAttacker)
					{
						AddDLLMessage(
							getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
							gDLL->getText("TXT_KEY_MISC_ENEMY_FIELD_MEDIC_DEFENDERS", GET_PLAYER(pDefender->getOwner()).getCivilizationAdjective()),
							"AS2D_COMBAT", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_YELLOW(), pDefender->getX(), pDefender->getY()
						);
					}
					else
					{
						AddDLLMessage(
							getOwner(), true, GC.getEVENT_MESSAGE_TIME(), gDLL->getText("TXT_KEY_MISC_ENEMY_FIELD_MEDIC_DEFENDERS_HIDDEN"),
							"AS2D_COMBAT", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_YELLOW(), pDefender->getX(), pDefender->getY()
						);
					}
				}
				if (bHumanDefender)
				{
					AddDLLMessage(
						pDefender->getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
						gDLL->getText("TXT_KEY_MISC_FIELD_MEDIC_DEFENDERS", pDefender->getNameKey(), iUnitsHealed),
						"AS2D_POSITIVE_DINK", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_GREEN(), pDefender->getX(), pDefender->getY()
					);
				}
			}

			if (pDefender->getDefensiveVictoryMoveCount() > 0)
			{
				pDefender->changeMoves(-GC.getMOVE_DENOMINATOR());
			}

			if (getSurvivorChance() > 0
			&& GC.getGame().getSorenRandNum(100, "Too Badass Check") <= getSurvivorChance())
			{
				setSurvivor(true);
				jumpToNearestValidPlot();
			}
			else if (isOneUp())
			{
				setCanRespawn(true);
			}

			if (pDefender->isPillageOnVictory())
			{
				CvPlot* pDefenderPlot = pDefender->plot();
				int iPillageGold = getLevel() * getExperience();
				if (NO_UNIT != getLeaderUnitType())
				{
					iPillageGold *= getLevel();
				}

				if (iPillageGold > 0)
				{
					iPillageGold += (iPillageGold * pDefender->getPillageChange()) / 100;
					GET_PLAYER(pDefender->getOwner()).changeGold(iPillageGold);

					if (bHuman)
					{
						if (BARBARIAN_PLAYER != eDefender)
						{
							AddDLLMessage(
								getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
								gDLL->getText("TXT_KEY_MISC_GOLD_LOOTED_FROM_DEAD", getNameKey(), pDefender->getVisualCivAdjective(pDefender->getTeam())),
								"AS2D_PILLAGED", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_YELLOW(), pDefenderPlot->getX(), pDefenderPlot->getY()
							);
						}
						else
						{
							AddDLLMessage(
								getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
								gDLL->getText("TXT_KEY_MISC_GOLD_LOOTED_FROM_DEAD_HIDDEN", getNameKey()),
								"AS2D_PILLAGED", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_YELLOW(), pDefenderPlot->getX(), pDefenderPlot->getY()
							);
						}
					}

					for (int iI = 0; iI < NUM_COMMERCE_TYPES; ++iI)
					{
						TechTypes ePillageTech = GET_PLAYER(pDefender->getOwner()).getCurrentResearch();
						CommerceTypes eCommerce = (CommerceTypes)iI;
						switch (eCommerce)
						{
						case COMMERCE_GOLD:
							if (pDefender->isPillageMarauder())
							{
								GET_PLAYER(pDefender->getOwner()).changeGold(iPillageGold);
								if (bHumanDefender)
								{
									AddDLLMessage(
										pDefender->getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
										gDLL->getText("TXT_KEY_MISC_MARAUDERS_PLUNDERED_VICTIMS", iPillageGold, pDefender->getNameKey()),
										"AS2D_PILLAGE", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_GREEN(), pDefenderPlot->getX(), pDefenderPlot->getY()
									);
								}
								if (bHuman)
								{
									if (BARBARIAN_PLAYER != eDefender)
									{
										AddDLLMessage(
											getOwner(), false, GC.getEVENT_MESSAGE_TIME(),
											gDLL->getText("TXT_KEY_MISC_DEFENDED_BY_MARAUDERS", getNameKey(), getVisualCivAdjective(pDefender->getTeam())),
											"AS2D_PILLAGED", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_YELLOW(), pDefenderPlot->getX(), pDefenderPlot->getY(), true, true
										);
									}
									else
									{
										AddDLLMessage(
											getOwner(), false, GC.getEVENT_MESSAGE_TIME(),
											gDLL->getText("TXT_KEY_MISC_DEFENDED_BY_MARAUDERS_HIDDEN", getNameKey()),
											"AS2D_PILLAGED", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_YELLOW(), pDefenderPlot->getX(), pDefenderPlot->getY(), true, true
										);
									}
								}
							}
							break;
						case COMMERCE_RESEARCH:
							if (pDefender->isPillageResearch())
							{
								GET_TEAM(GET_PLAYER(pDefender->getOwner()).getTeam()).changeResearchProgress(ePillageTech, iPillageGold, pDefender->getOwner());
								if (bHumanDefender)
								{
									if (BARBARIAN_PLAYER != eDefender)
									{
										AddDLLMessage(
											pDefender->getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
											gDLL->getText(
												"TXT_KEY_MISC_PLUNDERED_RESEARCH_FROM_VICTIMS",
												iPillageGold, pDefender->getNameKey(), getVisualCivAdjective(getTeam()), ePillageTech
											),
											"AS2D_PILLAGE", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_GREEN(), pDefenderPlot->getX(), pDefenderPlot->getY()
										);
									}
									else
									{
										AddDLLMessage(
											pDefender->getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
											gDLL->getText("TXT_KEY_MISC_PLUNDERED_RESEARCH_FROM_VICTIMS_HIDDEN", iPillageGold, pDefender->getNameKey(), ePillageTech),
											"AS2D_PILLAGE", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_GREEN(), pDefenderPlot->getX(), pDefenderPlot->getY()
										);
									}
								}
							}
							break;
						case COMMERCE_CULTURE:
							break;
						case COMMERCE_ESPIONAGE:
							if (pDefender->isPillageEspionage() && pDefenderPlot->getTeam() != NO_TEAM)
							{
								GET_TEAM(GET_PLAYER(pDefender->getOwner()).getTeam()).changeEspionagePointsAgainstTeam(getTeam(), iPillageGold);
								if (bHumanDefender)
								{
									if (BARBARIAN_PLAYER != eDefender)
									{
										AddDLLMessage(
											pDefender->getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
											gDLL->getText("TXT_KEY_MISC_PLUNDERED_ESPIONAGE_FROM_VICTIMS", iPillageGold, getVisualCivAdjective(getTeam()), pDefender->getNameKey()),
											"AS2D_PILLAGE", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_GREEN(), pDefenderPlot->getX(), pDefenderPlot->getY()
										);
									}
									else
									{
										AddDLLMessage(
											pDefender->getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
											gDLL->getText("TXT_KEY_MISC_PLUNDERED_ESPIONAGE_FROM_VICTIMS_HIDDEN", iPillageGold, pDefender->getNameKey()),
											"AS2D_PILLAGE", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_GREEN(), pDefenderPlot->getX(), pDefenderPlot->getY()
										);
									}
								}
							}
							break;
						}
					}
				}
			}

			// report event to Python, along with some other key state
			CvEventReporter::getInstance().combatResult(pDefender, this);

			CvOutcomeListMerged list;
			list.addOutcomeList(getUnitInfo().getKillOutcomeList());
			//getUnitInfo().getKillOutcomeList()->execute(*pDefender, getOwner(), getUnitType());
			for (int iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
			{
				const UnitCombatTypes eCombat = (UnitCombatTypes)iI;
				if (isHasUnitCombat(eCombat))
				{
					list.addOutcomeList(GC.getUnitCombatInfo(eCombat).getKillOutcomeList());
					//pOutcomeList->execute(*pDefender, getOwner(), getUnitType());
				}
			}
			list.execute(*pDefender, getOwner(), getUnitType());

			return;
		}

		if (m_combatResult.bDefenderWithdrawn)
		{
			if (!m_combatResult.bAttackerOnslaught)
			{
				if (!m_combatResult.bAttackerStampedes)
				{
					if (bHuman)
					{
						AddDLLMessage(
							getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
							gDLL->getText("TXT_KEY_MISC_ENEMY_UNIT_WITHDRAW", pDefender->getNameKey(), getNameKey()),
							"AS2D_OUR_WITHDRAWL", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_YELLOW(), pPlot->getX(), pPlot->getY()
						);
					}
					if (bHumanDefender)
					{
						AddDLLMessage(
							pDefender->getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
							gDLL->getText("TXT_KEY_MISC_YOU_UNIT_WITHDRAW", pDefender->getNameKey(), getNameKey()),
							"AS2D_THEIR_WITHDRAWL", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_GREEN(), pPlot->getX(), pPlot->getY()
						);
					}
				}
				else
				{
					if (bHuman)
					{
						AddDLLMessage(
							getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
							gDLL->getText("TXT_KEY_MISC_ENEMY_UNIT_WITHDRAW_STAMPEDE", pDefender->getNameKey(), getNameKey()),
							"AS2D_OUR_WITHDRAWL", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_YELLOW(), pPlot->getX(), pPlot->getY()
						);
					}
					if (bHumanDefender)
					{
						AddDLLMessage(
							pDefender->getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
							gDLL->getText("TXT_KEY_MISC_YOU_UNIT_WITHDRAW_STAMPEDE", pDefender->getNameKey(), getNameKey()),
							"AS2D_THEIR_WITHDRAWL", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_GREEN(), pPlot->getX(), pPlot->getY()
						);
					}
				}
			}
			else
			{
				if (bHuman)
				{
					AddDLLMessage(
						getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
						gDLL->getText("TXT_KEY_MISC_ENEMY_UNIT_WITHDRAW_ONSLAUGHT", pDefender->getNameKey(), getNameKey()),
						"AS2D_OUR_WITHDRAWL", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_YELLOW(), pPlot->getX(), pPlot->getY()
					);
				}
				if (bHumanDefender)
				{
					AddDLLMessage(
						pDefender->getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
						gDLL->getText("TXT_KEY_MISC_YOU_UNIT_WITHDRAW_ONSLAUGHT", pDefender->getNameKey(), getNameKey()),
						"AS2D_THEIR_WITHDRAWL", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_GREEN(), pPlot->getX(), pPlot->getY()
					);
				}
			}

			if (pPlot->isCity())
			{
				m_combatResult.pPlot = NULL;
				//TB Combat Mod (Stampede)
				if (m_combatResult.bAttackerStampedes || m_combatResult.bAttackerOnslaught)
				{
					attack(pPlot);
				}
				else
				{
					const bool bAdvance = !bSamePlot && canAdvance(pPlot, (pDefender->canDefend() && !pDefender->isDead() && pDefender->plot() == pPlot) ? 1 : 0);
					if (bAdvance)
					{
						if (getGroup() != NULL && pPlot->getNumVisiblePotentialEnemyDefenders(this) == 0)
						{
							PROFILE("CvUnit::updateCombat.Advance");
							getGroup()->groupMove(pPlot, true, bAdvance ? this : NULL);
						}
					}
					else if (!m_combatResult.bAttackerStampedes && !m_combatResult.bAttackerOnslaught)
					{
						changeMoves(std::max(GC.getMOVE_DENOMINATOR(), pPlot->movementCost(this, plot())));
					}
				}
				//TB Combat Mod end
			}

			if (m_combatResult.pPlot && !bSamePlot)
			{
				FAssertMsg(m_combatResult.pPlot != plot(), "Can't escape back to attacker plot");
				FAssertMsg(m_combatResult.pPlot != pDefender->plot(), "Can't escape back to own plot");

				//defender escapes to a safe plot
				pDefender->move(m_combatResult.pPlot, true);
				const bool bAdvance = canAdvance(pPlot, (pDefender->canDefend() && !pDefender->isDead() && pDefender->plot() == pPlot) ? 1 : 0);

				//TB Combat Mod (Stampede) begin
				if (m_combatResult.bAttackerStampedes || m_combatResult.bAttackerOnslaught)
				{
					attack(pPlot);
				}
				else if (getGroup())
				{
					if (bAdvance && pPlot->getNumVisiblePotentialEnemyDefenders(this) == 0)
					{
						PROFILE("CvUnit::updateCombat.Advance");

						getGroup()->groupMove(pPlot, true, ((bAdvance) ? this : NULL));
					}
					else if (!bStealthDefense && !m_combatResult.bAttackerStampedes && !m_combatResult.bAttackerOnslaught)
					{
						changeMoves(std::max(GC.getMOVE_DENOMINATOR(), pPlot->movementCost(this, plot())));
					}
				}
				else if (!bStealthDefense)
				{
					changeMoves(std::max(GC.getMOVE_DENOMINATOR(), pPlot->movementCost(this, plot())));
				}
			}
			else if (!bStealthDefense)
			{
				changeMoves(std::max(GC.getMOVE_DENOMINATOR(), pPlot->movementCost(this, plot())));
			}
		}
		else if (m_combatResult.bAttackerRepelled)
		{
			if (!m_combatResult.bAttackerStampedes && !m_combatResult.bAttackerOnslaught)
			{
				if (bHuman)
				{

					if (BARBARIAN_PLAYER != eDefender)
					{
						AddDLLMessage(
							getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
							gDLL->getText(
								"TXT_KEY_MISC_ATTACKER_REPELLED_HUMAN",
								getNameKey(), getVisualCivAdjective(pDefender->getTeam()), pDefender->getNameKey()
							),
							"AS2D_OUR_WITHDRAWL", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_YELLOW(), pPlot->getX(), pPlot->getY()
						);
					}
					else
					{
						AddDLLMessage(
							getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
							gDLL->getText("TXT_KEY_MISC_ATTACKER_REPELLED_HUMAN_HIDDEN", getNameKey(), pDefender->getNameKey()),
							"AS2D_OUR_WITHDRAWL", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_YELLOW(), pPlot->getX(), pPlot->getY()
						);
					}
				}
				if (bHumanDefender)
				{

					if (BARBARIAN_PLAYER != eDefender)
					{
						AddDLLMessage(
							pDefender->getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
							gDLL->getText("TXT_KEY_MISC_ATTACKER_REPELLED", getVisualCivAdjective(getTeam()), getNameKey(), pDefender->getNameKey()),
							"AS2D_THEIR_WITHDRAWL", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_GREEN(), pPlot->getX(), pPlot->getY()
						);
					}
					else
					{
						AddDLLMessage(
							pDefender->getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
							gDLL->getText("TXT_KEY_MISC_ATTACKER_REPELLED_HIDDEN", getNameKey(), pDefender->getNameKey()),
							"AS2D_THEIR_WITHDRAWL", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_GREEN(), pPlot->getX(), pPlot->getY()
						);
					}
				}
			}
			else if (!m_combatResult.bAttackerOnslaught)
			{
				if (bHuman)
				{

					if (BARBARIAN_PLAYER != eDefender)
					{
						AddDLLMessage(
							getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
							gDLL->getText(
								"TXT_KEY_MISC_ATTACKER_REPELLED_HUMAN_STAMPEDE",
								getNameKey(), getVisualCivAdjective(pDefender->getTeam()), pDefender->getNameKey()
							),
							"AS2D_OUR_WITHDRAWL", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_YELLOW(), pPlot->getX(), pPlot->getY()
						);
					}
					else
					{
						AddDLLMessage(
							getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
							gDLL->getText("TXT_KEY_MISC_ATTACKER_REPELLED_HUMAN_STAMPEDE_HIDDEN", getNameKey(), pDefender->getNameKey()),
							"AS2D_OUR_WITHDRAWL", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_YELLOW(), pPlot->getX(), pPlot->getY()
						);
					}
				}
				if (bHumanDefender)
				{

					if (BARBARIAN_PLAYER != eAttacker)
					{
						AddDLLMessage(
							pDefender->getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
							gDLL->getText("TXT_KEY_MISC_ATTACKER_REPELLED_STAMPEDE", getVisualCivAdjective(getTeam()), getNameKey(), pDefender->getNameKey()),
							"AS2D_THEIR_WITHDRAWL", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_GREEN(), pPlot->getX(), pPlot->getY()
						);
					}
					else
					{
						AddDLLMessage(
							pDefender->getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
							gDLL->getText("TXT_KEY_MISC_ATTACKER_REPELLED_STAMPEDE_HIDDEN", getNameKey(), pDefender->getNameKey()),
							"AS2D_THEIR_WITHDRAWL", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_GREEN(), pPlot->getX(), pPlot->getY()
						);
					}
				}
			}
			else
			{
				if (bHuman)
				{
					if (BARBARIAN_PLAYER != eDefender)
					{
						AddDLLMessage(
							getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
							gDLL->getText(
								"TXT_KEY_MISC_ATTACKER_REPELLED_HUMAN_ONSLAUGHT",
								getNameKey(), getVisualCivAdjective(pDefender->getTeam()), pDefender->getNameKey()
							),
							"AS2D_OUR_WITHDRAWL", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_YELLOW(), pPlot->getX(), pPlot->getY()
						);
					}
					else
					{
						AddDLLMessage(
							getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
							gDLL->getText("TXT_KEY_MISC_ATTACKER_REPELLED_HUMAN_ONSLAUGHT_HIDDEN", getNameKey(), pDefender->getNameKey()),
							"AS2D_OUR_WITHDRAWL", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_YELLOW(), pPlot->getX(), pPlot->getY()
						);
					}
				}
				if (bHumanDefender)
				{
					if (BARBARIAN_PLAYER != eAttacker)
					{
						AddDLLMessage(
							pDefender->getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
							gDLL->getText(
								"TXT_KEY_MISC_ATTACKER_REPELLED_ONSLAUGHT",
								getVisualCivAdjective(getTeam()), getNameKey(), pDefender->getNameKey()
							),
							"AS2D_THEIR_WITHDRAWL", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_GREEN(), pPlot->getX(), pPlot->getY()
						);
					}
					else
					{
						AddDLLMessage(
							pDefender->getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
							gDLL->getText("TXT_KEY_MISC_ATTACKER_REPELLED_ONSLAUGHT_HIDDEN", getNameKey(), pDefender->getNameKey()),
							"AS2D_THEIR_WITHDRAWL", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_GREEN(), pPlot->getX(), pPlot->getY()
						);
					}
				}
			}

			m_combatResult.bAttackerRepelled = false;

			if (!m_combatResult.bAttackerStampedes && !m_combatResult.bAttackerOnslaught)
			{
				if (!bStealthDefense)
				{
					changeMoves(std::max(GC.getMOVE_DENOMINATOR(), pPlot->movementCost(this, plot())));
				}
			}
			else attack(pPlot); //TB Combat Mod (Stampede)
		}
		else if (m_combatResult.bDefenderKnockedBack)
		{
			//Knockback
			if (!m_combatResult.bAttackerStampedes && !m_combatResult.bAttackerOnslaught)
			{
				if (bHuman)
				{
					if (BARBARIAN_PLAYER != eDefender)
					{
						AddDLLMessage(
							getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
							gDLL->getText(
								"TXT_KEY_MISC_DEFENDER_KNOCKEDBACK_HUMAN",
								getNameKey(), getVisualCivAdjective(pDefender->getTeam()), pDefender->getNameKey()
							),
							"AS2D_THEIR_WITHDRAWL", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_GREEN(), pPlot->getX(), pPlot->getY()
						);
					}
					else
					{
						AddDLLMessage(
							getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
							gDLL->getText("TXT_KEY_MISC_DEFENDER_KNOCKEDBACK_HUMAN_HIDDEN", getNameKey(), pDefender->getNameKey()),
							"AS2D_THEIR_WITHDRAWL", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_GREEN(), pPlot->getX(), pPlot->getY()
						);
					}
				}
				if (bHumanDefender)
				{
					if (BARBARIAN_PLAYER != eAttacker)
					{
						AddDLLMessage(
							pDefender->getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
							gDLL->getText(
								"TXT_KEY_MISC_DEFENDER_KNOCKEDBACK",
								getVisualCivAdjective(getTeam()), getNameKey(), pDefender->getNameKey()
							),
							"AS2D_OUR_WITHDRAWL", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_YELLOW(), pPlot->getX(), pPlot->getY()
						);
					}
					else
					{
						AddDLLMessage(
							pDefender->getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
							gDLL->getText("TXT_KEY_MISC_DEFENDER_KNOCKEDBACK_HIDDEN", getNameKey(), pDefender->getNameKey()),
							"AS2D_OUR_WITHDRAWL", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_YELLOW(), pPlot->getX(), pPlot->getY()
						);
					}
				}
			}
			else if (!m_combatResult.bAttackerOnslaught)
			{
				if (bHuman)
				{
					if (BARBARIAN_PLAYER != eDefender)
					{
						AddDLLMessage(
							getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
							gDLL->getText(
								"TXT_KEY_MISC_DEFENDER_KNOCKEDBACK_HUMAN_STAMPEDE",
								getNameKey(), getVisualCivAdjective(pDefender->getTeam()), pDefender->getNameKey()
							),
							"AS2D_THEIR_WITHDRAWL", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_GREEN(), pPlot->getX(), pPlot->getY()
						);
					}
					else
					{
						AddDLLMessage(
							getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
							gDLL->getText(
								"TXT_KEY_MISC_DEFENDER_KNOCKEDBACK_HUMAN_STAMPEDE_HIDDEN",
								getNameKey(), pDefender->getNameKey()
							),
							"AS2D_THEIR_WITHDRAWL", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_GREEN(), pPlot->getX(), pPlot->getY()
						);
					}
				}
				if (bHumanDefender)
				{
					if (BARBARIAN_PLAYER != eAttacker)
					{
						AddDLLMessage(
							pDefender->getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
							gDLL->getText(
								"TXT_KEY_MISC_DEFENDER_KNOCKEDBACK_STAMPEDE",
								getVisualCivAdjective(getTeam()), getNameKey(), pDefender->getNameKey()
							),
							"AS2D_OUR_WITHDRAWL", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_YELLOW(), pPlot->getX(), pPlot->getY()
						);
					}
					else
					{
						AddDLLMessage(
							pDefender->getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
							gDLL->getText(
								"TXT_KEY_MISC_DEFENDER_KNOCKEDBACK_STAMPEDE_HIDDEN",
								getNameKey(), pDefender->getNameKey()
							),
							"AS2D_OUR_WITHDRAWL", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_YELLOW(), pPlot->getX(), pPlot->getY()
						);
					}
				}
			}
			else
			{
				if (bHuman)
				{
					if (BARBARIAN_PLAYER != eDefender)
					{
						AddDLLMessage(
							getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
							gDLL->getText(
								"TXT_KEY_MISC_DEFENDER_KNOCKEDBACK_HUMAN_ONSLAUGHT",
								getNameKey(), getVisualCivAdjective(pDefender->getTeam()), pDefender->getNameKey()
							),
							"AS2D_THEIR_WITHDRAWL", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_GREEN(), pPlot->getX(), pPlot->getY()
						);
					}
					else
					{
						AddDLLMessage(
							getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
							gDLL->getText(
								"TXT_KEY_MISC_DEFENDER_KNOCKEDBACK_HUMAN_ONSLAUGHT_HIDDEN",
								getNameKey(), pDefender->getNameKey()
							),
							"AS2D_THEIR_WITHDRAWL", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_GREEN(), pPlot->getX(), pPlot->getY()
						);
					}
				}
				if (bHumanDefender)
				{
					if (BARBARIAN_PLAYER != eAttacker)
					{
						AddDLLMessage(
							pDefender->getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
							gDLL->getText(
								"TXT_KEY_MISC_DEFENDER_KNOCKEDBACK_ONSLAUGHT",
								getVisualCivAdjective(getTeam()), getNameKey(), pDefender->getNameKey()
							),
							"AS2D_OUR_WITHDRAWL", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_YELLOW(), pPlot->getX(), pPlot->getY()
						);
					}
					else
					{
						AddDLLMessage(
							pDefender->getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
							gDLL->getText(
								"TXT_KEY_MISC_DEFENDER_KNOCKEDBACK_ONSLAUGHT_HIDDEN",
								getNameKey(), pDefender->getNameKey()
							),
							"AS2D_OUR_WITHDRAWL", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_YELLOW(), pPlot->getX(), pPlot->getY()
						);
					}
				}
			}
			m_combatResult.bDefenderKnockedBack = false;

			if (pPlot->isCity())
			{
				m_combatResult.pPlot = NULL;
			}
			pDefender->setFortifyTurns(0);

			if (m_combatResult.pPlot != NULL)
			{
				FAssertMsg(m_combatResult.pPlot != plot(), "Can't get knocked back to attacker plot");
				FAssertMsg(m_combatResult.pPlot != pDefender->plot(), "Can't get knocked back to own plot");

				//defender escapes to a safe plot
				pDefender->move(m_combatResult.pPlot, true);
				pDefender->getGroup()->clearMissionQueue();
			}

			const bool bAdvance = canAdvance(pPlot, (pDefender->canDefend() && !pDefender->isDead() && pDefender->plot() == pPlot) ? 1 : 0);

			if (!bAdvance && !m_combatResult.bAttackerStampedes && !m_combatResult.bAttackerOnslaught)
			{
				if (!isNoCapture())
				{
					pDefender->setCapturingPlayer(getOwner());
					pDefender->setCapturingUnit(this);
				}
				if (!bStealthDefense)
				{
					changeMoves(std::max(GC.getMOVE_DENOMINATOR(), pPlot->movementCost(this, plot())));
				}
			}
			else if (m_combatResult.bAttackerStampedes || m_combatResult.bAttackerOnslaught)
			{
				attack(pPlot);
			}

			if (getGroup())
			{
				if (pPlot->getNumVisiblePotentialEnemyDefenders(this) == 0)
				{
					PROFILE("CvUnit::updateCombat.Advance");

					getGroup()->groupMove(pPlot, true, ((bAdvance) ? this : NULL));
				}
				// This is before the plot advancement, the unit will always try to walk back
				// to the square that they came from, before advancing.
			}
		}
		else if (m_combatResult.bAttackerWithdraws)
		{
			if (!m_combatResult.bAttackerStampedes && !m_combatResult.bAttackerOnslaught)
			{
				if (bHuman)
				{
					AddDLLMessage(
						getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
						gDLL->getText("TXT_KEY_MISC_YOU_UNIT_WITHDRAW", getNameKey(), pDefender->getNameKey()),
						"AS2D_OUR_WITHDRAWL", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_GREEN(), pPlot->getX(), pPlot->getY()
					);
				}
				if (bHumanDefender)
				{
					AddDLLMessage(
						pDefender->getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
						gDLL->getText("TXT_KEY_MISC_ENEMY_UNIT_WITHDRAW", getNameKey(), pDefender->getNameKey()),
						"AS2D_THEIR_WITHDRAWL", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_YELLOW(), pPlot->getX(), pPlot->getY()
					);
				}
				changeMoves(std::max(GC.getMOVE_DENOMINATOR(), pPlot->movementCost(this, plot())));
				//GC.getGame().logOOSSpecial(53, getID(), getMoves(), getDamage());
			}
			//TB Combat Mod (Stampede) begin
			else if (m_combatResult.bAttackerStampedes)
			{
				if (bHuman)
				{
					AddDLLMessage(
						getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
						gDLL->getText("TXT_KEY_MISC_YOU_UNIT_ATTACKER_WITHDRAW_STAMPEDE", getNameKey(), pDefender->getNameKey()),
						"AS2D_OUR_WITHDRAWL", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_GREEN(), pPlot->getX(), pPlot->getY()
					);
				}
				if (bHumanDefender)
				{
					AddDLLMessage(
						pDefender->getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
						gDLL->getText("TXT_KEY_MISC_ENEMY_UNIT_ATTACKER_WITHDRAW_STAMPEDE", getNameKey(), pDefender->getNameKey()),
						"AS2D_THEIR_WITHDRAWL", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_YELLOW(), pPlot->getX(), pPlot->getY()
					);
				}
				attack(pPlot);
			}
			else if (m_combatResult.bAttackerOnslaught)
			{
				if (bHuman)
				{
					AddDLLMessage(
						getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
						gDLL->getText("TXT_KEY_MISC_YOU_UNIT_ATTACKER_WITHDRAW_ONSLAUGHT", getNameKey(), pDefender->getNameKey()),
						"AS2D_OUR_WITHDRAWL", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_GREEN(), pPlot->getX(), pPlot->getY()
					);
				}
				if (bHumanDefender)
				{
					AddDLLMessage(
						pDefender->getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
						gDLL->getText("TXT_KEY_MISC_ENEMY_UNIT_ATTACKER_WITHDRAW_ONSLAUGHT", getNameKey(), pDefender->getNameKey()),
						"AS2D_THEIR_WITHDRAWL", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_YELLOW(), pPlot->getX(), pPlot->getY()
					);
				}
				attack(pPlot);
			}
		}
		else if (pDefender->isDead())
		{
			if (pDefender->isNPC())
			{
				GET_PLAYER(getOwner()).changeWinsVsBarbs(1);
			}

			if (!isHiddenNationality() && !pDefender->isHiddenNationality())
			{
				const int defenderWarWearinessChangeTimes100 =
				(
					std::max(
						1,
						100 * GC.getDefineINT("WW_UNIT_KILLED_DEFENDING")
						* (pDefender->getMaxHP() - pDefender->getPreCombatDamage())
						/
						pDefender->getMaxHP()
					)
				);
				GET_TEAM(pDefender->getTeam()).changeWarWearinessTimes100(getTeam(), *pPlot, defenderWarWearinessChangeTimes100);

				const int attackerWarWearinessChangeTimes100 =
				(
					100 * GC.getDefineINT("WW_KILLED_UNIT_ATTACKING")
					* (getDamage() - getPreCombatDamage())
					/
					getMaxHP()
				);
				GET_TEAM(getTeam()).changeWarWearinessTimes100(pDefender->getTeam(), *pPlot, attackerWarWearinessChangeTimes100);

				GET_TEAM(getTeam()).AI_changeWarSuccess(pDefender->getTeam(), GC.getDefineINT("WAR_SUCCESS_ATTACKING"));
			}

			const int iInfluenceRatio = GC.isIDW_ENABLED() ? doVictoryInfluence(pDefender, true, false) : 0;

			if (bHuman)
			{
				CvWString szBuffer;

				if (m_combatResult.bDefenderPursued)
				{
					szBuffer = gDLL->getText("TXT_KEY_MISC_PURSUIT_ONATTACK_SUCCESS", pDefender->getNameKey(), getNameKey());
				}
				else if (m_combatResult.bAttackerRefusedtoYield)
				{
					szBuffer = gDLL->getText("TXT_KEY_MISC_UNYIELDING_YOU_DESTROYED_ENEMY", pDefender->getNameKey(), getNameKey());
				}
				else if (m_combatResult.bDefenderRefusedtoYield)
				{
					szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_UNIT_DESTROYED_UNYIELDING_ENEMY", pDefender->getNameKey(), getNameKey());
				}
				else if (m_combatResult.bAttackerStampedes)
				{
					szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_UNIT_DESTROYED_ENEMY_STAMPEDE", pDefender->getNameKey(), getNameKey());
				}
				else if (m_combatResult.bAttackerOnslaught)
				{
					szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_UNIT_DESTROYED_ENEMY_ONSLAUGHT", pDefender->getNameKey(), getNameKey());
				}
				else szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_UNIT_DESTROYED_ENEMY", getNameKey(), pDefender->getNameKey());

				if (iInfluenceRatio > 0)
				{
					szBuffer = szBuffer + CvString::format(" %s: +%.1f%%", gDLL->getText("TXT_KEY_TILE_INFLUENCE").GetCString(), ((float)iInfluenceRatio)/10);
				}
				AddDLLMessage(
					getOwner(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer,
					GC.getEraInfo(GC.getGame().getCurrentEra()).getAudioUnitVictoryScript(),
					MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_GREEN(), pPlot->getX(), pPlot->getY()
				);
			}
			if (bHumanDefender)
			{
				CvWString szBuffer;

				if (m_combatResult.bDefenderPursued)
				{
					szBuffer = gDLL->getText("TXT_KEY_MISC_PURSUIT_ONATTACK_VICTIM", pDefender->getNameKey(), getNameKey());
				}
				else if (m_combatResult.bAttackerRefusedtoYield)
				{
					if (BARBARIAN_PLAYER != eDefender)
					{
						szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_UNIT_WAS_DESTROYED_BYUNYIELDING_UNKNOWN", pDefender->getNameKey(), getNameKey());
					}
					else szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_UNIT_WAS_DESTROYED_BYUNYIELDING", pDefender->getNameKey(), getVisualCivAdjective(pDefender->getTeam()), getNameKey());
				}
				else if (m_combatResult.bDefenderRefusedtoYield)
				{
					if (BARBARIAN_PLAYER == eDefender)
					{
						szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_UNIT_WAS_DESTROYED_WHILEUNYIELDING_UNKNOWN", pDefender->getNameKey(), getNameKey());
					}
					else szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_UNIT_WAS_DESTROYED_WHILEUNYIELDING", pDefender->getNameKey(), getVisualCivAdjective(pDefender->getTeam()), getNameKey());
				}
				else if (m_combatResult.bAttackerStampedes)
				{
					szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_UNIT_WAS_DESTROYED_ENEMY_STAMPEDE", pDefender->getNameKey(), getNameKey());
				}
				else if (m_combatResult.bAttackerOnslaught)
				{
					szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_UNIT_WAS_DESTROYED_ENEMY_ONSLAUGHT", pDefender->getNameKey(), getNameKey());
				}
				else if (BARBARIAN_PLAYER == eAttacker)
				{
					szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_UNIT_WAS_DESTROYED_UNKNOWN", pDefender->getNameKey(), getNameKey());
				}
				else szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_UNIT_WAS_DESTROYED", pDefender->getNameKey(), getNameKey(), getVisualCivAdjective(pDefender->getTeam()));

				if (iInfluenceRatio > 0)
				{
					szBuffer = szBuffer + CvString::format(" %s: -%.1f%%", gDLL->getText("TXT_KEY_TILE_INFLUENCE").GetCString(), ((float)iInfluenceRatio)/10);
				}
				AddDLLMessage(
					pDefender->getOwner(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer,
					GC.getEraInfo(GC.getGame().getCurrentEra()).getAudioUnitDefeatScript(),
					MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_RED(), pPlot->getX(), pPlot->getY()
				);
			}

			// report event to Python, along with some other key state
			int iUnitsHealed = 0;
			if (getVictoryAdjacentHeal() > 0
			&& GC.getGame().getSorenRandNum(100, "Field Hospital Die Roll") <= getVictoryAdjacentHeal())
			{
				foreach_(const CvPlot* pLoopPlot, pPlot->adjacent() | filtered(CvPlot::fn::area() == pPlot->area()))
				{
					foreach_(CvUnit* pLoopUnit, pLoopPlot->units())
					{
						if (pLoopUnit->getTeam() == getTeam() && pLoopUnit->isHurt())
						{
							iUnitsHealed++;
							pLoopUnit->doHeal();
						}
					}
				}
			}

			if (getVictoryStackHeal() > 0
			&& GC.getGame().getSorenRandNum(100, "Field Surgeon Die Roll") <= getVictoryStackHeal())
			{
				foreach_(CvUnit* pLoopUnit, pPlot->units())
				{
					if (pLoopUnit->getTeam() == getTeam() && pLoopUnit->isHurt())
					{
						iUnitsHealed++;
						pLoopUnit->doHeal();
					}
				}
			}
			else if (getVictoryHeal() > 0 && GC.getGame().getSorenRandNum(100, "Field Medic Die Roll") <= getVictoryHeal())
			{
				doHeal();
			}

			if (iUnitsHealed > 1)
			{
				if (bHumanDefender)
				{
					if (BARBARIAN_PLAYER != eAttacker)
					{
						AddDLLMessage(
							pDefender->getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
							gDLL->getText("TXT_KEY_MISC_ENEMY_FIELD_MEDIC_ATTACKERS", GET_PLAYER(getOwner()).getCivilizationAdjective()),
							"AS2D_COMBAT", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_YELLOW(), getX(), getY(), true, true
						);
					}
					else
					{
						AddDLLMessage(
							pDefender->getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
							gDLL->getText("TXT_KEY_MISC_ENEMY_FIELD_MEDIC_ATTACKERS_HIDDEN"),
							"AS2D_COMBAT", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_YELLOW(), getX(), getY(), true, true
						);
					}
				}
				if (bHuman)
				{
					AddDLLMessage(
						getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
						gDLL->getText("TXT_KEY_MISC_FIELD_MEDIC_ATTACKERS", getNameKey(), iUnitsHealed),
						"AS2D_POSITIVE_DINK", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_GREEN(), getX(), getY()
					);
				}
			}

			if (getOffensiveVictoryMoveCount() > 0)
			{
				changeMoves(-GC.getMOVE_DENOMINATOR());
			}

			if (pDefender->getSurvivorChance() > 0
			&& GC.getGame().getSorenRandNum(100, "Too Badass Check") <= pDefender->getSurvivorChance())
			{
				pDefender->setSurvivor(true);
				pDefender->jumpToNearestValidPlot();
			}
			else if (pDefender->isOneUp())
			{
				CvCity* pCapitalCity = GET_PLAYER(pDefender->getOwner()).getCapitalCity();
				if (pCapitalCity != NULL)
				{
					pDefender->setCanRespawn(true);
				}
			}

			if (isPillageOnVictory())
			{
				CvPlot* pDefenderPlot = (pDefender->plot());
				int iPillageGold = (pDefender->getLevel() * pDefender->getExperience());
				if (NO_UNIT != pDefender->getLeaderUnitType())
				{
					iPillageGold *= pDefender->getLevel();
				}
				if (iPillageGold > 0)
	            {
					iPillageGold += iPillageGold * getPillageChange() / 100;
					GET_PLAYER(getOwner()).changeGold(iPillageGold);

					if (bHuman)
					{
						if (BARBARIAN_PLAYER != eAttacker)
						{
							AddDLLMessage(
								getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
								gDLL->getText("TXT_KEY_MISC_GOLD_LOOTED_FROM_DEAD", pDefender->getNameKey(), getVisualCivAdjective(getTeam())),
								"AS2D_PILLAGED", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_YELLOW(), pDefenderPlot->getX(), pDefenderPlot->getY()
							);
						}
						else
						{
							AddDLLMessage(
								getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
								gDLL->getText("TXT_KEY_MISC_GOLD_LOOTED_FROM_DEAD_HIDDEN", pDefender->getNameKey()),
								"AS2D_PILLAGED", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_YELLOW(), pDefenderPlot->getX(), pDefenderPlot->getY()
							);
						}
					}

					for (int iI = 0; iI < NUM_COMMERCE_TYPES; ++iI)
					{
						TechTypes ePillageTech = GET_PLAYER(getOwner()).getCurrentResearch();
						CommerceTypes eCommerce = (CommerceTypes)iI;
						switch (eCommerce)
						{
						case COMMERCE_GOLD:
							if (isPillageMarauder())
							{
								GET_PLAYER(getOwner()).changeGold(iPillageGold);
								if (bHuman)
								{
									AddDLLMessage(
										getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
										gDLL->getText("TXT_KEY_MISC_MARAUDERS_PLUNDERED_VICTIMS", iPillageGold, getNameKey()),
										"AS2D_PILLAGE", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_GREEN(), pDefenderPlot->getX(), pDefenderPlot->getY()
									);
								}
								if (bHumanDefender)
								{
									if (BARBARIAN_PLAYER != eAttacker)
									{
										AddDLLMessage(
											pDefender->getOwner(), false, GC.getEVENT_MESSAGE_TIME(),
											gDLL->getText("TXT_KEY_MISC_ATTACKED_BY_MARAUDERS", pDefender->getNameKey(), getVisualCivAdjective(getTeam())),
											"AS2D_PILLAGED", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_YELLOW(), pDefenderPlot->getX(), pDefenderPlot->getY(), true, true
										);
									}
									else
									{
										AddDLLMessage(
											pDefender->getOwner(), false, GC.getEVENT_MESSAGE_TIME(),
											gDLL->getText("TXT_KEY_MISC_ATTACKED_BY_MARAUDERS_HIDDEN", pDefender->getNameKey()),
											"AS2D_PILLAGED", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_YELLOW(), pDefenderPlot->getX(), pDefenderPlot->getY(), true, true
										);
									}
								}
							}
							break;
						case COMMERCE_RESEARCH:
							if (isPillageResearch())
							{
								GET_TEAM(GET_PLAYER(getOwner()).getTeam()).changeResearchProgress(ePillageTech, iPillageGold, getOwner());
								if (bHuman)
								{
									if (BARBARIAN_PLAYER != eDefender)
									{
										AddDLLMessage(
											getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
											gDLL->getText(
												"TXT_KEY_MISC_PLUNDERED_RESEARCH_FROM_IMP",
												iPillageGold, getNameKey(), getVisualCivAdjective(pDefender->getTeam()), ePillageTech
											),
											"AS2D_PILLAGE", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_GREEN(), pDefenderPlot->getX(), pDefenderPlot->getY()
										);
									}
									else
									{
										AddDLLMessage(
											getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
											gDLL->getText("TXT_KEY_MISC_PLUNDERED_RESEARCH_FROM_IMP_HIDDEN", iPillageGold, getNameKey(), ePillageTech),
											"AS2D_PILLAGE", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_GREEN(), pDefenderPlot->getX(), pDefenderPlot->getY()
										);
									}
								}
							}
							break;
						case COMMERCE_CULTURE:
							break;
						case COMMERCE_ESPIONAGE:
							if (isPillageEspionage() && pDefenderPlot->getTeam() != NO_TEAM)
							{
								GET_TEAM(GET_PLAYER(getOwner()).getTeam()).changeEspionagePointsAgainstTeam(pDefenderPlot->getTeam(), iPillageGold);

								if (bHuman)
								{
									if (BARBARIAN_PLAYER != eDefender)
									{
										AddDLLMessage(
											getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
											gDLL->getText(
												"TXT_KEY_MISC_PLUNDERED_ESPIONAGE_FROM_IMP",
												iPillageGold, getNameKey(), getVisualCivAdjective(pDefender->getTeam()), ePillageTech
											),
											"AS2D_PILLAGE", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_GREEN(), pDefenderPlot->getX(), pDefenderPlot->getY()
										);
									}
									else
									{
										AddDLLMessage(
											getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
											gDLL->getText("TXT_KEY_MISC_PLUNDERED_ESPIONAGE_FROM_IMP_HIDDEN", iPillageGold, getNameKey(), ePillageTech),
											"AS2D_PILLAGE", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_GREEN(), pDefenderPlot->getX(), pDefenderPlot->getY()
										);
									}
								}
							}
							break;
						}
					}
				}
			}

			CvEventReporter::getInstance().combatResult(this, pDefender);
			PlayerTypes eDefenderUnitPlayer = pDefender->getOwner();
			UnitTypes eDefenderUnitType = pDefender->getUnitType();

			// generate the kill outcome list but don't execute it yet
			//std::vector<UnitCombatTypes> aDefenderCombats;
			CvOutcomeListMerged mergedList;
			mergedList.addOutcomeList(pDefender->getUnitInfo().getKillOutcomeList());
			for (std::map<UnitCombatTypes, UnitCombatKeyedInfo>::const_iterator it = m_unitCombatKeyedInfo.begin(), end = m_unitCombatKeyedInfo.end(); it != end; ++it)
			{
				if(it->second.m_bHasUnitCombat)
				{
					mergedList.addOutcomeList(GC.getUnitCombatInfo((UnitCombatTypes)it->first).getKillOutcomeList());
					//aDefenderCombats.push_back((UnitCombatTypes)it->first);
				}
			}

			if (isSuicide())
			{
				kill(true);

				pDefender->kill(false, NO_PLAYER, true);
				pDefender = NULL;
			}
			else
			{
				if (pPlot == plot())
				{
					bSamePlot = true;
				}
				//TB debug attempt: added && pDefender->plot() == pPlot to try to allow units to move in when one defender on the plot withdrew.
				const bool bAdvance = !bSamePlot && canAdvance(pPlot, pDefender->canDefend() && !pDefender->isDead() && pDefender->plot() == pPlot);

				//TBMaybeproblem - should this come before the generation of the captive which takes place above at the add outcome step?
				if (bAdvance && !isNoCapture())
				{
					pDefender->setCapturingPlayer(getOwner());
					pDefender->setCapturingUnit(this);
				}

				pDefender->killUnconditional(false, NO_PLAYER, true);
				pDefender = NULL;
				//TB Combat Mod (Stampede) begin
				if (!bAdvance && !m_combatResult.bAttackerStampedes && !m_combatResult.bAttackerOnslaught && !bStealthDefense)
				{
					changeMoves(std::max(GC.getMOVE_DENOMINATOR(), pPlot->movementCost(this, plot())));
				}
				if (m_combatResult.bAttackerStampedes || m_combatResult.bAttackerOnslaught)
				{
					attack(pPlot);
				}
				if (bAdvance && (bQuick || !getGroup()->isCombat())) getGroup()->groupMove(pPlot, true, this);
			}
			//TB Combat Mods End

			mergedList.execute(*this, eDefenderUnitPlayer, eDefenderUnitType);
		}

		if (bQuick && IsSelected() && !canMove())
		{
			gDLL->getInterfaceIFace()->removeFromSelectionList(this);
		}
	}
}


bool CvUnit::isActionRecommended(int iAction) const
{
	if (getOwner() != GC.getGame().getActivePlayer()
	|| GET_PLAYER(getOwner()).isOption(PLAYEROPTION_NO_UNIT_RECOMMENDATIONS))
	{
		return false;
	}

	CvPlot* pPlot = gDLL->getInterfaceIFace()->getGotoPlot();

	if (pPlot == NULL && gDLL->shiftKey())
	{
		pPlot = getGroup()->lastMissionPlot();
	}
	if (pPlot == NULL)
	{
		pPlot = plot();
	}

	if (GC.getActionInfo(iAction).getMissionType() == MISSION_FORTIFY)
	{
		if (pPlot->isCity(true, getTeam()) && canDefend(pPlot) && pPlot->getNumDefenders(getOwner()) < (atPlot(pPlot) ? 2 : 1))
		{
			return true;
		}
	}
#ifdef _MOD_SENTRY
	else if (GC.getActionInfo(iAction).getMissionType() == MISSION_HEAL || GC.getActionInfo(iAction).getMissionType() == MISSION_SENTRY_WHILE_HEAL)
#else
	else if(GC.getActionInfo(iAction).getMissionType() == MISSION_HEAL || GC.getActionInfo(iAction).getMissionType() == MISSION_HEAL_BUILDUP)
#endif
	{
		if (isHurt() && !hasMoved() && (pPlot->getTeam() == getTeam() || healTurns(pPlot) > 0))
		{
			return true;
		}
	}
	else if (GC.getActionInfo(iAction).getCommandType() == COMMAND_PROMOTION)
	{
		return true;
	}
	else if (GC.getActionInfo(iAction).getMissionType() == MISSION_BUILD)
	{
		if (pPlot->getOwner() == getOwner())
		{
			const BuildTypes eBuild = (BuildTypes) GC.getActionInfo(iAction).getMissionData();

			FASSERT_BOUNDS(0, GC.getNumBuildInfos(), eBuild);

			if (canBuild(pPlot, eBuild))
			{
				const ImprovementTypes eImprovement = pPlot->getImprovementType();

				// Recommend build
				if (eImprovement == NO_IMPROVEMENT)
				{
					// If City AI wants it
					const CvCity* pWorkingCity = pPlot->getWorkingCity();

					if (pWorkingCity != NULL)
					{
						const int iIndex = pWorkingCity->getCityPlotIndex(pPlot);
						if (iIndex != -1 && pWorkingCity->AI_getBestBuild(iIndex) == eBuild)
						{
							return true;
						}
					}
					// Recommend improvement
					const ImprovementTypes eImprovementNew = GC.getBuildInfo(eBuild).getImprovement();

					if (eImprovementNew != NO_IMPROVEMENT)
					{
						const CvImprovementInfo& improvement = GC.getImprovementInfo(eImprovementNew);

						const BonusTypes eBonus = pPlot->getBonusType(getTeam());

						// If it provides bonus
						if (eBonus != NO_BONUS && improvement.isImprovementBonusTrade(eBonus))
						{
							return true;
						}
						// If it irrigates
						if (improvement.isCarriesIrrigation() && !pPlot->isIrrigated() && pPlot->isIrrigationAvailable(true))
						{
							return true;
						}
						// If it gives yields
						if (pWorkingCity != NULL)
						{
							if (improvement.getYieldChange(YIELD_COMMERCE) > 0)
							{
								return true;
							}
							// Food is only interesting on flatland/water
							if (improvement.getYieldChange(YIELD_FOOD) > 0 && !pPlot->isHills() && !pPlot->isAsPeak())
							{
								return true;
							}
							if (improvement.getYieldChange(YIELD_PRODUCTION) > 0)
							{
								return true;
							}
						}
					}
				}
				// Recommend route
				const RouteTypes eRouteNew = (RouteTypes) GC.getBuildInfo(eBuild).getRoute();

				if (eRouteNew != NO_ROUTE)
				{
					// If bonus with no route
					if (!pPlot->isRoute() && pPlot->getBonusType(getTeam()) != NO_BONUS)
					{
						return true;
					}
					// If route improves yields from improvement
					if (eImprovement != NO_IMPROVEMENT
					&& (
						GC.getImprovementInfo(eImprovement).getRouteYieldChanges(eRouteNew, YIELD_FOOD) > 0
					||	GC.getImprovementInfo(eImprovement).getRouteYieldChanges(eRouteNew, YIELD_PRODUCTION) > 0
					||	GC.getImprovementInfo(eImprovement).getRouteYieldChanges(eRouteNew, YIELD_COMMERCE) > 0))
					{
						return true;
					}
				}
			}
		}
	}
	else if (GC.getActionInfo(iAction).getMissionType() == MISSION_FOUND)
	{
		if (canFound(pPlot) && pPlot->isBestAdjacentFound(getOwner()))
		{
			return true;
		}
	}
	return false;
}

int CvUnit::defenderValue(const CvUnit* pAttacker) const
{
	PROFILE_EXTRA_FUNC();
	if (pAttacker)
	{
		if (pAttacker->getDomainType() == DOMAIN_AIR)
		{
			// Does my current damage exceed the attackers damage limit?
			if (getDamage() >= pAttacker->airCombatLimit(this))
			{
				return 0;
			}
		}
		else if ((!isAnimal() && canCoexistWithAttacker(*pAttacker)) || !pAttacker->canAttack(*this))
		{
			return 0;
		}
	}
	if (!canDefend())
	{
		return 1;
	}
	int iValue = 2 + currCombatStr(plot(), pAttacker);

	if (isHurt() && ::isWorldUnit(getUnitType()))
	{
		iValue *= 3;
		iValue /= 4;
	}

	if (pAttacker)
	{
		if (!pAttacker->immuneToFirstStrikes())
		{
			iValue *= 100 + (firstStrikes() * 2 + chanceFirstStrikes()) * (GC.getCOMBAT_DAMAGE() * 2 / 5);
			iValue /= 100;
		}
		if (immuneToFirstStrikes())
		{
			iValue *= 100 + (pAttacker->firstStrikes() * 2 + pAttacker->chanceFirstStrikes()) * (GC.getCOMBAT_DAMAGE() * 2 / 5);
			iValue /= 100;
		}
	}
	else
	{
		if (collateralDamage() > 0)
		{
			iValue *= 100;
			iValue /= 100 + collateralDamage();
		}
		if (currInterceptionProbability() > 0)
		{
			iValue *= 100;
			iValue /= 100 + currInterceptionProbability();
		}
	}

	{
		const int iAssetValue = std::max(1, assetValueTotal()/100);
		int iCargoAssetValue = 0;
		std::vector<CvUnit*> aCargoUnits;
		getCargoUnits(aCargoUnits);
		foreach_(const CvUnit* pCargo, aCargoUnits)
		{
			iCargoAssetValue += std::max(1, pCargo->assetValueTotal()/100);
		}
		iValue = iValue * iAssetValue / std::max(1, iAssetValue + iCargoAssetValue);
	}

	if (NO_UNIT == getLeaderUnitType())
	{
		++iValue;
	}
	iValue += tauntTotal() * iValue / 100;

	// It should be greater than 0 as this target is at least valid as per the checks above
	if (pAttacker && isTargetOf(*pAttacker))
	{
		return std::max(1000000, std::min(MAX_INT, iValue + 1000000));
	}
	return std::max(1, iValue);
}

bool CvUnit::isBetterDefenderThan(const CvUnit* pDefender, const CvUnit* pAttacker) const
{
	PROFILE_EXTRA_FUNC();

	if (!pDefender) return true;

	const TeamTypes eAttackerTeam = pAttacker ? pAttacker->getTeam() : NO_TEAM;

	if (alwaysInvisible() || getTeam() == eAttackerTeam || !canDefend())
	{
		return false;
	}

	if (!pDefender->canDefend())
	{
		return true;
	}

	if (pAttacker)
	{
		if (isTargetOf(*pAttacker) && !pDefender->isTargetOf(*pAttacker))
		{
			return true;
		}

		if (!isTargetOf(*pAttacker) && pDefender->isTargetOf(*pAttacker))
		{
			return false;
		}

		if (pAttacker->canAttack(*pDefender) && !pAttacker->canAttack(*this))
		{
			return false;
		}

		if (pAttacker->canAttack(*this) && !pAttacker->canAttack(*pDefender))
		{
			return true;
		}
	}

	int iOurDefense = currCombatStr(plot(), pAttacker);
	if (::isWorldUnit(getUnitType()))
	{
		iOurDefense /= 2;
	}

	if (pAttacker)
	{
		if (!pAttacker->immuneToFirstStrikes())
		{
			iOurDefense *= 100 + (firstStrikes() * 2 + chanceFirstStrikes()) * GC.getCOMBAT_DAMAGE() * 2 / 5;
			iOurDefense /= 100;
		}

		if (immuneToFirstStrikes())
		{
			iOurDefense *= 100 + (pAttacker->firstStrikes() * 2 + pAttacker->chanceFirstStrikes()) * GC.getCOMBAT_DAMAGE() * 2 / 5;
			iOurDefense /= 100;
		}
	}
	else
	{
		if (pDefender->collateralDamage() > 0)
		{
			iOurDefense *= 100 + pDefender->collateralDamage();
			iOurDefense /= 100;
		}

		if (pDefender->currInterceptionProbability() > 0)
		{
			iOurDefense *= 100 + pDefender->currInterceptionProbability();
			iOurDefense /= 100;
		}
	}

	{
		const int iAssetValue = assetValueTotal() / 100;
		int iCargoAssetValue = 0;
		std::vector<CvUnit*> aCargoUnits;
		getCargoUnits(aCargoUnits);
		foreach_(const CvUnit* pCargoUnit, aCargoUnits)
		{
			iCargoAssetValue += pCargoUnit->assetValueTotal() / 100;
		}
		iOurDefense = iOurDefense * iAssetValue / std::max(1, iAssetValue + iCargoAssetValue);
	}

	int iTheirDefense = pDefender->currCombatStr(plot(), pAttacker);
	if (::isWorldUnit(pDefender->getUnitType()))
	{
		iTheirDefense /= 2;
	}

	if (NULL == pAttacker)
	{
		if (collateralDamage() > 0)
		{
			iTheirDefense *= (100 + collateralDamage());
			iTheirDefense /= 100;
		}

		if (currInterceptionProbability() > 0)
		{
			iTheirDefense *= (100 + currInterceptionProbability());
			iTheirDefense /= 100;
		}
	}
	else
	{
		if (!(pAttacker->immuneToFirstStrikes()))
		{
			iTheirDefense *= ((((pDefender->firstStrikes() * 2) + pDefender->chanceFirstStrikes()) * ((GC.getCOMBAT_DAMAGE() * 2) / 5)) + 100);
			iTheirDefense /= 100;
		}

		if (pDefender->immuneToFirstStrikes())
		{
			iTheirDefense *= ((((pAttacker->firstStrikes() * 2) + pAttacker->chanceFirstStrikes()) * ((GC.getCOMBAT_DAMAGE() * 2) / 5)) + 100);
			iTheirDefense /= 100;
		}
	}

	{
		const int iAssetValue = pDefender->assetValueTotal() / 100;
		int iCargoAssetValue = 0;
		std::vector<CvUnit*> aCargoUnits;
		pDefender->getCargoUnits(aCargoUnits);
		foreach_(const CvUnit* pCargoUnit, aCargoUnits)
		{
			iCargoAssetValue += pCargoUnit->assetValueTotal() / 100;
		}
		iTheirDefense = iTheirDefense * iAssetValue / std::max(1, iAssetValue + iCargoAssetValue);
	}

	if (iOurDefense == iTheirDefense)
	{
		if (NO_UNIT == getLeaderUnitType() && NO_UNIT != pDefender->getLeaderUnitType())
		{
			++iOurDefense;
		}
		else if (NO_UNIT != getLeaderUnitType() && NO_UNIT == pDefender->getLeaderUnitType())
		{
			++iTheirDefense;
		}
		else if (isBeforeUnitCycle(this, pDefender))
		{
			++iOurDefense;
		}
	}
	iOurDefense += tauntTotal() * iOurDefense / 100;
	iTheirDefense += pDefender->tauntTotal() * iTheirDefense / 100;

	return iOurDefense > iTheirDefense;
}


bool CvUnit::canDoCommand(CommandTypes eCommand, int iData1, int iData2, bool bTestVisible, bool bTestBusy) const
{
	CvUnit* pUnit;

	if (bTestBusy && getGroup()->isBusy())
	{
		return false;
	}

	switch (eCommand)
	{
	case COMMAND_PROMOTION:
		if (canPromote((PromotionTypes)iData1, iData2))
		{
			return true;
		}
		break;

	case COMMAND_UPGRADE:
		if (canUpgrade(((UnitTypes)iData1), bTestVisible))
		{
			return true;
		}
		break;

	case COMMAND_AUTOMATE:
		if (canAutomate((AutomateTypes)iData1))
		{
			return true;
		}
		break;

	case COMMAND_WAKE:
		if (!isAutomated() && isWaiting())
		{
			return true;
		}
		break;

	case COMMAND_CANCEL:
	case COMMAND_CANCEL_ALL:
		if (!isAutomated() && getGroup()->getLengthMissionQueue() > 0)
		{
			return true;
		}
		break;

	case COMMAND_STOP_AUTOMATION:
		if (isAutomated())
		{
			return true;
		}
		break;

	case COMMAND_DELETE:
		if (canScrap())
		{
			return true;
		}
		break;

	case COMMAND_GIFT:
		if (canGift(bTestVisible))
		{
			return true;
		}
		break;

	case COMMAND_LOAD:
		if (canLoad(plot()))
		{
			return true;
		}
		break;

	case COMMAND_LOAD_UNIT:
		pUnit = ::getUnit(IDInfo(((PlayerTypes)iData1), iData2));
		if (pUnit != NULL)
		{
			if (canLoadOntoUnit(pUnit, plot()))
			{
				return true;
			}
		}
		break;

	case COMMAND_UNLOAD:
		if (canUnload())
		{
			return true;
		}
		break;

	case COMMAND_UNLOAD_ALL:
		if (canUnloadAll())
		{
			return true;
		}
		break;

	case COMMAND_HOTKEY:
		if (isGroupHead())
		{
			return true;
		}
		break;

	case COMMAND_REEQUIP:

		if (plot()->isCity(true, getTeam()))
		{
			if (canSwitchEquipment((PromotionTypes)iData1))
			{
				return true;
			}
		}
		break;
//TBSIZE
	case COMMAND_MERGE:

		if (GC.getGame().isOption(GAMEOPTION_COMBAT_SIZE_MATTERS))
		{
			if (canMerge())
			{
				return true;
			}
		}
		break;

	case COMMAND_SPLIT:

		if (GC.getGame().isOption(GAMEOPTION_COMBAT_SIZE_MATTERS))
		{
			if (canSplit())
			{
				return true;
			}
		}
		break;

	case COMMAND_STATUS:

		if ((PromotionTypes)iData1 != NO_PROMOTION)
		{//TBHERE
			bool bIsQuick = GC.getPromotionInfo((PromotionTypes)iData1).isQuick();
			if ((!hasMoved() || (canMove() && bIsQuick)) && canAcquirePromotion((PromotionTypes)iData1, PromotionRequirements::ForStatus))
			{
				return true;
			}
		}
		break;

	case COMMAND_ARREST:
		if (canArrest())
		{
			return true;
		}
		break;

	case COMMAND_AMBUSH:
		return false;
		break;

	default:
		FErrorMsg("error");
		break;
	}

	return false;
}


void CvUnit::doCommand(CommandTypes eCommand, int iData1, int iData2)
{
	FAssert(getOwner() != NO_PLAYER);

	if (!canDoCommand(eCommand, iData1, iData2))
	{
		return;
	}
	switch (eCommand)
	{
		case COMMAND_PROMOTION:
		{
			promote((PromotionTypes)iData1, iData2);
			break;
		}
		case COMMAND_UPGRADE:
		{
			upgrade((UnitTypes)iData1);
			break;
		}
		case COMMAND_AUTOMATE:
		{
			automate((AutomateTypes)iData1);
			GC.getGame().updateSelectionListInternal();
			break;
		}
		case COMMAND_WAKE:
		{
			getGroup()->setActivityType(ACTIVITY_AWAKE);
			break;
		}
		case COMMAND_CANCEL:
		{
			getGroup()->popMission();
			break;
		}
		case COMMAND_CANCEL_ALL:
		{
			getGroup()->clearMissionQueue();
			break;
		}
		case COMMAND_STOP_AUTOMATION:
		{
			getGroup()->setAutomateType(NO_AUTOMATE);
			break;
		}
		case COMMAND_DELETE:
		{
			scrap();
			break;
		}
		case COMMAND_GIFT:
		{
			gift();
			break;
		}
		case COMMAND_LOAD:
		{
			load();
			break;
		}
		case COMMAND_LOAD_UNIT:
		{
			CvUnit* pUnit = ::getUnit(IDInfo(((PlayerTypes)iData1), iData2));

			if (pUnit != NULL)
			{
				loadOntoUnit(pUnit);
			}
			break;
		}
		case COMMAND_UNLOAD:
		{
			unload();
			break;
		}
		case COMMAND_UNLOAD_ALL:
		{
			unloadAll();
			break;
		}
		case COMMAND_HOTKEY:
		{
			setHotKeyNumber(iData1);
			break;
		}
		case COMMAND_REEQUIP:
		{
			reEquip((PromotionTypes)iData1);
			finishMoves();
			break;
		}
		case COMMAND_MERGE:
		{
			doMerge();
			break;
		}
		case COMMAND_SPLIT:
		{
			doSplit();
			break;
		}
		case COMMAND_STATUS:
		{
			statusUpdate((PromotionTypes)iData1);
			if (!GC.getPromotionInfo((PromotionTypes)iData1).isQuick())
			{
				finishMoves();
			}
			break;
		}
		case COMMAND_ARREST:
		{
			doArrest();
			break;
		}
		case COMMAND_AMBUSH:
		{
			break;
		}
		default: FErrorMsg("error");
	}
	getGroup()->doDelayedDeath();
}


#ifdef USE_OLD_PATH_GENERATOR
FAStarNode* CvUnit::getPathLastNode() const
{
	return getGroup()->getPathLastNode();
}
#else
int CvUnit::getPathMovementRemaining() const
{
	return getGroup()->getPath().movementRemaining();
}
#endif


CvPlot* CvUnit::getPathEndTurnPlot() const
{
	return getGroup()->getPathEndTurnPlot();
}


bool CvUnit::generatePath(const CvPlot* pToPlot, int iFlags, bool bReuse, int* piPathTurns, int iMaxTurns, int iOptimizationLimit) const
{
	//TB OOS fix: This is just to assist me with my tracking
	//GC.getGame().logOOSSpecial(29, getGroup()->getID(), iMaxTurns);
	return getGroup()->generatePath(plot(), pToPlot, iFlags, bReuse, piPathTurns, iMaxTurns, iOptimizationLimit);
}


bool CvUnit::canEnterTerritory(TeamTypes eTeam, bool bIgnoreRightOfPassage) const
{
	if (eTeam == NO_TEAM)
	{
		return true;
	}

	if (GET_TEAM(getTeam()).isFriendlyTerritory(eTeam))
	{
		return true;
	}

	if (isEnemy(eTeam))
	{
		return true;
	}

	if (isRivalTerritory())
	{
		return true;
	}

	if (alwaysInvisible())
	{
		return true;
	}

	if (isHiddenNationality())
	{
		return true;
	}

	if (!bIgnoreRightOfPassage)
	{
		if (GET_TEAM(getTeam()).isOpenBorders(eTeam))
		{
			return true;
		}

		if (GET_TEAM(getTeam()).isLimitedBorders(eTeam) && (isOnlyDefensive() || !canFight() || isPassage()))
		{
			return true;
		}
	}
	if (!GET_TEAM(eTeam).isAlive())
	{
		return true;
	}

	return false;
}


bool CvUnit::canEnterArea(TeamTypes eTeam, const CvArea* pArea, bool bIgnoreRightOfPassage) const
{
	return canEnterTerritory(eTeam, bIgnoreRightOfPassage);
}


// Returns the ID of the team to declare war against
TeamTypes CvUnit::getDeclareWarMove(const CvPlot* pPlot) const
{
	FAssert(GET_PLAYER(getOwner()).isHumanPlayer(true));

	if (getDomainType() != DOMAIN_AIR)
	{
		const TeamTypes eRevealedTeam = pPlot->getRevealedTeam(getTeam(), false);

		if (eRevealedTeam != NO_TEAM)
		{
			if ((!canEnterArea(eRevealedTeam, pPlot->area()) || getDomainType() == DOMAIN_SEA && !canCargoEnterArea(eRevealedTeam, pPlot->area(), false) && getGroup()->isAmphibPlot(pPlot))
			&& GET_TEAM(getTeam()).canDeclareWar(pPlot->getTeam()))
			{
				return eRevealedTeam;
			}
		}
		else if (pPlot->isActiveVisible(false) && canEnterPlot(pPlot, MoveCheck::Attack | MoveCheck::DeclareWar | MoveCheck::IgnoreLoad))
		{
			const CvUnit* pUnit = pPlot->plotCheck(PUF_canDeclareWar, getOwner(), isAlwaysHostile(pPlot), NULL, NO_PLAYER, NO_TEAM, PUF_isVisible, getOwner());

			if (pUnit != NULL)
			{
				return pUnit->getTeam();
			}
		}
	}
	return NO_TEAM;
}

bool CvUnit::willRevealByMove(const CvPlot* pPlot) const
{
	PROFILE_EXTRA_FUNC();
	const int iRange = visibilityRange(pPlot) + 1;

	foreach_(const CvPlot* plotX, pPlot->rect(iRange, iRange))
	{
		if (!plotX->isRevealed(getTeam(), false) && pPlot->canSeePlot(plotX, getTeam()))
		{
			return true;
		}
	}
	return false;
}

bool CvUnit::canEnterPlot(const CvPlot* pPlot, MoveCheck::flags flags /*= MoveCheck::None*/, CvUnit** ppDefender /*= NULL*/) const
{
	PROFILE_FUNC();

	if (!pPlot)
	{
		FErrorMsg("Plot is not assigned a valid value");
		return false;
	}
	// Wrong map category?
	if (m_pUnitInfo && !isMapCategory(*pPlot, *m_pUnitInfo)
	// Can Explore?
	|| m_pUnitInfo->isNoRevealMap() && willRevealByMove(pPlot)
	// Exiled?
	|| isExcile() && (pPlot->getOwner() == getOwner() || pPlot->getOwner() == getOriginalOwner())
	// Spies barred territorial entry by some condition
	|| isSpy()
	&& GC.getUSE_SPIES_NO_ENTER_BORDERS()
	&& NO_PLAYER != pPlot->getOwner()
	&& !GET_PLAYER(getOwner()).canSpiesEnterBorders(pPlot->getOwner()))
	{
		return false;
	}
	const bool bIgnoreLocation = flags & MoveCheck::IgnoreLocation;

	if (!bIgnoreLocation && atPlot(pPlot))
	{
		return false;
	}

	const bool bAttack = flags & MoveCheck::Attack;
	const bool bDeclareWar = flags & MoveCheck::DeclareWar;
	const bool bIgnoreLoad = flags & MoveCheck::IgnoreLoad;
	const bool bIgnoreTileLimit = flags & MoveCheck::IgnoreTileLimit;
	const bool bIgnoreAttack = flags & MoveCheck::IgnoreAttack;
	const bool bAssassinate = flags & MoveCheck::Assassinate;
	const bool bSuprise = flags & MoveCheck::Suprise;
	const bool bCheckForBest = flags & MoveCheck::CheckForBest;

	FAssertMsg(!bCheckForBest && !ppDefender || bCheckForBest && ppDefender, "MoveCheck::CheckForBest implies ppDefender is valid and vice-versa");

	const CvArea* pPlotArea = pPlot->area();
	TeamTypes ePlotTeam = pPlot->getTeam();

	if (canEnterArea(ePlotTeam, pPlotArea))
	{
		if (pPlot->getFeatureType() != NO_FEATURE)
		{
			if (algo::any_of_equal(m_pUnitInfo->getImpassableFeatures(), pPlot->getFeatureType()))
			{
				const TechTypes eTech = (TechTypes)m_pUnitInfo->getFeaturePassableTech(pPlot->getFeatureType());
				if (NO_TECH == eTech || !GET_TEAM(getTeam()).isHasTech(eTech))
				{
					if (DOMAIN_SEA != getDomainType() || ePlotTeam != getTeam())  // sea units can enter impassable in own cultural borders
					{
						return false;
					}
				}
			}
		}

		if (pPlot->isAsPeak() && m_pUnitInfo->isTerrainImpassableType(GC.getTERRAIN_PEAK())
		|| pPlot->isHills() && m_pUnitInfo->isTerrainImpassableType(GC.getTERRAIN_HILL()))
		{
			const TechTypes eTech = (TechTypes)m_pUnitInfo->getTerrainPassableTech(pPlot->getTerrainType());
			if (NO_TECH == eTech || !GET_TEAM(getTeam()).isHasTech(eTech))
			{
				if (DOMAIN_SEA != getDomainType() || ePlotTeam != getTeam())  // sea units can enter impassable in own cultural borders
				{
					if (bIgnoreLoad || !canLoad(pPlot))
					{
						return false;
					}
				}
			}
		}
		if (algo::any_of_equal(m_pUnitInfo->getImpassableTerrains(), pPlot->getTerrainType()))
		{
			const TechTypes eTech = (TechTypes)m_pUnitInfo->getTerrainPassableTech(pPlot->getTerrainType());
			if (NO_TECH == eTech || !GET_TEAM(getTeam()).isHasTech(eTech))
			{
				if (DOMAIN_SEA != getDomainType() || ePlotTeam != getTeam())  // sea units can enter impassable in own cultural borders
				{
					if (bIgnoreLoad || !canLoad(pPlot))
					{
						return false;
					}
				}
			}
		}
	}

	switch (getDomainType())
	{
		case DOMAIN_SEA:
		{
			if (!pPlot->isWater() && !canMoveAllTerrain() && !pPlot->isCanMoveSeaUnits()
			&& (!pPlot->isFriendlyCity(*this, true) || !pPlot->isCoastalLand()))
			{
				return false;
			}
			break;
		}
		case DOMAIN_AIR:
		{
			if (bAttack || bIgnoreAttack)
			{
				break;
			}

			bool bValid = pPlot->isFriendlyCity(*this, true);

			if (bValid && m_pUnitInfo->getAirUnitCap() > 0)
			{
				if (GC.getGame().isOption(GAMEOPTION_COMBAT_SIZE_MATTERS))
				{
					if (pPlot->airUnitSpaceAvailable(getTeam()) < GC.getGame().getBaseAirUnitIncrementsbyCargoVolume())
					{
						bValid = false;
					}
				}
				else if (pPlot->airUnitSpaceAvailable(getTeam()) <= 0)
				{
					bValid = false;
				}
			}
			if (!bValid && (bIgnoreLoad || !canLoad(pPlot)))
			{
				return false;
			}

			// Afforess - 03/7/10 - Rebase Limit
			if (!GET_TEAM(getTeam()).isRebaseAnywhere() && GC.getGame().isModderGameOption(MODDERGAMEOPTION_AIRLIFT_RANGE)
			&& plotDistance(pPlot->getX(), pPlot->getY(), getX(), getY()) > GC.getGame().getModderGameOption(MODDERGAMEOPTION_AIRLIFT_RANGE))
			{
				return false;
			}
			break;
		}
		case DOMAIN_LAND:
		{
			if (pPlot->isWater() && !canMoveAllTerrain() && !pPlot->isSeaTunnel()
			&& (!pPlot->isCity() || pPlot->isCity() && 0 == GC.getLAND_UNITS_CAN_ATTACK_WATER_CITIES())
			&& (bIgnoreLoad || !isHuman() || plot()->isWater() || !canLoad(pPlot)))
			{
				return false;
			}
			if (isHominid() && plot()->getTeam() != ePlotTeam && pPlotArea->isBorderObstacle(ePlotTeam))
			{
				return false;
			}
			break;
		}
		case DOMAIN_IMMOBILE: return false;

		default: FErrorMsg("error");
	}

	if ((m_pUnitInfo->getPassableRouteNeeded(0) || m_pUnitInfo->getPassableRouteNeeded(1))
	&& (!m_pUnitInfo->getPassableRouteNeeded(pPlot->getRouteType()) || !pPlot->isRoute()))
	{
		return false;
	}

	//ls612: For units that can't enter non-Owned Cities
	if (m_pUnitInfo->isNoNonOwnedEntry() && pPlot->isCity() && (pPlot->getOwner() != getOwner()))
	{
		return false;
	}

	if (isAnimal() && pPlot->isOwned())
	{
		if (!canAnimalIgnoresBorders())
		{
			return false;
		}

		if (pPlot->getImprovementType() != NO_IMPROVEMENT
		&& !canAnimalIgnoresImprovements())
		{
			return false;
		}

		if (pPlot->isCity(true) && !canAnimalIgnoresCities())
		{
			return false;
		}
	}

	bool bHasCheckedCityEntry = false;
	if (getDomainType() == DOMAIN_AIR)
	{
		if (bAttack && !bIgnoreAttack && !canAirStrike(pPlot))
		{
			return false;
		}
	}
	else
	{
		const bool bCanCoexist = canCoexistAlwaysOnPlot(*pPlot);
		const bool bVisibleEnemyDefender = !bCanCoexist && pPlot->isVisiblePotentialEnemyDefender(this);
		const bool bVisibleEnemyUnit = !bCanCoexist && (bVisibleEnemyDefender || pPlot->isVisiblePotentialEnemyDefenderless(this));

		bool bFailWithoutAttack = false;
		bool bFailWithAttack = false;

		// The following change makes it possible to capture defenseless units after having made a previous attack or paradrop
		if (bAttack && bVisibleEnemyUnit && !bSuprise && isMadeAttack() && !isBlitz())
		{
			if (!bIgnoreAttack)
			{
				return false;
			}
			bFailWithAttack = true;
		}

		if (canAttack())
		{
			if (pPlot->isVisible(getTeam(), false))
			{
				if (!bFailWithAttack && bVisibleEnemyDefender && bVisibleEnemyDefender && isMadeAttack() && !isBlitz())
				{
					return false;
				}

				if (bIgnoreAttack)
				{
					if (!bFailWithoutAttack && !bCanCoexist && bVisibleEnemyUnit
					&& (!bDeclareWar || pPlot->isVisibleOtherUnit(getOwner())))
					{
						if (bFailWithAttack)
						{
							return false;
						}
						bFailWithoutAttack = true;
					}
					if (!bFailWithAttack
					&& !bVisibleEnemyUnit
					&& (!bDeclareWar || !pPlot->isVisibleOtherUnit(getOwner()) && (!pPlot->getPlotCity() || isBlendIntoCity())))
					{
						if (bFailWithoutAttack)
						{
							return false;
						}
						bFailWithAttack = true;
					}
				}
				else if (!bCanCoexist && bVisibleEnemyDefender && !bAttack)
				{
					return false;
				}
			}

			if (bAttack && !bFailWithAttack)
			{
				//City Minimum Defense Level
				if (!bIgnoreLocation
				&& pPlot->getPlotCity()
				&& !isSpy()
				&& !isBlendIntoCity()
				&& (!isBarbCoExist() || !pPlot->isHominid())
				&& GET_TEAM(GET_PLAYER(getCombatOwner(ePlotTeam, pPlot)).getTeam()).isAtWar(ePlotTeam))
				{
					if (!pPlot->getPlotCity()->isDirectAttackable() && !canIgnoreNoEntryLevel())
					{
						return false;
					}
					bHasCheckedCityEntry = true;
				}
				const CvUnit* pDefender = pPlot->getFirstDefender(NO_PLAYER, getOwner(), this, true);
				if (pDefender)
				{
					if (!canAttack(*pDefender))
					{
						if (!bIgnoreAttack || bFailWithoutAttack)
						{
							return false;
						}
						bFailWithAttack = true;
					}
					if (bCheckForBest)
					{
						*ppDefender = pPlot->getBestDefender(NO_PLAYER, getOwner(), this, true, false, false, bAssassinate);
					}
				}
			}
		}
		else if (bAttack && !bFailWithAttack && !bIgnoreAttack
		|| !bCanCoexist && bVisibleEnemyUnit && pPlot->isVisible(getTeam(), false))
		{
			return false;
		}

		const TeamTypes eVisibleTeam = isHuman() ? pPlot->getRevealedTeam(getTeam(), false) : ePlotTeam;

		if (!canEnterArea(eVisibleTeam, pPlotArea))
		{
			FAssert(eVisibleTeam != NO_TEAM);

			if (!GET_TEAM(getTeam()).canDeclareWar(eVisibleTeam))
			{
				return false;
			}

			if (isHuman())
			{
				if (!bDeclareWar)
				{
					return false;
				}
			}
			else if (!GET_TEAM(getTeam()).AI_isSneakAttackReady(eVisibleTeam) || !getGroup()->AI_isDeclareWar(pPlot))
			{
				return false;
			}
		}
	}

	bool bValid = false;
	if (pPlot->isImpassable(getTeam()))
	{
		//Check our current tile
		if (plot()->isAsPeak())
		{
			//	Can this unit move through peaks regardless?
			if (isCanMovePeaks())
			{
				bValid = true;
			}
			else
			{
				//	If not we need a peak leader to be present
				bValid = plot()->getHasMountainLeader(getTeam());
			}
		}
		//Check the impassible tile
		if (!bValid)
		{
			if (pPlot->isAsPeak())
			{
				// Can this unit move through peaks regardless?
				if (isCanMovePeaks())
				{
					bValid = true;
				}
				else
				{
					// If not we need a peak leader to be present
					bValid = pPlot->getHasMountainLeader(getTeam());
				}
			}
			if (!bValid && !canMoveImpassable())
			{
				return false;
			}
		}
	}

	if (GC.getGame().getModderGameOption(MODDERGAMEOPTION_MAX_UNITS_PER_TILES) > 0)
	{
		if (!bIgnoreTileLimit)
		{
			if (!getUnitInfo().isOnlyDefensive() && baseCombatStr() > 0)
			{
				if (getDomainType() == DOMAIN_LAND && !pPlot->isWater() || getDomainType() == DOMAIN_SEA && pPlot->isWater() || getDomainType() == DOMAIN_AIR)
				{
					int iCount = 0;

					//Check our current tile
					foreach_(const CvUnit* pLoopUnit, pPlot->units())
					{
						if (pLoopUnit->getTeam() == getTeam())
						{
							//Ignore workers, Missionaries, etc...
							if (!pLoopUnit->getUnitInfo().isOnlyDefensive() && pLoopUnit->baseCombatStr() > 0)
							{
								//No counting cargo for ships, or harbors
								if (pLoopUnit->getDomainType() == getDomainType())
								{
									iCount++;
								}
							}
						}
					}//Unit is already on the tile, ignore it in the count
					if (bIgnoreLocation)
					{
						iCount--;
					}
					if (GC.getGame().getModderGameOption(MODDERGAMEOPTION_MAX_UNITS_PER_TILES) <= iCount)
					{
						return false;
					}
				}
			}
		}
	}

	if (!bIgnoreLocation && GC.getGame().isOption(GAMEOPTION_UNSUPPORTED_ZONE_OF_CONTROL))
	{
		//	ZoC don't apply into cities of the unit owner
		if (pPlot->getPlotCity() == NULL || pPlot->getPlotCity()->getTeam() != getTeam())
		{
			// Fort ZoC
			const PlayerTypes eDefender = plot()->controlsAdjacentZOCSource(getTeam());
			if (eDefender != NO_PLAYER)
			{
				const CvPlot* pZoneOfControl = plot()->isInFortControl(true, eDefender, getOwner());
				const CvPlot* pForwardZoneOfControl = pPlot->isInFortControl(true, eDefender, getOwner());
				if (pZoneOfControl != NULL && pForwardZoneOfControl != NULL && !canIgnoreZoneofControl()
				&& pZoneOfControl == pPlot->isInFortControl(true, eDefender, getOwner(), pZoneOfControl))
				{
					return false;
				}
			}
			// City ZoC
			if (plot()->isInCityZoneOfControl(getOwner()) && pPlot->isInCityZoneOfControl(getOwner()) && !canIgnoreZoneofControl())
			{
				return false;
			}
		}
		// Promotion ZoC
		if (GC.getGame().isAnyoneHasUnitZoneOfControl() && !canIgnoreZoneofControl()
		&& plot()->isInUnitZoneOfControl(getOwner()) && pPlot->isInUnitZoneOfControl(getOwner()))
		{
			return false;
		}
	}
	//City Minimum Defense Level
	if (!bHasCheckedCityEntry
	&& !bIgnoreLocation
	&& pPlot->getPlotCity()
	&& !isSpy()
	&& !isBlendIntoCity()
	&& (!isBarbCoExist() || !pPlot->isHominid())
	&& GET_TEAM(GET_PLAYER(getCombatOwner(ePlotTeam, pPlot)).getTeam()).isAtWar(ePlotTeam)
	&& !pPlot->getPlotCity()->isDirectAttackable()
	&& !canIgnoreNoEntryLevel())
	{
		return false;
	}
	return true;
}

bool CvUnit::canEnterOrAttackPlot(const CvPlot* pPlot, bool bDeclareWar) const
{
	const bool ignoreLocation = stepDistance(pPlot->getX(), pPlot->getY(), getX(), getY()) != 1;
	return canEnterPlot(pPlot,
		(bDeclareWar ? MoveCheck::DeclareWar : MoveCheck::None) |
		(ignoreLocation ? MoveCheck::IgnoreLocation : MoveCheck::None) |
		MoveCheck::IgnoreAttack
	);
}

bool CvUnit::canMoveThrough(const CvPlot* pPlot, bool bDeclareWar) const
{
	return canEnterPlot(pPlot, (bDeclareWar ? MoveCheck::DeclareWar : MoveCheck::None) | MoveCheck::IgnoreLoad);
}

void CvUnit::attack(CvPlot* pPlot, bool bStealth, bool bNoCache)
{
	PROFILE_FUNC();
	FAssert(plot() == pPlot || bStealth || bNoCache || canEnterPlot(pPlot, MoveCheck::Attack));
	FAssert(getCombatTimer() == 0);

	m_combatResult.iTurnCount = 0;

	//TB Combat Mods begin
	pPlot->doPreAttackTraps(this);

	if (!isDead())
	{
#ifdef STRENGTH_IN_NUMBERS
		CvPlot* aPlot = plot();
		if (GC.getGame().isOption(GAMEOPTION_COMBAT_STRENGTH_IN_NUMBERS))
		{
			setAttackFromPlot(aPlot);
		}
#endif // STRENGTH_IN_NUMBERS
		//TB Combat Mods end
		setAttackPlot(pPlot, false);

		FAssertMsg(pPlot != plot(), "We are passing in false for bSamePlot so why are we on the same plot? (This is here to confirm if the bSamePlot parameter actually means what it says or not, we might remove the parameter or rename it if the assert is hit)");
		updateCombat(NULL, false, bStealth, bNoCache);
	}
}

void CvUnit::fightInterceptor(const CvPlot* pPlot, bool bQuick)
{
	FAssert(getCombatTimer() == 0);

	setAttackPlot(pPlot, true);

	updateAirCombat(bQuick);
}


void CvUnit::move(CvPlot* pPlot, bool bShow)
{
	PROFILE_FUNC();

	FAssert(canEnterOrAttackPlot(pPlot) || isMadeAttack());

	CvPlot* pOldPlot = plot();

	changeMoves(pPlot->movementCost(this, pOldPlot));

	//GC.getGame().logOOSSpecial(16, getID(), pPlot->getX(), pPlot->getY());
	OutputDebugString(CvString::format("%S (%d) CvUnit::move (%d,%d)-->(%d,%d)\n", getDescription().c_str(), m_iID, m_iX, m_iY, pPlot->getX(), pPlot->getY()).c_str());
	LOG_UNIT_BLOCK(4, {
		UnitAITypes eUnitAi = AI_getUnitAIType();
		MissionAITypes eMissionAI = getGroup()->AI_getMissionAIType();
		CvWString StrunitAIType = GC.getUnitAIInfo(eUnitAi).getType();
		CvWString MissionInfos = MissionAITypeToString(eMissionAI);
		CvWString StrUnitName = m_szName;
		CvPlot* pMissionPlot = getGroup()->AI_getMissionAIPlot();
		CvWString MissionTarget = "";
		if (pMissionPlot != NULL)
		{
			MissionTarget = CvWString::format(L"--> (%d, %d)", pMissionPlot->getX(), pMissionPlot->getY());
		}
		if (StrUnitName.length() == 0)
		{
			StrUnitName = getName(0).GetCString();
		}

		logBBAI("Player %d Unit ID %d, %S of Type %S, move (%d, %d)-->(%d,%d), in Mission %S [stack size %d]%S", getOwner(), m_iID, StrUnitName.GetCString(), StrunitAIType.GetCString(), m_iX, m_iY, pPlot->getX(), pPlot->getY(), MissionInfos.GetCString(), getGroup()->getNumUnits(), MissionTarget.GetCString());
	});

	setXY(pPlot->getX(), pPlot->getY(), true, true, bShow && pPlot->isVisibleToWatchingHuman(), bShow);

	//TBFIXHERE it's very possible for the unit to be dead from this point and there are further move aspects taking place that would make little sense if unit is dead.
	if (isDead())
	{
		// Toffer - Shouldn't this be handled when pLoopUnit actually dies in the above pLoopUnit->move(pPlot, true);
		//	rather than after it has died here below.
		joinGroup(NULL, true);
		finishMoves();
		return;
	}
	const FeatureTypes featureType = pPlot->getFeatureType();
	if (featureType != NO_FEATURE)
	{
		const CvString featureString(GC.getFeatureInfo(featureType).getOnUnitChangeTo());
		if (!featureString.IsEmpty())
		{
			pPlot->setFeatureType((FeatureTypes)GC.getInfoTypeForString(featureString));
		}
		//spawn birds if trees present - JW
		else if (!pPlot->isOwned() && getOwner() == GC.getGame().getActivePlayer()
		&& GC.getASyncRand().get(100) < GC.getFeatureInfo(featureType).getEffectProbability())
		{
			EffectTypes eEffect = (EffectTypes)GC.getInfoTypeForString(GC.getFeatureInfo(featureType).getEffectType());
			gDLL->getEngineIFace()->TriggerEffect(eEffect, pPlot->getPoint(), (float)(GC.getASyncRand().get(360)));
			gDLL->getInterfaceIFace()->playGeneralSound("AS3D_UN_BIRDS_SCATTER", pPlot->getPoint());
		}
	}
	if((pPlot->getOwner() != getOwner() || !pPlot->isOwned() ) && !(GET_PLAYER(getOwner()).isNPC()))
	{
		changeExperience100(10, 500);
		changeExperience100(1, 2000);
		if(isHasUnitCombat(GC.getUNITCOMBAT_RECON()))
		{
			changeExperience100(4, 10000);
		}
	}
}

// false if unit is killed
bool CvUnit::jumpToNearestValidPlot(bool bKill)
{
	PROFILE_EXTRA_FUNC();
	FAssertMsg(!isAttacking(), "isAttacking did not return false as expected");
	FAssertMsg(!isInBattle(), "isInBattle did not return false as expected");

	//	If the jump is due to being in an incorrect doamin it implies there WILL be an area change, so the relevant nearest
	//	city cannot possibly be in the same area, hence we need to search all
	CvCity* pNearestCity = GC.getMap().findCity(getX(), getY(), getOwner(), NO_TEAM, plot()->isValidDomainForAction(*this));

	int iBestValue = MAX_INT;
	CvPlot* pBestPlot = NULL;

	for (int iI = 0; iI < GC.getMap().numPlots(); iI++)
	{
		CvPlot* pLoopPlot = GC.getMap().plotByIndex(iI);

		if (pLoopPlot->isValidDomainForLocation(*this))
		{
			if (canEnterPlot(pLoopPlot))
			{
				if (canEnterArea(pLoopPlot->getTeam(), pLoopPlot->area()) && !isEnemy(pLoopPlot->getTeam(), pLoopPlot))
				{
					FAssertMsg(!atPlot(pLoopPlot), "atPlot(pLoopPlot) did not return false as expected");

					if ((getDomainType() != DOMAIN_AIR) || pLoopPlot->isFriendlyCity(*this, true))
					{
						if (pLoopPlot->isRevealed(getTeam(), false))
						{
							int iValue = (plotDistance(getX(), getY(), pLoopPlot->getX(), pLoopPlot->getY()) * 2);

							if (pNearestCity != NULL)
							{
								iValue += plotDistance(pLoopPlot->getX(), pLoopPlot->getY(), pNearestCity->getX(), pNearestCity->getY());

								//	Try to at least favour the same landmass as the nearest city
								if (pLoopPlot->area() != pNearestCity->area())
								{
									iValue *= 3;
								}
							}

							if (getDomainType() == DOMAIN_SEA && !plot()->isWater())
							{
								if (!pLoopPlot->isWater() || !pLoopPlot->isAdjacentToArea(area()))
								{
									iValue *= 3;
								}
							}
							else
							{
								if (pLoopPlot->area() != area())
								{
									iValue *= 3;
								}
							}
							iValue *= std::max(1, ((pLoopPlot->getTotalTurnDamage(this)) / 2));

							if (iValue < iBestValue)
							{
								iBestValue = iValue;
								pBestPlot = pLoopPlot;
							}
						}
					}
				}
			}
		}
	}

	if (pBestPlot != NULL)
	{
		//GC.getGame().logOOSSpecial(17, getID(), pBestPlot->getX(), pBestPlot->getY());
		setXY(pBestPlot->getX(), pBestPlot->getY());
		return true;
	}

	if (bKill)
	{
		kill(false);
	}
	return false;
}


bool CvUnit::canAutomate(AutomateTypes eAutomate) const
{
	if (eAutomate == NO_AUTOMATE)
	{
		return false;
	}

	if (!isGroupHead())
	{
		return false;
	}
	/************************************************************************************************/
	/* Afforess	                  Start		 02/14/10                                               */
	/*                                                                                              */
	/*  Clicking on the Automate button with an Inquisitor causes a CTD                             */
	/************************************************************************************************/
	if (m_pUnitInfo->isInquisitor())
	{
		return false;
	}
	/************************************************************************************************/
	/* Afforess	                     END                                                            */
	/************************************************************************************************/

	switch (eAutomate)
	{
	case AUTOMATE_BUILD:
		if ((AI_getUnitAIType() != UNITAI_WORKER) && (AI_getUnitAIType() != UNITAI_WORKER_SEA))
		{
			return false;
		}
		break;

	case AUTOMATE_NETWORK:
		if ((AI_getUnitAIType() != UNITAI_WORKER) || !canBuildRoute())
		{
			return false;
		}
		break;

	case AUTOMATE_CITY:
		if (AI_getUnitAIType() != UNITAI_WORKER)
		{
			return false;
		}
		break;

	case AUTOMATE_EXPLORE:
		/************************************************************************************************/
		/* BETTER_BTS_AI_MOD                      04/25/10                                jdog5000      */
		/*                                                                                              */
		/* Player Interface                                                                             */
		/************************************************************************************************/
		if (!canFight())
		{
			// Enable exploration for air units
			if (getDomainType() != DOMAIN_SEA && getDomainType() != DOMAIN_AIR)
			{
				if (!alwaysInvisible() || !isSpy())
				{
					return false;
				}
			}
		}

		if (getDomainType() == DOMAIN_IMMOBILE)
		{
			return false;
		}

		if (getDomainType() == DOMAIN_AIR && !canRecon())
		{
			return false;
		}

		if (GET_PLAYER(getOwner()).isModderOption(MODDEROPTION_HIDE_AUTO_EXPLORE))
		{
			return false;
		}
		/************************************************************************************************/
		/* BETTER_BTS_AI_MOD                       END                                                  */
		/************************************************************************************************/

		break;

	case AUTOMATE_RELIGION:
		if (AI_getUnitAIType() != UNITAI_MISSIONARY)
		{
			return false;
		}
		/************************************************************************************************/
		/* Afforess	                  Start		 09/16/10                                               */
		/*                                                                                              */
		/* Advanced Automations                                                                         */
		/************************************************************************************************/
		if (GET_PLAYER(getOwner()).isModderOption(MODDEROPTION_HIDE_AUTO_SPREAD))
		{
			return false;
		}
		break;

	case AUTOMATE_PILLAGE:
		if (!getUnitInfo().isPillage())
		{
			return false;
		}
		if (GET_PLAYER(getOwner()).isModderOption(MODDEROPTION_HIDE_AUTO_PILLAGE))
		{
			return false;
		}
		break;
	case AUTOMATE_HUNT:
		if (GET_PLAYER(getOwner()).isModderOption(MODDEROPTION_HIDE_AUTO_HUNT))
		{
			return false;
		}
		if (!canAttack())
		{
			return false;
		}
		break;
	case AUTOMATE_CITY_DEFENSE:
		if (GET_PLAYER(getOwner()).isModderOption(MODDEROPTION_HIDE_AUTO_DEFENSE))
		{
			return false;
		}
		if (!canAttack())
		{
			return false;
		}
		break;
	case AUTOMATE_BORDER_PATROL:
		if (GET_PLAYER(getOwner()).isModderOption(MODDEROPTION_HIDE_AUTO_PATROL))
		{
			return false;
		}
		if (!canAttack())
		{
			return false;
		}
		break;
	case AUTOMATE_PIRATE:
		if (GET_PLAYER(getOwner()).isModderOption(MODDEROPTION_HIDE_AUTO_PIRATE))
		{
			return false;
		}
		if (getDomainType() != DOMAIN_SEA)
		{
			return false;
		}
		if (!canAttack())
		{
			return false;
		}
		if (!isHiddenNationality() || !m_pUnitInfo->isAlwaysHostile())
		{
			return false;
		}
		break;
	case AUTOMATE_HURRY:
		if (GET_PLAYER(getOwner()).isModderOption(MODDEROPTION_HIDE_AUTO_CARAVAN))
		{
			return false;
		}
		if (m_pUnitInfo->getBaseHurry() <= 0)
		{
			return false;
		}
		//Do not give ability to great people
		if (m_pUnitInfo->getProductionCost() < 0)
		{
			return false;
		}
		break;
	case AUTOMATE_AIRSTRIKE:
		if (GET_PLAYER(getOwner()).isModderOption(MODDEROPTION_HIDE_AUTO_AIR))
		{
			return false;
		}
		if (getDomainType() != DOMAIN_AIR)
		{
			return false;
		}
		if (!canAirAttack())
		{
			return false;
		}
		//Jets and Fighters can intercept, modders, if you have fighters with 0 interception, feel free to get rid of this check
		if (m_pUnitInfo->getInterceptionProbability() <= 0)
		{
			return false;
		}
		break;
	case AUTOMATE_AIRBOMB:
		if (GET_PLAYER(getOwner()).isModderOption(MODDEROPTION_HIDE_AUTO_AIR))
		{
			return false;
		}
		if (getDomainType() != DOMAIN_AIR)
		{
			return false;
		}

		if (getAirBombBaseRate() == 0)
		{
			return false;
		}

		if (canAutomate(AUTOMATE_AIRSTRIKE))
		{
			return false;
		}
	case AUTOMATE_AIR_RECON:
		if (!canRecon())
		{
			return false;
		}
		break;
	case AUTOMATE_UPGRADING:
		if (m_pUnitInfo->getNumUnitUpgrades() == 0)
		{
			return false;
		}
		if (isAutoUpgrading())
		{
			return false;
		}
		if (GET_PLAYER(getOwner()).isModderOption(MODDEROPTION_HIDE_AUTO_UPGRADE))
		{
			return false;
		}
		break;
	case AUTOMATE_CANCEL_UPGRADING:
		if (m_pUnitInfo->getNumUnitUpgrades() == 0)
		{
			return false;
		}
		if (!isAutoUpgrading())
		{
			return false;
		}
		break;
	case AUTOMATE_PROMOTIONS:
		if (GET_PLAYER(getOwner()).isModderOption(MODDEROPTION_HIDE_AUTO_PROMOTE))
		{
			return false;
		}
		if (!canAcquirePromotionAny())
		{
			return false;
		}
		if (isAutoPromoting())
		{
			return false;
		}
		break;
	case AUTOMATE_CANCEL_PROMOTIONS:
		if (!canAcquirePromotionAny())
		{
			return false;
		}
		if (!isAutoPromoting())
		{
			return false;
		}
		break;
	case AUTOMATE_SHADOW:
		if (!canShadow())
		{
			return false;
		}
		if (GET_PLAYER(getOwner()).isModderOption(MODDEROPTION_HIDE_AUTO_PROTECT))
		{
			return false;
		}
		break;
/************************************************************************************************/
/* Afforess	                     END                                                            */
/************************************************************************************************/
	default:
		FErrorMsg("error");
		break;
	}

	return true;
}


void CvUnit::automate(AutomateTypes eAutomate)
{
	PROFILE_EXTRA_FUNC();
	if (!canAutomate(eAutomate))
	{
		return;
	}

	if (eAutomate == AUTOMATE_UPGRADING || eAutomate == AUTOMATE_CANCEL_UPGRADING)
	{
		foreach_(CvUnit* pLoopUnit, getGroup()->units())
		{
			pLoopUnit->setAutoUpgrading((eAutomate == AUTOMATE_UPGRADING));
		}
		if (IsSelected())
		{
			gDLL->getInterfaceIFace()->setDirty(SelectionButtons_DIRTY_BIT, true);
		}
		return;
	}
	if (eAutomate == AUTOMATE_PROMOTIONS || eAutomate == AUTOMATE_CANCEL_PROMOTIONS)
	{
		foreach_(CvUnit* pLoopUnit, getGroup()->units())
		{
			pLoopUnit->setAutoPromoting((eAutomate == AUTOMATE_PROMOTIONS));
		}
		if (IsSelected())
		{
			gDLL->getInterfaceIFace()->setDirty(SelectionButtons_DIRTY_BIT, true);
		}
		return;
	}

	getGroup()->setAutomateType(eAutomate);
}


bool CvUnit::canScrap() const
{
	if (plot()->isBattle())
	{
		return false;
	}

	return true;
}


// No need to let return value exceed MAX_INT, shouldn't really happen unless one of the most expensive units is merged many times.
int CvUnit::calculateScrapValue() const
{
	int64_t iCost = getUnitInfo().getProductionCost() * GC.getGameSpeedInfo(GC.getGame().getGameSpeedType()).getHammerCostPercent();

	if (GC.getGame().isOption(GAMEOPTION_COMBAT_SIZE_MATTERS))
	{
		const int iGroupDiff = groupRank() - m_pUnitInfo->getBaseGroupRank();
		if (iGroupDiff != 0)
		{
			if (iGroupDiff > 0)
			{
				iCost *= intPow64(3, iGroupDiff);
			}
			else iCost /= intPow64(3, -iGroupDiff);
		}
	}
	iCost /= 100*GC.getUNIT_GOLD_DISBAND_DIVISOR();

	if (iCost > MAX_INT) return MAX_INT;
	// A minimum return of 1 will cause oddities in early game where a unit that can split only gives 1 gold,
	//	giving the player a reason to split before disbanding to earn a couple extra gold coins.
	if (iCost < 1) return 0;

	return static_cast<int>(iCost);
}

void CvUnit::scrap()
{
	if (!canScrap())
	{
		return;
	}

	if (gUnitLogLevel > 2)
	{
		CvWString szString;
		getUnitAIString(szString, AI_getUnitAIType());
		logBBAI("    %S scraps %S (%d) with %S", GET_PLAYER(getOwner()).getCivilizationDescription(0), getName(0).GetCString(), getID(), szString.GetCString());
	}

	if (GC.getGame().isOption(GAMEOPTION_UNIT_DOWNSIZING_IS_PROFITABLE) && plot()->getOwner() == getOwner())
	{
		GET_PLAYER(getOwner()).changeGold(calculateScrapValue());
	}

	getGroup()->AI_setMissionAI(MISSIONAI_DELIBERATE_KILL, NULL, NULL);
	kill(true, NO_PLAYER, true);
}


bool CvUnit::canGift(bool bTestVisible, bool bTestTransport) const
{
	PROFILE_EXTRA_FUNC();
	const CvPlot* pPlot = plot();

	if (!pPlot->isOwned()
	||  pPlot->getOwner() == getOwner()
	||  pPlot->isVisibleEnemyUnit(this)
	||  pPlot->isVisibleEnemyUnit(pPlot->getOwner()))
	{
		return false;
	}

	{
		const CvUnit* pTransport = getTransportUnit();

		if (pTransport)
		{
			if (bTestTransport && pTransport->getTeam() != pPlot->getTeam())
			{
				return false;
			}
		}
		else if (!pPlot->isValidDomainForLocation(*this))
		{
			return false;
		}
	}

	for (int iCorp = 0; iCorp < GC.getNumCorporationInfos(); ++iCorp)
	{
		if (m_pUnitInfo->getCorporationSpreads(iCorp) > 0)
		{
			return false;
		}
	}

	if (!bTestVisible)
	{
		if (GET_PLAYER(pPlot->getOwner()).isUnitMaxedOut(getUnitType(), GET_PLAYER(pPlot->getOwner()).getUnitMaking(getUnitType()))
		|| !GET_PLAYER(pPlot->getOwner()).AI_acceptUnit(this))
		{
			return false;
		}
	}
	return !atWar(pPlot->getTeam(), getTeam());
}


void CvUnit::gift(bool bTestTransport)
{
	if (!canGift(false, bTestTransport))
	{
		return;
	}
	std::vector<CvUnit*> aCargoUnits;
	getCargoUnits(aCargoUnits);
	if (!aCargoUnits.empty())
	{
		validateCargoUnits();
	}
	algo::for_each(aCargoUnits, bind(CvUnit::gift, _1, false));

	const PlayerTypes eNewOwner = plot()->getOwner();

	FAssertMsg(eNewOwner != NO_PLAYER, "plot()->getOwner() is not expected to be equal with NO_PLAYER");

	CvUnit* pGiftUnit = GET_PLAYER(eNewOwner).initUnit(getUnitType(), getX(), getY(), AI_getUnitAIType(), NO_DIRECTION, GC.getGame().getSorenRandNum(10000, "AI Unit Birthmark"));
	if (pGiftUnit == NULL)
	{
		FErrorMsg("GiftUnit is not assigned a valid value");
		return;
	}
	const PlayerTypes eOldOwner = getOwner();

	pGiftUnit->convert(this);

	if (pGiftUnit->isCombat())
	{
		GET_PLAYER(eNewOwner).AI_changePeacetimeGrantValue(eOldOwner, (pGiftUnit->getUnitInfo().getProductionCost() * 3 * GC.getGame().AI_combatValue(pGiftUnit->getUnitType()))/100);
	}
	else GET_PLAYER(eNewOwner).AI_changePeacetimeGrantValue(eOldOwner, (pGiftUnit->getUnitInfo().getProductionCost()));

	if (pGiftUnit->isHuman())
	{
		AddDLLMessage(
			eNewOwner, false, GC.getEVENT_MESSAGE_TIME(),
			gDLL->getText("TXT_KEY_MISC_GIFTED_UNIT_TO_YOU", GET_PLAYER(eOldOwner).getNameKey(), pGiftUnit->getNameKey()),
			"AS2D_UNITGIFTED", MESSAGE_TYPE_INFO, pGiftUnit->getButton(), GC.getCOLOR_WHITE(), pGiftUnit->getX(), pGiftUnit->getY(), true, true
		);
	}
	// Python Event
	CvEventReporter::getInstance().unitGifted(pGiftUnit, eOldOwner, plot());
}


bool CvUnit::canLoadOntoUnit(const CvUnit* pUnit, const CvPlot* pPlot) const
{
	FAssert(pUnit != NULL);
	FAssert(pPlot != NULL);

	if (pUnit == this)
	{
		return false;
	}

	if (!pUnit->isCarrier())
	{
		return false;
	}

	if (isArmedTrap())
	{
		return false;
	}

	if (pUnit->getUnitType() == getUnitType())
	{
		return false;
	}

	if (pUnit->getTeam() != getTeam())
	{
		return false;
	}

	if (getTransportUnit() == pUnit || pUnit->getTransportUnit() == this)
	{
		return false;
	}

	{
		const int iCargoSpace = pUnit->cargoSpaceAvailable(getSpecialUnitType(), getDomainType());

		if (iCargoSpace < 1 || GC.getGame().isOption(GAMEOPTION_COMBAT_SIZE_MATTERS) && iCargoSpace < SMCargoVolume())
		{
			return false;
		}
	}

	//Not a good rule for C2C - would keep units carrying from being able to load
	//if (pUnit->isCargo())
	//{
	//	return false;
	//}

	if (!(pUnit->atPlot(pPlot)))
	{
		return false;
	}

	//Not a helpful rule for C2C
	//if (!m_pUnitInfo->isHiddenNationality() && pUnit->getUnitInfo().isHiddenNationality())
	//{
	//	return false;
	//}

	if (NO_SPECIALUNIT != getSpecialUnitType())
	{
		if (GC.getSpecialUnitInfo(getSpecialUnitType()).isCityLoad())
		{
			if (!pPlot->isCity(true, getTeam()))
			{
				return false;
			}
		}
	}

	return true;
}


void CvUnit::loadOntoUnit(CvUnit* pUnit)
{
	if (!canLoadOntoUnit(pUnit, plot()))
	{
		return;
	}

	setTransportUnit(pUnit);
}

bool CvUnit::shouldLoadOnMove(const CvPlot* pPlot) const
{
	if (isCargo())
	{
		return false;
	}

	switch (getDomainType())
	{
	case DOMAIN_LAND:
		if ((pPlot->isWater() && !canMoveAllTerrain()) && !pPlot->isSeaTunnel())
		{
			return true;
		}
		break;
	case DOMAIN_AIR:
		if (!pPlot->isFriendlyCity(*this, true))
		{
			return true;
		}

		if (m_pUnitInfo->getAirUnitCap() > 0)
		{
			if (GC.getGame().isOption(GAMEOPTION_COMBAT_SIZE_MATTERS))
			{
				if (pPlot->airUnitSpaceAvailable(getTeam()) < getCargoVolume())
				{
					return true;
				}
			}
			else if (pPlot->airUnitSpaceAvailable(getTeam()) <= 0)
			{
				return true;
			}
		}
		break;
	default:
		break;
	}

	if (algo::any_of_equal(m_pUnitInfo->getImpassableTerrains(), pPlot->getTerrainType()))
	{
		const TechTypes eTech = (TechTypes)m_pUnitInfo->getTerrainPassableTech(pPlot->getTerrainType());
		if (NO_TECH == eTech || !GET_TEAM(getTeam()).isHasTech(eTech))
		{
			return true;
		}
	}

	return false;
}


bool CvUnit::canLoad(const CvPlot* pPlot) const
{
	PROFILE_FUNC();

	FAssert(pPlot != NULL);

	foreach_(const CvUnit* pLoopUnit, pPlot->units())
	{
		if (canLoadOntoUnit(pLoopUnit, pPlot))
		{
			return true;
		}
	}

	return false;
}


void CvUnit::load()
{
	PROFILE_EXTRA_FUNC();
	if (!canLoad(plot()))
	{
		return;
	}

	const CvPlot* pPlot = plot();

	for (int iPass = 0; iPass < 2; iPass++)
	{
		foreach_(CvUnit* pLoopUnit, pPlot->units())
		{
			if (canLoadOntoUnit(pLoopUnit, pPlot))
			{
				if ((iPass == 0) ? (pLoopUnit->getOwner() == getOwner()) : (pLoopUnit->getTeam() == getTeam()))
				{
					setTransportUnit(pLoopUnit);
					break;
				}
			}
		}

		if (isCargo())
		{
			break;
		}
	}
}


bool CvUnit::canUnload() const
{
	if (getTransportUnit() == NULL)
	{
		return false;
	}

	const CvPlot& kPlot = *(plot());
	if (!kPlot.isValidDomainForLocation(*this))
	{
		return false;
	}

	if (isTrap())
	{
		const TerrainTypes eTerrain = kPlot.getTerrainType();
		if (eTerrain != NO_TERRAIN)
		{
			return false;
		}
		const FeatureTypes eFeature = kPlot.getFeatureType();
		if (eFeature != NO_FEATURE)
		{
			return false;
		}
	}

	if (m_pUnitInfo != NULL && !isMapCategory(kPlot, *m_pUnitInfo))
	{
		return false;
	}

	if (getDomainType() == DOMAIN_AIR)
	{
		if (kPlot.isFriendlyCity(*this, true))
		{
			const int iNumAirUnits = kPlot.countNumAirUnits(getTeam());
			const CvCity* pCity = kPlot.getPlotCity();
			if (NULL != pCity)
			{
				if (GC.getGame().isOption(GAMEOPTION_COMBAT_SIZE_MATTERS))
				{
					const int iNumAirUnitCargoVolume = kPlot.countNumAirUnitCargoVolume(getTeam());
					if (iNumAirUnitCargoVolume >= pCity->getSMAirUnitCapacity(getTeam()))
					{
						return false;
					}
				}
				else if (iNumAirUnits >= pCity->getAirUnitCapacity(getTeam()))
				{
					return false;
				}
			}
			else
			{
				if (iNumAirUnits >= GC.getDefineINT("CITY_AIR_UNIT_CAPACITY"))
				{
					return false;
				}
			}
		}
	}

	return true;
}


void CvUnit::unload()
{
	if (!canUnload())
	{
		return;
	}

	CvUnit* pUnit = getTransportUnit();
	setTransportUnit(NULL);

	if (isTrap())
	{
		if (plot()->isFriendlyCity(*this, false))
		{
			setTrap(pUnit);
		}
	}
}


bool CvUnit::canUnloadAll() const
{
	return hasCargo();
}


void CvUnit::unloadAll()
{
	PROFILE_EXTRA_FUNC();
	if (!canUnloadAll())
	{
		return;
	}

	std::vector<CvUnit*> aCargoUnits;
	getCargoUnits(aCargoUnits);
	if (!aCargoUnits.empty())
	{
		validateCargoUnits();
	}
	foreach_(CvUnit* pCargo, aCargoUnits)
	{
		if (pCargo->canUnload())
		{
			pCargo->setTransportUnit(NULL);
		}
		else
		{
			FAssert(isHuman() || pCargo->getDomainType() == DOMAIN_AIR);
			pCargo->getGroup()->setActivityType(ACTIVITY_AWAKE);
		}
	}
}


bool CvUnit::canHold() const
{
	return true;
}


bool CvUnit::canSleep() const
{
	if (isFortifyable() || isWaiting())
	{
		return false;
	}
	return true;
}


bool CvUnit::canFortify() const
{
	if (!isFortifyable() || isWaiting())
	{
		return false;
	}
	return true;
}

bool CvUnit::canBuildUp() const
{
	if (!isBuildUpable() || isWaiting())
	{
		return false;
	}
	return true;
}

bool CvUnit::canAirPatrol(const CvPlot* pPlot) const
{
	if (getDomainType() != DOMAIN_AIR || !canAirDefend(pPlot) || isWaiting())
	{
		return false;
	}
	return true;
}


bool CvUnit::canSeaPatrol(const CvPlot* pPlot) const
{
	if (!pPlot->isWater())
	{
		return false;
	}

	if (getDomainType() != DOMAIN_SEA)
	{
		return false;
	}

	if (!canFight() || isOnlyDefensive())
	{
		return false;
	}

	if (isWaiting())
	{
		return false;
	}

	return true;
}


void CvUnit::airCircle(bool bStart)
{
	if (!GC.IsGraphicsInitialized())
	{
		return;
	}

	if (!isInViewport())
	{
		return;
	}

	if (getDomainType() != DOMAIN_AIR || maxInterceptionProbability() == 0)
	{
		return;
	}

	//cancel previos missions
	if ( !isUsingDummyEntities() && isInViewport() )
	{
		gDLL->getEntityIFace()->RemoveUnitFromBattle( this );

		if (bStart)
		{
			// patrol is indefinite - time is ignored
			addMission(CvAirMissionDefinition(MISSION_AIRPATROL, plot(), this, NULL, 1.f));
		}
	}
}


bool CvUnit::canHeal(const CvPlot* pPlot) const
{
	if (!isHurt() || isWaiting() || healTurns(pPlot) == 0)
	{
		return false;
	}
	return true;
}


bool CvUnit::canSentry(const CvPlot* pPlot) const
{
	if (!canDefend(pPlot) || isWaiting())
	{
		return false;
	}
	return true;
}


int CvUnit::healRate(const CvPlot* pPlot, bool bHealCheck) const
{
	PROFILE_FUNC();

	if (pPlot->getTotalTurnDamage(this) > 0)
	{
		return 0;
	}

	//Find what will take the longest to heal and use that rate
	if (m_pUnitInfo->getNumHealAsTypes() > 0)
	{
		int iWorstNumTurns = -1;
		int iBestHeal = MAX_INT;
		for (int iI = m_pUnitInfo->getNumHealAsTypes() - 1; iI > -1; iI--)
		{
			const UnitCombatTypes eHealAsType = (UnitCombatTypes)m_pUnitInfo->getHealAsType(iI);
			const int iHealAsDamage = getHealAsDamage(eHealAsType);
			if (iHealAsDamage > 0)
			{
				const int iHealAs = getHealRateAsType(pPlot, bHealCheck, eHealAsType);
				const int iNumTurns = iHealAs > 0 ? iHealAsDamage / iHealAs : MAX_INT;

				//Note we're actually looking for the slowest to heal here to use that for the # of rounds to heal total
				if (iNumTurns > iWorstNumTurns)
				{
					iBestHeal = iHealAs;
					iWorstNumTurns = iNumTurns;
					if (iNumTurns == MAX_INT)
					{
						break;
					}
				}
			}
		}
		if (iWorstNumTurns > -1)
		{
			if (!hasNoSelfHeal())
			{
				return std::max(1, std::min(iBestHeal, getDamage()));
			}
			return std::max(0, std::min(iBestHeal, getDamage()));
		}
	}

	int iTotalHeal = 0;

	if (!hasNoSelfHeal() || getSelfHealModifierTotal() < 0)
	{
		iTotalHeal += getSelfHealModifierTotal();
	}

	if (pPlot->isCity(true, getTeam()))
	{
		iTotalHeal += GC.getCITY_HEAL_RATE() + (GET_TEAM(getTeam()).isFriendlyTerritory(pPlot->getTeam()) ? getExtraFriendlyHeal() : getExtraNeutralHeal());

		const CvCity* pCity = pPlot->getPlotCity();

		if (pCity && !pCity->isOccupation())
		{
			iTotalHeal += pCity->getHealRate();
		}
	}
	else if (!hasNoSelfHeal())
	{
		if (!GET_TEAM(getTeam()).isFriendlyTerritory(pPlot->getTeam()))
		{
			if (isEnemy(pPlot->getTeam(), pPlot))
			{
				iTotalHeal += (GC.getENEMY_HEAL_RATE() + getExtraEnemyHeal());
			}
			else
			{
				iTotalHeal += (GC.getNEUTRAL_HEAL_RATE() + getExtraNeutralHeal());
			}
		}
		else
		{
			iTotalHeal += (GC.getFRIENDLY_HEAL_RATE() + getExtraFriendlyHeal());
		}
	}
	CvUnit* pHealUnit = NULL;

	// XXX optimize this (save it?)
	int iBestHeal = 0;

	foreach_(CvUnit* pLoopUnit, pPlot->units())
	{
		if (pLoopUnit->getTeam() == getTeam() && pLoopUnit->hasHealSupportRemaining()) // XXX what about alliances?
		{
			const int iHeal = pLoopUnit->getSameTileHeal();

			if (iHeal > iBestHeal)
			{
				iBestHeal = iHeal;
				pHealUnit = pLoopUnit;
			}
		}
	}

	foreach_(const CvPlot* pLoopPlot, pPlot->adjacent() | filtered(CvPlot::fn::area() == pPlot->area()))
	{
		foreach_(CvUnit* pLoopUnit, pLoopPlot->units())
		{
			if (pLoopUnit->getTeam() == getTeam() && pLoopUnit->hasHealSupportRemaining()) // XXX what about alliances?
			{
				const int iHeal = pLoopUnit->getAdjacentTileHeal();

				if (iHeal > iBestHeal)
				{
					iBestHeal = iHeal;
					pHealUnit = pLoopUnit;
				}
			}
		}
	}
	iTotalHeal += iBestHeal;

	if (pHealUnit != NULL && bHealCheck)
	{
		pHealUnit->changeHealSupportUsed(1);
		pHealUnit->changeExperience100((10));
	}

	if (!hasNoSelfHeal())
	{
		return std::max(1, iTotalHeal);
	}
	return std::max(0, iTotalHeal);
}

int CvUnit::getHealRateAsType(const CvPlot* pPlot, bool bHealCheck, UnitCombatTypes eHealAsType) const
{
	PROFILE_FUNC();
	{
		bool bIsValid = false;
		for (int iI = 0; iI < m_pUnitInfo->getNumHealAsTypes(); iI++)
		{
			if (m_pUnitInfo->getHealAsType(iI) == eHealAsType)
			{
				bIsValid = true;
				break;
			}
		}
		if (!bIsValid)
		{
			return MAX_INT;
		}
	}
	if (pPlot->getTotalTurnDamage(this) > 0)
	{
		return 0;
	}
	int iTotalHeal = 0;

	if (!hasNoSelfHeal() || (getSelfHealModifierTotal() < 0))
	{
		iTotalHeal += getSelfHealModifierTotal();
	}

	if (pPlot->isCity(true, getTeam()))
	{
		iTotalHeal += GC.getCITY_HEAL_RATE() + (GET_TEAM(getTeam()).isFriendlyTerritory(pPlot->getTeam()) ? getExtraFriendlyHeal() : getExtraNeutralHeal());

		const CvCity* pCity = pPlot->getPlotCity();

		if (pCity && !pCity->isOccupation())
		{
			iTotalHeal += pCity->getHealRate() + pCity->getHealUnitCombatTypeTotal(eHealAsType);
		}
	}
	else if (!hasNoSelfHeal())
	{
		if (GET_TEAM(getTeam()).isFriendlyTerritory(pPlot->getTeam()))
		{
			iTotalHeal += GC.getFRIENDLY_HEAL_RATE() + getExtraFriendlyHeal();
		}
		else if (isEnemy(pPlot->getTeam(), pPlot))
		{
			iTotalHeal += GC.getENEMY_HEAL_RATE() + getExtraEnemyHeal();
		}
		else
		{
			iTotalHeal += GC.getNEUTRAL_HEAL_RATE() + getExtraNeutralHeal();
		}
	}

	// XXX optimize this (save it?)
	int iBestHeal = 0;
	CvUnit* pHealUnit = NULL;

	foreach_(CvUnit* pLoopUnit, pPlot->units())
	{
		if (pLoopUnit->getTeam() == getTeam() && pLoopUnit->hasHealSupportRemaining()) // XXX what about alliances?
		{
			const int iHeal = pLoopUnit->getSameTileHeal() + pLoopUnit->getHealUnitCombatTypeTotal(eHealAsType);

			//if (pLoopUnit->getSameTileHeal() > 0 || pLoopUnit->getHealUnitCombatTypeTotal(eHealAsType) > 0)
			//{
			//	iHeal += pLoopUnit->establishModifier();
			//}

			if (iHeal > iBestHeal)
			{
				iBestHeal = iHeal;
				pHealUnit = pLoopUnit;
			}
		}
	}
	foreach_(const CvPlot* pLoopPlot, pPlot->adjacent() | filtered(CvPlot::fn::area() == pPlot->area()))
	{
		foreach_(CvUnit* pLoopUnit, pLoopPlot->units())
		{
			if (pLoopUnit->getTeam() == getTeam() && pLoopUnit->hasHealSupportRemaining()) // XXX what about alliances?
			{
				const int iHeal = pLoopUnit->getAdjacentTileHeal() + pLoopUnit->getHealUnitCombatTypeAdjacentTotal(eHealAsType);

				//if (pLoopUnit->getAdjacentTileHeal() > 0 || pLoopUnit->getHealUnitCombatTypeAdjacentTotal(eHealAsType) > 0)
				//{
				//	iHeal += pLoopUnit->establishModifier();
				//}

				if (iHeal > iBestHeal)
				{
					iBestHeal = iHeal;
					pHealUnit = pLoopUnit;
				}
			}
		}
	}
	if (pHealUnit != NULL && bHealCheck)
	{
		pHealUnit->changeHealSupportUsed(1);
		pHealUnit->changeExperience100(10 / m_pUnitInfo->getNumHealAsTypes());
	}
	iTotalHeal += iBestHeal;

	if (hasNoSelfHeal())
	{
		return std::max(0, iTotalHeal);
	}
	return std::max(1, iTotalHeal);
}


int CvUnit::healTurns(const CvPlot* pPlot) const
{
	PROFILE_EXTRA_FUNC();
	if (!isHurt() || pPlot->getTotalTurnDamage(this) > 0)
	{
		return 0;
	}
	const int iNumHealAs = m_pUnitInfo->getNumHealAsTypes();

	//Find what will take the longest to heal and use that rate
	if (iNumHealAs > 0)
	{
		bool bNeedsHealing = false;
		int iBestNumTurns = 0;

		for (int iI = 0; iI < iNumHealAs; iI++)
		{
			const UnitCombatTypes eHealAsType = (UnitCombatTypes)m_pUnitInfo->getHealAsType(iI);
			const int iHealDamage = getHealAsDamage(eHealAsType);
			if (iHealDamage > 0)
			{
				bNeedsHealing = true;
				const int iHealRate = getHealRateAsType(pPlot, false, eHealAsType);

				if (iHealRate > 0 && iHealRate < MAX_INT)
				{
					int iNumTurns = iHealDamage / iHealRate;
					if ((iHealDamage % iHealRate) != 0)
					{
						iNumTurns++;
					}
					//Note we're actually looking for the slowest to heal here to use that for the # of rounds to heal total
					if (iNumTurns > iBestNumTurns)
					{
						iBestNumTurns = iNumTurns;
					}
				}
			}
		}
		if (bNeedsHealing)
		{
			return iBestNumTurns;
		}
	}

	const int iHeal = healRate(pPlot);

	if (iHeal > 0)
	{
		int iTurns = getDamage() / iHeal;

		if ((getDamage() % iHeal) != 0)
		{
			iTurns++;
		}
		return iTurns;
	}
	return MAX_INT;
}

int CvUnit::healTurnsAsType(const CvPlot* pPlot, UnitCombatTypes eHealAsType) const
{
	const int iHealDamage = getHealAsDamage(eHealAsType);
	if (iHealDamage < 1)
	{
		return MAX_INT;
	}
	const int iHealAs = getHealRateAsType(pPlot, false, eHealAsType);
	if (iHealAs < 1)
	{
		return MAX_INT;
	}
	int iNumTurns = iHealDamage / iHealAs;

	if ((iHealDamage % iHealAs) != 0)
	{
		iNumTurns++;
	}
	return iNumTurns;
}

void CvUnit::doHeal()
{
	PROFILE_EXTRA_FUNC();
	UnitCombatTypes eHealAsType = NO_UNITCOMBAT;

	if (m_pUnitInfo->getNumHealAsTypes() > 0)
	{
		for (int iI = 0; iI < m_pUnitInfo->getNumHealAsTypes(); iI++)
		{
			eHealAsType = (UnitCombatTypes)m_pUnitInfo->getHealAsType(iI);
			if (!isHasUnitCombat(eHealAsType))
			{
				setHasUnitCombat(eHealAsType, true);
				setHealAsDamage(eHealAsType, getDamage());
			}
			if (getHealAsDamage(eHealAsType) > 0)
			{
				changeHealAsDamage(eHealAsType,-(getHealRateAsType(plot(), true, eHealAsType)));
			}
		}
	}
	else
	{
		changeDamage(-(healRate(plot(), true)));
	}
	//TB Combat Mod begin
	//Note: to be re-evaluated!!!
	if (getColdDamage() > 0)
	{
		changeColdDamage(-(healRate(plot())));
	}
	//TB Combat Mod end
}

#ifdef OUTBREAKS_AND_AFFLICTIONS
void CvUnit::doAffliction(const bool bHeal)
{
	PROFILE_EXTRA_FUNC();
	for (int iI = GC.getNumPromotionLineInfos() - 1; iI > -1; iI--)
	{
		const PromotionLineTypes ePromoLine = static_cast<PromotionLineTypes>(iI);
		const CvPromotionLineInfo& promoLine = GC.getPromotionLineInfo(ePromoLine);

		if (promoLine.isAffliction())
		{
			const bool bHasAffliction = hasAfflictionLine(ePromoLine);

			if (bHasAffliction)
			{
				changeAfflictionTurnCount(ePromoLine, 1);

				for (int iJ = 0; iJ < promoLine.getNumPromotions(); iJ++)
				{
					//Update Afflictions
					const PromotionTypes ePromotion = (PromotionTypes)promoLine.getPromotion(iJ);

					if (isHasPromotion(ePromotion))
					{
						changeAfflictionHitCount(ePromotion, 1);
						updateAfflictionHits(ePromotion);

						if (GC.getPromotionInfo(ePromotion).isParalyze())
						{
							changeImmobileTimer(1);
						}
					}
				}
			}
			//Update Afflictions
			const int iToleranceDecay = promoLine.getToleranceDecay();

			if (!bHasAffliction && getUnitAfflictionTolerance(ePromoLine) > 0 && iToleranceDecay != 0)
			{
				changeUnitAfflictionTolerance(ePromoLine, -iToleranceDecay);
			}

			int iCommunicableExposure = getTotalCommunicableExposure(ePromoLine);
			if (iCommunicableExposure > 0)//sure we have access to communicable source?  Maybe included in checkcontract huh?
			{
				if (checkContractDisease(ePromoLine, iCommunicableExposure))
				{
					afflict(ePromoLine);
				}
			}
			if (bHeal && bHasAffliction)
			{
				doOvercomeAttempt(ePromoLine);
			}
		}
	}
}
#endif

bool CvUnit::canAirlift(const CvPlot* pPlot) const
{
	if (getDomainType() != DOMAIN_LAND || hasMoved())
	{
		return false;
	}
	const CvCity* pCity = pPlot->getPlotCity();

	return pCity && pCity->getCurrAirlift() < pCity->getMaxAirlift() && pCity->getTeam() == getTeam();
}


bool CvUnit::canAirliftAt(const CvPlot* pPlot, int iX, int iY) const
{
	if (!canAirlift(pPlot))
	{
		return false;
	}
	const CvPlot* pTargetPlot = GC.getMap().plot(iX, iY);

	if (!canEnterPlot(pTargetPlot))
	{
		return false;
	}

	// Super Forts begin *airlift*
	if (pTargetPlot->getTeam() != NO_TEAM
	&& (pTargetPlot->getTeam() == getTeam() || GET_TEAM(pTargetPlot->getTeam()).isVassal(getTeam()))
	&&  pTargetPlot->getImprovementType() != NO_IMPROVEMENT
	&& GC.getImprovementInfo(pTargetPlot->getImprovementType()).isActsAsCity())
	{
		return true;
	}
	// Super Forts end
	{
		const CvCity* pTargetCity = pTargetPlot->getPlotCity();

		if (pTargetCity == NULL || pTargetCity->isAirliftTargeted())
		{
			return false;
		}

		if (pTargetCity->getTeam() != getTeam() && !GET_TEAM(pTargetCity->getTeam()).isVassal(getTeam()))
		{
			return false;
		}
	}
	if (!GET_TEAM(getTeam()).isRebaseAnywhere()
	&& GC.getGame().isModderGameOption(MODDERGAMEOPTION_AIRLIFT_RANGE)
	&& plotDistance(pPlot->getX(), pPlot->getY(), iX, iY) > GC.getGame().getModderGameOption(MODDERGAMEOPTION_AIRLIFT_RANGE))
	{
		return false;
	}
	return true;
}


bool CvUnit::airlift(int iX, int iY)
{
	if (!canAirliftAt(plot(), iX, iY))
	{
		return false;
	}
	CvCity* pCity = plot()->getPlotCity();

	CvPlot* pTargetPlot = GC.getMap().plot(iX, iY);

	FAssert(pCity != NULL && pTargetPlot != NULL);

	// Super Forts begin *airlift* - added if statement to allow airlifts to plots that aren't cities
	if (pTargetPlot->isCity())
	{
		CvCity* pTargetCity = pTargetPlot->getPlotCity();

		FAssert(pTargetCity != NULL && pCity != pTargetCity);

		if (pTargetCity->getMaxAirlift() == 0)
		{
			pTargetCity->setAirliftTargeted(true);
		}
	}
	pCity->changeCurrAirlift(1);
	// Super Forts end

	finishMoves();

	//GC.getGame().logOOSSpecial(18, getID(), pTargetPlot->getX(), pTargetPlot->getY());
	setXY(pTargetPlot->getX(), pTargetPlot->getY());

	return true;
}


void CvUnit::nukeDiplomacy(bool* nukedTeams)
{
	const PlayerTypes eMyOwner = getOwner();
	const TeamTypes eMyTeam = getTeam();
	CvTeam& myTeam = GET_TEAM(eMyTeam);

	for (int iI = 0; iI < MAX_PC_TEAMS; iI++)
	{
		if (nukedTeams[iI])
		{
			const TeamTypes eNukedTeam = static_cast<TeamTypes>(iI);
			CvTeam& nukedTeam = GET_TEAM(eNukedTeam);

			if (!isEnemy(eNukedTeam))
			{
				myTeam.declareWar(eNukedTeam, false, WARPLAN_TOTAL);
			}
			nukedTeam.changeWarWeariness(eMyTeam, 100 * GC.getDefineINT("WW_HIT_BY_NUKE"));
			myTeam.changeWarWeariness(eNukedTeam, 100 * GC.getDefineINT("WW_ATTACKED_WITH_NUKE"));
			myTeam.AI_changeWarSuccess(eNukedTeam, GC.getDefineINT("WAR_SUCCESS_NUKE"));

			for (int iJ = 0; iJ < MAX_PC_PLAYERS; iJ++)
			{
				CvPlayerAI& playerX = GET_PLAYER((PlayerTypes)iJ);

				if (playerX.isAliveAndTeam(eNukedTeam))
				{
					playerX.AI_changeMemoryCount(eMyOwner, MEMORY_NUKED_US, 1);
				}
			}
			for (int iJ = 0; iJ < MAX_PC_TEAMS; iJ++)
			{
				// If we are hit oureself we don't get further insulted if anyone else is too.
				if (!nukedTeams[iJ] && iJ != eMyTeam)
				{
					const TeamTypes eTeamX = static_cast<TeamTypes>(iJ);

					if (GET_TEAM(eTeamX).isAlive())
					{
						if (GET_TEAM(eTeamX).isHasMet(eNukedTeam)
						&&  GET_TEAM(eTeamX).AI_getAttitude(eNukedTeam) >= ATTITUDE_CAUTIOUS)
						{
							for (int iK = 0; iK < MAX_PC_PLAYERS; iK++)
							{
								CvPlayerAI& playerX = GET_PLAYER((PlayerTypes)iK);

								if (playerX.isAliveAndTeam(eTeamX))
								{
									playerX.AI_changeMemoryCount(eMyOwner, MEMORY_NUKED_FRIEND, 1);
								}
							}
						}
						else
						{
							for (int iK = 0; iK < MAX_PC_PLAYERS; iK++)
							{
								CvPlayerAI& playerX = GET_PLAYER((PlayerTypes)iK);

								if (playerX.isAliveAndTeam(eTeamX)
								&&  playerX.AI_getMemoryCount(eMyOwner, MEMORY_NUKED_US) == 0
								&&  playerX.AI_getMemoryCount(eMyOwner, MEMORY_NUKED_FRIEND) == 0)
								{
									playerX.AI_changeMemoryCount(eMyOwner, MEMORY_USED_NUKE, 1);
								}
							}
						}
					}
				}
			}
		}
	}
}

bool CvUnit::isNukeVictim(const CvPlot* pPlot, const TeamTypes eTeam, const int iRange) const
{
	PROFILE_EXTRA_FUNC();
	if (!GET_TEAM(eTeam).isAlive() || eTeam == getTeam())
	{
		return false;
	}

	foreach_(const CvPlot* plotX, pPlot->rect(iRange, iRange))
	{
		if (plotX->getTeam() == eTeam || plotX->plotCheck(PUF_isCombatTeam, eTeam, getTeam()))
		{
			return true;
		}
	}
	return false;
}

bool CvUnit::canNuke() const
{
	return nukeRange() > -1;
}

bool CvUnit::canNukeAt(const CvPlot* pPlot, int iX, int iY) const
{
	PROFILE_EXTRA_FUNC();
	if (!canNuke())
	{
		return false;
	}
	const int iNukeRange = nukeRange();
	{
		const int iDistance = plotDistance(pPlot->getX(), pPlot->getY(), iX, iY);

		if (iDistance <= nukeRange() || airRange() > 0 && iDistance > airRange())
		{
			return false;
		}
	}
	const CvPlot* nukePlot = GC.getMap().plot(iX, iY);
	const CvTeam& team = GET_TEAM(getTeam());

	for (int iI = 0; iI < MAX_PC_TEAMS; iI++)
	{
		if (!team.isAtWar(static_cast<TeamTypes>(iI))
		&&  !team.canDeclareWar(static_cast<TeamTypes>(iI))
		&&  isNukeVictim(nukePlot, static_cast<TeamTypes>(iI), nukeRange()))
		{
			return false;
		}
	}
	return true;
}

bool CvUnit::nuke(int iX, int iY, bool bTrap)
{
	PROFILE_EXTRA_FUNC();

	if (!canNukeAt(plot(), iX, iY))
	{
		return false;
	}
	CvPlot* nukePlot = GC.getMap().plot(iX, iY);

	if (!bTrap && airBaseCombatStr() != 0 && interceptTest(nukePlot))
	{
		return true;
	}
	const PlayerTypes eMyOwner = getOwner();
	CvPlayerAI& myOwner = GET_PLAYER(eMyOwner);

	bool nukedTeams[MAX_PC_TEAMS];

	for (int iI = 0; iI < MAX_PC_TEAMS; iI++)
	{
		nukedTeams[iI] = isNukeVictim(nukePlot, (TeamTypes)iI, nukeRange());
	}

	if (!bTrap)
	{
		int iBestInterception = 0;
		TeamTypes eBestTeam = NO_TEAM;

		for (int iI = 0; iI < MAX_PC_TEAMS; iI++)
		{
			if (nukedTeams[iI] && GET_TEAM((TeamTypes)iI).getNukeInterception() > iBestInterception)
			{
				iBestInterception = GET_TEAM((TeamTypes)iI).getNukeInterception();
				eBestTeam = (TeamTypes)iI;
			}
		}

		iBestInterception *= 100 - m_pUnitInfo->getEvasionProbability();
		iBestInterception /= 100;

		if (airBaseCombatStr() != 0)
		{
			setReconPlot(nukePlot);
		}

		if (GC.getGame().getSorenRandNum(100, "Nuke") < iBestInterception)
		{
			for (int iI = 0; iI < MAX_PC_PLAYERS; iI++)
			{
				if (GET_PLAYER((PlayerTypes)iI).isAlive())
				{
					AddDLLMessage(
						(PlayerTypes)iI, iI == eMyOwner, GC.getEVENT_MESSAGE_TIME(),
						gDLL->getText(
							"TXT_KEY_MISC_NUKE_INTERCEPTED",
							myOwner.getNameKey(), getNameKey(),
							GET_TEAM(eBestTeam).getName().GetCString()
						),
						"AS2D_NUKE_INTERCEPTED", MESSAGE_TYPE_MAJOR_EVENT, getButton(),
						GC.getCOLOR_RED(), nukePlot->getX(), nukePlot->getY(), true, true
					);
				}
			}
			// Nuke entity mission
			// Add the intercepted mission (defender is not NULL)
			addMission(CvMissionDefinition(MISSION_NUKE, nukePlot, this, this));

			kill(true, NO_PLAYER, true);

			return true; // Intercepted!!! (XXX need special event for this...)
		}
	}

	if (nukePlot->isActiveVisible(false) && !isUsingDummyEntities() && isInViewport())
	{
		if (airBaseCombatStr() != 0)
		{
			addMission(CvAirMissionDefinition(MISSION_AIRSTRIKE, nukePlot, this));

			if (GC.getInfoTypeForString("EFFECT_JETFIGHTER_NUKE_EXPLODE") != -1)
			{
				gDLL->getEngineIFace()->TriggerEffect((EffectTypes)GC.getInfoTypeForString("EFFECT_JETFIGHTER_NUKE_EXPLODE"), nukePlot->getPoint(), 0);
				gDLL->getInterfaceIFace()->playGeneralSound("AS2D_NUKE_EXPLODES", nukePlot->getPoint());
			}
		}
		else // Nuke entity mission
		{
			// Add the non-intercepted mission (defender is NULL)
			addMission(CvMissionDefinition(MISSION_NUKE, nukePlot, this));
		}
	}

	setMadeAttack(true);
	setAttackPlot(nukePlot, false);

	nukeDiplomacy(nukedTeams);

	const CvWString szBuffer =
	(
		bTrap
		?
		gDLL->getText("TXT_KEY_MISC_NUKE_TRAP", getNameKey(), myOwner.getNameKey())
		:
		gDLL->getText("TXT_KEY_MISC_NUKE_LAUNCHED", myOwner.getNameKey(), getNameKey())
	);

	for (int iI = 0; iI < MAX_PC_PLAYERS; iI++)
	{
		if (GET_PLAYER((PlayerTypes)iI).isAlive())
		{
			AddDLLMessage(
				(PlayerTypes)iI, iI == eMyOwner, GC.getEVENT_MESSAGE_TIME(),
				szBuffer, "AS2D_NUKE_EXPLODES", MESSAGE_TYPE_MAJOR_EVENT,
				getButton(), GC.getCOLOR_RED(), nukePlot->getX(), nukePlot->getY(), true, true
			);
		}
	}

	if (isSuicide())
	{
		kill(true);
	}
	return true;
}


bool CvUnit::canRecon() const
{
	if (getDomainType() != DOMAIN_AIR)
	{
		return false;
	}

	if (airRange() == 0)
	{
		return false;
	}

	if (m_pUnitInfo->isSuicide())
	{
		return false;
	}

	return true;
}



bool CvUnit::canReconAt(const CvPlot* pPlot, int iX, int iY) const
{
	if (!canRecon())
	{
		return false;
	}

	const int iDistance = plotDistance(pPlot->getX(), pPlot->getY(), iX, iY);

	if (iDistance > airRange() || 0 == iDistance)
	{
		return false;
	}
	return true;
}


bool CvUnit::recon(int iX, int iY)
{
	if (!canReconAt(plot(), iX, iY))
	{
		return false;
	}

	CvPlot* pPlot = GC.getMap().plot(iX, iY);

	setReconPlot(pPlot);
	finishMoves();

	if (GC.getGame().isModderGameOption(MODDERGAMEOPTION_IMPROVED_XP))
	{
		 setExperience100(getExperience100() + 5);
	}
	addMission(CvAirMissionDefinition(MISSION_RECON, pPlot, this, NULL));

	return true;
}


bool CvUnit::canParadrop(const CvPlot* pPlot) const
{
	if (getDropRange() <= 0 || hasMoved() || !pPlot->isFriendlyCity(*this, true))
	{
		return false;
	}
	return true;
}


bool CvUnit::canParadropAt(const CvPlot* fromPlot, int toX, int toY) const
{
	if (!canParadrop(fromPlot))
	{
		return false;
	}

	CvPlot* pTargetPlot = GC.getMap().plot(toX, toY);
	if (NULL == pTargetPlot || pTargetPlot == fromPlot)
	{
		return false;
	}

	if (!pTargetPlot->isVisible(getTeam(), false))
	{
		return false;
	}

	if (!canEnterPlot(pTargetPlot, MoveCheck::IgnoreLoad))
	{
		return false;
	}

	if (plotDistance(fromPlot->getX(), fromPlot->getY(), toX, toY) > getDropRange())
	{
		return false;
	}

	if (!canCoexistAlwaysOnPlot(*pTargetPlot) && pTargetPlot->isEnemyCity(*this))
	{
		return false;
	}

	if (pTargetPlot->isWater() && getDomainType() == DOMAIN_LAND)
	{
		return false;
	}

	return true;
}


bool CvUnit::paradrop(int iX, int iY)
{
	if (!canParadropAt(plot(), iX, iY))
	{
		return false;
	}
	CvPlot* pPlot = GC.getMap().plot(iX, iY);

	if (!isFreeDrop())
	{
		changeMoves(GC.getMOVE_DENOMINATOR() / 2);
		setMadeAttack(true);
	}

	//GC.getGame().logOOSSpecial(19, getID(), pPlot->getX(), pPlot->getY());
	setXY(pPlot->getX(), pPlot->getY());

	//check if intercepted
	if (interceptTest(pPlot))
	{
		return true;
	}

	if (GC.getGame().isModderGameOption(MODDERGAMEOPTION_IMPROVED_XP))
	{
		 setExperience100(getExperience100() + 5);
	}

	//play paradrop animation by itself
	addMission(CvAirMissionDefinition(MISSION_PARADROP, pPlot, this));

	return true;
}


bool CvUnit::canAirBomb() const
{
	if (GC.isDCM_AIR_BOMBING() && isHuman())
	{
		return false;
	}

	if (getDomainType() != DOMAIN_AIR)
	{
		return false;
	}

	if (getAirBombBaseRate() == 0)
	{
		return false;
	}

	if (isMadeAttack())
	{
		return false;
	}
	return true;
}


bool CvUnit::canAirBombAt(const CvPlot* pPlot, int iX, int iY) const
{
	PROFILE_EXTRA_FUNC();
	if (!canAirBomb())
	{
		return false;
	}

	CvPlot* pTargetPlot = GC.getMap().plot(iX, iY);

	if (plotDistance(pPlot->getX(), pPlot->getY(), pTargetPlot->getX(), pTargetPlot->getY()) > airRange())
	{
		return false;
	}

	if (pTargetPlot->isOwned() && !potentialWarAction(pTargetPlot))
	{
		return false;
	}

	CvCity* pCity = pTargetPlot->getPlotCity();

	if (pTargetPlot->getImprovementType() != NO_IMPROVEMENT)
	{
		if (GC.getImprovementInfo(pTargetPlot->getImprovementType()).isActsAsCity() && pCity == NULL)
		{
			if (m_pUnitInfo->getDCMAirBomb4())
			{
				int iCount = 0;
				foreach_(const CvUnit* pLoopUnit, pPlot->units())
				{
					if (pLoopUnit->getDomainType() == DOMAIN_SEA && atWar(pLoopUnit->getTeam(), getTeam()))
					{
						iCount++;
					}
				}
				if (iCount > 0)
				{
					return true;
				}
			}
		}
	}
	else if (pCity != NULL)
	{
		if (GC.isDCM_AIR_BOMBING())
		{
			for (int iI = 0; iI < MAX_PLAYERS; ++iI)
			{
				if (atWar(GET_PLAYER((PlayerTypes)iI).getTeam(), getTeam()))
				{
					if (algo::any_of(GET_PLAYER((PlayerTypes)iI).units(),
						CvUnit::fn::plot() == pTargetPlot && CvUnit::fn::getDomainType() == DOMAIN_SEA))
					{
						return true;
					}
				}
			}
			if (pCity->isBombardable(this))
			{
				return true;
			}
			return false;
		}
		else if (!(pCity->isBombardable(this)))
		{
			return false;
		}
	}
	// Toffer - Something is wrong here, this else if can never be true as we already established that there's no improvement here if first if fails.
	else if (!pTargetPlot->isImprovementDestructible())
	{
		return false;
	}
	return true;
}


bool CvUnit::airBomb(int iX, int iY)
{
	PROFILE_EXTRA_FUNC();
	if (!canAirBombAt(plot(), iX, iY))
	{
		return false;
	}
	CvPlot* pPlot = GC.getMap().plot(iX, iY);

	if (!isEnemy(pPlot->getTeam()))
	{
		getGroup()->groupDeclareWar(pPlot, true);
	}

	if (!isEnemy(pPlot->getTeam()))
	{
		return false;
	}

	if (interceptTest(pPlot))
	{
		return true;
	}

	CvCity* pCity = pPlot->getPlotCity();

	if (pPlot->getImprovementType() != NO_IMPROVEMENT)
	{
		if (!GC.isDCM_AIR_BOMBING())
		{
			if (GC.getGame().getSorenRandNum(getAirBombCurrRate(), "Air Bomb - Offense")
				>=
				GC.getGame().getSorenRandNum(GC.getImprovementInfo(pPlot->getImprovementType()).getAirBombDefense(), "Air Bomb - Defense"))
			{
				AddDLLMessage(
					getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
					gDLL->getText(
						"TXT_KEY_MISC_YOU_UNIT_DESTROYED_IMP",
						getNameKey(), GC.getImprovementInfo(pPlot->getImprovementType()).getTextKeyWide()
					),
					"AS2D_PILLAGE", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_GREEN(), pPlot->getX(), pPlot->getY()
				);
				if (pPlot->isOwned())
				{
					if (BARBARIAN_PLAYER != getVisualOwner(getTeam()))
					{
						AddDLLMessage(
							pPlot->getOwner(), false, GC.getEVENT_MESSAGE_TIME(),
							gDLL->getText(
								"TXT_KEY_MISC_YOU_IMP_WAS_DESTROYED",
								GC.getImprovementInfo(pPlot->getImprovementType()).getTextKeyWide(),
								getNameKey(), getVisualCivAdjective(pPlot->getTeam())
							),
							"AS2D_PILLAGED", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_RED(), pPlot->getX(), pPlot->getY(), true, true
						);
					}
					else
					{
						AddDLLMessage(
							pPlot->getOwner(), false, GC.getEVENT_MESSAGE_TIME(),
							gDLL->getText(
								"TXT_KEY_MISC_YOU_IMP_WAS_DESTROYED_HIDDEN",
								GC.getImprovementInfo(pPlot->getImprovementType()).getTextKeyWide(), getNameKey()
							),
							"AS2D_PILLAGED", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_RED(), pPlot->getX(), pPlot->getY(), true, true
						);
					}
				}
				pPlot->setImprovementType(GC.getImprovementInfo(pPlot->getImprovementType()).getImprovementPillage());
			}
			else
			{
				AddDLLMessage(
					getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
					gDLL->getText(
						"TXT_KEY_MISC_YOU_UNIT_FAIL_DESTROY_IMP",
						getNameKey(), GC.getImprovementInfo(pPlot->getImprovementType()).getTextKeyWide()
					),
					"AS2D_BOMB_FAILS", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_RED(), pPlot->getX(), pPlot->getY()
				);
			}
		}
		else if (GC.getImprovementInfo(pPlot->getImprovementType()).isActsAsCity() && pCity == NULL && m_pUnitInfo->getDCMAirBomb4()

		&& algo::any_of(pPlot->units(), CvUnit::fn::getDomainType() == DOMAIN_SEA))
		{
			airBomb4(iX, iY);
		}
	}
	else if (pCity != NULL)
	{
		if (!GC.isDCM_AIR_BOMBING())
		{
			pCity->changeDefenseModifier(-getAirBombCurrRate());

			AddDLLMessage(
				pCity->getOwner(), false, GC.getEVENT_MESSAGE_TIME(),
				gDLL->getText(
					"TXT_KEY_MISC_YOU_DEFENSES_REDUCED_TO",
					pCity->getNameKey(), pCity->getDefenseModifier(false), getNameKey()
				),
				"AS2D_BOMBARDED", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_RED(), pCity->getX(), pCity->getY(), true, true
			);
			AddDLLMessage(
				getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
				gDLL->getText(
					"TXT_KEY_MISC_ENEMY_DEFENSES_REDUCED_TO",
					getNameKey(), pCity->getNameKey(), pCity->getDefenseModifier(false)
				),
				"AS2D_BOMBARD", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_GREEN(), pCity->getX(), pCity->getY()
			);
		}
		else
		{
			int iMis1, iMis2, iMis3;
			iMis1 = iMis2 = iMis3 = 0;
			if (m_pUnitInfo->getDCMAirBomb1())
			{
				iMis1 = 10;
				int iCount = 0;
				foreach_(const CvPlot* pLoopPlot, plot()->rect(2, 2))
				{
					iCount += algo::count_if(pLoopPlot->units(), CvUnit::fn::getOwner() == getOwner());
				}
				iMis1 *= iCount * 2;
			}

			if (m_pUnitInfo->getDCMAirBomb2() || m_pUnitInfo->getDCMAirBomb3())
			{
				const bool bAirBomb2 = m_pUnitInfo->getDCMAirBomb2();
				const bool bAirBomb3 = m_pUnitInfo->getDCMAirBomb3();

				foreach_(const BuildingTypes eType, pCity->getHasBuildings())
				{
					if (pCity->isDisabledBuilding(eType))
					{
						continue;
					}
					if (GC.getBuildingInfo(eType).getDCMAirbombMission() == 2)
					{
						if (bAirBomb2)
						{
							iMis2 += 10;
						}
					}
					else if (bAirBomb3 && GC.getBuildingInfo(eType).getDCMAirbombMission() == 3)
					{
						iMis3 += 20;
					}
				}
			}
			const int iMis4 = m_pUnitInfo->getDCMAirBomb4() ? 40 * algo::count_if(pPlot->units(), CvUnit::fn::getDomainType() == DOMAIN_SEA) : 0;

			const int iMis5 = m_pUnitInfo->getDCMAirBomb5() ? 10 * GC.getGame().getSorenRandNum(20, "Strat Bombing") : 0;

			int iMis0 = 1;
			if (iMis2 > iMis1)
			{
				iMis1 = iMis2;
				iMis0++;
			}
			if (iMis3 > iMis1)
			{
				iMis1 = iMis3;
				iMis0++;
			}
			if (iMis4 > iMis1)
			{
				iMis1 = iMis4;
				iMis0++;
			}
			if (iMis5 > iMis1)
			{
				iMis0++;
			}
			bool bNoTarget = true;
			switch(iMis0)
			{
				case 1:
				{
					if (airBomb1(iX, iY))
					{
						bNoTarget = false;
					}
					break;
				}
				case 2:
				{
					if (airBomb2(iX, iY))
					{
						bNoTarget = false;
					}
					break;
				}
				case 3:
				{
					if (airBomb3(iX, iY))
					{
						bNoTarget = false;
					}
					break;
				}
				case 4:
				{
					if (airBomb4(iX, iY))
					{
						bNoTarget = false;
					}
					break;
				}
				case 5:
				{
					if (airBomb5(iX, iY))
					{
						bNoTarget = false;
					}
					break;
				}
			}
			if (bNoTarget && pCity->getPopulation() > 1 && GC.getGame().getSorenRandNum(5, "Airbomb population") < 2)
			{
				pCity->changePopulation(-1);

				AddDLLMessage(
					getOwner(), true, GC.getEVENT_MESSAGE_TIME(), gDLL->getText("TXT_KEY_MISC_YOU_AIRBOMB_POP"),
					"AS2D_BOMBARD", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_GREEN(), pCity->getX(), pCity->getY(), true, true
				);
				AddDLLMessage(
					pCity->getOwner(), false, GC.getEVENT_MESSAGE_TIME(), gDLL->getText("TXT_KEY_MISC_ENEMY_AIRBOMB_POP"),
					"AS2D_BOMBARDED", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_RED(), pCity->getX(), pCity->getY(), true, true
				);
			}
		}
	}
	setReconPlot(pPlot);
	setMadeAttack(true);
	changeMoves(GC.getMOVE_DENOMINATOR());
	addMission(CvAirMissionDefinition(MISSION_AIRBOMB, pPlot, this));

	if (isSuicide())
	{
		kill(true);
	}
	else if (GC.getGame().isModderGameOption(MODDERGAMEOPTION_IMPROVED_XP))
	{
		setExperience100(getExperience100() + 25 + GC.getGame().getSorenRandNum(26, "Random Min XP"));
	}
	return true;
}


CvCity* CvUnit::bombardTarget(const CvPlot* pPlot) const
{
	PROFILE_EXTRA_FUNC();
	int iBestValue = MAX_INT;
	CvCity* pBestCity = NULL;

	foreach_(const CvPlot* pLoopPlot, pPlot->adjacent())
	{
		CvCity* pLoopCity = pLoopPlot->getPlotCity();

		if (pLoopCity != NULL && pLoopCity->isBombardable(this))
		{
			int iValue = pLoopCity->getDefenseDamage();

			// always prefer cities we are at war with
			if (isEnemy(pLoopCity->getTeam(), pPlot))
			{
				iValue *= 128;
			}

			if (iValue < iBestValue)
			{
				iBestValue = iValue;
				pBestCity = pLoopCity;
			}
		}
	}

	return pBestCity;
}


// Super Forts begin *bombard*
CvPlot* CvUnit::bombardImprovementTarget(const CvPlot* pPlot) const
{
	PROFILE_EXTRA_FUNC();
	int iBestValue = MAX_INT;
	CvPlot* pBestPlot = NULL;

	foreach_(CvPlot* pLoopPlot, pPlot->adjacent() | filtered(CvPlot::fn::isBombardable(this)))
	{
		int iValue = pLoopPlot->getDefenseDamage();

		// always prefer cities we are at war with
		if (isEnemy(pLoopPlot->getTeam(), pPlot))
		{
			iValue *= 128;
		}

		if (iValue < iBestValue)
		{
			iBestValue = iValue;
			pBestPlot = pLoopPlot;
		}
	}

	return pBestPlot;
}
// Super Forts end

bool CvUnit::canBombard(const CvPlot* pPlot, bool bIgnoreHasAttacked) const
{
	if (getBombardRate() <= 0)
	{
		return false;
	}

	if (!bIgnoreHasAttacked && isMadeAttack())
	{
		return false;
	}

	if (isCargo())
	{
		return false;
	}

	// Super Forts begin *bombard*
	if (bombardTarget(pPlot) == NULL && bombardImprovementTarget(pPlot) == NULL)
	//if (bombardTarget(pPlot) == NULL) - Original Code
	// Super Forts end
	{
		return false;
	}

	return true;
}


bool CvUnit::bombard()
{
	CvPlot* pPlot = plot();
	if (!canBombard(pPlot))
	{
		return false;
	}

	CvCity* pBombardCity = bombardTarget(pPlot);
	// Super Forts begin *bombard*
	//FAssertMsg(pBombardCity != NULL, "BombardCity is not assigned a valid value"); - Removed for Super Forts

	CvPlot* pTargetPlot;
	//CvPlot* pTargetPlot = pBombardCity->plot(); - Original Code
	if(pBombardCity != NULL)
	{
		pTargetPlot = pBombardCity->plot();
	}
	else
	{
		pTargetPlot = bombardImprovementTarget(pPlot);
	}
	// Super Forts end

	// Dale - RB: Bug Fix (RevolutionDCM - just checks for a null value)
	if (pTargetPlot != NULL)
	{
		if (!isEnemy(pTargetPlot->getTeam()))
		{
			getGroup()->groupDeclareWar(pTargetPlot, true);
		}

		if (!isEnemy(pTargetPlot->getTeam()))
		{
			return false;
		}

		int iBombardModifier = 0;
		// Super Forts begin *bombard* *text*
		if(pBombardCity != NULL)
		{

			if (!ignoreBuildingDefense())
			{
				iBombardModifier -= pBombardCity->getBuildingBombardDefense();
			}

			pBombardCity->changeDefenseModifier(-(getBombardRate() * std::max(0, 100 + iBombardModifier)) / 100);

			CvWString szBuffer = gDLL->getText("TXT_KEY_MISC_DEFENSES_IN_CITY_REDUCED_TO", pBombardCity->getNameKey(), pBombardCity->getDefenseModifier(false), GET_PLAYER(getOwner()).getNameKey());
			AddDLLMessage(pBombardCity->getOwner(), false, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_BOMBARDED", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_RED(), pBombardCity->getX(), pBombardCity->getY(), true, true);

			szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_REDUCE_CITY_DEFENSES", getNameKey(), pBombardCity->getNameKey(), pBombardCity->getDefenseModifier(false));
			AddDLLMessage(getOwner(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_BOMBARD", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_GREEN(), pBombardCity->getX(), pBombardCity->getY());
		}
		else
		{

			pTargetPlot->changeDefenseDamage(getBombardRate());

			CvWString szBuffer = gDLL->getText("TXT_KEY_MISC_DEFENSES_IN_CITY_REDUCED_TO", GC.getImprovementInfo(pTargetPlot->getImprovementType()).getText(),
				(GC.getImprovementInfo(pTargetPlot->getImprovementType()).getDefenseModifier()-pTargetPlot->getDefenseDamage()), GET_PLAYER(getOwner()).getNameKey());
			AddDLLMessage(pTargetPlot->getOwner(), false, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_BOMBARDED", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_RED(), pTargetPlot->getX(), pTargetPlot->getY(), true, true);

			szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_REDUCE_CITY_DEFENSES", getNameKey(), GC.getImprovementInfo(pTargetPlot->getImprovementType()).getText(),
				(GC.getImprovementInfo(pTargetPlot->getImprovementType()).getDefenseModifier()-pTargetPlot->getDefenseDamage()));
			AddDLLMessage(getOwner(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_BOMBARD", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_GREEN(), pTargetPlot->getX(), pTargetPlot->getY());
		}
		// Super Forts end

		changeExperience100(100, -1, true);
		setMadeAttack(true);
		changeMoves(GC.getMOVE_DENOMINATOR());

		if (GC.getGame().isModderGameOption(MODDERGAMEOPTION_IMPROVED_XP))
		{
			 setExperience100(getExperience100() + 1 + GC.getGame().getSorenRandNum(26, "Random Min XP"));
		}

		if (pPlot->isActiveVisible(false))
		{
			CvUnit *pDefender = pTargetPlot->getBestDefender(NO_PLAYER, getOwner(), this, true);

			// Bombard entity mission
			addMission(CvMissionDefinition(MISSION_BOMBARD, pTargetPlot, this, pDefender));
		}
	}
	return true;
}

bool CvUnit::canPillage(const CvPlot* pPlot) const
{
	if (pPlot == NULL || !m_pUnitInfo->isPillage())
	{
		return false;
	}

	if (isOnlyDefensive() && !isAnimal())
	{
		// Toffer - This is an odd one, probably specific to the locust swarm unit.
		return false;
	}

	if (GET_PLAYER(getOwner()).isModderOption(MODDEROPTION_NO_FRIENDLY_PILLAGING) && pPlot->getTeam() == getTeam())
	{
		return false;
	}

	if (isCargo())
	{
		return false;
	}

	if (pPlot->isCity())
	{
		return false;
	}

	if (pPlot->getImprovementType() == NO_IMPROVEMENT)
	{
		if (!pPlot->isRoute())
		{
			return false;
		}
	}

	if (pPlot->isOwned() && !potentialWarAction(pPlot)
	&& (pPlot->getImprovementType() == NO_IMPROVEMENT || pPlot->getOwner() != getOwner()))
	{
		return false;
	}

	if (!pPlot->isValidDomainForAction(*this))
	{
		return false;
	}

	return true;
}


bool CvUnit::pillage(const bool bAutoPillage)
{
	PROFILE_EXTRA_FUNC();
	CvPlot* pPlot = plot();

	if (!canPillage(pPlot))
	{
		return false;
	}

	const PlayerTypes ePlayerPillaged = pPlot->getOwner();
	if (ePlayerPillaged != NO_PLAYER
	// We should not be calling this without declaring war first, so do not declare war here
	&& !isEnemy(pPlot->getTeam(), pPlot)
	&& (pPlot->getImprovementType() == NO_IMPROVEMENT || ePlayerPillaged != getOwner()))
	{
		return false;
	}

	if (pPlot->isWater())
	{
		CvUnit* pInterceptor = bestSeaPillageInterceptor(this, GC.getCOMBAT_DIE_SIDES() / 2);

		if (NULL != pInterceptor)
		{
			setMadeAttack(false);

			int iWithdrawal = withdrawalProbability();
			changeExtraWithdrawal(-iWithdrawal); // no withdrawal since we are really the defender
			attack(pInterceptor->plot());
			changeExtraWithdrawal(iWithdrawal);

			return false;
		}
	}
	CvPlayer& player = GET_PLAYER(getOwner());
	int iPillageGold = 0;
	ImprovementTypes eTempImprovement = NO_IMPROVEMENT;
	RouteTypes eTempRoute = NO_ROUTE;

	if (pPlot->getImprovementType() != NO_IMPROVEMENT)
	{
		eTempImprovement = pPlot->getImprovementType();

		if (ePlayerPillaged != NO_PLAYER && pPlot->getTeam() != getTeam())
		{
			// Use python to determine pillage amounts...
			iPillageGold = Cy::call<int>(PYGameModule, "doPillageGold", Cy::Args() << pPlot << this);

			if (iPillageGold > 0)
			{
				const int iInfluenceRatio =
				(
					GC.isIDW_ENABLED() && GC.isIDW_PILLAGE_INFLUENCE_ENABLED() && atWar(pPlot->getTeam(), getTeam())
					?
					doPillageInfluence()
					:
					0
				);
				iPillageGold += iPillageGold * getPillageChange() / 100;
				player.changeGold(iPillageGold);

				if (isHuman())
				{
					AddDLLMessage(
						getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
						gDLL->getText(
							"TXT_KEY_MISC_PLUNDERED_GOLD_FROM_IMP",
							iPillageGold, GC.getImprovementInfo(pPlot->getImprovementType()).getTextKeyWide()
						)
						, "AS2D_PILLAGE", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_GREEN(),
						pPlot->getX(), pPlot->getY()
					);
				}
				for (int iI = 0; iI < NUM_COMMERCE_TYPES; ++iI)
				{
					CommerceTypes eCommerce = (CommerceTypes)iI;
					switch (eCommerce)
					{
						case COMMERCE_GOLD:
						{
							if (isPillageMarauder())
							{
								player.changeGold(iPillageGold);
								pPlot->setImprovementType(GC.getImprovementInfo(pPlot->getImprovementType()).getImprovementPillage());
								if (isHuman())
								{
									AddDLLMessage(
										getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
										gDLL->getText(
											"TXT_KEY_MISC_MARAUDERS_PLUNDERED_IMP",
											iPillageGold, GC.getImprovementInfo(pPlot->getImprovementType()).getTextKeyWide()
										),
										"AS2D_PILLAGE", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_GREEN(),
										pPlot->getX(), pPlot->getY()
									);
								}
								if (GET_PLAYER(ePlayerPillaged).isHumanPlayer())
								{
									AddDLLMessage(
										ePlayerPillaged, false, GC.getEVENT_MESSAGE_TIME(),
										gDLL->getText(
											"TXT_KEY_MISC_IMP_DESTROYED_BY_MARAUDERS",
											GC.getImprovementInfo(pPlot->getImprovementType()).getTextKeyWide(),
											getNameKey(), getVisualCivAdjective(pPlot->getTeam())
										),
										"AS2D_PILLAGED", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_RED(),
										pPlot->getX(), pPlot->getY(), true, true
									);
								}
							}
							break;
						}
						case COMMERCE_RESEARCH:
						{
							if (isPillageResearch())
							{
								GET_TEAM(player.getTeam()).changeResearchProgress(player.getCurrentResearch(), iPillageGold, getOwner());
								if (isHuman())
								{
									AddDLLMessage(
										getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
										gDLL->getText(
											"TXT_KEY_MISC_PLUNDERED_RESEARCH_FROM_IMP",
											iPillageGold, GC.getImprovementInfo(pPlot->getImprovementType()).getTextKeyWide()
										),
										"AS2D_PILLAGE", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_GREEN(),
										pPlot->getX(), pPlot->getY()
									);
								}
							}
							break;
						}
						case COMMERCE_CULTURE:
						{
							break;
						}
						case COMMERCE_ESPIONAGE:
						{
							if (isPillageEspionage() && pPlot->getTeam() != NO_TEAM)
							{
								GET_TEAM(player.getTeam()).changeEspionagePointsAgainstTeam(pPlot->getTeam(), iPillageGold);
								if (isHuman())
								{
									AddDLLMessage(
										getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
										gDLL->getText(
											"TXT_KEY_MISC_PLUNDERED_ESPIONAGE_FROM_IMP",
											iPillageGold, GC.getImprovementInfo(pPlot->getImprovementType()).getTextKeyWide()
										),
										"AS2D_PILLAGE", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_GREEN(),
										pPlot->getX(), pPlot->getY()
									);
								}
							}
							break;
						}
					}
				}
				if (GET_PLAYER(ePlayerPillaged).isHumanPlayer())
				{
					CvWString szBuffer = gDLL->getText("TXT_KEY_MISC_IMP_DESTROYED", GC.getImprovementInfo(pPlot->getImprovementType()).getTextKeyWide(), getNameKey(), getVisualCivAdjective(pPlot->getTeam()));

					if (iInfluenceRatio > 0)
					{
						szBuffer = szBuffer + CvString::format(" %s: -%.1f%%", gDLL->getText("TXT_KEY_TILE_INFLUENCE").GetCString(), ((float)iInfluenceRatio)/10);
					}
					AddDLLMessage(
						ePlayerPillaged, false, GC.getEVENT_MESSAGE_TIME(), szBuffer,
						"AS2D_PILLAGED", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_RED(), pPlot->getX(), pPlot->getY(), true, true
					);
				}
				//	A pillage implies a source of danger even if we can't see it
				GET_PLAYER(ePlayerPillaged).addPlotDangerSource(pPlot, 100);
			}
		}
		pPlot->setImprovementType(GC.getImprovementInfo(pPlot->getImprovementType()).getImprovementPillage());
	}
	else if (pPlot->isRoute() && !bAutoPillage)
	{
		eTempRoute = pPlot->getRouteType();
		pPlot->setRouteType(NO_ROUTE, true); // XXX downgrade rail???

		// Afforess - Alert Player of Pillaged Routes
		if (ePlayerPillaged != NO_PLAYER)
		{
			// A pillage implies a source of danger even if we can't see it
			GET_PLAYER(ePlayerPillaged).addPlotDangerSource(pPlot, 100);

			if (GET_PLAYER(ePlayerPillaged).isHumanPlayer())
			{
				AddDLLMessage(
					pPlot->getOwner(), false, GC.getEVENT_MESSAGE_TIME(),
					gDLL->getText(
						"TXT_KEY_MISC_IMP_DESTROYED",
						GC.getRouteInfo(eTempRoute).getTextKeyWide(), getNameKey(),
						getVisualCivAdjective(pPlot->getTeam())
					)
					, "AS2D_PILLAGED", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_RED(),
					pPlot->getX(), pPlot->getY(), true, true
				);
			}
		}
	}
	changeMoves(GC.getMOVE_DENOMINATOR());

	if (GC.getGame().isModderGameOption(MODDERGAMEOPTION_IMPROVED_XP))
	{
		setExperience100(getExperience100() + 10 + GC.getGame().getSorenRandNum(21, "Random Min XP"));
	}
	else if (iPillageGold > 0 && pPlot->getOwner() != getOwner())
	{
		changeExperience100(iPillageGold);
	}
	addMission(CvMissionDefinition(MISSION_PILLAGE, pPlot, this));

	if (eTempImprovement != NO_IMPROVEMENT || eTempRoute != NO_ROUTE)
	{
		CvEventReporter::getInstance().unitPillage(this, eTempImprovement, eTempRoute, getOwner());
	}

	return true;
}


bool CvUnit::canPlunder(const CvPlot* pPlot, bool bTestVisible) const
{
	if (getDomainType() != DOMAIN_SEA)
	{
		return false;
	}

	if (!m_pUnitInfo->isPillage())
	{
		return false;
	}

	if (!pPlot->isWater() || pPlot->isFreshWater())
	{
		return false;
	}

	if (!pPlot->isValidDomainForAction(*this))
	{
		return false;
	}

	if (!bTestVisible && pPlot->getTeam() == getTeam())
	{
		return false;
	}

	return true;
}


bool CvUnit::plunder()
{
	if (!canPlunder(plot()))
	{
		return false;
	}
	setBlockading(true);
	finishMoves();

	return true;
}


void CvUnit::updatePlunder(int iChange, bool bUpdatePlotGroups)
{
	PROFILE_FUNC();

	const int iBlockadeRange = GC.getDefineINT("SHIP_BLOCKADE_RANGE");
	bool bChanged = false;

	if (bUpdatePlotGroups)
	{
		CvPlot::setDeferredPlotGroupRecalculationMode(true);
	}

	foreach_(CvPlot* pLoopPlot, plot()->rect(iBlockadeRange, iBlockadeRange))
	{
		if (!pLoopPlot->isWater() || pLoopPlot->area() != area())
		{
			continue;
		}
		const int iPathDist = GC.getMap().calculatePathDistance(plot(),pLoopPlot);

		/* BBAI NOTES:
		// There are rare issues where the path finder will return incorrect results for unknown reasons.
		// Seems to find a suboptimal path sometimes in partially repeatable circumstances.
		// The fix below is a hack to address the permanent one or two tile blockades which
		// would appear randomly, it should cause extra blockade clearing only very rarely.
		if (iPathDist > iBlockadeRange)
		{
			continue; // No blockading on other side of an isthmus
		}
		*/
		if (iPathDist < 0 || iPathDist > iBlockadeRange + 2)
		{
			continue;
		}
		for (int iTeam = 0; iTeam < MAX_TEAMS; ++iTeam)
		{
			if (isEnemy((TeamTypes)iTeam)
			&& (iPathDist <= iBlockadeRange || iChange == -1 && pLoopPlot->getBlockadedCount((TeamTypes)iTeam) > 0))
			{
				const bool bOldTradeNet = pLoopPlot->isTradeNetwork((TeamTypes)iTeam);

				pLoopPlot->changeBlockadedCount((TeamTypes)iTeam, iChange);

				if (bOldTradeNet != pLoopPlot->isTradeNetwork((TeamTypes)iTeam))
				{
					bChanged = true;
					if (bUpdatePlotGroups)
					{
						pLoopPlot->updatePlotGroup();
					}
				}
			}
		}
	}

	if (bChanged)
	{
		gDLL->getInterfaceIFace()->setDirty(BlockadedPlots_DIRTY_BIT, true);

		if (bUpdatePlotGroups)
		{
			CvPlot::setDeferredPlotGroupRecalculationMode(false);
		}
	}
}


int CvUnit::sabotageProb(const CvPlot* pPlot, ProbabilityTypes eProbStyle) const
{
	PROFILE_EXTRA_FUNC();
	if (!pPlot->isOwned())
	{
		return 40 + 50 * (eProbStyle != PROBABILITY_LOW);
	}
	const int iProb = 40 / (pPlot->plotCount(PUF_canDefend, -1, -1, NULL, NO_PLAYER, pPlot->getTeam()) + 1);

	if (eProbStyle == PROBABILITY_LOW)
	{
		return iProb;
	}
	if (eProbStyle == PROBABILITY_HIGH)
	{
		return iProb + 50;
	}
	int iCounterSpyCount = pPlot->plotCount(PUF_isCounterSpy, -1, -1, NULL, NO_PLAYER, pPlot->getTeam());

	foreach_(const CvPlot* pLoopPlot, pPlot->adjacent())
	{
		iCounterSpyCount += pLoopPlot->plotCount(PUF_isCounterSpy, -1, -1, NULL, NO_PLAYER, pPlot->getTeam());
	}
	return iProb + 50 / (iCounterSpyCount + 1);
}


bool CvUnit::canSabotage(const CvPlot* pPlot, bool bTestVisible) const
{
	if (!m_pUnitInfo->isSabotage())
	{
		return false;
	}

	if (pPlot->getTeam() == getTeam() || pPlot->isCity())
	{
		return false;
	}

	if (pPlot->getImprovementType() == NO_IMPROVEMENT)
	{
		return false;
	}

	if (!bTestVisible && GET_PLAYER(getOwner()).getGold() < GC.getBASE_SPY_SABOTAGE_COST())
	{
		return false;
	}

	return true;
}


bool CvUnit::sabotage()
{
	if (!canSabotage(plot()))
	{
		return false;
	}

	CvPlot* pPlot = plot();

	GET_PLAYER(getOwner()).changeGold(-GC.getBASE_SPY_SABOTAGE_COST());

	if (GC.getGame().getSorenRandNum(100, "Spy: Sabotage") <= sabotageProb(pPlot))
	{
		pPlot->setImprovementType(GC.getImprovementInfo(pPlot->getImprovementType()).getImprovementPillage());

		finishMoves();

		const CvCity* pNearestCity = GC.getMap().findCity(pPlot->getX(), pPlot->getY(), pPlot->getOwner(), NO_TEAM, false);

		if (pNearestCity != NULL)
		{
			AddDLLMessage(
				getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
				gDLL->getText("TXT_KEY_MISC_SPY_SABOTAGED", getNameKey(), pNearestCity->getNameKey()),
				"AS2D_SABOTAGE", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_GREEN(), pPlot->getX(), pPlot->getY()
			);
			if (pPlot->isOwned())
			{
				AddDLLMessage(
					pPlot->getOwner(), false, GC.getEVENT_MESSAGE_TIME(),
					gDLL->getText("TXT_KEY_MISC_SABOTAGE_NEAR", pNearestCity->getNameKey()),
					"AS2D_SABOTAGE", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_RED(),
					pPlot->getX(), pPlot->getY(), true, true
				);
			}
		}

		if (pPlot->isActiveVisible(false))
		{
			NotifyEntity(MISSION_SABOTAGE);
		}
	}
	else // Caught red handed
	{
		if (plot()->isActiveVisible(false))
		{
			NotifyEntity(MISSION_SURRENDER);
		}

		if (pPlot->isOwned())
		{
			if (!isEnemy(pPlot->getTeam(), pPlot))
			{
				GET_PLAYER(pPlot->getOwner()).AI_changeMemoryCount(getOwner(), MEMORY_SPY_CAUGHT, 1);
			}
			AddDLLMessage(
				pPlot->getOwner(), false, GC.getEVENT_MESSAGE_TIME(),
				gDLL->getText(
					"TXT_KEY_MISC_SPY_CAUGHT_AND_KILLED",
					GET_PLAYER(getOwner()).getCivilizationAdjective(), getNameKey()
				),
				"AS2D_EXPOSE", MESSAGE_TYPE_INFO
			);
		}
		{
			AddDLLMessage(
				getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
				gDLL->getText("TXT_KEY_MISC_YOUR_SPY_CAUGHT", getNameKey()),
				"AS2D_EXPOSED", MESSAGE_TYPE_INFO
			);
		}

		kill(true, pPlot->getOwner(), true);
	}

	return true;
}


int CvUnit::destroyCost(const CvPlot* pPlot) const
{
	const CvCity* pCity = pPlot->getPlotCity();

	if (pCity == NULL)
	{
		return 0;
	}
	bool bLimited = false;

	if (pCity->isProductionUnit())
	{
		bLimited = isLimitedUnit(pCity->getProductionUnit());
	}
	else if (pCity->isProductionBuilding())
	{
		bLimited = isLimitedWonder(pCity->getProductionBuilding());
	}
	else if (pCity->isProductionProject())
	{
		bLimited = isLimitedProject(pCity->getProductionProject());
	}
	return
	(
		GC.getDefineINT("BASE_SPY_DESTROY_COST")
		+
		pCity->getProductionProgress()
		*
		(
			bLimited
			?
			GC.getDefineINT("SPY_DESTROY_COST_MULTIPLIER_LIMITED")
			:
			GC.getDefineINT("SPY_DESTROY_COST_MULTIPLIER")
		)
	);
}


int CvUnit::destroyProb(const CvPlot* pPlot, ProbabilityTypes eProbStyle) const
{
	PROFILE_EXTRA_FUNC();
	const CvCity* pCity = pPlot->getPlotCity();

	if (pCity == NULL)
	{
		return 0;
	}
	int iProb = 25 / (pPlot->plotCount(PUF_canDefend, -1, -1, NULL, NO_PLAYER, pPlot->getTeam()) + 1);

	if (eProbStyle != PROBABILITY_LOW)
	{
		if (eProbStyle != PROBABILITY_HIGH)
		{
			int iCounterSpyCount = pPlot->plotCount(PUF_isCounterSpy, -1, -1, NULL, NO_PLAYER, pPlot->getTeam());

			foreach_(const CvPlot* pLoopPlot, pPlot->adjacent())
			{
				iCounterSpyCount += pLoopPlot->plotCount(PUF_isCounterSpy, -1, -1, NULL, NO_PLAYER, pPlot->getTeam());
			}
			iProb += 50 / (iCounterSpyCount + 1);
		}
		else iProb += 50;
	}
	return iProb + std::min(25, pCity->getProductionTurnsLeft());
}


bool CvUnit::canDestroy(const CvPlot* pPlot, bool bTestVisible) const
{
	if (!m_pUnitInfo->isDestroy())
	{
		return false;
	}

	if (pPlot->getTeam() == getTeam())
	{
		return false;
	}

	const CvCity* pCity = pPlot->getPlotCity();

	if (pCity == NULL || pCity->getProductionProgress() == 0)
	{
		return false;
	}

	if (!bTestVisible && GET_PLAYER(getOwner()).getGold() < destroyCost(pPlot))
	{
		return false;
	}

	return true;
}


bool CvUnit::destroy()
{
	CvCity* pCity;
	CvWString szBuffer;
	bool bCaught;

	if (!canDestroy(plot()))
	{
		return false;
	}

	bCaught = (GC.getGame().getSorenRandNum(100, "Spy: Destroy") > destroyProb(plot()));

	pCity = plot()->getPlotCity();
	FAssertMsg(pCity != NULL, "City is not assigned a valid value");

	GET_PLAYER(getOwner()).changeGold(-(destroyCost(plot())));

	if (!bCaught)
	{
		pCity->setProductionProgress(pCity->getProductionProgress() / 2);

		finishMoves();

		{

			szBuffer = gDLL->getText("TXT_KEY_MISC_SPY_DESTROYED_PRODUCTION", getNameKey(), pCity->getProductionNameKey(), pCity->getNameKey());
			AddDLLMessage(getOwner(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_DESTROY", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_GREEN(), pCity->getX(), pCity->getY());

			szBuffer = gDLL->getText("TXT_KEY_MISC_CITY_PRODUCTION_DESTROYED", pCity->getProductionNameKey(), pCity->getNameKey());
			AddDLLMessage(pCity->getOwner(), false, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_DESTROY", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_RED(), pCity->getX(), pCity->getY(), true, true);
		}

		if (plot()->isActiveVisible(false))
		{
			NotifyEntity(MISSION_DESTROY);
		}
		if (!isSpy())
		{
			changeExperience100(100);
		}
	}
	else
	{
		if (isSpy())
		{

			szBuffer = gDLL->getText("TXT_KEY_MISC_SPY_CAUGHT_AND_KILLED", GET_PLAYER(getOwner()).getCivilizationAdjective(), getNameKey());
			AddDLLMessage(pCity->getOwner(), false, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_EXPOSE", MESSAGE_TYPE_INFO);

			szBuffer = gDLL->getText("TXT_KEY_MISC_YOUR_SPY_CAUGHT", getNameKey());
			AddDLLMessage(getOwner(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_EXPOSED", MESSAGE_TYPE_INFO);

			if (plot()->isActiveVisible(false))
			{
				NotifyEntity(MISSION_SURRENDER);
			}

			kill(true, pCity->getOwner(), true);
		}
		else
		{

			szBuffer = gDLL->getText("TXT_KEY_MISC_CRIMINAL_CAUGHT", GET_PLAYER(getOwner()).getCivilizationAdjective(), getNameKey());
			AddDLLMessage(pCity->getOwner(), false, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_EXPOSE", MESSAGE_TYPE_INFO);

			szBuffer = gDLL->getText("TXT_KEY_MISC_YOUR_CRIMINAL_CAUGHT", getNameKey());
			AddDLLMessage(getOwner(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_EXPOSED", MESSAGE_TYPE_INFO);

			makeWanted(pCity);
		}


		if (!isEnemy(pCity->getTeam()))
		{
			GET_PLAYER(pCity->getOwner()).AI_changeMemoryCount(getOwner(), MEMORY_SPY_CAUGHT, 1);
		}
	}

	return true;
}


int CvUnit::stealPlansCost(const CvPlot* pPlot) const
{
	const CvCity* pCity = pPlot->getPlotCity();

	if (pCity == NULL)
	{
		return 0;
	}

	return (GC.getDefineINT("BASE_SPY_STEAL_PLANS_COST") + ((GET_TEAM(pCity->getTeam()).getTotalLand() + GET_TEAM(pCity->getTeam()).getTotalPopulation()) * GC.getDefineINT("SPY_STEAL_PLANS_COST_MULTIPLIER")));
}


// XXX compare with destroy prob...
int CvUnit::stealPlansProb(const CvPlot* pPlot, ProbabilityTypes eProbStyle) const
{
	PROFILE_EXTRA_FUNC();
	const CvCity* pCity = pPlot->getPlotCity();
	if (pCity == NULL)
	{
		return 0;
	}

	int iProb = ((pCity->isGovernmentCenter()) ? 20 : 0); // XXX

	const int iDefenseCount = pPlot->plotCount(PUF_canDefend, -1, -1, NULL, NO_PLAYER, pPlot->getTeam());

	int iCounterSpyCount = pPlot->plotCount(PUF_isCounterSpy, -1, -1, NULL, NO_PLAYER, pPlot->getTeam());

	foreach_(const CvPlot* pLoopPlot, pPlot->adjacent())
	{
		iCounterSpyCount += pLoopPlot->plotCount(PUF_isCounterSpy, -1, -1, NULL, NO_PLAYER, pPlot->getTeam());
	}

	if (eProbStyle == PROBABILITY_HIGH)
	{
		iCounterSpyCount = 0;
	}

	iProb += (20 / (iDefenseCount + 1)); // XXX

	if (eProbStyle != PROBABILITY_LOW)
	{
		iProb += (50 / (iCounterSpyCount + 1)); // XXX
	}

	return iProb;
}


bool CvUnit::canStealPlans(const CvPlot* pPlot, bool bTestVisible) const
{
	if (!(m_pUnitInfo->isStealPlans()))
	{
		return false;
	}

	if (pPlot->getTeam() == getTeam() || pPlot->isNPC())
	{
		return false;
	}

	if (isNPC())
	{
		return false;
	}

	if (pPlot->getPlotCity() == NULL)
	{
		return false;
	}

	if (!bTestVisible && GET_PLAYER(getOwner()).getGold() < stealPlansCost(pPlot))
	{
		return false;
	}

	return true;
}


bool CvUnit::stealPlans()
{
	if (!canStealPlans(plot()))
	{
		return false;
	}
	const CvCity* pCity = plot()->getPlotCity();
	FAssertMsg(pCity != NULL, "City is not assigned a valid value");

	GET_PLAYER(getOwner()).changeGold(-stealPlansCost(plot()));

	if (GC.getGame().getSorenRandNum(100, "Spy: Steal Plans") <= stealPlansProb(plot()))
	{
		GET_TEAM(getTeam()).changeStolenVisibilityTimer(pCity->getTeam(), 2);

		finishMoves();

		AddDLLMessage(
			getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
			gDLL->getText("TXT_KEY_MISC_SPY_STOLE_PLANS", getNameKey(), pCity->getNameKey()),
			"AS2D_STEALPLANS", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_GREEN(), pCity->getX(), pCity->getY()
		);
		AddDLLMessage(
			pCity->getOwner(), false, GC.getEVENT_MESSAGE_TIME(),
			gDLL->getText("TXT_KEY_MISC_PLANS_STOLEN", pCity->getNameKey()),
			"AS2D_STEALPLANS", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_RED(), pCity->getX(), pCity->getY(), true, true
		);

		if (plot()->isActiveVisible(false))
		{
			NotifyEntity(MISSION_STEAL_PLANS);
		}
		if (!isSpy())
		{
			changeExperience100(100);
		}

	}
	else
	{
		if (isSpy())
		{
			AddDLLMessage(
				pCity->getOwner(), false, GC.getEVENT_MESSAGE_TIME(),
				gDLL->getText("TXT_KEY_MISC_SPY_CAUGHT_AND_KILLED", GET_PLAYER(getOwner()).getCivilizationAdjective(), getNameKey()),
				"AS2D_EXPOSE", MESSAGE_TYPE_INFO
			);
			AddDLLMessage(
				getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
				gDLL->getText("TXT_KEY_MISC_YOUR_SPY_CAUGHT", getNameKey()),
				"AS2D_EXPOSED", MESSAGE_TYPE_INFO
			);

			if (plot()->isActiveVisible(false))
			{
				NotifyEntity(MISSION_SURRENDER);
			}
			kill(true, pCity->getOwner(), true);
		}
		else
		{
			AddDLLMessage(
				pCity->getOwner(), false, GC.getEVENT_MESSAGE_TIME(),
				gDLL->getText("TXT_KEY_MISC_CRIMINAL_CAUGHT", GET_PLAYER(getOwner()).getCivilizationAdjective(), getNameKey()),
				"AS2D_EXPOSE", MESSAGE_TYPE_INFO
			);
			AddDLLMessage(
				getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
				gDLL->getText("TXT_KEY_MISC_YOUR_CRIMINAL_CAUGHT", getNameKey()),
				"AS2D_EXPOSED", MESSAGE_TYPE_INFO
			);
			makeWanted(pCity);
		}

		if (!isEnemy(pCity->getTeam()))
		{
			GET_PLAYER(pCity->getOwner()).AI_changeMemoryCount(getOwner(), MEMORY_SPY_CAUGHT, 1);
		}
	}

	return true;
}


bool CvUnit::canFound(const CvPlot* pPlot, bool bTestVisible) const
{
	return isFound() && GET_PLAYER(getOwner()).canFound(pPlot->getX(), pPlot->getY(), bTestVisible);
}


bool CvUnit::found()
{
	CvPlot* pPlot = plot();

	if (!pPlot || !canFound(pPlot))
	{
		return false;
	}

	if (GC.getGame().getActivePlayer() == getOwner())
	{
		GC.getCurrentViewport()->bringIntoView(getX(), getY());
	}

	GET_PLAYER(getOwner()).found(getX(), getY(), this);

	if (pPlot->isActiveVisible(false))
	{
		NotifyEntity(MISSION_FOUND);
	}

	// For the AI we need to run the turn for the new city to get production set
	if (!GET_PLAYER(getOwner()).isHumanPlayer())
	{
		pPlot->getPlotCity()->doTurn();
	}

	kill(true, NO_PLAYER, true);

	return true;
}


bool CvUnit::canSpread(const CvPlot* pPlot, ReligionTypes eReligion, bool bTestVisible) const
{
	PROFILE_FUNC();

	if (eReligion == NO_RELIGION || m_pUnitInfo->getReligionSpreads(eReligion) <= 0)
	{
		return false;
	}

	CvCity* pCity = pPlot->getPlotCity();

	if (pCity == NULL || pCity->isHasReligion(eReligion))
	{
		return false;
	}

	if (!canEnterArea(pPlot->getTeam(), pPlot->area()))
	{
		return false;
	}

	if (!bTestVisible && pCity->getTeam() != getTeam()
	&& GET_PLAYER(pCity->getOwner()).isNoNonStateReligionSpread()
	&& eReligion != GET_PLAYER(pCity->getOwner()).getStateReligion())
	{
		return false;
	}

	// TB Prophet Mod
	if (AI_getUnitAIType() != UNITAI_MISSIONARY)
	{
		if (!GC.getGame().isOption(GAMEOPTION_RELIGION_DIVINE_PROPHETS)
		|| GC.getGame().isOption(GAMEOPTION_RELIGION_LIMITED) && GET_PLAYER(getOwner()).hasHolyCity())
		{
			return false;
		}

		if (!GC.getGame().isOption(GAMEOPTION_RELIGION_PICK))
		{
			const TechTypes ePreqTech = GC.getReligionInfo(eReligion).getTechPrereq();

			if (!GC.getGame().isTechDiscovered(ePreqTech)
			|| !GET_TEAM(getTeam()).isHasTech(ePreqTech)
			&& GC.getGame().getGameTurn() <= GC.getGame().getTechGameTurnDiscovered(ePreqTech) + 1)
			{
				return false;
			}
		}
	}
	// ! TB Prophet Mod

	return true;
}


bool CvUnit::spread(ReligionTypes eReligion)
{
	if (!canSpread(plot(), eReligion))
	{
		return false;
	}
	CvCity* pCity = plot()->getPlotCity();

	if (pCity != NULL)
	{
		if (GC.getGame().isReligionFounded(eReligion))
		{
			int iSpreadProb = m_pUnitInfo->getReligionSpreads(eReligion);

			if ((ReligionTypes)GET_PLAYER(getOwner()).getStateReligion() == eReligion)
			{
				iSpreadProb += GET_PLAYER(getOwner()).getExtraStateReligionSpreadModifier();
			}
			else iSpreadProb += GET_PLAYER(getOwner()).getExtraNonStateReligionSpreadModifier();

			if (pCity->getTeam() != getTeam())
			{
				iSpreadProb /= 2;
			}

			iSpreadProb += (GC.getNumReligionInfos() - pCity->getReligionCount()) * (100 - iSpreadProb) / GC.getNumReligionInfos();
			const bool bSuccess = GC.getGame().getSorenRandNum(100, "Unit Spread Religion") < iSpreadProb;

			// Python Event
			CvEventReporter::getInstance().unitSpreadReligionAttempt(this, eReligion, bSuccess);

			if (!bSuccess)
			{
				// Python event above may have spread the religion, it's fine if it did.
				if (!pCity->isHasReligion(eReligion))
				{
					AddDLLMessage(
						getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
						gDLL->getText(
							"TXT_KEY_MISC_RELIGION_FAILED_TO_SPREAD",
							getNameKey(),
							GC.getReligionInfo(eReligion).getChar(),
							pCity->getNameKey()
						),
						"AS2D_NOSPREAD", MESSAGE_TYPE_INFO, getButton(),
						GC.getCOLOR_RED(), pCity->getX(), pCity->getY()
					);
				}
			}
			else pCity->setHasReligion(eReligion, true, true, false);
		}
		else // Divine Prophet is founding religion here; always 100% chance.
		{
			GC.getGame().setHolyCity(eReligion, pCity, true);
			GC.getGame().setReligionSlotTaken(eReligion, true);
			pCity->setHasReligion(eReligion, true, true, false);
		}
	}

	if (plot()->isActiveVisible(false))
	{
		NotifyEntity(MISSION_SPREAD);
	}

	kill(true, NO_PLAYER, true);

	return true;
}


bool CvUnit::canSpreadCorporation(const CvPlot* pPlot, CorporationTypes eCorporation, bool bTestVisible) const
{
	PROFILE_EXTRA_FUNC();
	if (NO_CORPORATION == eCorporation)
	{
		return false;
	}

	if (!GET_PLAYER(getOwner()).isActiveCorporation(eCorporation))
	{
		return false;
	}

	if (m_pUnitInfo->getCorporationSpreads(eCorporation) <= 0)
	{
		return false;
	}

	const CvCity* pCity = pPlot->getPlotCity();

	if (NULL == pCity)
	{
		return false;
	}

	if (pCity->isHasCorporation(eCorporation))
	{
		return false;
	}
/************************************************************************************************/
/* Afforess	                  Start		 01/17/10                                               */
/*                                                                                              */
/*   Blocks obsolete Corps from spreading                                                       */
/************************************************************************************************/
	if (GC.getCorporationInfo(eCorporation).getObsoleteTech() != NO_TECH)
	{
		if (GET_TEAM(GET_PLAYER(pCity->getOwner()).getTeam()).isHasTech(GC.getCorporationInfo(eCorporation).getObsoleteTech()))
		{
			return false;
		}
	}
	if (GC.getGame().isOption(GAMEOPTION_ADVANCED_REALISTIC_CORPORATIONS))
	{
		if (!GC.getGame().isModderGameOption(MODDERGAMEOPTION_NO_AUTO_CORPORATION_FOUNDING))
		{
			return false;
		}
	}
	if (!GC.getGame().canEverSpread(eCorporation))
	{
		return false;
	}
	if (!bTestVisible)
	{
		for (int iI = 0; iI < GC.getNumBuildingInfos(); iI++)
		{
			if (GC.getCorporationInfo(eCorporation).getPrereqBuilding(iI) > 0)
			{
				if (GET_PLAYER(pCity->getOwner()).getBuildingCount((BuildingTypes)iI) < GC.getCorporationInfo(eCorporation).getPrereqBuilding(iI))
				{
					return false;
				}
			}
		}
	}
/************************************************************************************************/
/* Afforess	                     END                                                            */
/************************************************************************************************/

	if (!canEnterArea(pPlot->getTeam(), pPlot->area()))
	{
		return false;
	}

	if (!bTestVisible)
	{
		if (!GET_PLAYER(pCity->getOwner()).isActiveCorporation(eCorporation))
		{
			return false;
		}

		for (int iCorporation = 0; iCorporation < GC.getNumCorporationInfos(); ++iCorporation)
		{
			if (pCity->isHeadquarters((CorporationTypes)iCorporation))
			{
				if (GC.getGame().isCompetingCorporation((CorporationTypes)iCorporation, eCorporation))
				{
					return false;
				}
			}
		}
		// Afforess: Some corporations don't require any resources...
		bool bValid = false;
		bool bRequiresBonus = false;
		foreach_(const BonusTypes eBonus, GC.getCorporationInfo(eCorporation).getPrereqBonuses())
		{
			bRequiresBonus = true;
			if (pCity->hasBonus(eBonus))
			{
				bValid = true;
				break;
			}
		}
		if (!bValid && bRequiresBonus)
		{
			return false;
		}

		if (GET_PLAYER(getOwner()).getGold() < spreadCorporationCost(eCorporation, pCity))
		{
			return false;
		}
	}

	return true;
}

int CvUnit::spreadCorporationCost(CorporationTypes eCorporation, const CvCity* pCity) const
{
	PROFILE_EXTRA_FUNC();
	int iCost = std::max(0, GC.getCorporationInfo(eCorporation).getSpreadCost());

	if (pCity)
	{
		if (getTeam() != pCity->getTeam() && !GET_TEAM(pCity->getTeam()).isVassal(getTeam()))
		{
			iCost *= GC.getDefineINT("CORPORATION_FOREIGN_SPREAD_COST_PERCENT");
			iCost /= 100;
		}

		for (int iCorp = 0; iCorp < GC.getNumCorporationInfos(); ++iCorp)
		{
			if (iCorp != eCorporation && pCity->isActiveCorporation((CorporationTypes)iCorp)
			&& GC.getGame().isCompetingCorporation(eCorporation, (CorporationTypes)iCorp))
			{
				iCost *= 100 + GC.getCorporationInfo((CorporationTypes)iCorp).getSpreadFactor();
				iCost /= 100;
			}
		}
	}
	return iCost;
}

bool CvUnit::spreadCorporation(CorporationTypes eCorporation)
{
	int iSpreadProb;

	if (!canSpreadCorporation(plot(), eCorporation))
	{
		return false;
	}

	CvCity* pCity = plot()->getPlotCity();

	if (NULL != pCity)
	{
		GET_PLAYER(getOwner()).changeGold(-spreadCorporationCost(eCorporation, pCity));

		iSpreadProb = m_pUnitInfo->getCorporationSpreads(eCorporation);

		if (pCity->getTeam() != getTeam())
		{
			iSpreadProb /= 2;
		}

		iSpreadProb += (((GC.getNumCorporationInfos() - pCity->getCorporationCount()) * (100 - iSpreadProb)) / GC.getNumCorporationInfos());

		if (GC.getGame().getSorenRandNum(100, "Unit Spread Corporation") < iSpreadProb)
		{
			pCity->setHasCorporation(eCorporation, true, true, false);
		}
		else
		{

			const CvWString szBuffer = gDLL->getText("TXT_KEY_MISC_CORPORATION_FAILED_TO_SPREAD", getNameKey(), GC.getCorporationInfo(eCorporation).getChar(), pCity->getNameKey());
			AddDLLMessage(getOwner(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_NOSPREAD", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_RED(), pCity->getX(), pCity->getY());
		}
	}

	if (plot()->isActiveVisible(false))
	{
		NotifyEntity(MISSION_SPREAD_CORPORATION);
	}

	kill(true, NO_PLAYER, true);

	return true;
}


bool CvUnit::canJoin(const CvPlot* pPlot, SpecialistTypes eSpecialist) const
{
	if (eSpecialist == NO_SPECIALIST)
	{
		return false;
	}

	if (isCommander() || isDelayedDeath())
	{
		return false;
	}

    if (isCommodore() || isDelayedDeath())
	{
		return false;
	}

	if (!m_pUnitInfo->getGreatPeoples(eSpecialist))
	{
		return false;
	}

	const CvCity* pCity = pPlot->getPlotCity();

	if (pCity == NULL || pCity->getTeam() != getTeam())
	{
		return false;
	}

	return true;
}


bool CvUnit::join(SpecialistTypes eSpecialist)
{
	CvCity* pCity;

	if (!canJoin(plot(), eSpecialist))
	{
		return false;
	}

	pCity = plot()->getPlotCity();

	if (pCity != NULL)
	{
		pCity->changeFreeSpecialistCount(eSpecialist, 1, true);
	}

	if (plot()->isActiveVisible(false))
	{
		NotifyEntity(MISSION_JOIN);
	}

	getGroup()->AI_setMissionAI(MISSIONAI_DELIBERATE_KILL, NULL, NULL);
	kill(true, NO_PLAYER, true);

	return true;
}


bool CvUnit::canConstruct(const CvPlot* pPlot, BuildingTypes eBuilding, bool bTestVisible) const
{
	if (eBuilding == NO_BUILDING || !m_pUnitInfo->getHasBuilding(eBuilding))
	{
		return false;
	}

	if (isDelayedDeath() || isCommander())
	{
		return false;
	}

	if (isDelayedDeath() || isCommodore())
	{
		return false;
	}

	if (!canPerformActionSM())
	{
		return false;
	}

	if (GC.getBuildingInfo(eBuilding).getGlobalReligionCommerce() > NO_RELIGION
	&& GC.getBuildingInfo(eBuilding).getProductionCost() == -1
	&& GC.getGame().getBuildingCreatedCount(eBuilding) > 0)
	{
		return false;
	}

	CvCity* pCity = pPlot->getPlotCity();

	if (!pCity || getTeam() != pCity->getTeam())
	{
		return false;
	}

	if (pCity->hasBuilding(eBuilding))
	{
		return false;
	}

	if (!pCity->canConstruct(eBuilding, false, bTestVisible, true))
	{
		return false;
	}

	return true;
}


bool CvUnit::construct(BuildingTypes eBuilding)
{
	if (!canConstruct(plot(), eBuilding))
	{
		return false;
	}
	CvCity* pCity = plot()->getPlotCity();

	if (pCity)
	{
		pCity->changeHasBuilding(eBuilding, true);

		CvEventReporter::getInstance().buildingBuilt(pCity, eBuilding);
	}

	if (plot()->isActiveVisible(false))
	{
		NotifyEntity(MISSION_CONSTRUCT);
	}

	getGroup()->AI_setMissionAI(MISSIONAI_DELIBERATE_KILL, NULL, NULL);
	kill(true, NO_PLAYER, true);
	return true;
}

bool CvUnit::canAddHeritage(const CvPlot* pPlot, const HeritageTypes eType, const bool bTestVisible) const
{
	if (eType == NO_HERITAGE || !m_pUnitInfo->getHasHeritage(eType))
	{
		return false;
	}

	if (isDelayedDeath() || isCommander() || !canPerformActionSM())
	{
		return false;
	}

    if (isDelayedDeath() || isCommodore() || !canPerformActionSM())
	{
		return false;
	}

	if (!GET_PLAYER(getOwner()).canAddHeritage(eType, bTestVisible))
	{
		return false;
	}

	CvCity* pCity = pPlot->getPlotCity();

	if (!pCity || getTeam() != pCity->getTeam())
	{
		return false;
	}

	return true;
}

bool CvUnit::addHeritage(const HeritageTypes eType)
{
	if (!canAddHeritage(plot(), eType))
	{
		return false;
	}
	GET_PLAYER(getOwner()).setHeritage(eType, true);

	if (plot()->isActiveVisible(false))
	{
		NotifyEntity(MISSION_HERITAGE);
	}
	getGroup()->AI_setMissionAI(MISSIONAI_DELIBERATE_KILL, NULL, NULL);
	kill(true, NO_PLAYER, true);
	return true;
}


TechTypes CvUnit::getDiscoveryTech() const
{
	return ::getDiscoveryTech(getUnitType(), getOwner());
}


int CvUnit::getDiscoverResearch(const TechTypes eTech) const
{
	int iResearch = (
		m_pUnitInfo->getBaseDiscover() +
		m_pUnitInfo->getDiscoverMultiplier() * GET_TEAM(getTeam()).getTotalPopulation()
	);
	if (iResearch > 0)
	{
		iResearch *= GC.getGameSpeedInfo(GC.getGame().getGameSpeedType()).getSpeedPercent();
		iResearch /= 100;

		if (eTech != NO_TECH)
		{
			return std::min(GET_TEAM(getTeam()).getResearchLeft(eTech), iResearch);
		}
		return iResearch;
	}
	return 0;
}


bool CvUnit::canDiscover() const
{
	if (isDelayedDeath())
	{
		return false;
	}
	if (getDiscoverResearch() == 0)
	{
		return false;
	}
	if (getDiscoveryTech() == NO_TECH)
	{
		return false;
	}
	return true;
}


bool CvUnit::discover(TechTypes eTech)
{
	if (!canDiscover())
	{
		return false;
	}
	if (eTech == NO_TECH)
	{
		eTech = getDiscoveryTech();
	}
	GET_TEAM(getTeam()).changeResearchProgress(eTech, getDiscoverResearch(eTech), getOwner());

	if (plot()->isActiveVisible(false))
	{
		NotifyEntity(MISSION_DISCOVER);
	}
	getGroup()->AI_setMissionAI(MISSIONAI_DELIBERATE_KILL, NULL, NULL);
	kill(true, NO_PLAYER, true);

	return true;
}


int CvUnit::getMaxHurryProduction(const CvCity* pCity) const
{
	int iProduction = (m_pUnitInfo->getBaseHurry() + (m_pUnitInfo->getHurryMultiplier() * pCity->getPopulation()));

	iProduction *= GC.getGameSpeedInfo(GC.getGame().getGameSpeedType()).getHammerCostPercent();
	iProduction /= 100;

	return std::max(0, iProduction);
}


int CvUnit::getHurryProduction(const CvPlot* pPlot) const
{
	const CvCity* pCity = pPlot->getPlotCity();

	if (pCity == NULL)
	{
		return 0;
	}

	int iProduction = std::min(pCity->productionLeft(), getMaxHurryProduction(pCity));

	return std::max(0, iProduction);
}


bool CvUnit::canHurry(const CvPlot* pPlot, bool bTestVisible) const
{
	if (isDelayedDeath() || getHurryProduction(pPlot) == 0)
	{
		return false;
	}

	const CvCity* pCity = pPlot->getPlotCity();

	if (pCity == NULL || getTeam() != pCity->getTeam())
	{
		return false;
	}

	if (!bTestVisible)
	{
		if (!(pCity->isProductionBuilding()))
		{
			return false;
		}
	}

	return true;
}


bool CvUnit::hurry()
{
	if (!canHurry(plot()))
	{
		return false;
	}

	CvCity* pCity = plot()->getPlotCity();

	if (pCity != NULL)
	{
		pCity->changeProduction(getHurryProduction(plot()));
	}

	if (plot()->isActiveVisible(false))
	{
		NotifyEntity(MISSION_HURRY);
	}

	kill(true, NO_PLAYER, true);

	return true;
}


int CvUnit::getTradeGold(const CvPlot* pPlot) const
{
	CvCity* pCity = pPlot->getPlotCity();

	if (pCity == NULL || pCity == getCityOfOrigin())
	{
		return 0;
	}
	CvCity* pCapitalCity = GET_PLAYER(pPlot->getOwner()).getCapitalCity();

	int iMult = m_pUnitInfo->getTradeMultiplier();

	int iGold = m_pUnitInfo->getBaseTrade() + iMult * ((pCapitalCity != NULL) ? pCity->calculateTradeProfit(pCapitalCity) : 0);

	iGold *= (pPlot->getOwner() != getOwner() ? iMult : 1);

	iGold *= pCity->getPopulation();
	iGold /= 10;

	CvPlot* cPlot = GC.getMap().plot(m_iXOrigin, m_iYOrigin);
	int iMaxDistance = GC.getMap().maxPlotDistance();
	if (cPlot != NULL)
	{
		iGold *= iMaxDistance + plotDistance(m_iXOrigin, m_iYOrigin, pPlot->getX(), pPlot->getY());
		iGold /= iMaxDistance;
	}

	iGold = getModifiedIntValue(iGold, GC.getTRADE_MISSION_END_TOTAL_PERCENT_ADJUSTMENT() + GET_TEAM(getTeam()).getTradeMissionModifier());

	iGold *= GC.getGameSpeedInfo(GC.getGame().getGameSpeedType()).getSpeedPercent();
	iGold /= 100;

	return std::max(0, iGold);
}


bool CvUnit::canTrade(const CvPlot* pPlot, bool bTestVisible) const
{
	if (isDelayedDeath())
	{
		return false;
	}

	if (!canPerformActionSM())
	{
		return false;
	}

	const CvCity* pCity = pPlot->getPlotCity();

	if (pCity == NULL)
	{
		return false;
	}

	if (getTradeGold(pPlot) == 0)
	{
		return false;
	}

	if (!canEnterArea(pPlot->getTeam(), pPlot->area()))
	{
		return false;
	}

	if (!bTestVisible)
	{
		if (pCity->getTeam() == getTeam())
		{
			return false;
		}
	}

	return true;
}


bool CvUnit::trade()
{
	if (!canTrade(plot()))
	{
		return false;
	}


	if (plot()->isActiveVisible(false))
	{
		NotifyEntity(MISSION_TRADE);
	}

	//if is criminal then must pass an investigation check or fail and become wanted.  If passes the check, then send back to capital.
	CvCity* pCapital = getCityOfOrigin();

	if (isCriminal())
	{
		if (!criminalSuccessCheck())
		{
			finishMoves();
			return true;
		}
		changeExperience100(10);
		GET_PLAYER(getOwner()).changeGold(getTradeGold(plot()));
		finishMoves();
		if (pCapital != NULL)
		{
			setXY(pCapital->getX(), pCapital->getY(), false, true, true, false, false);
		}
		return true;
	}

	GET_PLAYER(getOwner()).changeGold(getTradeGold(plot()));
	//if is Great Person then kill

	//otherwise send back to capital
	if (!isGoldenAge() && pCapital != NULL)
	{
		changeExperience100(10);
		setXY(pCapital->getX(), pCapital->getY(), false, true, true, false, false);
	}
	else
	{
		kill(true, NO_PLAYER, true);
	}

	return true;
}


int CvUnit::getGreatWorkCulture() const
{
	int iCulture = m_pUnitInfo->getGreatWorkCulture();

	iCulture *= GC.getGameSpeedInfo(GC.getGame().getGameSpeedType()).getSpeedPercent();
	iCulture /= 100;

	return std::max(0, iCulture);
}


bool CvUnit::canGreatWork(const CvPlot* pPlot) const
{
	if (isDelayedDeath())
	{
		return false;
	}

	const CvCity* pCity = pPlot->getPlotCity();

	if (pCity == NULL)
	{
		return false;
	}

	if (pCity->getOwner() != getOwner())
	{
		return false;
	}

	if (getGreatWorkCulture() == 0)
	{
		return false;
	}

	return true;
}


bool CvUnit::greatWork()
{
	PROFILE_EXTRA_FUNC();
	if (!canGreatWork(plot()))
	{
		return false;
	}

	CvCity* pCity = plot()->getPlotCity();

	if (pCity != NULL)
	{
		pCity->setCultureUpdateTimer(0);
		pCity->setOccupationTimer(0);

		const int iCultureToAdd = 100 * getGreatWorkCulture();
		const int iNumTurnsApplied = GC.getDefineINT("GREAT_WORKS_CULTURE_TURNS") * GC.getGameSpeedInfo(GC.getGame().getGameSpeedType()).getSpeedPercent() / 100;

		for (int i = 0; i < iNumTurnsApplied; ++i)
		{
			pCity->changeCultureTimes100(getOwner(), iCultureToAdd / iNumTurnsApplied, true, true);
		}

		if (iNumTurnsApplied > 0)
		{
			pCity->changeCultureTimes100(getOwner(), iCultureToAdd % iNumTurnsApplied, false, true);
		}
	}

	if (plot()->isActiveVisible(false))
	{
		NotifyEntity(MISSION_GREAT_WORK);
	}

	kill(true, NO_PLAYER, true);

	return true;
}

bool CvUnit::doOutcomeMission(MissionTypes eMission)
{
	PROFILE_EXTRA_FUNC();
	const CvOutcomeMission* pOutcomeMission = getUnitInfo().getOutcomeMissionByMission(eMission);

	if (!pOutcomeMission)
	{
		// Outcome missions on unit combats
		for (int iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
		{
			if (isHasUnitCombat((UnitCombatTypes)iI))
			{
				pOutcomeMission = GC.getUnitCombatInfo((UnitCombatTypes)iI).getOutcomeMissionByMission(eMission);
				if (pOutcomeMission)
				{
					break;
				}
			}
		}
	}

	if (!pOutcomeMission)
	{
		return false;
	}

	if (!pOutcomeMission->isPossible(this))
	{
		return false;
	}

	pOutcomeMission->execute(this);

	if (plot()->isActiveVisible(false))
	{
		NotifyEntity(eMission);
	}

	if (pOutcomeMission->isKill())
	{
		getGroup()->AI_setMissionAI(MISSIONAI_DELIBERATE_KILL, NULL, NULL);
		kill(true);
	}

	return true;
}


int CvUnit::getEspionagePoints() const
{
	int iEspionagePoints = m_pUnitInfo->getEspionagePoints();

	iEspionagePoints *= GC.getGameSpeedInfo(GC.getGame().getGameSpeedType()).getSpeedPercent();
	iEspionagePoints /= 100;

	return std::max(0, iEspionagePoints);
}

bool CvUnit::canInfiltrate() const
{
	if (isDelayedDeath() || isNPC() || getEspionagePoints() == 0)
	{
		return false;
	}
	return true;
}

bool CvUnit::canInfiltrate(const CvPlot* pPlot, bool bTestVisible) const
{
	if (!canInfiltrate())
	{
		return false;
	}
	const CvCity* pCity = pPlot->getPlotCity();

	if (pCity == NULL || pCity->isNPC())
	{
		return false;
	}
	if (!bTestVisible && pCity->getTeam() == getTeam())
	{
		return false;
	}
	if (!isInvisible(pCity->getTeam(), false, true))
	{
		return false;
	}
	return true;
}


bool CvUnit::infiltrate()
{
	if (!canInfiltrate(plot()))
	{
		return false;
	}

	int iPoints = getEspionagePoints();

	int iPointsAdj = (GC.getINFILTRATE_MISSION_END_TOTAL_PERCENT_ADJUSTMENT() * iPoints) / 100;

	iPoints += iPointsAdj;

	if (plot()->isActiveVisible(false))
	{
		NotifyEntity(MISSION_INFILTRATE);
	}

	if (!isSpy())
	{
		if (criminalSuccessCheck())
		{
			changeExperience100(100);
			GET_TEAM(getTeam()).changeEspionagePointsAgainstTeam(GET_PLAYER(plot()->getOwner()).getTeam(), iPoints);
			GET_TEAM(getTeam()).changeEspionagePointsEver(iPoints);

			const CvCity* pCapital = GET_PLAYER(getOwner()).getCapitalCity();
			if (pCapital != NULL)
			{
				finishMoves();
				setXY(pCapital->getX(), pCapital->getY(), false, true, true, false, false);
			}
			else
			{
				kill(true, NO_PLAYER, true);
			}
		}
		else
		{
			finishMoves();
		}
	}
	else
	{
		GET_TEAM(getTeam()).changeEspionagePointsAgainstTeam(GET_PLAYER(plot()->getOwner()).getTeam(), iPoints);
		GET_TEAM(getTeam()).changeEspionagePointsEver(iPoints);
		kill(true, NO_PLAYER, true);
	}

	return true;
}


bool CvUnit::canEspionage(const CvPlot* pPlot, bool bTestVisible) const
{
	if (isDelayedDeath() || !isSpy())
	{
		return false;
	}

	const PlayerTypes ePlotOwner = pPlot->getOwner();
	if (NO_PLAYER == ePlotOwner)
	{
		return false;
	}

	const CvPlayer& kTarget = GET_PLAYER(ePlotOwner);

	if (kTarget.isNPC())
	{
		return false;
	}

	if (kTarget.getTeam() == getTeam())
	{
		return false;
	}

	if (GET_TEAM(getTeam()).isVassal(kTarget.getTeam()))
	{
		return false;
	}

	if (!bTestVisible)
	{
		if (isMadeAttack())
		{
			return false;
		}

		if (hasMoved())
		{
			return false;
		}

		if (kTarget.getTeam() != getTeam() && !isInvisible(kTarget.getTeam(), false))
		{
			return false;
		}
	}

	return true;
}

//TSHEEP start
bool CvUnit::awardSpyExperience(TeamTypes eTargetTeam, int iModifier)
{
	if (GC.isSS_ENABLED())
	{
		const int iDifficulty = getSpyInterceptPercent(eTargetTeam) * (100 + iModifier) / 100;
		if (iDifficulty < 1)
			changeExperience(1);
		else if (iDifficulty < 10)
			changeExperience(2);
		else if (iDifficulty < 25)
			changeExperience(3);
		else if (iDifficulty < 50)
			changeExperience(4);
		else if (iDifficulty < 75)
			changeExperience(5);
		else
			changeExperience(6);
		return true;
	}
	return false;
}
//TSHEEP End


bool CvUnit::canAssassin(const CvPlot* pPlot, bool bTestVisible) const
{
	if (isDelayedDeath())
	{
		return false;
	}

	if (!isSpy())
	{
		return false;
	}

	const CvCity* pCity = pPlot->getPlotCity();
	if (NULL == pCity)
	{
		return false;
	}

	const int numGreatPeople = pCity->getNumGreatPeople();
	if (numGreatPeople <= 0)
	{
		return false;
	}

	const CvPlayer& kTarget = GET_PLAYER(pCity->getOwner());

	if (kTarget.getTeam() == getTeam())
	{
		return false;
	}

	if (kTarget.isNPC())
	{
		return false;
	}

	if (GET_TEAM(getTeam()).isVassal(kTarget.getTeam()))
	{
		return false;
	}

	if (!bTestVisible)
	{
		if (isMadeAttack())
		{
			return false;
		}

		if (hasMoved())
		{
			return false;
		}

		if (kTarget.getTeam() != getTeam() && !isInvisible(kTarget.getTeam(), false))
		{
			return false;
		}
	}

	return true;
}

bool CvUnit::canBribe(const CvPlot* pPlot, bool bTestVisible) const
{
	if (isDelayedDeath())
	{
		return false;
	}

	if (!isSpy())
	{
		return false;
	}

	if(pPlot->plotCount(PUF_isOtherTeam, getOwner(), -1, NULL, NO_PLAYER, NO_TEAM, PUF_isVisible, getOwner()) < 1)
	{
		return false;
	}

	if (pPlot->plotCount(PUF_isUnitAIType, UNITAI_WORKER, -1) < 1)
	{
		return false;
	}

	const CvUnit* pTargetUnit = pPlot->plotCheck(PUF_isOtherTeam, getOwner(), -1, NULL, NO_PLAYER, NO_TEAM, PUF_isVisible, getOwner());
	const CvPlayer& kTarget = GET_PLAYER(pTargetUnit->getOwner());

	if (kTarget.getTeam() == getTeam())
	{
		return false;
	}

	if (kTarget.isNPC())
	{
		return false;
	}

	if (GET_TEAM(getTeam()).isVassal(kTarget.getTeam()))
	{
		return false;
	}

	if (!bTestVisible)
	{
		if (isMadeAttack())
		{
			return false;
		}

		if (hasMoved())
		{
			return false;
		}

		if (kTarget.getTeam() != getTeam() && !isInvisible(kTarget.getTeam(), false))
		{
			return false;
		}
	}

	return true;
}


bool CvUnit::espionage(EspionageMissionTypes eMission, int iData)
{
	if (!canEspionage(plot()))
	{
		return false;
	}

	PlayerTypes eTargetPlayer = plot()->getOwner();

	if (NO_ESPIONAGEMISSION == eMission)
	{
		FAssert(GET_PLAYER(getOwner()).isHumanPlayer());
		CvPopupInfo* pInfo = new CvPopupInfo(BUTTONPOPUP_DOESPIONAGE);
		if (NULL != pInfo)
		{
			gDLL->getInterfaceIFace()->addPopup(pInfo, getOwner(), true);
		}
	}
	else if (GC.getEspionageMissionInfo(eMission).isTwoPhases() && -1 == iData)
	{
		FAssert(GET_PLAYER(getOwner()).isHumanPlayer());
		CvPopupInfo* pInfo = new CvPopupInfo(BUTTONPOPUP_DOESPIONAGE_TARGET);
		if (NULL != pInfo)
		{
			pInfo->setData1(eMission);
			gDLL->getInterfaceIFace()->addPopup(pInfo, getOwner(), true);
		}
	}
	else
	{
		if (testSpyIntercepted(eTargetPlayer, GC.getEspionageMissionInfo(eMission).getDifficultyMod()))
		{
			return false;
		}

		const bool bCaught = testSpyIntercepted(eTargetPlayer, GC.getDefineINT("ESPIONAGE_SPY_MISSION_ESCAPE_MOD"));

		if (GET_PLAYER(getOwner()).doEspionageMission(eMission, eTargetPlayer, plot(), iData, this, (bCaught && !isAlwaysHeal())))
		{
			// If it died in the mission (e.g. - nuke and blew itself up) then nothing else needs doing
			if (!isDelayedDeath())
			{
				if (plot()->isActiveVisible(false))
				{
					NotifyEntity(MISSION_ESPIONAGE);
				}

				if (!bCaught)
				{
					setFortifyTurns(0);
					setMadeAttack(true);
					finishMoves();

					// Afforess 07/12/10
					// Spy actions that aren't in a city don't cause the spy to be sent back
					if (plot()->isCity())
					{
						const CvCity* pCapital = GET_PLAYER(getOwner()).getCapitalCity();

						if (NULL != pCapital)
						{
							if (!pCapital->isInViewport())
							{
								GC.getCurrentViewport()->bringIntoView(pCapital->getX(), pCapital->getY(), NULL, true);
							}
							//GC.getGame().logOOSSpecial(20, getID(), pCapital->getX(), pCapital->getY());
							setXY(pCapital->getX(), pCapital->getY(), false, false, false);


							const CvWString szBuffer = gDLL->getText("TXT_KEY_ESPIONAGE_SPY_SUCCESS", getNameKey(), pCapital->getNameKey());
							AddDLLMessage(getOwner(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_POSITIVE_DINK", MESSAGE_TYPE_INFO,
								getButton(), GC.getCOLOR_WHITE(), pCapital->getX(), pCapital->getY(), true, true);
						}
					}
					//TSHEEP Give spies xp for successful missions
					awardSpyExperience(GET_PLAYER(eTargetPlayer).getTeam(),GC.getEspionageMissionInfo(eMission).getDifficultyMod());
				}
			}
			return true;
		}
	}
	return false;
}

bool CvUnit::testSpyIntercepted(PlayerTypes eTargetPlayer, int iModifier)
{
	CvPlayer& kTargetPlayer = GET_PLAYER(eTargetPlayer);

	if (kTargetPlayer.isNPC())
	{
		return false;
	}

	if (GC.getGame().getSorenRandNum(10000, "Spy Interception") >= getSpyInterceptPercent(kTargetPlayer.getTeam()) * (100 + iModifier))
	{
		return false;
	}

	CvString szFormatNoReveal;
	CvString szFormatReveal;

	if (GET_TEAM(kTargetPlayer.getTeam()).getCounterespionageModAgainstTeam(getTeam()) > 0)
	{
		szFormatNoReveal = "TXT_KEY_SPY_INTERCEPTED_MISSION";
		szFormatReveal = "TXT_KEY_SPY_INTERCEPTED_MISSION_REVEAL";
	}
	else if (plot()->isEspionageCounterSpy(kTargetPlayer.getTeam()))
	{
		szFormatNoReveal = "TXT_KEY_SPY_INTERCEPTED_SPY";
		szFormatReveal = "TXT_KEY_SPY_INTERCEPTED_SPY_REVEAL";
	}
	else
	{
		szFormatNoReveal = "TXT_KEY_SPY_INTERCEPTED";
		szFormatReveal = "TXT_KEY_SPY_INTERCEPTED_REVEAL";
	}

	CvWString szCityName = kTargetPlayer.getCivilizationShortDescription();
	CvCity* pClosestCity = GC.getMap().findCity(getX(), getY(), eTargetPlayer, kTargetPlayer.getTeam(), true, false);
	if (pClosestCity != NULL)
	{
		szCityName = pClosestCity->getName();
	}

	CvWString szBuffer = gDLL->getText(szFormatReveal.GetCString(), GET_PLAYER(getOwner()).getCivilizationAdjectiveKey(), getNameKey(), kTargetPlayer.getCivilizationAdjectiveKey(), szCityName.GetCString());
	AddDLLMessage(getOwner(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_EXPOSED", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_RED(), getX(), getY(), true, true);

	//TSHEEP Enable Loyalty Promotion
	//if (GC.getGame().getSorenRandNum(100, "Spy Reveal identity") < GC.getDefineINT("ESPIONAGE_SPY_REVEAL_IDENTITY_PERCENT"))
	if (GC.getGame().getSorenRandNum(100, "Spy Reveal identity") < GC.getDefineINT("ESPIONAGE_SPY_REVEAL_IDENTITY_PERCENT") && !isAlwaysHeal())//TSHEEP End
	{
		if (!isEnemy(kTargetPlayer.getTeam()))
		{
			kTargetPlayer.AI_changeMemoryCount(getOwner(), MEMORY_SPY_CAUGHT, 1);
		}
		AddDLLMessage(eTargetPlayer, true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_EXPOSE", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_GREEN(), getX(), getY(), true, true);
	}
	else
	{
		AddDLLMessage(
			eTargetPlayer, true, GC.getEVENT_MESSAGE_TIME(),
			gDLL->getText(
				szFormatNoReveal.GetCString(), getNameKey(), kTargetPlayer.getCivilizationAdjectiveKey(), szCityName.GetCString()
			),
			"AS2D_EXPOSE", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_GREEN(), getX(), getY(), true, true
		);
	}

	if (plot()->isActiveVisible(false))
	{
		NotifyEntity(MISSION_SURRENDER);
	}

	//TSHEEP - Give xp to spy who catches spy
	{
		CvUnit* pCounterUnit = plot()->plotCheck(PUF_isCounterSpy, -1, -1, NULL, NO_PLAYER, kTargetPlayer.getTeam());

		if (NULL != pCounterUnit)
		{
			pCounterUnit->changeExperience(1);
		}
	}

	//TSHEEP Implement Escape Promotion
	if (GC.getGame().getSorenRandNum(100, "Spy Reveal identity") < withdrawalProbability())
	{
		setFortifyTurns(0);
		setMadeAttack(true);
		finishMoves();

		CvCity* pCapital = GET_PLAYER(getOwner()).getCapitalCity();

		if (NULL != pCapital)
		{
			//GC.getGame().logOOSSpecial(21, getID(), pCapital->getX(), pCapital->getY());
			setXY(pCapital->getX(), pCapital->getY(), false, false, false);
		}
		{

			szFormatReveal = "TXT_KEY_SPY_ESCAPED_REVEAL";
			szFormatNoReveal = "TXT_KEY_SPY_ESCAPED";
			AddDLLMessage(
				getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
				gDLL->getText(
					szFormatReveal.GetCString(), GET_PLAYER(getOwner()).getCivilizationAdjectiveKey(),
					getNameKey(), kTargetPlayer.getCivilizationAdjectiveKey(), szCityName.GetCString()
				),
				"AS2D_EXPOSED", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_GREEN(), getX(), getY(), true, true
			);
			AddDLLMessage(
				eTargetPlayer, true, GC.getEVENT_MESSAGE_TIME(),
				gDLL->getText(
					szFormatNoReveal.GetCString(),
					getNameKey(), kTargetPlayer.getCivilizationAdjectiveKey(), szCityName.GetCString()
				),
				"AS2D_EXPOSE", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_RED(), getX(), getY(), true, true
			);
		}
		changeExperience(1);

		return true;
	}
	//TSHEEP End

	kill(true, NO_PLAYER, true);

	return true;
}

int CvUnit::getSpyInterceptPercent(TeamTypes eTargetTeam) const
{
	FAssert(isSpy());
	FAssert(getTeam() != eTargetTeam);

	int iSuccess = 0;

	int iTargetPoints = GET_TEAM(eTargetTeam).getEspionagePointsEver();
	int iOurPoints = GET_TEAM(getTeam()).getEspionagePointsEver();
	iSuccess += (GC.getDefineINT("ESPIONAGE_INTERCEPT_SPENDING_MAX") * iTargetPoints) / std::max(1, iTargetPoints + iOurPoints);

	//TSHEEP - add evasion attribute to spy chances
	if (getExtraEvasion())
	{
		iSuccess -= getExtraEvasion();
	}

	if (plot()->isEspionageCounterSpy(eTargetTeam))
	{
		iSuccess += GC.getDefineINT("ESPIONAGE_INTERCEPT_COUNTERSPY");
		//TSHEEP - Add intercept attribute of any enemy spies present to chances
		if(plot()->plotCheck(PUF_isCounterSpy, -1, -1, NULL, NO_PLAYER, eTargetTeam))
		{
			CvUnit* pCounterUnit = plot()->plotCheck(PUF_isCounterSpy, -1, -1, NULL, NO_PLAYER, eTargetTeam);
			if(pCounterUnit != NULL && pCounterUnit->getExtraIntercept())
				iSuccess += pCounterUnit->getExtraIntercept();
		}
	}

	if (GET_TEAM(eTargetTeam).getCounterespionageModAgainstTeam(getTeam()) > 0)
	{
		iSuccess += GC.getDefineINT("ESPIONAGE_INTERCEPT_COUNTERESPIONAGE_MISSION");
	}

	//TSHEEP - This check was always returning true since there is always at least one friendly spy in the tile
	//if (0 == getFortifyTurns() || plot()->plotCount(PUF_isSpy, -1, -1, NO_PLAYER, getTeam()) > 0)
	if (0 == getFortifyTurns() || plot()->plotCount(PUF_isSpy, -1, -1, NULL, NO_PLAYER, getTeam()) > 1)//TSHEEP - End
	{
		iSuccess += GC.getDefineINT("ESPIONAGE_INTERCEPT_RECENT_MISSION");
	}

	return std::min(100, std::max(0, iSuccess));
}

bool CvUnit::isIntruding() const
{
	TeamTypes eLocalTeam = plot()->getTeam();

	if (NO_TEAM == eLocalTeam || eLocalTeam == getTeam())
	{
		return false;
	}

	// UNOFFICIAL_PATCH Start
	// * Vassal's spies no longer caught in master's territory
	//if (GET_TEAM(eLocalTeam).isVassal(getTeam()))
	if (GET_TEAM(eLocalTeam).isVassal(getTeam()) || GET_TEAM(getTeam()).isVassal(eLocalTeam))
	// UNOFFICIAL_PATCH End
	{
		return false;
	}

	return true;
}

bool CvUnit::canGoldenAge(bool bTestVisible) const
{
	if (!isGoldenAge())
	{
		return false;
	}

	if (!bTestVisible)
	{
		if (GET_PLAYER(getOwner()).unitsRequiredForGoldenAge() > GET_PLAYER(getOwner()).unitsGoldenAgeReady())
		{
			return false;
		}
	}

	return true;
}


bool CvUnit::goldenAge()
{
	if (!canGoldenAge())
	{
		return false;
	}

	GET_PLAYER(getOwner()).killGoldenAgeUnits(this);

	GET_PLAYER(getOwner()).changeGoldenAgeTurns(GET_PLAYER(getOwner()).getGoldenAgeLength());
	GET_PLAYER(getOwner()).changeNumUnitGoldenAges(1);

	if (plot()->isActiveVisible(false))
	{
		NotifyEntity(MISSION_GOLDEN_AGE);
	}

	kill(true, NO_PLAYER, true);

	return true;
}


bool CvUnit::canBuild(const CvPlot* pPlot, BuildTypes eBuild, bool bTestVisible) const
{
	if (!hasBuild(eBuild))
	{
		return false;
	}

	if (getGroup()->isAutomated())
	{
		if (!GET_PLAYER(getOwner()).isAutomatedCanBuild(eBuild))
		{
			return false;
		}
		if (plot()->getWorkingCity() != NULL && !plot()->getWorkingCity()->isAutomatedCanBuild(eBuild))
		{
			return false;
		}
	}

	if (!GET_PLAYER(getOwner()).canBuild(pPlot, eBuild, bTestVisible))
	{
		return false;
	}

	if (!pPlot->isValidDomainForAction(*this))
	{
		return false;
	}

	return true;
}

// Returns true if build finished...
bool CvUnit::build(BuildTypes eBuild)
{
	if (!canBuild(plot(), eBuild))
	{
		return false;
	}

	//TBNOTE: There were still some crashes in this so workers cannot merge or split anymore.
	//if (GC.getBuildInfo(eBuild).isKill())
	//{
	//	if (!canPerformActionSM())
	//	{
	//		getGroup()->clearMissionQueue();
	//		if (isHuman())
	//		{

	//			CvWString szBuffer = gDLL->getText("TXT_KEY_MISC_UNIT_CANT_FINISH_BUILD", getNameKey(), GC.getBuildInfo(eBuild).getTextKeyWide());
	//			AddDLLMessage(getOwner(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_PILLAGE", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_YELLOW(), getX(), getY());
	//		}
	//		return false;
	//	}
	//}

	// Note: notify entity must come before changeBuildProgress - because once the unit is done building,
	// that function will notify the entity to stop building.
	NotifyEntity((MissionTypes)GC.getBuildInfo(eBuild).getMissionType());

	GET_PLAYER(getOwner()).changeGold(-(GET_PLAYER(getOwner()).getBuildCost(plot(), eBuild)));

	bool bFinished = plot()->changeBuildProgress(eBuild, workRate(false), getOwner());

	finishMoves(); // needs to be at bottom because movesLeft() can affect workRate()...
	deselect(true);

	if (bFinished)
	{
		const CvBuildInfo& kBuild = GC.getBuildInfo(eBuild);
		// Super Forts begin *culture*
		if (kBuild.getImprovement() != NO_IMPROVEMENT
		&& GC.getImprovementInfo(kBuild.getImprovement()).getCulture() > 0)
		{
			if (plot()->getOwner() == NO_PLAYER)
			{
				plot()->setOwner(getOwner(),true,true);
			}

			// Special case for plot-grabbing improvements - to get the AI to behave sensibly
			// we nee to split the group here or else an escorted worker will now move away, taking its
			// escort with it, leaving the fort undefended until some other defensive unit can get there.
			// By splitting the group we let the escort occupy the fort at higher priority than
			// re-grouping with the worker, which then has to wait for another escort if it needs one
			if (!isHuman())
			{
				getGroup()->AI_makeForceSeparate();
			}
		}
		// Super Forts end

		if (kBuild.isKill())
		{
			if (plot()->getWorkingCity() != NULL)
			{
				OutputDebugString(CvString::format("Worker at (%d,%d) consumed by build for city %S\n", getX(), getY(), plot()->getWorkingCity()->getName().GetCString()).c_str());
			}
			kill(true, NO_PLAYER, true);
		}
		else if (kBuild.getTime() > 0)
		{
			//ls612: Workers now get XP on finishing a build
			changeExperience100(kBuild.getTime() / std::max(1, workRate(true) / 50));
		}
	}

	// Python Event
	CvEventReporter::getInstance().unitBuildImprovement(this, eBuild, bFinished);

	return bFinished;
}


bool CvUnit::canPromote(PromotionTypes ePromotion, int iLeaderUnitId) const
{
	if (iLeaderUnitId >= 0)
	{
		if (iLeaderUnitId == getID())
		{
			return false;
		}

		// The command is always possible if it's coming from a Warlord unit that gives just experience points
		CvUnit* pWarlord = GET_PLAYER(getOwner()).getUnit(iLeaderUnitId);
		if (pWarlord &&
			NO_UNIT != pWarlord->getUnitType() &&
			pWarlord->getUnitInfo().getLeaderExperience() > 0 &&
			NO_PROMOTION == pWarlord->getUnitInfo().getLeaderPromotion() &&
			canAcquirePromotionAny())
		{
			return true;
		}
	}

	if (ePromotion == NO_PROMOTION)
	{
		return false;
	}

	//TB Debug Note: Apparently the promotions that indicate the unit will become a Leader type that are given to the unit during a Leader attaching
	//to the unit were passing through canAcquirePromotion with a true result though these should've been eliminated here as testPromotionReady would
	//thus find there was an existing promotion possible by only checking against canAcquirePromotion and not including the rest of these checks.
	//By making bForLeader a default false, this will only make it possible to pass true on that check on a leader promotion in canAcquirePromotion if the
	//check is specfically to see if the unit can in all other ways qualify for the leader promo.
	PromotionRequirements::flags promoFlags = PromotionRequirements::Promote;

	if (iLeaderUnitId >= 0)
	{
		promoFlags |= PromotionRequirements::ForLeader;
	}

	if (!canAcquirePromotion(ePromotion, promoFlags))
	{
		return false;
	}

	if (GC.getPromotionInfo(ePromotion).isLeader())
	{
		if (iLeaderUnitId >= 0)
		{
			const CvUnit* pWarlord = GET_PLAYER(getOwner()).getUnit(iLeaderUnitId);

			if (pWarlord && NO_UNIT != pWarlord->getUnitType())
			{
				return (pWarlord->getUnitInfo().getLeaderPromotion() == ePromotion);
			}
		}
		return false;
	}

	if (!isPromotionReady())
	{
		return false;
	}

	return true;
}

bool CvUnit::promote(PromotionTypes ePromotion, int iLeaderUnitId)
{
	if (!canPromote(ePromotion, iLeaderUnitId))
	{
		return false;
	}

	if (iLeaderUnitId >= 0)
	{
		CvUnit* pWarlord = GET_PLAYER(getOwner()).getUnit(iLeaderUnitId);
		if (pWarlord)
		{
			pWarlord->giveExperience();
			if (!pWarlord->getNameNoDesc().empty())
			{
				setName(pWarlord->getNameKey());
			}

			//update graphics models
			m_eLeaderUnitType = pWarlord->getUnitType();
			reloadEntity();
		}
	}

	if (!GC.getPromotionInfo(ePromotion).isLeader())
	{
		if (getRetrainsAvailable() > 0)
		{
			changeRetrainsAvailable(-1);
		}
		else
		{
			changeLevel(1);
			changeDamage(-(getDamage() / 2));
			int iDmgChange = (-(getDamage() / 2));
			if (getColdDamage() > 0)
			{
				if (iDmgChange > getColdDamage())
				{
					setColdDamage(0);
				}
				else
				{
					changeColdDamage(iDmgChange);
				}
			}
		}
	}

	setHasPromotion(ePromotion, true, false, false, true);

	testPromotionReady();

	if (IsSelected())
	{
		gDLL->getInterfaceIFace()->playGeneralSound(GC.getPromotionInfo(ePromotion).getSound());

		gDLL->getInterfaceIFace()->setDirty(UnitInfo_DIRTY_BIT, true);

// BUG - Update Plot List - start
		gDLL->getInterfaceIFace()->setDirty(PlotListButtons_DIRTY_BIT, true);
// BUG - Update Plot List - end
	}
	else
	{
		setInfoBarDirty(true);
	}

	CvEventReporter::getInstance().unitPromoted(this, ePromotion);

	return true;
}

bool CvUnit::lead(int iUnitId)
{
	if (!canLead(plot(), iUnitId))
	{
		return false;
	}

	PromotionTypes eLeaderPromotion = (PromotionTypes)m_pUnitInfo->getLeaderPromotion();

	if (-1 == iUnitId)
	{
		CvPopupInfo* pInfo = new CvPopupInfo(BUTTONPOPUP_LEADUNIT, eLeaderPromotion, getID());
		if (pInfo)
		{
			gDLL->getInterfaceIFace()->addPopup(pInfo, getOwner(), true);
		}
		return false;
	}
	else
	{
		CvUnit* pUnit = GET_PLAYER(getOwner()).getUnit(iUnitId);

		if (!pUnit || !pUnit->canPromote(eLeaderPromotion, getID()))
		{
			return false;
		}

		pUnit->joinGroup(NULL, true, true);

		pUnit->promote(eLeaderPromotion, getID());

		if (plot()->isActiveVisible(false))
		{
			NotifyEntity(MISSION_LEAD);
		}

		kill(true, NO_PLAYER, true);

		return true;
	}
}


int CvUnit::canLead(const CvPlot* pPlot, int iUnitId) const
{
	PROFILE_FUNC();

	if (isDelayedDeath())
	{
		return 0;
	}

	if (NO_UNIT == getUnitType())
	{
		return 0;
	}

	if (isCommander())
	{
		return 0;
	}

	if (isCommodore())
	{
		return 0;
	}

	if (isTrap())
	{
		return 0;
	}

	int iNumUnits = 0;
	const CvUnitInfo& kUnitInfo = getUnitInfo();

	if (-1 == iUnitId)
	{
		foreach_(const CvUnit* pUnit, pPlot->units())
		{
			if (pUnit != this &&
				pUnit->getOwner() == getOwner() &&
				!pUnit->isTrap() &&
				!pUnit->isCommander() &&
				!pUnit->isCommodore() &&
				pUnit->canPromote((PromotionTypes)kUnitInfo.getLeaderPromotion(), getID()))
			{
				++iNumUnits;
			}
		}
	}
	else
	{
		const CvUnit* pUnit = GET_PLAYER(getOwner()).getUnit(iUnitId);
		if (pUnit && pUnit != this &&
			!pUnit->isTrap() &&
			pUnit->canPromote((PromotionTypes)kUnitInfo.getLeaderPromotion(), getID()))
		{
			iNumUnits = 1;
		}
	}
	return iNumUnits;
}


int CvUnit::canGiveExperience(const CvPlot* pPlot) const
{
	PROFILE_EXTRA_FUNC();
	int iNumUnits = 0;

	if (NO_UNIT != getUnitType() && m_pUnitInfo->getLeaderExperience() > 0)
	{
		foreach_(const CvUnit* pUnit, pPlot->units())
		{
			if (pUnit != this
			&& pUnit->getOwner() == getOwner()
			&& pUnit->canAcquirePromotionAny()
			&& !pUnit->getUnitInfo().isGreatGeneral()
			&& !pUnit->isTrap())
			{
				++iNumUnits;
			}
		}
	}
	return iNumUnits;
}

bool CvUnit::giveExperience()
{
	PROFILE_EXTRA_FUNC();
	const CvPlot* pPlot = plot();

	if (pPlot)
	{
		const int iNumUnits = canGiveExperience(pPlot);
		if (iNumUnits > 0)
		{
			const int iTotalExperience = getStackExperienceToGive(iNumUnits);
			const int iMinExperiencePerUnit = iTotalExperience / iNumUnits;

			int i = 0;
			foreach_(CvUnit* pUnit, pPlot->units())
			{
				if (pUnit != this && pUnit->getOwner() == getOwner() && !pUnit->isTrap()
				&& !pUnit->isCommander() && !pUnit->isCommodore() && pUnit->canAcquirePromotionAny())
				{
					pUnit->changeExperience(i < (iTotalExperience % iNumUnits) ? iMinExperiencePerUnit + 1 : iMinExperiencePerUnit);
				}
				i++;
			}
			return true;
		}
	}
	return false;
}

int CvUnit::getStackExperienceToGive(int iNumUnits) const
{
	return (m_pUnitInfo->getLeaderExperience() * (100 + std::min(50, (iNumUnits - 1) * GC.getDefineINT("WARLORD_EXTRA_EXPERIENCE_PER_UNIT_PERCENT")))) / 100;
}

int CvUnit::upgradePrice(UnitTypes eUnit) const
{
	if (isNPC())
	{
		return 0;
	}
	int64_t iPrice = (
		GC.getUNIT_UPGRADE_COST_PER_PRODUCTION()
		* (
			GET_PLAYER(getOwner()).getProductionNeeded(eUnit)
			-
			GET_PLAYER(getOwner()).getBaseUnitCost100(getUnitType()) / 100
		)
	);
	if (iPrice < 1)
	{
		return 1;
	}
	{
		int iMod = GET_PLAYER(getOwner()).getUnitUpgradePriceModifier();
		if (!isHuman())
		{
			iMod += (
				GC.getHandicapInfo(GC.getGame().getHandicapType()).getAIUnitUpgradePercent() - 100
				+
				GC.getHandicapInfo(GC.getGame().getHandicapType()).getAIPerEraModifier() * GET_PLAYER(getOwner()).getCurrentEra()
			);
		}
		iPrice = getModifiedIntValue64(iPrice, iMod);
	}
	iPrice -= iPrice * std::min(100, getUpgradeDiscount()) / 100;

	if (GC.getGame().isOption(GAMEOPTION_COMBAT_SIZE_MATTERS))
	{
		iPrice = applySMRank64(iPrice, getSizeMattersOffsetValue(), GC.getSIZE_MATTERS_MOST_MULTIPLIER(), false);
	}
	iPrice /= 100;

	if (iPrice >= MAX_INT)
	{
		return MAX_INT;
	}
	return std::max(1, static_cast<int>(iPrice));
}


bool CvUnit::upgradeAvailable(UnitTypes eFromUnit, UnitTypes eToUnit) const
{
	return GET_PLAYER(getOwner()).upgradeAvailable(eFromUnit, eToUnit);
}


bool CvUnit::canUpgrade(UnitTypes eUnit, bool bTestVisible) const
{
	if (eUnit == NO_UNIT || !isReadyForUpgrade())
	{
		return false;
	}

	if (!bTestVisible && GET_PLAYER(getOwner()).getGold() < upgradePrice(eUnit))
	{
		return false;
	}

	if (GET_PLAYER(getOwner()).getUpgradeRoundCount() == GC.getUPGRADE_ROUND_LIMIT())
	{
		return false;
	}

	if (isCargo())//Being able to upgrade a loaded unit can be problematic
	{
		return false;
	}

	//units in cities cannot upgrade unless the city is one of the owner's team.
	//easiest way to keep upgrades from capturing.  Enforces Rogues must move out of opponent cities to upgrade, which is a little risky which is something to keep things interesting for them.
	if (plot() != NULL && plot()->getPlotCity() != NULL && getTeam() != plot()->getTeam())
	{
		return false;
	}

	if (hasUpgrade(eUnit))
	{
		return true;
	}

	return false;
}

bool CvUnit::isReadyForUpgrade() const
{
	return canMove() && (plot()->getTeam() == getTeam() || isUpgradeAnywhere() || GET_PLAYER(getOwner()).isUpgradeAnywhere());
}

// has upgrade is used to determine if an upgrade is possible,
// it specifically does not check whether the unit can move, whether the current plot is owned, enough gold
// those are checked in canUpgrade()
// does not search all cities, only checks the closest one
bool CvUnit::hasUpgrade(bool bSearch) const
{
	return getUpgradeCity(bSearch) != NULL;
}

// has upgrade is used to determine if an upgrade is possible,
// it specifically does not check whether the unit can move, whether the current plot is owned, enough gold
// those are checked in canUpgrade()
// does not search all cities, only checks the closest one
bool CvUnit::hasUpgrade(UnitTypes eUnit, bool bSearch) const
{
	return getUpgradeCity(eUnit, bSearch) != NULL;
}

// finds the 'best' city which has a valid upgrade for the unit,
// it specifically does not check whether the unit can move, or if the player has enough gold to upgrade
// those are checked in canUpgrade()
// if bSearch is true, it will check every city, if not, it will only check the closest valid city
// NULL result means the upgrade is not possible
CvCity* CvUnit::getUpgradeCity(bool bSearch) const
{
	PROFILE_FUNC();

	CvPlayerAI& kPlayer = GET_PLAYER(getOwner());
	const UnitAITypes eUnitAI = AI_getUnitAIType();
	CvArea* pArea = area();

	const int iCurrentValue = kPlayer.AI_unitValue(getUnitType(), eUnitAI, pArea);

	int iBestSearchValue = MAX_INT;
	CvCity* pBestUpgradeCity = NULL;

	foreach_(int iUnitX, GC.getUnitInfo(m_eUnitType).getUnitUpgradeChain())
	{
		const UnitTypes eUnitX = (UnitTypes)iUnitX;

		if (upgradeAvailable(m_eUnitType, eUnitX) && kPlayer.canTrain(eUnitX)
		&& kPlayer.AI_unitValue(eUnitX, eUnitAI, pArea) > iCurrentValue)
		{
			int iSearchValue;
			CvCity* pUpgradeCity = getUpgradeCity(eUnitX, bSearch, &iSearchValue);
			if (pUpgradeCity != NULL)
			{
				// if not searching or close enough, then this match will do
				if (!bSearch || iSearchValue < 16)
				{
					return pUpgradeCity;
				}

				if (iSearchValue < iBestSearchValue)
				{
					iBestSearchValue = iSearchValue;
					pBestUpgradeCity = pUpgradeCity;
				}
			}
		}
	}
	return pBestUpgradeCity;
}

// finds the 'best' city which has a valid upgrade for the unit, to eUnit type
// it specifically does not check whether the unit can move, or if the player has enough gold to upgrade
// those are checked in canUpgrade()
// if bSearch is true, it will check every city, if not, it will only check the closest valid city
// if iSearchValue non NULL, then on return it will be the city's proximity value, lower is better
// NULL result means the upgrade is not possible
CvCity* CvUnit::getUpgradeCity(UnitTypes eUnit, bool bSearch, int* iSearchValue) const
{
	PROFILE_FUNC();

	if (eUnit == NO_UNIT || !upgradeAvailable(m_eUnitType, eUnit) || !GET_PLAYER(getOwner()).canTrain(eUnit, false, false, true))
	{
		return NULL;
	}
	const CvUnitInfo& kUnitInfo = GC.getUnitInfo(eUnit);

	//The following checks to make sure that the upgrade won't make it impossible for a ship to hold
	//the cargo it already does.
	if (GC.getGame().isOption(GAMEOPTION_COMBAT_SIZE_MATTERS))
	{
		if (kUnitInfo.getSMCargoSpace() < SMgetCargo())
		{
			return NULL;
		}
	}
	else if (kUnitInfo.getCargoSpace() < getCargo())
	{
		return NULL;
	}

	foreach_(const CvUnit* pLoopUnit, plot()->units())
	{
		if (pLoopUnit->getTransportUnit() == this)
		{
			if (kUnitInfo.getSpecialCargo() != NO_SPECIALUNIT)
			{
				return NULL;
			}

			if (kUnitInfo.getDomainCargo() != NO_DOMAIN && kUnitInfo.getDomainCargo() != pLoopUnit->getDomainType())
			{
				return NULL;
			}
		}
	}

	// sea units must be built on the coast
	const bool bCoastalOnly = getDomainType() == DOMAIN_SEA;

	// results
	int iBestValue = MAX_INT;
	CvCity* pBestCity = NULL;

	// if search is true, check every city for our team
	if (bSearch)
	{
		// air units can travel any distance
		const bool bIgnoreDistance = getDomainType() == DOMAIN_AIR;
		const CvArea* pMyArea = (bCoastalOnly && !plot()->isWater()) ? plot()->waterArea() : area();

		const TeamTypes eTeam = getTeam();
		const int iX = getX();
		const int iY = getY();

		// check every player on our team's cities
		for (int iI = 0; iI < MAX_PLAYERS; iI++)
		{
			// is this player on our team?
			if (GET_PLAYER((PlayerTypes)iI).isAliveAndTeam(eTeam))
			{
				foreach_(CvCity* pLoopCity, GET_PLAYER((PlayerTypes)iI).cities())
				{
					// if coastal only, then make sure we are coast
					CvArea* pCityArea = bCoastalOnly ? pLoopCity->waterArea() : pLoopCity->area();

					// Toffer, units should not be compelled to travel between areas just to get an upgrade.
					if ((bIgnoreDistance || pMyArea == pCityArea) && pLoopCity->canTrain(eUnit, false, false, true))
					{
						// if we do not care about distance, then the first match will do
						if (bIgnoreDistance)
						{
							// if we do not care about distance, then return 1 for value
							if (iSearchValue != NULL)
							{
								*iSearchValue = 1;
							}
							return pLoopCity;
						}
						int iValue = plotDistance(iX, iY, pLoopCity->getX(), pLoopCity->getY());

						// if we cannot path there, not as good (lower numbers are better)
						if (!generatePath(pLoopCity->plot(), 0, true))
						{
							iValue *= 16;
						}
						if (iValue < iBestValue)
						{
							iBestValue = iValue;
							pBestCity = pLoopCity;
						}
					}
				}
			}
		}
	}
	else
	{
		// Find the closest city
		CvCity* pClosestCity = GC.getMap().findCity(getX(), getY(), NO_PLAYER, getTeam(), true, bCoastalOnly);

		// If we can train, then return this city (otherwise it will return NULL)
		if (pClosestCity != NULL && pClosestCity->canTrain(eUnit, false, false, true))
		{
			// did not search, always return 1 for search value
			iBestValue = 1;
			pBestCity = pClosestCity;
		}
	}

	// return the best value, if non-NULL
	if (iSearchValue != NULL)
	{
		*iSearchValue = iBestValue;
	}
	return pBestCity;
}

bool CvUnit::upgrade(UnitTypes eUnit)
{
	if (!canUpgrade(eUnit))
	{
		return false;
	}

// BUG - Upgrade Unit Event - start
	const int iPrice = upgradePrice(eUnit);
	GET_PLAYER(getOwner()).changeGold(-iPrice);
	GET_PLAYER(getOwner()).changeUpgradeRoundCount(1);
// BUG - Upgrade Unit Event - end

	//	Preserve the AI type if that is possible
	UnitAITypes eUnitAI = AI_getUnitAIType();

	if ( !GC.getUnitInfo(eUnit).getUnitAIType(eUnitAI) )
	{
		eUnitAI = NO_UNITAI;	//	Will cause it to initialize with its default
	}

	//Set Group to rejoin
	GET_PLAYER(getOwner()).setSelectionRegroup(getGroupID());
	//Set Unit to reload onto
	CvUnit* pTransportUnit = getTransportUnit();

	CvUnit* pUpgradeUnit = GET_PLAYER(getOwner()).initUnit(eUnit, getX(), getY(), eUnitAI, NO_DIRECTION, GC.getGame().getSorenRandNum(10000, "AI Unit Birthmark"));
	if (pUpgradeUnit == NULL)
	{
		FErrorMsg("UpgradeUnit is not assigned a valid value");
		return false;
	}
	pUpgradeUnit->joinGroup(getGroup());
	if (pTransportUnit)
	{
		pUpgradeUnit->setTransportUnit(pTransportUnit);
	}
	//Clear Group to rejoin
	GET_PLAYER(getOwner()).setSelectionRegroup(NULL);

	pUpgradeUnit->convert(this);

	pUpgradeUnit->finishMoves();

	if (pUpgradeUnit->getLeaderUnitType() == NO_UNIT && !GC.getGame().isOption(GAMEOPTION_UNIT_INFINITE_XP))
	{
		pUpgradeUnit->setExperience(pUpgradeUnit->getExperience() * 3 / 5);
	}

	CvEventReporter::getInstance().unitUpgraded(this, pUpgradeUnit, iPrice);

	if (gUnitLogLevel > 2)
	{
		CvWString szString;
		getUnitAIString(szString, pUpgradeUnit->AI_getUnitAIType());
		logBBAI("    %S spends %d to upgrade %S to %S, unit AI %S", GET_PLAYER(getOwner()).getCivilizationDescription(0), upgradePrice(eUnit), getName(0).GetCString(), pUpgradeUnit->getName(0).GetCString(), szString.GetCString());
	}

	return true;
}


HandicapTypes CvUnit::getHandicapType() const
{
	return GET_PLAYER(getOwner()).getHandicapType();
}


CivilizationTypes CvUnit::getCivilizationType() const
{
	return GET_PLAYER(getOwner()).getCivilizationType();
}

const wchar_t* CvUnit::getVisualCivAdjective(TeamTypes eForTeam) const
{
	if (getVisualOwner(eForTeam) == getOwner())
	{
		return GC.getCivilizationInfo(getCivilizationType()).getAdjectiveKey();
	}

	return L"";
}

SpecialUnitTypes CvUnit::getSpecialUnitType() const
{
	if (m_eSpecialUnit != NO_SPECIALUNIT)
	{
		return m_eSpecialUnit;
	}
	return ((SpecialUnitTypes)(m_pUnitInfo->getSpecialUnitType()));
}


UnitTypes CvUnit::getCaptureUnitType() const
{
	return m_pUnitInfo->getUnitCaptureType();
}


UnitCombatTypes CvUnit::getUnitCombatType() const
{
	return (UnitCombatTypes) m_pUnitInfo->getUnitCombatType();
}


DomainTypes CvUnit::getDomainType() const
{
	return m_pUnitInfo->getDomainType();
}


InvisibleTypes CvUnit::getInvisibleType() const
{
	const InvisibleTypes eInvisible = (InvisibleTypes)m_pUnitInfo->getInvisibleType();
	if (eInvisible != NO_INVISIBLE && isNegatesInvisible(eInvisible))
	{
		return NO_INVISIBLE;
	}
	return (eInvisible);
}

int CvUnit::getNumSeeInvisibleTypes() const
{
	return m_pUnitInfo->getNumSeeInvisibleTypes();
}

InvisibleTypes CvUnit::getSeeInvisibleType(int i) const
{
	return (InvisibleTypes)(m_pUnitInfo->getSeeInvisibleType(i));
}


int CvUnit::flavorValue(FlavorTypes eFlavor) const
{
	return m_pUnitInfo->getFlavorValue(eFlavor);
}


bool CvUnit::isNPC() const
{
	return GET_PLAYER(getOwner()).isNPC();
}


bool CvUnit::isHominid() const
{
	return GET_PLAYER(getOwner()).isHominid();
}


bool CvUnit::isHuman() const
{
	return GET_PLAYER(getOwner()).isHumanPlayer();
}


int CvUnit::visibilityRange(const CvPlot* pPlot) const
{
	if (pPlot == NULL)
	{
		pPlot = plot();
	}
	int iRange = 1 + pPlot->getTerrainElevation() + getExtraVisibilityRange();

	if (pPlot->getImprovementType() != NO_IMPROVEMENT)
	{
		iRange += GC.getImprovementInfo(pPlot->getImprovementType()).getVisibilityChange();
	}
	return std::min(GC.getMAX_UNIT_VISIBILITY_RANGE(), iRange);
}


int CvUnit::baseMoves() const
{
	return (
		m_pUnitInfo->getMoves()
		+ getExtraMoves()
		+ (getDomainType() != DOMAIN_AIR ? GET_TEAM(getTeam()).getExtraMoves(getDomainType()) : 0)
	);
}

int CvUnit::maxMoves() const
{
	PROFILE_FUNC();

	if (m_iMaxMoveCacheTurn != GC.getGame().getGameTurn())
	{
		m_maxMoveCache = (baseMoves() * GC.getMOVE_DENOMINATOR());
		m_iMaxMoveCacheTurn = GC.getGame().getGameTurn();
	}
	return m_maxMoveCache;
}

int CvUnit::movesLeft() const
{
	return std::max(0, maxMoves() - getMoves());
}

bool CvUnit::canMove() const
{
	return !isDead() && getMoves() < maxMoves() && getImmobileTimer() < 1;
}

bool CvUnit::hasMoved()	const
{
	return getMoves() > 0;
}


int CvUnit::airRange() const
{
	const SpecialUnitTypes eMissile = GC.getSPECIALUNIT_MISSILE();
	if (getDomainType() == DOMAIN_AIR && nukeRange() == -1 && getSpecialUnitType() != eMissile)
	{
		return (m_pUnitInfo->getAirRange() + getExtraAirRange() + GET_TEAM(getTeam()).getExtraMoves(DOMAIN_AIR) + GET_PLAYER(getOwner()).getNationalFlightOperationRangeChange());
	}
	if (getDomainType() == DOMAIN_AIR && getSpecialUnitType() == eMissile)
	{
		return (m_pUnitInfo->getAirRange() + getExtraAirRange() + GET_TEAM(getTeam()).getExtraMoves(DOMAIN_AIR) + GET_PLAYER(getOwner()).getNationalMissileRangeChange());
	}
	return (m_pUnitInfo->getAirRange() + getExtraAirRange());
}


int CvUnit::nukeRange() const
{
	return m_pUnitInfo->getNukeRange();
}

namespace CvUnitInternal
{
	bool canBuildRoute(const std::vector<BuildTypes>& aBuilds, const CvTeam& team)
	{
		PROFILE_EXTRA_FUNC();
		foreach_(const BuildTypes eBuild, aBuilds)
		{
			const CvBuildInfo& info = GC.getBuildInfo(eBuild);
			if (info.getRoute() > NO_ROUTE && team.isHasTech(info.getTechPrereq()))
			{
				const TechTypes obsoleteTech = info.getObsoleteTech();
				if (obsoleteTech == NO_TECH || !team.isHasTech(obsoleteTech))
					return true;
			}
		}
		return false;
	}
}

bool CvUnit::canBuildRoute() const
{
	if (!isWorker()) return false;

	const CvTeam& team = GET_TEAM(getTeam());
	return CvUnitInternal::canBuildRoute(m_worker->getExtraBuilds(), team)
		|| CvUnitInternal::canBuildRoute(m_pUnitInfo->getBuilds(), team);
}

BuildTypes CvUnit::getBuildType() const
{
	BuildTypes eBuild;

	if (getGroup()->headMissionQueueNode() != NULL)
	{
		switch (getGroup()->headMissionQueueNode()->m_data.eMissionType)
		{
		case MISSION_MOVE_TO:
// BUG - Sentry Actions - start
#ifdef _MOD_SENTRY
		case MISSION_MOVE_TO_SENTRY:
#endif
// BUG - Sentry Actions - end
			break;

		case MISSION_ROUTE_TO:
			if (getGroup()->getBestBuildRoute(plot(), &eBuild) != NO_ROUTE)
			{
				return eBuild;
			}
			break;

		case MISSION_MOVE_TO_UNIT:
		case MISSION_SKIP:
		case MISSION_SLEEP:
		case MISSION_FORTIFY:
		case MISSION_BUILDUP:
		case MISSION_AUTO_BUILDUP:
		case MISSION_HEAL_BUILDUP:
		case MISSION_PLUNDER:
		case MISSION_AIRPATROL:
		case MISSION_SEAPATROL:
		case MISSION_HEAL:
		case MISSION_SENTRY:
// BUG - Sentry Actions - start
#ifdef _MOD_SENTRY
		case MISSION_SENTRY_WHILE_HEAL:
		case MISSION_SENTRY_NAVAL_UNITS:
		case MISSION_SENTRY_LAND_UNITS:
#endif
// BUG - Sentry Actions - end
		case MISSION_AIRLIFT:
		case MISSION_NUKE:

		case MISSION_RECON:
		case MISSION_PARADROP:
		case MISSION_AIRBOMB:
		case MISSION_BOMBARD:
		case MISSION_RANGE_ATTACK:
		case MISSION_PILLAGE:
		case MISSION_SABOTAGE:
		case MISSION_DESTROY:
		case MISSION_STEAL_PLANS:
		case MISSION_FOUND:
		case MISSION_SPREAD:
		case MISSION_SPREAD_CORPORATION:
		case MISSION_JOIN:
		case MISSION_CONSTRUCT:
		case MISSION_HERITAGE:
		case MISSION_DISCOVER:
		case MISSION_HURRY:
		case MISSION_TRADE:
		case MISSION_GREAT_WORK:
		case MISSION_INFILTRATE:
		case MISSION_GOLDEN_AGE:
		case MISSION_LEAD:
		case MISSION_ESPIONAGE:
		case MISSION_DIE_ANIMATION:
		// Dale - AB: Bombing
		case MISSION_AIRBOMB1:
		case MISSION_AIRBOMB2:
		case MISSION_AIRBOMB3:
		case MISSION_AIRBOMB4:
		case MISSION_AIRBOMB5:
		// Dale - RB: Field Bombard
		case MISSION_RBOMBARD:
		// Dale - FE: Fighters
		case MISSION_FENGAGE:
		// ! Dale
		case MISSION_HURRY_FOOD:
		case MISSION_INQUISITION:
		case MISSION_CLAIM_TERRITORY:
		case MISSION_ESPIONAGE_SLEEP:
		case MISSION_GREAT_COMMANDER:
		case MISSION_GREAT_COMMODORE:
		case MISSION_SHADOW:
		case MISSION_AMBUSH:
		case MISSION_ASSASSINATE:
			break;

		case MISSION_BUILD:
			return (BuildTypes)getGroup()->headMissionQueueNode()->m_data.iData1;
			break;

		default:
			// AIAndy: Assumed to be an outcome mission
			// FErrorMsg("error");
			break;
		}
	}

	return NO_BUILD;
}

ImprovementTypes CvUnit::getBuildTypeImprovement() const
{
	const BuildTypes buildType = getBuildType();
	if (buildType == NO_BUILD) return NO_IMPROVEMENT;
	return GC.getBuildInfo(buildType).getImprovement();
}

bool CvUnit::isAnimal() const
{
	return GET_PLAYER(getOwner()).isAnimal();
}


bool CvUnit::isNoBadGoodies() const
{
	return m_pUnitInfo->isNoBadGoodies();
}


bool CvUnit::isOnlyDefensive() const
{
	return m_iOnlyDefensiveCount + m_pUnitInfo->isOnlyDefensive();
}

void CvUnit::changeOnlyDefensiveCount(int iChange)
{
	m_iOnlyDefensiveCount += iChange;
}


bool CvUnit::hasRBombardForceAbility() const
{
	bool bForce = (m_pUnitInfo->isRBombardForceAbility() || (getRBombardForceAbilityCount() > 0));
	return bForce;
}

int CvUnit::getRBombardForceAbilityCount() const
{
	return m_iRBombardForceAbilityCount;
}

void CvUnit::changeRBombardForceAbilityCount(int iChange)
{
	m_iRBombardForceAbilityCount += iChange;
}

bool CvUnit::isNoCapture() const
{
	int iCount = getNoCaptureCount();
	if (!canAttack())
	{
		iCount++;
	}
	if (m_pUnitInfo->isNoCapture())
	{
		iCount++;
	}
	return (iCount > 0);
}


bool CvUnit::isRivalTerritory() const
{
	return m_pUnitInfo->isRivalTerritory();
}


bool CvUnit::isMilitaryHappiness() const
{
	return m_pUnitInfo->isMilitaryHappiness();
}

bool CvUnit::isMilitaryBranch() const
{
	return m_pUnitInfo->isMilitarySupport();
}


bool CvUnit::isInvestigate() const
{
	return m_pUnitInfo->isInvestigate();
}


bool CvUnit::isCounterSpy() const
{
	return m_pUnitInfo->isCounterSpy();
}


bool CvUnit::isSpy() const
{
	return m_pUnitInfo->isSpy();
}


bool CvUnit::isFound() const
{
	return m_pUnitInfo->isFound();
}

bool CvUnit::isGoldenAge() const
{
	if (isDelayedDeath())
	{
		return false;
	}
	return m_pUnitInfo->isGoldenAge();
}

bool CvUnit::canCoexistAlwaysOnPlot(const CvPlot& onPlot) const
{
	return alwaysInvisible() || onPlot.isCity(true) && isBlendIntoCity();
}

bool CvUnit::canCoexistWithTeam(const TeamTypes withTeam) const
{
	return alwaysInvisible() || getTeam() == withTeam;
}

bool CvUnit::canCoexistWithTeamOnPlot(const TeamTypes withTeam, const CvPlot& onPlot) const
{
	return (
		   getTeam() == withTeam
		|| canCoexistAlwaysOnPlot(onPlot)
		// Invisible to team and on the same plot
		|| isInvisible(withTeam) && *plot() == onPlot
	);
}

namespace {
	// Will an attacker be always hostile to a defender on the defenders plot?
	bool alwaysHostile(const CvUnit& defender, const CvUnit& attacker)
	{
		return (
			(defender.isAlwaysHostile(defender.plot()) || attacker.isAlwaysHostile(defender.plot()))
			&&
			(!GC.getGame().isOption(GAMEOPTION_ANIMAL_PEACE_AMONG_NPCS) || !defender.isNPC() || !attacker.isNPC())
		);
	}
}
bool CvUnit::canCoexistWithAttacker(const CvUnit& attacker, bool bStealthDefend, bool bAssassinate) const
{
	const TeamTypes attackerTeam = GET_PLAYER(attacker.getOwner()).getTeam();

	return (
		// Same team
		getTeam() == attackerTeam
		// Always invisible
		|| alwaysInvisible() || attacker.alwaysInvisible()
		// Coexists due to blending into a city (nullified by assassination)
		|| !bAssassinate && plot()->isCity(false) && (isBlendIntoCity() || attacker.isBlendIntoCity())
		// Invisibility to the attacking team (nullified by stealthDefend)
		|| !bStealthDefend && isInvisible(attackerTeam, false)
		// War enemy, or just always hostile
		|| !isEnemy(attackerTeam) && !alwaysHostile(*this, attacker)
		// Checks for differing domains, transport status, amnesty game setting
		|| canUnitCoexistWithArrivingUnit(attacker)
	);
}

bool CvUnit::canUnitCoexistWithArrivingUnit(const CvUnit& enemyUnit) const
{
	if (enemyUnit.isDead())
	{
		return true;
	}

	if (plot()->isWater())
	{
		if (enemyUnit.canLoad(plot()))
		{
			return true;
		}

		if (plot()->isSeaTunnel())
		{
			const bool bIsAboveWater =
				getDomainType() != DOMAIN_LAND
				||
				canMoveAllTerrain();
			const bool bOtherIsAboveWater =
				enemyUnit.getDomainType() != DOMAIN_LAND
				||
				enemyUnit.canMoveAllTerrain();

			if (bIsAboveWater && !bOtherIsAboveWater)
			{
				return true;
			}
			if (!bIsAboveWater && bOtherIsAboveWater)
			{
				return true;
			}
		}
	}

	if (!isArmedTrap() && !enemyUnit.isArmedTrap())
	{
		if (!canAttack() && !enemyUnit.canAttack())
		{
			return true;
		}
		if (enemyUnit.isBarbCoExist() && isHominid() || enemyUnit.isHominid() && isBarbCoExist())
		{
			return true;
		}

		if (enemyUnit.isInvisible(getTeam(), false, false) && enemyUnit.isOnlyDefensive() || isInvisible(enemyUnit.getTeam(), false, false) && isOnlyDefensive())
		{
			return true;
		}

		if (GC.getGame().isOption(GAMEOPTION_COMBAT_AMNESTY))
		{
			const bool bBorderValid =
				GET_TEAM(getTeam()).isOpenBorders(enemyUnit.getTeam())
				||
				GET_TEAM(getTeam()).isLimitedBorders(enemyUnit.getTeam());

			if (bBorderValid)
			{
				if (plot()->getOwner() == getOwner() && isHiddenNationality())
				{
					if (!enemyUnit.canAttack() || enemyUnit.isPassage())
					{
						return true;
					}
				}
				else if (plot()->getOwner() == enemyUnit.getOwner() && enemyUnit.isHiddenNationality())
				{
					if (!canAttack() || isPassage())
					{
						return true;
					}
				}
			}
		}

		if (plot()->isCity(false) && (isBlendIntoCity() || enemyUnit.isBlendIntoCity()))
		{
			return true;
		}
	}

	// if is loaded and is not attacking
	if (isCargo()
	&& !getGroup()->IsSelected()
	&&  plot()->isWater() == enemyUnit.plot()->isWater()
	||
		enemyUnit.isCargo()
	&& !enemyUnit.getGroup()->IsSelected()
	&&  plot()->isWater() == enemyUnit.plot()->isWater())
	{
		// May be oversimplified still
		//	If I move a transport and drop off units on land,
		//	the units aren't selected when they are checked to see if they can make this move without an attack.
		//	So this makes for a free overlapping beachhead maneuver somehow, if disembarking,
		//	it must still consider the unit incapable of automatically being able to share the space being moved to with enemies.
		//	Check the autodisembarking code for the right filter checks perhaps...
		return true;
	}
	return false;
}


/*DllExport*/ bool CvUnit::isFighting() const
{
#ifdef _DEBUG
	OutputDebugString("exe is asking if this unit is in battle\n");
#endif
	return getUnit(m_combatUnit) != NULL;
}

// Toffer - Same as isFighting.
bool CvUnit::isInBattle() const
{
	return getCombatUnit() != NULL;
}


bool CvUnit::isAttacking() const
{
	return getAttackPlot() && !isDelayedDeath();
}


bool CvUnit::isDefending() const
{
	return isInBattle() && !isAttacking();
}


bool CvUnit::isCombat() const
{
	return isInBattle() || isAttacking();
}

int CvUnit::withdrawalHP(int iMaxHitPoints, int iAttackerEarly) const
{
	return iMaxHitPoints * (100-iAttackerEarly) / 100;
}


/*DllExport*/ int CvUnit::maxHitPoints() const
{
#ifdef _DEBUG
	OutputDebugString("exe enquiring about unit max HP\n");
#endif
	return getMaxHP();
}


int CvUnit::getHP()	const
{
	return (AI_getPredictedHitPoints() == -1 ? getMaxHP() - getDamage() : AI_getPredictedHitPoints());
}


bool CvUnit::isHurt() const
{
	return (getDamage() > 0);
}


bool CvUnit::isDead() const
{
	return isDelayedDeath() || (getDamage() >= getMaxHP());
}


void CvUnit::setBaseCombatStr(int iCombat)
{
	m_iBaseCombat = iCombat;
}

int CvUnit::baseCombatStr() const
{
	return GC.getGame().isOption(GAMEOPTION_COMBAT_SIZE_MATTERS) ? getSMStrength() : baseCombatStrPreCheck();
}

int CvUnit::baseCombatStrNonGranular() const
{
	if (GC.getGame().isOption(GAMEOPTION_COMBAT_SIZE_MATTERS))
	{
		return baseCombatStr() / 100;
	}
	return baseCombatStr();
}

int CvUnit::airBaseCombatStr() const
{
	if (GC.getGame().isOption(GAMEOPTION_COMBAT_SIZE_MATTERS))
	{
		return getSMStrength();
	}
	return baseAirCombatStrPreCheck();
}

int CvUnit::baseCombatStrPreCheck() const
{
	int iStr = m_iBaseCombat + getExtraStrength();

	if (iStr < 0)
	{
		return 0;
	}
	if (GC.getGame().isOption(GAMEOPTION_COMBAT_SIZE_MATTERS))
	{
		iStr *= 100;
	}
	if (getExtraStrengthModifier() != 0)
	{
		iStr *= 100 + getExtraStrengthModifier();
		iStr /= 100;
	}
	return iStr;
}

int CvUnit::baseAirCombatStrPreCheck() const
{
	int iStr = m_pUnitInfo->getAirCombat() + getExtraStrength();

	if (iStr < 0)
	{
		return 0;
	}
	if (GC.getGame().isOption(GAMEOPTION_COMBAT_SIZE_MATTERS))
	{
		iStr *= 100;
	}
	if (getExtraStrengthModifier() != 0)
	{
		iStr *= 100 + getExtraStrengthModifier();
		iStr /= 100;
	}
	return iStr;
}

int CvUnit::getExtraStrength() const
{
	return m_iExtraStrength;
}

void CvUnit::changeExtraStrength(int iChange)
{
	m_iExtraStrength += iChange;
	FASSERT_NOT_NEGATIVE(m_iExtraStrength);
}

int CvUnit::getSMStrength() const
{
	return m_iSMStrength;
}

void CvUnit::setSMStrength()
{
	const int iStrength = getDomainType() == DOMAIN_AIR? baseAirCombatStrPreCheck() : baseCombatStrPreCheck();
	m_iSMStrength = applySMRank(iStrength, getSizeMattersOffsetValue(), GC.getSIZE_MATTERS_MOST_MULTIPLIER());
	FASSERT_NOT_NEGATIVE(m_iSMStrength);
}

float CvUnit::fbaseCombatStr() const
{
	return (float)baseCombatStr()/100;
}

float CvUnit::fairBaseCombatStr() const
{
	return (float)airBaseCombatStr()/100;
}

struct CombatStrCacheEntry
{
	int	iLRUIndex;
	int iResult;
	const CvPlot* pPlot;
	const CvPlot* pAttackedPlot;
	const CvUnit* pAttacker;
	const CvUnit* pForUnit;
};

#define	COMBATSTR_CACHE_SIZE	100
static CombatStrCacheEntry CombatStrCache[COMBATSTR_CACHE_SIZE];
static int CombatStrCacheInitializedTurn = -1;
static int iNextCombatCacheLRU = 1;

static void FlushCombatStrCache(CvUnit* pMovingUnit)
{
	PROFILE_EXTRA_FUNC();
	if ( pMovingUnit == NULL || pMovingUnit->isCommander() || pMovingUnit->isCommodore())
	{
		memset(CombatStrCache, 0, sizeof(CombatStrCache));

		CombatStrCacheInitializedTurn = GC.getGame().getGameTurn();
	}
	else
	{
		for(int iI = 0; iI < COMBATSTR_CACHE_SIZE; iI++)
		{
			CombatStrCacheEntry* pEntry = &CombatStrCache[iI];

			if ( pEntry->pAttacker == pMovingUnit ||
				 pEntry->pForUnit == pMovingUnit )
			{
				pEntry->pForUnit = NULL;
				pEntry->iLRUIndex = 1;
			}
		}
	}
}

// maxCombatStr can be called in four different configurations
//		pPlot == NULL, pAttacker == NULL for combat when this is the attacker
//		pPlot valid, pAttacker valid for combat when this is the defender
/*** Dexy - Surround and Destroy START ****/
//		pPlot == NULL, pAttacker valid for combat when this is the defender, attacker is just surrounding us (then defender gets no plot defensive bonuses)
/*** Dexy - Surround and Destroy  END  ****/
//		pPlot valid, pAttacker == NULL (new case), when this is the defender, attacker unknown
//		pPlot valid, pAttacker == this (new case), when the defender is unknown, but we want to calc approx str
//			note, in this last case, it is expected pCombatDetails == NULL, it does not have to be, but some
//			values may be unexpectedly reversed in this case (iModifierTotal will be the negative sum)
/*** Dexy - Surround and Destroy START ****/
int CvUnit::maxCombatStr(const CvPlot* pPlot, const CvUnit* pAttacker, CombatDetails* pCombatDetails, bool bSurroundedModifier) const
/*** Dexy - Surround and Destroy  END  ****/
{
	PROFILE_FUNC();

	FAssertMsg(pPlot == NULL || pPlot->getTerrainType() != NO_TERRAIN, "(pPlot == NULL) || (pPlot->getTerrainType() is not expected to be equal with NO_TERRAIN)");

	// Dexy - handle our new special case
	const CvPlot* pAttackedPlot = NULL; // Toffer - Hmm, feels so wrong to establish this as a const when it is changed below.
	bool bAttackingUnknownDefender = false;
	if (pAttacker == this)
	{
		bAttackingUnknownDefender = true;
		bSurroundedModifier = false;
		pAttackedPlot = pPlot;

		// Dexy - reset these values, we will fiddle with them below
		pPlot = NULL;
		pAttacker = NULL;
	}
	// Dexy - otherwise, attack plot is the plot of us (the defender)
	else if (pAttacker != NULL)
	{
		pAttackedPlot = plot();
	}

	CombatStrCacheEntry* pCacheEntry = NULL;
	const CvUnit* pOriginalAttacker = pAttacker;
	const int iBaseCombatStr = baseCombatStr();

	if (pCombatDetails != NULL)
	{
		pCombatDetails->iExtraCombatPercent = 0;
		pCombatDetails->iAnimalCombatModifierTA = 0;
		pCombatDetails->iAIAnimalCombatModifierTA = 0;
		pCombatDetails->iAnimalCombatModifierAA = 0;
		pCombatDetails->iAIAnimalCombatModifierAA = 0;
		pCombatDetails->iBarbarianCombatModifierTB = 0;
		pCombatDetails->iAIBarbarianCombatModifierTB = 0;
		pCombatDetails->iBarbarianCombatModifierAB = 0;
		pCombatDetails->iAIBarbarianCombatModifierAB = 0;
		pCombatDetails->iPlotDefenseModifier = 0;
		pCombatDetails->iFortifyModifier = 0;
		pCombatDetails->iCityDefenseModifier = 0;
		pCombatDetails->iHillsAttackModifier = 0;
		pCombatDetails->iHillsDefenseModifier = 0;
		pCombatDetails->iFeatureAttackModifier = 0;
		pCombatDetails->iFeatureDefenseModifier = 0;
		pCombatDetails->iTerrainAttackModifier = 0;
		pCombatDetails->iTerrainDefenseModifier = 0;
		pCombatDetails->iCityAttackModifier = 0;
		pCombatDetails->iDomainDefenseModifier = 0;
		pCombatDetails->iCityBarbarianDefenseModifier = 0;
		pCombatDetails->iDefenseModifier = 0;
		pCombatDetails->iAttackModifier = 0;
		pCombatDetails->iCombatModifierA = 0;
		pCombatDetails->iCombatModifierT = 0;
		pCombatDetails->iDomainModifierA = 0;
		pCombatDetails->iDomainModifierT = 0;
		pCombatDetails->iAnimalCombatModifierA = 0;
		pCombatDetails->iAnimalCombatModifierT = 0;
		pCombatDetails->iRiverAttackModifier = 0;
		pCombatDetails->iAmphibAttackModifier = 0;
		pCombatDetails->iKamikazeModifier = 0;
		pCombatDetails->iModifierTotal = 0;
		pCombatDetails->iBaseCombatStr = 0;
		pCombatDetails->iCombat = 0;
		pCombatDetails->iMaxCombatStr = 0;
		pCombatDetails->iCurrHitPoints = 0;
		pCombatDetails->iMaxHitPoints = 0;
		pCombatDetails->iCurrCombatStr = 0;
		pCombatDetails->eOwner = getOwner();
		pCombatDetails->eVisualOwner = getVisualOwner();
		pCombatDetails->sUnitName = getName().GetCString();
	}
	else if (iBaseCombatStr == 0)
	{
		return 0;
	}
	else if (bSurroundedModifier
	// And doesn't involve a human player
	&& !GET_PLAYER(getOwner()).isHumanPlayer()
	&& (pAttacker == NULL || !GET_PLAYER(pAttacker->getOwner()).isHumanPlayer()))
	{
		PROFILE("maxCombatStr.Cachable");

		if (CombatStrCacheInitializedTurn != GC.getGame().getGameTurn())
		{
			FlushCombatStrCache(NULL);
		}

		int	iBestLRU = MAX_INT;

		for (int iI = 0; iI < COMBATSTR_CACHE_SIZE; iI++)
		{
			CombatStrCacheEntry* pEntry = &CombatStrCache[iI];

			if (pEntry->iLRUIndex == 0)
			{
				pCacheEntry = pEntry;
				break;
			}
			if (pEntry->pPlot == pPlot && pEntry->pAttackedPlot == pAttackedPlot && pEntry->pAttacker == pOriginalAttacker && pEntry->pForUnit == this)
			{
				//OutputDebugString("maxCombatStr.CachHit\n");
				PROFILE("maxCombatStr.CachHit");
				pEntry->iLRUIndex = iNextCombatCacheLRU++;
				//TB overflow fix
				if (GC.getGame().isOption(GAMEOPTION_COMBAT_SIZE_MATTERS))
				{
					return pEntry->iResult / 100;
				}
				return pEntry->iResult;
			}
			if (pEntry->iLRUIndex < iBestLRU)
			{
				iBestLRU = pEntry->iLRUIndex;
				pCacheEntry = pEntry;
			}
		}
	}

	int iExtraModifier = getExtraCombatPercent();
	int iModifier = iExtraModifier;
	if (pCombatDetails != NULL)
	{
		pCombatDetails->iExtraCombatPercent = iExtraModifier;
	}

	// Do modifiers for animals and barbarians (leaving these out for bAttackingUnknownDefender case)
	if (pAttacker != NULL)
	{
		if (isAnimal())
		{
			if (pAttacker->isHuman())
			{
				iExtraModifier = GC.getHandicapInfo(GC.getGame().getHandicapType()).getAnimalCombatModifier();
				iModifier += iExtraModifier;
				if (pCombatDetails != NULL)
				{
					pCombatDetails->iAnimalCombatModifierTA = iExtraModifier;
				}
			}
			else
			{
				iExtraModifier = GC.getHandicapInfo(GC.getGame().getHandicapType()).getAIAnimalCombatModifier();
				iModifier += iExtraModifier;
				if (pCombatDetails != NULL)
				{
					pCombatDetails->iAIAnimalCombatModifierTA = iExtraModifier;
				}
			}
		}

		if (pAttacker->isAnimal())
		{
			if (isHuman())
			{
				iExtraModifier = -GC.getHandicapInfo(GC.getGame().getHandicapType()).getAnimalCombatModifier();
				iModifier += iExtraModifier;
				if (pCombatDetails != NULL)
				{
					pCombatDetails->iAnimalCombatModifierAA = iExtraModifier;
				}
			}
			else
			{
				iExtraModifier = -GC.getHandicapInfo(GC.getGame().getHandicapType()).getAIAnimalCombatModifier();
				iModifier += iExtraModifier;
				if (pCombatDetails != NULL)
				{
					pCombatDetails->iAIAnimalCombatModifierAA = iExtraModifier;
				}
			}
		}

		if (isHominid())
		{
			//TB Combat Mods Begin
			if (pAttacker->isHuman())
			{
				iExtraModifier = GC.getHandicapInfo(GC.getGame().getHandicapType()).getBarbarianCombatModifier() - pAttacker->vsBarbsModifier();
				iModifier += iExtraModifier;
				if (pCombatDetails != NULL)
				{
					pCombatDetails->iBarbarianCombatModifierTB = iExtraModifier;
				}
			}
			else
			{
				iExtraModifier = GC.getHandicapInfo(GC.getGame().getHandicapType()).getAIBarbarianCombatModifier() - pAttacker->vsBarbsModifier();
				iModifier += iExtraModifier;
				if (pCombatDetails != NULL)
				{
					pCombatDetails->iAIBarbarianCombatModifierTB = iExtraModifier;
				}
			}
		}

		if (pAttacker->isHominid())
		{
			const int iBarbsMod = vsBarbsModifier();

			if (isHuman())
			{
				iExtraModifier = -GC.getHandicapInfo(GC.getGame().getHandicapType()).getBarbarianCombatModifier();
				iModifier += (iExtraModifier + iBarbsMod);
				if (pCombatDetails != NULL)
				{
					pCombatDetails->iBarbarianCombatModifierAB = (iExtraModifier + iBarbsMod);
				}
			}
			else
			{
				iExtraModifier = -GC.getHandicapInfo(GC.getGame().getHandicapType()).getAIBarbarianCombatModifier();
				iModifier += (iExtraModifier + iBarbsMod);
				if (pCombatDetails != NULL)
				{
					pCombatDetails->iAIBarbarianCombatModifierTB = (iExtraModifier + iBarbsMod);
				}
			}
		}
	}

	// add defensive bonuses (leaving these out for bAttackingUnknownDefender case)
	if (pPlot != NULL)
	{
		if (!noDefensiveBonus())
		{
			// When pAttacker is NULL but pPlot is not, this is a computation for this units defensive value
			// against an unknown attacker.  Always ignoring building defense in this case is a conservative estimate,
			// but causes AI to suicide against castle walls of low culture cities in early game.  Using this units
			// ignoreBuildingDefense does a little better ... in early game it corrects undervalue of castles.  One
			// downside is when medieval unit is defending a walled city against gunpowder.  Here, the over value
			// makes attacker a little more cautious, but with their tech lead it shouldn't matter too much.  Also
			// makes vulnerable units (ships, etc) feel safer in this case and potentially not leave, but ships
			// leave when ratio is pretty low anyway.
			iExtraModifier = pPlot->defenseModifier(getTeam(), (pAttacker != NULL) ? pAttacker->ignoreBuildingDefense() : ignoreBuildingDefense());

			iModifier += iExtraModifier;
			if (pCombatDetails != NULL)
			{
				pCombatDetails->iPlotDefenseModifier = iExtraModifier;
			}
		}
		//TB Combat Mods (fortification)
		int iFort = fortifyModifier();
		int iOverrun = ((pAttacker != NULL) ? pAttacker->overrunTotal() : 0);
		int iOverrunzero = ((iOverrun < 0) ? 0 : iOverrun);
		int iOverruntotal = ((iOverrunzero > 100) ? 100 : iOverrunzero);
		int iFortModTotal = ((iFort * (100 - iOverruntotal))/100);

		iExtraModifier = iFortModTotal;
		iModifier += iExtraModifier;
		if (pCombatDetails != NULL)
		{
			pCombatDetails->iFortifyModifier = iExtraModifier;
		}

		if (pPlot->isCity(true, getTeam()))
		{
			if (pAttacker && pAttacker->plot() != pPlot)
			{
				iExtraModifier = cityDefenseModifier() + cityDefenseVSOpponent(pAttacker);

				if (pPlot->isCity())
				{
					//TB SubCombat Mod Begin
					for (std::map<UnitCombatTypes, UnitCombatKeyedInfo>::const_iterator it = m_unitCombatKeyedInfo.begin(), end = m_unitCombatKeyedInfo.end(); it != end; ++it)
					{
						if (it->second.m_bHasUnitCombat)
						{
							iExtraModifier += pPlot->getPlotCity()->getUnitCombatExtraStrength(it->first);
						}
					}
					//TB SubCombat Mod End
				}
			}

			iModifier += iExtraModifier;
			if (pCombatDetails != NULL)
			{
				pCombatDetails->iCityDefenseModifier = iExtraModifier;
			}

		}

		if (pPlot->isHills())
		{
			iExtraModifier = hillsDefenseModifier();
			iModifier += iExtraModifier;
			if (pCombatDetails != NULL)
			{
				pCombatDetails->iHillsDefenseModifier = iExtraModifier;
			}
		}

		if (pPlot->getFeatureType() != NO_FEATURE)
		{
			iExtraModifier = featureDefenseModifier(pPlot->getFeatureType());
			iModifier += iExtraModifier;
			if (pCombatDetails != NULL)
			{
				pCombatDetails->iFeatureDefenseModifier = iExtraModifier;
			}
		}

		iExtraModifier = terrainDefenseModifier(pPlot->getTerrainType());
		iModifier += iExtraModifier;
		if (pCombatDetails != NULL)
		{
			pCombatDetails->iTerrainDefenseModifier = iExtraModifier;
		}
	}

	// if we are attacking to an plot with an unknown defender, the calc the modifier in reverse
	if (bAttackingUnknownDefender)
	{
		pAttacker = this;
	}

	// calc attacker bonueses
	if (pAttacker != NULL && pAttackedPlot != NULL)
	{
		int iTempModifier = 0;

		if (pAttacker->plot() == pAttackedPlot || pAttacker->isInvisible(getTeam(), false, false) || (isRevealed() && getDefenseCount() <= 1))
		{
			iExtraModifier = -pAttacker->stealthCombatModifierTotal();
			iTempModifier += iExtraModifier;
			if (pCombatDetails != NULL)
			{
				pCombatDetails->iExtraCombatPercent += iExtraModifier;
			}

			if (!pAttacker->isInvisible(getTeam(), false, false))
			{
				iExtraModifier = stealthCombatModifierTotal();
				iTempModifier += iExtraModifier;
				{
					if (pCombatDetails != NULL)
					{
						pCombatDetails->iExtraCombatPercent += iExtraModifier;
					}
				}
			}
		}

		if (pAttackedPlot->isCity(true, getTeam()) && pAttacker->plot() != pPlot)
		{
			iExtraModifier = -pAttacker->cityAttackModifier();
			iTempModifier += iExtraModifier;
			if (pCombatDetails != NULL)
			{
				pCombatDetails->iCityAttackModifier = iExtraModifier;
			}

			if (pAttacker->isHominid())
			{
				iExtraModifier = GC.getCITY_BARBARIAN_DEFENSE_MODIFIER();
				iTempModifier += iExtraModifier;
				if (pCombatDetails != NULL)
				{
					pCombatDetails->iCityBarbarianDefenseModifier = iExtraModifier;
				}
			}
		}

		if (pAttackedPlot->isHills())
		{
			iExtraModifier = -pAttacker->hillsAttackModifier();
			iTempModifier += iExtraModifier;
			if (pCombatDetails != NULL)
			{
				pCombatDetails->iHillsAttackModifier = iExtraModifier;
			}
		}

		if (pAttackedPlot->getFeatureType() != NO_FEATURE)
		{
			iExtraModifier = -pAttacker->featureAttackModifier(pAttackedPlot->getFeatureType());
			iTempModifier += iExtraModifier;
			if (pCombatDetails != NULL)
			{
				pCombatDetails->iFeatureAttackModifier = iExtraModifier;
			}
		}
		else
		{
			iExtraModifier = -pAttacker->terrainAttackModifier(pAttackedPlot->getTerrainType());
			/*** Dexy - Others' bug fixes START ****/
			iTempModifier += iExtraModifier;
			// OLD CODE
			// iModifier += iExtraModifier;
			/*** Dexy - Others' bug fixes  END  ****/
			if (pCombatDetails != NULL)
			{
				pCombatDetails->iTerrainAttackModifier = iExtraModifier;
			}
		}

		// only compute comparisons if we are the defender with a known attacker
		if (!bAttackingUnknownDefender)
		{
			FAssertMsg(pAttacker != this, "pAttacker is not expected to be equal with this");

			iExtraModifier = unitDefenseModifier(pAttacker->getUnitType());
			iTempModifier += iExtraModifier;
			if (pCombatDetails != NULL)
			{
				pCombatDetails->iDefenseModifier = iExtraModifier;
			}

			iExtraModifier = -pAttacker->unitAttackModifier(getUnitType());
			iTempModifier += iExtraModifier;
			if (pCombatDetails != NULL)
			{
				pCombatDetails->iAttackModifier = iExtraModifier;
			}

			iExtraModifier = religiousCombatModifierTotal(pAttacker->getReligion());
			iTempModifier += iExtraModifier;
			if (pCombatDetails != NULL)
			{
				pCombatDetails->iExtraCombatPercent += iExtraModifier;
			}

			iExtraModifier = -pAttacker->religiousCombatModifierTotal(getReligion());
			iTempModifier += iExtraModifier;
			if (pCombatDetails != NULL)
			{
				pCombatDetails->iExtraCombatPercent += iExtraModifier;
			}

			iExtraModifier = 0;
			//TB SubCombat Mod Begin
			for (std::map<UnitCombatTypes, UnitCombatKeyedInfo>::const_iterator it = pAttacker->m_unitCombatKeyedInfo.begin(), end = pAttacker->m_unitCombatKeyedInfo.end(); it != end; ++it)
			{
				if(it->second.m_bHasUnitCombat)
				{
					iExtraModifier += unitCombatModifier(it->first);
				}
			}

			iTempModifier += iExtraModifier;
			if (pCombatDetails != NULL)
			{
				pCombatDetails->iCombatModifierA = iExtraModifier;
			}

			iExtraModifier = 0;
			//TB SubCombat Mod Begin
			for (std::map<UnitCombatTypes, UnitCombatKeyedInfo>::const_iterator it = m_unitCombatKeyedInfo.begin(), end = m_unitCombatKeyedInfo.end(); it != end; ++it)
			{
				if(it->second.m_bHasUnitCombat)
				{
					iExtraModifier -= pAttacker->unitCombatModifier(it->first);
				}
			}
			//TB SubCombat Mod End
			iTempModifier += iExtraModifier;
			if (pCombatDetails != NULL)
			{
				pCombatDetails->iCombatModifierT = iExtraModifier;
			}

			iExtraModifier = domainModifier(pAttacker->getDomainType());
			iTempModifier += iExtraModifier;
			if (pCombatDetails != NULL)
			{
				pCombatDetails->iDomainModifierA = iExtraModifier;
			}

			iExtraModifier = -pAttacker->domainModifier(getDomainType());
			iTempModifier += iExtraModifier;
			if (pCombatDetails != NULL)
			{
				pCombatDetails->iDomainModifierT = iExtraModifier;
			}

			if (pAttacker->isAnimal())
			{
				iExtraModifier = animalCombatModifier();
				iTempModifier += iExtraModifier;
				if (pCombatDetails != NULL)
				{
					pCombatDetails->iAnimalCombatModifierA = iExtraModifier;
				}
			}

			if (isAnimal())
			{
				iExtraModifier = -pAttacker->animalCombatModifier();
				iTempModifier += iExtraModifier;
				if (pCombatDetails != NULL)
				{
					pCombatDetails->iAnimalCombatModifierT = iExtraModifier;
				}
			}
		}

		if (!(pAttacker->isRiver()))
		{
			if (pAttacker->plot()->isRiverCrossing(directionXY(pAttacker->plot(), pAttackedPlot)))
			{
				CvCity* pCity = pAttackedPlot->getPlotCity();

				if (pCity != NULL && pAttackedPlot->isCity(true, getTeam()))
				{
					iExtraModifier = std::min(0,(pCity->getExtraRiverDefensePenalty() - GC.getRIVER_ATTACK_MODIFIER()));
				}
				else
				{
					iExtraModifier = -GC.getRIVER_ATTACK_MODIFIER();
				}
				iTempModifier += iExtraModifier;
				if (pCombatDetails != NULL)
				{
					pCombatDetails->iRiverAttackModifier = iExtraModifier;
				}
			}
		}

		if (!pAttacker->isAmphib() && !pAttackedPlot->isWater() && pAttacker->plot()->isWater())
		{
			iExtraModifier = -GC.getAMPHIB_ATTACK_MODIFIER();
			iTempModifier += iExtraModifier;
			if (pCombatDetails != NULL)
			{
				pCombatDetails->iAmphibAttackModifier = iExtraModifier;
			}
		}

		if (pAttacker->getKamikazePercent() != 0)
		{
			iExtraModifier = -pAttacker->getKamikazePercent();
			iTempModifier += iExtraModifier;
			if (pCombatDetails != NULL)
			{
				pCombatDetails->iKamikazeModifier = iExtraModifier;
			}
		}

		if (bSurroundedModifier && pAttacker != this /* (pAttacker != this) != bAttackingUnknownDefender */)
		{
			// the stronger the surroundings -> decrease the iModifier more
			//TB Combat Mods (S&D promos) begin
			const int iSurround = pAttacker->surroundedDefenseModifier(pAttackedPlot, this);
			iTempModifier -= std::max(0, iSurround - iSurround * dynamicDefenseTotal() / 100);
			//TB Combat Mods (S&D promos) end
		}

		//TB Combat Mods (StrAdjperAtt) begin
		if (pAttacker->currentStrAdjperAttTotal() != 0)
		{
			iExtraModifier = -(pAttacker->currentStrAdjperAttTotal());
			iTempModifier += iExtraModifier;
		}

		if (currentStrAdjperDefTotal() != 0)
		{
			iExtraModifier = currentStrAdjperDefTotal();
			iTempModifier += iExtraModifier;
		}

		if (pAttacker->attackCombatModifierTotal() != 0)
		{
			iExtraModifier = -pAttacker->attackCombatModifierTotal();
			iTempModifier += iExtraModifier;
			if (pCombatDetails != NULL)
			{
				pCombatDetails->iExtraCombatPercent += iExtraModifier;
			}
		}

		if (defenseCombatModifierTotal() != 0)
		{
			iExtraModifier = defenseCombatModifierTotal();
			iTempModifier += iExtraModifier;
			if (pCombatDetails != NULL)
			{
				pCombatDetails->iExtraCombatPercent += iExtraModifier;
			}
		}

		//Defender's bonus from size diff (more)
		int iOffset = 0;
		int iPerTotal = 0;
		iOffset = pAttacker->sizeRank() - sizeRank();
		if (combatModifierPerSizeMoreTotal() != 0 && iOffset > 0)
		{
			iPerTotal = combatModifierPerSizeMoreTotal() * iOffset;
			iExtraModifier = iPerTotal;
			iTempModifier += iExtraModifier;
			if (pCombatDetails != NULL)
			{
				pCombatDetails->iExtraCombatPercent += iExtraModifier;
			}
		}
		//Attacker's bonus from size diff (more)
		iOffset = 0;
		iPerTotal = 0;
		iOffset = sizeRank() - pAttacker->sizeRank();
		if (pAttacker->combatModifierPerSizeMoreTotal() != 0 && iOffset > 0)
		{
			iPerTotal = pAttacker->combatModifierPerSizeMoreTotal() * iOffset;
			iExtraModifier = -iPerTotal;
			iTempModifier += iExtraModifier;
			if (pCombatDetails != NULL)
			{
				pCombatDetails->iExtraCombatPercent += iExtraModifier;
			}
		}

		//Defender's bonus from volume diff (more)
		iOffset = 0;
		iPerTotal = 0;
		iOffset = pAttacker->groupRank() - groupRank();
		if (combatModifierPerVolumeMoreTotal() != 0 && iOffset > 0)
		{
			iPerTotal = combatModifierPerVolumeMoreTotal() * iOffset;
			iExtraModifier = iPerTotal;
			iTempModifier += iExtraModifier;
			if (pCombatDetails != NULL)
			{
				pCombatDetails->iExtraCombatPercent += iExtraModifier;
			}
		}
		//Attacker's bonus from volume diff (more)
		iOffset = 0;
		iPerTotal = 0;
		iOffset = groupRank() - pAttacker->groupRank();
		if (pAttacker->combatModifierPerVolumeMoreTotal() != 0 && iOffset > 0)
		{
			iPerTotal = pAttacker->combatModifierPerVolumeMoreTotal() * iOffset;
			iExtraModifier = -iPerTotal;
			iTempModifier += iExtraModifier;
			if (pCombatDetails != NULL)
			{
				pCombatDetails->iExtraCombatPercent += iExtraModifier;
			}
		}

		//Defender's bonus from size diff (Less)
		iOffset = 0;
		iPerTotal = 0;
		iOffset = pAttacker->sizeRank() - sizeRank();
		if (combatModifierPerSizeLessTotal() != 0 && iOffset < 0)
		{
			iPerTotal = combatModifierPerSizeLessTotal() * -iOffset;
			iExtraModifier = iPerTotal;
			iTempModifier += iExtraModifier;
			if (pCombatDetails != NULL)
			{
				pCombatDetails->iExtraCombatPercent += iExtraModifier;
			}
		}
		//Attacker's bonus from size diff (Less)
		iOffset = 0;
		iPerTotal = 0;
		iOffset = sizeRank() - pAttacker->sizeRank();
		if (pAttacker->combatModifierPerSizeLessTotal() != 0 && iOffset < 0)
		{
			iPerTotal = pAttacker->combatModifierPerSizeLessTotal() * -iOffset;
			iExtraModifier = -iPerTotal;
			iTempModifier += iExtraModifier;
			if (pCombatDetails != NULL)
			{
				pCombatDetails->iExtraCombatPercent += iExtraModifier;
			}
		}

		//Defender's bonus from volume diff (Less)
		iOffset = 0;
		iPerTotal = 0;
		iOffset = pAttacker->groupRank() - groupRank();
		if (combatModifierPerVolumeLessTotal() != 0 && iOffset < 0)
		{
			iPerTotal = combatModifierPerVolumeLessTotal() * -iOffset;
			iExtraModifier = iPerTotal;
			iTempModifier += iExtraModifier;
			if (pCombatDetails != NULL)
			{
				pCombatDetails->iExtraCombatPercent += iExtraModifier;
			}
		}
		//Attacker's bonus from volume diff (Less)
		iOffset = 0;
		iPerTotal = 0;
		iOffset = groupRank() - pAttacker->groupRank();
		if (pAttacker->combatModifierPerVolumeLessTotal() != 0 && iOffset < 0)
		{
			iPerTotal = pAttacker->combatModifierPerVolumeLessTotal() * -iOffset;
			iExtraModifier = -iPerTotal;
			iTempModifier += iExtraModifier;
			if (pCombatDetails != NULL)
			{
				pCombatDetails->iExtraCombatPercent += iExtraModifier;
			}
		}
		//TB Combat Mods (StrAdjperAtt) end
		// if we are attacking an unknown defender, then use the reverse of the modifier
		if (bAttackingUnknownDefender)
		{
			iModifier -= iTempModifier;
		}
		else
		{
			iModifier += iTempModifier;
		}
	}

	if (pCombatDetails != NULL)
	{
		pCombatDetails->iModifierTotal = iModifier;
		pCombatDetails->iBaseCombatStr = iBaseCombatStr;
	}
	const int iCombat = iBaseCombatStr * (iModifier > 0 ? iModifier + 100 : 10000 / (100 - iModifier));

	if (pCombatDetails != NULL)
	{
		pCombatDetails->iCombat = iCombat;
		pCombatDetails->iMaxCombatStr = std::max(1, iCombat);
		pCombatDetails->iCurrHitPoints = getHP();
		pCombatDetails->iMaxHitPoints = getMaxHP();
		pCombatDetails->iCurrCombatStr = ((pCombatDetails->iMaxCombatStr * pCombatDetails->iCurrHitPoints) / pCombatDetails->iMaxHitPoints);
	}

	if (pCacheEntry != NULL)
	{
		pCacheEntry->iLRUIndex = iNextCombatCacheLRU++;
		pCacheEntry->iResult = std::max(1, iCombat);
		pCacheEntry->pPlot = pPlot;
		pCacheEntry->pAttackedPlot = pAttackedPlot;
		pCacheEntry->pAttacker = pOriginalAttacker;
		pCacheEntry->pForUnit = this;
	}
	if (GC.getGame().isOption(GAMEOPTION_COMBAT_SIZE_MATTERS))
	{
		return std::max(1, iCombat / 100);
	}
	return std::max(1, iCombat);
}


int CvUnit::currCombatStr(const CvPlot* pPlot, const CvUnit* pAttacker, CombatDetails* pCombatDetails, bool bSurroundedModifier) const
{
	const int iMaxStr = maxCombatStr(pPlot, pAttacker, pCombatDetails, bSurroundedModifier);

	return iMaxStr * getHP() / getMaxHP() + (iMaxStr * getHP() / getMaxHP()) * currentStrAdjperRndTotal() / 100;
}


int CvUnit::currFirepower(const CvPlot* pPlot, const CvUnit* pAttacker) const
{
	return (maxCombatStr(pPlot, pAttacker) + currCombatStr(pPlot, pAttacker) + 1) / 2;
}

// this normalizes str by firepower, useful for quick odds calcs
// the effect is that a damaged unit will have an effective str lowered by firepower/maxFirepower
// doing the algebra, this means we mulitply by 1/2(1 + currHP)/maxHP = (maxHP + currHP) / (2 * maxHP)
int CvUnit::currEffectiveStr(const CvPlot* pPlot, const CvUnit* pAttacker, CombatDetails* pCombatDetails) const
{
	int currStr = currCombatStr(pPlot, pAttacker, pCombatDetails);

	currStr *= getMaxHP() + getHP();
	currStr /= 2 * getMaxHP();

	return currStr;
}

float CvUnit::maxCombatStrFloat(const CvPlot* pPlot, const CvUnit* pAttacker) const
{
	return maxCombatStr(pPlot, pAttacker) / 100.0f;
}


float CvUnit::currCombatStrFloat(const CvPlot* pPlot, const CvUnit* pAttacker) const
{
	return currCombatStr(pPlot, pAttacker) / 100.0f;
}


bool CvUnit::canFight() const
{
	return m_iBaseCombat > 0; // Don't bother calculating modifiers for this call
}

bool CvUnit::canAttackNow() const
{
	return canAttack() && (!isMadeAttack() || isBlitz());
}

bool CvUnit::canAttack() const
{
	return canFight() && !isOnlyDefensive();
}

bool CvUnit::canAttack(const CvUnit& defender) const
{
	if (!canAttack() || getOwner() == defender.getOwner())
	{
		return false;
	}
	if (defender.canCoexistWithAttacker(*this))
	{
		return false;
	}
	// Combat limit reached; breakdown combat can proceed even at combat limit.
	if (defender.getDamage() >= combatLimit() * defender.getMaxHP() / 100 && breakdownChanceTotal() <= 0)
	{
		return false;
	}

	// Artillery can't amphibious attack
	if (plot()->isWater() && !defender.plot()->isWater() && combatLimit() < 100)
	{
		return false;
	}

	if (canAttackOnlyCities() && !defender.plot()->isCity())
	{
		return false;
	}

	//tunnel fixes
	if (defender.plot()->isWater() && defender.plot()->isSeaTunnel())
	{
		//Sea units and air units and hovering units can't be attacked by land units in tunnels (Unless the land unit is hovering)
		if ((defender.getDomainType() != DOMAIN_LAND || defender.canMoveAllTerrain()) && getDomainType() == DOMAIN_LAND && !canMoveAllTerrain())
		{
			return false;
		}

		//Non-Hovering Land units can't be attacked by sea or air units or transported units or hovering units in tunnels.
		if (defender.getDomainType() == DOMAIN_LAND && !defender.canMoveAllTerrain() && (getDomainType() != DOMAIN_LAND || isCargo() || canMoveAllTerrain()))
		{
			return false;
		}
	}

	if (defender.plot()->isCity(true) && isBlendIntoCity())
	{
		if (!isAssassin())
		{
			return false;
		}
		if (defender.plot() != plot())
		{
			return false;
		}
	}

	if (GC.getGame().isOption(GAMEOPTION_COMBAT_AMNESTY)
	&& defender.plot()->getOwner() == getOwner()
	&& isHiddenNationality()
	&& (GET_TEAM(getTeam()).isOpenBorders(defender.getTeam()) || GET_TEAM(getTeam()).isLimitedBorders(defender.getTeam()))
	&& (!defender.canAttack() || defender.isPassage()))
	{
		return false;
	}

	return true;
}

bool CvUnit::canAmbush(const CvUnit& defender, const bool bAssassinate) const
{
	if (!canAttack() || getOwner() == defender.getOwner())
	{
		return false;
	}
	// Combat limit reached; breakdown combat can proceed even at combat limit.
	if (defender.getDamage() >= combatLimit() * defender.getMaxHP() / 100 && breakdownChanceTotal() <= 0)
	{
		return false;
	}

	if (canAttackOnlyCities() && !defender.plot()->isCity())
	{
		return false;
	}

	if (defender.plot()->isCity(true) && isBlendIntoCity())
	{
		if (!isAssassin())
		{
			return false;
		}
		if (defender.plot() != plot())
		{
			return false;
		}
	}

	if (GC.getGame().isOption(GAMEOPTION_COMBAT_AMNESTY)
	&& defender.plot()->getOwner() == getOwner()
	&& isHiddenNationality()
	&& (GET_TEAM(getTeam()).isOpenBorders(defender.getTeam()) || GET_TEAM(getTeam()).isLimitedBorders(defender.getTeam()))
	&& (!defender.canAttack() || defender.isPassage()))
	{
		return false;
	}

	return true;
}


bool CvUnit::canDefend(const CvPlot* pPlot) const
{
	if (!canFight() || isTrap() || isCargo())
	{
		return false;
	}
	if (!pPlot) pPlot = plot();

	if (!pPlot->isValidDomainForAction(*this) && !GC.getLAND_UNITS_CAN_ATTACK_WATER_CITIES())
	{
		return false;
	}
	return true;
}

bool CvUnit::canStealthDefend(const CvUnit* victim) const
{
	return (
		   !isDead()
		&&  canFight()
		&&  hasStealthDefense()
		&& !isCargo()
		&&  getImmobileTimer() < 1
		&&  isInvisible(victim->getTeam(), false, false)
		&& !victim->isInvisible(getTeam(), false, false)
		&& !canCoexistWithAttacker(*victim, true)
	);
}


bool CvUnit::canSiege(TeamTypes eTeam) const
{
	if (!canDefend())
	{
		return false;
	}

	if (!isEnemy(eTeam))
	{
		return false;
	}

	if (isInvisible(eTeam, false))
	{
		return false;
	}

	if (getOwner() == PREY_PLAYER)
	{
		return false;
	}

	if (isCargo())
	{
		return false;
	}

	return true;
}


int CvUnit::airMaxCombatStr(const CvUnit* pOther) const
{
	PROFILE_EXTRA_FUNC();
	if (airBaseCombatStr() == 0)
	{
		return 0;
	}
	int iModifier = getExtraCombatPercent() + getKamikazePercent();

	if (NULL != pOther)
	{
		for (std::map<UnitCombatTypes, UnitCombatKeyedInfo>::const_iterator it = pOther->m_unitCombatKeyedInfo.begin(), end = pOther->m_unitCombatKeyedInfo.end(); it != end; ++it)
		{
			if (it->second.m_bHasUnitCombat)
			{
				iModifier += unitCombatModifier(it->first);
			}
		}

		iModifier += domainModifier(pOther->getDomainType());

		if (pOther->isAnimal())
		{
			iModifier += animalCombatModifier();
		}

		if (pOther->isHominid())
		{
			iModifier += vsBarbsModifier();
		}
	}

	return std::max(1, getModifiedIntValue(100 * airBaseCombatStr(), iModifier));
}


int CvUnit::airCurrCombatStr(const CvUnit* pOther) const
{
	return airMaxCombatStr(pOther) * getHP() / getMaxHP();
}


float CvUnit::airMaxCombatStrFloat(const CvUnit* pOther) const
{
	return (((float)(airMaxCombatStr(pOther))) / 100.0f);
}


float CvUnit::airCurrCombatStrFloat(const CvUnit* pOther) const
{
	return (((float)(airCurrCombatStr(pOther))) / 100.0f);
}


int CvUnit::combatLimit(const CvUnit* pOpponent) const
{
/*****************************************************************************************************/
/**  Author: TheLadiesOgre                                                                          **/
/**  Date: 18.09.2009                                                                               **/
/**  ModComp: TLOTags                                                                               **/
/**  Reason Added: Implement iAirCombatLimitChange                                                  **/
/**  Notes:                                                                                         **/
/*****************************************************************************************************
	return m_pUnitInfo->getCombatLimit();*/
	//return (m_pUnitInfo->getCombatLimit() + getCombatLimitChange());
/*****************************************************************************************************/
/**  TheLadiesOgre; 18.09.2009; TLOTags                                                             **/
/*****************************************************************************************************/

	int iTotal = (m_pUnitInfo->getCombatLimit() + getCombatLimitChange());
	if (pOpponent != NULL)
	{
		iTotal *= pOpponent->getMaxHP();
		iTotal /= 100;
	}
	return iTotal;
}


int CvUnit::airCombatLimit(const CvUnit* pOpponent) const
{
	int iTotal = m_pUnitInfo->getAirCombatLimit() + getAirCombatLimitChange();

	if (pOpponent)
	{
		iTotal *= pOpponent->getMaxHP();
		iTotal /= 100;
	}
	return iTotal;
}


bool CvUnit::canAirAttack() const
{
	return !isMadeAttack() && !hasMoved() && airBaseCombatStr() > 0;
}


bool CvUnit::canAirDefend(const CvPlot* pPlot) const
{
	if (!pPlot)
	{
		pPlot = plot();
	}

	if (isSpy() || maxInterceptionProbability() == 0)
	{
		return false;
	}

	if (getDomainType() != DOMAIN_AIR)
	{
		// Land units which are cargo cannot intercept
		if (!pPlot->isValidDomainForLocation(*this) || isCargo())
		{
			return false;
		}
	}
	return true;
}


int CvUnit::airCombatDamage(const CvUnit* pDefender) const
{
	const CvPlot* pPlot = pDefender->plot();

	const int iTheirStrength = pDefender->maxCombatStr(pPlot, this);
	const int iOurStrength = airCurrCombatStr(pDefender);
	FAssertMsg(iOurStrength > 0, "Air combat strength is expected to be greater than zero");

	const int iStrengthFactor = (iOurStrength + iTheirStrength + 1) / 2;

	if (pPlot->getPlotCity())
	{
		return (
			std::max(1, GC.getDefineINT("AIR_COMBAT_DAMAGE") * (iOurStrength + iStrengthFactor) / (iTheirStrength + iStrengthFactor))
			*
			std::max(0, 100 + pPlot->getPlotCity()->getAirModifier())
			/
			100
		);
	}
	return std::max(1, GC.getDefineINT("AIR_COMBAT_DAMAGE") * (iOurStrength + iStrengthFactor) / (iTheirStrength + iStrengthFactor));
}


int CvUnit::rangeCombatDamage(const CvUnit* pDefender) const
{
	const CvPlot* pPlot = pDefender->plot();

	const int iOurStrength = airCurrCombatStr(pDefender);
	FAssertMsg(iOurStrength > 0, "Combat strength is expected to be greater than zero");
	const int iTheirStrength = pDefender->maxCombatStr(pPlot, this);

	const int iStrengthFactor = ((iOurStrength + iTheirStrength + 1) / 2);

	return std::max(1, ((GC.getDefineINT("RANGE_COMBAT_DAMAGE") * (iOurStrength + iStrengthFactor)) / (iTheirStrength + iStrengthFactor)));
}


CvUnit* CvUnit::bestInterceptor(const CvPlot* pPlot) const
{
	PROFILE_EXTRA_FUNC();
	int iBestValue = 0;
	CvUnit* pBestUnit = NULL;

	for (int iI = 0; iI < MAX_PLAYERS; iI++)
	{
		if (GET_PLAYER((PlayerTypes)iI).isAlive())
		{
			if (!isInvisible(GET_PLAYER((PlayerTypes)iI).getTeam(), false, false))
			{
				foreach_(CvUnit* pLoopUnit, GET_PLAYER((PlayerTypes)iI).units())
				{
					if (pLoopUnit->canAirDefend())
					{
						if (!pLoopUnit->isMadeInterception())
						{
							if (isEnemy(GET_PLAYER((PlayerTypes)iI).getTeam(), NULL, pLoopUnit))
							{
								if ((pLoopUnit->getDomainType() != DOMAIN_AIR) || !(pLoopUnit->hasMoved()))
								{
									if ((pLoopUnit->getDomainType() != DOMAIN_AIR) || (pLoopUnit->getGroup()->getActivityType() == ACTIVITY_INTERCEPT))
									{
										if (plotDistance(pLoopUnit->getX(), pLoopUnit->getY(), pPlot->getX(), pPlot->getY()) <= pLoopUnit->airRange())
										{
											const int iValue = pLoopUnit->currInterceptionProbability();

											if (iValue > iBestValue)
											{
												iBestValue = iValue;
												pBestUnit = pLoopUnit;
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}

	return pBestUnit;
}


CvUnit* CvUnit::bestSeaPillageInterceptor(const CvUnit* pPillager, int iMinOdds) const
{
	PROFILE_EXTRA_FUNC();
	CvUnit* pBestUnit = NULL;

	foreach_(const CvPlot* pLoopPlot, pPillager->plot()->rect(1, 1))
	{
		foreach_(CvUnit* pLoopUnit, pLoopPlot->units())
		{
			if (pLoopUnit->area() == pPillager->plot()->area()
			&& !pLoopUnit->isInvisible(getTeam(), false)
			&& isEnemy(pLoopUnit->getTeam())
			&& DOMAIN_SEA == pLoopUnit->getDomainType()
			&& ACTIVITY_PATROL == pLoopUnit->getGroup()->getActivityType()
			&& (NULL == pBestUnit || pLoopUnit->isBetterDefenderThan(pBestUnit, this))
			&& getCombatOdds(pPillager, pLoopUnit) < iMinOdds)
			{
				pBestUnit = pLoopUnit;
			}
		}
	}
	return pBestUnit;
}


bool CvUnit::isAutomated() const
{
	return getGroup()->isAutomated();
}


bool CvUnit::isWaiting() const
{
	return getGroup()->isWaiting();
}


bool CvUnit::isFortifyable() const
{
	if (!canFight() || noDefensiveBonus() || ((getDomainType() != DOMAIN_LAND) && (getDomainType() != DOMAIN_IMMOBILE)))
	{
		return false;
	}

	return true;
}

bool CvUnit::isBuildUpable() const
{
	if (isDead())
	{
		return false;
	}
	return m_bHasBuildUp;
}


int CvUnit::fortifyModifier() const
{
	if (!isFortifyable())
	{
		return 0;
	}
	return range(getFortifyTurns(), 0, GC.getDefineINT("MAX_FORTIFY_TURNS")) * GC.getFORTIFY_MODIFIER_PER_TURN();
}


int CvUnit::fortifyRepelModifier() const
{
	if (!isFortifyable() || noDefensiveBonus())
	{
		return 0;
	}
	return getFortifyTurns() * fortRepelTotal();
}
//TB Combat Mods end

int CvUnit::experienceNeeded(int iLvlOffset) const
{
	int iExperienceNeeded = calcBaseExpNeeded(getLevel() + iLvlOffset, getOwner());

	if (isCommander())
	{
		iExperienceNeeded *= 3;
		iExperienceNeeded /= 2;
	}

    if (isCommodore())
	{
		iExperienceNeeded *= 3;
		iExperienceNeeded /= 2;
	}
	return iExperienceNeeded;
}


int CvUnit::attackXPValue() const
{
	return m_pUnitInfo->getXPValueAttack();
}


int CvUnit::defenseXPValue() const
{
	return m_pUnitInfo->getXPValueDefense();
}


int CvUnit::maxXPValue(const CvUnit* pVictim, bool bBarb) const
{
	if (GC.getGame().isOption(GAMEOPTION_UNIT_INFINITE_XP) || isNPC())
	{
		return -1;
	}
	int iMaxValue = -1;

	if (pVictim != NULL && pVictim->isAnimal())
	{
		if (!isHasUnitCombat(GC.getUNITCOMBAT_EXPLORER())
		&& !isHasPromotion(GC.getPROMOTION_ANIMAL_HUNTER()))
		{
			iMaxValue = GC.getANIMAL_MAX_XP_VALUE();
		}
	}
	else if (pVictim != NULL && pVictim->isHominid() || bBarb)
	{
		if (!isHasUnitCombat(GC.getUNITCOMBAT_RECON())
		&& !isHasPromotion(GC.getPROMOTION_BARBARIAN_HUNTER()))
		{
			iMaxValue = GC.getBARBARIAN_MAX_XP_VALUE();
		}
	}
	else if (pVictim != NULL && getUnitCombatType() == GC.getUNITCOMBAT_HUNTER())
	{
		if (!isHasPromotion(GC.getPROMOTION_BARBARIAN_HUNTER())
		&& pVictim->getUnitCombatType() != GC.getUNITCOMBAT_ANIMAL())
		{
			iMaxValue = GC.getBARBARIAN_MAX_XP_VALUE();
		}
	}
	if (iMaxValue > 0 && GC.getGame().isOption(GAMEOPTION_UNIT_MORE_XP_TO_LEVEL))
	{
		iMaxValue *= GC.getMORE_XP_TO_LEVEL_MODIFIER();
		iMaxValue /= 100;
	}
	return iMaxValue;
}


int CvUnit::firstStrikes() const
{
	return std::max(0, m_pUnitInfo->getFirstStrikes() + getExtraFirstStrikes());
}


int CvUnit::chanceFirstStrikes() const
{
	return std::max(0, (m_pUnitInfo->getChanceFirstStrikes() + getExtraChanceFirstStrikes()));
}


int CvUnit::maxFirstStrikes() const
{
	return (firstStrikes() + chanceFirstStrikes());
}


bool CvUnit::isRanged() const
{
	PROFILE_EXTRA_FUNC();
	const int groupDefinitions = getUnitInfo().getGroupDefinitions();
	for (int  i = 0; i < groupDefinitions; i++)
	{
		if ( !getArtInfo(i, GET_PLAYER(getOwner()).getCurrentEra())->getActAsRanged() )
		{
			return false;
		}
	}
	return true;
}


bool CvUnit::alwaysInvisible() const
{
	return m_pUnitInfo->isInvisible() || getAlwaysInvisibleCount() > 0;
}


bool CvUnit::immuneToFirstStrikes() const
{
	return (m_pUnitInfo->isFirstStrikeImmune() || (getImmuneToFirstStrikesCount() > 0));
}


bool CvUnit::noDefensiveBonus() const
{
	return m_pUnitInfo->isNoDefensiveBonus() + getExtraNoDefensiveBonusCount() > 0;
}

int CvUnit::getExtraNoDefensiveBonusCount() const
{
	return m_iExtraNoDefensiveBonusCount;
}

void CvUnit::changeExtraNoDefensiveBonusCount(int iChange)
{
	m_iExtraNoDefensiveBonusCount += iChange;
}

bool CvUnit::ignoreBuildingDefense() const
{
	return m_pUnitInfo->isIgnoreBuildingDefense();
}


bool CvUnit::canMoveImpassable() const
{
	return (m_pUnitInfo->isCanMoveImpassable() || canFliesToMove());
}

bool CvUnit::canMoveAllTerrain() const
{
	return (m_pUnitInfo->isCanMoveAllTerrain() || canFliesToMove());
}

bool CvUnit::flatMovementCost() const
{
	//soon as the pathing engine can handle it this should be uncommented.
	return (/*canFliesToMove() ||*/ m_pUnitInfo->isFlatMovementCost());
}

bool CvUnit::ignoreTerrainCost() const
{
	return (m_pUnitInfo->isIgnoreTerrainCost() || canFliesToMove());
}

bool CvUnit::isNeverInvisible() const
{
	return !alwaysInvisible() && getInvisibleType() == NO_INVISIBLE && !hasAnyInvisibilityType();
}

int CvUnit::getNoInvisibilityCount() const
{
	return GC.getGame().isOption(GAMEOPTION_COMBAT_HIDE_SEEK) * m_iNoInvisibilityCount;
}

void CvUnit::changeNoInvisibilityCount(int iChange)
{
	m_iNoInvisibilityCount += iChange;
	setHasAnyInvisibility();
}


bool CvUnit::isInvisible(TeamTypes eTeam, bool bDebug, bool bCheckCargo) const
{
	PROFILE_EXTRA_FUNC();
	if (bDebug && GC.getGame().isDebugMode())
	{
		return false;
	}

	if (getTeam() == eTeam)
	{
		return false;
	}

	if (alwaysInvisible())
	{
		return true;
	}

	if (bCheckCargo && isCargo())
	{
		return true;
	}

	if (isNeverInvisible())
	{
		return false;
	}

	if (isRevealed())
	{
		return false;
	}

	if (!GC.getGame().isOption(GAMEOPTION_COMBAT_HIDE_SEEK))
	{
		return getInvisibleType() != NO_INVISIBLE && !plot()->isSpotterInSight(eTeam, getInvisibleType());
	}

	if (hasAnyInvisibilityType())
	{
		for (int iI = GC.getNumInvisibleInfos() - 1; iI > -1; iI--)
		{
			const InvisibleTypes eInvisible = static_cast<InvisibleTypes>(iI);

			if (hasInvisibilityType(eInvisible))
			{
				if (!plot()->isSpotterInSight(eTeam, eInvisible))
				{
					return true;
				}
				const int iIntensity = invisibilityIntensityTotal(eInvisible);

				if ((iIntensity > 0 || GC.getInvisibleInfo(eInvisible).isIntrinsic())
				&& plot()->getHighestPlotTeamVisibilityIntensity(eInvisible, eTeam) < iIntensity)
				{
					return true;
				}
			}
		}
	}
	return false;
}


bool CvUnit::isNukeImmune() const
{
	return m_pUnitInfo->isNukeImmune();
}


bool CvUnit::isInquisitor() const
{
	return m_pUnitInfo->isInquisitor();
}


int CvUnit::maxInterceptionProbability(bool bIgnoreCommanders, bool bIgnoreCommodores) const
{
	return std::min(GC.getDefineINT("MAX_INTERCEPTION_PROBABILITY"),std::max(0, m_pUnitInfo->getInterceptionProbability() + getExtraIntercept(bIgnoreCommanders, bIgnoreCommodores)));
}


int CvUnit::currInterceptionProbability() const
{
	if (getDomainType() != DOMAIN_AIR && !GC.getGame().isModderGameOption(MODDERGAMEOPTION_BETTER_INTERCETION))
	{
		return maxInterceptionProbability();
	}
	return maxInterceptionProbability() * getHP() / getMaxHP();
}


int CvUnit::evasionProbability(bool bIgnoreCommanders, bool bIgnoreCommodores) const
{
	return std::min(GC.getDefineINT("MAX_EVASION_PROBABILITY"),std::max(0, m_pUnitInfo->getEvasionProbability() + getExtraEvasion(bIgnoreCommanders, bIgnoreCommodores)));
}


int CvUnit::withdrawalProbability() const
{
	const int iProbability = m_pUnitInfo->getWithdrawalProbability() + getExtraWithdrawal() /*+ escapeModifier()*/;

	if (shouldUseWithdrawalOddsCap())
	{
		return std::min(GC.getDefineINT("MAX_WITHDRAWAL_PROBABILITY"), std::max(0, iProbability));
	}
	return std::max(0, iProbability);
}
//TB Combat Mods Begin
int CvUnit::attackCombatModifierTotal() const
{
	return (m_pUnitInfo->getAttackCombatModifier() + getExtraAttackCombatModifier());
}

int CvUnit::defenseCombatModifierTotal() const
{
	if (noDefensiveBonus())
	{
		return 0;
	}

	return (m_pUnitInfo->getDefenseCombatModifier() + getExtraDefenseCombatModifier());
}

int CvUnit::pursuitProbability() const
{
	if (!GC.getGame().isOption(GAMEOPTION_COMBAT_FIGHT_OR_FLIGHT))
	{
		return 0;
	}
	if (getDomainType() == DOMAIN_LAND && plot()->isWater())
	{
		return 0;
	}
	return std::max(0, (m_pUnitInfo->getPursuit() + getExtraPursuit() + currentWithdrawAdjperAttTotal()));
}

int CvUnit::earlyWithdrawTotal() const
{
	if (!GC.getGame().isOption(GAMEOPTION_COMBAT_FIGHT_OR_FLIGHT))
	{
		return 0;
	}
	if (getDomainType() == DOMAIN_LAND && plot()->isWater())
	{
		return 0;
	}
	return std::max(0, (m_pUnitInfo->getEarlyWithdraw() + getExtraEarlyWithdraw()));
}

int CvUnit::vsBarbsModifier() const
{
	return (m_pUnitInfo->getVSBarbs() + getExtraVSBarbs());
}

int CvUnit::religiousCombatModifierTotal(ReligionTypes eReligion, bool bDisplay) const
{
	if (bDisplay || (getReligion() != NO_RELIGION))
	{
		if (bDisplay || getReligion() != eReligion)
		{
			return (m_pUnitInfo->getReligiousCombatModifier() + getExtraReligiousCombatModifier());
		}
		else if (getReligion() == eReligion)
		{
			return -(m_pUnitInfo->getReligiousCombatModifier() + getExtraReligiousCombatModifier());
		}
	}
	return 0;
}

int CvUnit::armorTotal() const
{
	return std::max(0, (m_pUnitInfo->getArmor() + getExtraArmor()));
}

int CvUnit::punctureTotal() const
{
	return std::max(0, (m_pUnitInfo->getPuncture() + getExtraPuncture()));
}

int CvUnit::damageModifierTotal() const
{
	return std::max(-95, (m_pUnitInfo->getDamageModifier() + getExtraDamageModifier()));
}

int CvUnit::costModifierTotal() const
{
	return 0;
}

int CvUnit::overrunTotal() const
{
	if (getDomainType() == DOMAIN_LAND && plot()->isWater())
	{
		return 0;
	}
	return std::max(0, (m_pUnitInfo->getOverrun() + getExtraOverrun()));
}

int CvUnit::repelTotal() const
{
	if (noDefensiveBonus() || (getDomainType() == DOMAIN_LAND && plot()->isWater()))
	{
		return 0;
	}
	return std::max(0, (m_pUnitInfo->getRepel() + getExtraRepel() + getCityRepel()));
}

int CvUnit::fortRepelTotal() const
{
	if (noDefensiveBonus() || (getDomainType() == DOMAIN_LAND && plot()->isWater()))
	{
		return 0;
	}
	return std::max(0, (m_pUnitInfo->getFortRepel() + getExtraFortRepel()));
}

int CvUnit::repelRetriesTotal() const
{
	if (noDefensiveBonus() || getDomainType() == DOMAIN_LAND && plot()->isWater())
	{
		return 0;
	}
	return std::max(0, m_pUnitInfo->getRepelRetries() + getExtraRepelRetries());
}

int CvUnit::unyieldingTotal() const
{
	if (getDomainType() == DOMAIN_LAND && plot()->isWater())
	{
		return 0;
	}
	return std::max(0, (m_pUnitInfo->getUnyielding() + getExtraUnyielding()));
}

int CvUnit::knockbackTotal() const
{
	if (getDomainType() == DOMAIN_LAND && plot()->isWater())
	{
		return 0;
	}
	return std::max(0, (m_pUnitInfo->getKnockback() + getExtraKnockback()));
}

int CvUnit::knockbackRetriesTotal() const
{
	if (getDomainType() == DOMAIN_LAND && plot()->isWater())
	{
		return 0;
	}
	return std::max(0, (m_pUnitInfo->getKnockbackRetries() + getExtraKnockbackRetries()));
}

bool CvUnit::canStampede() const
{
	return (m_pUnitInfo->isStampede() || mayStampede()) && !cannotStampede();
}

bool CvUnit::canAttackOnlyCities() const
{
	int iTrueCount = 0;

	if (m_pUnitInfo->isAttackOnlyCities())
	{
		iTrueCount++;
	}
	iTrueCount += getAttackOnlyCitiesCount();

	return iTrueCount > 0;
}

bool CvUnit::canIgnoreNoEntryLevel() const
{
	int iTrueCount = 0;

	if (m_pUnitInfo->isIgnoreNoEntryLevel())
	{
		iTrueCount++;
	}
	iTrueCount += getIgnoreNoEntryLevelCount();

	return iTrueCount > 0;
}

bool CvUnit::canIgnoreZoneofControl() const
{
	int iTrueCount = 0;

	if (m_pUnitInfo->isIgnoreZoneofControl())
	{
		iTrueCount++;
	}
	iTrueCount += getIgnoreZoneofControlCount();

	return iTrueCount > 0;
}

bool CvUnit::canFliesToMove() const
{
	int iTrueCount = 0;

	if (m_pUnitInfo->isFliesToMove())
	{
		iTrueCount++;
	}
	iTrueCount += getFliesToMoveCount();

	return iTrueCount > 0;
}

int CvUnit::strAdjperRndTotal() const
{
	int iStrAdjperRnd = m_iExtraStrAdjperRnd;
	if (!isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander)
		{
			iStrAdjperRnd += pCommander->m_iExtraStrAdjperRnd;
		}
	}
    if (!isCommodore())
	{
		const CvUnit* pCommodore = getCommodore();
		if (pCommodore)
		{
			iStrAdjperRnd += pCommodore->m_iExtraStrAdjperRnd;
		}
	}
#ifdef BATTLEWORN
	iStrAdjperRnd += m_pUnitInfo->getStrAdjperRnd();
#endif
	if (iStrAdjperRnd < 0)
	{
		iStrAdjperRnd = std::max(0, iStrAdjperRnd + enduranceTotal());
	}
	return iStrAdjperRnd;
}

int CvUnit::strAdjperAttTotal() const
{
	int iStrAdjperAtt = m_iExtraStrAdjperAtt;
	if (!isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander)
		{
			iStrAdjperAtt += pCommander->m_iExtraStrAdjperAtt;
		}
	}
    if (!isCommodore())
	{
		const CvUnit* pCommodore = getCommodore();
		if (pCommodore)
		{
			iStrAdjperAtt += pCommodore->m_iExtraStrAdjperAtt;
		}
	}
#ifdef BATTLEWORN
	iStrAdjperAtt += m_pUnitInfo->getStrAdjperAtt();
#endif
	if (iStrAdjperAtt < 0)
	{
		iStrAdjperAtt = std::max(0, (iStrAdjperAtt + enduranceTotal()));
	}
	return (iStrAdjperAtt);
}

int CvUnit::strAdjperDefTotal() const
{
	if (noDefensiveBonus())
	{
		return 0;
	}
	int iStrAdjperDef = m_iExtraStrAdjperDef;

	if (!isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander)
		{
			iStrAdjperDef += pCommander->m_iExtraStrAdjperDef;
		}
	}

    if (!isCommodore())
	{
		const CvUnit* pCommodore = getCommodore();
		if (pCommodore)
		{
			iStrAdjperDef += pCommodore->m_iExtraStrAdjperDef;
		}
	}
#ifdef BATTLEWORN
	iStrAdjperDef += m_pUnitInfo->getStrAdjperDef();
#endif
	return iStrAdjperDef;
}

int CvUnit::withdrawAdjperAttTotal() const
{
	int iWithdrawAdjperAtt = m_iExtraWithdrawAdjperAtt;
	if (!isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander)
		{
			iWithdrawAdjperAtt += pCommander->m_iExtraWithdrawAdjperAtt;
		}
	}
	if (!isCommodore())
    	{
    		const CvUnit* pCommodore = getCommodore();
    		if (pCommodore)
    		{
    			iWithdrawAdjperAtt += pCommodore->m_iExtraWithdrawAdjperAtt;
    		}
    	}
#ifdef BATTLEWORN
	iWithdrawAdjperAtt += m_pUnitInfo->getWithdrawAdjperAtt();
#endif
	if (iWithdrawAdjperAtt < 0)
	{
		iWithdrawAdjperAtt = std::max(0, iWithdrawAdjperAtt + enduranceTotal());
	}
	return iWithdrawAdjperAtt;
}

int CvUnit::currentStrAdjperRndTotal() const
{
	return strAdjperRndTotal() * getRoundCount();
}

int CvUnit::currentStrAdjperAttTotal() const
{
	return strAdjperAttTotal() * getAttackCount();
}

int CvUnit::currentStrAdjperDefTotal() const
{
	if (noDefensiveBonus())
	{
		return 0;
	}
	return strAdjperDefTotal() * getDefenseCount();
}

int CvUnit::currentWithdrawAdjperAttTotal() const
{
	return withdrawAdjperAttTotal() * getAttackCount();
}

int CvUnit::unnerveTotal() const
{
	return std::max(0, m_pUnitInfo->getUnnerve() + getExtraUnnerve());
}

int CvUnit::encloseTotal() const
{
	return std::max(0, m_pUnitInfo->getEnclose() + getExtraEnclose());
}

int CvUnit::lungeTotal() const
{
	return std::max(0, m_pUnitInfo->getLunge() + getExtraLunge());
}

int CvUnit::dynamicDefenseTotal() const
{
	int iData = m_pUnitInfo->getDynamicDefense() + getExtraDynamicDefense();

	if (plot()->isCity(false, getTeam()))
	{
		iData += plot()->getPlotCity()->getExtraLocalDynamicDefense();
	}
	return std::max(0, iData);
}

bool CvUnit::canAnimalIgnoresBorders() const
{
	if (GC.getGame().isOption(GAMEOPTION_ANIMAL_STAY_OUT))
	{
		return false;
	}
    if (GC.getGame().isOption(GAMEOPTION_ANIMAL_DANGEROUS))
    {
        return true;
    }
	return getAnimalIgnoresBordersCount() > 0;
}

bool CvUnit::canAnimalIgnoresImprovements() const
{
	if (GC.getGame().isOption(GAMEOPTION_ANIMAL_STAY_OUT))
	{
		return false;
	}
	if (GC.getGame().isOption(GAMEOPTION_ANIMAL_DANGEROUS))
	{
		return true;
	}
	return getAnimalIgnoresBordersCount() > 1;

}

bool CvUnit::canAnimalIgnoresCities() const
{
	if (GC.getGame().isOption(GAMEOPTION_ANIMAL_STAY_OUT))
	{
		return false;
	}
	if (GC.getGame().isOption(GAMEOPTION_ANIMAL_DANGEROUS))
	{
		return true;
	}
	return getAnimalIgnoresBordersCount() > 2;
}

bool CvUnit::canOnslaught() const
{
	return m_pUnitInfo->isOnslaught() || mayOnslaught();
}

#ifdef OUTBREAKS_AND_AFFLICTIONS
bool CvUnit::hasCureAfflictionType(PromotionLineTypes ePromotionLineType) const
{
	PROFILE_EXTRA_FUNC();
	bool bCureAffliction = ePromotionLineType != NO_PROMOTIONLINE && hasExtraCureAffliction(ePromotionLineType);
	if (!bCureAffliction)
	{
		for (int iI = 0; iI < m_pUnitInfo->getNumCureAfflictionTypes(); iI++)
		{
			if (m_pUnitInfo->getCureAfflictionType(iI) == (int)ePromotionLineType)
			{
				bCureAffliction = true;
			}
		}
	}
	return bCureAffliction;
}

int CvUnit::fortitudeTotal() const
{
	return m_pUnitInfo->getFortitude() + getExtraFortitude();
}

int CvUnit::aidTotal(PropertyTypes eProperty) const
{
	return std::max(0, (m_pUnitInfo->getAidChange((int)eProperty) + extraAidChange(eProperty)));
}
#endif // OUTBREAKS_AND_AFFLICTIONS

int CvUnit::dodgeTotal() const
{
	const int iChill = std::max(
		0, getColdDamage() - getColdDamage() * enduranceTotal() / 10
	);
	const int iDodge = m_pUnitInfo->getDodgeModifier() + getExtraDodgeModifier() + 100;

	return iDodge - iDodge * iChill / 100;
}

int CvUnit::precisionTotal() const
{
	const int iChill = std::max(
		0, getColdDamage() - getColdDamage() * enduranceTotal() / 10
	);
	const int iPrecision = m_pUnitInfo->getPrecisionModifier() + getExtraPrecisionModifier() + 100;

	return iPrecision - iPrecision * iChill / 100;
}

int CvUnit::powerShotsTotal() const
{
	return m_pUnitInfo->getPowerShots() + getExtraPowerShots();
}

int CvUnit::powerShotCombatModifierTotal() const
{
	return m_pUnitInfo->getPowerShotCombatModifier() + getExtraPowerShotCombatModifier();
}

int CvUnit::powerShotPunctureModifierTotal() const
{
	return m_pUnitInfo->getPowerShotPunctureModifier() + getExtraPowerShotPunctureModifier();
}

int CvUnit::powerShotPrecisionModifierTotal() const
{
	return m_pUnitInfo->getPowerShotPrecisionModifier() + getExtraPowerShotPrecisionModifier();
}

int CvUnit::powerShotCriticalModifierTotal() const
{
	return m_pUnitInfo->getPowerShotCriticalModifier() + getExtraPowerShotCriticalModifier();
}

int CvUnit::criticalModifierTotal() const
{
	return m_pUnitInfo->getCriticalModifier() + getExtraCriticalModifier();
}

int CvUnit::enduranceTotal() const
{
	return m_pUnitInfo->getEndurance() + getExtraEndurance();
}

bool CvUnit::dealsColdDamage() const
{
	return (m_pUnitInfo->isDealsColdDamage() || mayDealColdDamage()) && !cannotDealColdDamage();
}

bool CvUnit::hasImmunitytoColdDamage() const
{
	return (m_pUnitInfo->isColdImmune() || mayColdImmune()) && !cannotColdImmune();
}

int CvUnit::poisonProbabilityModifierTotal() const
{
	return m_pUnitInfo->getPoisonProbabilityModifier() + getExtraPoisonProbabilityModifier();
}
//TB Combat Mods End


int CvUnit::collateralDamage() const
{
	int iTotal = m_pUnitInfo->getCollateralDamage();
	iTotal += getExtraCollateralDamage();
	return std::max(0, iTotal);
}

int CvUnit::collateralDamageLimit() const
{
	return std::max(0, (m_pUnitInfo->getCollateralDamageLimit() + getCollateralDamageLimitChange()) * GC.getMAX_HIT_POINTS() / 100);
}

int CvUnit::collateralDamageMaxUnits() const
{
	return std::max(0, (m_pUnitInfo->getCollateralDamageMaxUnits() + getCollateralDamageMaxUnitsChange()));
}


int CvUnit::cityAttackModifier() const
{
	return m_pUnitInfo->getCityAttackModifier() + getExtraCityAttackPercent();
}

int CvUnit::cityDefenseModifier() const
{
	if (noDefensiveBonus())
	{
		return 0;
	}
	return (m_pUnitInfo->getCityDefenseModifier() + getExtraCityDefensePercent());
}

int CvUnit::cityDefenseVSOpponent(const CvUnit* pOpponent) const
{
	PROFILE_EXTRA_FUNC();
	if (noDefensiveBonus())
	{
		return 0;
	}
	const CvCity* pCity = plot()->getPlotCity();
	int iValue = 0;

	for (std::map<UnitCombatTypes, UnitCombatKeyedInfo>::const_iterator it = pOpponent->m_unitCombatKeyedInfo.begin(), end = pOpponent->m_unitCombatKeyedInfo.end(); it != end; ++it)
	{
		if (it->second.m_bHasUnitCombat)
		{
			if (plot()->isCity(false, getTeam()))
			{
				iValue += pCity->getUnitCombatDefenseAgainstModifierTotal(it->first);
			}
		}
	}
	return iValue;
}


int CvUnit::animalCombatModifier() const
{
	return m_pUnitInfo->getAnimalCombatModifier();
}


int CvUnit::hillsAttackModifier() const
{
	return (m_pUnitInfo->getHillsAttackModifier() + getExtraHillsAttackPercent());
}


int CvUnit::hillsDefenseModifier() const
{
	if (noDefensiveBonus())
	{
		return 0;
	}
	return (m_pUnitInfo->getHillsDefenseModifier() + getExtraHillsDefensePercent());
}


int CvUnit::terrainAttackModifier(TerrainTypes eTerrain) const
{
	FASSERT_BOUNDS(0, GC.getNumTerrainInfos(), eTerrain);
	return (m_pUnitInfo->getTerrainAttackModifier(eTerrain) + getExtraTerrainAttackPercent(eTerrain));
}


int CvUnit::terrainDefenseModifier(TerrainTypes eTerrain) const
{
	if (noDefensiveBonus())
	{
		return 0;
	}
	FASSERT_BOUNDS(0, GC.getNumTerrainInfos(), eTerrain);
	return (m_pUnitInfo->getTerrainDefenseModifier(eTerrain) + getExtraTerrainDefensePercent(eTerrain));
}


int CvUnit::featureAttackModifier(FeatureTypes eFeature) const
{
	FASSERT_BOUNDS(0, GC.getNumFeatureInfos(), eFeature);
	return (m_pUnitInfo->getFeatureAttackModifier(eFeature) + getExtraFeatureAttackPercent(eFeature));
}

int CvUnit::featureDefenseModifier(FeatureTypes eFeature) const
{
	if (noDefensiveBonus())
	{
		return 0;
	}
	FASSERT_BOUNDS(0, GC.getNumFeatureInfos(), eFeature);
	return (m_pUnitInfo->getFeatureDefenseModifier(eFeature) + getExtraFeatureDefensePercent(eFeature));
}

int CvUnit::unitAttackModifier(UnitTypes eUnit) const
{
	FASSERT_BOUNDS(0, GC.getNumUnitInfos(), eUnit);
	return m_pUnitInfo->getUnitAttackModifiers().getValue(eUnit);
}


int CvUnit::unitDefenseModifier(UnitTypes eUnit) const
{
	if (noDefensiveBonus())
	{
		return 0;
	}
	FASSERT_BOUNDS(0, GC.getNumUnitInfos(), eUnit);
	return m_pUnitInfo->getUnitDefenseModifiers().getValue(eUnit);
}


int CvUnit::unitCombatModifier(UnitCombatTypes eUnitCombat) const
{
	FASSERT_BOUNDS(0, GC.getNumUnitCombatInfos(), eUnitCombat);
	return (m_pUnitInfo->getUnitCombatModifier(eUnitCombat) + getExtraUnitCombatModifier(eUnitCombat, isCommander(), isCommodore()));
}


int CvUnit::domainModifier(DomainTypes eDomain) const
{
	FASSERT_BOUNDS(0, NUM_DOMAIN_TYPES, eDomain);
	return (m_pUnitInfo->getDomainModifier(eDomain) + getExtraDomainModifier(eDomain));
}


int CvUnit::cargoSpace() const
{
	if (GC.getGame().isOption(GAMEOPTION_COMBAT_SIZE_MATTERS))
	{
		int iCargoCapacity = SMcargoSpaceFilter();

		if (getDomainType() == DOMAIN_SEA)
		{
			iCargoCapacity += applySMRank(GET_PLAYER(getOwner()).getNationalNavalCargoSpaceChange(),
				getSizeMattersSpacialOffsetValue(),
				GC.getSIZE_MATTERS_MOST_VOLUMETRIC_MULTIPLIER());
		}
		const SpecialUnitTypes eMissile = (SpecialUnitTypes)GC.getInfoTypeForString("SPECIALUNIT_MISSILE");
		if (getSpecialCargo() == eMissile)
		{
			iCargoCapacity += applySMRank(GET_PLAYER(getOwner()).getNationalMissileCargoSpaceChange(),
				getSizeMattersSpacialOffsetValue(),
				GC.getSIZE_MATTERS_MOST_VOLUMETRIC_MULTIPLIER());
		}
		return iCargoCapacity;
	}
	int iCargoCapacity = m_pUnitInfo->getCargoSpace() + m_iCargoCapacity;

	if (getDomainType() == DOMAIN_SEA)
	{
		iCargoCapacity += GET_PLAYER(getOwner()).getNationalNavalCargoSpaceChange();
	}
	if (getSpecialCargo() == GC.getSPECIALUNIT_MISSILE())
	{
		iCargoCapacity += GET_PLAYER(getOwner()).getNationalMissileCargoSpaceChange();
	}
	return std::max(0, iCargoCapacity);
}

void CvUnit::changeCargoSpace(int iChange)
{
	if (iChange != 0)
	{
		m_iCargoCapacity += iChange;
		setInfoBarDirty(true);
	}
}

bool CvUnit::isFull() const
{
	if (GC.getGame().isOption(GAMEOPTION_COMBAT_SIZE_MATTERS))
	{
		return SMgetCargo() >= cargoSpace();
	}
	return getCargo() >= cargoSpace();
}


int CvUnit::cargoSpaceAvailable(SpecialUnitTypes eSpecialCargo, DomainTypes eDomainCargo) const
{
	if (getSpecialCargo() != NO_SPECIALUNIT && getSpecialCargo() != eSpecialCargo)
	{
		return 0;
	}
	if (getDomainCargo() != NO_DOMAIN && getDomainCargo() != eDomainCargo)
	{
		return 0;
	}

	if (GC.getGame().isOption(GAMEOPTION_COMBAT_SIZE_MATTERS))
	{
		if  (eSpecialCargo != NO_SPECIALUNIT && getSMNotSpecialCargo() == eSpecialCargo)
		{
			return 0;
		}
		return std::max(0, cargoSpace() - SMgetCargo());
	}
	return std::max(0, cargoSpace() - getCargo());
}


bool CvUnit::hasCargo() const
{
	return SMgetCargo() > 0 || getCargo() > 0;
}


bool CvUnit::canCargoAllMove() const
{
	return algo::none_of(plot()->units(),
		CvUnit::fn::getTransportUnit() == this &&
		CvUnit::fn::getDomainType() == DOMAIN_LAND &&
		!CvUnit::fn::canMove()
	);
}

bool CvUnit::canCargoEnterArea(TeamTypes eTeam, const CvArea* pArea, bool bIgnoreRightOfPassage) const
{
	return algo::none_of(plot()->units(),
		CvUnit::fn::getTransportUnit() == this &&
		!CvUnit::fn::canEnterArea(eTeam, pArea, bIgnoreRightOfPassage)
	);
}

int CvUnit::getUnitAICargo(UnitAITypes eUnitAI) const
{
	std::vector<CvUnit*> aCargoUnits;
	getCargoUnits(aCargoUnits);
	return algo::count_if(aCargoUnits, bind(CvUnit::AI_getUnitAIType, _1) == eUnitAI);
}


int CvUnit::getID() const
{
	return m_iID;
}


int CvUnit::getIndex() const
{
	return (getID() & FLTA_INDEX_MASK);
}


IDInfo CvUnit::getIDInfo() const
{
	IDInfo unit(getOwner(), getID());
	return unit;
}


void CvUnit::setID(int iID)
{
	m_iID = iID;
}


int CvUnit::getGroupID() const
{
	return m_iGroupID;
}


bool CvUnit::isInGroup() const
{
	return(getGroupID() != FFreeList::INVALID_INDEX);
}


bool CvUnit::isGroupHead() const
{
	return getGroup()->getHeadUnit() == this;
}


CvSelectionGroup* CvUnit::getGroup() const
{
	return GET_PLAYER(getOwner()).getSelectionGroup(getGroupID());
}

bool CvUnit::canJoinGroup(const CvPlot* pPlot, const CvSelectionGroup* pSelectionGroup) const
{
	// do not allow someone to join a group that is about to be split apart
	// this prevents a case of a never-ending turn
	if (pSelectionGroup->AI_isForceSeparate())
	{
		return false;
	}
	const CvUnit* pHeadUnit = pSelectionGroup->getHeadUnit();

	if (pSelectionGroup->getOwner() == NO_PLAYER)
	{
		if (pHeadUnit != NULL && pHeadUnit->getOwner() != getOwner())
		{
			return false;
		}
	}
	else if (pSelectionGroup->getOwner() != getOwner())
	{
		return false;
	}

	if (pSelectionGroup->getNumUnits() > 0)
	{
		if (pPlot != NULL && !pSelectionGroup->atPlot(pPlot))
		{
			return false;
		}

		//	Can't join a group that is loaded onto a transport as this
		//	would bypass the transport's record of what units it has on
		//	board
		if (pHeadUnit->isCargo())
		{
			if (pHeadUnit->isHuman() && pHeadUnit->getTransportUnit() == getTransportUnit())
			{
				return true;
			}
			return false;
		}
		//TB Note: Although it seems very unusual, checking for null pPlot allows this check to be safe for inter-domain upgrades.
		//this is important for immobile units to land or sea or air.  Could also enable some units to go from land or sea to air or vice versa.
		//if pPlot is NULL, the only known cause would be that the unit is, in fact, upgrading.
		if (pPlot != NULL && pSelectionGroup->getDomainType() != getDomainType())
		{
			return false;
		}
	}

	return true;
}


void CvUnit::joinGroup(CvSelectionGroup* pSelectionGroup, bool bRemoveSelected, bool bRejoin)
{
	PROFILE_FUNC();

	CvSelectionGroup* pOldSelectionGroup = GET_PLAYER(getOwner()).getSelectionGroup(getGroupID());
	CvSelectionGroup* pNewSelectionGroup = NULL;

	if (pSelectionGroup != pOldSelectionGroup && pSelectionGroup != NULL
	&& pSelectionGroup->getHeadUnit() != NULL
	&& pSelectionGroup->getHeadUnit()->isWaitingOnUnitAI((int)AI_getUnitAIType()))
	{
		pSelectionGroup->getHeadUnit()->setToWaitOnUnitAI(AI_getUnitAIType(), false);
	}

	if (pSelectionGroup != pOldSelectionGroup || pOldSelectionGroup == NULL)
	{
		CvPlot* pPlot = plot();

		if (pSelectionGroup != NULL)
		{
			pNewSelectionGroup = pSelectionGroup;
		}
		else if (bRejoin)
		{
			const int iSelectionRegroup = GET_PLAYER(getOwner()).getSelectionRegroup();

			if (iSelectionRegroup != NULL)
			{
				pNewSelectionGroup = GET_PLAYER(getOwner()).getSelectionGroup(iSelectionRegroup);

				if (!canJoinGroup(pPlot, pNewSelectionGroup))
				{
					pNewSelectionGroup = GET_PLAYER(getOwner()).addSelectionGroup();
					FAssert(pNewSelectionGroup != NULL);
					pNewSelectionGroup->init(pNewSelectionGroup->getID(), getOwner());
				}
			}
			else
			{
				pNewSelectionGroup = GET_PLAYER(getOwner()).addSelectionGroup();
				FAssert(pNewSelectionGroup != NULL);
				pNewSelectionGroup->init(pNewSelectionGroup->getID(), getOwner());
			}
		}

		if (pNewSelectionGroup == NULL || canJoinGroup(pPlot, pNewSelectionGroup))
		{
			if (pOldSelectionGroup != NULL)
			{
				const bool bWasHead = !isHuman()
					&& pOldSelectionGroup->getNumUnits() > 1
					&& pOldSelectionGroup->getHeadUnit() == this;

				pOldSelectionGroup->removeUnit(this);

				// if we were the head, if the head unitAI changed, then force the group to separate (non-humans)
				if (bWasHead)
				{
					if (isWaitingOnUnitAIAny())
					{
						for (int iI = 0; iI < NUM_UNITAI_TYPES; iI++)
						{
							if (isWaitingOnUnitAI(iI))
							{
								setToWaitOnUnitAI((UnitAITypes)iI, false);
							}
						}
					}
					FAssert(pOldSelectionGroup->getHeadUnit() != NULL);

					if (!pOldSelectionGroup->isChoosingNewLeader()
					&& pOldSelectionGroup->getHeadUnit()->AI_getUnitAIType() != AI_getUnitAIType()
					// Special case to try to hold together city attacks that are breaking up but can still succeed
					// If we have lost the last city_attack AI unit see if we have a unit that COULD take over in the SAME role
					&& (UNITAI_ATTACK_CITY != AI_getUnitAIType() || !pOldSelectionGroup->findNewLeader(UNITAI_ATTACK_CITY)))
					{
						pOldSelectionGroup->AI_makeForceSeparate();
					}
				}
			}

			if (pNewSelectionGroup != NULL)
			{
				if (pNewSelectionGroup->getHeadUnit() != NULL && pNewSelectionGroup->getHeadUnit()->isWaitingOnUnitAI((int)AI_getUnitAIType()))
				{
					pNewSelectionGroup->getHeadUnit()->setToWaitOnUnitAI(AI_getUnitAIType(), false);
				}

				//	Normal rules apply when we join someone else's group unless
				//	the priority chnage was actually to DOWNgrade our priority
				if (AI_groupFirstVal() != LEADER_PRIORITY_MIN)
				{
					AI_setLeaderPriority(-1);
				}

				m_iGroupID = pNewSelectionGroup->getID();

				if (!pNewSelectionGroup->addUnit(this, false))
				{
					m_iGroupID = FFreeList::INVALID_INDEX;
				}

				LOG_UNIT_BLOCK(4, {
					CvWString StrunitAIType = GC.getUnitAIInfo(AI_getUnitAIType()).getType();
					CvWString StrUnitName = m_szName;
					if (StrUnitName.length() == 0)
					{
						StrUnitName = getName(0).GetCString();
					}
					logBBAI("	Player %d Unit ID %d, %S of Type %S at (%d,%d) [stack size %d] groups have joigned here, new GroupID %d.", getOwner(), getID(), StrUnitName.GetCString(), StrunitAIType.GetCString(), getX(), getY(), getGroup()->getNumUnits(), m_iGroupID);
				});
			}
			else
			{
				//	Normal rules apply when we are alone again
				AI_setLeaderPriority(-1);

				m_iGroupID = FFreeList::INVALID_INDEX;
			}

			if (getGroup() != NULL)
			{
				if (getGroup()->getNumUnits() > 1)
				{
					if (getGroup()->canAllMove())
					{
						getGroup()->setActivityType(ACTIVITY_AWAKE);
					}
				}
				else
				{
					GET_PLAYER(getOwner()).updateGroupCycle(this, false);
				}
			}

			if (pPlot != NULL && getTeam() == GC.getGame().getActiveTeam())
			{
				pPlot->setFlagDirty(true);
			}

			if (pPlot == gDLL->getInterfaceIFace()->getSelectionPlot())
			{
				gDLL->getInterfaceIFace()->setDirty(PlotListButtons_DIRTY_BIT, true);
			}
		}

		if (bRemoveSelected && IsSelected())
		{
			gDLL->getInterfaceIFace()->removeFromSelectionList(this);
		}
	}
}


int CvUnit::getHotKeyNumber()
{
	return m_iHotKeyNumber;
}


void CvUnit::setHotKeyNumber(int iNewValue)
{
	PROFILE_EXTRA_FUNC();
	FAssert(getOwner() != NO_PLAYER);

	if (getHotKeyNumber() != iNewValue)
	{
		if (iNewValue != -1)
		{
			foreach_(CvUnit* pLoopUnit, GET_PLAYER(getOwner()).units())
			{
				if (pLoopUnit->getHotKeyNumber() == iNewValue)
				{
					pLoopUnit->setHotKeyNumber(-1);
				}
			}
		}

		m_iHotKeyNumber = iNewValue;

		if (IsSelected())
		{
			gDLL->getInterfaceIFace()->setDirty(InfoPane_DIRTY_BIT, true);
		}
	}
}


int CvUnit::getViewportX() const
{
	const CvViewport* pCurrentViewPort = GC.getCurrentViewport();
	FAssert(pCurrentViewPort != NULL);

	return pCurrentViewPort->getViewportXFromMapX(m_iX);
}


int CvUnit::getViewportY() const
{
	const CvViewport* pCurrentViewPort = GC.getCurrentViewport();
	FAssert(pCurrentViewPort != NULL);

	return pCurrentViewPort->getViewportYFromMapY(m_iY);
}

bool CvUnit::isInViewport() const
{
	return GC.getCurrentViewport()->isInViewport(m_iX, m_iY);
}

bool CvUnit::isTempUnit() const
{
	return GET_PLAYER(getOwner()).isTempUnit(this);
}

void CvUnit::setXY(int iX, int iY, bool bGroup, bool bUpdate, bool bShow, bool bCheckPlotVisible, bool bInit)
{
	PROFILE_FUNC();
	/*GC.getGame().logOOSSpecial(1, getID(), iX, iY);*/

	{ // Toffer - Problems arise when units have illegal coordinates that are not specifically INVALID_PLOT_COORD.
		//	No Idea why it is set up so that plot() only returns NULL for INVALID_PLOT_COORD but not for other illegal coordinates.
		const int iMaxX = GC.getMap().getGridWidth();
		const int iMaxY = GC.getMap().getGridHeight();
		if (iX < 0 || iX >= iMaxX || iY < 0 || iY >= iMaxY)
		{
			if (iX != INVALID_PLOT_COORD || iY != INVALID_PLOT_COORD)
			{
				FErrorMsg("Illegal coordinates given to unit");
				iX = INVALID_PLOT_COORD;
				iY = INVALID_PLOT_COORD;
			}
		}
	}

	// Temp units do not really exist, and are just used to provide a data anchor for virtual pathing calculations.
	// As such they do not need to process their position into the wider game state and indeed should not without additional concurrency protection.
	if (isTempUnit())
	{
		m_iX = iX;
		m_iY = iY;

		if (!getGroup())
		{
			joinGroup(NULL);
		}
		/*GC.getGame().logOOSSpecial(2, getID(), iX, iY);*/
		return;
	}
	const PlayerTypes eMyPlayer = getOwner();
	CvPlayer& myPlayer = GET_PLAYER(eMyPlayer);

	// If a unit moves we need to flush any combat str cache entries relating to it
	FlushCombatStrCache(this);

	/*
	// OOS!! Temporary for Out-of-Sync madness debugging...
	if (GC.getLogging())
	{
		PROFILE("CvUnit::setXY.OOSLogging");

		char szOut[1024];
		sprintf(szOut, "Player %d Unit %d (%S's %S) moving from %d:%d to %d:%d\n", eMyPlayer, getID(), myPlayer.getNameKey(), getName().GetCString(), getX(), getY(), iX, iY);
		gDLL->messageControlLog(szOut);
	}
	*/

	if (isInBattle())
	{
		setCombatUnit(NULL);
	}
	if (at(iX, iY))
	{
		return;
	}
	FAssert(iX == INVALID_PLOT_COORD || GC.getMap().plot(iX, iY)->getX() == iX);
	FAssert(iY == INVALID_PLOT_COORD || GC.getMap().plot(iX, iY)->getY() == iY);

	// Activity before moving to the new plot
	const ActivityTypes eOldActivityType = getGroup() ? getGroup()->getActivityType() : NO_ACTIVITY;

	setBlockading(false);

	if (!bGroup || isCargo())
	{
		bShow = false;
	}

	CvPlot* pNewPlot = GC.getMap().plot(iX, iY);
	CvPlot* pOldPlot = plot();

	//	Koshling - Forcing the unit into a new group causes rapid cycling through the group id
	//	space, which is a scaling issue, so only do it when necessary
	//	Note - it used o do this unconditionally for cargo and changing that behavior
	//	might be dangerous, but it solves some scaling problems and I cannot think of a reason why
	//	it should be problematics, nor is it causing any issues in test cases I have tried
	if (!bGroup && (!getGroup() || getGroup()->getNumUnits() > 1))
	{
		// Need valid plot() for joinGroup() so set our position now
		if (bInit || pOldPlot == nullptr)
		{
			m_iX = iX;
			m_iY = iY;
		}
		joinGroup(NULL, true);
	}

	if (pNewPlot)
	{
		PROFILE("CvUnit::setXY.NewPlot");

		CvUnit* pTransportUnit = getTransportUnit();

		if (pTransportUnit && !pTransportUnit->atPlot(pNewPlot))
		{
			setTransportUnit(NULL); // Departed from transport
		}

		if (!bInit && pOldPlot && canFight() && !isCargo())
		{
			///TB: This next portion is to reset the plot list of the new plot before moving on after units may (probably were) have been destroyed in combat there.
			//This might be necessary for the trap segment below, to rerun this.
			OutputDebugString(CvString::format("%S (%d) CvUnit::setXY (%d,%d)\n", getDescription().c_str(), m_iID, m_iX, m_iY).c_str());
			foreach_(CvUnit* unitX, pNewPlot->units_safe())
			{
				if (unitX->isDead())
					continue;

				if ((isEnemy(unitX->getTeam(), pNewPlot) || unitX->isEnemy(getTeam())) && !unitX->canCoexistWithAttacker(*this, true))
				{
					if (unitX->isArmedTrap())
					{
						unitX->doTrap(this);
					}
					else if (!unitX->canDefend(pNewPlot) && !unitX->isInvisible(getTeam(), false) && !unitX->isCargo())
					{
						//TB NOTE: This is where units that can't defend themselves are auto-captured IF the unit has a defined capture tag and cannot defend.
						if (!isNoCapture() && NO_UNIT != unitX->getUnitInfo().getUnitCaptureType())
						{
							if (isHiddenNationality() || unitX->isHiddenNationality())
							{
								GET_TEAM(unitX->getTeam()).changeWarWeariness(getTeam(), *pNewPlot, GC.getDefineINT("WW_UNIT_CAPTURED"));
								GET_TEAM(getTeam()).changeWarWeariness(unitX->getTeam(), *pNewPlot, GC.getDefineINT("WW_CAPTURED_UNIT"));
								GET_TEAM(getTeam()).AI_changeWarSuccess(unitX->getTeam(), GC.getDefineINT("WAR_SUCCESS_UNIT_CAPTURING"));
							}
							unitX->setCapturingPlayer(eMyPlayer);
							unitX->setCapturingUnit(this);
						}
						unitX->kill(true, eMyPlayer, true);
					}
				}
			}
		}

		if (pNewPlot->isGoody(getTeam()) && !isNPC() && !m_pUnitInfo->isNoRevealMap())
		{
			myPlayer.doGoody(pNewPlot, this);
		}

		pNewPlot->area()->changeUnitsPerPlayer(eMyPlayer, 1);
		pNewPlot->area()->changePower(eMyPlayer, getPowerValueTotal());

		if (AI_getUnitAIType() != NO_UNITAI)
		{
			pNewPlot->area()->changeNumAIUnits(eMyPlayer, AI_getUnitAIType(), 1);
		}

		if (isAnimal())
		{
			pNewPlot->area()->changeAnimalsPerPlayer(eMyPlayer, 1);
		}

		if (pNewPlot->getTeam() != getTeam() && (pNewPlot->getTeam() == NO_TEAM || !GET_TEAM(pNewPlot->getTeam()).isVassal(getTeam())))
		{
			myPlayer.changeNumOutsideUnits(1);
		}
	}

	if (pOldPlot)
	{
		PROFILE("CvUnit::setXY.OldPlot");

		pOldPlot->removeUnit(this, bUpdate && !hasCargo());

		setFortifyTurns(0);

		pOldPlot->changeAdjacentSight(getTeam(), visibilityRange(pOldPlot), false, this, true);
		changeDebugCount(-1);

		pOldPlot->area()->changeUnitsPerPlayer(eMyPlayer, -1);
		pOldPlot->area()->changePower(eMyPlayer, -getPowerValueTotal());

		if (AI_getUnitAIType() != NO_UNITAI)
		{
			pOldPlot->area()->changeNumAIUnits(eMyPlayer, AI_getUnitAIType(), -1);
		}

		if (isAnimal())
		{
			pOldPlot->area()->changeAnimalsPerPlayer(eMyPlayer, -1);
		}

		if (pOldPlot->getTeam() != getTeam() && (pOldPlot->getTeam() == NO_TEAM || !GET_TEAM(pOldPlot->getTeam()).isVassal(getTeam())))
		{
			myPlayer.changeNumOutsideUnits(-1);
		}

		setLastMoveTurn(GC.getGame().getTurnSlice());

		CvCity* pOldCity = pOldPlot->getPlotCity();

		if (pOldCity)
		{
			if (isMilitaryHappiness())
			{
				pOldCity->changeMilitaryHappinessUnits(-1);
			}
			pOldCity->noteUnitMoved(this);
		}

		{
			CvCity* pWorkingCity = pOldPlot->getWorkingCity();

			if (pWorkingCity && canSiege(pWorkingCity->getTeam()))
			{
				pWorkingCity->AI_setAssignWorkDirty(true);
			}

			if (pOldPlot->isWater())
			{
				foreach_(const CvPlot* pLoopPlot, pOldPlot->adjacent() | filtered(CvPlot::fn::isWater()))
				{
					pWorkingCity = pLoopPlot->getWorkingCity();

					if (pWorkingCity && canSiege(pWorkingCity->getTeam()))
					{
						pWorkingCity->AI_setAssignWorkDirty(true);
					}
				}
			}
		}

		if (pOldPlot->isActiveVisible(true))
		{
			pOldPlot->updateMinimapColor();
		}

		if (pOldPlot == gDLL->getInterfaceIFace()->getSelectionPlot())
		{
			gDLL->getInterfaceIFace()->verifyPlotListColumn();

			gDLL->getInterfaceIFace()->setDirty(PlotListButtons_DIRTY_BIT, true);
		}
	}

	if (pNewPlot)
	{
		m_iX = pNewPlot->getX();
		m_iY = pNewPlot->getY();
	}
	else
	{
		m_iX = INVALID_PLOT_COORD;
		m_iY = INVALID_PLOT_COORD;
	}

	FAssertMsg(plot() == pNewPlot, "plot is expected to equal pNewPlot");

	if (pNewPlot)
	{
		PROFILE("CvUnit::setXY.NewPlot2");

		CvCity* pNewCity = pNewPlot->getPlotCity();

		if (pNewCity) //Again... is bUpdate only for when the unit is not cargo?
		{
			PROFILE("CvUnit::setXY.NewPlot2.NewCity");

			if (!myPlayer.isAnimal()
			&& !isBlendIntoCity()
			&& !isNoCapture()
			&& !isCargo()
			&& canFight()
			&& isEnemy(pNewCity->getTeam())
			&& (!isBarbCoExist() || !pNewPlot->isHominid())
			&& (!isHiddenNationality() || !pNewCity->isNPC())
			&& !canCoexistAlwaysOnPlot(*pNewPlot)
			&& !pNewPlot->hasDefender(false, NO_PLAYER, getOwner(), this, true, false, false, true))
			{
				GET_TEAM(getTeam()).changeWarWeariness(pNewCity->getTeam(), *pNewPlot, GC.getDefineINT("WW_CAPTURED_CITY"));

				// Double war success if capturing capital city, always a significant blow to enemy
				// pNewCity still points to old city here, hasn't been acquired yet
				GET_TEAM(getTeam()).AI_changeWarSuccess(pNewCity->getTeam(), (pNewCity->isCapital() ? 2 : 1)*GC.getWAR_SUCCESS_CITY_CAPTURING());


				const PlayerTypes eNewOwner =
				(
					isHiddenNationality()
					?
					BARBARIAN_PLAYER
					:
					myPlayer.pickConqueredCityOwner(*pNewCity)
				);
				if (NO_PLAYER != eNewOwner)
				{
					GET_PLAYER(eNewOwner).acquireCity(pNewCity, true, false, true); // will delete the pointer
					pNewCity = NULL;
				}
			}
			else
			{
				pNewCity->noteUnitMoved(this);
			}
		}

		// Koshling - modified a little to merge Super Forts logic
		const ImprovementTypes eImprovement = pNewPlot->getImprovementType();

		if (eImprovement != NO_IMPROVEMENT && GC.getImprovementInfo(eImprovement).isActsAsCity() && !isNoCapture()
		&& !isBlendIntoCity() && !isHiddenNationality() && !myPlayer.isAnimal() && !isCargo())
		{
			PROFILE("CvUnit::setXY.NewPlot2.ActAsCity");

			if (pNewPlot->getOwner() != NO_PLAYER)
			{
				const CvPlayer& pNewPlotOwner = GET_PLAYER(pNewPlot->getOwner());

				if ((isEnemy(pNewPlotOwner.getTeam()) || !pNewPlotOwner.isAlive())
				&& (!isBarbCoExist() || !pNewPlot->isHominid())
				&& !canCoexistWithTeamOnPlot(pNewPlotOwner.getTeam(), *pNewPlot) && canFight())
				{
					AddDLLMessage(
						pNewPlot->getOwner(), false, GC.getEVENT_MESSAGE_TIME(),
						gDLL->getText("TXT_KEY_MISC_CITY_CAPTURED_BY", GC.getImprovementInfo(eImprovement).getText(), myPlayer.getCivilizationDescriptionKey()),
						"AS2D_CITYCAPTURED", MESSAGE_TYPE_MAJOR_EVENT, GC.getImprovementInfo(eImprovement).getButton(), GC.getCOLOR_RED(), pNewPlot->getX(), pNewPlot->getY(), true, true
					);
					myPlayer.acquireFort(pNewPlot);
				}
			}
			else myPlayer.acquireFort(pNewPlot);
		}

		//update facing direction
		if (pOldPlot)
		{
			const DirectionTypes newDirection = estimateDirection(pOldPlot, pNewPlot);
			if (newDirection != NO_DIRECTION)
				m_eFacingDirection = newDirection;
		}

		//update cargo mission animations
		if (isCargo())
		{
			PROFILE("CvUnit::setXY.NewPlot2.Cargo");

			if (eOldActivityType != ACTIVITY_MISSION)
			{
				getGroup()->setActivityType(eOldActivityType);
			}
		}

		pNewPlot->changeAdjacentSight(getTeam(), visibilityRange(pNewPlot), true, this, true); // needs to be here so that the square is considered visible when we move into it...
		changeDebugCount(1);
		pNewPlot->addUnit(this, bUpdate && !hasCargo());

		if (!bInit && shouldLoadOnMove(pNewPlot))
		{
			PROFILE("CvUnit::setXY.NewPlot2.Load");

			load();
		}
		{
			PROFILE("CvUnit::setXY.NewPlot2.Meet");

			for (int iI = 0; iI < MAX_PC_TEAMS; iI++)
			{
				if (GET_TEAM((TeamTypes)iI).isAlive() && !isInvisible((TeamTypes)iI, false) && pNewPlot->isVisible((TeamTypes)iI, false))
				{
					GET_TEAM((TeamTypes)iI).meet(getTeam(), true);
				}
			}
		}

		{
			CvCity* pNewCity = pNewPlot->getPlotCity();

			if (pNewCity && isMilitaryHappiness())
			{
				pNewCity->changeMilitaryHappinessUnits(1);
			}
		}
		{
			CvCity* pWorkingCity = pNewPlot->getWorkingCity();

			if (pWorkingCity)
			{
				PROFILE("CvUnit::setXY.NewPlot2.WorkingCity");

				if (canSiege(pWorkingCity->getTeam()))
				{
					pWorkingCity->verifyWorkingPlot(pWorkingCity->getCityPlotIndex(pNewPlot));
				}
			}

			if (pNewPlot->isWater())
			{
				PROFILE("CvUnit::setXY.NewPlot2.Water");

				foreach_(const CvPlot* pLoopPlot, pNewPlot->adjacent() | filtered(CvPlot::fn::isWater()))
				{
					pWorkingCity = pLoopPlot->getWorkingCity();

					if (pWorkingCity && canSiege(pWorkingCity->getTeam()))
					{
						pWorkingCity->verifyWorkingPlot(pWorkingCity->getCityPlotIndex(pLoopPlot));
					}
				}
			}
		}

		if (pNewPlot->isActiveVisible(true))
		{
			pNewPlot->updateMinimapColor();
		}

		if (GC.IsGraphicsInitialized() && isInViewport())
		{
			PROFILE("CvUnit::setXY.NewPlot2.Visibility");

			// Override bShow if check plot visible
			if (bShow || bCheckPlotVisible && pNewPlot->isVisibleToWatchingHuman())
			{
				QueueMove(pNewPlot);
			}
			else SetPosition(pNewPlot);
		}

		if (pNewPlot == gDLL->getInterfaceIFace()->getSelectionPlot())
		{
			gDLL->getInterfaceIFace()->verifyPlotListColumn();
			gDLL->getInterfaceIFace()->setDirty(PlotListButtons_DIRTY_BIT, true);
		}

		// Pillage on move: Only if unowned tile, or at war
		if (isPillageOnMove() && pNewPlot->getImprovementType() != NO_IMPROVEMENT)
		{
			if (!pNewPlot->isOwned() || atWar(getTeam(), GET_PLAYER(pNewPlot->getOwner()).getTeam()))
			{
				pillage(true);
			}
		}
	}

	if (pOldPlot && hasCargo())
	{
		PROFILE("CvUnit::setXY.OldPlot2");

		std::vector<CvUnit*> cargoUnits;

		foreach_(CvUnit* pLoopUnit, pOldPlot->units())
		{
			if (pLoopUnit->getTransportUnit() == this)
			{
				//GC.getGame().logOOSSpecial(22, pLoopUnit->getID(), iX, iY);
				cargoUnits.push_back(pLoopUnit);
			}
		}
		foreach_(CvUnit* pLoopUnit, cargoUnits)
		{
			pLoopUnit->setXY(iX, iY, bGroup, false);
		}
#ifdef _DEBUG
		foreach_(const CvUnit* pLoopUnit, pOldPlot->units())
		{
			if (pLoopUnit->getTransportUnit() == this)
			{
				pLoopUnit->getGroup()->validateLocations();
			}
		}
#endif
	}

	if (bUpdate)// && hasCargo())
	{
		PROFILE("CvUnit::setXY.updateCenter");

		if (pOldPlot)
		{
			pOldPlot->updateCenterUnit();
			pOldPlot->setFlagDirty(true);
		}
		if (pNewPlot)
		{
			pNewPlot->updateCenterUnit();
			pNewPlot->setFlagDirty(true);
		}
	}

	const bool bFarMove =
	(
		!pOldPlot || !pNewPlot
		||
		3 < stepDistance(pOldPlot->getX(), pOldPlot->getY(), pNewPlot->getX(), pNewPlot->getY())
	);

	FAssert(pOldPlot != pNewPlot);
	myPlayer.updateGroupCycle(this, bFarMove);

	if (pNewPlot)
	{
		setHasAnyInvisibility();

		if ((pOldPlot && pOldPlot->isInViewport()) != pNewPlot->isInViewport()
		|| g_bUseDummyEntities
		&& (pOldPlot && pOldPlot->isActiveVisible(false)) != pNewPlot->isActiveVisible(false))
		{
			reloadEntity();
		}
	}

	setInfoBarDirty(true);

	if (IsSelected())
	{
		if (isFound())
		{
			gDLL->getInterfaceIFace()->setDirty(GlobeLayer_DIRTY_BIT, true);

			if (!isUsingDummyEntities() && isInViewport())
			{
				gDLL->getEngineIFace()->updateFoundingBorder();
			}
		}
		gDLL->getInterfaceIFace()->setDirty(ColoredPlots_DIRTY_BIT, true);
	}

	//update glow
	if (pNewPlot && !isUsingDummyEntities() && isInViewport())
	{
		gDLL->getEntityIFace()->updateEnemyGlow(getUnitEntity());
	}
	/*GC.getGame().logOOSSpecial(5, getID(), iX, iY);*/
}


bool CvUnit::at(int iX, int iY) const
{
	return getX() == iX && getY() == iY;
}


bool CvUnit::atPlot(const CvPlot* pPlot) const
{
	return plot() == pPlot;
}


CvPlot* CvUnit::plot() const
{
	//FAssertMsg(isInViewport(), "Can't get plot of unit that is not in the viewport");
	//FAssertMsg(!isUsingDummyEntities(), "Can't get plot of unit that is using dummy entities");
	return GC.getMap().plotSorenINLINE(getX(), getY());
}


/*DllExport*/ CvPlot* CvUnit::plotExternal() const
{
#ifdef _DEBUG
	OutputDebugString("exe is asking for the plot of this unit\n");
#endif
	FAssertMsg(isInViewport(), "Can't get plot of unit that is not in the viewport");
	FAssertMsg(!isUsingDummyEntities(), "Can't get plot of unit that is using dummy entities");
	return GC.getMap().plotSorenINLINE(getX(), getY());
}


int CvUnit::getArea() const
{
	return plot()->getArea();
}


CvArea* CvUnit::area() const
{
	return plot()->area();
}


int CvUnit::getLastMoveTurn() const
{
	return m_iLastMoveTurn;
}

void CvUnit::setLastMoveTurn(int iNewValue)
{
	m_iLastMoveTurn = iNewValue;
	FASSERT_NOT_NEGATIVE(m_iLastMoveTurn);
}


CvPlot* CvUnit::getReconPlot() const
{
	return GC.getMap().plotSorenINLINE(m_iReconX, m_iReconY);
}


void CvUnit::setReconPlot(CvPlot* pNewPlot)
{
	CvPlot* pOldPlot = getReconPlot();

	if (pOldPlot != pNewPlot)
	{
		if (pOldPlot)
		{
			pOldPlot->changeAdjacentSight(getTeam(), GC.getRECON_VISIBILITY_RANGE(), false, this, true);
			pOldPlot->changeReconCount(-1); // changeAdjacentSight() tests for getReconCount()
			changeDebugCount(-1);
		}

		if (pNewPlot)
		{
			m_iReconX = pNewPlot->getX();
			m_iReconY = pNewPlot->getY();

			pNewPlot->changeReconCount(1); // changeAdjacentSight() tests for getReconCount()
			pNewPlot->changeAdjacentSight(getTeam(), GC.getRECON_VISIBILITY_RANGE(), true, this, true);
			changeDebugCount(1);
		}
		else
		{
			m_iReconX = INVALID_PLOT_COORD;
			m_iReconY = INVALID_PLOT_COORD;
		}
	}
}


int CvUnit::getGameTurnCreated() const
{
	return m_iGameTurnCreated;
}


void CvUnit::setGameTurnCreated(int iNewValue)
{
	FASSERT_NOT_NEGATIVE(iNewValue);

	m_iGameTurnCreated = iNewValue;
}


int CvUnit::getDamage() const
{
	return m_iDamage;
}

int CvUnit::getHealAsDamage(UnitCombatTypes eHealAsType) const
{
	FASSERT_BOUNDS(0, GC.getNumUnitCombatInfos(), eHealAsType);

	const UnitCombatKeyedInfo* info = findUnitCombatKeyedInfo(eHealAsType);

	return info ? info->m_iHealAsDamage : 0;
}

void CvUnit::changeHealAsDamage(UnitCombatTypes eHealAsType, int iChange, PlayerTypes ePlayer)
{
	FASSERT_BOUNDS(0, GC.getNumUnitCombatInfos(), eHealAsType);

	if (iChange != 0)
	{
		const UnitCombatKeyedInfo* info = findOrCreateUnitCombatKeyedInfo(eHealAsType);

		const int iNewValue = (info->m_iHealAsDamage + iChange);

		setHealAsDamage(eHealAsType, range(iNewValue, 0, getMaxHP()), ePlayer);

		FASSERT_NOT_NEGATIVE(info->m_iHealAsDamage);
	}
}

void CvUnit::setHealAsDamage(UnitCombatTypes eHealAsType, int iNewValue, PlayerTypes ePlayer, bool bNotifyEntity)
{
	PROFILE_EXTRA_FUNC();
	FASSERT_BOUNDS(0, GC.getNumUnitCombatInfos(), eHealAsType);

	UnitCombatKeyedInfo* info = findOrCreateUnitCombatKeyedInfo(eHealAsType);

	info->m_iHealAsDamage = range(iNewValue, 0, getMaxHP());

	int iHighestDamage = 0;
	for (int iI = 0; iI < m_pUnitInfo->getNumHealAsTypes(); iI++)
	{
		const UnitCombatKeyedInfo* info2 = findOrCreateUnitCombatKeyedInfo((UnitCombatTypes)m_pUnitInfo->getHealAsType(iI));
		if (info2->m_iHealAsDamage > iHighestDamage)
		{
			iHighestDamage = info2->m_iHealAsDamage;
		}
	}
	if (iHighestDamage != getDamage())
	{
		setDamage(iHighestDamage, ePlayer, bNotifyEntity, NO_UNITCOMBAT, true);
	}
	FASSERT_NOT_NEGATIVE(info->m_iHealAsDamage);
}

int CvUnit::getDamagePercent() const
{
	return 100 * m_iDamage / getMaxHP();
}

void CvUnit::setupPreCombatDamage()
{
	m_iPreCombatDamage = m_iDamage;
}

int CvUnit::getPreCombatDamage() const
{
	return m_iPreCombatDamage;
}

void CvUnit::setDamage(int iNewValue, PlayerTypes ePlayer, bool bNotifyEntity, UnitCombatTypes eHealAsType, bool bSecondPass)
{
	PROFILE_EXTRA_FUNC();
	const int iOldValue = getDamage();

	if (eHealAsType == NO_UNITCOMBAT && !bSecondPass && m_pUnitInfo->getNumHealAsTypes() > 0)
	{
		for (int iI = 0; iI < m_pUnitInfo->getNumHealAsTypes(); iI++)
		{
			setHealAsDamage((UnitCombatTypes)m_pUnitInfo->getHealAsType(iI), iNewValue, ePlayer, bNotifyEntity);
		}
	}
	else if (eHealAsType != NO_UNITCOMBAT && m_pUnitInfo->getNumHealAsTypes() > 0)
	{
		setHealAsDamage(eHealAsType, iNewValue, ePlayer, bNotifyEntity);
	}
	else
	{
		m_iDamage = range(iNewValue, 0, getMaxHP());

		if (iOldValue != getDamage())
		{
			if (GC.getGame().isFinalInitialized() && bNotifyEntity)
			{
				NotifyEntity(MISSION_DAMAGE);
			}

			setInfoBarDirty(true);

			if (IsSelected())
			{
				gDLL->getInterfaceIFace()->setDirty(InfoPane_DIRTY_BIT, true);
			}

			if (plot() == gDLL->getInterfaceIFace()->getSelectionPlot())
			{
				gDLL->getInterfaceIFace()->setDirty(PlotListButtons_DIRTY_BIT, true);
			}
		}
	}
	FAssertMsg(getHP() >= 0, "getHP() is expected to be non-negative (invalid Index)");

	if (isDead())
	{
		kill(true, ePlayer);
	}
}


void CvUnit::changeDamage(int iChange, PlayerTypes ePlayer, UnitCombatTypes eHealAsType)
{
	PROFILE_EXTRA_FUNC();
	if (eHealAsType == NO_UNITCOMBAT && m_pUnitInfo->getNumHealAsTypes() > 0)
	{
		for (int iI = 0; iI < m_pUnitInfo->getNumHealAsTypes(); iI++)
		{
			changeHealAsDamage((UnitCombatTypes)m_pUnitInfo->getHealAsType(iI), iChange, ePlayer);
		}
	}
	else if (m_pUnitInfo->getNumHealAsTypes() > 0)
	{
		changeHealAsDamage(eHealAsType, iChange, ePlayer);
	}
	else setDamage(getDamage() + iChange, ePlayer);
}

void CvUnit::changeDamagePercent(int iChange, PlayerTypes ePlayer)
{
	setDamage((getDamagePercent() + iChange) * getMaxHP() / 100, ePlayer);
}


int CvUnit::getMoves() const
{
	return m_iMoves;
}


void CvUnit::setMoves(int iNewValue)
{
	if (m_iMoves != iNewValue)
	{
		CvPlot* pPlot = plot();

		m_iMoves = iNewValue;

		FASSERT_NOT_NEGATIVE(m_iMoves);

		if (pPlot && getTeam() == GC.getGame().getActiveTeam())
		{
			pPlot->setFlagDirty(true);
		}

		if (IsSelected())
		{
			if (canMove())
			{
				gDLL->getFAStarIFace()->ForceReset(&GC.getInterfacePathFinder());
				gDLL->getInterfaceIFace()->setDirty(InfoPane_DIRTY_BIT, true);
			}
			/* Toffer - make it a bug option - Unselect units upon expending all movement points.
			else if (getGroup()->canAnyMove())
			{
				gDLL->getInterfaceIFace()->removeFromSelectionList(this);
			}
			*/
		}

		if (pPlot == gDLL->getInterfaceIFace()->getSelectionPlot())
		{
			gDLL->getInterfaceIFace()->setDirty(PlotListButtons_DIRTY_BIT, true);
		}
	}
}


void CvUnit::changeMoves(int iChange)
{
	setMoves(m_iMoves + iChange);
}


void CvUnit::finishMoves()
{
	setMoves(maxMoves());
}


int CvUnit::getExperience100() const
{
	return m_iExperience;
}

void CvUnit::setExperience100(int iNewValue)
{
	if (iNewValue < 0) return; // Integer overflow protection

	if (m_iExperience != iNewValue)
	{
		m_iExperience = iNewValue;

		if (IsSelected())
		{
			gDLL->getInterfaceIFace()->setDirty(InfoPane_DIRTY_BIT, true);
		}
	}
}

void CvUnit::changeExperience100(int iChange, int iMax, bool bFromCombat, bool bInBorders, bool bUpdateGlobal)
{
	if (bFromCombat)
	{
		if (iChange < 1) return; // Never lose xp from battle.

		CvPlayer& kPlayer = GET_PLAYER(getOwner());

		int iMod = getExperiencePercent();
		int iModGG = kPlayer.getGreatGeneralRateModifier();

		if (bInBorders)
		{
			iMod += kPlayer.getExpInBorderModifier();
			iModGG += kPlayer.getDomesticGreatGeneralRateModifier() + kPlayer.getExpInBorderModifier();
		}
		iChange = getModifiedIntValue(iChange, iMod);

		if (bUpdateGlobal)
		{
			kPlayer.changeFractionalCombatExperience(getModifiedIntValue(iChange, iModGG), getGGExperienceEarnedTowardsType());
		}

		if (getUsedCommander())
		{
			getUsedCommander()->changeExperience100(60, iMax); //0.6 xp every time, make global define?
			m_iUsedCommanderID = -1;
		}

		if (getUsedCommodore())
        {
        	getUsedCommodore()->changeExperience100(60, iMax); //0.6 xp every time, make global define?
        	m_iUsedCommodoreID = -1;
        }
	}
	if (iChange == 0)
	{
		return;
	}
	// Toffer - Maybe its redundant to support XP reductions with this function?
	//	However, I do like to be thorough, so here goes.
	if (iMax > -1)
	{
		if (iChange > 0)
		{
			if (getExperience100() >= iMax)
			{
				return;
			}
			if (getExperience100() + iChange >= iMax)
			{
				setExperience100(iMax);
				return;
			}
		}
		else // Reduction, and iMax is then considered a iMin value.
		{
			if (getExperience100() <= iMax)
			{
				return;
			}
			if (getExperience100() + iChange <= iMax)
			{
				setExperience100(iMax);
				return;
			}
		}
	}
	setExperience100(getExperience100() + iChange);
}

int CvUnit::getExperience() const
{
	return getExperience100() / 100;
}

void CvUnit::setExperience(int iNewValue)
{
	setExperience100(iNewValue * 100);
}

void CvUnit::changeExperience(int iChange, int iMax, bool bFromCombat, bool bInBorders, bool bUpdateGlobal)
{
	changeExperience100(iChange * 100, iMax * 100, bFromCombat, bInBorders, bUpdateGlobal);
}


int CvUnit::getLevel() const
{
	return m_iLevel;
}

void CvUnit::setLevel(int iNewValue)
{
	FAssert(iNewValue > 0);

	if (m_iLevel != iNewValue)
	{
		m_iLevel = iNewValue;

		if (iNewValue > GET_PLAYER(getOwner()).getHighestUnitLevel())
		{
			GET_PLAYER(getOwner()).setHighestUnitLevel(iNewValue);
		}

		if (IsSelected())
		{
			gDLL->getInterfaceIFace()->setDirty(InfoPane_DIRTY_BIT, true);
		}
	}
}

void CvUnit::changeLevel(int iChange)
{
	setLevel(getLevel() + iChange);
}

int CvUnit::getCargo() const
{
	return m_iCargo;
}

int CvUnit::SMgetCargo() const
{
	return m_iSMCargo;
}

void CvUnit::changeCargo(int iChange)
{
	m_iCargo += iChange;
	FAssertRecalcMsg(getCargo() >= 0, "Transported units is less than 0");
}

void CvUnit::SMchangeCargo(int iChange)
{
	m_iSMCargo += iChange;
	FAssertOptionRecalcMsg(GAMEOPTION_COMBAT_SIZE_MATTERS, SMgetCargo() >= 0, "Transported cargo is less than 0");
}

void CvUnit::getCargoUnits(std::vector<CvUnit*>& aUnits) const
{
	PROFILE_EXTRA_FUNC();
	aUnits.clear();

#if FASSERT_ENABLE
	int iCheck = 0;
#endif
	if (hasCargo())
	{
		foreach_(CvUnit* pLoopUnit, plot()->units())
		{
			if (pLoopUnit->getTransportUnit() == this)
			{
				aUnits.push_back(pLoopUnit);
#if FASSERT_ENABLE
				if (GC.getGame().isOption(GAMEOPTION_COMBAT_SIZE_MATTERS))
				{
					iCheck += pLoopUnit->SMCargoVolume();
				}
				else
				{
					iCheck++;
				}
#endif
			}
		}
	}

	FAssertOptionRecalcMsg(GAMEOPTION_COMBAT_SIZE_MATTERS, SMgetCargo() == iCheck, "Cargo size doesn't match expectations");
	FAssertRecalcMsg(getCargo() == aUnits.size(), "Number of cargo units found doesn't match cached number");
}

void CvUnit::validateCargoUnits()
{
	PROFILE_EXTRA_FUNC();
#if FASSERT_ENABLE
	int iCheck = 0;
	int iCount = 0;
	const CvPlot* pPlot = plot();

	if (hasCargo())
	{
		foreach_(const CvUnit* pLoopUnit, pPlot->units())
		{
			if (pLoopUnit->getTransportUnit() == this)
			{
				if (GC.getGame().isOption(GAMEOPTION_COMBAT_SIZE_MATTERS))
				{
					iCheck += pLoopUnit->SMCargoVolume();
					iCount++;
				}
				else
				{
					iCheck++;
					iCount++;
				}
			}
		}
	}

	if (GC.getGame().isOption(GAMEOPTION_COMBAT_SIZE_MATTERS))
	{
		//TB: Backend cleanup - Assert is coming up and we have ghost loads so this is a quickfix only - still evaluating to see how this takes place
		if (SMgetCargo() != iCheck)
		{
			FErrorMsg("Load Volume is incorrect");
			m_iSMCargo = 0;
			foreach_(const CvUnit* pLoopUnit, pPlot->units())
			{
				if (pLoopUnit->getTransportUnit() == this)
				{
					SMchangeCargo(pLoopUnit->SMCargoVolume());
				}
			}
			//rerun check
			iCheck = 0;
			iCount = 0;
			foreach_(const CvUnit* pLoopUnit, pPlot->units())
			{
				if (pLoopUnit->getTransportUnit() == this)
				{
					if (GC.getGame().isOption(GAMEOPTION_COMBAT_SIZE_MATTERS))
					{
						iCheck += pLoopUnit->SMCargoVolume();
						iCount++;
					}
					else
					{
						iCheck++;
						iCount++;
					}
				}
			}
			if (SMgetCargo() != iCheck)
			{
				FErrorMsg("Load Volume is incorrect");//If this persists, then the problem is due to having a unit that's not sharing the same plot being loaded onto the transport.
				std::vector<CvUnit*> aCargoUnits;
				getCargoUnits(aCargoUnits);
				foreach_(CvUnit* pCargo, aCargoUnits)
				{
					pCargo->setTransportUnit(NULL);
					if (pCargo->plot() == plot())
					{
						pCargo->setTransportUnit(this);
					}
				}
				m_iSMCargo = 0;
				iCount = 0;
				foreach_(const CvUnit* pCargo, aCargoUnits)
				{
					SMchangeCargo(pCargo->SMCargoVolume());
					iCount++;
				}
			}
		}
	}
	else
	{
		FAssert(iCheck == iCount);
	}
	FAssert(getCargo() == iCount);
#endif
}

CvPlot* CvUnit::getAttackPlot() const
{
	return GC.getMap().plotSorenINLINE(m_iAttackPlotX, m_iAttackPlotY);
}


void CvUnit::setAttackPlot(const CvPlot* pNewValue, bool bAirCombat)
{
	if (getAttackPlot() != pNewValue)
	{
		if (pNewValue)
		{
			m_iAttackPlotX = pNewValue->getX();
			m_iAttackPlotY = pNewValue->getY();
		}
		else
		{
			m_iAttackPlotX = INVALID_PLOT_COORD;
			m_iAttackPlotY = INVALID_PLOT_COORD;
		}
	}

	m_bAirCombat = bAirCombat;
}

bool CvUnit::isAirCombat() const
{
	return m_bAirCombat;
}

int CvUnit::getCombatTimer() const
{
	return m_iCombatTimer;
}

void CvUnit::setCombatTimer(int iNewValue)
{
	m_iCombatTimer = iNewValue;
	FASSERT_NOT_NEGATIVE(getCombatTimer());
}

void CvUnit::changeCombatTimer(int iChange)
{
	setCombatTimer(getCombatTimer() + iChange);
}

int CvUnit::getCombatFirstStrikes() const
{
	return m_iCombatFirstStrikes;
}

void CvUnit::setCombatFirstStrikes(int iNewValue)
{
	m_iCombatFirstStrikes = iNewValue;
	FASSERT_NOT_NEGATIVE(getCombatFirstStrikes());
}

void CvUnit::changeCombatFirstStrikes(int iChange)
{
	setCombatFirstStrikes(getCombatFirstStrikes() + iChange);
}

int CvUnit::getFortifyTurns() const
{
	return m_iFortifyTurns;
}

void CvUnit::setFortifyTurns(int iNewValue)
{
	const int iMaxFortify = GC.getDefineINT("MAX_FORTIFY_TURNS");

	iNewValue = range(iNewValue, 0, iMaxFortify);

	if (iNewValue != m_iFortifyTurns)
	{
		m_iFortifyTurns = iNewValue;
		setInfoBarDirty(true);

		if (iNewValue == 0 && isBuildUp())
		{
			clearBuildups();
		}
	}
}

int CvUnit::getBlitzCount() const
{
	return m_iBlitzCount;
}

bool CvUnit::isBlitz() const
{
	return m_iBlitzCount > 0;
}

void CvUnit::changeBlitzCount(int iChange)
{
	m_iBlitzCount += iChange;
	FASSERT_NOT_NEGATIVE(m_iBlitzCount);
}

int CvUnit::getAmphibCount() const
{
	return m_iAmphibCount;
}

bool CvUnit::isAmphib() const
{
	return (getAmphibCount() > 0 || canFliesToMove());
}

void CvUnit::changeAmphibCount(int iChange)
{
	m_iAmphibCount += iChange;
	FASSERT_NOT_NEGATIVE(getAmphibCount());
}

int CvUnit::getRiverCount() const
{
	return m_iRiverCount;
}

bool CvUnit::isRiver() const
{
	return (getRiverCount() > 0 || canFliesToMove());
}

void CvUnit::changeRiverCount(int iChange)
{
	m_iRiverCount += iChange;
	FASSERT_NOT_NEGATIVE(getRiverCount());
}

int CvUnit::getEnemyRouteCount() const
{
	return m_iEnemyRouteCount;
}

bool CvUnit::isEnemyRoute() const
{
	return getEnemyRouteCount() > 0;
}

void CvUnit::changeEnemyRouteCount(int iChange)
{
	m_iEnemyRouteCount += iChange;
	FASSERT_NOT_NEGATIVE(getEnemyRouteCount());
}

int CvUnit::getAlwaysHealCount() const
{
	return m_iAlwaysHealCount;
}

bool CvUnit::isAlwaysHeal() const
{
	return (getAlwaysHealCount() > 0);
}

void CvUnit::changeAlwaysHealCount(int iChange)
{
	m_iAlwaysHealCount += iChange;
	FASSERT_NOT_NEGATIVE(getAlwaysHealCount());
}

int CvUnit::getHillsDoubleMoveCount() const
{
	return m_iHillsDoubleMoveCount;
}

bool CvUnit::isHillsDoubleMove() const
{
	return (getHillsDoubleMoveCount() > 0);
}

void CvUnit::changeHillsDoubleMoveCount(int iChange)
{
	m_iHillsDoubleMoveCount += iChange;
	FASSERT_NOT_NEGATIVE(getHillsDoubleMoveCount());
}

int CvUnit::getImmuneToFirstStrikesCount() const
{
	return m_iImmuneToFirstStrikesCount;
}

void CvUnit::changeImmuneToFirstStrikesCount(int iChange)
{
	m_iImmuneToFirstStrikesCount += iChange;
	FASSERT_NOT_NEGATIVE(getImmuneToFirstStrikesCount());
}


int CvUnit::getAlwaysInvisibleCount() const
{
	return m_iAlwaysInvisibleCount;
}

void CvUnit::changeAlwaysInvisibleCount(int iChange)
{
	m_iAlwaysInvisibleCount += iChange;
	FASSERT_NOT_NEGATIVE(getAlwaysInvisibleCount());
}


int CvUnit::getDefensiveVictoryMoveCount() const
{
	return m_iDefensiveVictoryMoveCount;
}

bool CvUnit::isDefensiveVictoryMove() const
{
	return (getDefensiveVictoryMoveCount() > 0);
}

void CvUnit::changeDefensiveVictoryMoveCount(int iChange)
{
	m_iDefensiveVictoryMoveCount += iChange;
	FASSERT_NOT_NEGATIVE(getDefensiveVictoryMoveCount());
}


int CvUnit::getFreeDropCount() const
{
	return m_iFreeDropCount;
}

bool CvUnit::isFreeDrop() const
{
	return (getFreeDropCount() > 0);
}

void CvUnit::changeFreeDropCount(int iChange)
{
	m_iFreeDropCount += iChange;
	FASSERT_NOT_NEGATIVE(getFreeDropCount());
}


int CvUnit::getOffensiveVictoryMoveCount() const
{
	return m_iOffensiveVictoryMoveCount;
}

bool CvUnit::isOffensiveVictoryMove() const
{
	return (getOffensiveVictoryMoveCount() > 0);
}

void CvUnit::changeOffensiveVictoryMoveCount(int iChange)
{
	m_iOffensiveVictoryMoveCount += iChange;
	FASSERT_NOT_NEGATIVE(getOffensiveVictoryMoveCount());
}


int CvUnit::getOneUpCount() const
{
	return m_iOneUpCount;
}

bool CvUnit::isOneUp() const
{
	return getOneUpCount() > 0;
}

void CvUnit::changeOneUpCount(int iChange)
{
	m_iOneUpCount += iChange;
	FASSERT_NOT_NEGATIVE(getOneUpCount());
}

int CvUnit::getPillageEspionageCount() const
{
	return m_iPillageEspionageCount;
}

bool CvUnit::isPillageEspionage() const
{
	return getPillageEspionageCount() > 0;
}

void CvUnit::changePillageEspionageCount(int iChange)
{
	m_iPillageEspionageCount += iChange;
	FASSERT_NOT_NEGATIVE(getPillageEspionageCount());
}


int CvUnit::getPillageMarauderCount() const
{
	return m_iPillageMarauderCount;
}

bool CvUnit::isPillageMarauder() const
{
	return getPillageMarauderCount() > 0;
}

void CvUnit::changePillageMarauderCount(int iChange)
{
	m_iPillageMarauderCount += iChange;
	FASSERT_NOT_NEGATIVE(getPillageMarauderCount());
}


int CvUnit::getPillageOnMoveCount() const
{
	return m_iPillageOnMoveCount;
}

bool CvUnit::isPillageOnMove() const
{
	return getPillageOnMoveCount() > 0 && !isCargo();
}

void CvUnit::changePillageOnMoveCount(int iChange)
{
	m_iPillageOnMoveCount += iChange;
	FASSERT_NOT_NEGATIVE(getPillageOnMoveCount());
}


int CvUnit::getPillageOnVictoryCount() const
{
	return m_iPillageOnVictoryCount;
}

bool CvUnit::isPillageOnVictory() const
{
	return getPillageOnVictoryCount() > 0;
}

void CvUnit::changePillageOnVictoryCount(int iChange)
{
	m_iPillageOnVictoryCount += iChange;
	FASSERT_NOT_NEGATIVE(getPillageOnVictoryCount());
}


int CvUnit::getPillageResearchCount() const
{
	return m_iPillageResearchCount;
}

bool CvUnit::isPillageResearch() const
{
	return (getPillageResearchCount() > 0);
}

void CvUnit::changePillageResearchCount(int iChange)
{
	m_iPillageResearchCount += iChange;
	FASSERT_NOT_NEGATIVE(getPillageResearchCount());
}


int CvUnit::getAirCombatLimitChange() const
{
	return m_iAirCombatLimitChange;
}

void CvUnit::changeAirCombatLimitChange(int iChange)
{
	if (iChange != 0)
	{
		m_iAirCombatLimitChange += iChange;

		setInfoBarDirty(true);
	}
}

int CvUnit::getCelebrityHappy() const
{
	return m_iCelebrityHappy;
}

void CvUnit::changeCelebrityHappy(int iChange)
{
	if (iChange != 0)
	{
		m_iCelebrityHappy += iChange;

		setInfoBarDirty(true);
	}
}

int CvUnit::getCollateralDamageLimitChange() const
{
	return m_iCollateralDamageLimitChange;
}

void CvUnit::changeCollateralDamageLimitChange(int iChange)
{
	if (iChange != 0)
	{
		m_iCollateralDamageLimitChange += iChange;

		setInfoBarDirty(true);
	}
}

int CvUnit::getCollateralDamageMaxUnitsChange() const
{
	return m_iCollateralDamageMaxUnitsChange;
}

void CvUnit::changeCollateralDamageMaxUnitsChange(int iChange)
{
	if (iChange != 0)
	{
		m_iCollateralDamageMaxUnitsChange += iChange;

		setInfoBarDirty(true);
	}
}

int CvUnit::getCombatLimitChange() const
{
	return m_iCombatLimitChange;
}

void CvUnit::changeCombatLimitChange(int iChange)
{
	if (iChange != 0)
	{
		m_iCombatLimitChange += iChange;

		setInfoBarDirty(true);
	}
}

int CvUnit::getExtraDropRange() const
{
	return m_iExtraDropRange;
}

void CvUnit::changeExtraDropRange(int iChange)
{
	if (iChange != 0)
	{
		m_iExtraDropRange += iChange;

		setInfoBarDirty(true);
	}
}

int CvUnit::getSurvivorChance() const
{
	return m_iSurvivorChance;
}

void CvUnit::changeSurvivorChance(int iChange)
{
	if (iChange != 0)
	{
		m_iSurvivorChance += iChange;

		setInfoBarDirty(true);
	}
}

int CvUnit::getVictoryAdjacentHeal() const
{
	return m_iVictoryAdjacentHeal;
}

void CvUnit::changeVictoryAdjacentHeal(int iChange)
{
	if (iChange != 0)
	{
		m_iVictoryAdjacentHeal += iChange;

		setInfoBarDirty(true);
	}
}

int CvUnit::getVictoryHeal() const
{
	return m_iVictoryHeal;
}

void CvUnit::changeVictoryHeal(int iChange)
{
	if (iChange != 0)
	{
		m_iVictoryHeal += iChange;

		setInfoBarDirty(true);
	}
}

int CvUnit::getVictoryStackHeal() const
{
	return m_iVictoryStackHeal;
}

void CvUnit::changeVictoryStackHeal(int iChange)
{
	if (iChange != 0)
	{
		m_iVictoryStackHeal += iChange;

		setInfoBarDirty(true);
	}
}


int CvUnit::getExtraVisibilityRange() const
{
	if (!isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander)
		{
			return m_iExtraVisibilityRange + pCommander->m_iExtraVisibilityRange;
		}
	}
	if (!isCommodore())
    	{
    		const CvUnit* pCommodore = getCommodore();
    		if (pCommodore)
    		{
    			return m_iExtraVisibilityRange + pCommodore->m_iExtraVisibilityRange;
    		}
    	}
	return m_iExtraVisibilityRange;
}

void CvUnit::changeExtraVisibilityRange(int iChange)
{
	if (iChange != 0)
	{
		if (plot() != NULL)
		{
			plot()->changeAdjacentSight(getTeam(), visibilityRange(plot()), false, this, false);
			changeDebugCount(-1);
		}

		m_iExtraVisibilityRange += iChange;
		FASSERT_NOT_NEGATIVE(getExtraVisibilityRange());

		if (plot() != NULL)
		{
			plot()->changeAdjacentSight(getTeam(), visibilityRange(plot()), true, this, false);
			changeDebugCount(1);
		}
	}
}

int CvUnit::getExtraMoves() const
{
	if (!isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander)
		{
			return m_iExtraMoves + pCommander->m_iExtraMoves;
		}
	}
	if (!isCommodore())
    	{
    		const CvUnit* pCommodore = getCommodore();
    		if (pCommodore)
    		{
    			return m_iExtraMoves + pCommodore->m_iExtraMoves;
    		}
    	}
	return m_iExtraMoves;
}

void CvUnit::changeExtraMoves(int iChange)
{
	m_iExtraMoves += iChange;
	m_iMaxMoveCacheTurn--;

	FASSERT_NOT_NEGATIVE(m_iExtraMoves);
}

int CvUnit::getExtraMoveDiscount() const
{
	if (!isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander)
		{
			return m_iExtraMoveDiscount + pCommander->m_iExtraMoveDiscount;
		}
	}
	if (!isCommodore())
    	{
    		const CvUnit* pCommodore = getCommodore();
    		if (pCommodore)
    		{
    			return m_iExtraMoveDiscount + pCommodore->m_iExtraMoveDiscount;
    		}
    	}
	return m_iExtraMoveDiscount;
}

void CvUnit::changeExtraMoveDiscount(int iChange)
{
	m_iExtraMoveDiscount += iChange;
	FASSERT_NOT_NEGATIVE(m_iExtraMoveDiscount);
}


int CvUnit::getExtraAirRange() const
{
	if (!isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander)
		{
			return m_iExtraAirRange + pCommander->m_iExtraAirRange;
		}
	}
	if (!isCommodore())
    	{
    		const CvUnit* pCommodore = getCommodore();
    		if (pCommodore)
    		{
    			return m_iExtraAirRange + pCommodore->m_iExtraAirRange;
    		}
    	}

	return m_iExtraAirRange;
}

void CvUnit::changeExtraAirRange(int iChange)
{
	m_iExtraAirRange += iChange;
}

int CvUnit::getExtraIntercept(bool bIgnoreCommanders, bool bIgnoreCommodores) const
{
	if (!bIgnoreCommanders && !isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander)
		{
			return m_iExtraIntercept + pCommander->m_iExtraIntercept;
		}
	}
	if (!bIgnoreCommodores && !isCommodore())
    	{
    		const CvUnit* pCommodore = getCommodore();
    		if (pCommodore)
    		{
    			return m_iExtraIntercept + pCommodore->m_iExtraIntercept;
    		}
    	}
	return m_iExtraIntercept;
}

void CvUnit::changeExtraIntercept(int iChange)
{
	m_iExtraIntercept += iChange;
}

int CvUnit::getExtraEvasion(bool bIgnoreCommanders, bool bIgnoreCommodores) const
{
	if (!bIgnoreCommanders && !isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander)
		{
			return m_iExtraEvasion + pCommander->m_iExtraEvasion;
		}
	}
	if (!bIgnoreCommodores && !isCommodore())
    	{
    		const CvUnit* pCommodore = getCommodore();
    		if (pCommodore)
    		{
    			return m_iExtraEvasion + pCommodore->m_iExtraEvasion;
    		}
    	}
	return m_iExtraEvasion;
}

void CvUnit::changeExtraEvasion(int iChange)
{
	m_iExtraEvasion += iChange;
}

int CvUnit::getExtraFirstStrikes() const
{
	if (!isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander)
		{
			return std::max(0, m_iExtraFirstStrikes + pCommander->getExtraFirstStrikes());
		}
	}
	if (!isCommodore())
    	{
    		const CvUnit* pCommodore = getCommodore();
    		if (pCommodore)
    		{
    			return std::max(0, m_iExtraFirstStrikes + pCommodore->getExtraFirstStrikes());
    		}
    	}
	return std::max(0, m_iExtraFirstStrikes);
}

void CvUnit::changeExtraFirstStrikes(int iChange)
{
	m_iExtraFirstStrikes += iChange;
}

int CvUnit::getExtraChanceFirstStrikes() const
{
	if (!isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander)
		{
			return std::max(0, m_iExtraChanceFirstStrikes + pCommander->getExtraChanceFirstStrikes());
		}
	}
	if (!isCommodore())
    	{
    		const CvUnit* pCommodore = getCommodore();
    		if (pCommodore)
    		{
    			return std::max(0, m_iExtraChanceFirstStrikes + pCommodore->getExtraChanceFirstStrikes());
    		}
    	}
	return std::max(0, m_iExtraChanceFirstStrikes);
}

void CvUnit::changeExtraChanceFirstStrikes(int iChange)
{
	m_iExtraChanceFirstStrikes += iChange;
}

int CvUnit::getExtraWithdrawal(bool bIgnoreCommanders, bool bIgnoreCommodores) const
{
	if (!bIgnoreCommanders && !isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander)
		{
			return m_iExtraWithdrawal + pCommander->m_iExtraWithdrawal;
		}
	}
	if (!bIgnoreCommodores && !isCommodore())
    	{
    		const CvUnit* pCommodore = getCommodore();
    		if (pCommodore)
    		{
    			return m_iExtraWithdrawal + pCommodore->m_iExtraWithdrawal;
    		}
    	}
	return m_iExtraWithdrawal;
}

void CvUnit::changeExtraWithdrawal(int iChange)
{
	m_iExtraWithdrawal += iChange;
}

//TB Combat Mods Begin
int CvUnit::getExtraAttackCombatModifier(bool bIgnoreCommanders, bool bIgnoreCommodores) const
{
	if (!bIgnoreCommanders && !isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander)
		{
			return m_iExtraAttackCombatModifier + pCommander->m_iExtraAttackCombatModifier;
		}
	}
	if (!bIgnoreCommodores && !isCommodore())
    	{
    		const CvUnit* pCommodore = getCommodore();
    		if (pCommodore)
    		{
    			return m_iExtraAttackCombatModifier + pCommodore->m_iExtraAttackCombatModifier;
    		}
    	}
	return m_iExtraAttackCombatModifier;
}

void CvUnit::changeExtraAttackCombatModifier(int iChange)
{
	m_iExtraAttackCombatModifier +=iChange;
}

int CvUnit::getExtraDefenseCombatModifier(bool bIgnoreCommanders, bool bIgnoreCommodores) const
{
	if (noDefensiveBonus())
	{
		return 0;
	}
	if (!bIgnoreCommanders && !isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander)
		{
			return m_iExtraDefenseCombatModifier + pCommander->m_iExtraDefenseCombatModifier;
		}
	}
	if (!bIgnoreCommodores && !isCommodore())
    	{
    		const CvUnit* pCommodore = getCommodore();
    		if (pCommodore)
    		{
    			return m_iExtraDefenseCombatModifier + pCommodore->m_iExtraDefenseCombatModifier;
    		}
    	}
	return m_iExtraDefenseCombatModifier;
}

void CvUnit::changeExtraDefenseCombatModifier(int iChange)
{
	m_iExtraDefenseCombatModifier +=iChange;
}

int CvUnit::getExtraPursuit(bool bIgnoreCommanders, bool bIgnoreCommodores) const
{
	if (!bIgnoreCommanders && !isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander)
		{
			return m_iExtraPursuit + pCommander->m_iExtraPursuit;
		}
	}
	if (!bIgnoreCommodores && !isCommodore())
    	{
    		const CvUnit* pCommodore = getCommodore();
    		if (pCommodore)
    		{
    			return m_iExtraPursuit + pCommodore->m_iExtraPursuit;
    		}
    	}
	return m_iExtraPursuit;
}

void CvUnit::changeExtraPursuit(int iChange)
{
	m_iExtraPursuit +=iChange;
}

int CvUnit::getExtraEarlyWithdraw(bool bIgnoreCommanders, bool bIgnoreCommodores) const
{
	if (!bIgnoreCommanders && !isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander)
		{
			return m_iExtraEarlyWithdraw + pCommander->m_iExtraEarlyWithdraw;
		}
	}
	if (!bIgnoreCommodores && !isCommodore())
    	{
    		const CvUnit* pCommodore = getCommodore();
    		if (pCommodore)
    		{
    			return m_iExtraEarlyWithdraw + pCommodore->m_iExtraEarlyWithdraw;
    		}
    	}
	return m_iExtraEarlyWithdraw;
}

void CvUnit::changeExtraEarlyWithdraw(int iChange)
{
	m_iExtraEarlyWithdraw +=iChange;
}

int CvUnit::getExtraVSBarbs(bool bIgnoreCommanders, bool bIgnoreCommodores) const
{
	if (!bIgnoreCommanders && !isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander)
		{
			return m_iExtraVSBarbs + pCommander->m_iExtraVSBarbs;
		}
	}
	if (!bIgnoreCommodores && !isCommodore())
    	{
    		const CvUnit* pCommodore = getCommodore();
    		if (pCommodore)
    		{
    			return m_iExtraVSBarbs + pCommodore->m_iExtraVSBarbs;
    		}
    	}
	return m_iExtraVSBarbs;
}

void CvUnit::changeExtraVSBarbs(int iChange)
{
	m_iExtraVSBarbs += iChange;
	FASSERT_NOT_NEGATIVE(m_iExtraVSBarbs);
}

int CvUnit::getExtraReligiousCombatModifier(bool bIgnoreCommanders, bool bIgnoreCommodores) const
{
	if (!bIgnoreCommanders && !isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander)
		{
			return m_iExtraReligiousCombatModifier + pCommander->m_iExtraReligiousCombatModifier;
		}
	}
	if (!bIgnoreCommodores && !isCommodore())
    	{
    		const CvUnit* pCommodore = getCommodore();
    		if (pCommodore)
    		{
    			return m_iExtraReligiousCombatModifier + pCommodore->m_iExtraReligiousCombatModifier;
    		}
    	}
	return m_iExtraReligiousCombatModifier;
}

void CvUnit::changeExtraReligiousCombatModifier(int iChange)
{
	m_iExtraReligiousCombatModifier += iChange;
}

int CvUnit::getExtraArmor(bool bIgnoreCommanders, bool bIgnoreCommodores) const
{
	if (!bIgnoreCommanders && !isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander)
		{
			return std::max(0, m_iExtraArmor + pCommander->m_iExtraArmor);
		}
	}
	if (!bIgnoreCommodores && !isCommodore())
    	{
    		const CvUnit* pCommodore = getCommodore();
    		if (pCommodore)
    		{
    			return std::max(0, m_iExtraArmor + pCommodore->m_iExtraArmor);
    		}
    	}
	return std::max(0, m_iExtraArmor);
}

void CvUnit::changeExtraArmor(int iChange)
{
	m_iExtraArmor += iChange;
}

int CvUnit::getExtraPuncture(bool bIgnoreCommanders, bool bIgnoreCommodores) const
{
	if (!bIgnoreCommanders && !isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander)
		{
			return std::max(0, m_iExtraPuncture + pCommander->getExtraPuncture());
		}
	}
	if (!bIgnoreCommodores && !isCommodore())
    	{
    		const CvUnit* pCommodore = getCommodore();
    		if (pCommodore)
    		{
    			return std::max(0, m_iExtraPuncture + pCommodore->getExtraPuncture());
    		}
    	}
	return std::max(0, m_iExtraPuncture);
}

void CvUnit::changeExtraPuncture(int iChange)
{
	m_iExtraPuncture += iChange;
}

int CvUnit::getExtraDamageModifier(bool bIgnoreCommanders, bool bIgnoreCommodores) const
{
	if (!bIgnoreCommanders && !isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander)
		{
			return m_iExtraDamageModifier + pCommander->m_iExtraDamageModifier;
		}
	}
	if (!bIgnoreCommodores && !isCommodore())
    	{
    		const CvUnit* pCommodore = getCommodore();
    		if (pCommodore)
    		{
    			return m_iExtraDamageModifier + pCommodore->m_iExtraDamageModifier;
    		}
    	}
	return m_iExtraDamageModifier;
}

void CvUnit::changeExtraDamageModifier(int iChange)
{
	m_iExtraDamageModifier += iChange;
}

// Toffer - Upkeep
void CvUnit::changeExtraUpkeep100(const int iChange)
{
	if (iChange != 0)
	{
		m_iExtraUpkeep100 += iChange;
		calcUpkeep100();
	}
}

int CvUnit::getExtraUpkeep100() const
{
	return m_iExtraUpkeep100;
}

void CvUnit::changeUpkeepModifier(const int iChange)
{
	if (iChange != 0)
	{
		m_iUpkeepModifier += iChange;
		calcUpkeep100();
	}
}

int CvUnit::getUpkeepModifier() const
{
	return m_iUpkeepModifier;
}

int CvUnit::getUpkeepMultiplierSM() const
{
	return m_iUpkeepMultiplierSM;
}

void CvUnit::calcUpkeepMultiplierSM(const int iGroupOffset)
{
	PROFILE_EXTRA_FUNC();
	m_iUpkeepMultiplierSM = 0;

	if (iGroupOffset > 0)
	{
		for (int iI = 0; iI < iGroupOffset; iI++)
		{
			m_iUpkeepMultiplierSM = (100 + m_iUpkeepMultiplierSM) * 150 / 100 - 100;
		}
	}
	else if (iGroupOffset < 0)
	{
		for (int iI = 0; iI < -iGroupOffset; iI++)
		{
			m_iUpkeepMultiplierSM = (100 + m_iUpkeepMultiplierSM) * 150 / 100 - 100;
		}
		m_iUpkeepMultiplierSM = -m_iUpkeepMultiplierSM;
	}
	calcUpkeep100();
}

void CvUnit::calcUpkeep100()
{
	if (isNPC())
	{
		return;
	}
	int iCalc = 100 * m_pUnitInfo->getBaseUpkeep() + m_iExtraUpkeep100;

	if (iCalc > 0)
	{
		iCalc = getModifiedIntValue(iCalc, m_iUpkeepModifier);
		iCalc = getModifiedIntValue(iCalc, m_iUpkeepMultiplierSM);

		const int iOldUpkeep = m_iUpkeep100;
		m_iUpkeep100 = std::max(0,  iCalc);

		// Update player total
		if (m_iUpkeep100 != iOldUpkeep)
		{
			GET_PLAYER(getOwner()).changeUnitUpkeep(m_iUpkeep100 - iOldUpkeep, isMilitaryBranch());
		}
	}
}

int CvUnit::getUpkeep100() const
{
	return m_iUpkeep100;
}

void CvUnit::recalculateUnitUpkeep()
{
	m_iUpkeep100 = 0;
	calcUpkeep100();
}
// ! Upkeep


int CvUnit::getExtraOverrun(bool bIgnoreCommanders, bool bIgnoreCommodores) const
{
	if (!bIgnoreCommanders && !isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander)
		{
			return m_iExtraOverrun + pCommander->m_iExtraOverrun;
		}
	}
	if (!bIgnoreCommodores && !isCommodore())
    	{
    		const CvUnit* pCommodore = getCommodore();
    		if (pCommodore)
    		{
    			return m_iExtraOverrun + pCommodore->m_iExtraOverrun;
    		}
    	}
	return m_iExtraOverrun;
}

void CvUnit::changeExtraOverrun(int iChange)
{
	m_iExtraOverrun += iChange;
	FASSERT_NOT_NEGATIVE(m_iExtraOverrun);
}

int CvUnit::getExtraRepel(bool bIgnoreCommanders, bool bIgnoreCommodores) const
{
	if (noDefensiveBonus())
	{
		return 0;
	}
	if (!bIgnoreCommanders && !isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander)
		{
			return m_iExtraRepel + pCommander->m_iExtraRepel;
		}
	}
	if (!bIgnoreCommodores && !isCommodore())
    	{
    		const CvUnit* pCommodore = getCommodore();
    		if (pCommodore)
    		{
    			return m_iExtraRepel + pCommodore->m_iExtraRepel;
    		}
    	}
	return m_iExtraRepel;
}

void CvUnit::changeExtraRepel(int iChange)
{
	m_iExtraRepel += iChange;
	FASSERT_NOT_NEGATIVE(m_iExtraRepel);
}

int CvUnit::getExtraFortRepel() const
{
	if (!isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander)
		{
			return m_iExtraFortRepel + pCommander->m_iExtraFortRepel;
		}
	}
	if (!isCommodore())
    	{
    		const CvUnit* pCommodore = getCommodore();
    		if (pCommodore)
    		{
    			return m_iExtraFortRepel + pCommodore->m_iExtraFortRepel;
    		}
    	}
	return m_iExtraFortRepel;
}

void CvUnit::changeExtraFortRepel(int iChange)
{
	m_iExtraFortRepel += iChange;
	FASSERT_NOT_NEGATIVE(m_iExtraFortRepel);
}

int CvUnit::getExtraRepelRetries() const
{
	if (!isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander)
		{
			return m_iExtraRepelRetries + pCommander->m_iExtraRepelRetries;
		}
	}
	if (!isCommodore())
    	{
    		const CvUnit* pCommodore = getCommodore();
    		if (pCommodore)
    		{
    			return m_iExtraRepelRetries + pCommodore->m_iExtraRepelRetries;
    		}
    	}
	return m_iExtraRepelRetries;
}

void CvUnit::changeExtraRepelRetries(int iChange)
{
	m_iExtraRepelRetries += iChange;
	FASSERT_NOT_NEGATIVE(m_iExtraRepelRetries);
}

int CvUnit::getExtraUnyielding(bool bIgnoreCommanders, bool bIgnoreCommodores) const
{
	if (!bIgnoreCommanders && !isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander)
		{
			return m_iExtraUnyielding + pCommander->m_iExtraUnyielding;
		}
	}
	if (!bIgnoreCommodores && !isCommodore())
    	{
    		const CvUnit* pCommodore = getCommodore();
    		if (pCommodore)
    		{
    			return m_iExtraUnyielding + pCommodore->m_iExtraUnyielding;
    		}
    	}
	return m_iExtraUnyielding;
}

void CvUnit::changeExtraUnyielding(int iChange)
{
	m_iExtraUnyielding += iChange;
	FASSERT_NOT_NEGATIVE(m_iExtraUnyielding);
}

int CvUnit::getExtraKnockback(bool bIgnoreCommanders, bool bIgnoreCommodores) const
{
	if (!bIgnoreCommanders && !isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander)
		{
			return m_iExtraKnockback + pCommander->m_iExtraKnockback;
		}
	}
	if (!bIgnoreCommodores && !isCommodore())
    	{
    		const CvUnit* pCommodore = getCommodore();
    		if (pCommodore)
    		{
    			return m_iExtraKnockback + pCommodore->m_iExtraKnockback;
    		}
    	}
	return m_iExtraKnockback;
}

void CvUnit::changeExtraKnockback(int iChange)
{
	m_iExtraKnockback += iChange;
	FASSERT_NOT_NEGATIVE(m_iExtraKnockback);
}

int CvUnit::getExtraKnockbackRetries(bool bIgnoreCommanders, bool bIgnoreCommodores) const
{
	if (!bIgnoreCommanders && !isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander)
		{
			return m_iExtraKnockbackRetries + pCommander->m_iExtraKnockbackRetries;
		}
	}
	if (!bIgnoreCommodores && !isCommodore())
    	{
    		const CvUnit* pCommodore = getCommodore();
    		if (pCommodore)
    		{
    			return m_iExtraKnockbackRetries + pCommodore->m_iExtraKnockbackRetries;
    		}
    	}
	return m_iExtraKnockbackRetries;
}

void CvUnit::changeExtraKnockbackRetries(int iChange)
{
	m_iExtraKnockbackRetries += iChange;
	FASSERT_NOT_NEGATIVE(m_iExtraKnockbackRetries);
}

int CvUnit::getStampedeCount() const
{
	return m_iStampedeCount;
}

bool CvUnit::cannotStampede() const
{
	return getStampedeCount() < 0;
}

bool CvUnit::mayStampede() const
{
	return getStampedeCount() > 0;
}

void CvUnit::changeStampedeCount(int iChange)
{
	m_iStampedeCount += iChange;
}

int CvUnit::getAttackOnlyCitiesCount() const
{
	return m_iAttackOnlyCitiesCount;
}

void CvUnit::setAttackOnlyCitiesCount(int iChange)
{
	m_iAttackOnlyCitiesCount = iChange;
}

void CvUnit::changeAttackOnlyCitiesCount(int iChange)
{
	m_iAttackOnlyCitiesCount += iChange;
}

int CvUnit::getIgnoreNoEntryLevelCount() const
{
	return m_iIgnoreNoEntryLevelCount;
}

void CvUnit::setIgnoreNoEntryLevelCount(int iChange)
{
	m_iIgnoreNoEntryLevelCount = iChange;
}

void CvUnit::changeIgnoreNoEntryLevelCount(int iChange)
{
	m_iIgnoreNoEntryLevelCount += iChange;
}

int CvUnit::getIgnoreZoneofControlCount() const
{
	return m_iIgnoreZoneofControlCount;
}

void CvUnit::changeIgnoreZoneofControlCount(int iChange)
{
	m_iIgnoreZoneofControlCount += iChange;
}

int CvUnit::getFliesToMoveCount() const
{
	return m_iFliesToMoveCount;
}

void CvUnit::setFliesToMoveCount(int iChange)
{
	m_iFliesToMoveCount = iChange;
}

void CvUnit::changeFliesToMoveCount(int iChange)
{
	m_iFliesToMoveCount += iChange;
}

void CvUnit::changeExtraStrAdjperRnd(int iChange)
{
	m_iExtraStrAdjperRnd += iChange;
	FASSERT_NOT_NEGATIVE(m_iExtraStrAdjperRnd);
}

void CvUnit::changeExtraStrAdjperAtt(int iChange)
{
	m_iExtraStrAdjperAtt += iChange;
	FASSERT_NOT_NEGATIVE(m_iExtraStrAdjperAtt);
}

void CvUnit::changeExtraStrAdjperDef(int iChange)
{
	m_iExtraStrAdjperDef += iChange;
	FASSERT_NOT_NEGATIVE(m_iExtraStrAdjperDef);
}

void CvUnit::changeExtraWithdrawAdjperAtt(int iChange)
{
	m_iExtraWithdrawAdjperAtt += iChange;
	FASSERT_NOT_NEGATIVE(m_iExtraWithdrawAdjperAtt);
}

int CvUnit::getExtraUnnerve(bool bIgnoreCommanders, bool bIgnoreCommodores) const
{
	if (!bIgnoreCommanders && !isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander)
		{
			return m_iExtraUnnerve + pCommander->m_iExtraUnnerve;
		}
	}
	if (!bIgnoreCommodores && !isCommodore())
    	{
    		const CvUnit* pCommodore = getCommodore();
    		if (pCommodore)
    		{
    			return m_iExtraUnnerve + pCommodore->m_iExtraUnnerve;
    		}
    	}
	return m_iExtraUnnerve;
}

void CvUnit::changeExtraUnnerve(int iChange)
{
	m_iExtraUnnerve += iChange;
	FASSERT_NOT_NEGATIVE(m_iExtraUnnerve);
}

int CvUnit::getExtraEnclose(bool bIgnoreCommanders, bool bIgnoreCommodores) const
{
	if (!bIgnoreCommanders && !isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander)
		{
			return m_iExtraEnclose + pCommander->m_iExtraEnclose;
		}
	}
	if (!bIgnoreCommodores && !isCommodore())
    	{
    		const CvUnit* pCommodore = getCommodore();
    		if (pCommodore)
    		{
    			return m_iExtraEnclose + pCommodore->m_iExtraEnclose;
    		}
    	}
	return m_iExtraEnclose;
}

void CvUnit::changeExtraEnclose(int iChange)
{
	m_iExtraEnclose += iChange;
	FASSERT_NOT_NEGATIVE(m_iExtraEnclose);
}

int CvUnit::getExtraLunge(bool bIgnoreCommanders, bool bIgnoreCommodores) const
{
	if (!bIgnoreCommanders && !isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander)
		{
			return m_iExtraLunge + pCommander->m_iExtraLunge;
		}
	}
	if (!bIgnoreCommodores && !isCommodore())
    	{
    		const CvUnit* pCommodore = getCommodore();
    		if (pCommodore)
    		{
    			return m_iExtraLunge + pCommodore->m_iExtraLunge;
    		}
    	}
	return m_iExtraLunge;
}

void CvUnit::changeExtraLunge(int iChange)
{
	m_iExtraLunge += iChange;
	FASSERT_NOT_NEGATIVE(m_iExtraLunge);
}

int CvUnit::getExtraDynamicDefense(bool bIgnoreCommanders, bool bIgnoreCommodores) const
{
	if (!bIgnoreCommanders && !isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander)
		{
			return m_iExtraDynamicDefense + pCommander->m_iExtraDynamicDefense;
		}
	}
	if (!bIgnoreCommodores && !isCommodore())
    	{
    		const CvUnit* pCommodore = getCommodore();
    		if (pCommodore)
    		{
    			return m_iExtraDynamicDefense + pCommodore->m_iExtraDynamicDefense;
    		}
    	}
	return m_iExtraDynamicDefense;
}

void CvUnit::changeExtraDynamicDefense(int iChange)
{
	m_iExtraDynamicDefense += iChange;
	FASSERT_NOT_NEGATIVE(m_iExtraDynamicDefense);
}

int CvUnit::getAnimalIgnoresBordersCount() const
{
	return m_pUnitInfo->canAnimalIgnoresBorders() + m_iAnimalIgnoresBordersCount;
}

void CvUnit::changeAnimalIgnoresBordersCount(int iChange)
{
	m_iAnimalIgnoresBordersCount += iChange;
}

int CvUnit::getOnslaughtCount() const
{
	return m_iOnslaughtCount;
}

bool CvUnit::mayOnslaught() const
{
	return getOnslaughtCount() > 0;
}

void CvUnit::changeOnslaughtCount(int iChange)
{
	m_iOnslaughtCount += iChange;
	FASSERT_NOT_NEGATIVE(getOnslaughtCount());
}

int CvUnit::getDealColdDamageCount() const
{
	return m_iDealColdDamageCount;
}

bool CvUnit::cannotDealColdDamage() const
{
	return getDealColdDamageCount() < 0;
}

bool CvUnit::mayDealColdDamage() const
{
	return getDealColdDamageCount() > 0;
}

void CvUnit::changeDealColdDamageCount(int iChange)
{
	m_iDealColdDamageCount += iChange;
}

int CvUnit::getColdImmuneCount() const
{
	return m_iColdImmuneCount;
}

bool CvUnit::cannotColdImmune() const
{
	return getColdImmuneCount() < 0;
}

bool CvUnit::mayColdImmune() const
{
	return getColdImmuneCount() > 0;
}

void CvUnit::changeColdImmuneCount(int iChange)
{
	m_iColdImmuneCount += iChange;
}


#ifdef OUTBREAKS_AND_AFFLICTIONS
int CvUnit::getCureAfflictionCount(PromotionLineTypes ePromotionLineType) const
{
	FASSERT_BOUNDS(0, GC.getNumPromotionLineInfos(), ePromotionLineType);

	const PromotionLineKeyedInfo* info = findPromotionLineKeyedInfo(ePromotionLineType);

	return info == NULL ? 0 : info->m_iCureAfflictionTypeCount;
}

bool CvUnit::hasExtraCureAffliction(PromotionLineTypes ePromotionLineType) const
{
	FASSERT_BOUNDS(0, GC.getNumPromotionLineInfos(), ePromotionLineType);
	return (getCureAfflictionCount(ePromotionLineType) > 0);
}

void CvUnit::changeCureAfflictionCount(PromotionLineTypes ePromotionLineType, int iChange)
{
	FASSERT_BOUNDS(0, GC.getNumPromotionLineInfos(), ePromotionLineType);

	if (iChange != 0)
	{
		PromotionLineKeyedInfo* info = findOrCreatePromotionLineKeyedInfo(ePromotionLineType);

		info->m_iCureAfflictionTypeCount += iChange;
	}
}
#endif // OUTBREAKS_AND_AFFLICTIONS

int CvUnit::getExtraFortitude(bool bIgnoreCommanders, bool bIgnoreCommodores) const
{
	if (!bIgnoreCommanders && !isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander)
		{
			return m_iExtraFortitude + pCommander->m_iExtraFortitude;
		}
	}
	if (!bIgnoreCommodores && !isCommodore())
    	{
    		const CvUnit* pCommodore = getCommodore();
    		if (pCommodore)
    		{
    			return m_iExtraFortitude + pCommodore->m_iExtraFortitude;
    		}
    	}
	return m_iExtraFortitude;
}

void CvUnit::changeExtraFortitude(int iChange)
{
	m_iExtraFortitude += iChange;
	FASSERT_NOT_NEGATIVE(m_iExtraFortitude);
}

int CvUnit::getExtraDodgeModifier (bool bIgnoreCommanders, bool bIgnoreCommodores) const
{
	if (!bIgnoreCommanders && !isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander)
		{
			return m_iExtraDodgeModifier + pCommander->m_iExtraDodgeModifier;
		}
	}
	if (!bIgnoreCommodores && !isCommodore())
    	{
    		const CvUnit* pCommodore = getCommodore();
    		if (pCommodore)
    		{
    			return m_iExtraDodgeModifier + pCommodore->m_iExtraDodgeModifier;
    		}
    	}
	return m_iExtraDodgeModifier;
}

void CvUnit::changeExtraDodgeModifier(int iChange)
{
	m_iExtraDodgeModifier +=iChange;
}

int CvUnit::getExtraPrecisionModifier(bool bIgnoreCommanders, bool bIgnoreCommodores) const
{
	if (!bIgnoreCommanders && !isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander)
		{
			return m_iExtraPrecisionModifier + pCommander->m_iExtraPrecisionModifier;
		}
	}
	if (!bIgnoreCommodores && !isCommodore())
    	{
    		const CvUnit* pCommodore = getCommodore();
    		if (pCommodore)
    		{
    			return m_iExtraPrecisionModifier + pCommodore->m_iExtraPrecisionModifier;
    		}
    	}
	return m_iExtraPrecisionModifier;
}

void CvUnit::changeExtraPrecisionModifier(int iChange)
{
	m_iExtraPrecisionModifier +=iChange;
}

int CvUnit::getExtraPowerShots(bool bIgnoreCommanders, bool bIgnoreCommodores) const
{
	if (!bIgnoreCommanders && !isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander)
		{
			return m_iExtraPowerShots + pCommander->m_iExtraPowerShots;
		}
	}
	if (!bIgnoreCommodores && !isCommodore())
    	{
    		const CvUnit* pCommodore = getCommodore();
    		if (pCommodore)
    		{
    			return m_iExtraPowerShots + pCommodore->m_iExtraPowerShots;
    		}
    	}
	return m_iExtraPowerShots;
}

void CvUnit::changeExtraPowerShots(int iChange)
{
	m_iExtraPowerShots += iChange;
	FASSERT_NOT_NEGATIVE(m_iExtraPowerShots);
}

int CvUnit::getExtraPowerShotCombatModifier(bool bIgnoreCommanders, bool bIgnoreCommodores) const
{
	if (!bIgnoreCommanders && !isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander)
		{
			return m_iExtraPowerShotCombatModifier + pCommander->m_iExtraPowerShotCombatModifier;
		}
	}
	if (!bIgnoreCommodores && !isCommodore())
    	{
    		const CvUnit* pCommodore = getCommodore();
    		if (pCommodore)
    		{
    			return m_iExtraPowerShotCombatModifier + pCommodore->m_iExtraPowerShotCombatModifier;
    		}
    	}
	return m_iExtraPowerShotCombatModifier;
}

void CvUnit::changeExtraPowerShotCombatModifier(int iChange)
{
	m_iExtraPowerShotCombatModifier += iChange;
	FASSERT_NOT_NEGATIVE(m_iExtraPowerShotCombatModifier);
}

int CvUnit::getExtraPowerShotPunctureModifier(bool bIgnoreCommanders, bool bIgnoreCommodores) const
{
	if (!bIgnoreCommanders && !isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander)
		{
			return m_iExtraPowerShotPunctureModifier + pCommander->m_iExtraPowerShotPunctureModifier;
		}
	}
	if (!bIgnoreCommodores && !isCommodore())
    	{
    		const CvUnit* pCommodore = getCommodore();
    		if (pCommodore)
    		{
    			return m_iExtraPowerShotPunctureModifier + pCommodore->m_iExtraPowerShotPunctureModifier;
    		}
    	}
	return m_iExtraPowerShotPunctureModifier;
}

void CvUnit::changeExtraPowerShotPunctureModifier(int iChange)
{
	m_iExtraPowerShotPunctureModifier += iChange;
	FASSERT_NOT_NEGATIVE(m_iExtraPowerShotPunctureModifier);
}

int CvUnit::getExtraPowerShotPrecisionModifier(bool bIgnoreCommanders, bool bIgnoreCommodores) const
{
	if (!bIgnoreCommanders && !isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander)
		{
			return m_iExtraPowerShotPrecisionModifier + pCommander->m_iExtraPowerShotPrecisionModifier;
		}
	}
	if (!bIgnoreCommodores && !isCommodore())
    	{
    		const CvUnit* pCommodore = getCommodore();
    		if (pCommodore)
    		{
    			return m_iExtraPowerShotPrecisionModifier + pCommodore->m_iExtraPowerShotPrecisionModifier;
    		}
    	}
	return m_iExtraPowerShotPrecisionModifier;
}

void CvUnit::changeExtraPowerShotPrecisionModifier(int iChange)
{
	m_iExtraPowerShotPrecisionModifier += iChange;
	FASSERT_NOT_NEGATIVE(m_iExtraPowerShotPrecisionModifier);
}

int CvUnit::getExtraPowerShotCriticalModifier(bool bIgnoreCommanders, bool bIgnoreCommodores) const
{
	if (!bIgnoreCommanders && !isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander)
		{
			return m_iExtraPowerShotCriticalModifier + pCommander->m_iExtraPowerShotCriticalModifier;
		}
	}
	if (!bIgnoreCommodores && !isCommodore())
    	{
    		const CvUnit* pCommodore = getCommodore();
    		if (pCommodore)
    		{
    			return m_iExtraPowerShotCriticalModifier + pCommodore->m_iExtraPowerShotCriticalModifier;
    		}
    	}
	return m_iExtraPowerShotCriticalModifier;
}

void CvUnit::changeExtraPowerShotCriticalModifier(int iChange)
{
	m_iExtraPowerShotCriticalModifier += iChange;
	FASSERT_NOT_NEGATIVE(m_iExtraPowerShotCriticalModifier);
}

int CvUnit::getExtraCriticalModifier(bool bIgnoreCommanders, bool bIgnoreCommodores) const
{
	if (!bIgnoreCommanders && !isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander)
		{
			return m_iExtraCriticalModifier + pCommander->m_iExtraCriticalModifier;
		}
	}
	if (!bIgnoreCommodores && !isCommodore())
    	{
    		const CvUnit* pCommodore = getCommodore();
    		if (pCommodore)
    		{
    			return m_iExtraCriticalModifier + pCommodore->m_iExtraCriticalModifier;
    		}
    	}
	return m_iExtraCriticalModifier;
}

void CvUnit::changeExtraCriticalModifier(int iChange)
{
	m_iExtraCriticalModifier += iChange;
	FASSERT_NOT_NEGATIVE(m_iExtraCriticalModifier);
}

int CvUnit::getExtraEndurance(bool bIgnoreCommanders, bool bIgnoreCommodores) const
{
	if (!bIgnoreCommanders && !isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander)
		{
			return m_iExtraEndurance + pCommander->m_iExtraEndurance;
		}
	}
	if (!bIgnoreCommodores && !isCommodore())
	{
		const CvUnit* pCommodore = getCommodore();
		if (pCommodore)
		{
			return m_iExtraEndurance + pCommodore->m_iExtraEndurance;
		}
	}
	return m_iExtraEndurance;
}

void CvUnit::changeExtraEndurance(int iChange)
{
	m_iExtraEndurance += iChange;
	FASSERT_NOT_NEGATIVE(m_iExtraEndurance);
}

int CvUnit::getExtraPoisonProbabilityModifier(bool bIgnoreCommanders, bool bIgnoreCommodores) const
{
	if (!bIgnoreCommanders && !isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander)
		{
			return m_iExtraPoisonProbabilityModifier + pCommander->m_iExtraPoisonProbabilityModifier;
		}
	}
	if (!bIgnoreCommodores && !isCommodore())
    	{
    		const CvUnit* pCommodore = getCommodore();
    		if (pCommodore)
    		{
    			return m_iExtraPoisonProbabilityModifier + pCommodore->m_iExtraPoisonProbabilityModifier;
    		}
    	}
	return m_iExtraPoisonProbabilityModifier;
}

void CvUnit::changeExtraPoisonProbabilityModifier(int iChange)
{
	m_iExtraPoisonProbabilityModifier += iChange;
	FASSERT_NOT_NEGATIVE(m_iExtraPoisonProbabilityModifier);
}

//TB Combat Mods End
int CvUnit::getExtraCollateralDamage() const
{
	if (!isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander)
		{
			return m_iExtraCollateralDamage + pCommander->m_iExtraCollateralDamage;
		}
	}
	if (!isCommodore())
    	{
    		const CvUnit* pCommodore = getCommodore();
    		if (pCommodore)
    		{
    			return m_iExtraCollateralDamage + pCommodore->m_iExtraCollateralDamage;
    		}
    	}
	return m_iExtraCollateralDamage;
}

void CvUnit::changeExtraCollateralDamage(int iChange)
{
	m_iExtraCollateralDamage += iChange;
	FASSERT_NOT_NEGATIVE(m_iExtraCollateralDamage);
}

int CvUnit::getExtraEnemyHeal() const
{
	if (!isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander)
		{
			return m_iExtraEnemyHeal + pCommander->m_iExtraEnemyHeal;
		}
	}
	if (!isCommodore())
    	{
    		const CvUnit* pCommodore = getCommodore();
    		if (pCommodore)
    		{
    			return m_iExtraEnemyHeal + pCommodore->m_iExtraEnemyHeal;
    		}
    	}
	return m_iExtraEnemyHeal;
}

void CvUnit::changeExtraEnemyHeal(int iChange)
{
	m_iExtraEnemyHeal += iChange;
}

int CvUnit::getExtraNeutralHeal() const
{
	if (!isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander)
		{
			return m_iExtraNeutralHeal + pCommander->m_iExtraNeutralHeal;
		}
	}
	if (!isCommodore())
    	{
    		const CvUnit* pCommodore = getCommodore();
    		if (pCommodore)
    		{
    			return m_iExtraNeutralHeal + pCommodore->m_iExtraNeutralHeal;
    		}
    	}
	return m_iExtraNeutralHeal;
}

void CvUnit::changeExtraNeutralHeal(int iChange)
{
	m_iExtraNeutralHeal += iChange;
}

int CvUnit::getExtraFriendlyHeal() const
{
	if (!isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander)
		{
			return m_iExtraFriendlyHeal + pCommander->m_iExtraFriendlyHeal;
		}
	}
	if (!isCommodore())
    	{
    		const CvUnit* pCommodore = getCommodore();
    		if (pCommodore)
    		{
    			return m_iExtraFriendlyHeal + pCommodore->m_iExtraFriendlyHeal;
    		}
    	}
	return m_iExtraFriendlyHeal;
}


void CvUnit::changeExtraFriendlyHeal(int iChange)
{
	m_iExtraFriendlyHeal += iChange;
}

int CvUnit::getSameTileHeal() const
{
	return m_iSameTileHeal;
}

void CvUnit::changeSameTileHeal(int iChange)
{
	m_iSameTileHeal += iChange;
	FASSERT_NOT_NEGATIVE(m_iSameTileHeal);
}

int CvUnit::getAdjacentTileHeal() const
{
	return m_iAdjacentTileHeal;
}

void CvUnit::changeAdjacentTileHeal(int iChange)
{
	m_iAdjacentTileHeal += iChange;
	FASSERT_NOT_NEGATIVE(m_iAdjacentTileHeal);
}

int CvUnit::getExtraCombatPercent() const
{
	if (!isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander)
		{
			return m_iExtraCombatPercent + pCommander->m_iExtraCombatPercent;
		}
	}
	if (!isCommodore())
    	{
    		const CvUnit* pCommodore = getCommodore();
    		if (pCommodore)
    		{
    			return m_iExtraCombatPercent + pCommodore->m_iExtraCombatPercent;
    		}
    	}
	return m_iExtraCombatPercent;
}

void CvUnit::changeExtraCombatPercent(int iChange)
{
	if (iChange != 0)
	{
		m_iExtraCombatPercent += iChange;

		setInfoBarDirty(true);
	}
}

int CvUnit::getExtraCityAttackPercent() const
{
	if (!isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander)
		{
			return m_iExtraCityAttackPercent + pCommander->m_iExtraCityAttackPercent;
		}
	}
	if (!isCommodore())
    	{
    		const CvUnit* pCommodore = getCommodore();
    		if (pCommodore)
    		{
    			return m_iExtraCityAttackPercent + pCommodore->m_iExtraCityAttackPercent;
    		}
    	}
	return m_iExtraCityAttackPercent;
}

void CvUnit::changeExtraCityAttackPercent(int iChange)
{
	if (iChange != 0)
	{
		m_iExtraCityAttackPercent += iChange;

		setInfoBarDirty(true);
	}
}

int CvUnit::getExtraCityDefensePercent() const
{
	if (!isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander)
		{
			return m_iExtraCityDefensePercent + pCommander->m_iExtraCityDefensePercent;
		}
	}
	if (!isCommodore())
    	{
    		const CvUnit* pCommodore = getCommodore();
    		if (pCommodore)
    		{
    			return m_iExtraCityDefensePercent + pCommodore->m_iExtraCityDefensePercent;
    		}
    	}
	return m_iExtraCityDefensePercent;
}

void CvUnit::changeExtraCityDefensePercent(int iChange)
{
	if (iChange != 0)
	{
		m_iExtraCityDefensePercent += iChange;

		setInfoBarDirty(true);
	}
}

int CvUnit::getExtraHillsAttackPercent() const
{
	if (!isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander)
		{
			return m_iExtraHillsAttackPercent + pCommander->m_iExtraHillsAttackPercent;
		}
	}
	if (!isCommodore())
    	{
    		const CvUnit* pCommodore = getCommodore();
    		if (pCommodore)
    		{
    			return m_iExtraHillsAttackPercent + pCommodore->m_iExtraHillsAttackPercent;
    		}
    	}
	return m_iExtraHillsAttackPercent;
}

void CvUnit::changeExtraHillsAttackPercent(int iChange)
{
	if (iChange != 0)
	{
		m_iExtraHillsAttackPercent += iChange;

		setInfoBarDirty(true);
	}
}

int CvUnit::getExtraHillsDefensePercent() const
{
	if (!isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander)
		{
			return m_iExtraHillsDefensePercent + pCommander->m_iExtraHillsDefensePercent;
		}
	}
	if (!isCommodore())
    	{
    		const CvUnit* pCommodore = getCommodore();
    		if (pCommodore)
    		{
    			return m_iExtraHillsDefensePercent + pCommodore->m_iExtraHillsDefensePercent;
    		}
    	}
	return m_iExtraHillsDefensePercent;
}

void CvUnit::changeExtraHillsDefensePercent(int iChange)
{
	if (iChange != 0)
	{
		m_iExtraHillsDefensePercent += iChange;

		setInfoBarDirty(true);
	}
}

//WorkRateMod
int CvUnit::hillsWorkModifier() const
{
	return isWorker() ? m_worker->getHillsWorkModifier() : 0;
}

int CvUnit::peaksWorkModifier() const
{
	return isWorker() ? m_worker->getPeaksWorkModifier() : 0;
}

int CvUnit::getWorkModifier() const
{
	return isWorker() ? m_worker->getWorkModifier() : 0;
}

int CvUnit::getExtraWorkModForBuild(const BuildTypes eBuild) const
{
	return isWorker() ? m_worker->getExtraWorkModForBuild(eBuild) : 0;
}


int CvUnit::getCollateralDamageProtection() const
{
	return m_iCollateralDamageProtection;
}

void CvUnit::changeCollateralDamageProtection(int iChange)
{
	if (iChange != 0)
	{
		m_iCollateralDamageProtection += iChange;

		setInfoBarDirty(true);
	}
}

int CvUnit::getPillageChange() const
{
	return m_iPillageChange;
}

void CvUnit::changePillageChange(int iChange)
{
	if (iChange != 0)
	{
		m_iPillageChange += iChange;

		setInfoBarDirty(true);
	}
}

int CvUnit::getUpgradeDiscount() const
{
	return m_iUpgradeDiscount;
}

void CvUnit::changeUpgradeDiscount(int iChange)
{
	if (iChange != 0)
	{
		m_iUpgradeDiscount += iChange;

		setInfoBarDirty(true);
	}
}

int CvUnit::getExperiencePercent() const
{

	if ((isCommander())||(isCommodore()))
	{
		return 0; // Afforess - Great Commanders/Commodores can not gain XP faster
	}
	const CvUnit* pCommander = getCommander();

	if (pCommander)
	{
		return m_iExperiencePercent + pCommander->getExperiencePercent();
	}

	const CvUnit* pCommodore = getCommodore();

		if (pCommodore)
    	{
    		return m_iExperiencePercent + pCommodore->getExperiencePercent();
    	}

	return m_iExperiencePercent;
}

void CvUnit::changeExperiencePercent(int iChange)
{
	if (iChange != 0)
	{
		m_iExperiencePercent += iChange;

		setInfoBarDirty(true);
	}
}

int CvUnit::getKamikazePercent() const
{
	return m_iKamikazePercent;
}

void CvUnit::changeKamikazePercent(int iChange)
{
	if (iChange != 0)
	{
		m_iKamikazePercent += iChange;

		setInfoBarDirty(true);
	}
}

DirectionTypes CvUnit::getFacingDirection(bool checkLineOfSightProperty) const
{
	if (checkLineOfSightProperty && !m_pUnitInfo->isLineOfSight())
	{
		return NO_DIRECTION; //look in all directions
	}
	return m_eFacingDirection; //only look in facing direction
}

void CvUnit::setFacingDirection(DirectionTypes eFacingDirection)
{
	if (eFacingDirection != m_eFacingDirection)
	{
		m_eFacingDirection = eFacingDirection;
		NotifyEntity(NO_MISSION);
	}
}

void CvUnit::rotateFacingDirectionClockwise()
{
	//change direction
	DirectionTypes eNewDirection = (DirectionTypes) ((m_eFacingDirection + 1) % NUM_DIRECTION_TYPES);
	setFacingDirection(eNewDirection);
}

void CvUnit::rotateFacingDirectionCounterClockwise()
{
	//change direction
	DirectionTypes eNewDirection = (DirectionTypes) ((m_eFacingDirection + NUM_DIRECTION_TYPES - 1) % NUM_DIRECTION_TYPES);
	setFacingDirection(eNewDirection);
}

int CvUnit::getImmobileTimer() const
{
	return m_iImmobileTimer;
}

void CvUnit::setImmobileTimer(int iNewValue)
{
	if (iNewValue != m_iImmobileTimer)
	{
		m_iImmobileTimer = iNewValue;

		setInfoBarDirty(true);
	}
}

void CvUnit::changeImmobileTimer(int iChange)
{
	if (iChange != 0)
	{
		setImmobileTimer(std::max(0, m_iImmobileTimer + iChange));
	}
}


bool CvUnit::isCanRespawn() const
{
	return m_bCanRespawn;
}


void CvUnit::setCanRespawn(bool bNewValue)
{
	m_bCanRespawn = bNewValue;
}


bool CvUnit::isSurvivor() const
{
	return m_bSurvivor;
}


void CvUnit::setSurvivor(bool bNewValue)
{
	m_bSurvivor = bNewValue;
}


bool CvUnit::isMadeAttack() const
{
	return m_bMadeAttack;
}


void CvUnit::setMadeAttack(bool bNewValue)
{
	m_bMadeAttack = bNewValue;
}


//TB Combat Mods (Att&DefCounters)
int CvUnit::getRoundCount() const
{
	return m_iRoundCount;
}

void CvUnit::changeRoundCount(int iChange)
{
	if (iChange != 0)
	{
		m_iRoundCount += iChange;
	}
}

int CvUnit::getAttackCount() const
{
	return m_iAttackCount;
}

void CvUnit::changeAttackCount(int iChange)
{
	if (iChange != 0)
	{
		m_iAttackCount += iChange;
	}
}

int CvUnit::getDefenseCount() const
{
	return m_iDefenseCount;
}

void CvUnit::changeDefenseCount(int iChange)
{
	if (iChange != 0)
	{
		m_iDefenseCount += iChange;
	}
}
//TB Combat Mods End

bool CvUnit::isMadeInterception() const
{
	return m_bMadeInterception;
}


void CvUnit::setMadeInterception(bool bNewValue)
{
	m_bMadeInterception = bNewValue;
}


bool CvUnit::isPromotionReady() const
{
	return m_bPromotionReady;
}


void CvUnit::setPromotionReady(bool bNewValue)
{
	if (isPromotionReady() != bNewValue)
	{
		m_bPromotionReady = bNewValue;

/************************************************************************************************/
/* Afforess	                  Start		 09/16/10                                               */
/*                                                                                              */
/* Advanced Automations                                                                         */
/************************************************************************************************/
		if ( !isUsingDummyEntities() && isInViewport())
		{
			gDLL->getEntityIFace()->showPromotionGlow(getUnitEntity(), bNewValue);
		}

		if (m_bPromotionReady)
		{
			if (isAutoPromoting())
			{
				if(AI_promote())
				{
					setPromotionReady(false);
					testPromotionReady();
				}
				else
				{
					setPromotionReady(false);
					FErrorMsg("Couldn't apply promotion");
				}
			}
			else
			{
				MissionAITypes eMissionAI = getGroup()->AI_getMissionAIType();

				//	Don't interrupt units on their way to delivery or rally plots
				if ( (MISSIONAI_CONTRACT != eMissionAI && MISSIONAI_CONTRACT_UNIT != eMissionAI) ||
					 getGroup()->AI_getMissionAIPlot() == plot() )
				{
					getGroup()->setAutomateType(NO_AUTOMATE);
					getGroup()->clearMissionQueue();
					getGroup()->setActivityType(ACTIVITY_AWAKE);
				}
			}
/************************************************************************************************/
/* Afforess	                     END                                                            */
/************************************************************************************************/
		}

		if (IsSelected())
		{
			gDLL->getInterfaceIFace()->setDirty(SelectionButtons_DIRTY_BIT, true);
		}
	}
}


void CvUnit::testPromotionReady()
{
	//TB Combat Mod
	bool bPromotionReady = false;
	if (getExperience() >= experienceNeeded() && canAcquirePromotionAny())
	{
		logBBAI("Exp for promotion present (%d vs %d)\n", getExperience(), experienceNeeded());
		bPromotionReady = true;
	}
	if (getRetrainsAvailable() > 0 && canAcquirePromotionAny())
	{
		logBBAI("Retrain available (%d left)\n", getRetrainsAvailable());
		bPromotionReady = true;
	}

	setPromotionReady(bPromotionReady);
	//TB Combat Mod end
}


bool CvUnit::isDelayedDeath() const
{
	return m_bDeathDelay;
}


// Returns true if killed...
bool CvUnit::doDelayedDeath()
{
	// Koshling - added 'isDead' check to clean up units with 100% damage that have somehow been left behind
	if (isDead() && !isInBattle())
	{
		killUnconditional(false, NO_PLAYER, true);
		return true;
	}
	return false;
}


bool CvUnit::isInfoBarDirty() const
{
	return m_bInfoBarDirty;
}


void CvUnit::setInfoBarDirty(bool bNewValue)
{
	m_bInfoBarDirty = bNewValue;
}

bool CvUnit::isBlockading() const
{
	return m_bBlockading;
}

void CvUnit::setBlockading(bool bNewValue)
{
	if (bNewValue != isBlockading())
	{
		m_bBlockading = bNewValue;

		updatePlunder(isBlockading() ? 1 : -1, true);
	}
}

void CvUnit::collectBlockadeGold()
{
	PROFILE_EXTRA_FUNC();
	if (plot()->getTeam() == getTeam())
	{
		return;
	}

	const int iBlockadeRange = GC.getDefineINT("SHIP_BLOCKADE_RANGE");

	foreach_(const CvPlot* pLoopPlot, plot()->rect(iBlockadeRange, iBlockadeRange)
	| filtered(CvPlot::fn::isRevealed(getTeam(), false)))
	{
		CvCity* pCity = pLoopPlot->getPlotCity();

		if (NULL != pCity && !pCity->isPlundered() && isEnemy(pCity->getTeam()) && !atWar(pCity->getTeam(), getTeam()))
		{
			if (pCity->area() == area() || pCity->plot()->isAdjacentToArea(area()))
			{
				int iGold = pCity->calculateTradeProfit(pCity) * pCity->getTradeRoutes();
				if (iGold > 0)
				{
					pCity->setPlundered(true);
					GET_PLAYER(getOwner()).changeGold(iGold);
					GET_PLAYER(pCity->getOwner()).changeGold(-iGold);


					const CvWString szBuffer = gDLL->getText("TXT_KEY_MISC_TRADE_ROUTE_PLUNDERED", getNameKey(), pCity->getNameKey(), iGold);
					AddDLLMessage(getOwner(), false, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_BUILD_BANK", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_GREEN(), getX(), getY());

					const CvWString szBuffer2 = gDLL->getText("TXT_KEY_MISC_TRADE_ROUTE_PLUNDER", getNameKey(), pCity->getNameKey(), iGold);
					AddDLLMessage(pCity->getOwner(), false, GC.getEVENT_MESSAGE_TIME(), szBuffer2, "AS2D_BUILD_BANK", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_RED(), pCity->getX(), pCity->getY());
				}
			}
		}
	}
}


PlayerTypes CvUnit::getVisualOwner(TeamTypes eForTeam) const
{
	if (NO_TEAM == eForTeam)
	{
		eForTeam = GC.getGame().getActiveTeam();
	}

	if (getTeam() != eForTeam && eForTeam != BARBARIAN_TEAM && isHiddenNationality() && !plot()->isCity(true, getTeam()))
	{
		return BARBARIAN_PLAYER;
	}
	return getOwner();
}


PlayerTypes CvUnit::getCombatOwner(TeamTypes eForTeam, const CvPlot* pPlot) const
{
	if (eForTeam != NO_TEAM && getTeam() != eForTeam && eForTeam != BARBARIAN_TEAM && isAlwaysHostile(pPlot))
	{
		return BARBARIAN_PLAYER;
	}
	return getOwner();
}

TeamTypes CvUnit::getTeam() const
{
	return GET_PLAYER(getOwner()).getTeam();
}


PlayerTypes CvUnit::getCapturingPlayer() const
{
	return m_eCapturingPlayer;
}


void CvUnit::setCapturingPlayer(PlayerTypes eNewValue)
{
	m_eCapturingPlayer = eNewValue;
}

CvUnit* CvUnit::getCapturingUnit() const
{
	return getUnit(m_eCapturingUnit);
}

void CvUnit::setCapturingUnit(const CvUnit* pCapturingUnit)
{
	m_eCapturingUnit = pCapturingUnit->getIDInfo();
}

const UnitTypes CvUnit::getUnitType() const
{
	return m_eUnitType;
}

const CvUnitInfo& CvUnit::getUnitInfo() const
{
	return *m_pUnitInfo;
}

const UnitTypes CvUnit::getLeaderUnitType() const
{
	return m_eLeaderUnitType;
}

void CvUnit::setLeaderUnitType(UnitTypes leaderUnitType)
{
	if (m_eLeaderUnitType != leaderUnitType)
	{
		m_eLeaderUnitType = leaderUnitType;
		reloadEntity();
	}
}

CvUnit* CvUnit::getCombatUnit() const
{
	return getUnit(m_combatUnit);
}


void CvUnit::setCombatUnit(CvUnit* pCombatUnit, bool bAttacking, bool bQuick, bool bStealthAttack, bool bStealthDefense)
{
	if (pCombatUnit)
	{
		if (bAttacking)
		{
			if (GC.getLogging() && GC.getGame().isDebugMode())
			{
				// Log info about this combat...
				char szOut[1024];
				sprintf( szOut, "*** KOMBAT!\n     ATTACKER: Player %d Unit %d (%S's %S), CombatStrength=%d\n     DEFENDER: Player %d Unit %d (%S's %S), CombatStrength=%d\n",
					getOwner(), getID(), GET_PLAYER(getOwner()).getName(), getName().GetCString(), currCombatStr(NULL, NULL),
					pCombatUnit->getOwner(), pCombatUnit->getID(), GET_PLAYER(pCombatUnit->getOwner()).getName(), pCombatUnit->getName().GetCString(), pCombatUnit->currCombatStr(pCombatUnit->plot(), this));
				gDLL->messageControlLog(szOut);
				CvString CombatInfos = szOut;
				LOG_BBAI_UNIT(3, ("%S", CombatInfos.GetCString()));
			}

			if (showSeigeTower(pCombatUnit) && !isUsingDummyEntities()  && isInViewport())
			{
				CvDLLEntity::SetSiegeTower(true);
			}
			if (!bStealthAttack && !bStealthDefense)
			{
				setCombatFirstStrikes((pCombatUnit->immuneToFirstStrikes()) ? 0 : (firstStrikes() + GC.getGame().getSorenRandNum(chanceFirstStrikes() + 1, "First Strike")));
			}
			else if (bStealthAttack)
			{
				setCombatFirstStrikes(stealthStrikesTotal());
			}
		}
		else if (bStealthDefense)
		{
			setCombatFirstStrikes(stealthStrikesTotal());
		}
		else setCombatFirstStrikes((pCombatUnit->immuneToFirstStrikes()) ? 0 : (firstStrikes() + GC.getGame().getSorenRandNum(chanceFirstStrikes() + 1, "First Strike")));

		if (bAttacking
		&& !bQuick
		&& !gDLL->getInterfaceIFace()->isCombatFocus()
		&& !gDLL->getInterfaceIFace()->isFocusedWidget()
		&& (
			getOwner() == GC.getGame().getActivePlayer()
			||
			pCombatUnit->getOwner() == GC.getGame().getActivePlayer()
			&&
			!GC.getGame().isMPOption(MPOPTION_SIMULTANEOUS_TURNS)
			)
		)
		{
			gDLL->getInterfaceIFace()->setCombatFocus(true);
		}
		m_combatUnit = pCombatUnit->getIDInfo();

		if (!bStealthAttack)
		{
			setCombatFirstStrikes((pCombatUnit->immuneToFirstStrikes()) ? 0 : (firstStrikes() + GC.getGame().getSorenRandNum(chanceFirstStrikes() + 1, "First Strike")));
		}
		else setCombatFirstStrikes(stealthStrikesTotal());

		//TB Combat mod begin
		setCombatPowerShots(powerShotsTotal());

		if (knockbackTotal() > 0)
		{
			setCombatKnockbacks(knockbackRetriesTotal() + 1);
		}
		if (repelTotal() > 0)
		{
			setCombatRepels(repelRetriesTotal() + 1);
		}
		setCombatStuns(0);
		//TB Combat Mod end
	}
	else if (getCombatUnit())
	{
		m_combatUnit.reset();
		setCombatFirstStrikes(0);
		//TB Combat Mod begin
		setCombatPowerShots(0);
		setCombatKnockbacks(0);
		setCombatRepels(0);
		setCombatStuns(0);
		//TB Combat mod end

		if (IsSelected())
		{
			gDLL->getInterfaceIFace()->setDirty(InfoPane_DIRTY_BIT, true);
		}

		if (plot() == gDLL->getInterfaceIFace()->getSelectionPlot())
		{
			gDLL->getInterfaceIFace()->setDirty(PlotListButtons_DIRTY_BIT, true);
		}

		if (!isUsingDummyEntities() && isInViewport())
		{
			CvDLLEntity::SetSiegeTower(false);
		}
	}
	setInfoBarDirty(true);
}

// K-Mod. Return true if the combat animation should include a seige tower
bool CvUnit::showSeigeTower(const CvUnit* pDefender) const
{
	return getDomainType() == DOMAIN_LAND
		&& !m_pUnitInfo->isIgnoreBuildingDefense()
		&& pDefender->plot()->getPlotCity()
		&& pDefender->plot()->getPlotCity()->getBuildingDefense() > 0
		&& cityAttackModifier() >= GC.getDefineINT("MIN_CITY_ATTACK_MODIFIER_FOR_SIEGE_TOWER");
}


CvUnit* CvUnit::getTransportUnit() const
{
	return getUnit(m_transportUnit);
}


bool CvUnit::isCargo() const
{
	return getTransportUnit() != NULL;
}


void CvUnit::setTransportUnit(CvUnit* pTransportUnit)
{
	CvUnit* pOldTransportUnit = getTransportUnit();

	if (pOldTransportUnit != pTransportUnit)
	{
		if (pOldTransportUnit != NULL)
		{
			if (GC.getGame().isOption(GAMEOPTION_COMBAT_SIZE_MATTERS))
			{
				pOldTransportUnit->SMchangeCargo(-SMCargoVolume());
				pOldTransportUnit->changeCargo(-1);
			}
			else
			{
				pOldTransportUnit->changeCargo(-1);
			}
			if (getSpecialUnitType() != NO_SPECIALUNIT)
			{
				pOldTransportUnit->processLoadedSpecialUnit(false, getSpecialUnitType());
			}
		}

		if (pTransportUnit != NULL)
		{
			//Can Happen without it being a bug if the unit was forced reloaded by means of an adjustment when already loaded that allowed the unit to overload the transport.
			FAssertMsg(pTransportUnit->cargoSpaceAvailable(getSpecialUnitType(), getDomainType()) > 0, "Cargo space is expected to be available");

			joinGroup(NULL, true); // Because what if a group of 3 tries to get in a transport which can hold 2...

			m_transportUnit = pTransportUnit->getIDInfo();
			setInhibitMerge(false);
			setInhibitSplit(false);

			if (getDomainType() != DOMAIN_AIR)
			{
				getGroup()->setActivityType(ACTIVITY_SLEEP);
			}

			if (GC.getGame().isFinalInitialized())
			{
				finishMoves();
			}

			if (GC.getGame().isOption(GAMEOPTION_COMBAT_SIZE_MATTERS))
			{
				pTransportUnit->SMchangeCargo(SMCargoVolume());
				pTransportUnit->changeCargo(1);
			}
			else
			{
				pTransportUnit->changeCargo(1);
			}
			if (getSpecialUnitType() != NO_SPECIALUNIT)
			{
				pTransportUnit->processLoadedSpecialUnit(true, getSpecialUnitType());
			}
			pTransportUnit->getGroup()->setActivityType(ACTIVITY_AWAKE);
		}
		else
		{
			m_transportUnit.reset();

			getGroup()->setActivityType(ACTIVITY_AWAKE);

			// After a Barb Transport is done, set it to attack AI
			if (pOldTransportUnit != NULL && !pOldTransportUnit->hasCargo())
			{
				if (pOldTransportUnit->getDomainType() == DOMAIN_SEA && pOldTransportUnit->isHominid())
				{
					pOldTransportUnit->AI_setUnitAIType(UNITAI_ATTACK_SEA);
				}
			}

			// Koshling - have the AI prioritize regrouping with other units when unloaded
			getGroup()->AI_setMissionAI(MISSIONAI_REGROUP, NULL, NULL);
		}

#ifdef _DEBUG
		std::vector<CvUnit*> aCargoUnits;
		if (pOldTransportUnit != NULL)
		{
			pOldTransportUnit->getCargoUnits(aCargoUnits);
			if (aCargoUnits.size() > 0)
			{
				pOldTransportUnit->validateCargoUnits();
			}
		}
		if (pTransportUnit != NULL)
		{
			pTransportUnit->getCargoUnits(aCargoUnits);
			if (aCargoUnits.size() > 0)
			{
				pTransportUnit->validateCargoUnits();
			}
		}

		getGroup()->validateLocations();
#endif

	}
}


int CvUnit::getExtraDomainModifier(DomainTypes eIndex) const
{
	FASSERT_BOUNDS(0, NUM_DOMAIN_TYPES, eIndex);

	if (!isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander)
		{
			return m_aiExtraDomainModifier[eIndex] + pCommander->m_aiExtraDomainModifier[eIndex];
		}
	}
	if (!isCommodore())
    	{
    		const CvUnit* pCommodore = getCommodore();
    		if (pCommodore)
    		{
    			return m_aiExtraDomainModifier[eIndex] + pCommodore->m_aiExtraDomainModifier[eIndex];
    		}
    	}
	return m_aiExtraDomainModifier[eIndex];
}


void CvUnit::changeExtraDomainModifier(DomainTypes eIndex, int iChange)
{
	FASSERT_BOUNDS(0, NUM_DOMAIN_TYPES, eIndex);
	m_aiExtraDomainModifier[eIndex] += iChange;
}


const CvWString CvUnit::getDescription(uint uiForm) const
{
	if (m_pUnitInfo->getCivilizationName(getCivilizationType()) != NULL
	&& !CvWString(m_pUnitInfo->getCivilizationName(getCivilizationType())).empty())
	{
		return gDLL->getText(m_pUnitInfo->getCivilizationName(getCivilizationType()));
	}
	return m_pUnitInfo->getDescription(uiForm);
}

const CvWString CvUnit::getName(uint uiForm) const
{
	CvWString szBuffer;

	if (m_szName.empty())
	{
		return getDescription(uiForm);
	}

	if (isDescInName())
	{
		return m_szName;
	}

	szBuffer.Format(L"%s (%s)", m_szName.GetCString(), getDescription(uiForm).GetCString());

	return szBuffer;
}

bool CvUnit::isDescInName() const
{
	return (m_szName.find(getDescription()) != -1);
}


const wchar_t* CvUnit::getNameKey() const
{
	if (m_szName.empty())
	{
		return m_pUnitInfo->getTextKeyWide();
	}
	return m_szName.GetCString();
}


const CvWString& CvUnit::getNameNoDesc() const
{
	return m_szName;
}


void CvUnit::setName(CvWString szNewValue)
{
	gDLL->stripSpecialCharacters(szNewValue);

	m_szName = szNewValue;

	if (IsSelected())
	{
		gDLL->getInterfaceIFace()->setDirty(InfoPane_DIRTY_BIT, true);
	}
}


std::string CvUnit::getScriptData() const
{
	return m_szScriptData;
}


void CvUnit::setScriptData(std::string szNewValue)
{
	m_szScriptData = szNewValue;
}


int CvUnit::getTerrainDoubleMoveCount(TerrainTypes eIndex) const
{
	FASSERT_BOUNDS(0, GC.getNumTerrainInfos(), eIndex);

	const TerrainKeyedInfo* info = findTerrainKeyedInfo(eIndex);

	return info == NULL ? 0 : info->m_iTerrainDoubleMoveCount;
}


bool CvUnit::isTerrainDoubleMove(TerrainTypes eIndex) const
{
	FASSERT_BOUNDS(0, GC.getNumTerrainInfos(), eIndex);
	return getTerrainDoubleMoveCount(eIndex) > 0;
}


void CvUnit::changeTerrainDoubleMoveCount(TerrainTypes eIndex, int iChange)
{
	FASSERT_BOUNDS(0, GC.getNumTerrainInfos(), eIndex);

	if (iChange != 0)
	{
		TerrainKeyedInfo* info = findOrCreateTerrainKeyedInfo(eIndex);

		info->m_iTerrainDoubleMoveCount += iChange;
		FASSERT_NOT_NEGATIVE(info->m_iTerrainDoubleMoveCount);
	}
}


int CvUnit::getFeatureDoubleMoveCount(FeatureTypes eIndex) const
{
	FASSERT_BOUNDS(0, GC.getNumFeatureInfos(), eIndex);

	const FeatureKeyedInfo* info = findFeatureKeyedInfo(eIndex);

	return info == NULL ? 0 : info->m_iFeatureDoubleMoveCount;
}


bool CvUnit::isFeatureDoubleMove(FeatureTypes eIndex) const
{
	FASSERT_BOUNDS(0, GC.getNumFeatureInfos(), eIndex);
	return (getFeatureDoubleMoveCount(eIndex) > 0);
}


void CvUnit::changeFeatureDoubleMoveCount(FeatureTypes eIndex, int iChange)
{
	FASSERT_BOUNDS(0, GC.getNumFeatureInfos(), eIndex);

	if (iChange != 0)
	{
		FeatureKeyedInfo* info = findOrCreateFeatureKeyedInfo(eIndex);

		info->m_iFeatureDoubleMoveCount += iChange;
		FASSERT_NOT_NEGATIVE(info->m_iFeatureDoubleMoveCount);
	}
}

int CvUnit::getExtraTerrainWorkPercent(TerrainTypes eIndex) const
{
	FASSERT_BOUNDS(0, GC.getNumTerrainInfos(), eIndex);

	const TerrainKeyedInfo* info = findTerrainKeyedInfo(eIndex);

	return info == NULL ? 0 : info->m_iExtraTerrainWorkPercent;
}

void CvUnit::changeExtraTerrainWorkPercent(TerrainTypes eIndex, int iChange)
{
	FASSERT_BOUNDS(0, GC.getNumTerrainInfos(), eIndex);

	if (iChange != 0)
	{
		TerrainKeyedInfo* info = findOrCreateTerrainKeyedInfo(eIndex);

		info->m_iExtraTerrainWorkPercent += iChange;

		setInfoBarDirty(true);
	}
}


int CvUnit::getExtraFeatureWorkPercent(FeatureTypes eIndex) const
{
	FASSERT_BOUNDS(0, GC.getNumFeatureInfos(), eIndex);

	const FeatureKeyedInfo* info = findFeatureKeyedInfo(eIndex);

	return info == NULL ? 0 : info->m_iExtraFeatureWorkPercent;
}

void CvUnit::changeExtraFeatureWorkPercent(FeatureTypes eIndex, int iChange)
{
	FASSERT_BOUNDS(0, GC.getNumFeatureInfos(), eIndex);

	if (iChange != 0)
	{
		FeatureKeyedInfo* info = findOrCreateFeatureKeyedInfo(eIndex);

		info->m_iExtraFeatureWorkPercent += iChange;

		setInfoBarDirty(true);
	}
}

//get totals
int CvUnit::terrainWorkPercent(TerrainTypes eIndex) const
{
	FASSERT_BOUNDS(0, GC.getNumTerrainInfos(), eIndex);
	return m_pUnitInfo->getTerrainWorkRateModifierType(eIndex) + getExtraTerrainWorkPercent(eIndex);
}

int CvUnit::featureWorkPercent(FeatureTypes eIndex) const
{
	FASSERT_BOUNDS(0, GC.getNumFeatureInfos(), eIndex);
	return m_pUnitInfo->getFeatureWorkRateModifierType(eIndex) + getExtraFeatureWorkPercent(eIndex);
}

int CvUnit::buildWorkPercent(BuildTypes eIndex) const
{
	FASSERT_BOUNDS(0, GC.getNumBuildInfos(), eIndex);
	return m_pUnitInfo->getBuildWorkRateModifierType(eIndex) + getExtraWorkModForBuild(eIndex);
}


int CvUnit::getExtraTerrainAttackPercent(TerrainTypes eIndex) const
{
	FASSERT_BOUNDS(0, GC.getNumTerrainInfos(), eIndex);

	const TerrainKeyedInfo* info = findTerrainKeyedInfo(eIndex);

	if (!isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander)
		{
			return (info ? info->m_iExtraTerrainAttackPercent : 0) + pCommander->getExtraTerrainAttackPercent(eIndex);
		}
	}
	if (!isCommodore())
    	{
    		const CvUnit* pCommodore = getCommodore();
    		if (pCommodore)
    		{
    			return (info ? info->m_iExtraTerrainAttackPercent : 0) + pCommodore->getExtraTerrainAttackPercent(eIndex);
    		}
    	}
	return info ? info->m_iExtraTerrainAttackPercent : 0;
}


void CvUnit::changeExtraTerrainAttackPercent(TerrainTypes eIndex, int iChange)
{
	FASSERT_BOUNDS(0, GC.getNumTerrainInfos(), eIndex);

	if (iChange != 0)
	{
		findOrCreateTerrainKeyedInfo(eIndex)->m_iExtraTerrainAttackPercent += iChange;

		setInfoBarDirty(true);
	}
}

int CvUnit::getExtraTerrainDefensePercent(TerrainTypes eIndex) const
{
	FASSERT_BOUNDS(0, GC.getNumTerrainInfos(), eIndex);

	const TerrainKeyedInfo* info = findTerrainKeyedInfo(eIndex);

	if (!isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander)
		{
			return (info ? info->m_iExtraTerrainDefensePercent : 0) + pCommander->getExtraTerrainDefensePercent(eIndex);
		}
	}
	if (!isCommodore())
    	{
    		const CvUnit* pCommodore = getCommodore();
    		if (pCommodore)
    		{
    			return (info ? info->m_iExtraTerrainDefensePercent : 0) + pCommodore->getExtraTerrainDefensePercent(eIndex);
    		}
    	}
	return info ? info->m_iExtraTerrainDefensePercent : 0;
}


void CvUnit::changeExtraTerrainDefensePercent(TerrainTypes eIndex, int iChange)
{
	FASSERT_BOUNDS(0, GC.getNumTerrainInfos(), eIndex);

	if (iChange != 0)
	{
		findOrCreateTerrainKeyedInfo(eIndex)->m_iExtraTerrainDefensePercent += iChange;

		setInfoBarDirty(true);
	}
}

int CvUnit::getExtraFeatureAttackPercent(FeatureTypes eIndex) const
{
	FASSERT_BOUNDS(0, GC.getNumFeatureInfos(), eIndex);

	const FeatureKeyedInfo* info = findFeatureKeyedInfo(eIndex);

	if (!isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander)
		{
			return (info ? info->m_iExtraFeatureAttackPercent : 0) + pCommander->getExtraFeatureAttackPercent(eIndex);
		}
	}
	if (!isCommodore())
    	{
    		const CvUnit* pCommodore = getCommodore();
    		if (pCommodore)
    		{
    			return (info ? info->m_iExtraFeatureAttackPercent : 0) + pCommodore->getExtraFeatureAttackPercent(eIndex);
    		}
    	}
	return info ? info->m_iExtraFeatureAttackPercent : 0;
}


void CvUnit::changeExtraFeatureAttackPercent(FeatureTypes eIndex, int iChange)
{
	FASSERT_BOUNDS(0, GC.getNumFeatureInfos(), eIndex);

	if (iChange != 0)
	{
		findOrCreateFeatureKeyedInfo(eIndex)->m_iExtraFeatureAttackPercent += iChange;
		setInfoBarDirty(true);
	}
}

int CvUnit::getExtraFeatureDefensePercent(FeatureTypes eIndex) const
{
	FASSERT_BOUNDS(0, GC.getNumFeatureInfos(), eIndex);

	const FeatureKeyedInfo* info = findFeatureKeyedInfo(eIndex);

	if (!isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander)
		{
			return (info ? info->m_iExtraFeatureDefensePercent : 0) + pCommander->getExtraFeatureDefensePercent(eIndex);
		}
	}
	if (!isCommodore())
    	{
    		const CvUnit* pCommodore = getCommodore();
    		if (pCommodore)
    		{
    			return (info ? info->m_iExtraFeatureDefensePercent : 0) + pCommodore->getExtraFeatureDefensePercent(eIndex);
    		}
    	}
	return info ? info->m_iExtraFeatureDefensePercent : 0;
}


void CvUnit::changeExtraFeatureDefensePercent(FeatureTypes eIndex, int iChange)
{
	FASSERT_BOUNDS(0, GC.getNumFeatureInfos(), eIndex);

	if (iChange != 0)
	{
		findOrCreateFeatureKeyedInfo(eIndex)->m_iExtraFeatureDefensePercent += iChange;
		setInfoBarDirty(true);
	}
}

int CvUnit::getExtraUnitCombatModifier(UnitCombatTypes eIndex, const bool bCommander, const bool bCommodore) const
{
	FASSERT_BOUNDS(0, GC.getNumUnitCombatInfos(), eIndex);

	const UnitCombatKeyedInfo* info = findUnitCombatKeyedInfo(eIndex);

	if (!bCommander)
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander)
		{
			return (info ? info->m_iExtraUnitCombatModifier : 0) + pCommander->getExtraUnitCombatModifier(eIndex);
		}
	}
	if (!bCommodore)
    	{
    		const CvUnit* pCommodore = getCommodore();
    		if (pCommodore)
    		{
    			return (info ? info->m_iExtraUnitCombatModifier : 0) + pCommodore->getExtraUnitCombatModifier(eIndex);
    		}
    	}
	return info ? info->m_iExtraUnitCombatModifier : 0;
}


void CvUnit::changeExtraUnitCombatModifier(UnitCombatTypes eIndex, int iChange)
{
	FASSERT_BOUNDS(0, GC.getNumUnitCombatInfos(), eIndex);

	if (iChange != 0)
	{
		UnitCombatKeyedInfo* info = findOrCreateUnitCombatKeyedInfo(eIndex);

		info->m_iExtraUnitCombatModifier += iChange;
	}
}

bool CvUnit::canAcquirePromotion(PromotionTypes ePromotion, PromotionRequirements::flags requirements) const
{
	return canAcquirePromotion(ePromotion,
		requirements & PromotionRequirements::IgnoreHas,
		requirements & PromotionRequirements::Equip,
		requirements & PromotionRequirements::Afflict,
		requirements & PromotionRequirements::ForLeader,
		requirements & PromotionRequirements::ForOffset,
		requirements & PromotionRequirements::ForFree,
		requirements & PromotionRequirements::ForBuildUp,
		requirements & PromotionRequirements::ForStatus
	);
}

bool CvUnit::canAcquirePromotion(PromotionTypes ePromotion, bool bIgnoreHas, bool bEquip, bool bAfflict, bool bForLeader, bool bForOffset, bool bForFree, bool bForBuildUp, bool bForStatus) const
{
	PROFILE_FUNC();

	FASSERT_BOUNDS(NO_PROMOTION, GC.getNumPromotionInfos(), ePromotion);

	if (ePromotion == NO_PROMOTION || !bIgnoreHas && isHasPromotion(ePromotion))
	{
		return false;
	}

	const CvPromotionInfo& promo = GC.getPromotionInfo(ePromotion);

	if (!bForStatus && promo.isStatus())
	{
		return false;
	}

	if (promo.getStateReligionPrereq() != NO_RELIGION && GET_PLAYER(getOwner()).getStateReligion() != promo.getStateReligionPrereq())
	{
		return false;
	}

	if (!isPromotionValid(ePromotion, bForFree))
	{
		return false;
	}

	//TB Combat Mod begin
	if (!bEquip && promo.isEquipment())
	{
		return false;
	}

#ifdef OUTBREAKS_AND_AFFLICTIONS
	if (!bAfflict && promo.isAffliction())
	{
		return false;
	}
#endif // OUTBREAKS_AND_AFFLICTIONS

	//TB Debug Note: If the promotion being evaluated for is the sort you get from a leader as it attaches to the unit that then qualifies you for other
	//promotions, and the check being called here is not for that specific purpose, then return false for that promotion.
	if (!bForLeader && promo.isLeader())
	{
		return false;
	}

	if (!bForOffset && promo.isForOffset())
	{
		return false;
	}

	if (promo.getObsoleteTech() != NO_TECH && GET_TEAM(getTeam()).isHasTech(promo.getObsoleteTech()))
	{
		return false;
	}

	//Units without a primary unitcombat are unable to be assigned promos
	if (getUnitCombatType() == NO_UNITCOMBAT)
	{
		return false;
	}

	if (promo.getReplacesUnitCombat() != NO_UNITCOMBAT && !isHasUnitCombat(promo.getReplacesUnitCombat()))
	{
		return false;
	}

	if (getLevel() < promo.getLevelPrereq() && !bForOffset)
	{
		return false;
	}
	if (promo.isRBombardPrereq() && !canRBombard(true))
	{
		return false;
	}
	const CvPlot* pPlot = plot();
	if ((m_pUnitInfo != NULL && pPlot != NULL) && (!isMapCategory(*pPlot, promo) || !isMapCategory(*m_pUnitInfo, promo)))
	{
		return false;
	}
	//TB Combat Mods Begin
	if (!bForFree || bForBuildUp)
	{
		const PromotionTypes ePromotionPrerequisite = promo.getPrereqPromotion();

		if (ePromotionPrerequisite != NO_PROMOTION && !isHasPromotion(ePromotionPrerequisite))
		{
			return false;
		}
		const PromotionTypes ePromotionPrerequisite1 = promo.getPrereqOrPromotion1();
		const PromotionTypes ePromotionPrerequisite2 = promo.getPrereqOrPromotion2();

		if ((ePromotionPrerequisite1 != NO_PROMOTION || ePromotionPrerequisite2 != NO_PROMOTION)
		&&  (ePromotionPrerequisite1 == NO_PROMOTION || !isHasPromotion(ePromotionPrerequisite1))
		&&  (ePromotionPrerequisite2 == NO_PROMOTION || !isHasPromotion(ePromotionPrerequisite2)))
		{
			return false;
		}
	}

	if (promo.isEquipment())
	{
		if (!pPlot->isCity(false, getTeam()))
		{
			//TB will be replacing this when units can carry and transport equipments without owning them as promos
			return false;
		}
		const CvCity* pCity = pPlot->getPlotCity();

		foreach_(const BonusTypes ePrereqBonus, promo.getPrereqBonuses())
		{
			if (ePrereqBonus != NO_BONUS && !pCity->hasBonus(ePrereqBonus))
			{
				return false;
			}
		}
	}

	{
		const int iMinEraInt = promo.getMinEraType();
		const int iMaxEraInt = promo.getMaxEraType();
		if (iMinEraInt > NO_ERA || iMaxEraInt > NO_ERA)
		{
			for (int iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
			{
				if (isHasUnitCombat((UnitCombatTypes)iI) && GC.getUnitCombatInfo((UnitCombatTypes)iI).getEra() != NO_ERA)
				{
					const int iEra = (int)GC.getUnitCombatInfo((UnitCombatTypes)iI).getEra();
					if (
						iMinEraInt > NO_ERA && iMinEraInt > iEra
					||	iMaxEraInt > NO_ERA && iMaxEraInt < iEra
					) return false;

					break;
				}
			}
		}
	}

	for (int iI = 0; iI < promo.getNumSubCombatChangeTypes(); iI++)
	{
		//If we have the unitcombat the promotion will give us already
		if (isHasUnitCombat((UnitCombatTypes)promo.getSubCombatChangeType(iI)))
		{
			return false;
		}
	}
	const PromotionLineTypes ePromotionLine = promo.getPromotionLine();

	if (bForBuildUp && (ePromotionLine == NO_PROMOTIONLINE || !GC.getPromotionLineInfo(ePromotionLine).isBuildUp())
	|| !bForBuildUp && ePromotionLine != NO_PROMOTIONLINE && GC.getPromotionLineInfo(ePromotionLine).isBuildUp())
	{
		return false;
	}

	if (
		promo.isNotOnDomainType((int)getDomainType())
	||
		ePromotionLine != NO_PROMOTIONLINE
	&&	GC.getPromotionLineInfo(ePromotionLine).isNotOnDomainType((int)getDomainType())
	) return false;

	// Afflictions and equipment promotions that are part of a line can only be acquired
	//	if you don't already have a higher priority one from the same line, since each line can only
	//	have one specific present at a time (and higher priority takes precedence)
	if (ePromotionLine != NO_PROMOTIONLINE
		&& (
#ifdef OUTBREAKS_AND_AFFLICTIONS
			promo.isAffliction() ||
#endif // OUTBREAKS_AND_AFFLICTIONS
			promo.isEquipment()))
	{
		for (int iI = 0; iI < GC.getNumPromotionInfos(); iI++)
		{
			if (GC.getPromotionInfo((PromotionTypes)iI).getPromotionLine() == ePromotionLine && isHasPromotion((PromotionTypes)iI)
			&& GC.getPromotionInfo((PromotionTypes)iI).getLinePriority() > promo.getLinePriority())
			{
				return false;
			}
		}
	}
	//TB SubCombat Mod End

	// Must have the next less promotionline priority unless this is an affliction, equipment, or BuildUp or Status.
	if (ePromotionLine != NO_PROMOTIONLINE && !bAfflict && !bEquip && !promo.isCritical() && !bForBuildUp && !bForStatus && promo.getLinePriority() > 1)
	{
		const CvPromotionLineInfo& promoLine = GC.getPromotionLineInfo(ePromotionLine);
		const int numPromotions = promoLine.getNumPromotions();
		for (int iJ = 0; iJ < numPromotions; iJ++)
		{
			const PromotionTypes ePrereq = (PromotionTypes)promoLine.getPromotion(iJ);
			if (GC.getPromotionInfo(ePrereq).getLinePriority() == promo.getLinePriority() - 1 && !isHasPromotion(ePrereq))
			{
				return false;
			}
		}
	}
	// For Statuses, you can only have one promotion in the line but iLinePriority is not necessarily a hierarchy, just an index in the line.
	//	However, you can set multiple promos with the same iLinePriority that cannot be swapped out for each other.
	if (bForStatus)
	{
		bool bPrereqFound = ePromotionLine == NO_PROMOTIONLINE || promo.getLinePriority() != 1;

		if (!bPrereqFound)
		{
			const int numPromotionInfos = GC.getNumPromotionInfos();
			for (int iI = 0; iI < numPromotionInfos; iI++)
			{
				const PromotionTypes ePrereq = (PromotionTypes)iI;
				if (isHasPromotion(ePrereq))
				{
					const CvPromotionInfo& kPrereqPromotion = GC.getPromotionInfo(ePrereq);
					if (kPrereqPromotion.getPromotionLine() == ePromotionLine)
					{
						if (kPrereqPromotion.getLinePriority() == promo.getLinePriority())
						{
							return false;
						}
						if (promo.getLinePriority() == 1)
						{
							// This establishes all Status Promos with an iLinePriority of 1 as being the status that erases any of the statuses.
							bPrereqFound = true;
							break;
						}
					}
				}
			}
		}
		if (!bPrereqFound)
		{
			return false;
		}
	}
	//TB Combat Mod end

	if	(promo.isCargoPrereq() && cargoSpace() < 1)
	{
		return false;
	}

	if (promo.getSpecialCargoPrereq() != NO_SPECIALUNIT
	&&  promo.getSpecialCargoPrereq() != getSpecialCargo())
	{
		return false;
	}

	if (GC.getGame().isOption(GAMEOPTION_COMBAT_SIZE_MATTERS)
	&& promo.getSMNotSpecialCargoPrereq() != NO_SPECIALUNIT
	&& promo.getSMNotSpecialCargoPrereq() != getSMNotSpecialCargo())
	{
		return false;
	}

	if (!bForFree)
	{
		if (promo.getTechPrereq() != NO_TECH && !GET_TEAM(getTeam()).isHasTech(promo.getTechPrereq()))
		{
			return false;
		}
		if (ePromotionLine != NO_PROMOTIONLINE
		&&
			GC.getPromotionLineInfo(ePromotionLine).getPrereqTech() != NO_TECH
		&&
			!GET_TEAM(getTeam()).isHasTech(GC.getPromotionLineInfo(ePromotionLine).getPrereqTech()))
		{
			return false;
		}
	}

	bool bValid = true;

	for (int iI = 0; iI < promo.getNumPrereqTerrainTypes(); iI++)
	{
		const TerrainTypes ePrereqTerrain = (TerrainTypes)promo.getPrereqTerrainType(iI);

		if (ePrereqTerrain != NO_TERRAIN)
		{
			bValid = false;

			if (ePrereqTerrain == GC.getTERRAIN_PEAK())
			{
				if (plot()->isAsPeak())
				{
					bValid = true;
					break;
				}
			}
			else if (ePrereqTerrain == GC.getTERRAIN_HILL())
			{
				if (plot()->isHills())
				{
					bValid = true;
					break;
				}
			}
			else if (ePrereqTerrain == plot()->getTerrainType())
			{
				bValid = true;
				break;
			}
		}
	}
	if (!bValid)
	{
		return false;
	}

	for (int iI = 0; iI < promo.getNumPrereqFeatureTypes(); iI++)
	{
		const FeatureTypes ePrereqFeature = (FeatureTypes)promo.getPrereqFeatureType(iI);

		if (ePrereqFeature != NO_FEATURE)
		{
			bValid = false;
			if (plot()->getFeatureType() == ePrereqFeature)
			{
				bValid = true;
				break;
			}
		}
	}
	if (!bValid)
	{
		return false;
	}

	// Improvements and buildings is an OR statement between all of them.
	{
		bool bFirst = true;

		for (int iI = 0; iI < promo.getNumPrereqImprovementTypes(); iI++)
		{
			ImprovementTypes ePrereqImprovement = (ImprovementTypes)promo.getPrereqImprovementType(iI);
			if (ePrereqImprovement != NO_IMPROVEMENT)
			{
				bFirst = false;
				bValid = false;
				if (plot()->isCity(true) && ePrereqImprovement == GC.getIMPROVEMENT_CITY())
				{
					bValid = true;
					break;
				}
				if (plot()->getImprovementType() == ePrereqImprovement)
				{
					bValid = true;
					break;
				}
			}
		}
		if (bFirst || !bValid)
		{
			const int iNumPrereqLocalBuilding = promo.getNumPrereqLocalBuildingTypes();
			if (iNumPrereqLocalBuilding > 0)
			{
				bValid = false;
				for (int iI = 0; iI < iNumPrereqLocalBuilding; iI++)
				{
					if (plot()->isCity(false)

					&& pPlot->getPlotCity()->isActiveBuilding((BuildingTypes)promo.getPrereqLocalBuildingType(iI)))
					{
						bValid = true;
						break;
					}
				}
			}
		}
	}
	if (!bValid)
	{
		return false;
	}

	for (int iI = 0; iI < promo.getNumPrereqPlotBonusTypes(); iI++)
	{
		const BonusTypes ePrereqBonus = (BonusTypes)promo.getPrereqPlotBonusType(iI);

		if (ePrereqBonus != NO_BONUS)
		{
			bValid = false;
			if (plot()->getBonusType(getTeam()) == ePrereqBonus)
			{
				bValid = true;
				break;
			}
		}
	}
	if (!bValid)
	{
		return false;
	}

	if (promo.isPrereqNormInvisible() && !hasInvisibleAbility())
	{
		return false;
	}

	if (!bForOffset && promo.getQualityChange() > 0 && getRetrainsAvailable() > 0)
	{
		return false;
	}

	return true;
}

bool CvUnit::isPromotionValid(PromotionTypes ePromotion, bool bFree, bool bKeepCheck) const
{
	PROFILE_EXTRA_FUNC();
	const CvPromotionInfo& promo = GC.getPromotionInfo(ePromotion);

	if (!bKeepCheck) // If the unit got the promo then these checks have already passed.
	{
		if (m_pUnitInfo->isSpy() && !GC.isSS_ENABLED())
		{
			return false;
		}

		//Disable via NotOnGameOption tag:
		for (int iI = 0; iI < promo.getNumNotOnGameOptions(); iI++)
		{
			if (GC.getGame().isOption((GameOptionTypes)promo.getNotOnGameOption(iI)))
			{
				return false;
			}
		}
		for (int iI = 0; iI < promo.getNumOnGameOptions(); iI++)
		{
			if (!GC.getGame().isOption((GameOptionTypes)promo.getOnGameOption(iI)))
			{
				return false;
			}
		}
		if (promo.getPromotionLine() != NO_PROMOTIONLINE)
		{
			for (int iI = 0; iI < GC.getPromotionLineInfo(promo.getPromotionLine()).getNumNotOnGameOptions(); iI++)
			{
				if (GC.getGame().isOption((GameOptionTypes)GC.getPromotionLineInfo(promo.getPromotionLine()).getNotOnGameOption(iI)))
				{
					return false;
				}
			}
			for (int iI = 0; iI < GC.getPromotionLineInfo(promo.getPromotionLine()).getNumNotOnGameOptions(); iI++)
			{
				if (!GC.getGame().isOption((GameOptionTypes)GC.getPromotionLineInfo(promo.getPromotionLine()).getNotOnGameOption(iI)))
				{
					return false;
				}
			}
		}
	}
	// Very few reasons to deny a unit promotions that are specifically set to be a free for it.
	if (m_pUnitInfo->getFreePromotions(ePromotion) || GET_PLAYER(getOwner()).isFreePromotion(getUnitType(), ePromotion))
	{
		return true;
	}

	if (m_pUnitInfo->getUnitCombatType() == NO_UNITCOMBAT)
	{
		return false;
	}
	if (promo.getObsoleteTech() != NO_TECH && GET_TEAM(getTeam()).isHasTech(promo.getObsoleteTech()))
	{
		return false;
	}
	if (!bFree)
	{
		if (promo.getTechPrereq() != NO_TECH && !GET_TEAM(getTeam()).isHasTech(promo.getTechPrereq()))
		{
			return false;
		}
		const PromotionLineTypes ePromotionLine = promo.getPromotionLine();

		if (ePromotionLine != NO_PROMOTIONLINE
		&& GC.getPromotionLineInfo(ePromotionLine).getPrereqTech() != NO_TECH
		&& !GET_TEAM(getTeam()).isHasTech(GC.getPromotionLineInfo(ePromotionLine).getPrereqTech()))
		{
			return false;
		}
	}

	// Toffer - Promotionline is factored in for the (dis)qualified caches.
	for (int iI = 0; iI < promo.getNumDisqualifiedUnitCombatTypes(); iI++)
	{
		if (isHasUnitCombat((UnitCombatTypes)promo.getDisqualifiedUnitCombatType(iI)))
		{
			return false;
		}
	}
	// TB SubCombat Mod Begin
	// The two solid ways to identify a Size Matters promotion that would not normally have a CC prereq.
	// Note: Apparently having no CC prereq is a clear way to isolate promotions to only being assigned directly by event or other special injection.
	// Thus it was necessary to pass the Size Matters promos despite having no particular CC prereq.
	if (!promo.isForOffset() && !promo.isZeroesXP())
	{
		bool bValid = bFree;

		for (int iI = promo.getNumQualifiedUnitCombatTypes() - 1; iI > -1; iI--)
		{
			bValid = false;
			if (isHasUnitCombat((UnitCombatTypes)promo.getQualifiedUnitCombatType(iI)))
			{
				bValid = true;
				break;
			}
		}
		if (!bValid)
		{
			return false;
		}
	}

	if (isSpy())
	{
		return true;
	}

	//Disable Looter Promos for units that cannot pillage
	if (promo.getPillageChange() > 0 && !m_pUnitInfo->isPillage())
	{
		return false;
	}

	if (isCommander() && (promo.getGroupChange() != 0 || promo.getQualityChange() != 0))
	{
		return false;
	}

	if (isCommodore() && (promo.getGroupChange() != 0 || promo.getQualityChange() != 0))
    	{
    		return false;
    	}

	if (isBlendIntoCity() && promo.getCityDefensePercent() != 0)
	{
		return false;
	}

	if (!bKeepCheck)
	{
		if (promo.getInterceptChange() + maxInterceptionProbability(true) > GC.getDefineINT("MAX_INTERCEPTION_PROBABILITY")
		||	promo.getEvasionChange() + evasionProbability(true) > GC.getDefineINT("MAX_EVASION_PROBABILITY")
		||	promo.getQualityChange() > 0 && getExperience() >= experienceNeeded(1))
		{
			return false;
		}
	}

	return true;
}


bool CvUnit::canAcquirePromotionAny() const
{
	PROFILE_EXTRA_FUNC();
	//TB Debug note: I had not originally considered how this was really only to be used for determination of the unit being able to access any
	//skill based promos only.  This is here to check if any skill promos are left that can be accessed right now and my previous considerations
	//to include the potential to receive equipments and afflictions will now be disincluded from this routine to avoid screwing up the entire purpose
	//of this function.  A check through reveals I never utilize this function in the processing of those features anyhow and it is only used for
	//its original purpose of making sure the unit still has something it can select when taking a skill-based promo.

	for (int iI = GC.getNumPromotionInfos() - 1; iI > -1; iI--)
	{
		const PromotionTypes ePromotion = static_cast<PromotionTypes>(iI);

		PromotionRequirements::flags promoFlags = PromotionRequirements::Promote;

		if (GC.getPromotionInfo(ePromotion).isLeader())
		{
			promoFlags |= PromotionRequirements::ForLeader;
		}
		if (canAcquirePromotion(ePromotion, promoFlags))
		{
			return true;
		}
	}
	return false;
}

PromotionKeyedInfo*	CvUnit::findOrCreatePromotionKeyedInfo(PromotionTypes ePromotion, bool bCreate)
{
	PROFILE_FUNC();

	std::map<PromotionTypes, PromotionKeyedInfo>::iterator itr = m_promotionKeyedInfo.find(ePromotion);

	if (itr != m_promotionKeyedInfo.end())
	{
		return &(itr->second);
	}

	if (bCreate)
	{
		PromotionKeyedInfo newInfo;

		return &(m_promotionKeyedInfo.insert(std::make_pair(ePromotion, newInfo)).first->second);
	}

	return NULL;
}

const PromotionKeyedInfo* CvUnit::findPromotionKeyedInfo(PromotionTypes ePromotion) const
{
	std::map<PromotionTypes, PromotionKeyedInfo>::const_iterator itr = m_promotionKeyedInfo.find(ePromotion);

	if (itr == m_promotionKeyedInfo.end())
	{
		return NULL;
	}

	if (m_promotionKeyedInfo.size() > 32 && itr->second.Empty())
	{
		m_promotionKeyedInfo.erase(itr->first); // Alberts2 - Erase empty elemnts to save memory
		return NULL;
	}

	return &(itr->second);
}

const std::map<PromotionTypes, PromotionKeyedInfo>& CvUnit::getPromotionKeyedInfo() const
{
	return m_promotionKeyedInfo;
}

PromotionIterator CvUnit::getPromotionBegin()
{
	return m_promotionKeyedInfo.begin();
}

PromotionIterator CvUnit::getPromotionEnd()
{
	return m_promotionKeyedInfo.end();
}

PromotionLineKeyedInfo* CvUnit::findOrCreatePromotionLineKeyedInfo(PromotionLineTypes ePromotionLine, bool bCreate)
{
	std::map<PromotionLineTypes, PromotionLineKeyedInfo>::iterator itr = m_promotionLineKeyedInfo.find(ePromotionLine);

	if (itr != m_promotionLineKeyedInfo.end())
	{
		return &(itr->second);
	}

	if (bCreate)
	{
		PromotionLineKeyedInfo newInfo;

		return &(m_promotionLineKeyedInfo.insert(std::make_pair(ePromotionLine, newInfo)).first->second);
	}

	return NULL;
}

const PromotionLineKeyedInfo* CvUnit::findPromotionLineKeyedInfo(PromotionLineTypes ePromotionLine) const
{
	std::map<PromotionLineTypes, PromotionLineKeyedInfo>::const_iterator itr = m_promotionLineKeyedInfo.find(ePromotionLine);

	if (itr == m_promotionLineKeyedInfo.end())
	{
		return NULL;
	}

	if (m_promotionLineKeyedInfo.size() > 16 && itr->second.Empty())
	{
		m_promotionLineKeyedInfo.erase(itr->first); // Alberts2 - Erase empty elemnts to save memory
		return NULL;
	}

	return &(itr->second);
}

std::map<PromotionLineTypes, PromotionLineKeyedInfo>& CvUnit::getPromotionLineKeyedInfo() const
{
	return m_promotionLineKeyedInfo;
}

TerrainKeyedInfo* CvUnit::findOrCreateTerrainKeyedInfo(TerrainTypes eTerrain, bool bCreate)
{
	std::map<TerrainTypes, TerrainKeyedInfo>::iterator itr = m_terrainKeyedInfo.find(eTerrain);

	if (itr != m_terrainKeyedInfo.end())
	{
		return &(itr->second);
	}

	if (bCreate)
	{
		TerrainKeyedInfo newInfo;

		return &(m_terrainKeyedInfo.insert(std::make_pair(eTerrain, newInfo)).first->second);
	}

	return NULL;
}

const TerrainKeyedInfo*	CvUnit::findTerrainKeyedInfo(TerrainTypes eTerrain) const
{
	std::map<TerrainTypes, TerrainKeyedInfo>::const_iterator itr = m_terrainKeyedInfo.find(eTerrain);

	if (itr == m_terrainKeyedInfo.end())
	{
		return NULL;
	}
	if (m_terrainKeyedInfo.size() > 16 && itr->second.Empty())
	{
		m_terrainKeyedInfo.erase(itr->first); // Alberts2 - Erase empty elemnts to save memory
		return NULL;
	}
	return &(itr->second);
}

FeatureKeyedInfo* CvUnit::findOrCreateFeatureKeyedInfo(FeatureTypes eFeature, bool bCreate)
{
	std::map<FeatureTypes, FeatureKeyedInfo>::iterator itr = m_featureKeyedInfo.find(eFeature);

	if (itr != m_featureKeyedInfo.end())
	{
		return &(itr->second);
	}

	if (bCreate)
	{
		FeatureKeyedInfo newInfo;

		return &(m_featureKeyedInfo.insert(std::make_pair(eFeature, newInfo)).first->second);
	}

	return NULL;
}

const FeatureKeyedInfo* CvUnit::findFeatureKeyedInfo(FeatureTypes eFeature) const
{
	std::map<FeatureTypes, FeatureKeyedInfo>::const_iterator itr = m_featureKeyedInfo.find(eFeature);

	if (itr == m_featureKeyedInfo.end())
	{
		return NULL;
	}
	if (m_featureKeyedInfo.size() > 16 && itr->second.Empty())
	{
		m_featureKeyedInfo.erase(itr->first); // Alberts2 - Erase empty elemnts to save memory
		return NULL;
	}
	return &(itr->second);
}

UnitCombatKeyedInfo* CvUnit::findOrCreateUnitCombatKeyedInfo(UnitCombatTypes eUnitCombat, bool bCreate)
{
	std::map<UnitCombatTypes, UnitCombatKeyedInfo>::iterator itr = m_unitCombatKeyedInfo.find(eUnitCombat);

	if (itr != m_unitCombatKeyedInfo.end())
	{
		return &(itr->second);
	}

	if (bCreate)
	{
		UnitCombatKeyedInfo	newInfo;

		return &(m_unitCombatKeyedInfo.insert(std::make_pair(eUnitCombat, newInfo)).first->second);
	}

	return NULL;
}

const UnitCombatKeyedInfo* CvUnit::findUnitCombatKeyedInfo(UnitCombatTypes eUnitCombat) const
{
	std::map<UnitCombatTypes, UnitCombatKeyedInfo>::const_iterator itr = m_unitCombatKeyedInfo.find(eUnitCombat);

	if (itr == m_unitCombatKeyedInfo.end())
	{
		return NULL;
	}
	if (m_unitCombatKeyedInfo.size() > 32 && itr->second.Empty())
	{
		m_unitCombatKeyedInfo.erase(itr->first); // Alberts2 - Erase empty elemnts to save memory
		return NULL;
	}
	return &(itr->second);
}

std::map<UnitCombatTypes, UnitCombatKeyedInfo>& CvUnit::getUnitCombatKeyedInfo() const
{
	return m_unitCombatKeyedInfo;
}

bool CvUnit::isHealsUnitCombat(UnitCombatTypes eIndex) const
{
	FASSERT_BOUNDS(NO_UNITCOMBAT, GC.getNumUnitCombatInfos(), eIndex);
	const UnitCombatKeyedInfo* info = findUnitCombatKeyedInfo(eIndex);

	return (info != NULL && (info->m_iHealUnitCombatTypeVolume > 0));
}

bool CvUnit::isHasUnitCombat(UnitCombatTypes eIndex) const
{
	FASSERT_BOUNDS(NO_UNITCOMBAT, GC.getNumUnitCombatInfos(), eIndex);
	const UnitCombatKeyedInfo* info = findUnitCombatKeyedInfo(eIndex);

	return (info != NULL && info->m_bHasUnitCombat);
}

void CvUnit::processUnitCombat(UnitCombatTypes eIndex, bool bAdding, bool bByPromo)
{
	PROFILE_EXTRA_FUNC();
	const CvUnitCombatInfo& kUnitCombat = GC.getUnitCombatInfo(eIndex);
	const int iChange = (bAdding ? 1 : -1);
	int	iI;

	bool bSM = GC.getGame().isOption(GAMEOPTION_COMBAT_SIZE_MATTERS);

	if (bSM)
	{
		if (!bByPromo)
		{
			if (kUnitCombat.getQualityBase() > -10)
			{
				setQualityBaseTotal(kUnitCombat.getQualityBase());
			}
			if (kUnitCombat.getSizeBase() > -10)
			{
				setSizeBaseTotal(kUnitCombat.getSizeBase());
			}
			if (kUnitCombat.getGroupBase() > -10)
			{
				setGroupBaseTotal(kUnitCombat.getGroupBase());
			}
		}
		if (bAdding && kUnitCombat.getGroupBase() > -10)
		{
			calcUpkeepMultiplierSM(kUnitCombat.getGroupBase() - getGroupBaseTotal());
		}
	}

	changeExtraVisibilityRange(kUnitCombat.getVisibilityChange() * iChange);//no merge/split diff
	changeExtraMoves(kUnitCombat.getMovesChange() * iChange);//no merge/split diff
	changeExtraMoveDiscount(kUnitCombat.getMoveDiscountChange() * iChange);//no merge/split diff
	changeExtraAirRange(kUnitCombat.getAirRangeChange() * iChange);//no merge/split diff
	changeExtraIntercept(kUnitCombat.getInterceptChange() * iChange);//no merge/split diff
	changeExtraEvasion(kUnitCombat.getEvasionChange() * iChange);//no merge/split diff
	if (isAnimal())
	{
		if (GC.getGame().isOption(GAMEOPTION_COMBAT_FIGHT_OR_FLIGHT))
		{
			changeExtraWithdrawal(kUnitCombat.getWithdrawalChange() * iChange);//no merge/split diff
		}
	}
	else
	{
		changeExtraWithdrawal(kUnitCombat.getWithdrawalChange() * iChange);//no merge/split diff
	}
	changeCargoSpace(kUnitCombat.getCargoChange() * iChange);//no merge/split diff (since this mechanism is either a base setter or is for non-SM or non-player on SM.

	changeSMCargoSpace(kUnitCombat.getSMCargoChange() * iChange);//merge/split volumetric
	changeCargoVolume(kUnitCombat.getSMCargoVolumeChange() * iChange);//merge/split volumetric
	changeCargoVolumeModifier(kUnitCombat.getSMCargoVolumeModifierChange() * iChange);//merge/split volumetric

	changeExtraCollateralDamage(kUnitCombat.getCollateralDamageChange() * iChange);//I suspect no merge/split
	changeExtraBombardRate(kUnitCombat.getBombardRateChange() * iChange);//no merge/split (affect this volumetrically on the final value)
	changeExtraFirstStrikes(kUnitCombat.getFirstStrikesChange() * iChange);//no merge/split
	changeExtraChanceFirstStrikes(kUnitCombat.getChanceFirstStrikesChange() * iChange);//no merge/split
	changeExtraEnemyHeal(kUnitCombat.getEnemyHealChange() * iChange);//no merge/split (modified but not multiplicative)
	changeExtraNeutralHeal(kUnitCombat.getNeutralHealChange() * iChange);//no merge/split (modified but not multiplicative)
	changeExtraFriendlyHeal(kUnitCombat.getFriendlyHealChange() * iChange);//no merge/split (modified but not multiplicative)
	changeSameTileHeal(kUnitCombat.getSameTileHealChange() * iChange);//no merge/split (modified but not multiplicative)
	changeAdjacentTileHeal(kUnitCombat.getAdjacentTileHealChange() * iChange);//no merge/split (modified but not multiplicative)
	changeExtraCombatPercent(kUnitCombat.getCombatPercent() * iChange);//no merge/split
	changeExtraCityAttackPercent(kUnitCombat.getCityAttackPercent() * iChange);//no merge/split
	changeExtraCityDefensePercent(kUnitCombat.getCityDefensePercent() * iChange);//no merge/split
	changeExtraHillsAttackPercent(kUnitCombat.getHillsAttackPercent() * iChange);//no merge/split
	changeExtraHillsDefensePercent(kUnitCombat.getHillsDefensePercent() * iChange);//no merge/split
	// Assume only worker units can get the relevant unit combats, if not then we'll need a retroactive unitComp late init function.
	if (isWorker())
	{
		bool bChanged = false;
		if (kUnitCombat.getHillsWorkPercent() != 0)
		{
			m_worker->changeHillsWorkModifier(kUnitCombat.getHillsWorkPercent() * iChange);
			bChanged = true;
		}
		if (kUnitCombat.getPeaksWorkPercent() != 0)
		{
			m_worker->changePeaksWorkModifier(kUnitCombat.getPeaksWorkPercent() * iChange);
			bChanged = true;
		}
		if (kUnitCombat.getWorkRatePercent() != 0)
		{
			m_worker->changeWorkModifier(kUnitCombat.getWorkRatePercent() * iChange);
			bChanged = true;
		}
		for (int iI = 0; iI < kUnitCombat.getNumBuildWorkChangeModifiers(); iI++)
		{
			m_worker->changeExtraWorkModForBuild((BuildTypes)kUnitCombat.getBuildWorkChangeModifier(iI).eBuild, kUnitCombat.getBuildWorkChangeModifier(iI).iModifier * iChange);
			bChanged = true;
		}
		if (bChanged) setInfoBarDirty(true);
	}
	changeRevoltProtection(kUnitCombat.getRevoltProtection() * iChange);// merge/split
	changeCollateralDamageProtection(kUnitCombat.getCollateralDamageProtection() * iChange);//no merge/split
	changePillageChange(kUnitCombat.getPillageChange() * iChange);//no merge/split
	changeUpgradeDiscount(kUnitCombat.getUpgradeDiscount() * iChange);//no merge/split (modified but not multiplicative)
	changeExperiencePercent(kUnitCombat.getExperiencePercent() * iChange);//no merge/split (modified but not multiplicative)
	changeKamikazePercent((kUnitCombat.getKamikazePercent()) * iChange);//no merge/split
	changeAirCombatLimitChange((kUnitCombat.getAirCombatLimitChange()) * iChange);//no merge/split
	changeCelebrityHappy((kUnitCombat.getCelebrityHappy()) * iChange);//no merge/split
	changeCollateralDamageLimitChange((kUnitCombat.getCollateralDamageLimitChange()) * iChange);//no merge/split
	changeCollateralDamageMaxUnitsChange((kUnitCombat.getCollateralDamageMaxUnitsChange()) * iChange);//no merge/split
	changeCombatLimitChange((kUnitCombat.getCombatLimitChange()) * iChange);//no merge/split
	changeExtraDropRange((kUnitCombat.getExtraDropRange()) * iChange);//no merge/split
	changeExtraNoDefensiveBonusCount((kUnitCombat.getNoDefensiveBonusChange()) * iChange);
	changeExtraGatherHerdCount((kUnitCombat.getGatherHerdChange()) * iChange);
	changeSurvivorChance((kUnitCombat.getSurvivorChance()) * iChange);//no merge/split
	changeVictoryAdjacentHeal((kUnitCombat.getVictoryAdjacentHeal()) * iChange);//no merge/split
	changeVictoryHeal((kUnitCombat.getVictoryHeal()) * iChange);//no merge/split
	changeVictoryStackHeal((kUnitCombat.getVictoryStackHeal()) * iChange);//no merge/split
	changeExtraAttackCombatModifier(kUnitCombat.getAttackCombatModifierChange() * iChange);//no merge/split
	changeExtraDefenseCombatModifier(kUnitCombat.getDefenseCombatModifierChange() * iChange);//no merge/split
	changeExtraPursuit(kUnitCombat.getPursuitChange() * iChange);//no merge/split
	changeExtraEarlyWithdraw(kUnitCombat.getEarlyWithdrawChange() * iChange);//no merge/split
	changeExtraVSBarbs(kUnitCombat.getVSBarbsChange() * iChange);//no merge/split
	changeExtraReligiousCombatModifier(kUnitCombat.getReligiousCombatModifierChange() * iChange);//no merge/split
	changeExtraArmor(kUnitCombat.getArmorChange() * iChange);//no merge/split
	changeExtraPuncture(kUnitCombat.getPunctureChange() * iChange);//no merge/split
	changeExtraDamageModifier(kUnitCombat.getDamageModifierChange() * iChange);//no merge/split
	changeExtraOverrun(kUnitCombat.getOverrunChange() * iChange);//no merge/split
	changeExtraRepel(kUnitCombat.getRepelChange() * iChange);//no merge/split
	changeExtraFortRepel(kUnitCombat.getFortRepelChange() * iChange);//no merge/split
	changeExtraRepelRetries(kUnitCombat.getRepelRetriesChange() * iChange);//no merge/split
	changeExtraUnyielding(kUnitCombat.getUnyieldingChange() * iChange);//no merge/split
	changeExtraKnockback(kUnitCombat.getKnockbackChange() * iChange);//no merge/split
	changeExtraKnockbackRetries(kUnitCombat.getKnockbackRetriesChange() * iChange);//no merge/split
#ifdef BATTLEWORN
	changeExtraStrAdjperAtt(kUnitCombat.getStrAdjperAttChange() * iChange);//no merge/split
	changeExtraStrAdjperDef(kUnitCombat.getStrAdjperDefChange() * iChange);//no merge/split
	changeExtraWithdrawAdjperAtt(kUnitCombat.getWithdrawAdjperAttChange() * iChange);//no merge/split
#endif // BATTLEWORN
	changeExtraUnnerve(kUnitCombat.getUnnerveChange() * iChange);//no merge/split
	changeExtraEnclose(kUnitCombat.getEncloseChange() * iChange);//no merge/split
	changeExtraLunge(kUnitCombat.getLungeChange() * iChange);//no merge/split
	changeExtraDynamicDefense(kUnitCombat.getDynamicDefenseChange() * iChange);//no merge/split
	changeExtraStrength(kUnitCombat.getStrengthChange() * iChange);//no merge/split (but included into merge/split mult)
	changeExtraFortitude(kUnitCombat.getFortitudeChange() * iChange);//no merge/split
#ifdef OUTBREAKS_AND_AFFLICTIONS
	for (iI = 0; iI < GC.getNumPropertyInfos(); iI++)
	{
		changeExtraAidChange((PropertyTypes)iI, kUnitCombat.getAidChange(iI) * iChange);//no merge/split
	}
#endif
#ifdef STRENGTH_IN_NUMBERS
	changeExtraFrontSupportPercent(kUnitCombat.getFrontSupportPercentChange() * iChange);//no merge/split
	changeExtraShortRangeSupportPercent(kUnitCombat.getShortRangeSupportPercentChange() * iChange);//no merge/split
	changeExtraMediumRangeSupportPercent(kUnitCombat.getMediumRangeSupportPercentChange() * iChange);//no merge/split
	changeExtraLongRangeSupportPercent(kUnitCombat.getLongRangeSupportPercentChange() * iChange);//no merge/split
	changeExtraFlankSupportPercent(kUnitCombat.getFlankSupportPercentChange() * iChange);//no merge/split
#endif // STRENGTH_IN_NUMBERS

	changeExtraDodgeModifier(kUnitCombat.getDodgeModifierChange() * iChange);//no merge/split
	changeExtraPrecisionModifier(kUnitCombat.getPrecisionModifierChange() * iChange);//no merge/split
	changeExtraPowerShots(kUnitCombat.getPowerShotsChange() * iChange);//no merge/split
	changeExtraPowerShotCombatModifier(kUnitCombat.getPowerShotCombatModifierChange() * iChange);//no merge/split
	changeExtraPowerShotPunctureModifier(kUnitCombat.getPowerShotPunctureModifierChange() * iChange);//no merge/split
	changeExtraPowerShotPrecisionModifier(kUnitCombat.getPowerShotPrecisionModifierChange() * iChange);//no merge/split
	changeExtraPowerShotCriticalModifier(kUnitCombat.getPowerShotCriticalModifierChange() * iChange);//no merge/split
	changeExtraCriticalModifier(kUnitCombat.getCriticalModifierChange() * iChange);//no merge/split
	changeExtraEndurance(kUnitCombat.getEnduranceChange() * iChange);//no merge/split
	changeExtraRoundStunProb(kUnitCombat.getRoundStunProbChange() * iChange);//no merge/split
	changeExtraPoisonProbabilityModifier(kUnitCombat.getPoisonProbabilityModifierChange() * iChange);//no merge/split
	changeExtraCaptureProbabilityModifier(kUnitCombat.getCaptureProbabilityModifierChange() * iChange);//no merge/split
	changeExtraCaptureResistanceModifier(kUnitCombat.getCaptureResistanceModifierChange() * iChange);//no merge/split

	changeExtraBreakdownChance(kUnitCombat.getBreakdownChanceChange() * iChange);//no merge/split (larger/smaller just more/less survivable)
	changeExtraBreakdownDamage(kUnitCombat.getBreakdownDamageChange() * iChange);//no merge/split
	changeExtraTaunt(kUnitCombat.getTauntChange() * iChange);//no merge/split
	changeExtraMaxHP(kUnitCombat.getMaxHPChange() * iChange);//merge/split
	changeExtraStrengthModifier(kUnitCombat.getStrengthModifier() * iChange);//merge/split

	changeExtraCombatModifierPerSizeMore(kUnitCombat.getCombatModifierPerSizeMoreChange() * iChange);//no merge/split
	changeExtraCombatModifierPerSizeLess(kUnitCombat.getCombatModifierPerSizeLessChange() * iChange);//no merge/split
	changeExtraCombatModifierPerVolumeMore(kUnitCombat.getCombatModifierPerVolumeMoreChange() * iChange);//no merge/split
	changeExtraCombatModifierPerVolumeLess(kUnitCombat.getCombatModifierPerVolumeLessChange() * iChange);//no merge/split
	//
	changeExcileCount(kUnitCombat.getExcileChange() * iChange);
	changePassageCount(kUnitCombat.getPassageChange() * iChange);
	changeNoNonOwnedCityEntryCount(kUnitCombat.getNoNonOwnedCityEntryChange() * iChange);
	changeBarbCoExistCount(kUnitCombat.getBarbCoExistChange() * iChange);
	changeBlendIntoCityCount(kUnitCombat.getBlendIntoCityChange() * iChange);
	//
	changeBaseRBombardDamage(kUnitCombat.getRBombardDamageBase() * iChange, bAdding, eIndex);//no merge/split
	changeBaseRBombardDamageLimit(kUnitCombat.getRBombardDamageLimitBase() * iChange, bAdding, eIndex);//no merge/split
	changeBaseRBombardDamageMaxUnits(kUnitCombat.getRBombardDamageMaxUnitsBase() * iChange, bAdding, eIndex);//no merge/split
	changeBaseDCMBombRange(kUnitCombat.getDCMBombRangeBase() * iChange, bAdding, eIndex);//no merge/split
	changeBaseDCMBombAccuracy(kUnitCombat.getDCMBombAccuracyBase() * iChange, bAdding, eIndex);//no merge/split
	changeBombardDirectCount((kUnitCombat.isRBombardDirect()) ? iChange : 0);
	//

	//booleans //no merge/split
	changeDefensiveVictoryMoveCount((kUnitCombat.isDefensiveVictoryMove()) ? iChange : 0);//no merge/split
	changeFreeDropCount((kUnitCombat.isFreeDrop()) ? iChange : 0);//no merge/split
	changeOffensiveVictoryMoveCount((kUnitCombat.isOffensiveVictoryMove()) ? iChange : 0);//no merge/split
	changeOneUpCount((kUnitCombat.isOneUp()) ? iChange : 0);//no merge/split
	changePillageEspionageCount((kUnitCombat.isPillageEspionage()) ? iChange : 0);//no merge/split
	changePillageMarauderCount((kUnitCombat.isPillageMarauder()) ? iChange : 0);//no merge/split
	changePillageOnMoveCount((kUnitCombat.isPillageOnMove()) ? iChange : 0);//no merge/split
	changePillageOnVictoryCount((kUnitCombat.isPillageOnVictory()) ? iChange : 0);//no merge/split
	changePillageResearchCount((kUnitCombat.isPillageResearch()) ? iChange : 0);//no merge/split
	changeBlitzCount((kUnitCombat.isBlitz()) ? iChange : 0);//no merge/split
	changeAmphibCount((kUnitCombat.isAmphib()) ? iChange : 0);//no merge/split
	changeRiverCount((kUnitCombat.isRiver()) ? iChange : 0);//no merge/split
	changeEnemyRouteCount((kUnitCombat.isEnemyRoute()) ? iChange : 0);//no merge/split
	changeAlwaysHealCount((kUnitCombat.isAlwaysHeal()) ? iChange : 0);
	changeHillsDoubleMoveCount((kUnitCombat.isHillsDoubleMove()) ? iChange : 0);
	changeImmuneToFirstStrikesCount((kUnitCombat.isImmuneToFirstStrikes()) ? iChange : 0);
	changeAlwaysInvisibleCount((kUnitCombat.isAlwaysInvisible()) ? iChange : 0);
	changeStampedeCount((kUnitCombat.isStampedeChange()) ? iChange : 0);
	changeStampedeCount((kUnitCombat.isRemoveStampede()) ? -iChange : 0);
	changeAnimalIgnoresBordersCount(kUnitCombat.getAnimalIgnoresBordersChange() * iChange);
	changeOnslaughtCount((kUnitCombat.isOnslaughtChange()) ? iChange : 0);
	changeDealColdDamageCount((kUnitCombat.isMakesDamageCold()) ? iChange : 0);
	changeDealColdDamageCount((kUnitCombat.isMakesDamageNotCold()) ? -iChange : 0);
	changeColdImmuneCount((kUnitCombat.isAddsColdImmunity()) ? iChange : 0);
	changeColdImmuneCount((kUnitCombat.isRemovesColdImmunity()) ? -iChange : 0);
	changeAttackOnlyCitiesCount((kUnitCombat.isAttackOnlyCitiesAdd()) ? iChange : 0);
	changeAttackOnlyCitiesCount((kUnitCombat.isAttackOnlyCitiesSubtract()) ? -iChange : 0);
	changeIgnoreNoEntryLevelCount((kUnitCombat.isIgnoreNoEntryLevelAdd()) ? iChange : 0);
	changeIgnoreNoEntryLevelCount((kUnitCombat.isIgnoreNoEntryLevelSubtract()) ? -iChange : 0);
	changeIgnoreZoneofControlCount((kUnitCombat.isIgnoreZoneofControlAdd()) ? iChange : 0);
	changeIgnoreZoneofControlCount((kUnitCombat.isIgnoreZoneofControlSubtract()) ? -iChange : 0);
	changeFliesToMoveCount((kUnitCombat.isFliesToMoveAdd()) ? iChange : 0);
	changeFliesToMoveCount((kUnitCombat.isFliesToMoveSubtract()) ? -iChange : 0);
	if ( kUnitCombat.changesMoveThroughPlots() )
	{
		m_movementCharacteristicsHash ^= kUnitCombat.getZobristValue();
		m_iMaxMoveCacheTurn = -1;
	}
	changeCanMovePeaksCount((kUnitCombat.isCanMovePeaks()) ? iChange : 0);
	changeCanLeadThroughPeaksCount((kUnitCombat.isCanLeadThroughPeaks()) ? iChange : 0);
	changeZoneOfControlCount((kUnitCombat.isZoneOfControl()) ? iChange : 0);
	changeCannotMergeSplitCount((kUnitCombat.isCannotMergeSplit()) ? iChange : 0);
	changeRBombardForceAbilityCount((kUnitCombat.isRBombardForceAbility()) ? iChange : 0);
	changeNoSelfHealCount((kUnitCombat.isNoSelfHeal()) ? iChange : 0);
	changeExtraSelfHealModifier(kUnitCombat.getSelfHealModifier() * iChange);
	changeExtraNumHealSupport(kUnitCombat.getNumHealSupport() * iChange);
	changeExtraInsidiousness(kUnitCombat.getInsidiousnessChange() * iChange);
	changeExtraInvestigation(kUnitCombat.getInvestigationChange() * iChange);
	changeExtraStealthStrikes(kUnitCombat.getStealthStrikesChange() * iChange);
	changeExtraStealthCombatModifier(kUnitCombat.getStealthCombatModifierChange() * iChange);
	changeStealthDefenseCount(kUnitCombat.getStealthDefenseChange() * iChange);
	changeOnlyDefensiveCount(kUnitCombat.getDefenseOnlyChange() * iChange);
	changeNoInvisibilityCount(kUnitCombat.getNoInvisibilityChange() * iChange);
	changeNoCaptureCount(kUnitCombat.getNoCaptureChange() * iChange);

	// Arrays
	if (kUnitCombat.isAnyDomainModifierPercent())
	{
		for (iI = 0; iI < NUM_DOMAIN_TYPES; iI++)
		{
			changeExtraDomainModifier(((DomainTypes)iI), (kUnitCombat.getDomainModifierPercent(iI) * iChange));
		}
	}

#ifdef OUTBREAKS_AND_AFFLICTIONS
	// bool vector with delayed resolution
	if (GC.getGame().isOption(GAMEOPTION_COMBAT_OUTBREAKS_AND_AFFLICTIONS))
	{
		for (iI = 0; iI < kUnitCombat.getNumCureAfflictionChangeTypes(); iI++)
		{
			changeCureAfflictionCount(((PromotionLineTypes)kUnitCombat.getCureAfflictionChangeType(iI)), iChange);
		}
		for (iI = 0; iI < kUnitCombat.getNumAfflictionFortitudeChangeModifiers(); iI++)
		{
			changeFortitudeModifierTypeAmount(((PromotionLineTypes)kUnitCombat.getAfflictionFortitudeChangeModifier(iI).ePromotionLine), kUnitCombat.getAfflictionFortitudeChangeModifier(iI).iModifier * iChange);
		}
	}
#endif // OUTBREAKS_AND_AFFLICTIONS

	for (iI = 0; iI < kUnitCombat.getNumTerrainIgnoreDamageChangeTypes(); iI++)
	{
		changeTerrainProtected(((TerrainTypes)kUnitCombat.getTerrainIgnoreDamageChangeType(iI)), iChange);
	}

	for (iI = 0; iI < kUnitCombat.getNumTerrainDoubleMoveChangeTypes(); iI++)
	{
		changeTerrainDoubleMoveCount(((TerrainTypes)kUnitCombat.getTerrainDoubleMoveChangeType(iI)), iChange);
	}

	for (iI = 0; iI < kUnitCombat.getNumFeatureDoubleMoveChangeTypes(); iI++)
	{
		changeFeatureDoubleMoveCount(((FeatureTypes)kUnitCombat.getFeatureDoubleMoveChangeType(iI)), iChange);
	}

	for (iI = 0; iI < kUnitCombat.getNumTrapImmunityUnitCombatTypes(); iI++)
	{
		changeTrapImmunityUnitCombatCount((UnitCombatTypes)kUnitCombat.getTrapImmunityUnitCombatType(iI), iChange);
	}

#ifdef OUTBREAKS_AND_AFFLICTIONS
	for (iI = 0; iI < kUnitCombat.getNumDistanceAttackCommunicabilityTypeChanges(); iI++)
	{
		changeDistanceAttackCommunicability((PromotionLineTypes)kUnitCombat.getDistanceAttackCommunicabilityTypeChange(iI).eAfflictionLine, kUnitCombat.getDistanceAttackCommunicabilityTypeChange(iI).iChange * iChange);
	}
#endif
	// int vector utilizing pairing without delayed resolution
	for (iI = 0; iI < GC.getNumTerrainInfos(); iI++)
	{
		changeExtraWithdrawOnTerrainType(((TerrainTypes)iI), (kUnitCombat.getWithdrawOnTerrainTypeChange(iI) * iChange));
	}

	for (iI = 0; iI < GC.getNumFeatureInfos(); iI++)
	{
		changeExtraWithdrawOnFeatureType(((FeatureTypes)iI), (kUnitCombat.getWithdrawOnFeatureTypeChange(iI) * iChange));
	}

	for (iI = 0; iI < GC.getNumInvisibleInfos(); iI++)
	{
		changeExtraVisibilityIntensityType(((InvisibleTypes)iI), (kUnitCombat.getVisibilityIntensityChangeType(iI) * iChange));
		changeExtraInvisibilityIntensityType(((InvisibleTypes)iI), (kUnitCombat.getInvisibilityIntensityChangeType(iI) * iChange));
		changeExtraVisibilityIntensityRangeType(((InvisibleTypes)iI), (kUnitCombat.getVisibilityIntensityRangeChangeType(iI) * iChange));
		changeExtraVisibilityIntensitySameTileType(((InvisibleTypes)iI), (kUnitCombat.getVisibilityIntensitySameTileChangeType(iI) * iChange));
	}

	for (iI = 0; iI < kUnitCombat.getNumInvisibleTerrainChanges(); iI++)
	{
		changeExtraInvisibleTerrain((InvisibleTypes)kUnitCombat.getInvisibleTerrainChange(iI).eInvisible,(TerrainTypes)kUnitCombat.getInvisibleTerrainChange(iI).eTerrain, kUnitCombat.getInvisibleTerrainChange(iI).iIntensity * iChange);
	}

	for (iI = 0; iI < kUnitCombat.getNumInvisibleFeatureChanges(); iI++)
	{
		changeExtraInvisibleFeature((InvisibleTypes)kUnitCombat.getInvisibleFeatureChange(iI).eInvisible,(FeatureTypes)kUnitCombat.getInvisibleFeatureChange(iI).eFeature, kUnitCombat.getInvisibleFeatureChange(iI).iIntensity * iChange);
	}

	for (iI = 0; iI < kUnitCombat.getNumInvisibleImprovementChanges(); iI++)
	{
		changeExtraInvisibleImprovement((InvisibleTypes)kUnitCombat.getInvisibleImprovementChange(iI).eInvisible,(ImprovementTypes)kUnitCombat.getInvisibleImprovementChange(iI).eImprovement, kUnitCombat.getInvisibleImprovementChange(iI).iIntensity * iChange);
	}

	for (iI = 0; iI < kUnitCombat.getNumVisibleTerrainChanges(); iI++)
	{
		changeExtraVisibleTerrain((InvisibleTypes)kUnitCombat.getVisibleTerrainChange(iI).eInvisible,(TerrainTypes)kUnitCombat.getVisibleTerrainChange(iI).eTerrain, kUnitCombat.getVisibleTerrainChange(iI).iIntensity * iChange);
	}

	for (iI = 0; iI < kUnitCombat.getNumVisibleFeatureChanges(); iI++)
	{
		changeExtraVisibleFeature((InvisibleTypes)kUnitCombat.getVisibleFeatureChange(iI).eInvisible,(FeatureTypes)kUnitCombat.getVisibleFeatureChange(iI).eFeature, kUnitCombat.getVisibleFeatureChange(iI).iIntensity * iChange);
	}

	for (iI = 0; iI < kUnitCombat.getNumVisibleImprovementChanges(); iI++)
	{
		changeExtraVisibleImprovement((InvisibleTypes)kUnitCombat.getVisibleImprovementChange(iI).eInvisible,(ImprovementTypes)kUnitCombat.getVisibleImprovementChange(iI).eImprovement, kUnitCombat.getVisibleImprovementChange(iI).iIntensity * iChange);
	}

	for (iI = 0; iI < kUnitCombat.getNumVisibleTerrainRangeChanges(); iI++)
	{
		changeExtraVisibleTerrainRange((InvisibleTypes)kUnitCombat.getVisibleTerrainRangeChange(iI).eInvisible,(TerrainTypes)kUnitCombat.getVisibleTerrainRangeChange(iI).eTerrain, kUnitCombat.getVisibleTerrainRangeChange(iI).iIntensity * iChange);
	}

	for (iI = 0; iI < kUnitCombat.getNumVisibleFeatureRangeChanges(); iI++)
	{
		changeExtraVisibleFeatureRange((InvisibleTypes)kUnitCombat.getVisibleFeatureRangeChange(iI).eInvisible,(FeatureTypes)kUnitCombat.getVisibleFeatureRangeChange(iI).eFeature, kUnitCombat.getVisibleFeatureRangeChange(iI).iIntensity * iChange);
	}

	for (iI = 0; iI < kUnitCombat.getNumVisibleImprovementRangeChanges(); iI++)
	{
		changeExtraVisibleImprovementRange((InvisibleTypes)kUnitCombat.getVisibleImprovementRangeChange(iI).eInvisible,(ImprovementTypes)kUnitCombat.getVisibleImprovementRangeChange(iI).eImprovement, kUnitCombat.getVisibleImprovementRangeChange(iI).iIntensity * iChange);
	}

	// int vector utilizing struct with delayed resolution
	for (iI = 0; iI < kUnitCombat.getNumTerrainAttackChangeModifiers(); iI++)
	{
		changeExtraTerrainAttackPercent(((TerrainTypes)kUnitCombat.getTerrainAttackChangeModifier(iI).eTerrain), kUnitCombat.getTerrainAttackChangeModifier(iI).iModifier * iChange);
	}

	for (iI = 0; iI < kUnitCombat.getNumTerrainDefenseChangeModifiers(); iI++)
	{
		changeExtraTerrainDefensePercent(((TerrainTypes)kUnitCombat.getTerrainDefenseChangeModifier(iI).eTerrain), kUnitCombat.getTerrainDefenseChangeModifier(iI).iModifier * iChange);
	}

	for (iI = 0; iI < kUnitCombat.getNumTerrainWorkChangeModifiers(); iI++)
	{
		changeExtraTerrainWorkPercent(((TerrainTypes)kUnitCombat.getTerrainWorkChangeModifier(iI).eTerrain), kUnitCombat.getTerrainWorkChangeModifier(iI).iModifier * iChange);
	}

	for (iI = 0; iI < kUnitCombat.getNumFeatureAttackChangeModifiers(); iI++)
	{
		changeExtraFeatureAttackPercent(((FeatureTypes)kUnitCombat.getFeatureAttackChangeModifier(iI).eFeature), kUnitCombat.getFeatureAttackChangeModifier(iI).iModifier * iChange);
	}

	for (iI = 0; iI < kUnitCombat.getNumFeatureDefenseChangeModifiers(); iI++)
	{
		changeExtraFeatureDefensePercent(((FeatureTypes)kUnitCombat.getFeatureDefenseChangeModifier(iI).eFeature), kUnitCombat.getFeatureDefenseChangeModifier(iI).iModifier * iChange);
	}

	for (iI = 0; iI < kUnitCombat.getNumFeatureWorkChangeModifiers(); iI++)
	{
		changeExtraFeatureWorkPercent(((FeatureTypes)kUnitCombat.getFeatureWorkChangeModifier(iI).eFeature), kUnitCombat.getFeatureWorkChangeModifier(iI).iModifier * iChange);
	}

	for (iI = 0; iI < kUnitCombat.getNumUnitCombatChangeModifiers(); iI++)
	{
		changeExtraUnitCombatModifier(((UnitCombatTypes)kUnitCombat.getUnitCombatChangeModifier(iI).eUnitCombat), kUnitCombat.getUnitCombatChangeModifier(iI).iModifier * iChange);
	}

	for (iI = 0; iI < kUnitCombat.getNumFlankingStrengthbyUnitCombatTypesChange(); iI++)
	{
		changeExtraFlankingStrengthbyUnitCombatType(((UnitCombatTypes)kUnitCombat.getFlankingStrengthbyUnitCombatTypeChange(iI).eUnitCombat), kUnitCombat.getFlankingStrengthbyUnitCombatTypeChange(iI).iModifier * iChange);
	}

	for (iI = 0; iI < kUnitCombat.getNumWithdrawVSUnitCombatTypesChange(); iI++)
	{
		changeExtraWithdrawVSUnitCombatType(((UnitCombatTypes)kUnitCombat.getWithdrawVSUnitCombatTypeChange(iI).eUnitCombat), kUnitCombat.getWithdrawVSUnitCombatTypeChange(iI).iModifier * iChange);
	}

	if (GC.getGame().isOption(GAMEOPTION_COMBAT_FIGHT_OR_FLIGHT))
	{
		for (iI = 0; iI < kUnitCombat.getNumPursuitVSUnitCombatTypesChange(); iI++)
		{
			changeExtraPursuitVSUnitCombatType(((UnitCombatTypes)kUnitCombat.getPursuitVSUnitCombatTypeChange(iI).eUnitCombat), kUnitCombat.getPursuitVSUnitCombatTypeChange(iI).iModifier * iChange);
		}
	}

	if (GC.getGame().isOption(GAMEOPTION_COMBAT_HEART_OF_WAR))
	{
		for (iI = 0; iI < kUnitCombat.getNumRepelVSUnitCombatTypesChange(); iI++)
		{
			changeExtraRepelVSUnitCombatType(((UnitCombatTypes)kUnitCombat.getRepelVSUnitCombatTypeChange(iI).eUnitCombat), kUnitCombat.getRepelVSUnitCombatTypeChange(iI).iModifier * iChange);
		}

		for (iI = 0; iI < kUnitCombat.getNumKnockbackVSUnitCombatTypesChange(); iI++)
		{
			changeExtraKnockbackVSUnitCombatType(((UnitCombatTypes)kUnitCombat.getKnockbackVSUnitCombatTypeChange(iI).eUnitCombat), kUnitCombat.getKnockbackVSUnitCombatTypeChange(iI).iModifier * iChange);
		}
	}

	for (iI = 0; iI < kUnitCombat.getNumPunctureVSUnitCombatTypesChange(); iI++)
	{
		changeExtraPunctureVSUnitCombatType(((UnitCombatTypes)kUnitCombat.getPunctureVSUnitCombatTypeChange(iI).eUnitCombat), kUnitCombat.getPunctureVSUnitCombatTypeChange(iI).iModifier * iChange);
	}

	for (iI = 0; iI < kUnitCombat.getNumArmorVSUnitCombatTypesChange(); iI++)
	{
		changeExtraArmorVSUnitCombatType(((UnitCombatTypes)kUnitCombat.getArmorVSUnitCombatTypeChange(iI).eUnitCombat), kUnitCombat.getArmorVSUnitCombatTypeChange(iI).iModifier * iChange);
	}

	for (iI = 0; iI < kUnitCombat.getNumDodgeVSUnitCombatTypesChange(); iI++)
	{
		changeExtraDodgeVSUnitCombatType(((UnitCombatTypes)kUnitCombat.getDodgeVSUnitCombatTypeChange(iI).eUnitCombat), kUnitCombat.getDodgeVSUnitCombatTypeChange(iI).iModifier * iChange);
	}

	for (iI = 0; iI < kUnitCombat.getNumPrecisionVSUnitCombatTypesChange(); iI++)
	{
		changeExtraPrecisionVSUnitCombatType(((UnitCombatTypes)kUnitCombat.getPrecisionVSUnitCombatTypeChange(iI).eUnitCombat), kUnitCombat.getPrecisionVSUnitCombatTypeChange(iI).iModifier * iChange);
	}

	for (iI = 0; iI < kUnitCombat.getNumCriticalVSUnitCombatTypesChange(); iI++)
	{
		changeExtraCriticalVSUnitCombatType(((UnitCombatTypes)kUnitCombat.getCriticalVSUnitCombatTypeChange(iI).eUnitCombat), kUnitCombat.getCriticalVSUnitCombatTypeChange(iI).iModifier * iChange);
	}

	for (iI = 0; iI < kUnitCombat.getNumRoundStunVSUnitCombatTypesChange(); iI++)
	{
		changeExtraRoundStunVSUnitCombatType(((UnitCombatTypes)kUnitCombat.getRoundStunVSUnitCombatTypeChange(iI).eUnitCombat), kUnitCombat.getRoundStunVSUnitCombatTypeChange(iI).iModifier * iChange);
	}

	for (iI = 0; iI < kUnitCombat.getNumTrapAvoidanceUnitCombatTypes(); iI++)
	{
		changeExtraTrapAvoidanceUnitCombatType(((UnitCombatTypes)kUnitCombat.getTrapAvoidanceUnitCombatType(iI).eUnitCombat), kUnitCombat.getTrapAvoidanceUnitCombatType(iI).iModifier * iChange);
	}

#ifdef OUTBREAKS_AND_AFFLICTIONS
	for (iI = 0; iI < kUnitCombat.getNumAfflictOnAttackChangeTypes(); iI++)
	{
		changeAfflictOnAttackTypeCount(((PromotionLineTypes)kUnitCombat.getAfflictOnAttackChangeType(iI).eAfflictionLine), iChange);
		changeAfflictOnAttackTypeProbability(((PromotionLineTypes)kUnitCombat.getAfflictOnAttackChangeType(iI).eAfflictionLine), kUnitCombat.getAfflictOnAttackChangeType(iI).iProbabilityChange * iChange);
		changeAfflictOnAttackTypeMeleeCount(((PromotionLineTypes)kUnitCombat.getAfflictOnAttackChangeType(iI).eAfflictionLine), kUnitCombat.getAfflictOnAttackChangeType(iI).iMelee * iChange);
		changeAfflictOnAttackTypeDistanceCount(((PromotionLineTypes)kUnitCombat.getAfflictOnAttackChangeType(iI).eAfflictionLine), kUnitCombat.getAfflictOnAttackChangeType(iI).iDistance * iChange);
		changeAfflictOnAttackTypeImmediateCount(((PromotionLineTypes)kUnitCombat.getAfflictOnAttackChangeType(iI).eAfflictionLine), kUnitCombat.getAfflictOnAttackChangeType(iI).iImmediate * iChange);
	}
#endif
	if (bSM && bByPromo)
	{
		setSMValues();
	}

	if (kUnitCombat.getReligion() != NO_RELIGION)
	{
		defineReligion();
	}

	changeExtraUpkeep100(kUnitCombat.getExtraUpkeep100() * iChange);
	changeUpkeepModifier(kUnitCombat.getUpkeepModifier() * iChange);

	establishBuildups();

	if (bByPromo)
	{
		setGGExperienceEarnedTowardsType();
	}
}

void CvUnit::setHasUnitCombat(UnitCombatTypes eIndex, bool bNewValue, bool bByPromo)
{
	PROFILE_FUNC();

	if (isHasUnitCombat(eIndex) != bNewValue)
	{
		const CvUnitCombatInfo& info = GC.getUnitCombatInfo(eIndex);

		if (GC.getGame().isValidByGameOption(info)
		// Disable spy promotions mechanism, exempt commando promotion
		&& (!isSpy() || GC.isSS_ENABLED() || info.isEnemyRoute()))
		{
			UnitCombatKeyedInfo* infoKeyed =
			(
				bNewValue
				?
				findOrCreateUnitCombatKeyedInfo(eIndex)
				:
				(UnitCombatKeyedInfo*)findUnitCombatKeyedInfo(eIndex)
			);

			if (infoKeyed != NULL)
			{
				infoKeyed->m_bHasUnitCombat = bNewValue;
			}
			processUnitCombat(eIndex, bNewValue, bByPromo);

			AI_flushValueCache();

			//	Updates the grpahics last after everything is calculated
			//  Not entirely sure this will be necessary?  Koshling what say you?
			if (IsSelected())
			{
				gDLL->getInterfaceIFace()->setDirty(SelectionButtons_DIRTY_BIT, true);
				gDLL->getInterfaceIFace()->setDirty(InfoPane_DIRTY_BIT, true);
			}

			//update graphics
			if (!isUsingDummyEntities() && isInViewport())
			{
				gDLL->getEntityIFace()->updatePromotionLayers(getUnitEntity());
			}
		}
	}
}

bool CvUnit::isHasPromotion(PromotionTypes eIndex) const
{
	FASSERT_BOUNDS(NO_PROMOTION, GC.getNumPromotionInfos(), eIndex);
	const PromotionKeyedInfo* info = findPromotionKeyedInfo(eIndex);

	return (info != NULL && info->m_bHasPromotion);
}

void CvUnit::processPromotion(PromotionTypes eIndex, bool bAdding, bool bInitial)
{
	PROFILE_EXTRA_FUNC();
	const CvPromotionInfo& kPromotion = GC.getPromotionInfo(eIndex);
	const int iChange = (bAdding ? 1 : -1);
	int	iI;
	bool bSMrecalc = false;

#ifdef OUTBREAKS_AND_AFFLICTIONS
	//	On affliction removal get rid of the accrued per-turn detrimental effects
	if (kPromotion.isAffliction() && !bAdding)
	{
		// Make sure we don't remove or reset these counts if we're taking away lesser versions of worsening afflictions
		PromotionLineTypes eAfflictionLine = kPromotion.getPromotionLine();
		if (kPromotion.getLinePriority() > getAfflictionLineCount(eAfflictionLine))
		{
			removeAfflictionHits(eIndex);
			setAfflictionHitCount(eIndex, 0);
		}
	}
#endif

	if (kPromotion.isParalyze() && bAdding)
	{
		setImmobileTimer(1);
	}

	if ( kPromotion.changesMoveThroughPlots() )
	{
		m_movementCharacteristicsHash ^= kPromotion.getZobristValue();
		m_iMaxMoveCacheTurn = -1;
	}

	CvWString szNullValue;
	CvWString szNewValue = kPromotion.getRenamesUnitTo();
	if (szNewValue != szNullValue)
	{
		setName(szNewValue);
	}

	if (kPromotion.getDomainCargoChange() != NO_DOMAIN)
	{
		if (bAdding)
		{
			setNewDomainCargo(kPromotion.getDomainCargoChange());
		}
		else
		{
			setNewDomainCargo(NO_DOMAIN);
		}
	}
	if (kPromotion.getSpecialCargoChange() != NO_SPECIALUNIT)
	{
		if (bAdding)
		{
			setNewSpecialCargo(kPromotion.getSpecialCargoChange());
		}
		else
		{
			setNewSpecialCargo(NO_SPECIALUNIT);
		}
	}

	if (kPromotion.getSMNotSpecialCargoChange() != NO_SPECIALUNIT)
	{
		if (bAdding)
		{
			setNewSMNotSpecialCargo(kPromotion.getSMNotSpecialCargoChange());
		}
		else
		{
			setNewSMNotSpecialCargo(NO_SPECIALUNIT);
		}
	}

	for (iI = 0; iI < kPromotion.getNumAddsBuildTypes(); iI++)
	{
		changeExtraBuildType(bAdding, (BuildTypes)kPromotion.getAddsBuildType(iI));
	}

	changeBlitzCount((kPromotion.isBlitz()) ? iChange : 0);
	changeAmphibCount((kPromotion.isAmphib()) ? iChange : 0);
	changeRiverCount((kPromotion.isRiver()) ? iChange : 0);
	changeEnemyRouteCount((kPromotion.isEnemyRoute()) ? iChange : 0);
	changeAlwaysHealCount((kPromotion.isAlwaysHeal()) ? iChange : 0);
	changeHillsDoubleMoveCount((kPromotion.isHillsDoubleMove()) ? iChange : 0);

	changeCanMovePeaksCount((kPromotion.isCanMovePeaks()) ? iChange : 0);
	//	Koshling - enhanced mountaineering mode to differentiate between ability to move through
	//	mountains, and ability to lead a stack through mountains
	changeCanLeadThroughPeaksCount((kPromotion.isCanLeadThroughPeaks()) ? iChange : 0);

	// Toffer - Assume promotions with commander stats can only be gained by commanders.
	//	If assumption is wrong, we'll need setCommander(true) to go through all promotions the unit has,
	//	and apply commander specific stats at that point.
	if (isCommander())
	{
		m_commander->changeControlPoints(kPromotion.getControlPoints() * iChange);
		m_commander->changeCommandRange(kPromotion.getCommandRange() * iChange);
	}
	if (isCommodore())
    {
    	m_commodore->changeControlPoints(kPromotion.getControlPoints() * iChange);
    	m_commodore->changeCommandRange(kPromotion.getCommandRange() * iChange);
    }

	changeImmuneToFirstStrikesCount((kPromotion.isImmuneToFirstStrikes()) ? iChange : 0);

	changeDefensiveVictoryMoveCount((kPromotion.isDefensiveVictoryMove()) ? iChange : 0);
	changeFreeDropCount((kPromotion.isFreeDrop()) ? iChange : 0);
	changeOffensiveVictoryMoveCount((kPromotion.isOffensiveVictoryMove()) ? iChange : 0);

	changeOneUpCount((kPromotion.isOneUp()) ? iChange : 0);
	changePillageEspionageCount((kPromotion.isPillageEspionage()) ? iChange : 0);
	changePillageMarauderCount((kPromotion.isPillageMarauder()) ? iChange : 0);
	changePillageOnMoveCount((kPromotion.isPillageOnMove()) ? iChange : 0);
	changePillageOnVictoryCount((kPromotion.isPillageOnVictory()) ? iChange : 0);
	changePillageResearchCount((kPromotion.isPillageResearch()) ? iChange : 0);
	changeAirCombatLimitChange((kPromotion.getAirCombatLimitChange()) * iChange);
	changeCelebrityHappy((kPromotion.getCelebrityHappy()) * iChange);
	changeCollateralDamageLimitChange((kPromotion.getCollateralDamageLimitChange()) * iChange);
	changeCollateralDamageMaxUnitsChange((kPromotion.getCollateralDamageMaxUnitsChange()) * iChange);
	changeCombatLimitChange((kPromotion.getCombatLimitChange()) * iChange);
	changeExtraDropRange((kPromotion.getExtraDropRange()) * iChange);
	changeExtraNoDefensiveBonusCount((kPromotion.getNoDefensiveBonusChange()) * iChange);
	changeExtraGatherHerdCount((kPromotion.getGatherHerdChange()) * iChange);

	changeSurvivorChance((kPromotion.getSurvivorChance()) * iChange);
	changeVictoryAdjacentHeal((kPromotion.getVictoryAdjacentHeal()) * iChange);
	changeVictoryHeal((kPromotion.getVictoryHeal()) * iChange);
	changeVictoryStackHeal((kPromotion.getVictoryStackHeal()) * iChange);

	changeExtraVisibilityRange(kPromotion.getVisibilityChange() * iChange);
	changeExtraMoves(kPromotion.getMovesChange() * iChange);
	changeExtraMoveDiscount(kPromotion.getMoveDiscountChange() * iChange);
	changeExtraAirRange(kPromotion.getAirRangeChange() * iChange);
	changeExtraIntercept(kPromotion.getInterceptChange() * iChange);
	changeExtraEvasion(kPromotion.getEvasionChange() * iChange);
	changeExtraFirstStrikes(kPromotion.getFirstStrikesChange() * iChange);
	changeExtraChanceFirstStrikes(kPromotion.getChanceFirstStrikesChange() * iChange);
	changeExtraWithdrawal(kPromotion.getWithdrawalChange() * iChange);
	//TB Combat Mods Begin
	changeExtraAttackCombatModifier(kPromotion.getAttackCombatModifierChange() * iChange);
	changeExtraDefenseCombatModifier(kPromotion.getDefenseCombatModifierChange() * iChange);
	changeExtraPursuit(kPromotion.getPursuitChange() * iChange);
	changeExtraEarlyWithdraw(kPromotion.getEarlyWithdrawChange() * iChange);
	changeExtraVSBarbs(kPromotion.getVSBarbsChange() * iChange);
	changeExtraReligiousCombatModifier(kPromotion.getReligiousCombatModifierChange() * iChange);
	changeExtraArmor(kPromotion.getArmorChange() * iChange);
	changeExtraPuncture(kPromotion.getPunctureChange() * iChange);
	changeExtraDamageModifier(kPromotion.getDamageModifierChange() * iChange);

	changeExtraUpkeep100(kPromotion.getExtraUpkeep100() * iChange);
	changeUpkeepModifier(kPromotion.getUpkeepModifier() * iChange);

	changeExtraOverrun(kPromotion.getOverrunChange() * iChange);
	changeExtraRepel(kPromotion.getRepelChange() * iChange);
	changeExtraFortRepel(kPromotion.getFortRepelChange() * iChange);
	changeExtraRepelRetries(kPromotion.getRepelRetriesChange() * iChange);
	changeExtraUnyielding(kPromotion.getUnyieldingChange() * iChange);
	changeExtraKnockback(kPromotion.getKnockbackChange() * iChange);
	changeExtraKnockbackRetries(kPromotion.getKnockbackRetriesChange() * iChange);
	changeStampedeCount((kPromotion.isStampedeChange()) ? iChange : 0);
	changeStampedeCount((kPromotion.isRemoveStampede()) ? -iChange : 0);
	changeAttackOnlyCitiesCount((kPromotion.isAttackOnlyCitiesAdd()) ? iChange : 0);
	changeAttackOnlyCitiesCount((kPromotion.isAttackOnlyCitiesSubtract()) ? -iChange : 0);
	changeIgnoreNoEntryLevelCount((kPromotion.isIgnoreNoEntryLevelAdd()) ? iChange : 0);
	changeIgnoreNoEntryLevelCount((kPromotion.isIgnoreNoEntryLevelSubtract()) ? -iChange : 0);
	changeIgnoreZoneofControlCount((kPromotion.isIgnoreZoneofControlAdd()) ? iChange : 0);
	changeIgnoreZoneofControlCount((kPromotion.isIgnoreZoneofControlSubtract()) ? -iChange : 0);
	changeFliesToMoveCount((kPromotion.isFliesToMoveAdd()) ? iChange : 0);
	changeFliesToMoveCount((kPromotion.isFliesToMoveSubtract()) ? -iChange : 0);
#ifdef BATTLEWORN
	changeExtraStrAdjperRnd(kPromotion.getStrAdjperRndChange() * iChange);
	changeExtraStrAdjperAtt(kPromotion.getStrAdjperAttChange() * iChange);
	changeExtraStrAdjperDef(kPromotion.getStrAdjperDefChange() * iChange);
	changeExtraWithdrawAdjperAtt(kPromotion.getWithdrawAdjperAttChange() * iChange);
#endif // BATTLEWORN
	changeExtraUnnerve(kPromotion.getUnnerveChange() * iChange);
	changeExtraEnclose(kPromotion.getEncloseChange() * iChange);
	changeExtraLunge(kPromotion.getLungeChange() * iChange);
	changeExtraDynamicDefense(kPromotion.getDynamicDefenseChange() * iChange);
	if (kPromotion.getStrengthChange() != 0)
	{
		changeExtraStrength(kPromotion.getStrengthChange() * iChange);
		bSMrecalc = true;
	}
	changeAnimalIgnoresBordersCount(kPromotion.getAnimalIgnoresBordersChange() * iChange);
	changeOnslaughtCount((kPromotion.isOnslaughtChange()) ? iChange : 0);
	changeExtraFortitude(kPromotion.getFortitudeChange() * iChange);
#ifdef OUTBREAKS_AND_AFFLICTIONS
	for (iI = 0; iI < GC.getNumPropertyInfos(); iI++)
	{
		changeExtraAidChange((PropertyTypes)iI, kPromotion.getAidChange(iI) * iChange);
	}
#endif
#ifdef STRENGTH_IN_NUMBERS
	changeExtraFrontSupportPercent(kPromotion.getFrontSupportPercentChange() * iChange);
	changeExtraShortRangeSupportPercent(kPromotion.getShortRangeSupportPercentChange() * iChange);
	changeExtraMediumRangeSupportPercent(kPromotion.getMediumRangeSupportPercentChange() * iChange);
	changeExtraLongRangeSupportPercent(kPromotion.getLongRangeSupportPercentChange() * iChange);
	changeExtraFlankSupportPercent(kPromotion.getFlankSupportPercentChange() * iChange);
#endif // STRENGTH_IN_NUMBERS

	changeExtraDodgeModifier(kPromotion.getDodgeModifierChange() * iChange);
	changeExtraPrecisionModifier(kPromotion.getPrecisionModifierChange() * iChange);
	changeExtraPowerShots(kPromotion.getPowerShotsChange() * iChange);
	changeExtraPowerShotCombatModifier(kPromotion.getPowerShotCombatModifierChange() * iChange);
	changeExtraPowerShotPunctureModifier(kPromotion.getPowerShotPunctureModifierChange() * iChange);
	changeExtraPowerShotPrecisionModifier(kPromotion.getPowerShotPrecisionModifierChange() * iChange);
	changeExtraPowerShotCriticalModifier(kPromotion.getPowerShotCriticalModifierChange() * iChange);
	changeExtraCriticalModifier(kPromotion.getCriticalModifierChange() * iChange);
	changeExtraEndurance(kPromotion.getEnduranceChange() * iChange);
	changeDealColdDamageCount((kPromotion.isMakesDamageCold()) ? iChange : 0);
	changeDealColdDamageCount((kPromotion.isMakesDamageNotCold()) ? -iChange : 0);
	changeColdImmuneCount((kPromotion.isAddsColdImmunity()) ? iChange : 0);
	changeColdImmuneCount((kPromotion.isRemovesColdImmunity()) ? -iChange : 0);
	changeExtraRoundStunProb(kPromotion.getRoundStunProbChange() * iChange);
	changeExtraPoisonProbabilityModifier(kPromotion.getPoisonProbabilityModifierChange() * iChange);

	changeExtraCaptureProbabilityModifier(kPromotion.getCaptureProbabilityModifierChange() * iChange);
	changeExtraCaptureResistanceModifier(kPromotion.getCaptureResistanceModifierChange() * iChange);

	changeExtraBreakdownChance(kPromotion.getBreakdownChanceChange() * iChange);
	changeExtraBreakdownDamage(kPromotion.getBreakdownDamageChange() * iChange);
	changeExtraTaunt(kPromotion.getTauntChange() * iChange);
	changeExcileCount(kPromotion.getExcileChange() * iChange);
	changePassageCount(kPromotion.getPassageChange() * iChange);
	changeNoNonOwnedCityEntryCount(kPromotion.getNoNonOwnedCityEntryChange() * iChange);
	changeBarbCoExistCount(kPromotion.getBarbCoExistChange() * iChange);
	changeBlendIntoCityCount(kPromotion.getBlendIntoCityChange() * iChange);
	changeUpgradeAnywhereCount(kPromotion.getUpgradeAnywhereChange() * iChange);

	if (kPromotion.getMaxHPChange() != 0)
	{
		changeExtraMaxHP(kPromotion.getMaxHPChange() * iChange);
		bSMrecalc = true;
	}
	if (kPromotion.getStrengthModifier() != 0)
	{
		changeExtraStrengthModifier(kPromotion.getStrengthModifier() * iChange);
		bSMrecalc = true;
	}
	//TB Combat Mods End
	changeExtraCollateralDamage(kPromotion.getCollateralDamageChange() * iChange);
	if (kPromotion.getBombardRateChange() != 0)
	{
		changeExtraBombardRate(kPromotion.getBombardRateChange() * iChange);
		bSMrecalc = true;
	}
	changeExtraEnemyHeal(kPromotion.getEnemyHealChange() * iChange);
	changeExtraNeutralHeal(kPromotion.getNeutralHealChange() * iChange);
	changeExtraFriendlyHeal(kPromotion.getFriendlyHealChange() * iChange);
	changeSameTileHeal(kPromotion.getSameTileHealChange() * iChange);
	changeAdjacentTileHeal(kPromotion.getAdjacentTileHealChange() * iChange);
	changeExtraCombatPercent(kPromotion.getCombatPercent() * iChange);
	changeExtraCityAttackPercent(kPromotion.getCityAttackPercent() * iChange);
	changeExtraCityDefensePercent(kPromotion.getCityDefensePercent() * iChange);
	changeExtraHillsAttackPercent(kPromotion.getHillsAttackPercent() * iChange);
	changeExtraHillsDefensePercent(kPromotion.getHillsDefensePercent() * iChange);
	// Assume only worker units can get the relevant promotions, if not then we'll need a retroactive unitComp late init function.
	if (isWorker())
	{
		bool bChanged = false;
		if (kPromotion.getHillsWorkPercent() != 0)
		{
			m_worker->changeHillsWorkModifier(kPromotion.getHillsWorkPercent() * iChange);
			bChanged = true;
		}
		if (kPromotion.getPeaksWorkPercent() != 0)
		{
			m_worker->changePeaksWorkModifier(kPromotion.getPeaksWorkPercent() * iChange);
			bChanged = true;
		}
		if (kPromotion.getWorkRatePercent() != 0)
		{
			m_worker->changeWorkModifier(kPromotion.getWorkRatePercent() * iChange);
			bChanged = true;
		}
		for (int iI = 0; iI < GC.getNumBuildInfos(); iI++)
		{
			if (kPromotion.getBuildWorkRateModifierChangeType(iI) != 0)
			{
				m_worker->changeExtraWorkModForBuild((BuildTypes)iI, kPromotion.getBuildWorkRateModifierChangeType(iI) * iChange);
				bChanged = true;
			}
		}
		if (bChanged) setInfoBarDirty(true);
	}
	changeRevoltProtection(kPromotion.getRevoltProtection() * iChange);
	changeCollateralDamageProtection(kPromotion.getCollateralDamageProtection() * iChange);
	changePillageChange(kPromotion.getPillageChange() * iChange);
	changeUpgradeDiscount(kPromotion.getUpgradeDiscount() * iChange);
	changeExperiencePercent(kPromotion.getExperiencePercent() * iChange);
	changeKamikazePercent((kPromotion.getKamikazePercent()) * iChange);
	if (kPromotion.getCargoChange() != 0)
	{
		changeCargoSpace(kPromotion.getCargoChange() * iChange);
		bSMrecalc = true;
	}
	if (kPromotion.getSMCargoChange() != 0)
	{
		changeSMCargoSpace(kPromotion.getSMCargoChange() * iChange);
		bSMrecalc = true;
	}
	if (kPromotion.getSMCargoVolumeChange() != 0)
	{
		changeExtraCargoVolume(kPromotion.getSMCargoVolumeChange() * iChange);
		bSMrecalc = true;
	}
	if (kPromotion.getSMCargoVolumeModifierChange() != 0)
	{
		changeCargoVolumeModifier(kPromotion.getSMCargoVolumeModifierChange() * iChange);
		bSMrecalc = true;
	}

	changeExtraCombatModifierPerSizeMore(kPromotion.getCombatModifierPerSizeMoreChange() * iChange);//no merge/split
	changeExtraCombatModifierPerSizeLess(kPromotion.getCombatModifierPerSizeLessChange() * iChange);//no merge/split
	changeExtraCombatModifierPerVolumeMore(kPromotion.getCombatModifierPerVolumeMoreChange() * iChange);//no merge/split
	changeExtraCombatModifierPerVolumeLess(kPromotion.getCombatModifierPerVolumeLessChange() * iChange);//no merge/split

	changeExtraRBombardDamage(kPromotion.getRBombardDamageChange() * iChange);
	changeExtraRBombardDamageLimit(kPromotion.getRBombardDamageLimitChange() * iChange);
	changeExtraRBombardDamageMaxUnits(kPromotion.getRBombardDamageMaxUnitsChange() * iChange);
	changeExtraDCMBombRange(kPromotion.getDCMBombRangeChange() * iChange);
	changeExtraDCMBombAccuracy(kPromotion.getDCMBombAccuracyChange() * iChange);
	changeNoSelfHealCount((kPromotion.isNoSelfHeal()) ? iChange : 0);
	changeExtraSelfHealModifier(kPromotion.getSelfHealModifier() * iChange);
	changeExtraNumHealSupport(kPromotion.getNumHealSupport() * iChange);
	changeExtraInsidiousness(kPromotion.getInsidiousnessChange() * iChange);
	changeExtraInvestigation(kPromotion.getInvestigationChange() * iChange);
	changeAssassinCount(kPromotion.getAssassinChange() * iChange);
	changeExtraStealthStrikes(kPromotion.getStealthStrikesChange() * iChange);
	changeExtraStealthCombatModifier(kPromotion.getStealthCombatModifierChange() * iChange);
	changeStealthDefenseCount(kPromotion.getStealthDefenseChange() * iChange);
	changeOnlyDefensiveCount(kPromotion.getDefenseOnlyChange() * iChange);
	changeNoInvisibilityCount(kPromotion.getNoInvisibilityChange() * iChange);
	changeExtraTrapDamageMax(kPromotion.getTrapDamageMax() * iChange);
	changeExtraTrapDamageMin(kPromotion.getTrapDamageMin() * iChange);
	changeExtraTrapComplexity(kPromotion.getTrapComplexity() * iChange);
	changeExtraNumTriggers(kPromotion.getNumTriggers() * iChange);
	changeTriggerBeforeAttackCount(kPromotion.getTriggerBeforeAttackChange() * iChange);
	changeHiddenNationalityCount(kPromotion.getHiddenNationalityChange() * iChange);

	if (kPromotion.getQualityChange() != 0)
	{
		changeExtraQuality(kPromotion.getQualityChange() * iChange);
		bSMrecalc = true;
	}
	if (kPromotion.getGroupChange() != 0)
	{
		changeExtraGroup(kPromotion.getGroupChange() * iChange);
		bSMrecalc = true;
	}

#ifdef OUTBREAKS_AND_AFFLICTIONS
	if (!bAdding && kPromotion.isAffliction())
	{
		changeUnitAfflictionTolerance(((PromotionLineTypes)kPromotion.getPromotionLine()),GC.getPromotionLineInfo((PromotionLineTypes)kPromotion.getPromotionLine()).getToleranceBuildup() * iChange);
	}
#endif

	if (kPromotion.isZoneOfControl())
	{
		changeZoneOfControlCount(iChange > 0 ? 1 : -1);
	}

	if (kPromotion.getIgnoreTerrainDamage() != NO_TERRAIN)
	{
		changeTerrainProtected((TerrainTypes)kPromotion.getIgnoreTerrainDamage(), iChange);
	}

	for (iI = 0; iI < GC.getNumTerrainInfos(); iI++)
	{
		changeExtraTerrainAttackPercent(((TerrainTypes)iI), (kPromotion.getTerrainAttackPercent(iI) * iChange));
		changeExtraTerrainDefensePercent(((TerrainTypes)iI), (kPromotion.getTerrainDefensePercent(iI) * iChange));

		changeExtraTerrainWorkPercent(((TerrainTypes)iI), (kPromotion.getTerrainWorkPercent(iI) * iChange));

		changeTerrainDoubleMoveCount(((TerrainTypes)iI), ((kPromotion.getTerrainDoubleMove(iI)) ? iChange : 0));
		changeExtraWithdrawOnTerrainType(((TerrainTypes)iI), (kPromotion.getWithdrawOnTerrainTypeChange(iI) * iChange));
	}

	for (iI = 0; iI < GC.getNumFeatureInfos(); iI++)
	{
		changeExtraFeatureAttackPercent(((FeatureTypes)iI), (kPromotion.getFeatureAttackPercent(iI) * iChange));
		changeExtraFeatureDefensePercent(((FeatureTypes)iI), (kPromotion.getFeatureDefensePercent(iI) * iChange));

		changeExtraFeatureWorkPercent(((FeatureTypes)iI), (kPromotion.getFeatureWorkPercent(iI) * iChange));

		changeFeatureDoubleMoveCount(((FeatureTypes)iI), ((kPromotion.getFeatureDoubleMove(iI)) ? iChange : 0));
		changeExtraWithdrawOnFeatureType(((FeatureTypes)iI), (kPromotion.getWithdrawOnFeatureTypeChange(iI) * iChange));
	}

	for (iI = 0; iI < GC.getNumInvisibleInfos(); iI++)
	{
		changeExtraVisibilityIntensityType(((InvisibleTypes)iI), (kPromotion.getVisibilityIntensityChangeType(iI) * iChange));
		changeExtraInvisibilityIntensityType(((InvisibleTypes)iI), (kPromotion.getInvisibilityIntensityChangeType(iI) * iChange));
		changeExtraVisibilityIntensityRangeType(((InvisibleTypes)iI), (kPromotion.getVisibilityIntensityRangeChangeType(iI) * iChange));
	}

	for (iI = 0; iI < kPromotion.getNumNegatesInvisibilityTypes(); iI++)
	{
		changeNegatesInvisibleCount((InvisibleTypes)kPromotion.getNegatesInvisibilityType(iI), iChange);
	}

	for (iI = 0; iI < kPromotion.getNumTrapSetWithPromotionTypes(); iI++)
	{
		changeTrapSetWithPromotionCount((PromotionTypes)kPromotion.getTrapSetWithPromotionType(iI), iChange);
	}

	for (iI = 0; iI < kPromotion.getNumTrapImmunityUnitCombatTypes(); iI++)
	{
		changeTrapImmunityUnitCombatCount((UnitCombatTypes)kPromotion.getTrapImmunityUnitCombatType(iI), iChange);
	}

	for (iI = 0; iI < kPromotion.getNumTargetUnitCombatTypes(); iI++)
	{
		changeTargetUnitCombatCount((UnitCombatTypes)kPromotion.getTargetUnitCombatType(iI), iChange);
	}

	for (iI = 0; iI < kPromotion.getNumInvisibleTerrainChanges(); iI++)
	{
		changeExtraInvisibleTerrain((InvisibleTypes)kPromotion.getInvisibleTerrainChange(iI).eInvisible,(TerrainTypes)kPromotion.getInvisibleTerrainChange(iI).eTerrain, kPromotion.getInvisibleTerrainChange(iI).iIntensity * iChange);
	}

	for (iI = 0; iI < kPromotion.getNumInvisibleFeatureChanges(); iI++)
	{
		changeExtraInvisibleFeature((InvisibleTypes)kPromotion.getInvisibleFeatureChange(iI).eInvisible,(FeatureTypes)kPromotion.getInvisibleFeatureChange(iI).eFeature, kPromotion.getInvisibleFeatureChange(iI).iIntensity * iChange);
	}

	for (iI = 0; iI < kPromotion.getNumInvisibleImprovementChanges(); iI++)
	{
		changeExtraInvisibleImprovement((InvisibleTypes)kPromotion.getInvisibleImprovementChange(iI).eInvisible,(ImprovementTypes)kPromotion.getInvisibleImprovementChange(iI).eImprovement, kPromotion.getInvisibleImprovementChange(iI).iIntensity * iChange);
	}

	for (iI = 0; iI < kPromotion.getNumVisibleTerrainChanges(); iI++)
	{
		changeExtraVisibleTerrain((InvisibleTypes)kPromotion.getVisibleTerrainChange(iI).eInvisible,(TerrainTypes)kPromotion.getVisibleTerrainChange(iI).eTerrain, kPromotion.getVisibleTerrainChange(iI).iIntensity * iChange);
	}

	for (iI = 0; iI < kPromotion.getNumVisibleFeatureChanges(); iI++)
	{
		changeExtraVisibleFeature((InvisibleTypes)kPromotion.getVisibleFeatureChange(iI).eInvisible,(FeatureTypes)kPromotion.getVisibleFeatureChange(iI).eFeature, kPromotion.getVisibleFeatureChange(iI).iIntensity * iChange);
	}

	for (iI = 0; iI < kPromotion.getNumVisibleImprovementChanges(); iI++)
	{
		changeExtraVisibleImprovement((InvisibleTypes)kPromotion.getVisibleImprovementChange(iI).eInvisible,(ImprovementTypes)kPromotion.getVisibleImprovementChange(iI).eImprovement, kPromotion.getVisibleImprovementChange(iI).iIntensity * iChange);
	}

	for (iI = 0; iI < kPromotion.getNumVisibleTerrainRangeChanges(); iI++)
	{
		changeExtraVisibleTerrainRange((InvisibleTypes)kPromotion.getVisibleTerrainRangeChange(iI).eInvisible,(TerrainTypes)kPromotion.getVisibleTerrainRangeChange(iI).eTerrain, kPromotion.getVisibleTerrainRangeChange(iI).iIntensity * iChange);
	}

	for (iI = 0; iI < kPromotion.getNumVisibleFeatureRangeChanges(); iI++)
	{
		changeExtraVisibleFeatureRange((InvisibleTypes)kPromotion.getVisibleFeatureRangeChange(iI).eInvisible,(FeatureTypes)kPromotion.getVisibleFeatureRangeChange(iI).eFeature, kPromotion.getVisibleFeatureRangeChange(iI).iIntensity * iChange);
	}

	for (iI = 0; iI < kPromotion.getNumVisibleImprovementRangeChanges(); iI++)
	{
		changeExtraVisibleImprovementRange((InvisibleTypes)kPromotion.getVisibleImprovementRangeChange(iI).eInvisible,(ImprovementTypes)kPromotion.getVisibleImprovementRangeChange(iI).eImprovement, kPromotion.getVisibleImprovementRangeChange(iI).iIntensity * iChange);
	}

#ifdef OUTBREAKS_AND_AFFLICTIONS
	for (iI = 0; iI < kPromotion.getNumDistanceAttackCommunicabilityTypeChanges(); iI++)
	{
		changeDistanceAttackCommunicability((PromotionLineTypes)kPromotion.getDistanceAttackCommunicabilityTypeChange(iI).eAfflictionLine, kPromotion.getDistanceAttackCommunicabilityTypeChange(iI).iChange * iChange);
	}
#endif
	const int numUnitCombatInfos = GC.getNumUnitCombatInfos();
	for (iI = 0; iI < numUnitCombatInfos; iI++)
	{
		changeExtraUnitCombatModifier(((UnitCombatTypes)iI), (kPromotion.getUnitCombatModifierPercent(iI) * iChange));
		changeExtraFlankingStrengthbyUnitCombatType(((UnitCombatTypes)iI), (kPromotion.getFlankingStrengthbyUnitCombatTypeChange(iI) * iChange));
		changeExtraWithdrawVSUnitCombatType(((UnitCombatTypes)iI), (kPromotion.getWithdrawVSUnitCombatChangeType(iI) * iChange));
		changeExtraPursuitVSUnitCombatType(((UnitCombatTypes)iI), (kPromotion.getPursuitVSUnitCombatChangeType(iI) * iChange));
		changeExtraRepelVSUnitCombatType(((UnitCombatTypes)iI), (kPromotion.getRepelVSUnitCombatChangeType(iI) * iChange));
		changeExtraKnockbackVSUnitCombatType(((UnitCombatTypes)iI), (kPromotion.getKnockbackVSUnitCombatChangeType(iI) * iChange));
		changeExtraPunctureVSUnitCombatType(((UnitCombatTypes)iI), (kPromotion.getPunctureVSUnitCombatChangeType(iI) * iChange));
		changeExtraArmorVSUnitCombatType(((UnitCombatTypes)iI), (kPromotion.getArmorVSUnitCombatChangeType(iI) * iChange));
		changeExtraDodgeVSUnitCombatType(((UnitCombatTypes)iI), (kPromotion.getDodgeVSUnitCombatChangeType(iI) * iChange));
		changeExtraPrecisionVSUnitCombatType(((UnitCombatTypes)iI), (kPromotion.getPrecisionVSUnitCombatChangeType(iI) * iChange));
		changeExtraCriticalVSUnitCombatType(((UnitCombatTypes)iI), (kPromotion.getCriticalVSUnitCombatChangeType(iI) * iChange));
		changeExtraRoundStunVSUnitCombatType(((UnitCombatTypes)iI), (kPromotion.getRoundStunVSUnitCombatChangeType(iI) * iChange));
		changeExtraTrapDisableUnitCombatType(((UnitCombatTypes)iI), (kPromotion.getTrapDisableUnitCombatType(iI) * iChange));
		changeExtraTrapAvoidanceUnitCombatType(((UnitCombatTypes)iI), (kPromotion.getTrapAvoidanceUnitCombatType(iI) * iChange));
		changeExtraTrapTriggerUnitCombatType(((UnitCombatTypes)iI), (kPromotion.getTrapTriggerUnitCombatType(iI) * iChange));
	}

	for (iI = 0; iI < kPromotion.getNumSubCombatChangeTypes(); iI++)
	{
		setHasUnitCombat(((UnitCombatTypes)kPromotion.getSubCombatChangeType(iI)), bAdding, true);
	}

	for (iI = 0; iI < kPromotion.getNumRemovesUnitCombatTypes(); iI++)
	{
		setHasUnitCombat(((UnitCombatTypes)kPromotion.getRemovesUnitCombatType(iI)), bAdding ? false : true, true);
	}

#ifdef OUTBREAKS_AND_AFFLICTIONS
	if (GC.getGame().isOption(GAMEOPTION_COMBAT_OUTBREAKS_AND_AFFLICTIONS))
	{
		for (iI = 0; iI < kPromotion.getNumCureAfflictionChangeTypes(); iI++)
		{
			changeCureAfflictionCount(((PromotionLineTypes)kPromotion.getCureAfflictionChangeType(iI)), bAdding);
		}

		for (iI = 0; iI < kPromotion.getNumAfflictionFortitudeChangeModifiers(); iI++)
		{
			changeFortitudeModifierTypeAmount(((PromotionLineTypes)kPromotion.getAfflictionFortitudeChangeModifier(iI).ePromotionLine), kPromotion.getAfflictionFortitudeChangeModifier(iI).iModifier * iChange);
		}

		for (iI = 0; iI < kPromotion.getNumAfflictOnAttackChangeTypes(); iI++)
		{
			changeAfflictOnAttackTypeCount(((PromotionLineTypes)kPromotion.getAfflictOnAttackChangeType(iI).eAfflictionLine), iChange);
			changeAfflictOnAttackTypeProbability(((PromotionLineTypes)kPromotion.getAfflictOnAttackChangeType(iI).eAfflictionLine), kPromotion.getAfflictOnAttackChangeType(iI).iProbabilityChange * iChange);
			changeAfflictOnAttackTypeMeleeCount(((PromotionLineTypes)kPromotion.getAfflictOnAttackChangeType(iI).eAfflictionLine), kPromotion.getAfflictOnAttackChangeType(iI).iMelee * iChange);
			changeAfflictOnAttackTypeDistanceCount(((PromotionLineTypes)kPromotion.getAfflictOnAttackChangeType(iI).eAfflictionLine), kPromotion.getAfflictOnAttackChangeType(iI).iDistance * iChange);
			changeAfflictOnAttackTypeImmediateCount(((PromotionLineTypes)kPromotion.getAfflictOnAttackChangeType(iI).eAfflictionLine), kPromotion.getAfflictOnAttackChangeType(iI).iImmediate * iChange);
		}
	}
#endif // OUTBREAKS_AND_AFFLICTIONS

	for (iI = 0; iI < kPromotion.getNumHealUnitCombatChangeTypes(); iI++)
	{
		changeHealUnitCombatTypeVolume(((UnitCombatTypes)kPromotion.getHealUnitCombatChangeType(iI).eUnitCombat), kPromotion.getHealUnitCombatChangeType(iI).iHeal * iChange);
		changeHealUnitCombatTypeAdjacentVolume(((UnitCombatTypes)kPromotion.getHealUnitCombatChangeType(iI).eUnitCombat), kPromotion.getHealUnitCombatChangeType(iI).iAdjacentHeal * iChange);
	}

	if (kPromotion.setSpecialUnit() != NO_SPECIALUNIT)
	{
		setSpecialUnit(iChange, kPromotion.setSpecialUnit());
	}
	//TB Combat Mod End

	for (iI = 0; iI < NUM_DOMAIN_TYPES; iI++)
	{
		changeExtraDomainModifier(((DomainTypes)iI), (kPromotion.getDomainModifierPercent(iI) * iChange));
	}

	if (bAdding && bInitial && kPromotion.isZeroesXP())
	{
		setExperience100(0);
	}

	if (bSMrecalc && GC.getGame().isOption(GAMEOPTION_COMBAT_SIZE_MATTERS))
	{
		setSMValues();
	}

	establishBuildups();
}

void CvUnit::setHasPromotion(PromotionTypes eIndex, bool bNewValue, PromotionApply::flags flags)
{
	setHasPromotion
	(
		eIndex, bNewValue,
		flags & PromotionApply::Free,
		flags & PromotionApply::Dying,
		flags & PromotionApply::Initial,
		flags & PromotionApply::FromTrait
	);
}

void CvUnit::setHasPromotion(PromotionTypes eIndex, bool bNewValue, bool bFree, bool bDying, bool bInitial, bool bFromTrait)
{
	PROFILE_FUNC();

	FASSERT_BOUNDS(0, GC.getNumPromotionInfos(), eIndex);

	if (eIndex == NO_PROMOTION)
	{
		FErrorMsg("Invalid promotion");
		return;
	}

	const CvPromotionInfo& kPromotion = GC.getPromotionInfo(eIndex);
	// Disable spy promotions mechanism
#ifdef OUTBREAKS_AND_AFFLICTIONS
	//TB Combat Mods begin (first, regardless of remove, add, or ignore because they already have it, reset AfflictionTurnCount to 0,
	//and another check is necessary here for equips and afflicts to ensure unusual means of reaching this point cannot bypass some necessary disqualifiers)
	if (kPromotion.isAffliction())
	{
		PromotionLineTypes eAfflict = (PromotionLineTypes)kPromotion.getPromotionLine();
		setAfflictionTurnCount(eAfflict, 0);
	}
	//TB Combat Mods end
#endif
	bool canPromote = !isSpy() || GC.isSS_ENABLED() || kPromotion.isEnemyRoute(); //exempt commando promotion

	bool bAssignFree = false;
	if (bFree)
	{
		if (bNewValue)
		{
			// Check canKeep to ensure we're not wasting our time on free promos
			canPromote = canKeepPromotion(eIndex, true, false);
			// Following removes the need to count all those promos as free.
			if (canPromote)
			{
				bAssignFree = true;
			}
		}
		else // Remove free status
		{
			setPromotionFreeCount(eIndex, 0);

			if (bFromTrait)
			{
				setPromotionFromTrait(eIndex, 0);
			}
		}
	}

	if (isHasPromotion(eIndex) != bNewValue)
	{
		// If we check all normal promotions through this routine we'll accidentally disqualify a number of free promos on the basis of tech prereq.
		// Important this only runs a check for equps and afflicts.  All other means of getting here should
		// already be checked in their own way.  A better check for those would be canKeepPromotion() which they should
		// run up against regularly by default anyhow.  If we notice units getting free promos they can't keep, then
		// we'll have to find the source and check against canKeepPromotion before they qualify to get to setHasPromotion in the first place.
		if (canPromote && bNewValue && (kPromotion.isEquipment()
#ifdef OUTBREAKS_AND_AFFLICTIONS
			|| kPromotion.isAffliction()
#endif
			))
		{
			// When trying to add a promotion: check we are allowed to have it.
			// Note - this check filters out attempts to set lower priority equipment
			//	or afflication promotions from the same line as an existing one that has a higher priority
			PromotionRequirements::flags promoFlags = PromotionRequirements::None;
			if (kPromotion.isEquipment()) promoFlags |= PromotionRequirements::Equip;
#ifdef OUTBREAKS_AND_AFFLICTIONS
			if (kPromotion.isAffliction()) promoFlags |= PromotionRequirements::Afflict;
#endif
			canPromote = canAcquirePromotion(eIndex, promoFlags);
		}


		if (canPromote)
		{
			PromotionKeyedInfo* info =
			(
				bNewValue
				?
				findOrCreatePromotionKeyedInfo(eIndex)
				:
				(PromotionKeyedInfo*)findPromotionKeyedInfo(eIndex)
			);

			if (info != NULL)
			{
				info->m_bHasPromotion = bNewValue;
			}

			if (bAssignFree)
			{
				setPromotionFreeCount(eIndex, 1);
				if (bFromTrait)
				{
					setPromotionFromTrait(eIndex, 1);
				}
			}

			// Never Initial if Free or Removing
			if (bInitial && (!bNewValue || bFree))
			{
				bInitial = false;
			}

			processPromotion(eIndex, bNewValue, bInitial);

			AI_flushValueCache();

			// A unit can only have a single promotion in a promotion line for equipment or affliction promotions,
			//	if we're applying a higher priority one make sure any lower priority one from the same line that was present previously is removed
			// QUESTION FOR TB - should removing an afflication add in the affliction below it (priority wise)
			//	in its line??  (I assume not for equipments, but wasn't sure for afflictions)
			if (bNewValue)
			{
				if (kPromotion.getPromotionLine() != NO_PROMOTIONLINE
				&& (
#ifdef OUTBREAKS_AND_AFFLICTIONS
					kPromotion.isAffliction() ||
#endif
					kPromotion.isEquipment()))
				{
					for (int iI = 0; iI < GC.getNumPromotionInfos(); iI++)
					{
						if (isHasPromotion((PromotionTypes)iI)
						&& GC.getPromotionInfo((PromotionTypes)iI).getPromotionLine() == kPromotion.getPromotionLine()
						&& GC.getPromotionInfo((PromotionTypes)iI).getLinePriority() < kPromotion.getLinePriority())
						{
							setHasPromotion((PromotionTypes)iI, false);
						}
					}
				}
				if (kPromotion.isRemoveAfterSet())
				{
					setHasPromotion(eIndex, false, bFree, bDying, bInitial);
				}
			}

			// When promotions are being removed as part of killing a unit we dont want to add any more or invoke obsoletion checks,
			//	which results in lots of extra processing, and can also generate retrain messages for the dying units!
			if (!isDead() && !bDying)
			{
				checkPromotionObsoletion();
				checkFreetoCombatClass();
			}

			//	Updates the grpahics last after everything is calculated
			if (IsSelected())
			{
				gDLL->getInterfaceIFace()->setDirty(SelectionButtons_DIRTY_BIT, true);
				gDLL->getInterfaceIFace()->setDirty(InfoPane_DIRTY_BIT, true);
			}

			//update graphics
			if (!isUsingDummyEntities() && isInViewport())
			{
				gDLL->getEntityIFace()->updatePromotionLayers(getUnitEntity());
			}
		}
	}
}


bool CvUnit::applyUnitPromotions(const std::vector<CvUnit*>& units, int number, PromotionPredicateFn promotionPredicateFn)
{
	PROFILE_EXTRA_FUNC();
	FAssertMsg(number >= 0, "Number of promotions to apply cannot be negative");

	if (units.size() == 0)
		return true;

	while (number > 0)
	{
		PromotionTypes foundPromo = GC.findPromotion(promotionPredicateFn);
		if (foundPromo == NO_PROMOTION)
			break;
		foreach_(CvUnit* unit, units)
		{
			unit->setHasPromotion(foundPromo, true, PromotionApply::Free);
		}
		number--;
	}
	return number == 0;
}

bool CvUnit::applyUnitPromotions(CvUnit* unit, int number, PromotionPredicateFn promotionPredicateFn)
{
	std::vector<CvUnit*> units;
	units.push_back(unit);
	return applyUnitPromotions(units, number, promotionPredicateFn);
}

bool CvUnit::normalizeUnitPromotions(const std::vector<CvUnit*>& units, int offset, PromotionPredicateFn upgradePredicateFn, PromotionPredicateFn downgradePredicateFn)
{
	return offset == 0 ? true : applyUnitPromotions(units, std::abs(offset), offset > 0 ? upgradePredicateFn : downgradePredicateFn);
}

bool CvUnit::normalizeUnitPromotions(CvUnit* unit, int offset, PromotionPredicateFn upgradePredicateFn, PromotionPredicateFn downgradePredicateFn)
{
	return offset == 0 ? true : applyUnitPromotions(unit, std::abs(offset), offset > 0 ? upgradePredicateFn : downgradePredicateFn);
}

UnitCombatTypes CvUnit::getBestHealingType()
{
	PROFILE_EXTRA_FUNC();
	UnitCombatTypes eBestUnitCombat = NO_UNITCOMBAT;
	int iBestValue = 0;

	for (int iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
	{
		if (GC.getUnitCombatInfo((UnitCombatTypes)iI).isHealsAs())
		{
			const int iValue = getHealUnitCombatTypeTotal((UnitCombatTypes)iI);
			if (iValue > iBestValue)
			{
				iBestValue = iValue;
				eBestUnitCombat = (UnitCombatTypes)iI;
			}
		}
	}
	return eBestUnitCombat;
}

UnitCombatTypes CvUnit::getBestHealingTypeConst() const
{
	PROFILE_EXTRA_FUNC();
	UnitCombatTypes eBestUnitCombat = NO_UNITCOMBAT;
	int iBestValue = 0;

	for (int iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
	{
		if (GC.getUnitCombatInfo((UnitCombatTypes)iI).isHealsAs())
		{
			const int iValue = getHealUnitCombatTypeTotal((UnitCombatTypes)iI);
			if (iValue > iBestValue)
			{
				iBestValue = iValue;
				eBestUnitCombat = (UnitCombatTypes)iI;
			}
		}
	}
	return eBestUnitCombat;
}

int CvUnit::getSubUnitCount() const
{
	if (GC.getGame().isOption(GAMEOPTION_COMBAT_SIZE_MATTERS) && groupRank() > 0)
	{
		return groupRank();
	}
	return m_pUnitInfo->getGroupSize();
}


int CvUnit::getSubUnitsAlive() const
{
	return getSubUnitsAlive(getDamage());
}


int CvUnit::getSubUnitsAlive(int iDamage) const
{
	const int iMaxHP = getMaxHP();
	if (iDamage >= iMaxHP)
	{
		return 0;
	}
	return std::max(1, (getSubUnitCount() * (iMaxHP - iDamage) + iMaxHP / (2*getSubUnitCount() + 1)) / iMaxHP);
}
// returns true if unit can initiate a war action with plot (possibly by declaring war)
bool CvUnit::potentialWarAction(const CvPlot* pPlot) const
{
	TeamTypes ePlotTeam = pPlot->getTeam();

	if (ePlotTeam == NO_TEAM)
	{
		return false;
	}

	if (isEnemy(ePlotTeam, pPlot))
	{
		return true;
	}

	if (getGroup()->AI_isDeclareWar(pPlot) && GET_TEAM(getTeam()).AI_getWarPlan(ePlotTeam) != NO_WARPLAN)
	{
		return true;
	}

	return false;
}

void CvUnit::read(FDataStreamBase* pStream)
{
	PROFILE_EXTRA_FUNC();
	// Init data before load
	reset();

	CvTaggedSaveFormatWrapper&	wrapper = CvTaggedSaveFormatWrapper::getSaveFormatWrapper();

	wrapper.AttachToStream(pStream);

	WRAPPER_READ_OBJECT_START(wrapper);

	WRAPPER_READ(wrapper, "CvUnit", &m_iDCMBombRange);
	WRAPPER_READ(wrapper, "CvUnit", &m_iDCMBombAccuracy);
	WRAPPER_READ(wrapper, "CvUnit", &m_iID);
	WRAPPER_READ(wrapper, "CvUnit", &m_iGroupID);
	WRAPPER_READ(wrapper, "CvUnit", &m_iHotKeyNumber);
	WRAPPER_READ(wrapper, "CvUnit", &m_iX);
	WRAPPER_READ(wrapper, "CvUnit", &m_iY);
	WRAPPER_READ(wrapper, "CvUnit", &m_iLastMoveTurn);
	WRAPPER_READ(wrapper, "CvUnit", &m_iReconX);
	WRAPPER_READ(wrapper, "CvUnit", &m_iReconY);
	WRAPPER_READ(wrapper, "CvUnit", &m_iGameTurnCreated);
	WRAPPER_READ(wrapper, "CvUnit", &m_iDamage);
	WRAPPER_READ(wrapper, "CvUnit", &m_iMoves);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExperience);
	WRAPPER_READ(wrapper, "CvUnit", &m_iLevel);
	WRAPPER_READ(wrapper, "CvUnit", &m_iCargo);
	WRAPPER_READ(wrapper, "CvUnit", &m_iCargoCapacity);
	WRAPPER_READ(wrapper, "CvUnit", &m_iAttackPlotX);
	WRAPPER_READ(wrapper, "CvUnit", &m_iAttackPlotY);
	WRAPPER_READ(wrapper, "CvUnit", &m_iCombatTimer);
	WRAPPER_READ(wrapper, "CvUnit", &m_iCombatFirstStrikes);
	WRAPPER_READ(wrapper, "CvUnit", &m_iFortifyTurns);
	WRAPPER_READ(wrapper, "CvUnit", &m_iBlitzCount);
	WRAPPER_READ(wrapper, "CvUnit", &m_iAmphibCount);
	WRAPPER_READ(wrapper, "CvUnit", &m_iRiverCount);
	WRAPPER_READ(wrapper, "CvUnit", &m_iEnemyRouteCount);
	WRAPPER_READ(wrapper, "CvUnit", &m_iAlwaysHealCount);
	WRAPPER_READ(wrapper, "CvUnit", &m_iHillsDoubleMoveCount);

	WRAPPER_READ(wrapper, "CvUnit", &m_iCanMovePeaksCount);
	WRAPPER_READ(wrapper, "CvUnit", &m_iCanLeadThroughPeaksCount);

	WRAPPER_READ(wrapper, "CvUnit", &m_iSleepTimer);

	WRAPPER_READ(wrapper, "CvUnit", &m_iCommanderID);
	WRAPPER_READ(wrapper, "CvUnit", &m_iCommodoreID);

	WRAPPER_READ(wrapper, "CvUnit", (int*)&m_eOriginalOwner);

	WRAPPER_READ(wrapper, "CvUnit", &m_bAutoPromoting);
	WRAPPER_READ(wrapper, "CvUnit", &m_bAutoUpgrading);

	WRAPPER_READ(wrapper, "CvUnit", (int*)&m_shadowUnit.eOwner);
	WRAPPER_READ(wrapper, "CvUnit", &m_shadowUnit.iID);

	WRAPPER_READ(wrapper, "CvUnit", &m_iImmuneToFirstStrikesCount);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraVisibilityRange);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraMoves);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraMoveDiscount);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraAirRange);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraIntercept);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraEvasion);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraFirstStrikes);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraChanceFirstStrikes);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraWithdrawal);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraCollateralDamage);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraBombardRate);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraEnemyHeal);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraNeutralHeal);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraFriendlyHeal);
	WRAPPER_READ(wrapper, "CvUnit", &m_iSameTileHeal);
	WRAPPER_READ(wrapper, "CvUnit", &m_iAdjacentTileHeal);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraCombatPercent);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraCityAttackPercent);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraCityDefensePercent);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraHillsAttackPercent);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraHillsDefensePercent);
	WRAPPER_READ(wrapper, "CvUnit", &m_iRevoltProtection);
	WRAPPER_READ(wrapper, "CvUnit", &m_iCollateralDamageProtection);
	WRAPPER_READ(wrapper, "CvUnit", &m_iPillageChange);
	WRAPPER_READ(wrapper, "CvUnit", &m_iUpgradeDiscount);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExperiencePercent);
	WRAPPER_READ(wrapper, "CvUnit", &m_iKamikazePercent);
	WRAPPER_READ(wrapper, "CvUnit", &m_iBaseCombat);
	WRAPPER_READ(wrapper, "CvUnit", (int*)&m_eFacingDirection);
	WRAPPER_READ(wrapper, "CvUnit", &m_iImmobileTimer);

	WRAPPER_READ(wrapper, "CvUnit", &m_bMadeAttack);
	WRAPPER_READ(wrapper, "CvUnit", &m_bMadeInterception);
	WRAPPER_READ(wrapper, "CvUnit", &m_bPromotionReady);
	WRAPPER_READ(wrapper, "CvUnit", &m_bDeathDelay);
	WRAPPER_SKIP_ELEMENT(wrapper,"CvUnit", m_bCombatFocus, SAVE_VALUE_ANY);
	// m_bInfoBarDirty not saved...
	WRAPPER_READ(wrapper, "CvUnit", &m_bBlockading);
	WRAPPER_READ(wrapper, "CvUnit", &m_bAirCombat);

	WRAPPER_READ(wrapper, "CvUnit", (int*)&m_eOwner);
	WRAPPER_READ(wrapper, "CvUnit", (int*)&m_eCapturingPlayer);
	WRAPPER_READ_CLASS_ENUM(wrapper, "CvUnit", REMAPPED_CLASS_TYPE_UNITS, (int*)&m_eUnitType);
	bool bKill = false;
	if (NO_UNIT == m_eUnitType)
	{
		// Assets must have removed this type (which will have been flagged in a queued error message).
		// Just give it a valid type and mark it to be killed.
		m_eUnitType = (UnitTypes)0;
		// Unit type 0 was never initialized, so we need to add its unit count before it dies.
		GET_PLAYER(getOwner()).changeUnitCount(m_eUnitType, 1);
		if (GC.getGame().isOption(GAMEOPTION_COMBAT_SIZE_MATTERS)
		// if unit doesn't have a group rank, it doesn't count as a SM unit at all
		&& GC.getUnitInfo(m_eUnitType).getBaseGroupRank() > 0)
		{
			GET_PLAYER(getOwner()).changeUnitCountSM(m_eUnitType, intPow(3, GC.getUnitInfo(m_eUnitType).getBaseGroupRank() - 1));
		}
		bKill = true;
	}
	m_pUnitInfo = &GC.getUnitInfo(m_eUnitType);
	m_movementCharacteristicsHash = m_pUnitInfo->getZobristValue();

	WRAPPER_READ_CLASS_ENUM(wrapper, "CvUnit", REMAPPED_CLASS_TYPE_UNITS, (int*)&m_eLeaderUnitType);

	WRAPPER_READ(wrapper, "CvUnit", (int*)&m_combatUnit.eOwner);
	WRAPPER_READ(wrapper, "CvUnit", &m_combatUnit.iID);
	WRAPPER_READ(wrapper, "CvUnit", (int*)&m_transportUnit.eOwner);
	WRAPPER_READ(wrapper, "CvUnit", &m_transportUnit.iID);

	WRAPPER_READ_ARRAY(wrapper, "CvUnit", NUM_DOMAIN_TYPES, m_aiExtraDomainModifier);

	WRAPPER_READ_STRING(wrapper, "CvUnit", m_szName);
	WRAPPER_READ_STRING(wrapper, "CvUnit", m_szScriptData);


	// Read compressed data format
	for (int iI = 0; iI < GC.getNumPromotionInfos(); iI++)
	{
		g_pabTempHasPromotion[iI] = false;
	}
	do
	{
		iI= -1;
		WRAPPER_READ_DECORATED(wrapper, "CvUnit", &iI, "hasPromotion");
		if (iI != -1)
		{
			const int iNewIndex = wrapper.getNewClassEnumValue(REMAPPED_CLASS_TYPE_PROMOTIONS, iI, true);

			if (iNewIndex != NO_PROMOTION)
			{
				g_pabTempHasPromotion[iNewIndex] = true;
			}
		}
	} while(iI != -1);


	for (int iI = 0; iI < GC.getNumPromotionInfos(); iI++)
	{
		if (g_pabTempHasPromotion[iI])
		{
			if (!GC.getPromotionInfo((PromotionTypes)iI).isRemoveAfterSet())
			{
				findOrCreatePromotionKeyedInfo((PromotionTypes)iI)->m_bHasPromotion = true;
			}

			if (GC.getPromotionInfo((PromotionTypes)iI).getPromotionLine() != NO_PROMOTIONLINE
			&& !GC.getPromotionInfo((PromotionTypes)iI).isEquipment()
#ifdef OUTBREAKS_AND_AFFLICTIONS
			&& !GC.getPromotionInfo((PromotionTypes)iI).isAffliction()
#endif
			&& !GC.getPromotionInfo((PromotionTypes)iI).isStatus())
			{
				//	All lesser priority promotions on the same line are implied - make sure they are set
				for (int iJ = 0; iJ < GC.getNumPromotionInfos(); iJ++)
				{
					if (GC.getPromotionInfo((PromotionTypes)iJ).getPromotionLine() == GC.getPromotionInfo((PromotionTypes)iI).getPromotionLine()
					&& GC.getPromotionInfo((PromotionTypes)iI).getLinePriority() > GC.getPromotionInfo((PromotionTypes)iJ).getLinePriority())
					{
						//	Set the map directly not via a call to setHasPromotion because the older versions
						//	would have the effect of the promotion already even though the flag was not set
						findOrCreatePromotionKeyedInfo((PromotionTypes)iI)->m_bHasPromotion = true;
					}
				}
			}
		}
	}

	do
	{
		iI = -1;
		WRAPPER_READ_DECORATED(wrapper, "CvUnit", &iI, "hasTerrainInfo");
		if (iI != -1)
		{
			const int iNewIndex = wrapper.getNewClassEnumValue(REMAPPED_CLASS_TYPE_TERRAINS, iI, true);

			if (iNewIndex != NO_TERRAIN)
			{
				TerrainKeyedInfo* info = findOrCreateTerrainKeyedInfo((TerrainTypes)iNewIndex);

				WRAPPER_READ_DECORATED(wrapper, "CvUnit", &info->m_iTerrainProtected, "TerrainProtected");
				WRAPPER_READ_DECORATED(wrapper, "CvUnit", &info->m_iTerrainDoubleMoveCount, "TerrainDoubleMove");
				WRAPPER_READ_DECORATED(wrapper, "CvUnit", &info->m_iExtraTerrainAttackPercent, "extraAttackPercent");
				WRAPPER_READ_DECORATED(wrapper, "CvUnit", &info->m_iExtraTerrainDefensePercent, "extraDefensePercent");
				WRAPPER_READ_DECORATED(wrapper, "CvUnit", &info->m_iExtraTerrainWorkPercent, "terrainExtraWorkPercent");
				WRAPPER_READ_DECORATED(wrapper, "CvUnit", &info->m_iExtraWithdrawOnTerrainType, "extraWithdrawOnTerrainType");
			}
		}
	} while(iI != -1);

	do
	{
		iI = -1;
		WRAPPER_READ_DECORATED(wrapper, "CvUnit", &iI, "hasFeatureInfo");
		if (iI != -1)
		{
			const int iNewIndex = wrapper.getNewClassEnumValue(REMAPPED_CLASS_TYPE_FEATURES, iI, true);

			if (iNewIndex != NO_FEATURE)
			{
				FeatureKeyedInfo* info = findOrCreateFeatureKeyedInfo((FeatureTypes)iNewIndex);

				WRAPPER_READ_DECORATED(wrapper, "CvUnit", &info->m_iFeatureDoubleMoveCount, "FeatureDoubleMove");
				WRAPPER_READ_DECORATED(wrapper, "CvUnit", &info->m_iExtraFeatureAttackPercent, "extraAttackPercent");
				WRAPPER_READ_DECORATED(wrapper, "CvUnit", &info->m_iExtraFeatureDefensePercent, "extraDefensePercent");
				WRAPPER_READ_DECORATED(wrapper, "CvUnit", &info->m_iExtraFeatureWorkPercent, "featureExtraWorkPercent");
				WRAPPER_READ_DECORATED(wrapper, "CvUnit", &info->m_iExtraWithdrawOnFeatureType, "extraWithdrawOnFeatureType");
			}
		}
	} while(iI != -1);

	for (int iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
	{
		g_paiTempExtraUnitCombatModifier[iI] = 0;
	}
	do
	{
		iI= -1;
		WRAPPER_READ_DECORATED(wrapper, "CvUnit", &iI, "hasUnitCombatInfo");
		if ( iI != -1 )
		{
			int iNewIndex = wrapper.getNewClassEnumValue(REMAPPED_CLASS_TYPE_COMBATINFOS, iI, true);

			if ( iNewIndex != NO_UNITCOMBAT )
			{
				WRAPPER_READ_DECORATED(wrapper, "CvUnit", &g_paiTempExtraUnitCombatModifier[iNewIndex], "ExtraUnitCombatMod");
			}
		}
	} while(iI != -1);

	for (int iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
	{
		if ( g_paiTempExtraUnitCombatModifier[iI] != 0 )
		{
			UnitCombatKeyedInfo* info = findOrCreateUnitCombatKeyedInfo((UnitCombatTypes)iI);

			info->m_iExtraUnitCombatModifier = g_paiTempExtraUnitCombatModifier[iI];
		}
	}

	m_Properties.readWrapper(pStream);

	//TB Combat Mods Begin  TB SubCombat Mods Begin
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraPursuit);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraEarlyWithdraw);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraVSBarbs);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraArmor);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraPuncture);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraOverrun);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraRepel);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraFortRepel);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraRepelRetries);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraUnyielding);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraKnockback);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraKnockbackRetries);
	WRAPPER_READ(wrapper, "CvUnit", &m_iStampedeCount);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraStrAdjperRnd);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraStrAdjperAtt);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraStrAdjperDef);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraWithdrawAdjperAtt);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraUnnerve);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraEnclose);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraLunge);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraDynamicDefense);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraStrength);
	WRAPPER_READ(wrapper, "CvUnit", &m_iAnimalIgnoresBordersCount);
	WRAPPER_READ(wrapper, "CvUnit", &m_iOnslaughtCount);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraFortitude);

	// Read compressed data format
	for (int iI = 0; iI < GC.getNumPromotionInfos(); iI++)
	{
		g_paiTempAfflictOnAttackCount[iI] = 0;
		g_paiTempCureAfflictionCount[iI] = 0;
		g_paiTempAfflictionTurnCount[iI] = 0;
		g_paiTempAfflictionHitCount[iI] = 0;
		g_paiTempAfflictionTolerance[iI] = 0;
		g_paiTempFortitudeModifierTypeAmount[iI] = 0;
		g_paiTempTrapSetWithPromotionCount[iI] = 0;
		g_paiTempPromotionFromTraitCount[iI] = 0;
	}
	do
	{
		iI= -1;
		WRAPPER_READ_DECORATED(wrapper, "CvUnit", &iI, "hasAfflicationInfo");
		if ( iI != -1 )
		{
			int iNewIndex = wrapper.getNewClassEnumValue(REMAPPED_CLASS_TYPE_PROMOTIONS, iI, true);

			if ( iNewIndex != NO_PROMOTION )
			{
				WRAPPER_READ_DECORATED(wrapper, "CvUnit", &g_paiTempAfflictOnAttackCount[iNewIndex], "afflictOnAttack");
				WRAPPER_READ_DECORATED(wrapper, "CvUnit", &g_paiTempCureAfflictionCount[iNewIndex], "cureAffliction");
				WRAPPER_READ_DECORATED(wrapper, "CvUnit", &g_paiTempAfflictionTurnCount[iNewIndex], "afflictionTurn");
				WRAPPER_READ_DECORATED(wrapper, "CvUnit", &g_paiTempAfflictionHitCount[iNewIndex], "afflictionHit");
				WRAPPER_READ_DECORATED(wrapper, "CvUnit", &g_paiTempAfflictionTolerance[iNewIndex], "afflictionTolerance");
				WRAPPER_READ_DECORATED(wrapper, "CvUnit", &g_paiTempFortitudeModifierTypeAmount[iNewIndex], "fortitudeModifierType");
				WRAPPER_READ_DECORATED(wrapper, "CvUnit", &g_paiTempTrapSetWithPromotionCount[iNewIndex], "trapSetWithPromotionType");
				WRAPPER_READ_DECORATED(wrapper, "CvUnit", &g_paiTempPromotionFromTraitCount[iNewIndex], "promotionFromTraitCount");
			}
		}
	} while(iI != -1);

	for (int iI = 0; iI < GC.getNumPromotionInfos(); iI++)
	{
		if (
		   0 != g_paiTempAfflictOnAttackCount[iI]
		|| 0 != g_paiTempCureAfflictionCount[iI]
		|| 0 != g_paiTempAfflictionTurnCount[iI]
		|| 0 != g_paiTempAfflictionHitCount[iI]
		|| 0 != g_paiTempAfflictionTolerance[iI]
		|| 0 != g_paiTempFortitudeModifierTypeAmount[iI]
		|| 0 != g_paiTempTrapSetWithPromotionCount[iI]
		|| 0 != g_paiTempPromotionFromTraitCount[iI])
		{
			PromotionKeyedInfo* info = findOrCreatePromotionKeyedInfo((PromotionTypes)iI);

			info->m_iAfflictOnAttackCount = g_paiTempAfflictOnAttackCount[iI];
			info->m_iCureAfflictionCount = g_paiTempCureAfflictionCount[iI];
			info->m_iAfflictionTurnCount = g_paiTempAfflictionTurnCount[iI];
			info->m_iAfflictionHitCount = g_paiTempAfflictionHitCount[iI];
			info->m_iAfflictionTolerance = g_paiTempAfflictionTolerance[iI];
			info->m_iFortitudeModifierTypeAmount = g_paiTempFortitudeModifierTypeAmount[iI];
			info->m_iTrapSetWithPromotionCount = g_paiTempTrapSetWithPromotionCount[iI];
			info->m_iPromotionFromTraitCount = g_paiTempPromotionFromTraitCount[iI];
		}
	}

	WRAPPER_READ(wrapper, "CvUnit", &m_iRoundCount);
	WRAPPER_READ(wrapper, "CvUnit", &m_iAttackCount);
	WRAPPER_READ(wrapper, "CvUnit", &m_iDefenseCount);

#ifdef STRENGTH_IN_NUMBERS
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraFrontSupportPercent);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraShortRangeSupportPercent);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraMediumRangeSupportPercent);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraLongRangeSupportPercent);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraFlankSupportPercent);
	WRAPPER_READ(wrapper, "CvUnit", &m_iSupportCount);
	WRAPPER_READ(wrapper, "CvUnit", &m_iAttackFromPlotX);
	WRAPPER_READ(wrapper, "CvUnit", &m_iAttackFromPlotY);
	WRAPPER_READ(wrapper, "CvUnit", (int*)&afIUnit.eOwner);
	WRAPPER_READ(wrapper, "CvUnit", &afIUnit.iID);
	WRAPPER_READ(wrapper, "CvUnit", (int*)&afIIUnit.eOwner);
	WRAPPER_READ(wrapper, "CvUnit", &afIIUnit.iID);
	WRAPPER_READ(wrapper, "CvUnit", (int*)&asrIUnit.eOwner);
	WRAPPER_READ(wrapper, "CvUnit", &asrIUnit.iID);
	WRAPPER_READ(wrapper, "CvUnit", (int*)&asrIIUnit.eOwner);
	WRAPPER_READ(wrapper, "CvUnit", &asrIIUnit.iID);
	WRAPPER_READ(wrapper, "CvUnit", (int*)&amrIUnit.eOwner);
	WRAPPER_READ(wrapper, "CvUnit", &amrIUnit.iID);
	WRAPPER_READ(wrapper, "CvUnit", (int*)&amrIIUnit.eOwner);
	WRAPPER_READ(wrapper, "CvUnit", &amrIIUnit.iID);
	WRAPPER_READ(wrapper, "CvUnit", (int*)&alrIUnit.eOwner);
	WRAPPER_READ(wrapper, "CvUnit", &alrIUnit.iID);
	WRAPPER_READ(wrapper, "CvUnit", (int*)&alrIIUnit.eOwner);
	WRAPPER_READ(wrapper, "CvUnit", &alrIIUnit.iID);
	WRAPPER_READ(wrapper, "CvUnit", (int*)&aflIUnit.eOwner);
	WRAPPER_READ(wrapper, "CvUnit", &aflIUnit.iID);
	WRAPPER_READ(wrapper, "CvUnit", (int*)&aflIIUnit.eOwner);
	WRAPPER_READ(wrapper, "CvUnit", &aflIIUnit.iID);
	WRAPPER_READ(wrapper, "CvUnit", (int*)&dfIUnit.eOwner);
	WRAPPER_READ(wrapper, "CvUnit", &dfIUnit.iID);
	WRAPPER_READ(wrapper, "CvUnit", (int*)&dfIIUnit.eOwner);
	WRAPPER_READ(wrapper, "CvUnit", &dfIIUnit.iID);
	WRAPPER_READ(wrapper, "CvUnit", (int*)&dsrIUnit.eOwner);
	WRAPPER_READ(wrapper, "CvUnit", &dsrIUnit.iID);
	WRAPPER_READ(wrapper, "CvUnit", (int*)&dsrIIUnit.eOwner);
	WRAPPER_READ(wrapper, "CvUnit", &dsrIIUnit.iID);
	WRAPPER_READ(wrapper, "CvUnit", (int*)&dmrIUnit.eOwner);
	WRAPPER_READ(wrapper, "CvUnit", &dmrIUnit.iID);
	WRAPPER_READ(wrapper, "CvUnit", (int*)&dmrIIUnit.eOwner);
	WRAPPER_READ(wrapper, "CvUnit", &dmrIIUnit.iID);
	WRAPPER_READ(wrapper, "CvUnit", (int*)&dlrIUnit.eOwner);
	WRAPPER_READ(wrapper, "CvUnit", &dlrIUnit.iID);
	WRAPPER_READ(wrapper, "CvUnit", (int*)&dlrIIUnit.eOwner);
	WRAPPER_READ(wrapper, "CvUnit", &dlrIIUnit.iID);
	WRAPPER_READ(wrapper, "CvUnit", (int*)&dflIUnit.eOwner);
	WRAPPER_READ(wrapper, "CvUnit", &dflIUnit.iID);
	WRAPPER_READ(wrapper, "CvUnit", (int*)&dflIIUnit.eOwner);
	WRAPPER_READ(wrapper, "CvUnit", &dflIIUnit.iID);
#else
	WRAPPER_SKIP_ELEMENT(wrapper, "CvUnit", m_iExtraFrontSupportPercent, SAVE_VALUE_TYPE_INT);
	WRAPPER_SKIP_ELEMENT(wrapper, "CvUnit", m_iExtraShortRangeSupportPercent, SAVE_VALUE_TYPE_INT);
	WRAPPER_SKIP_ELEMENT(wrapper, "CvUnit", m_iExtraMediumRangeSupportPercent, SAVE_VALUE_TYPE_INT);
	WRAPPER_SKIP_ELEMENT(wrapper, "CvUnit", m_iExtraLongRangeSupportPercent, SAVE_VALUE_TYPE_INT);
	WRAPPER_SKIP_ELEMENT(wrapper, "CvUnit", m_iExtraFlankSupportPercent, SAVE_VALUE_TYPE_INT);
	WRAPPER_SKIP_ELEMENT(wrapper, "CvUnit", m_iSupportCount, SAVE_VALUE_TYPE_INT);
	WRAPPER_SKIP_ELEMENT(wrapper, "CvUnit", m_iAttackFromPlotX, SAVE_VALUE_TYPE_INT);
	WRAPPER_SKIP_ELEMENT(wrapper, "CvUnit", m_iAttackFromPlotY, SAVE_VALUE_TYPE_INT);

	WRAPPER_SKIP_ELEMENT(wrapper, "CvUnit", (int*)afIUnit.eOwner, SAVE_VALUE_TYPE_INT);
	WRAPPER_SKIP_ELEMENT(wrapper, "CvUnit", afIUnit.iID, SAVE_VALUE_TYPE_INT);
	WRAPPER_SKIP_ELEMENT(wrapper, "CvUnit", (int*)afIIUnit.eOwner, SAVE_VALUE_TYPE_INT);
	WRAPPER_SKIP_ELEMENT(wrapper, "CvUnit", afIIUnit.iID, SAVE_VALUE_TYPE_INT);
	WRAPPER_SKIP_ELEMENT(wrapper, "CvUnit", (int*)asrIUnit.eOwner, SAVE_VALUE_TYPE_INT);
	WRAPPER_SKIP_ELEMENT(wrapper, "CvUnit", asrIUnit.iID, SAVE_VALUE_TYPE_INT);
	WRAPPER_SKIP_ELEMENT(wrapper, "CvUnit", (int*)asrIIUnit.eOwner, SAVE_VALUE_TYPE_INT);
	WRAPPER_SKIP_ELEMENT(wrapper, "CvUnit", asrIIUnit.iID, SAVE_VALUE_TYPE_INT);
	WRAPPER_SKIP_ELEMENT(wrapper, "CvUnit", (int*)amrIUnit.eOwner, SAVE_VALUE_TYPE_INT);
	WRAPPER_SKIP_ELEMENT(wrapper, "CvUnit", amrIUnit.iID, SAVE_VALUE_TYPE_INT);
	WRAPPER_SKIP_ELEMENT(wrapper, "CvUnit", (int*)amrIIUnit.eOwner, SAVE_VALUE_TYPE_INT);
	WRAPPER_SKIP_ELEMENT(wrapper, "CvUnit", amrIIUnit.iID, SAVE_VALUE_TYPE_INT);
	WRAPPER_SKIP_ELEMENT(wrapper, "CvUnit", (int*)alrIUnit.eOwner, SAVE_VALUE_TYPE_INT);
	WRAPPER_SKIP_ELEMENT(wrapper, "CvUnit", alrIUnit.iID, SAVE_VALUE_TYPE_INT);
	WRAPPER_SKIP_ELEMENT(wrapper, "CvUnit", (int*)alrIIUnit.eOwner, SAVE_VALUE_TYPE_INT);
	WRAPPER_SKIP_ELEMENT(wrapper, "CvUnit", alrIIUnit.iID, SAVE_VALUE_TYPE_INT);
	WRAPPER_SKIP_ELEMENT(wrapper, "CvUnit", (int*)aflIUnit.eOwner, SAVE_VALUE_TYPE_INT);
	WRAPPER_SKIP_ELEMENT(wrapper, "CvUnit", aflIUnit.iID, SAVE_VALUE_TYPE_INT);
	WRAPPER_SKIP_ELEMENT(wrapper, "CvUnit", (int*)aflIIUnit.eOwner, SAVE_VALUE_TYPE_INT);
	WRAPPER_SKIP_ELEMENT(wrapper, "CvUnit", aflIIUnit.iID, SAVE_VALUE_TYPE_INT);
	WRAPPER_SKIP_ELEMENT(wrapper, "CvUnit", (int*)dfIUnit.eOwner, SAVE_VALUE_TYPE_INT);
	WRAPPER_SKIP_ELEMENT(wrapper, "CvUnit", dfIUnit.iID, SAVE_VALUE_TYPE_INT);
	WRAPPER_SKIP_ELEMENT(wrapper, "CvUnit", (int*)dfIIUnit.eOwner, SAVE_VALUE_TYPE_INT);
	WRAPPER_SKIP_ELEMENT(wrapper, "CvUnit", dfIIUnit.iID, SAVE_VALUE_TYPE_INT);
	WRAPPER_SKIP_ELEMENT(wrapper, "CvUnit", (int*)dsrIUnit.eOwner, SAVE_VALUE_TYPE_INT);
	WRAPPER_SKIP_ELEMENT(wrapper, "CvUnit", dsrIUnit.iID, SAVE_VALUE_TYPE_INT);
	WRAPPER_SKIP_ELEMENT(wrapper, "CvUnit", (int*)dsrIIUnit.eOwner, SAVE_VALUE_TYPE_INT);
	WRAPPER_SKIP_ELEMENT(wrapper, "CvUnit", dsrIIUnit.iID, SAVE_VALUE_TYPE_INT);
	WRAPPER_SKIP_ELEMENT(wrapper, "CvUnit", (int*)dmrIUnit.eOwner, SAVE_VALUE_TYPE_INT);
	WRAPPER_SKIP_ELEMENT(wrapper, "CvUnit", dmrIUnit.iID, SAVE_VALUE_TYPE_INT);
	WRAPPER_SKIP_ELEMENT(wrapper, "CvUnit", (int*)dmrIIUnit.eOwner, SAVE_VALUE_TYPE_INT);
	WRAPPER_SKIP_ELEMENT(wrapper, "CvUnit", dmrIIUnit.iID, SAVE_VALUE_TYPE_INT);
	WRAPPER_SKIP_ELEMENT(wrapper, "CvUnit", (int*)dlrIUnit.eOwner, SAVE_VALUE_TYPE_INT);
	WRAPPER_SKIP_ELEMENT(wrapper, "CvUnit", dlrIUnit.iID, SAVE_VALUE_TYPE_INT);
	WRAPPER_SKIP_ELEMENT(wrapper, "CvUnit", (int*)dlrIIUnit.eOwner, SAVE_VALUE_TYPE_INT);
	WRAPPER_SKIP_ELEMENT(wrapper, "CvUnit", dlrIIUnit.iID, SAVE_VALUE_TYPE_INT);
	WRAPPER_SKIP_ELEMENT(wrapper, "CvUnit", (int*)dflIUnit.eOwner, SAVE_VALUE_TYPE_INT);
	WRAPPER_SKIP_ELEMENT(wrapper, "CvUnit", dflIUnit.iID, SAVE_VALUE_TYPE_INT);
	WRAPPER_SKIP_ELEMENT(wrapper, "CvUnit", (int*)dflIIUnit.eOwner, SAVE_VALUE_TYPE_INT);
	WRAPPER_SKIP_ELEMENT(wrapper, "CvUnit", dflIIUnit.iID, SAVE_VALUE_TYPE_INT);
#endif // STRENGTH_IN_NUMBERS

	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraDodgeModifier);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraPrecisionModifier);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraPowerShots);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraPowerShotCombatModifier);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraPowerShotPunctureModifier);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraPowerShotPrecisionModifier);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraPowerShotCriticalModifier);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraCriticalModifier);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraEndurance);
	WRAPPER_READ(wrapper, "CvUnit", &m_iColdDamage);
	WRAPPER_READ(wrapper, "CvUnit", &m_iDealColdDamageCount);
	WRAPPER_READ(wrapper, "CvUnit", &m_iColdImmuneCount);
	WRAPPER_READ(wrapper, "CvUnit", &m_iCombatPowerShots);

	// Read compressed data format
	for (int iI = 0; iI < GC.getNumPromotionInfos(); iI++)
	{
		g_paiTempPromotionFreeCount[iI] = 0;
	}
	do
	{
		iI= -1;
		WRAPPER_READ_DECORATED(wrapper, "CvUnit", &iI, "hasFreePromotionCount");
		if ( iI != -1 )
		{
			int iNewIndex = wrapper.getNewClassEnumValue(REMAPPED_CLASS_TYPE_PROMOTIONS, iI, true);

			if ( iNewIndex != NO_PROMOTION )
			{
				WRAPPER_READ_DECORATED(wrapper, "CvUnit", &g_paiTempPromotionFreeCount[iNewIndex], "FreePromoCount");
			}
		}
	} while(iI != -1);

	for (int iI = 0; iI < GC.getNumPromotionInfos(); iI++)
	{
		if ( g_paiTempPromotionFreeCount[iI] != 0 )
		{
			PromotionKeyedInfo* info = findOrCreatePromotionKeyedInfo((PromotionTypes)iI);

			info->m_iPromotionFreeCount = g_paiTempPromotionFreeCount[iI];
		}
	}
	WRAPPER_READ(wrapper, "CvUnit", &m_iCombatKnockbacks);
	WRAPPER_READ(wrapper, "CvUnit", &m_iCombatRepels);

	// Read compressed data format
	for (int iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
	{
		g_paiTempExtraFlankingStrengthbyUnitCombatType[iI] = 0;
	}
	do
	{
		iI= -1;
		WRAPPER_READ_DECORATED(wrapper, "CvUnit", &iI, "hasUnitCombatInfo5");
		if ( iI != -1 )
		{
			int iNewIndex = wrapper.getNewClassEnumValue(REMAPPED_CLASS_TYPE_COMBATINFOS, iI, true);

			if ( iNewIndex != NO_UNITCOMBAT )
			{
				WRAPPER_READ_DECORATED(wrapper, "CvUnit", &g_paiTempExtraFlankingStrengthbyUnitCombatType[iNewIndex], "extraFlankingStrengthbyUnitCombatType");
			}
		}
	} while(iI != -1);

	for (int iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
	{
		if ( g_paiTempExtraFlankingStrengthbyUnitCombatType[iI] != 0 )
		{
			UnitCombatKeyedInfo* info = findOrCreateUnitCombatKeyedInfo((UnitCombatTypes)iI);

			info->m_iExtraFlankingStrengthbyUnitCombatType = g_paiTempExtraFlankingStrengthbyUnitCombatType[iI];
		}
	}

	// Read compressed data format
	for (int iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
	{
		g_paiTempExtraWithdrawVSUnitCombatType[iI] = 0;
	}
	do
	{
		iI= -1;
		WRAPPER_READ_DECORATED(wrapper, "CvUnit", &iI, "hasUnitCombatInfo6");
		if ( iI != -1 )
		{
			int iNewIndex = wrapper.getNewClassEnumValue(REMAPPED_CLASS_TYPE_COMBATINFOS, iI, true);

			if ( iNewIndex != NO_UNITCOMBAT )
			{
				WRAPPER_READ_DECORATED(wrapper, "CvUnit", &g_paiTempExtraWithdrawVSUnitCombatType[iNewIndex], "extraWithdrawVSUnitCombatType");
			}
		}
	} while(iI != -1);

	for (int iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
	{
		if ( g_paiTempExtraWithdrawVSUnitCombatType[iI] != 0 )
		{
			UnitCombatKeyedInfo* info = findOrCreateUnitCombatKeyedInfo((UnitCombatTypes)iI);

			info->m_iExtraWithdrawVSUnitCombatType = g_paiTempExtraWithdrawVSUnitCombatType[iI];
		}
	}

	// Read compressed data format
	for (int iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
	{
		g_paiTempExtraRepelVSUnitCombatType[iI] = 0;
	}
	do
	{
		iI= -1;
		WRAPPER_READ_DECORATED(wrapper, "CvUnit", &iI, "hasUnitCombatInfo7");
		if ( iI != -1 )
		{
			int iNewIndex = wrapper.getNewClassEnumValue(REMAPPED_CLASS_TYPE_COMBATINFOS, iI, true);

			if ( iNewIndex != NO_UNITCOMBAT )
			{
				WRAPPER_READ_DECORATED(wrapper, "CvUnit", &g_paiTempExtraRepelVSUnitCombatType[iNewIndex], "extraRepelVSUnitCombatType");
			}
		}
	} while(iI != -1);

	for (int iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
	{
		if ( g_paiTempExtraRepelVSUnitCombatType[iI] != 0 )
		{
			UnitCombatKeyedInfo* info = findOrCreateUnitCombatKeyedInfo((UnitCombatTypes)iI);

			info->m_iExtraRepelVSUnitCombatType = g_paiTempExtraRepelVSUnitCombatType[iI];
		}
	}

	// Read compressed data format
	for (int iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
	{
		g_paiTempExtraKnockbackVSUnitCombatType[iI] = 0;
	}
	do
	{
		iI= -1;
		WRAPPER_READ_DECORATED(wrapper, "CvUnit", &iI, "hasUnitCombatInfo8");
		if ( iI != -1 )
		{
			int iNewIndex = wrapper.getNewClassEnumValue(REMAPPED_CLASS_TYPE_COMBATINFOS, iI, true);

			if ( iNewIndex != NO_UNITCOMBAT )
			{
				WRAPPER_READ_DECORATED(wrapper, "CvUnit", &g_paiTempExtraKnockbackVSUnitCombatType[iNewIndex], "extraKnockbackVSUnitCombatType");
			}
		}
	} while(iI != -1);

	for (int iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
	{
		if ( g_paiTempExtraKnockbackVSUnitCombatType[iI] != 0 )
		{
			UnitCombatKeyedInfo* info = findOrCreateUnitCombatKeyedInfo((UnitCombatTypes)iI);

			info->m_iExtraKnockbackVSUnitCombatType = g_paiTempExtraKnockbackVSUnitCombatType[iI];
		}
	}

	// Read compressed data format
	for (int iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
	{
		g_paiTempExtraPunctureVSUnitCombatType[iI] = 0;
	}
	do
	{
		iI= -1;
		WRAPPER_READ_DECORATED(wrapper, "CvUnit", &iI, "hasUnitCombatInfo9");
		if ( iI != -1 )
		{
			int iNewIndex = wrapper.getNewClassEnumValue(REMAPPED_CLASS_TYPE_COMBATINFOS, iI, true);

			if ( iNewIndex != NO_UNITCOMBAT )
			{
				WRAPPER_READ_DECORATED(wrapper, "CvUnit", &g_paiTempExtraPunctureVSUnitCombatType[iNewIndex], "extraPunctureVSUnitCombatType");
			}
		}
	} while(iI != -1);

	for (int iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
	{
		if ( g_paiTempExtraPunctureVSUnitCombatType[iI] != 0 )
		{
			UnitCombatKeyedInfo* info = findOrCreateUnitCombatKeyedInfo((UnitCombatTypes)iI);

			info->m_iExtraPunctureVSUnitCombatType = g_paiTempExtraPunctureVSUnitCombatType[iI];
		}
	}

	// Read compressed data format
	for (int iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
	{
		g_paiTempExtraArmorVSUnitCombatType[iI] = 0;
	}
	do
	{
		iI= -1;
		WRAPPER_READ_DECORATED(wrapper, "CvUnit", &iI, "hasUnitCombatInfo10");
		if ( iI != -1 )
		{
			int iNewIndex = wrapper.getNewClassEnumValue(REMAPPED_CLASS_TYPE_COMBATINFOS, iI, true);

			if ( iNewIndex != NO_UNITCOMBAT )
			{
				WRAPPER_READ_DECORATED(wrapper, "CvUnit", &g_paiTempExtraArmorVSUnitCombatType[iNewIndex], "extraArmorVSUnitCombatType");
			}
		}
	} while(iI != -1);

	for (int iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
	{
		if ( g_paiTempExtraArmorVSUnitCombatType[iI] != 0 )
		{
			UnitCombatKeyedInfo* info = findOrCreateUnitCombatKeyedInfo((UnitCombatTypes)iI);

			info->m_iExtraArmorVSUnitCombatType = g_paiTempExtraArmorVSUnitCombatType[iI];
		}
	}

	// Read compressed data format
	for (int iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
	{
		g_paiTempExtraDodgeVSUnitCombatType[iI] = 0;
	}
	do
	{
		iI= -1;
		WRAPPER_READ_DECORATED(wrapper, "CvUnit", &iI, "hasUnitCombatInfo11");
		if ( iI != -1 )
		{
			int iNewIndex = wrapper.getNewClassEnumValue(REMAPPED_CLASS_TYPE_COMBATINFOS, iI, true);

			if ( iNewIndex != NO_UNITCOMBAT )
			{
				WRAPPER_READ_DECORATED(wrapper, "CvUnit", &g_paiTempExtraDodgeVSUnitCombatType[iNewIndex], "extraDodgeVSUnitCombatType");
			}
		}
	} while(iI != -1);

	for (int iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
	{
		if ( g_paiTempExtraDodgeVSUnitCombatType[iI] != 0 )
		{
			UnitCombatKeyedInfo* info = findOrCreateUnitCombatKeyedInfo((UnitCombatTypes)iI);

			info->m_iExtraDodgeVSUnitCombatType = g_paiTempExtraDodgeVSUnitCombatType[iI];
		}
	}

	// Read compressed data format
	for (int iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
	{
		g_paiTempExtraPrecisionVSUnitCombatType[iI] = 0;
	}
	do
	{
		iI= -1;
		WRAPPER_READ_DECORATED(wrapper, "CvUnit", &iI, "hasUnitCombatInfo12");
		if ( iI != -1 )
		{
			int iNewIndex = wrapper.getNewClassEnumValue(REMAPPED_CLASS_TYPE_COMBATINFOS, iI, true);

			if ( iNewIndex != NO_UNITCOMBAT )
			{
				WRAPPER_READ_DECORATED(wrapper, "CvUnit", &g_paiTempExtraPrecisionVSUnitCombatType[iNewIndex], "extraPrecisionVSUnitCombatType");
			}
		}
	} while(iI != -1);

	for (int iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
	{
		if ( g_paiTempExtraPrecisionVSUnitCombatType[iI] != 0 )
		{
			UnitCombatKeyedInfo* info = findOrCreateUnitCombatKeyedInfo((UnitCombatTypes)iI);

			info->m_iExtraPrecisionVSUnitCombatType = g_paiTempExtraPrecisionVSUnitCombatType[iI];
		}
	}

	// Read compressed data format
	for (int iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
	{
		g_paiTempExtraCriticalVSUnitCombatType[iI] = 0;
	}
	do
	{
		iI= -1;
		WRAPPER_READ_DECORATED(wrapper, "CvUnit", &iI, "hasUnitCombatInfo13");
		if ( iI != -1 )
		{
			int iNewIndex = wrapper.getNewClassEnumValue(REMAPPED_CLASS_TYPE_COMBATINFOS, iI, true);

			if ( iNewIndex != NO_UNITCOMBAT )
			{
				WRAPPER_READ_DECORATED(wrapper, "CvUnit", &g_paiTempExtraCriticalVSUnitCombatType[iNewIndex], "extraCriticalVSUnitCombatType");
			}
		}
	} while(iI != -1);

	for (int iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
	{
		if ( g_paiTempExtraCriticalVSUnitCombatType[iI] != 0 )
		{
			UnitCombatKeyedInfo* info = findOrCreateUnitCombatKeyedInfo((UnitCombatTypes)iI);

			info->m_iExtraCriticalVSUnitCombatType = g_paiTempExtraCriticalVSUnitCombatType[iI];
		}
	}

	// Read compressed data format
	for (int iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
	{
		g_paiTempExtraRoundStunVSUnitCombatType[iI] = 0;
	}
	do
	{
		iI= -1;
		WRAPPER_READ_DECORATED(wrapper, "CvUnit", &iI, "hasUnitCombatInfo14");
		if ( iI != -1 )
		{
			int iNewIndex = wrapper.getNewClassEnumValue(REMAPPED_CLASS_TYPE_COMBATINFOS, iI, true);

			if ( iNewIndex != NO_UNITCOMBAT )
			{
				WRAPPER_READ_DECORATED(wrapper, "CvUnit", &g_paiTempExtraRoundStunVSUnitCombatType[iNewIndex], "extraRoundStunVSUnitCombatType");
			}
		}
	} while(iI != -1);

	for (int iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
	{
		if ( g_paiTempExtraRoundStunVSUnitCombatType[iI] != 0 )
		{
			UnitCombatKeyedInfo* info = findOrCreateUnitCombatKeyedInfo((UnitCombatTypes)iI);

			info->m_iExtraRoundStunVSUnitCombatType = g_paiTempExtraRoundStunVSUnitCombatType[iI];
		}
	}
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraRoundStunProb);
	WRAPPER_READ(wrapper, "CvUnit", &m_iCombatStuns);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraPoisonProbabilityModifier);

	// Read compressed data format
	for (int iI = 0; iI < GC.getNumPromotionLineInfos(); iI++)
	{
		g_pabTempValidBuildUp[iI] = false;
#ifdef OUTBREAKS_AND_AFFLICTIONS
		g_paiTempAfflictOnAttackTypeProbability[iI] = 0;
		g_paiTempAfflictOnAttackTypeCount[iI] = 0;
		g_paiTempAfflictOnAttackTypeImmediateCount[iI] = 0;
		g_paiTempAfflictOnAttackTypeAttemptedCount[iI] = 0;
		g_paiTempCureAfflictionTypeCount[iI] = 0;
		g_paiTempAfflictionTurnTypeCount[iI] = 0;
		g_paiTempAfflictionLineCount[iI] = 0;
		g_paiTempAfflictionTypeTolerance[iI] = 0;
		g_paiTempFortitudeModifierAmount[iI] = 0;
		g_paiTempDistanceAttackCommunicability[iI] = 0;
		g_paiTempAfflictOnAttackTypeMeleeCount[iI] = 0;
		g_paiTempAfflictOnAttackTypeDistanceCount[iI] = 0;
#endif
	}
	do
	{
		iI= -1;
		WRAPPER_READ_DECORATED(wrapper, "CvUnit", &iI, "hasAfflictOnAttackInfo");
		if ( iI != -1 )
		{
			int iNewIndex = wrapper.getNewClassEnumValue(REMAPPED_CLASS_TYPE_PROMOTIONLINES, iI, true);

			if ( iNewIndex != NO_PROMOTIONLINE )
			{
				WRAPPER_READ_DECORATED(wrapper, "CvUnit", &g_pabTempValidBuildUp[iNewIndex], "validBuildUp");
//#ifdef OUTBREAKS_AND_AFFLICTIONS
				WRAPPER_READ_DECORATED(wrapper, "CvUnit", &g_paiTempAfflictOnAttackTypeProbability[iNewIndex], "afflictOnAttackTypeProb");
				WRAPPER_READ_DECORATED(wrapper, "CvUnit", &g_paiTempAfflictOnAttackTypeCount[iNewIndex], "afflictOnAttackTypeCount");
				WRAPPER_READ_DECORATED(wrapper, "CvUnit", &g_paiTempAfflictOnAttackTypeImmediateCount[iNewIndex], "afflictOnAttackTypeImmediateCount");
				WRAPPER_READ_DECORATED(wrapper, "CvUnit", &g_paiTempAfflictOnAttackTypeAttemptedCount[iNewIndex], "afflictOnAttackTypeAttemptedCount");
				WRAPPER_READ_DECORATED(wrapper, "CvUnit", &g_paiTempCureAfflictionTypeCount[iNewIndex], "cureAfflictionType");
				WRAPPER_READ_DECORATED(wrapper, "CvUnit", &g_paiTempAfflictionTurnTypeCount[iNewIndex], "afflictionTurnType");
				WRAPPER_READ_DECORATED(wrapper, "CvUnit", &g_paiTempAfflictionLineCount[iNewIndex], "hasAfflictionLine");
				WRAPPER_READ_DECORATED(wrapper, "CvUnit", &g_paiTempAfflictionTypeTolerance[iNewIndex], "afflictionToleranceType");
				WRAPPER_READ_DECORATED(wrapper, "CvUnit", &g_paiTempFortitudeModifierAmount[iNewIndex], "fortitudeModifier");
				WRAPPER_READ_DECORATED(wrapper, "CvUnit", &g_paiTempDistanceAttackCommunicability[iNewIndex], "distanceAttackCommunicability");
				WRAPPER_READ_DECORATED(wrapper, "CvUnit", &g_paiTempAfflictOnAttackTypeMeleeCount[iNewIndex], "afflictOnAttackTypeMeleeCount");
				WRAPPER_READ_DECORATED(wrapper, "CvUnit", &g_paiTempAfflictOnAttackTypeDistanceCount[iNewIndex], "afflictOnAttackTypeDistanceCount");
//#endif
			}
		}
	} while(iI != -1);

	for (int iI = 0; iI < GC.getNumPromotionLineInfos(); iI++)
	{
		bool	bNonDefaultValue =
			g_pabTempValidBuildUp[iI]
#ifdef OUTBREAKS_AND_AFFLICTIONS
			|| g_paiTempAfflictOnAttackTypeProbability[iI] != 0
			|| g_paiTempAfflictOnAttackTypeCount[iI] != 0
			|| g_paiTempAfflictOnAttackTypeImmediateCount[iI] != 0
			|| g_paiTempAfflictOnAttackTypeAttemptedCount[iI] != 0
			|| g_paiTempCureAfflictionTypeCount[iI] != 0
			|| g_paiTempAfflictionTurnTypeCount[iI] != 0
			|| g_paiTempAfflictionLineCount[iI] != 0
			|| g_paiTempAfflictionTypeTolerance[iI] != 0
			|| g_paiTempFortitudeModifierAmount[iI] != 0
			|| g_paiTempDistanceAttackCommunicability[iI] != 0
			|| g_paiTempAfflictOnAttackTypeMeleeCount[iI] != 0
			|| g_paiTempAfflictOnAttackTypeDistanceCount[iI] != 0
#endif
		;

		if ( bNonDefaultValue )
		{
			PromotionLineKeyedInfo* info = findOrCreatePromotionLineKeyedInfo((PromotionLineTypes)iI);

			info->m_bValidBuildUp = g_pabTempValidBuildUp[iI];
#ifdef OUTBREAKS_AND_AFFLICTIONS
			info->m_iAfflictOnAttackTypeProbability = g_paiTempAfflictOnAttackTypeProbability[iI];
			info->m_iAfflictOnAttackTypeCount = g_paiTempAfflictOnAttackTypeCount[iI];
			info->m_iAfflictOnAttackTypeImmediateCount = g_paiTempAfflictOnAttackTypeImmediateCount[iI];
			info->m_iAfflictOnAttackTypeAttemptedCount = g_paiTempAfflictOnAttackTypeAttemptedCount[iI];
			info->m_iCureAfflictionTypeCount = g_paiTempCureAfflictionTypeCount[iI];
			info->m_iAfflictionTurnTypeCount = g_paiTempAfflictionTurnTypeCount[iI];
			info->m_iAfflictionLineCount = g_paiTempAfflictionLineCount[iI];
			info->m_iAfflictionTypeTolerance = g_paiTempAfflictionTypeTolerance[iI];
			info->m_iFortitudeModifierAmount = g_paiTempFortitudeModifierAmount[iI];
			info->m_iDistanceAttackCommunicability = g_paiTempDistanceAttackCommunicability[iI];
			info->m_iAfflictOnAttackTypeMeleeCount = g_paiTempAfflictOnAttackTypeMeleeCount[iI];
			info->m_iAfflictOnAttackTypeDistanceCount = g_paiTempAfflictOnAttackTypeDistanceCount[iI];
#endif
		}
	}
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraAttackCombatModifier);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraDefenseCombatModifier);
	WRAPPER_READ(wrapper, "CvUnit", &m_iRetrainsAvailable);
	//TB Combat Mods End  TB SubCombat Mods End

	WRAPPER_READ(wrapper, "CvUnit", &m_iDefensiveVictoryMoveCount);
	WRAPPER_READ(wrapper, "CvUnit", &m_iFreeDropCount);
	WRAPPER_READ(wrapper, "CvUnit", &m_iOffensiveVictoryMoveCount);
	WRAPPER_READ(wrapper, "CvUnit", &m_iPillageCultureCount);
	WRAPPER_READ(wrapper, "CvUnit", &m_iPillageEspionageCount);
	WRAPPER_READ(wrapper, "CvUnit", &m_iPillageMarauderCount);
	WRAPPER_READ(wrapper, "CvUnit", &m_iPillageOnMoveCount);
	WRAPPER_READ(wrapper, "CvUnit", &m_iPillageOnVictoryCount);
	WRAPPER_READ(wrapper, "CvUnit", &m_iPillageResearchCount);
	WRAPPER_READ(wrapper, "CvUnit", &m_iAirCombatLimitChange);
	WRAPPER_READ(wrapper, "CvUnit", &m_iCelebrityHappy);
	WRAPPER_READ(wrapper, "CvUnit", &m_iCollateralDamageLimitChange);
	WRAPPER_READ(wrapper, "CvUnit", &m_iCollateralDamageMaxUnitsChange);
	WRAPPER_READ(wrapper, "CvUnit", &m_iCombatLimitChange);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraDropRange);
	WRAPPER_READ(wrapper, "CvUnit", &m_iVictoryHeal);
	WRAPPER_READ(wrapper, "CvUnit", &m_iOneUpCount);
	WRAPPER_READ(wrapper, "CvUnit", &m_iSurvivorChance);
	WRAPPER_READ(wrapper, "CvUnit", &m_iVictoryAdjacentHeal);
	WRAPPER_READ(wrapper, "CvUnit", &m_iVictoryStackHeal);
	WRAPPER_READ(wrapper, "CvUnit", &m_bSurvivor);

	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraCaptureProbabilityModifier);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraCaptureResistanceModifier);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraBreakdownChance);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraBreakdownDamage);

	// Read compressed data format
	for (int iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
	{
		g_pabTempHasUnitCombat[iI] = false;
	}
	do
	{
		iI= -1;
		WRAPPER_READ_DECORATED(wrapper, "CvUnit", &iI, "hasUnitCombat");
		if ( iI != -1 )
		{
			int iNewIndex = wrapper.getNewClassEnumValue(REMAPPED_CLASS_TYPE_COMBATINFOS, iI, true);

			if ( iNewIndex != NO_UNITCOMBAT )
			{
				g_pabTempHasUnitCombat[iNewIndex] = true;
			}
		}
	} while(iI != -1);

	for (int iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
	{
		if (g_pabTempHasUnitCombat[iI])
		{
			UnitCombatKeyedInfo* info = findOrCreateUnitCombatKeyedInfo((UnitCombatTypes)iI);

			info->m_bHasUnitCombat = true;
		}
	}

	WRAPPER_READ(wrapper, "CvUnit", &m_iAttackOnlyCitiesCount);
	WRAPPER_READ(wrapper, "CvUnit", &m_iIgnoreNoEntryLevelCount);
	WRAPPER_READ(wrapper, "CvUnit", &m_iIgnoreZoneofControlCount);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraTaunt);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraMaxHP);

	// Read compressed data format
	for (int iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
	{
		g_paiTempExtraPursuitVSUnitCombatType[iI] = 0;
	}
	do
	{
		iI= -1;
		WRAPPER_READ_DECORATED(wrapper, "CvUnit", &iI, "hasUnitCombatInfo15");
		if ( iI != -1 )
		{
			int iNewIndex = wrapper.getNewClassEnumValue(REMAPPED_CLASS_TYPE_COMBATINFOS, iI, true);

			if ( iNewIndex != NO_UNITCOMBAT )
			{
				WRAPPER_READ_DECORATED(wrapper, "CvUnit", &g_paiTempExtraPursuitVSUnitCombatType[iNewIndex], "extraPursuitVSUnitCombatType");
			}
		}
	} while(iI != -1);

	for (int iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
	{
		if ( g_paiTempExtraPursuitVSUnitCombatType[iI] != 0 )
		{
			UnitCombatKeyedInfo* info = findOrCreateUnitCombatKeyedInfo((UnitCombatTypes)iI);

			info->m_iExtraPursuitVSUnitCombatType = g_paiTempExtraPursuitVSUnitCombatType[iI];
		}
	}

	WRAPPER_READ(wrapper, "CvUnit", &m_iFliesToMoveCount);
	WRAPPER_READ(wrapper, "CvUnit", &m_iQualityBaseTotal);
	WRAPPER_READ(wrapper, "CvUnit", &m_iGroupBaseTotal);
	WRAPPER_READ(wrapper, "CvUnit", &m_iSizeBaseTotal);
	WRAPPER_READ(wrapper, "CvUnit", &m_iCannotMergeSplitCount);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraStrengthModifier);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraDamageModifier);

	WRAPPER_READ_CLASS_ENUM(wrapper, "CvUnit", REMAPPED_CLASS_TYPE_UNITS, (int*)&m_eGGExperienceEarnedTowardsType);
	WRAPPER_READ(wrapper, "CvUnit", &m_iSMCargo);
	WRAPPER_READ(wrapper, "CvUnit", &m_iSMCargoCapacity);
	WRAPPER_READ(wrapper, "CvUnit", &m_iSMCargoVolume);
	WRAPPER_READ(wrapper, "CvUnit", &m_iSMCargoVolumeModifier);
	WRAPPER_READ(wrapper, "CvUnit", (int*)&m_eNewDomainCargo);

	WRAPPER_READ_CLASS_ENUM_ALLOW_MISSING(wrapper, "CvUnit", REMAPPED_CLASS_TYPE_SPECIAL_UNITS, (int*)&m_eNewSpecialCargo);
	WRAPPER_READ_CLASS_ENUM_ALLOW_MISSING(wrapper, "CvUnit", REMAPPED_CLASS_TYPE_SPECIAL_UNITS, (int*)&m_eNewSMNotSpecialCargo);

	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraQuality);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraGroup);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraSize);
	WRAPPER_READ(wrapper, "CvUnit", &m_iSMStrength);
	WRAPPER_READ(wrapper, "CvUnit", &m_iSMAssetValue);
	WRAPPER_READ(wrapper, "CvUnit", &m_iSMPowerValue);
	WRAPPER_READ(wrapper, "CvUnit", &m_iSMHPValue);
	WRAPPER_READ(wrapper, "CvUnit", &m_iSMExtraCargoVolume);
	WRAPPER_READ(wrapper, "CvUnit", &m_iSMBombardRate);
	WRAPPER_READ(wrapper, "CvUnit", &m_iSMAirBombBaseRate);
	WRAPPER_READ(wrapper, "CvUnit", &m_iSMBaseWorkRate);
	WRAPPER_READ(wrapper, "CvUnit", &m_iSMRevoltProtection);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraRBombardDamage);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraRBombardDamageLimit);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraRBombardDamageMaxUnits);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraDCMBombRange);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraDCMBombAccuracy);
	WRAPPER_READ(wrapper, "CvUnit", &m_iBaseRBombardDamage);
	WRAPPER_READ(wrapper, "CvUnit", &m_iBaseRBombardDamageLimit);
	WRAPPER_READ(wrapper, "CvUnit", &m_iBaseRBombardDamageMaxUnits);
	WRAPPER_READ(wrapper, "CvUnit", &m_iBaseDCMBombRange);
	WRAPPER_READ(wrapper, "CvUnit", &m_iBaseDCMBombAccuracy);
	WRAPPER_READ(wrapper, "CvUnit", &m_iBombardDirectCount);
	WRAPPER_READ(wrapper, "CvUnit", &m_iRBombardForceAbilityCount);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraCombatModifierPerSizeMore);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraCombatModifierPerSizeLess);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraCombatModifierPerVolumeMore);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraCombatModifierPerVolumeLess);
	WRAPPER_READ(wrapper, "CvUnit", &m_iAlwaysInvisibleCount);
	WRAPPER_READ(wrapper, "CvUnit", &m_iHealUnitCombatCount);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraSelfHealModifier);
	WRAPPER_READ(wrapper, "CvUnit", &m_iNoSelfHealCount);

	// Read compressed data format
	for (int iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
	{
		g_paiTempHealAsDamage[iI] = 0;
	}
	do
	{
		iI= -1;
		WRAPPER_READ_DECORATED(wrapper, "CvUnit", &iI, "healAsDamageInfo");
		if ( iI != -1 )
		{
			int iNewIndex = wrapper.getNewClassEnumValue(REMAPPED_CLASS_TYPE_COMBATINFOS, iI, true);

			if ( iNewIndex != NO_UNITCOMBAT )
			{
				WRAPPER_READ_DECORATED(wrapper, "CvUnit", &g_paiTempHealAsDamage[iNewIndex], "healAsDamage");
			}
		}
	} while(iI != -1);

	for (int iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
	{
		if ( g_paiTempHealAsDamage[iI] != 0 )
		{
			UnitCombatKeyedInfo* info = findOrCreateUnitCombatKeyedInfo((UnitCombatTypes)iI);

			info->m_iHealAsDamage = g_paiTempHealAsDamage[iI];
		}
	}

	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraNumHealSupport);
	WRAPPER_READ(wrapper, "CvUnit", &m_iHealSupportUsed);
	WRAPPER_READ_CLASS_ENUM_ALLOW_MISSING(wrapper, "CvUnit", REMAPPED_CLASS_TYPE_MISSIONS, (int*)&m_eSleepType);
	WRAPPER_READ(wrapper, "CvUnit", &m_bHasBuildUp);
	WRAPPER_READ_CLASS_ENUM(wrapper, "CvUnit", REMAPPED_CLASS_TYPE_PROMOTIONLINES, (int*)&m_eCurrentBuildUpType);
	WRAPPER_READ(wrapper, "CvUnit", &m_iZoneOfControlCount);
	WRAPPER_READ(wrapper, "CvUnit", &m_bInhibitMerge);
	WRAPPER_READ(wrapper, "CvUnit", &m_bInhibitSplit);
	WRAPPER_READ(wrapper, "CvUnit", &m_bIsBuildUp);
	WRAPPER_READ_CLASS_ENUM_ALLOW_MISSING(wrapper, "CvUnit", REMAPPED_CLASS_TYPE_SPECIAL_UNITS, (int*)&m_eSpecialUnit);
	WRAPPER_READ(wrapper, "CvUnit", &m_bHasHNCapturePromotion);
	WRAPPER_READ(wrapper, "CvUnit", (int*)&m_eCapturingUnit.eOwner);
	WRAPPER_READ(wrapper, "CvUnit", &m_eCapturingUnit.iID);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExcileCount);
	WRAPPER_READ(wrapper, "CvUnit", &m_iPassageCount);
	WRAPPER_READ(wrapper, "CvUnit", &m_iNoNonOwnedCityEntryCount);
	WRAPPER_READ(wrapper, "CvUnit", &m_iBarbCoExistCount);
	WRAPPER_READ(wrapper, "CvUnit", &m_iBlendIntoCityCount);
	WRAPPER_READ(wrapper, "CvUnit", &m_iUpgradeAnywhereCount);

	// Read compressed data format
	for (int iI = 0; iI < GC.getNumInvisibleInfos(); iI++)
	{
		m_aiExtraVisibilityIntensity[iI] = 0;
		m_aiExtraInvisibilityIntensity[iI] = 0;
		m_aiExtraVisibilityIntensityRange[iI] = 0;
		m_aiNegatesInvisibleCount[iI] = 0;
		m_aiExtraVisibilityIntensitySameTile[iI] = 0;
	}
	do
	{
		iI= -1;
		WRAPPER_READ_DECORATED(wrapper, "CvUnit", &iI, "Visibilities");
		if ( iI != -1 )
		{
			int iNewIndex = wrapper.getNewClassEnumValue(REMAPPED_CLASS_TYPE_INVISIBLES, iI, true);

			if ( iNewIndex != NO_UNITCOMBAT )
			{
				WRAPPER_READ_DECORATED(wrapper, "CvUnit", &m_aiExtraVisibilityIntensity[iNewIndex], "extraVisibilityIntensity");
				WRAPPER_READ_DECORATED(wrapper, "CvUnit", &m_aiExtraInvisibilityIntensity[iNewIndex], "extraInvisibilityIntensity");
				WRAPPER_READ_DECORATED(wrapper, "CvUnit", &m_aiExtraVisibilityIntensityRange[iNewIndex], "extraVisibilityIntensityRange");
				WRAPPER_READ_DECORATED(wrapper, "CvUnit", &m_aiNegatesInvisibleCount[iNewIndex], "negatesInvisibleCount");
				WRAPPER_READ_DECORATED(wrapper, "CvUnit", &m_aiExtraVisibilityIntensitySameTile[iNewIndex], "extraVisibilityIntensitySameTile");
			}
		}
	} while(iI != -1);

	WRAPPER_READ(wrapper, "CvUnit", &m_bHasAnyInvisibility);

	int iType1 = 0;
	int iType2 = 0;
	int iType3 = 0;

	int iSize1 = 0;
	WRAPPER_READ_DECORATED(wrapper, "CvUnit", &iSize1, "m_aExtraInvisibleTerrains.size");
	m_aExtraInvisibleTerrains.resize(iSize1);
	if (iSize1 > 0)
	{
		for (int iI = 0; iI < iSize1; iI++)
		{
			iType1 = 0;
			iType2 = 0;
			iType3 = 0;
			WRAPPER_READ(wrapper, "CvUnit", &iType1);
			WRAPPER_READ(wrapper, "CvUnit", &iType2);
			WRAPPER_READ(wrapper, "CvUnit", &iType3);
			m_aExtraInvisibleTerrains[iI].eInvisible = (InvisibleTypes)iType1;
			m_aExtraInvisibleTerrains[iI].eTerrain = (TerrainTypes)iType2;
			m_aExtraInvisibleTerrains[iI].iIntensity = iType3;
		}
	}

	int iSize2 = 0;
	WRAPPER_READ_DECORATED(wrapper, "CvUnit", &iSize2, "m_aExtraInvisibleFeatures.size");
	m_aExtraInvisibleFeatures.resize(iSize2);
	if (iSize2 > 0)
	{
		for (int iI = 0; iI < iSize2; iI++)
		{
			iType1 = 0;
			iType2 = 0;
			iType3 = 0;
			WRAPPER_READ(wrapper, "CvUnit", &iType1);
			WRAPPER_READ(wrapper, "CvUnit", &iType2);
			WRAPPER_READ(wrapper, "CvUnit", &iType3);
			m_aExtraInvisibleFeatures[iI].eInvisible = (InvisibleTypes)iType1;
			m_aExtraInvisibleFeatures[iI].eFeature = (FeatureTypes)iType2;
			m_aExtraInvisibleFeatures[iI].iIntensity = iType3;
		}
	}

	int iSize3 = 0;
	WRAPPER_READ_DECORATED(wrapper, "CvUnit", &iSize3, "m_aExtraInvisibleImprovements.size");
	m_aExtraInvisibleImprovements.resize(iSize3);
	if (iSize3 > 0)
	{
		for (int iI = 0; iI < iSize3; iI++)
		{
			iType1 = 0;
			iType2 = 0;
			iType3 = 0;
			WRAPPER_READ(wrapper, "CvUnit", &iType1);
			WRAPPER_READ(wrapper, "CvUnit", &iType2);
			WRAPPER_READ(wrapper, "CvUnit", &iType3);
			m_aExtraInvisibleImprovements[iI].eInvisible = (InvisibleTypes)iType1;
			m_aExtraInvisibleImprovements[iI].eImprovement = (ImprovementTypes)iType2;
			m_aExtraInvisibleImprovements[iI].iIntensity = iType3;
		}
	}

	int iSize4 = 0;
	WRAPPER_READ_DECORATED(wrapper, "CvUnit", &iSize4, "m_aExtraVisibleTerrains.size");
	m_aExtraVisibleTerrains.resize(iSize4);
	if (iSize4 > 0)
	{
		for (int iI = 0; iI < iSize4; iI++)
		{
			iType1 = 0;
			iType2 = 0;
			iType3 = 0;
			WRAPPER_READ(wrapper, "CvUnit", &iType1);
			WRAPPER_READ(wrapper, "CvUnit", &iType2);
			WRAPPER_READ(wrapper, "CvUnit", &iType3);
			m_aExtraVisibleTerrains[iI].eInvisible = (InvisibleTypes)iType1;
			m_aExtraVisibleTerrains[iI].eTerrain = (TerrainTypes)iType2;
			m_aExtraVisibleTerrains[iI].iIntensity = iType3;
		}
	}

	int iSize5 = 0;
	WRAPPER_READ_DECORATED(wrapper, "CvUnit", &iSize5, "m_aExtraVisibleFeatures.size");
	m_aExtraVisibleFeatures.resize(iSize5);
	if (iSize5 > 0)
	{
		for (int iI = 0; iI < iSize5; iI++)
		{
			iType1 = 0;
			iType2 = 0;
			iType3 = 0;
			WRAPPER_READ(wrapper, "CvUnit", &iType1);
			WRAPPER_READ(wrapper, "CvUnit", &iType2);
			WRAPPER_READ(wrapper, "CvUnit", &iType3);
			m_aExtraVisibleFeatures[iI].eInvisible = (InvisibleTypes)iType1;
			m_aExtraVisibleFeatures[iI].eFeature = (FeatureTypes)iType2;
			m_aExtraVisibleFeatures[iI].iIntensity = iType3;
		}
	}

	int iSize6 = 0;
	WRAPPER_READ_DECORATED(wrapper, "CvUnit", &iSize6, "m_aExtraVisibleImprovements.size");
	m_aExtraVisibleImprovements.resize(iSize6);
	if (iSize6 > 0)
	{
		for (int iI = 0; iI < iSize6; iI++)
		{
			iType1 = 0;
			iType2 = 0;
			iType3 = 0;
			WRAPPER_READ(wrapper, "CvUnit", &iType1);
			WRAPPER_READ(wrapper, "CvUnit", &iType2);
			WRAPPER_READ(wrapper, "CvUnit", &iType3);
			m_aExtraVisibleImprovements[iI].eInvisible = (InvisibleTypes)iType1;
			m_aExtraVisibleImprovements[iI].eImprovement = (ImprovementTypes)iType2;
			m_aExtraVisibleImprovements[iI].iIntensity = iType3;
		}
	}

	int iSize7 = 0;
	WRAPPER_READ_DECORATED(wrapper, "CvUnit", &iSize7, "m_aExtraVisibleTerrainRanges.size");
	m_aExtraVisibleTerrainRanges.resize(iSize7);
	if (iSize7 > 0)
	{
		for (int iI = 0; iI < iSize7; iI++)
		{
			iType1 = 0;
			iType2 = 0;
			iType3 = 0;
			WRAPPER_READ(wrapper, "CvUnit", &iType1);
			WRAPPER_READ(wrapper, "CvUnit", &iType2);
			WRAPPER_READ(wrapper, "CvUnit", &iType3);
			m_aExtraVisibleTerrainRanges[iI].eInvisible = (InvisibleTypes)iType1;
			m_aExtraVisibleTerrainRanges[iI].eTerrain = (TerrainTypes)iType2;
			m_aExtraVisibleTerrainRanges[iI].iIntensity = iType3;
		}
	}

	int iSize8 = 0;
	WRAPPER_READ_DECORATED(wrapper, "CvUnit", &iSize8, "m_aExtraVisibleFeatureRanges.size");
	m_aExtraVisibleFeatureRanges.resize(iSize8);
	if (iSize8 > 0)
	{
		for (int iI = 0; iI < iSize8; iI++)
		{
			iType1 = 0;
			iType2 = 0;
			iType3 = 0;
			WRAPPER_READ(wrapper, "CvUnit", &iType1);
			WRAPPER_READ(wrapper, "CvUnit", &iType2);
			WRAPPER_READ(wrapper, "CvUnit", &iType3);
			m_aExtraVisibleFeatureRanges[iI].eInvisible = (InvisibleTypes)iType1;
			m_aExtraVisibleFeatureRanges[iI].eFeature = (FeatureTypes)iType2;
			m_aExtraVisibleFeatureRanges[iI].iIntensity = iType3;
		}
	}

	int iSize9 = 0;
	WRAPPER_READ_DECORATED(wrapper, "CvUnit", &iSize9, "m_aExtraVisibleImprovementRanges.size");
	m_aExtraVisibleImprovementRanges.resize(iSize9);
	if (iSize9 > 0)
	{
		for (int iI = 0; iI < iSize9; iI++)
		{
			iType1 = 0;
			iType2 = 0;
			iType3 = 0;
			WRAPPER_READ(wrapper, "CvUnit", &iType1);
			WRAPPER_READ(wrapper, "CvUnit", &iType2);
			WRAPPER_READ(wrapper, "CvUnit", &iType3);
			m_aExtraVisibleImprovementRanges[iI].eInvisible = (InvisibleTypes)iType1;
			m_aExtraVisibleImprovementRanges[iI].eImprovement = (ImprovementTypes)iType2;
			m_aExtraVisibleImprovementRanges[iI].iIntensity = iType3;
		}
	}
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraInsidiousness);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraInvestigation);
	WRAPPER_READ(wrapper, "CvUnit", (int*)&m_pPlayerInvestigated);
	WRAPPER_READ(wrapper, "CvUnit", &m_iAssassinCount);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraStealthStrikes);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraStealthCombatModifier);
	WRAPPER_READ(wrapper, "CvUnit", &m_iStealthDefenseCount);
	WRAPPER_READ(wrapper, "CvUnit", &m_bRevealed);
	WRAPPER_READ(wrapper, "CvUnit", &m_iOnlyDefensiveCount);
	WRAPPER_READ(wrapper, "CvUnit", &m_iNoInvisibilityCount);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraTrapDamageMax);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraTrapDamageMin);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraTrapComplexity);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraNumTriggers);
	WRAPPER_READ(wrapper, "CvUnit", &m_iNumTimesTriggered);
	WRAPPER_READ(wrapper, "CvUnit", &m_iTriggerBeforeAttackCount);
	WRAPPER_READ(wrapper, "CvUnit", &m_bIsArmed);
	WRAPPER_READ(wrapper, "CvUnit", &m_iHiddenNationalityCount);
	WRAPPER_READ(wrapper, "CvUnit", &m_iNoCaptureCount);
	int iSize10 = 0;
	WRAPPER_READ_DECORATED(wrapper, "CvUnit", &iSize10, "m_aExtraAidChanges.size");
	if (iSize10 > 0)
	{
		for (int iI = 0; iI < iSize10; iI++)
		{
			iType1 = -1;
			iType2 = 0;
			WRAPPER_READ_CLASS_ENUM_DECORATED_ALLOW_MISSING(wrapper, "CvUnit", REMAPPED_CLASS_TYPE_PROPERTIES, &iType1, "AidChange.eProperty");
			WRAPPER_READ_DECORATED(wrapper, "CvUnit", &iType2, "AidChange.iChange");

			if (iType1 != -1)
			{

				AidStruct AidChange;
				AidChange.eProperty = (PropertyTypes)iType1;
				AidChange.iChange = iType2;

				m_aExtraAidChanges.push_back(AidChange);
			}
		}
	}

	WRAPPER_READ(wrapper, "CvUnit", &m_iXOrigin);
	WRAPPER_READ(wrapper, "CvUnit", &m_iYOrigin);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraNoDefensiveBonusCount);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraGatherHerdCount);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraReligiousCombatModifier);
	WRAPPER_READ_CLASS_ENUM(wrapper, "CvUnit", REMAPPED_CLASS_TYPE_RELIGIONS, (int*)&m_eReligionType);
	WRAPPER_READ(wrapper, "CvUnit", &m_bIsReligionLocked);

	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraUpkeep100);
	WRAPPER_READ(wrapper, "CvUnit", &m_iUpkeepModifier);
	WRAPPER_READ(wrapper, "CvUnit", &m_iUpkeepMultiplierSM);
	WRAPPER_READ(wrapper, "CvUnit", &m_iUpkeep100);
	WRAPPER_READ(wrapper, "CvUnit", &m_iBuildUpTurns);

	for (int iI = GC.getNumUnitCombatInfos() - 1; iI > -1; iI--)
	{
		WRAPPER_READ_DECORATED(wrapper, "CvUnit", &g_paiTempHealUnitCombatTypeVolume[iI], "healUnitCombatTypeVolume");
		WRAPPER_READ_DECORATED(wrapper, "CvUnit", &g_paiTempHealUnitCombatTypeAdjacentVolume[iI], "healUnitCombatTypeAdjacentVolume");
		WRAPPER_READ_DECORATED(wrapper, "CvUnit", &g_paiTempTrapImmunityUnitCombatCount[iI], "trapImmunityUnitCombatCount");
		WRAPPER_READ_DECORATED(wrapper, "CvUnit", &g_paiTempTargetUnitCombatCount[iI], "targetUnitCombatCount");
		WRAPPER_READ_DECORATED(wrapper, "CvUnit", &g_paiTempExtraTrapDisableUnitCombatType[iI], "extraTrapDisableUnitCombatType");
		WRAPPER_READ_DECORATED(wrapper, "CvUnit", &g_paiTempExtraTrapAvoidanceUnitCombatType[iI], "extraTrapAvoidanceUnitCombatType");
		WRAPPER_READ_DECORATED(wrapper, "CvUnit", &g_paiTempExtraTrapTriggerUnitCombatType[iI], "extraTrapTriggerUnitCombatType");

		if (g_paiTempHealUnitCombatTypeVolume[iI] != 0
		||  g_paiTempHealUnitCombatTypeAdjacentVolume[iI] != 0
		||  g_paiTempTrapImmunityUnitCombatCount[iI] != 0
		||  g_paiTempTargetUnitCombatCount[iI] != 0
		||  g_paiTempExtraTrapDisableUnitCombatType[iI] != 0
		||  g_paiTempExtraTrapAvoidanceUnitCombatType[iI] != 0
		||  g_paiTempExtraTrapTriggerUnitCombatType[iI] != 0)
		{
			UnitCombatKeyedInfo* info = findOrCreateUnitCombatKeyedInfo((UnitCombatTypes)iI);

			info->m_iHealUnitCombatTypeVolume = g_paiTempHealUnitCombatTypeVolume[iI];
			info->m_iHealUnitCombatTypeAdjacentVolume = g_paiTempHealUnitCombatTypeAdjacentVolume[iI];
			info->m_iTrapImmunityUnitCombatCount = g_paiTempTrapImmunityUnitCombatCount[iI];
			info->m_iTargetUnitCombatCount = g_paiTempTargetUnitCombatCount[iI];
			info->m_iExtraTrapDisableUnitCombatType = g_paiTempExtraTrapDisableUnitCombatType[iI];
			info->m_iExtraTrapAvoidanceUnitCombatType = g_paiTempExtraTrapAvoidanceUnitCombatType[iI];
			info->m_iExtraTrapTriggerUnitCombatType = g_paiTempExtraTrapTriggerUnitCombatType[iI];
		}
	}
	{
		bool bCommander = false;
		WRAPPER_READ_DECORATED(wrapper, "CvUnit", &bCommander, "m_bCommander");

		if (bCommander)
		{
			int iExtraControlPoints = 0;
			int iExtraCommandRange = 0;
			short iControlPointsLeft = 0;
			WRAPPER_READ_DECORATED(wrapper, "CvUnit", &iExtraControlPoints, "m_iExtraControlPoints");
			WRAPPER_READ_DECORATED(wrapper, "CvUnit", &iExtraCommandRange, "m_iExtraCommandRange");
			WRAPPER_READ_DECORATED(wrapper, "CvUnit", &iControlPointsLeft, "m_iControlPointsLeft");

			m_commander = (
				new UnitCompCommander(
					this,
					m_pUnitInfo->getControlPoints() + iExtraControlPoints,
					iControlPointsLeft,
					m_pUnitInfo->getCommandRange() + iExtraCommandRange
				)
			);
		}
	}
	{
		bool bCommodore = false;
		WRAPPER_READ_DECORATED(wrapper, "CvUnit", &bCommodore, "m_bCommodore");

		if (bCommodore)
		{
			int iExtraControlPoints = 0;
			int iExtraCommandRange = 0;
			short iControlPointsLeft = 0;
			WRAPPER_READ_DECORATED(wrapper, "CvUnit", &iExtraControlPoints, "m_iExtraControlPoints");
			WRAPPER_READ_DECORATED(wrapper, "CvUnit", &iExtraCommandRange, "m_iExtraCommandRange");
			WRAPPER_READ_DECORATED(wrapper, "CvUnit", &iControlPointsLeft, "m_iControlPointsLeft");

			m_commodore = (
				new UnitCompCommodore(
					this,
					m_pUnitInfo->getControlPoints() + iExtraControlPoints,
					iControlPointsLeft,
					m_pUnitInfo->getCommandRange() + iExtraCommandRange
				)
			);
		}
	}
	{
		bool bWorker = false;
		WRAPPER_READ_DECORATED(wrapper, "CvUnit", &bWorker, "m_worker");

		if (bWorker)
		{
			m_worker = new UnitCompWorker();
			short iExtraWorkPercent = 0;
			int iExtraHillsWorkPercent = 0;
			int iExtraPeaksWorkPercent = 0;
			int iAssignedCity = -1;
			WRAPPER_READ_DECORATED(wrapper, "CvUnit", &iExtraWorkPercent, "m_iExtraWorkPercent");
			WRAPPER_READ_DECORATED(wrapper, "CvUnit", &iExtraHillsWorkPercent, "m_iExtraHillsWorkPercent");
			WRAPPER_READ_DECORATED(wrapper, "CvUnit", &iExtraPeaksWorkPercent, "m_iExtraPeaksWorkPercent");
			WRAPPER_READ_DECORATED(wrapper, "CvUnit", &iAssignedCity, "m_iAssignedCity");

			m_worker->changeWorkModifier(iExtraWorkPercent);
			m_worker->changeHillsWorkModifier(iExtraHillsWorkPercent + m_pUnitInfo->getHillsWorkModifier());
			m_worker->changePeaksWorkModifier(iExtraPeaksWorkPercent + m_pUnitInfo->getPeaksWorkModifier());
			m_worker->setCityAssignment(iAssignedCity);

			short iSize = 0;
			int iBuild = NO_BUILD;

			WRAPPER_READ_DECORATED(wrapper, "CvUnit", &iSize, "ExtraBuildsSize");
			for (short i = 0; i < iSize; ++i)
			{
				WRAPPER_READ_CLASS_ENUM_DECORATED(wrapper, "CvUnit", REMAPPED_CLASS_TYPE_BUILDS, &iBuild, "ExtraBuildType");

				if (iBuild != -1)
				{
					m_worker->setExtraBuild((BuildTypes)iBuild);
				}
			}

			WRAPPER_READ_DECORATED(wrapper, "CvUnit", &iSize, "ExtraWorkModForBuildsSize");
			while (iSize-- > 0)
			{
				short iMod = 0;
				WRAPPER_READ_CLASS_ENUM_DECORATED(wrapper, "CvUnit", REMAPPED_CLASS_TYPE_BUILDS, &iBuild, "ExtraWorkModForBuildType");
				WRAPPER_READ_DECORATED(wrapper, "CvUnit", &iMod, "ExtraWorkModForBuild");

				if (iBuild != NO_BUILD)
				{
					m_worker->changeExtraWorkModForBuild((BuildTypes)iBuild, iMod);
				}
			}
		}
	}

	//Example of how to skip an outdated and unnecessary save element (at least for ints and bools)
	/*WRAPPER_SKIP_ELEMENT(wrapper,"CvUnit", m_bHiddenNationality, SAVE_VALUE_ANY);*/
	WRAPPER_READ_OBJECT_END(wrapper);


	// Post Process
	if (GC.getGame().isOption(GAMEOPTION_COMBAT_SIZE_MATTERS))
	{
		setSMValues(true);
	}
	//	Zobrist characteristic hashes are not serialized so recalculate
	//	Right now it's just characteristics that affect what a unit might
	//	be able to move through that matter, so its unit class + certain promotions

	for (int iI = 0; iI < GC.getNumPromotionInfos(); iI++)
	{
		if (isHasPromotion((PromotionTypes)iI))
		{
			if (GC.getPromotionInfo((PromotionTypes)iI).changesMoveThroughPlots())
			{
				m_movementCharacteristicsHash ^= GC.getPromotionInfo((PromotionTypes)iI).getZobristValue();
			}
			// Toffer - Perhaps just as well to not store this data in the save... Mandatory recalc for one variable.
			for (int iJ = 0; iJ < GC.getPromotionInfo((PromotionTypes)iI).getNumAddsBuildTypes(); iJ++)
			{
				if ((BuildTypes)GC.getPromotionInfo((PromotionTypes)iI).getAddsBuildType(iJ) != NO_BUILD)
				{
					changeExtraBuildType(true, (BuildTypes)GC.getPromotionInfo((PromotionTypes)iI).getAddsBuildType(iJ));
				}
			}
		}
	}

	for (int iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
	{
		if (isHasUnitCombat((UnitCombatTypes)iI) && GC.getUnitCombatInfo((UnitCombatTypes)iI).changesMoveThroughPlots())
		{
			m_movementCharacteristicsHash ^= GC.getUnitCombatInfo((UnitCombatTypes)iI).getZobristValue();
		}
	}
	establishBuildups();
	if (bKill)
	{
		kill(false);
		FErrorMsg("Unit Asset removed, killing unit.");
	}
}


void CvUnit::write(FDataStreamBase* pStream)
{
	PROFILE_EXTRA_FUNC();
	CvTaggedSaveFormatWrapper&	wrapper = CvTaggedSaveFormatWrapper::getSaveFormatWrapper();

	wrapper.AttachToStream(pStream);

	WRAPPER_WRITE_OBJECT_START(wrapper);

	WRAPPER_WRITE(wrapper, "CvUnit", m_iDCMBombRange);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iDCMBombAccuracy);

	WRAPPER_WRITE(wrapper, "CvUnit", m_iID);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iGroupID);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iHotKeyNumber);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iX);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iY);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iLastMoveTurn);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iReconX);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iReconY);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iGameTurnCreated);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iDamage);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iMoves);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExperience);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iLevel);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iCargo);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iCargoCapacity);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iAttackPlotX);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iAttackPlotY);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iCombatTimer);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iCombatFirstStrikes);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iFortifyTurns);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iBlitzCount);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iAmphibCount);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iRiverCount);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iEnemyRouteCount);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iAlwaysHealCount);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iHillsDoubleMoveCount);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iCanMovePeaksCount);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iCanLeadThroughPeaksCount);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iSleepTimer);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iCommanderID);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iCommodoreID);

	WRAPPER_WRITE(wrapper, "CvUnit", m_eOriginalOwner);

	WRAPPER_WRITE(wrapper, "CvUnit", m_bAutoPromoting);
	WRAPPER_WRITE(wrapper, "CvUnit", m_bAutoUpgrading);

	WRAPPER_WRITE(wrapper, "CvUnit", m_shadowUnit.eOwner);
	WRAPPER_WRITE(wrapper, "CvUnit", m_shadowUnit.iID);

	WRAPPER_WRITE(wrapper, "CvUnit", m_iImmuneToFirstStrikesCount);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraVisibilityRange);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraMoves);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraMoveDiscount);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraAirRange);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraIntercept);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraEvasion);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraFirstStrikes);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraChanceFirstStrikes);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraWithdrawal);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraCollateralDamage);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraBombardRate);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraEnemyHeal);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraNeutralHeal);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraFriendlyHeal);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iSameTileHeal);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iAdjacentTileHeal);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraCombatPercent);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraCityAttackPercent);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraCityDefensePercent);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraHillsAttackPercent);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraHillsDefensePercent);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iRevoltProtection);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iCollateralDamageProtection);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iPillageChange);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iUpgradeDiscount);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExperiencePercent);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iKamikazePercent);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iBaseCombat);
	WRAPPER_WRITE(wrapper, "CvUnit", m_eFacingDirection);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iImmobileTimer);

	WRAPPER_WRITE(wrapper, "CvUnit", m_bMadeAttack);
	WRAPPER_WRITE(wrapper, "CvUnit", m_bMadeInterception);
	WRAPPER_WRITE(wrapper, "CvUnit", m_bPromotionReady);
	WRAPPER_WRITE(wrapper, "CvUnit", m_bDeathDelay);
	// m_bInfoBarDirty not saved...
	WRAPPER_WRITE(wrapper, "CvUnit", m_bBlockading);
	WRAPPER_WRITE(wrapper, "CvUnit", m_bAirCombat);

	WRAPPER_WRITE(wrapper, "CvUnit", m_eOwner);
	WRAPPER_WRITE(wrapper, "CvUnit", m_eCapturingPlayer);
	WRAPPER_WRITE_CLASS_ENUM(wrapper, "CvUnit", REMAPPED_CLASS_TYPE_UNITS, m_eUnitType);
	WRAPPER_WRITE_CLASS_ENUM(wrapper, "CvUnit", REMAPPED_CLASS_TYPE_UNITS, m_eLeaderUnitType);

	WRAPPER_WRITE(wrapper, "CvUnit", m_combatUnit.eOwner);
	WRAPPER_WRITE(wrapper, "CvUnit", m_combatUnit.iID);
	WRAPPER_WRITE(wrapper, "CvUnit", m_transportUnit.eOwner);
	WRAPPER_WRITE(wrapper, "CvUnit", m_transportUnit.iID);

	WRAPPER_WRITE_ARRAY(wrapper, "CvUnit", NUM_DOMAIN_TYPES, m_aiExtraDomainModifier);

	WRAPPER_WRITE_STRING(wrapper, "CvUnit", m_szName);
	WRAPPER_WRITE_STRING(wrapper, "CvUnit", m_szScriptData);

	//	Use condensed format now - only save non-default array elements
	for (int iI = 0; iI < GC.getNumPromotionInfos(); iI++)
	{
		if ( isHasPromotion((PromotionTypes)iI) )
		{
			WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", iI, "hasPromotion");
		}
	}

	for (std::map<TerrainTypes, TerrainKeyedInfo>::iterator it = m_terrainKeyedInfo.begin(), itEnd = m_terrainKeyedInfo.end(); it != itEnd; ++it)
	{
		const TerrainKeyedInfo& info = it->second;
		if (!info.Empty())
		{
			WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", it->first, "hasTerrainInfo");
			WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", info.m_iTerrainProtected, "TerrainProtected");
			WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", info.m_iTerrainDoubleMoveCount, "TerrainDoubleMove");
			WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", info.m_iExtraTerrainAttackPercent, "extraAttackPercent");
			WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", info.m_iExtraTerrainDefensePercent, "extraDefensePercent");
			WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", info.m_iExtraTerrainWorkPercent, "terrainExtraWorkPercent");
			WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", info.m_iExtraWithdrawOnTerrainType, "extraWithdrawOnTerrainType");
		}
	}
	for (std::map<FeatureTypes, FeatureKeyedInfo>::iterator it = m_featureKeyedInfo.begin(), itEnd = m_featureKeyedInfo.end(); it != itEnd; ++it)
	{
		const FeatureKeyedInfo& info = it->second;
		if (!info.Empty())
		{
			WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", it->first, "hasFeatureInfo");
			WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", info.m_iFeatureDoubleMoveCount, "FeatureDoubleMove");
			WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", info.m_iExtraFeatureAttackPercent, "extraAttackPercent");
			WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", info.m_iExtraFeatureDefensePercent, "extraDefensePercent");
			WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", info.m_iExtraFeatureWorkPercent, "featureExtraWorkPercent");
			WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", info.m_iExtraWithdrawOnFeatureType, "extraWithdrawOnFeatureType");
		}
	}
	for (iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
	{
		if (getExtraUnitCombatModifier((UnitCombatTypes)iI) != 0)
		{
			WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", iI, "hasUnitCombatInfo");
			WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", getExtraUnitCombatModifier((UnitCombatTypes)iI), "ExtraUnitCombatMod");
		}
	}

	m_Properties.writeWrapper(pStream);

	//TB Combat Mods Begin
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraPursuit);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraEarlyWithdraw);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraVSBarbs);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraArmor);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraPuncture);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraOverrun);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraRepel);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraFortRepel);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraRepelRetries);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraUnyielding);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraKnockback);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraKnockbackRetries);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iStampedeCount);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraStrAdjperRnd);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraStrAdjperAtt);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraStrAdjperDef);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraWithdrawAdjperAtt);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraUnnerve);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraEnclose);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraLunge);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraDynamicDefense);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraStrength);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iAnimalIgnoresBordersCount);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iOnslaughtCount);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraFortitude);


#ifdef OUTBREAKS_AND_AFFLICTIONS
	//	Use condensed format now - only save non-default array elements
	for (int iI = 0; iI < GC.getNumPromotionInfos(); iI++)
	{
		if ( getAfflictionHitCount((PromotionTypes)iI) != 0)
		{
			WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", iI, "hasAfflicationInfo");
			WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", getAfflictionHitCount((PromotionTypes)iI), "afflictOnAttack");
			WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", getAfflictionHitCount((PromotionTypes)iI), "cureAffliction");
			WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", getAfflictionHitCount((PromotionTypes)iI), "afflictionTurn");
			WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", getAfflictionHitCount((PromotionTypes)iI), "afflictionHit");
			WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", getAfflictionHitCount((PromotionTypes)iI), "afflictionTolerance");
			WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", getAfflictionHitCount((PromotionTypes)iI), "fortitudeModifierType");
			WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", getTrapSetWithPromotionCount((PromotionTypes)iI), "trapSetWithPromotionType");
			WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", getAfflictionHitCount((PromotionTypes)iI), "promotionFromTraitCount");
		}
	}
#endif
	WRAPPER_WRITE(wrapper, "CvUnit", m_iRoundCount);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iAttackCount);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iDefenseCount);

#ifdef STRENGTH_IN_NUMBERS
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraFrontSupportPercent);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraShortRangeSupportPercent);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraMediumRangeSupportPercent);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraLongRangeSupportPercent);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraFlankSupportPercent);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iSupportCount);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iAttackFromPlotX);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iAttackFromPlotY);
	WRAPPER_WRITE(wrapper, "CvUnit", afIUnit.eOwner);
	WRAPPER_WRITE(wrapper, "CvUnit", afIUnit.iID);
	WRAPPER_WRITE(wrapper, "CvUnit", afIIUnit.eOwner);
	WRAPPER_WRITE(wrapper, "CvUnit", afIIUnit.iID);
	WRAPPER_WRITE(wrapper, "CvUnit", asrIUnit.eOwner);
	WRAPPER_WRITE(wrapper, "CvUnit", asrIUnit.iID);
	WRAPPER_WRITE(wrapper, "CvUnit", asrIIUnit.eOwner);
	WRAPPER_WRITE(wrapper, "CvUnit", asrIIUnit.iID);
	WRAPPER_WRITE(wrapper, "CvUnit", amrIUnit.eOwner);
	WRAPPER_WRITE(wrapper, "CvUnit", amrIUnit.iID);
	WRAPPER_WRITE(wrapper, "CvUnit", amrIIUnit.eOwner);
	WRAPPER_WRITE(wrapper, "CvUnit", amrIIUnit.iID);
	WRAPPER_WRITE(wrapper, "CvUnit", alrIUnit.eOwner);
	WRAPPER_WRITE(wrapper, "CvUnit", alrIUnit.iID);
	WRAPPER_WRITE(wrapper, "CvUnit", alrIIUnit.eOwner);
	WRAPPER_WRITE(wrapper, "CvUnit", alrIIUnit.iID);
	WRAPPER_WRITE(wrapper, "CvUnit", aflIUnit.eOwner);
	WRAPPER_WRITE(wrapper, "CvUnit", aflIUnit.iID);
	WRAPPER_WRITE(wrapper, "CvUnit", aflIIUnit.eOwner);
	WRAPPER_WRITE(wrapper, "CvUnit", aflIIUnit.iID);
	WRAPPER_WRITE(wrapper, "CvUnit", dfIUnit.eOwner);
	WRAPPER_WRITE(wrapper, "CvUnit", dfIUnit.iID);
	WRAPPER_WRITE(wrapper, "CvUnit", dfIIUnit.eOwner);
	WRAPPER_WRITE(wrapper, "CvUnit", dfIIUnit.iID);
	WRAPPER_WRITE(wrapper, "CvUnit", dsrIUnit.eOwner);
	WRAPPER_WRITE(wrapper, "CvUnit", dsrIUnit.iID);
	WRAPPER_WRITE(wrapper, "CvUnit", dsrIIUnit.eOwner);
	WRAPPER_WRITE(wrapper, "CvUnit", dsrIIUnit.iID);
	WRAPPER_WRITE(wrapper, "CvUnit", dmrIUnit.eOwner);
	WRAPPER_WRITE(wrapper, "CvUnit", dmrIUnit.iID);
	WRAPPER_WRITE(wrapper, "CvUnit", dmrIIUnit.eOwner);
	WRAPPER_WRITE(wrapper, "CvUnit", dmrIIUnit.iID);
	WRAPPER_WRITE(wrapper, "CvUnit", dlrIUnit.eOwner);
	WRAPPER_WRITE(wrapper, "CvUnit", dlrIUnit.iID);
	WRAPPER_WRITE(wrapper, "CvUnit", dlrIIUnit.eOwner);
	WRAPPER_WRITE(wrapper, "CvUnit", dlrIIUnit.iID);
	WRAPPER_WRITE(wrapper, "CvUnit", dflIUnit.eOwner);
	WRAPPER_WRITE(wrapper, "CvUnit", dflIUnit.iID);
	WRAPPER_WRITE(wrapper, "CvUnit", dflIIUnit.eOwner);
	WRAPPER_WRITE(wrapper, "CvUnit", dflIIUnit.iID);
#endif // STRENGTH_IN_NUMBERS


	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraDodgeModifier);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraPrecisionModifier);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraPowerShots);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraPowerShotCombatModifier);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraPowerShotPunctureModifier);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraPowerShotPrecisionModifier);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraPowerShotCriticalModifier);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraCriticalModifier);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraEndurance);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iColdDamage);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iDealColdDamageCount);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iColdImmuneCount);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iCombatPowerShots);

	//	Use condensed format now - only save non-default array elements
	for (int iI = 0; iI < GC.getNumPromotionInfos(); iI++)
	{
		if (getPromotionFreeCount((PromotionTypes)iI) != 0)
		{
			WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", iI, "hasFreePromotionCount");
			WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", getPromotionFreeCount((PromotionTypes)iI), "FreePromoCount");
		}
	}

	WRAPPER_WRITE(wrapper, "CvUnit", m_iCombatKnockbacks);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iCombatRepels);

	//	Use condensed format now - only save non-default array elements
	for (int iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
	{
		if (getExtraFlankingStrengthbyUnitCombatType((UnitCombatTypes)iI) != 0)
		{
			WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", iI, "hasUnitCombatInfo5");
			WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", getExtraFlankingStrengthbyUnitCombatType((UnitCombatTypes)iI), "extraFlankingStrengthbyUnitCombatType");
		}
	}

	//	Use condensed format now - only save non-default array elements
	for (int iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
	{
		if (getExtraWithdrawVSUnitCombatType((UnitCombatTypes)iI) != 0)
		{
			WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", iI, "hasUnitCombatInfo6");
			WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", getExtraWithdrawVSUnitCombatType((UnitCombatTypes)iI), "extraWithdrawVSUnitCombatType");
		}
	}

	//	Use condensed format now - only save non-default array elements
	for (int iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
	{
		if (getExtraRepelVSUnitCombatType((UnitCombatTypes)iI) != 0)
		{
			WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", iI, "hasUnitCombatInfo7");
			WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", getExtraRepelVSUnitCombatType((UnitCombatTypes)iI), "extraRepelVSUnitCombatType");
		}
	}

	//	Use condensed format now - only save non-default array elements
	for (int iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
	{
		if (getExtraKnockbackVSUnitCombatType((UnitCombatTypes)iI) != 0)
		{
			WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", iI, "hasUnitCombatInfo8");
			WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", getExtraKnockbackVSUnitCombatType((UnitCombatTypes)iI), "extraKnockbackVSUnitCombatType");
		}
	}

	//	Use condensed format now - only save non-default array elements
	for (int iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
	{
		if (getExtraPunctureVSUnitCombatType((UnitCombatTypes)iI) != 0)
		{
			WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", iI, "hasUnitCombatInfo9");
			WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", getExtraPunctureVSUnitCombatType((UnitCombatTypes)iI), "extraPunctureVSUnitCombatType");
		}
	}

	//	Use condensed format now - only save non-default array elements
	for (int iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
	{
		if (getExtraArmorVSUnitCombatType((UnitCombatTypes)iI) != 0)
		{
			WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", iI, "hasUnitCombatInfo10");
			WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", getExtraArmorVSUnitCombatType((UnitCombatTypes)iI), "extraArmorVSUnitCombatType");
		}
	}

	//	Use condensed format now - only save non-default array elements
	for (int iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
	{
		if (getExtraDodgeVSUnitCombatType((UnitCombatTypes)iI) != 0)
		{
			WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", iI, "hasUnitCombatInfo11");
			WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", getExtraDodgeVSUnitCombatType((UnitCombatTypes)iI), "extraDodgeVSUnitCombatType");
		}
	}

	//	Use condensed format now - only save non-default array elements
	for (int iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
	{
		if (getExtraPrecisionVSUnitCombatType((UnitCombatTypes)iI) != 0)
		{
			WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", iI, "hasUnitCombatInfo12");
			WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", getExtraPrecisionVSUnitCombatType((UnitCombatTypes)iI), "extraPrecisionVSUnitCombatType");
		}
	}

	//	Use condensed format now - only save non-default array elements
	for (int iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
	{
		if (getExtraCriticalVSUnitCombatType((UnitCombatTypes)iI) != 0)
		{
			WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", iI, "hasUnitCombatInfo13");
			WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", getExtraCriticalVSUnitCombatType((UnitCombatTypes)iI), "extraCriticalVSUnitCombatType");
		}
	}

	//	Use condensed format now - only save non-default array elements
	for (int iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
	{
		if (getExtraRoundStunVSUnitCombatType((UnitCombatTypes)iI) != 0)
		{
			WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", iI, "hasUnitCombatInfo14");
			WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", getExtraRoundStunVSUnitCombatType((UnitCombatTypes)iI), "extraRoundStunVSUnitCombatType");
		}
	}
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraRoundStunProb);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iCombatStuns);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraPoisonProbabilityModifier);

#ifdef OUTBREAKS_AND_AFFLICTIONS
	//	Use condensed format now - only save non-default array elements
	for (int iI = 0; iI < GC.getNumPromotionLineInfos(); iI++)
	{
		if ( getAfflictOnAttackTypeProbability((PromotionLineTypes)iI) != 0 ||
			 getAfflictOnAttackTypeCount((PromotionLineTypes)iI) != 0 ||
			 getAfflictOnAttackTypeImmediateCount((PromotionLineTypes)iI) != 0 ||
			 getAfflictOnAttackTypeAttemptedCount((PromotionLineTypes)iI) != 0 ||
			 getCureAfflictionCount((PromotionLineTypes)iI) != 0 ||
			 getAfflictionTurnCount((PromotionLineTypes)iI) != 0 ||
			 getAfflictionLineCount((PromotionLineTypes)iI) != 0 ||
			 getUnitAfflictionTolerance((PromotionLineTypes)iI) != 0 ||
			 getFortitudeModifierTypeAmount((PromotionLineTypes)iI) != 0)
		{
			WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", iI, "hasAfflictOnAttackInfo");
			WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", getAfflictOnAttackTypeProbability((PromotionLineTypes)iI), "afflictOnAttackTypeProb");
			WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", getAfflictOnAttackTypeCount((PromotionLineTypes)iI), "afflictOnAttackTypeCount");
			WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", getAfflictOnAttackTypeImmediateCount((PromotionLineTypes)iI), "afflictOnAttackTypeImmediateCount");
			WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", getAfflictOnAttackTypeAttemptedCount((PromotionLineTypes)iI), "afflictOnAttackTypeAttemptedCount");
			WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", getCureAfflictionCount((PromotionLineTypes)iI), "cureAfflictionType");
			WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", getAfflictionTurnCount((PromotionLineTypes)iI), "afflictionTurnType");
			WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", getAfflictionLineCount((PromotionLineTypes)iI), "hasAfflictionLine");
			WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", getUnitAfflictionTolerance((PromotionLineTypes)iI), "afflictionToleranceType");
			WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", getFortitudeModifierTypeAmount((PromotionLineTypes)iI), "fortitudeModifier");
		}
	}
#endif
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraAttackCombatModifier);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraDefenseCombatModifier);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iRetrainsAvailable);
	//TB Combat Mods end

	WRAPPER_WRITE(wrapper, "CvUnit", m_iDefensiveVictoryMoveCount);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iFreeDropCount);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iOffensiveVictoryMoveCount);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iPillageCultureCount);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iPillageEspionageCount);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iPillageMarauderCount);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iPillageOnMoveCount);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iPillageOnVictoryCount);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iPillageResearchCount);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iAirCombatLimitChange);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iCelebrityHappy);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iCollateralDamageLimitChange);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iCollateralDamageMaxUnitsChange);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iCombatLimitChange);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraDropRange);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iVictoryHeal);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iOneUpCount);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iSurvivorChance);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iVictoryAdjacentHeal);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iVictoryStackHeal);
	WRAPPER_WRITE(wrapper, "CvUnit", m_bSurvivor);

	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraCaptureProbabilityModifier);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraCaptureResistanceModifier);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraBreakdownChance);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraBreakdownDamage);

	//	Use condensed format now - only save non-default array elements
	for (int iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
	{
		if ( isHasUnitCombat((UnitCombatTypes)iI) )
		{
			WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", iI, "hasUnitCombat");
		}
	}
	WRAPPER_WRITE(wrapper, "CvUnit", m_iAttackOnlyCitiesCount);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iIgnoreNoEntryLevelCount);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iIgnoreZoneofControlCount);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraTaunt);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraMaxHP);


	//	Use condensed format now - only save non-default array elements
	for (int iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
	{
		if ( getExtraPursuitVSUnitCombatType((UnitCombatTypes)iI) != 0 )
		{
			WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", iI, "hasUnitCombatInfo15");
			WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", getExtraPursuitVSUnitCombatType((UnitCombatTypes)iI), "extraPursuitVSUnitCombatType");
		}
	}
	WRAPPER_WRITE(wrapper, "CvUnit", m_iFliesToMoveCount);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iQualityBaseTotal);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iGroupBaseTotal);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iSizeBaseTotal);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iCannotMergeSplitCount);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraStrengthModifier);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraDamageModifier);
	WRAPPER_WRITE_CLASS_ENUM(wrapper, "CvUnit", REMAPPED_CLASS_TYPE_UNITS, m_eGGExperienceEarnedTowardsType);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iSMCargo);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iSMCargoCapacity);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iSMCargoVolume);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iSMCargoVolumeModifier);
	WRAPPER_WRITE(wrapper, "CvUnit", m_eNewDomainCargo);
	WRAPPER_WRITE_CLASS_ENUM(wrapper, "CvUnit", REMAPPED_CLASS_TYPE_SPECIAL_UNITS, m_eNewSpecialCargo);
	WRAPPER_WRITE_CLASS_ENUM(wrapper, "CvUnit", REMAPPED_CLASS_TYPE_SPECIAL_UNITS, m_eNewSMNotSpecialCargo);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraQuality);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraGroup);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraSize);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iSMStrength);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iSMAssetValue);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iSMPowerValue);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iSMHPValue);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iSMExtraCargoVolume);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iSMBombardRate);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iSMAirBombBaseRate);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iSMBaseWorkRate);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iSMRevoltProtection);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraRBombardDamage);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraRBombardDamageLimit);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraRBombardDamageMaxUnits);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraDCMBombRange);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraDCMBombAccuracy);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iBaseRBombardDamage);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iBaseRBombardDamageLimit);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iBaseRBombardDamageMaxUnits);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iBaseDCMBombRange);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iBaseDCMBombAccuracy);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iBombardDirectCount);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iRBombardForceAbilityCount);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraCombatModifierPerSizeMore);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraCombatModifierPerSizeLess);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraCombatModifierPerVolumeMore);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraCombatModifierPerVolumeLess);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iAlwaysInvisibleCount);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iHealUnitCombatCount);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraSelfHealModifier);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iNoSelfHealCount);
	for (int iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
	{
		if ( getHealAsDamage((UnitCombatTypes)iI) != 0 )
		{
			WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", iI, "healAsDamageInfo");
			WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", getHealAsDamage((UnitCombatTypes)iI), "healAsDamage");
		}
	}

	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraNumHealSupport);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iHealSupportUsed);
	WRAPPER_WRITE_CLASS_ENUM(wrapper, "CvUnit", REMAPPED_CLASS_TYPE_MISSIONS, m_eSleepType);
	WRAPPER_WRITE(wrapper, "CvUnit", m_bHasBuildUp);
	WRAPPER_WRITE_CLASS_ENUM(wrapper, "CvUnit", REMAPPED_CLASS_TYPE_PROMOTIONLINES, m_eCurrentBuildUpType);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iZoneOfControlCount);
	WRAPPER_WRITE(wrapper, "CvUnit", m_bInhibitMerge);
	WRAPPER_WRITE(wrapper, "CvUnit", m_bInhibitSplit);
	WRAPPER_WRITE(wrapper, "CvUnit", m_bIsBuildUp);
	WRAPPER_WRITE_CLASS_ENUM(wrapper, "CvUnit", REMAPPED_CLASS_TYPE_SPECIAL_UNITS, m_eSpecialUnit);
	//WRAPPER_WRITE(wrapper, "CvUnit", m_bHiddenNationality);
	WRAPPER_WRITE(wrapper, "CvUnit", m_bHasHNCapturePromotion);
	WRAPPER_WRITE(wrapper, "CvUnit", m_eCapturingUnit.eOwner);
	WRAPPER_WRITE(wrapper, "CvUnit", m_eCapturingUnit.iID);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExcileCount);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iPassageCount);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iNoNonOwnedCityEntryCount);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iBarbCoExistCount);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iBlendIntoCityCount);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iUpgradeAnywhereCount);
	//	Use condensed format now - only save non-default array elements
	for (int iI = 0; iI < GC.getNumInvisibleInfos(); iI++)
	{
		if ( m_aiExtraVisibilityIntensity[iI] != 0 ||
			m_aiExtraInvisibilityIntensity[iI] != 0 ||
			m_aiExtraVisibilityIntensityRange[iI] != 0 ||
			m_aiNegatesInvisibleCount[iI] != 0 ||
			m_aiExtraVisibilityIntensitySameTile[iI] != 0)
		{
			WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", iI, "Visibilities");
			WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", m_aiExtraVisibilityIntensity[iI], "extraVisibilityIntensity");
			WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", m_aiExtraInvisibilityIntensity[iI], "extraInvisibilityIntensity");
			WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", m_aiExtraVisibilityIntensityRange[iI], "extraVisibilityIntensityRange");
			WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", m_aiNegatesInvisibleCount[iI], "negatesInvisibleCount");
			WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", m_aiExtraVisibilityIntensitySameTile[iI], "extraVisibilityIntensitySameTile");
		}
	}
	WRAPPER_WRITE(wrapper, "CvUnit", m_bHasAnyInvisibility);

	int iType1 = 0;
	int iType2 = 0;
	int iType3 = 0;

	int iSize1 = (int)m_aExtraInvisibleTerrains.size();
	WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", iSize1, "m_aExtraInvisibleTerrains.size");
	if (iSize1 > 0)
	{
		for (iI = 0; iI < iSize1; iI++)
		{
			iType1 = (int)m_aExtraInvisibleTerrains[iI].eInvisible;
			iType2 = (int)m_aExtraInvisibleTerrains[iI].eTerrain;
			iType3 = m_aExtraInvisibleTerrains[iI].iIntensity;
			WRAPPER_WRITE(wrapper, "CvUnit", iType1);
			WRAPPER_WRITE(wrapper, "CvUnit", iType2);
			WRAPPER_WRITE(wrapper, "CvUnit", iType3);
		}
	}

	int iSize2 = (int)m_aExtraInvisibleFeatures.size();
	WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", iSize2, "m_aExtraInvisibleFeatures.size");
	if (iSize2 > 0)
	{
		for (iI = 0; iI < iSize2; iI++)
		{
			iType1 = (int)m_aExtraInvisibleFeatures[iI].eInvisible;
			iType2 = (int)m_aExtraInvisibleFeatures[iI].eFeature;
			iType3 = m_aExtraInvisibleFeatures[iI].iIntensity;
			WRAPPER_WRITE(wrapper, "CvUnit", iType1);
			WRAPPER_WRITE(wrapper, "CvUnit", iType2);
			WRAPPER_WRITE(wrapper, "CvUnit", iType3);
		}
	}

	int iSize3 = (int)m_aExtraInvisibleImprovements.size();
	WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", iSize3, "m_aExtraInvisibleImprovements.size");
	if (iSize3 > 0)
	{
		for (iI = 0; iI < iSize3; iI++)
		{
			iType1 = (int)m_aExtraInvisibleImprovements[iI].eInvisible;
			iType2 = (int)m_aExtraInvisibleImprovements[iI].eImprovement;
			iType3 = m_aExtraInvisibleImprovements[iI].iIntensity;
			WRAPPER_WRITE(wrapper, "CvUnit", iType1);
			WRAPPER_WRITE(wrapper, "CvUnit", iType2);
			WRAPPER_WRITE(wrapper, "CvUnit", iType3);
		}
	}

	int iSize4 = (int)m_aExtraVisibleTerrains.size();
	WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", iSize4, "m_aExtraVisibleTerrains.size");
	if (iSize4 > 0)
	{
		for (iI = 0; iI < iSize4; iI++)
		{
			iType1 = (int)m_aExtraVisibleTerrains[iI].eInvisible;
			iType2 = (int)m_aExtraVisibleTerrains[iI].eTerrain;
			iType3 = m_aExtraVisibleTerrains[iI].iIntensity;
			WRAPPER_WRITE(wrapper, "CvUnit", iType1);
			WRAPPER_WRITE(wrapper, "CvUnit", iType2);
			WRAPPER_WRITE(wrapper, "CvUnit", iType3);
		}
	}

	int iSize5 = (int)m_aExtraVisibleFeatures.size();
	WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", iSize5, "m_aExtraVisibleFeatures.size");
	if (iSize5 > 0)
	{
		for (iI = 0; iI < iSize5; iI++)
		{
			iType1 = (int)m_aExtraVisibleFeatures[iI].eInvisible;
			iType2 = (int)m_aExtraVisibleFeatures[iI].eFeature;
			iType3 = m_aExtraVisibleFeatures[iI].iIntensity;
			WRAPPER_WRITE(wrapper, "CvUnit", iType1);
			WRAPPER_WRITE(wrapper, "CvUnit", iType2);
			WRAPPER_WRITE(wrapper, "CvUnit", iType3);
		}
	}

	int iSize6 = (int)m_aExtraVisibleImprovements.size();
	WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", iSize6, "m_aExtraVisibleImprovements.size");
	if (iSize6 > 0)
	{
		for (iI = 0; iI < iSize6; iI++)
		{
			iType1 = (int)m_aExtraVisibleImprovements[iI].eInvisible;
			iType2 = (int)m_aExtraVisibleImprovements[iI].eImprovement;
			iType3 = m_aExtraVisibleImprovements[iI].iIntensity;
			WRAPPER_WRITE(wrapper, "CvUnit", iType1);
			WRAPPER_WRITE(wrapper, "CvUnit", iType2);
			WRAPPER_WRITE(wrapper, "CvUnit", iType3);
		}
	}

	int iSize7 = (int)m_aExtraVisibleTerrainRanges.size();
	WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", iSize7, "m_aExtraVisibleTerrainRanges.size");
	if (iSize7 > 0)
	{
		for (iI = 0; iI < iSize7; iI++)
		{
			iType1 = (int)m_aExtraVisibleTerrainRanges[iI].eInvisible;
			iType2 = (int)m_aExtraVisibleTerrainRanges[iI].eTerrain;
			iType3 = m_aExtraVisibleTerrainRanges[iI].iIntensity;
			WRAPPER_WRITE(wrapper, "CvUnit", iType1);
			WRAPPER_WRITE(wrapper, "CvUnit", iType2);
			WRAPPER_WRITE(wrapper, "CvUnit", iType3);
		}
	}

	int iSize8 = (int)m_aExtraVisibleFeatureRanges.size();
	WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", iSize8, "m_aExtraVisibleFeatureRanges.size");
	if (iSize8 > 0)
	{
		for (iI = 0; iI < iSize8; iI++)
		{
			iType1 = (int)m_aExtraVisibleFeatureRanges[iI].eInvisible;
			iType2 = (int)m_aExtraVisibleFeatureRanges[iI].eFeature;
			iType3 = m_aExtraVisibleFeatureRanges[iI].iIntensity;
			WRAPPER_WRITE(wrapper, "CvUnit", iType1);
			WRAPPER_WRITE(wrapper, "CvUnit", iType2);
			WRAPPER_WRITE(wrapper, "CvUnit", iType3);
		}
	}

	int iSize9 = (int)m_aExtraVisibleImprovementRanges.size();
	WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", iSize9, "m_aExtraVisibleImprovementRanges.size");
	if (iSize9 > 0)
	{
		for (iI = 0; iI < iSize9; iI++)
		{
			iType1 = (int)m_aExtraVisibleImprovementRanges[iI].eInvisible;
			iType2 = (int)m_aExtraVisibleImprovementRanges[iI].eImprovement;
			iType3 = m_aExtraVisibleImprovementRanges[iI].iIntensity;
			WRAPPER_WRITE(wrapper, "CvUnit", iType1);
			WRAPPER_WRITE(wrapper, "CvUnit", iType2);
			WRAPPER_WRITE(wrapper, "CvUnit", iType3);
		}
	}

	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraInsidiousness);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraInvestigation);
	WRAPPER_WRITE(wrapper, "CvUnit", (int)m_pPlayerInvestigated);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iAssassinCount);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraStealthStrikes);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraStealthCombatModifier);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iStealthDefenseCount);
	WRAPPER_WRITE(wrapper, "CvUnit", m_bRevealed);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iOnlyDefensiveCount);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iNoInvisibilityCount);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraTrapDamageMax);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraTrapDamageMin);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraTrapComplexity);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraNumTriggers);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iNumTimesTriggered);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iTriggerBeforeAttackCount);
	WRAPPER_WRITE(wrapper, "CvUnit", m_bIsArmed);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iHiddenNationalityCount);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iNoCaptureCount);

	int iSize10 = (int)m_aExtraAidChanges.size();
	WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", iSize10, "m_aExtraAidChanges.size");
	if (iSize10 > 0)
	{
		for (iI = 0; iI < iSize10; iI++)
		{
			iType1 = m_aExtraAidChanges[iI].eProperty;
			iType2 = m_aExtraAidChanges[iI].iChange;
			WRAPPER_WRITE_CLASS_ENUM_DECORATED(wrapper, "CvUnit", REMAPPED_CLASS_TYPE_PROPERTIES, iType1, "AidChange.eProperty");
			WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", iType2, "AidChange.iChange");
		}
	}
	WRAPPER_WRITE(wrapper, "CvUnit", m_iXOrigin);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iYOrigin);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraNoDefensiveBonusCount);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraGatherHerdCount);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraReligiousCombatModifier);
	WRAPPER_WRITE_CLASS_ENUM(wrapper, "CvUnit", REMAPPED_CLASS_TYPE_RELIGIONS, m_eReligionType);
	WRAPPER_WRITE(wrapper, "CvUnit", m_bIsReligionLocked);

	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraUpkeep100);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iUpkeepModifier);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iUpkeepMultiplierSM);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iUpkeep100);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iBuildUpTurns);

	for (int iI = GC.getNumUnitCombatInfos() - 1; iI > -1; iI--)
	{
		const UnitCombatKeyedInfo* info = findUnitCombatKeyedInfo(static_cast<UnitCombatTypes>(iI));

		WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", info ? info->m_iHealUnitCombatTypeVolume : 0, "healUnitCombatTypeVolume");
		WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", info ? info->m_iHealUnitCombatTypeAdjacentVolume : 0, "healUnitCombatTypeAdjacentVolume");
		WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", info ? info->m_iTrapImmunityUnitCombatCount : 0, "trapImmunityUnitCombatCount");
		WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", info ? info->m_iTargetUnitCombatCount : 0, "targetUnitCombatCount");
		WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", info ? info->m_iExtraTrapDisableUnitCombatType : 0, "extraTrapDisableUnitCombatType");
		WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", info ? info->m_iExtraTrapAvoidanceUnitCombatType : 0, "extraTrapAvoidanceUnitCombatType");
		WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", info ? info->m_iExtraTrapTriggerUnitCombatType : 0, "extraTrapTriggerUnitCombatType");
	}

	WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", isCommander(), "m_bCommander");
	if (m_commander)
	{
		WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", m_commander->getControlPoints() - m_pUnitInfo->getControlPoints(), "m_iExtraControlPoints");
		WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", m_commander->getCommandRange() - m_pUnitInfo->getCommandRange(), "m_iExtraCommandRange");
		WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", m_commander->getControlPointsLeft(), "m_iControlPointsLeft");
	}

	WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", isCommodore(), "m_bCommodore");
    	if (m_commodore)
    	{
    		WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", m_commodore->getControlPoints() - m_pUnitInfo->getControlPoints(), "m_iExtraControlPoints");
    		WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", m_commodore->getCommandRange() - m_pUnitInfo->getCommandRange(), "m_iExtraCommandRange");
    		WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", m_commodore->getControlPointsLeft(), "m_iControlPointsLeft");
    	}

	WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", isWorker(), "m_worker");
	if (m_worker)
	{
		WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", m_worker->getWorkModifier(), "m_iExtraWorkPercent");
		WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", m_worker->getHillsWorkModifier() - m_pUnitInfo->getHillsWorkModifier(), "m_iExtraHillsWorkPercent");
		WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", m_worker->getPeaksWorkModifier() - m_pUnitInfo->getPeaksWorkModifier(), "m_iExtraPeaksWorkPercent");
		WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", m_worker->getAssignedCity(), "m_iAssignedCity");

		const std::vector<BuildTypes>& extraBuilds = m_worker->getExtraBuilds();
		WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", (short)extraBuilds.size(), "ExtraBuildsSize");

		for (int i = extraBuilds.size() - 1; i > -1; i--)
		{
			WRAPPER_WRITE_CLASS_ENUM_DECORATED(wrapper, "CvUnit", REMAPPED_CLASS_TYPE_BUILDS, extraBuilds[i], "ExtraBuildType");
		}

		std::map<BuildTypes, short> extraWorkModForBuilds = m_worker->getExtraWorkModForBuilds();
		WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", (short)extraWorkModForBuilds.size(), "ExtraWorkModForBuildsSize");

		for (std::map<BuildTypes, short>::const_iterator it = extraWorkModForBuilds.begin(), itEnd = extraWorkModForBuilds.end(); it != itEnd; ++it)
		{
			WRAPPER_WRITE_CLASS_ENUM_DECORATED(wrapper, "CvUnit", REMAPPED_CLASS_TYPE_BUILDS, it->first, "ExtraWorkModForBuildType");
			WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", it->second, "ExtraWorkModForBuild");
		}
	}

	WRAPPER_WRITE_OBJECT_END(wrapper);
}

// Protected Functions...

bool CvUnit::canAdvance(const CvPlot* pPlot, int iThreshold) const
{
	FAssert(canFight());
	//TB Combat Mod next line
	FAssert(!isAnimal() || canAnimalIgnoresBorders() || !pPlot->isCity());
	FAssert(getDomainType() != DOMAIN_AIR);
	FAssert(getDomainType() != DOMAIN_IMMOBILE);

	if (pPlot->getNumVisiblePotentialEnemyDefenders(this) > iThreshold)
	{
		return false;
	}
	return true;
}


void CvUnit::collateralCombat(const CvPlot* pPlot, CvUnit* pSkipUnit)
{
	PROFILE_EXTRA_FUNC();
	const int iCollateralStrength = (getDomainType() == DOMAIN_AIR ? airBaseCombatStr() : baseCombatStr()) * collateralDamage() / 100;

	if (iCollateralStrength == 0)
	{
		return;
	}
	std::map<CvUnit*, int> mapUnitDamage;
	std::map<CvUnit*, int>::iterator it;

	const int iPossibleTargets = std::min((pPlot->getNumVisiblePotentialEnemyDefenders(this) - 1), collateralDamageMaxUnits());

	foreach_(CvUnit* pLoopUnit, pPlot->units())
	{
		if (pLoopUnit != pSkipUnit
		&& isEnemy(pLoopUnit->getTeam(), pPlot, pLoopUnit)
		&& !pLoopUnit->isInvisible(getTeam(), false)
		&& pLoopUnit->canDefend())
		{
			mapUnitDamage[pLoopUnit] = pLoopUnit->getHP() * (1 + GC.getGame().getSorenRandNum(10000, "Collateral Damage"));
		}
	}

	CvCity* pCity = NULL;
	if (getDomainType() == DOMAIN_AIR)
	{
		pCity = pPlot->getPlotCity();
	}
	int iDamageCount = 0;
	int iCount = 0;

	while (iCount < iPossibleTargets)
	{
		int iBestValue = 0;
		CvUnit* pBestUnit = NULL;

		for (it = mapUnitDamage.begin(); it != mapUnitDamage.end(); ++it)
		{
			if (it->second > iBestValue)
			{
				iBestValue = it->second;
				pBestUnit = it->first;
			}
		}

		if (pBestUnit == NULL)
		{
			break;
		}
		mapUnitDamage.erase(pBestUnit);
		//TB SubCombat Mod Begin
		int iI;
		UnitCombatTypes eUnitCombatType;
		bool isCollateralImmune = false;

		for (iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
		{
			if (/*pBestUnit->*/isHasUnitCombat((UnitCombatTypes)iI))
			{
				eUnitCombatType = ((UnitCombatTypes)iI);
				if (pBestUnit->getUnitInfo().getUnitCombatCollateralImmune(eUnitCombatType))
				{
					isCollateralImmune = true;
				}
			}
		}
		//TB SubCombat Mod End (with the exception of the following reference to 'isCollateralImmune'
		if (!isCollateralImmune)
		{
			const int iTheirStrength = pBestUnit->baseCombatStr();
			const int iStrengthFactor = (iCollateralStrength + iTheirStrength + 1) / 2;

			int iCollateralDamage = 100 * GC.getDefineINT("COLLATERAL_COMBAT_DAMAGE");

			iCollateralDamage *= iStrengthFactor + iCollateralStrength;
			iCollateralDamage /= iStrengthFactor + iTheirStrength;

			iCollateralDamage -= std::min(100, std::max(0, pBestUnit->getCollateralDamageProtection())) * iCollateralDamage / 100;
			iCollateralDamage = std::max(0, iCollateralDamage);
			//TB Combat Mods end

			if (pCity != NULL)
			{
				iCollateralDamage *= 100 + pCity->getAirModifier();
				iCollateralDamage /= 100;
			}

			iCollateralDamage /= 100;

			//TB note: Armor should be checked against the puncture of the attacker (with the weapon in use) and act as a value that diminishes the damage if any armor is left
			//TB note: A dodge check should also be made (% check) to see if the defender evades the random blast or scattered sources of damage coming at him (entirely - all or nothing).

			iCollateralDamage = std::max(0, iCollateralDamage);

			const int iMaxDamage = std::min(collateralDamageLimit(), (collateralDamageLimit() * (iCollateralStrength + iStrengthFactor)) / (iTheirStrength + iStrengthFactor));
			const int iUnitDamage = std::max(pBestUnit->getDamage(), std::min(pBestUnit->getDamage() + iCollateralDamage, iMaxDamage));

			if (pBestUnit->getDamage() != iUnitDamage)
			{
// BUG - Combat Events - start
				int iDamageDone = iUnitDamage - pBestUnit->getDamage();
				pBestUnit->setDamage(iUnitDamage, getOwner());
				//TB Combat Mod begin
				if (dealsColdDamage())
				{
					pBestUnit->setColdDamage(iUnitDamage);
				}
				//TB Combat Mod end
				CvEventReporter::getInstance().combatLogCollateral(this, pBestUnit, iDamageDone);
// BUG - Combat Events - end
				iDamageCount++;
			}
		}
		iCount++;
	}

	if (iDamageCount > 0)
	{
		AddDLLMessage(
			pSkipUnit->getOwner(), pSkipUnit->getDomainType() != DOMAIN_AIR, GC.getEVENT_MESSAGE_TIME(),
			gDLL->getText("TXT_KEY_MISC_YOU_SUFFER_COL_DMG", iDamageCount), "AS2D_COLLATERAL",
			MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_RED(), pSkipUnit->getX(), pSkipUnit->getY(), true, true
		);
		AddDLLMessage(
			getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
			gDLL->getText("TXT_KEY_MISC_YOU_INFLICT_COL_DMG", getNameKey(), iDamageCount),
			"AS2D_COLLATERAL", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_GREEN(), pSkipUnit->getX(), pSkipUnit->getY()
		);
	}
}

void CvUnit::rBombardCombat(const CvPlot* pPlot, CvUnit* pFirstUnit)
{
	PROFILE_EXTRA_FUNC();
	const int iRBombardStrength = (getDomainType() == DOMAIN_AIR ? airBaseCombatStr() : baseCombatStr()) * rBombardDamage() / 100;

	if (iRBombardStrength == 0)
	{
		return;
	}
	CvCity* pCity = pPlot->getPlotCity();

	const int iPossibleTargets = std::min(pPlot->getNumVisiblePotentialEnemyDefenders(this), rBombardDamageMaxUnits());

#ifdef OUTBREAKS_AND_AFFLICTIONS
	int iDistanceAttackCommunicability = 0;
	std::vector<int> m_iAfflictionIndex;
	bool bAffliction = false;
	if (GC.getGame().isOption(GAMEOPTION_COMBAT_OUTBREAKS_AND_AFFLICTIONS))
	{
		for (int iI = 0; iI < GC.getNumPromotionLineInfos(); iI++)
		{
			iDistanceAttackCommunicability = getDistanceAttackCommunicability((PromotionLineTypes)iI);
			if (iDistanceAttackCommunicability > 0)
			{
				bAffliction = true;
				PromotionLineTypes eAfflictionLine = ((PromotionLineTypes)iI);
				if (pCity != NULL)
				{
					pCity->changePromotionLineAfflictionAttackCommunicability(eAfflictionLine, iDistanceAttackCommunicability);
				}
				m_iAfflictionIndex.push_back(iI);
			}
		}
	}
#endif // OUTBREAKS_AND_AFFLICTIONS

	std::map<CvUnit*, int>::iterator it;
	std::map<CvUnit*, int> mapUnitDamage;

	foreach_(CvUnit* pLoopUnit, pPlot->units())
	{
		if (pLoopUnit->isEnemy(getTeam(), pPlot, this) && !pLoopUnit->isInvisible(getTeam(), false) && pLoopUnit->canDefend())
		{
			int iValue = pLoopUnit->getHP() * (1 + GC.getGame().getSorenRandNum(100, "Ranged Bombard Damage"));

			//Favor striking the bigger targets
			if (GC.getGame().isOption(GAMEOPTION_COMBAT_SIZE_MATTERS))
			{
				iValue *= pLoopUnit->getSizeMattersSpacialOffsetValue() + 10;
			}

			//Favor the first defender on the front lines less
			if (!isRBombardDirect() && pLoopUnit == pFirstUnit)
			{
				iValue /= 10;
			}
			mapUnitDamage[pLoopUnit] = iValue;
		}
	}

	PlayerTypes eBUPlayer = NO_PLAYER;
	DomainTypes eBUDomain = NO_DOMAIN;
	CvUnit* pBestUnit = NULL;
	int iDamageCount = 0;
	int iCount = 0;

	while (iCount < iPossibleTargets)
	{
		int iBestValue = 0;
		pBestUnit = NULL;

		for (it = mapUnitDamage.begin(); it != mapUnitDamage.end(); ++it)
		{
			if (it->second > iBestValue)
			{
				iBestValue = it->second;
				pBestUnit = it->first;
			}
		}

		if (pBestUnit == NULL)
		{
			break;
		}
		eBUPlayer = pBestUnit->getOwner();
		eBUDomain = pBestUnit->getDomainType();

		mapUnitDamage.erase(pBestUnit);
		//TB SubCombat Mod Begin
		bool isCollateralImmune = false;

		for (int iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
		{
			const UnitCombatTypes eType = static_cast<UnitCombatTypes>(iI);

			if (pBestUnit->isHasUnitCombat(eType) && pBestUnit->getUnitInfo().getUnitCombatCollateralImmune(eType))
			{
				isCollateralImmune = true;
				break;
			}
		}
		//TB SubCombat Mod End (with the exception of the following reference to 'isCollateralImmune'
		if (!isCollateralImmune)
		{
			const int iTheirStrength = pBestUnit->baseCombatStr();
			const int iStrengthFactor = (iRBombardStrength + iTheirStrength + 1) / 2;

			int iRBombardDamage = 100 * GC.getDefineINT("COLLATERAL_COMBAT_DAMAGE");

			iRBombardDamage *= iStrengthFactor + iRBombardStrength;
			iRBombardDamage /= iStrengthFactor + iTheirStrength;

			//TB Combat Mods begin (fortified collateral defense) Reference to iCollatDef was pBestUnit->getCollateralDamageProtection()
			//int iOverrunMod = overrunTotal();
			//int iFortDef = pBestUnit->fortifyCollateralDefenseModifier() - iOverrunMod;
			//int iFortDefzero = iFortDef < 0 ? 0 : iFortDef;
			//int iStdDef = pBestUnit->getCollateralDamageProtection();
			//int iUncheckedDef = /*iFortDefzero +*/ iStdDef;
			//int iUncheckedDefzero = std::max(0, iStdDef);
			int iCollatDef = std::max(0, std::min(pBestUnit->getCollateralDamageProtection(), 100));
			// Reduce bombard damage based on collatoral damage protection factor
			iRBombardDamage -= (iRBombardDamage * iCollatDef) / 100;
			//TB Combat Mods end

			if (pCity != NULL)
			{
				iRBombardDamage *= 100 + pCity->getAirModifier();
				iRBombardDamage /= 100;
			}

			iRBombardDamage /= 100;

			iRBombardDamage = std::max(0, iRBombardDamage);

			//Save data for the message:

			const int iMaxDamage = std::min(rBombardDamageLimit(), rBombardDamageLimit() * (iRBombardStrength + iStrengthFactor) / (iTheirStrength + iStrengthFactor));

			const int iUnitDamage = std::max(pBestUnit->getDamage(), std::min(pBestUnit->getDamage() + iRBombardDamage, iMaxDamage));

			if (pBestUnit->getDamage() != iUnitDamage)
			{
// BUG - Combat Events - start
				int iDamageDone = iUnitDamage - pBestUnit->getDamage();
				pBestUnit->setDamage(iUnitDamage, getOwner());
				//TB Combat Mod begin
				if (dealsColdDamage())
				{
					pBestUnit->setColdDamage(iUnitDamage);
				}
				//TB Combat Mod end
#ifdef OUTBREAKS_AND_AFFLICTIONS
				//Distance Communicability
				if (GC.getGame().isOption(GAMEOPTION_COMBAT_OUTBREAKS_AND_AFFLICTIONS))
				{
					if (bAffliction)
					{
						int iSize = (int)m_iAfflictionIndex.size();
						for (int iJ = 0; iJ < iSize; iJ++)
						{
							int iIndex = m_iAfflictionIndex[iJ];
							PromotionLineTypes eAfflictionLine = (PromotionLineTypes)iIndex;
							int iDAC = getDistanceAttackCommunicability(eAfflictionLine);
							if (pBestUnit->checkContractDisease(eAfflictionLine, iDAC))
							{
								pBestUnit->afflict(eAfflictionLine);
							}
						}
					}
					//Afflict On Attack
					for (int iJ = 0; iJ < GC.getNumPromotionLineInfos(); iJ++)
					{
						if (hasAfflictOnAttackType((PromotionLineTypes)iJ) && isAfflictOnAttackTypeDistance((PromotionLineTypes)iJ) && GC.getPromotionLineInfo((PromotionLineTypes)iJ).isAffliction())
						{
							PromotionLineTypes eAfflictionLinePoison = ((PromotionLineTypes)iJ);
							int iAfflictChance = getAfflictOnAttackTypeProbability(eAfflictionLinePoison) - pBestUnit->fortitudeTotal() - pBestUnit->getUnitAfflictionTolerance(eAfflictionLinePoison);
							int iAfflictCheckResult = GC.getGame().getSorenRandNum(100, "Trap Affliction Check");
							if (iAfflictCheckResult < iAfflictChance)
							{
								pBestUnit->afflict(eAfflictionLinePoison, true, this, false);
							}
						}
					}
				}
#endif // OUTBREAKS_AND_AFFLICTIONS
				CvEventReporter::getInstance().combatLogCollateral(this, pBestUnit, iDamageDone);
// BUG - Combat Events - end
				iDamageCount++;
			}
		}
		iCount++;
	}

	if (pBestUnit == NULL)
	{
		return;
	}
	if (iDamageCount > 0  && pPlot->getX() != -1 && pPlot->getY() != -1)
	{
		AddDLLMessage(
			eBUPlayer, (eBUDomain != DOMAIN_AIR), GC.getEVENT_MESSAGE_TIME(),
			gDLL->getText("TXT_KEY_MISC_YOU_SUFFER_COL_DMG", iDamageCount),
			"AS2D_COLLATERAL", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_RED(), pPlot->getX(), pPlot->getY(), true, true
		);
		AddDLLMessage(
			getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
			gDLL->getText("TXT_KEY_MISC_YOU_INFLICT_COL_DMG", getNameKey(), iDamageCount),
			"AS2D_COLLATERAL", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_GREEN(), pPlot->getX(), pPlot->getY()
		);
	}
	else
	{
		FAssertMsg(pPlot->getX() != -1 && pPlot->getY() != -1, "Unit's X or Y is out of valid range in Ranged Assault");
	}
#ifdef OUTBREAKS_AND_AFFLICTIONS
	m_iAfflictionIndex.clear();
#endif
}


void CvUnit::flankingStrikeCombat(const CvPlot* pPlot, int iAttackerStrength, int iAttackerFirepower, int iDefenderOdds, int iDefenderDamage, CvUnit* pSkipUnit)
{
	PROFILE_EXTRA_FUNC();
	if (pSkipUnit && pPlot->isCity(true, pSkipUnit->getTeam()))
	{
		return;
	}

	std::vector< std::pair<CvUnit*, int> > listFlankedUnits;
	foreach_(CvUnit* pLoopUnit, pPlot->units())
	{
		if (pLoopUnit != pSkipUnit && !pLoopUnit->isDead() && isEnemy(pLoopUnit->getTeam(), pPlot, pLoopUnit)
		&& !pLoopUnit->isInvisible(getTeam(), false) && pLoopUnit->canDefend())
		{
			int iFlankingStrength = m_pUnitInfo->getFlankingStrikeUnits().getValue(pLoopUnit->getUnitType());

			for (int iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
			{
				if (pLoopUnit->isHasUnitCombat((UnitCombatTypes)iI))
				{
					iFlankingStrength += flankingStrengthbyUnitCombatTotal((UnitCombatTypes)iI);
				}
			}

			if (iFlankingStrength > 0)
			{
				int iFlankedDefenderStrength;
				int iFlankedDefenderOdds;
				int iAttackerDamage;
				int iFlankedDefenderDamage;
				getDefenderCombatValues(*pLoopUnit, pPlot, iAttackerStrength, iAttackerFirepower, iFlankedDefenderOdds, iFlankedDefenderStrength, iAttackerDamage, iFlankedDefenderDamage, NULL, pLoopUnit);

				if (GC.getGame().getSorenRandNum(GC.getCOMBAT_DIE_SIDES(), "Flanking Combat") >= iDefenderOdds)
				{
					const int iUnitDamage = std::max(pLoopUnit->getDamage(), pLoopUnit->getDamage() + iFlankingStrength * iDefenderDamage / 100);

					if (pLoopUnit->getDamage() != iUnitDamage)
					{
						listFlankedUnits.push_back(std::make_pair(pLoopUnit, iUnitDamage));
					}
				}
			}
		}
	}

	int iNumUnitsHit = std::min((int)listFlankedUnits.size(), collateralDamageMaxUnits());

	for (int i = 0; i < iNumUnitsHit; ++i)
	{
		int iIndexHit = GC.getGame().getSorenRandNum(listFlankedUnits.size(), "Pick Flanked Unit");
		CvUnit* pUnit = listFlankedUnits[iIndexHit].first;
		int iDamage = listFlankedUnits[iIndexHit].second;
// BUG - Combat Events - start
		int iDamageDone = iDamage - pUnit->getDamage();
// BUG - Combat Events - end
		pUnit->setDamage(iDamage, getOwner());
		//TB Combat Mod begin
		if (dealsColdDamage())
		{
			pUnit->setColdDamage(iDamage);
		}
		//TB Combat mod end
		if (pUnit->isDead())
		{
			{

				CvWString szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_KILLED_UNIT_BY_FLANKING", getNameKey(), pUnit->getNameKey(), pUnit->getVisualCivAdjective(getTeam()));
				AddDLLMessage(getOwner(), false, GC.getEVENT_MESSAGE_TIME(), szBuffer, GC.getEraInfo(GC.getGame().getCurrentEra()).getAudioUnitVictoryScript(), MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_GREEN(), pPlot->getX(), pPlot->getY());
				szBuffer = gDLL->getText("TXT_KEY_MISC_YOUR_UNIT_DIED_BY_FLANKING", pUnit->getNameKey(), getNameKey(), getVisualCivAdjective(pUnit->getTeam()));
				AddDLLMessage(pUnit->getOwner(), false, GC.getEVENT_MESSAGE_TIME(), szBuffer, GC.getEraInfo(GC.getGame().getCurrentEra()).getAudioUnitDefeatScript(), MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_RED(), pPlot->getX(), pPlot->getY());
			}

			pUnit->kill(false, NO_PLAYER, true);
		}
// BUG - Combat Events - start
		CvEventReporter::getInstance().combatLogFlanking(this, pUnit, iDamageDone);
// BUG - Combat Events - end

		listFlankedUnits.erase(std::remove(listFlankedUnits.begin(), listFlankedUnits.end(), listFlankedUnits[iIndexHit]));
	}

	if (iNumUnitsHit > 0)
	{

		CvWString szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_DAMAGED_UNITS_BY_FLANKING", getNameKey(), iNumUnitsHit);
		AddDLLMessage(getOwner(), false, GC.getEVENT_MESSAGE_TIME(), szBuffer, GC.getEraInfo(GC.getGame().getCurrentEra()).getAudioUnitVictoryScript(), MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_GREEN(), pPlot->getX(), pPlot->getY());

		if (NULL != pSkipUnit)
		{
			szBuffer = gDLL->getText("TXT_KEY_MISC_YOUR_UNITS_DAMAGED_BY_FLANKING", getNameKey(), iNumUnitsHit);
			AddDLLMessage(pSkipUnit->getOwner(), false, GC.getEVENT_MESSAGE_TIME(), szBuffer, GC.getEraInfo(GC.getGame().getCurrentEra()).getAudioUnitDefeatScript(), MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_RED(), pPlot->getX(), pPlot->getY());
		}
	}
}


// Returns true if we were intercepted...
bool CvUnit::interceptTest(const CvPlot* pPlot)
{
	if (GC.getGame().getSorenRandNum(100, "Evasion Rand") >= evasionProbability())
	{
		CvUnit* pInterceptor = bestInterceptor(pPlot);
		if (pInterceptor)
		{
			int iInterceptionOdds;
			if (GC.getGame().isModderGameOption(MODDERGAMEOPTION_BETTER_INTERCETION))
			{
				iInterceptionOdds = interceptionChance(pPlot);
			}
			else
			{
				iInterceptionOdds = pInterceptor->currInterceptionProbability();
			}
			if (GC.getGame().getSorenRandNum(100, "Intercept Rand (Air)") < iInterceptionOdds)
			{
				fightInterceptor(pPlot, false);
				return true;
			}
		}
	}
	return false;
}


CvUnit* CvUnit::airStrikeTarget(const CvPlot* pPlot) const
{
	CvUnit* pDefender = pPlot->getBestDefender(NO_PLAYER, getOwner(), this, true);

	if (pDefender && !pDefender->isDead() && pDefender->canDefend())
	{
		return pDefender;
	}
	return NULL;
}


bool CvUnit::canAirStrike(const CvPlot* pPlot) const
{
	return (
		   getDomainType() == DOMAIN_AIR
		&& canAirAttack()
		&& pPlot != plot()
		&& pPlot->isVisible(getTeam(), false)
		&& plotDistance(getX(), getY(), pPlot->getX(), pPlot->getY()) <= airRange()
		&& airStrikeTarget(pPlot)
	);
}


bool CvUnit::airStrike(CvPlot* pPlot)//
{
	PROFILE_EXTRA_FUNC();
	if (!canAirStrike(pPlot))
	{
		return false;
	}

	if (interceptTest(pPlot))
	{
		return false;
	}

	CvUnit* pDefender = airStrikeTarget(pPlot);
	if (pDefender == NULL)
	{
		return false;
	}

	FAssert(pDefender != NULL);
	FAssert(pDefender->canDefend());

	setReconPlot(pPlot);

	CvCity* pCity = pPlot->getPlotCity();

	setMadeAttack(true);
	changeMoves(GC.getMOVE_DENOMINATOR());

	int iDamage = airCombatDamage(pDefender);

	int iUnitDamage = std::max(pDefender->getDamage(), std::min((pDefender->getDamage() + iDamage), airCombatLimit(pDefender)));

	{

		CvWString szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_ARE_ATTACKED_BY_AIR", pDefender->getNameKey(), getNameKey(), -(((iUnitDamage - pDefender->getDamage()) * 100) / pDefender->getMaxHP()));
		AddDLLMessage(pDefender->getOwner(), false, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_AIR_ATTACK", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_RED(), pPlot->getX(), pPlot->getY(), true, true);

		szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_ATTACK_BY_AIR", getNameKey(), pDefender->getNameKey(), -(((iUnitDamage - pDefender->getDamage()) * 100) / pDefender->getMaxHP()));
		AddDLLMessage(getOwner(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_AIR_ATTACKED", MESSAGE_TYPE_INFO, pDefender->getButton(), GC.getCOLOR_GREEN(), pPlot->getX(), pPlot->getY());
	}

	collateralCombat(pPlot, pDefender);

#ifdef OUTBREAKS_AND_AFFLICTIONS
	//Afflict
	int iDistanceAttackCommunicability = 0;
	bool bAffliction = false;
	if (GC.getGame().isOption(GAMEOPTION_COMBAT_OUTBREAKS_AND_AFFLICTIONS))
	{
		for (int iI = 0; iI < GC.getNumPromotionLineInfos(); iI++)
		{
			//Distance Communicability
			iDistanceAttackCommunicability = getDistanceAttackCommunicability((PromotionLineTypes)iI);
			if (iDistanceAttackCommunicability > 0)
			{
				bAffliction = true;
				PromotionLineTypes eAfflictionLine = ((PromotionLineTypes)iI);
				if (pDefender->checkContractDisease(eAfflictionLine, iDistanceAttackCommunicability))
				{
					pDefender->afflict(eAfflictionLine);
				}
				if (pCity != NULL)
				{
					pCity->changePromotionLineAfflictionAttackCommunicability(eAfflictionLine, iDistanceAttackCommunicability);
				}
			}
			//Afflict On Attack
			if (hasAfflictOnAttackType((PromotionLineTypes)iI)  && isAfflictOnAttackTypeDistance((PromotionLineTypes)iI) && GC.getPromotionLineInfo((PromotionLineTypes)iI).isAffliction())
			{
				PromotionLineTypes eAfflictionLinePoison = ((PromotionLineTypes)iI);
				int iAfflictChance = getAfflictOnAttackTypeProbability(eAfflictionLinePoison) - pDefender->fortitudeTotal() - pDefender->getUnitAfflictionTolerance(eAfflictionLinePoison);
				int iAfflictCheckResult = GC.getGame().getSorenRandNum(100, "Air Raid Affliction Check");
				if (iAfflictCheckResult < iAfflictChance)
				{
					pDefender->afflict(eAfflictionLinePoison, true, this, false);
				}
			}
		}
	}
#endif // OUTBREAKS_AND_AFFLICTIONS

	pDefender->setDamage(iUnitDamage, getOwner());
	//TB Combat Mod Begin
	if (dealsColdDamage())
	{
		pDefender->setColdDamage(iUnitDamage);
	}
	//TB Combat mod end

	if (GC.getGame().isModderGameOption(MODDERGAMEOPTION_IMPROVED_XP))
	{
		setExperience100(getExperience100() + 25);
	}

	return true;
}

bool CvUnit::canRangeStrike() const
{
	if (getDomainType() == DOMAIN_AIR)
	{
		return false;
	}

	if (airRange() <= 0)
	{
		return false;
	}

	if (airBaseCombatStr() <= 0)
	{
		return false;
	}

	if (!canFight())
	{
		return false;
	}

	if (isMadeAttack() && !isBlitz())
	{
		return false;
	}

	if (!canMove() && getMoves() > 0)
	{
		return false;
	}

	return true;
}

bool CvUnit::canRangeStrikeAt(const CvPlot* pPlot, int iX, int iY) const
{
	if (!canRangeStrike())
	{
		return false;
	}

	const CvPlot* pTargetPlot = GC.getMap().plot(iX, iY);

	if (NULL == pTargetPlot)
	{
		return false;
	}

	if (!pPlot->isVisible(getTeam(), false))
	{
		return false;
	}

	// Need to check target plot too
	//Fuyu: AI-controlled units can strike even when tile is invisible
	if (isHuman() && !isAutomated() && !pTargetPlot->isVisible(getTeam(), false))
	{
		return false;
	}

	if (plotDistance(pPlot->getX(), pPlot->getY(), pTargetPlot->getX(), pTargetPlot->getY()) > airRange())
	{
		return false;
	}

	const CvUnit* pDefender = airStrikeTarget(pTargetPlot);
	if (NULL == pDefender)
	{
		return false;
	}

	if (!pPlot->canSeePlot(pTargetPlot, getTeam()))
	{
		return false;
	}

	return true;
}


bool CvUnit::rangeStrike(int iX, int iY)
{
	PROFILE_EXTRA_FUNC();
	CvPlot* pPlot = GC.getMap().plot(iX, iY);
	if (NULL == pPlot)
	{
		return false;
	}
	if (!canRangeStrikeAt(plot(), iX, iY))
	{
		return false;
	}

	CvUnit* pDefender = airStrikeTarget(pPlot);

	FAssert(pDefender != NULL);
	FAssert(pDefender->canDefend());

	if (GC.getDefineINT("RANGED_ATTACKS_USE_MOVES") == 0)
	{
		setMadeAttack(true);
	}
	changeMoves(GC.getMOVE_DENOMINATOR());

	const int iUnitDamage = std::max(
		pDefender->getDamage(),
		std::min(
			pDefender->getDamage() + rangeCombatDamage(pDefender),
			airCombatLimit(pDefender)
		)
	);

	{

		CvWString szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_ARE_ATTACKED_BY_AIR",
			pDefender->getNameKey(), getNameKey(), (iUnitDamage - pDefender->getDamage()) * -100 / pDefender->getMaxHP()
		);
		//red icon over attacking unit
		AddDLLMessage(pDefender->getOwner(), false, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_COMBAT", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_RED(), this->getX(), this->getY(), true, true);
		//white icon over defending unit
		AddDLLMessage(pDefender->getOwner(), false, 0, L"", "AS2D_COMBAT", MESSAGE_TYPE_DISPLAY_ONLY, pDefender->getButton(), GC.getCOLOR_WHITE(), pDefender->getX(), pDefender->getY(), true, true);

		szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_ATTACK_BY_AIR", getNameKey(), pDefender->getNameKey(), -(((iUnitDamage - pDefender->getDamage()) * 100) / pDefender->getMaxHP()));
		AddDLLMessage(getOwner(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_COMBAT", MESSAGE_TYPE_INFO, pDefender->getButton(), GC.getCOLOR_GREEN(), pPlot->getX(), pPlot->getY());
	}

	collateralCombat(pPlot, pDefender);

#ifdef OUTBREAKS_AND_AFFLICTIONS
	//Afflict
	int iDistanceAttackCommunicability = 0;
	bool bAffliction = false;
	if (GC.getGame().isOption(GAMEOPTION_COMBAT_OUTBREAKS_AND_AFFLICTIONS))
	{
		CvCity* pCity = pPlot->getPlotCity();

		for (int iI = 0; iI < GC.getNumPromotionLineInfos(); iI++)
		{
			//Distance Communicability
			iDistanceAttackCommunicability = getDistanceAttackCommunicability((PromotionLineTypes)iI);
			if (iDistanceAttackCommunicability > 0)
			{
				bAffliction = true;
				PromotionLineTypes eAfflictionLine = ((PromotionLineTypes)iI);
				if (pDefender->checkContractDisease(eAfflictionLine, iDistanceAttackCommunicability))
				{
					pDefender->afflict(eAfflictionLine);
				}
				if (pCity != NULL)
				{
					pCity->changePromotionLineAfflictionAttackCommunicability(eAfflictionLine, iDistanceAttackCommunicability);
				}
			}
			//Afflict On Attack
			if (hasAfflictOnAttackType((PromotionLineTypes)iI) && isAfflictOnAttackTypeDistance((PromotionLineTypes)iI) && GC.getPromotionLineInfo((PromotionLineTypes)iI).isAffliction())
			{
				PromotionLineTypes eAfflictionLinePoison = ((PromotionLineTypes)iI);
				int iAfflictChance = getAfflictOnAttackTypeProbability(eAfflictionLinePoison) - pDefender->fortitudeTotal() - pDefender->getUnitAfflictionTolerance(eAfflictionLinePoison);
				int iAfflictCheckResult = GC.getGame().getSorenRandNum(100, "Air Raid Affliction Check");
				if (iAfflictCheckResult < iAfflictChance)
				{
					pDefender->afflict(eAfflictionLinePoison, true, this, false);
				}
			}
		}
	}
#endif
	//set damage but don't update entity damage visibility
	pDefender->setDamage(iUnitDamage, getOwner(), false);
	//TB Combat Mod begin
	if (dealsColdDamage())
	{
		pDefender->setColdDamage(iUnitDamage);
	}
	//TB Combat Mod end

	// Range strike entity mission
	addMission(CvMissionDefinition(MISSION_RANGE_ATTACK, pDefender->plot(), this, pDefender));

	return true;
}

//------------------------------------------------------------------------------------------------
// FUNCTION:    CvUnit::planBattle
//! \brief      Determines in general how a battle will progress.
//!
//!				Note that the outcome of the battle is not determined here. This function plans
//!				how many sub-units die and in which 'rounds' of battle.
//! \param      kBattleDefinition The battle definition, which receives the battle plan.
//! \retval     The number of game turns that the battle should be given.
//------------------------------------------------------------------------------------------------
int CvUnit::planBattle( CvBattleDefinition & kBattleDefinition ) const
{
PROFILE_EXTRA_FUNC();
#define BATTLE_TURNS_SETUP 4
/************************************************************************************************/
/* Afforess	                  Start		 6/20/11                                                */
/*                                                                                              */
/* Boost ending rounds to allow all unit animations to end                                      */
/************************************************************************************************/
/*
#define BATTLE_TURNS_ENDING 4
*/
#define BATTLE_TURNS_ENDING 6
/************************************************************************************************/
/* Afforess	                     END                                                            */
/************************************************************************************************/


#define BATTLE_TURNS_MELEE 6
#define BATTLE_TURNS_RANGED 6
#define BATTLE_TURN_RECHECK 4

	int								aiUnitsBegin[BATTLE_UNIT_COUNT];
	int								aiUnitsEnd[BATTLE_UNIT_COUNT];
	int								aiToKillMelee[BATTLE_UNIT_COUNT];
	int								aiToKillRanged[BATTLE_UNIT_COUNT];
	CvBattleRoundVector::iterator	iIterator;
	int								i, j;
	bool							bIsLoser;
	int								iRoundIndex;
	int								iTotalRounds = 0;
	int								iRoundCheck = BATTLE_TURN_RECHECK;

	// Initial conditions
	kBattleDefinition.setNumRangedRounds(0);
	kBattleDefinition.setNumMeleeRounds(0);

	int iFirstStrikesDelta = kBattleDefinition.getFirstStrikes(BATTLE_UNIT_ATTACKER) - kBattleDefinition.getFirstStrikes(BATTLE_UNIT_DEFENDER);
	if (iFirstStrikesDelta > 0) // Attacker first strikes
	{
		int iKills = computeUnitsToDie( kBattleDefinition, true, BATTLE_UNIT_DEFENDER );
		kBattleDefinition.setNumRangedRounds(std::max(iFirstStrikesDelta, iKills / iFirstStrikesDelta));
	}
	else if (iFirstStrikesDelta < 0) // Defender first strikes
	{
		int iKills = computeUnitsToDie( kBattleDefinition, true, BATTLE_UNIT_ATTACKER );
		iFirstStrikesDelta = -iFirstStrikesDelta;
		kBattleDefinition.setNumRangedRounds(std::max(iFirstStrikesDelta, iKills / iFirstStrikesDelta));
	}
	increaseBattleRounds( kBattleDefinition);


	// Keep randomizing until we get something valid
	do
	{
		iRoundCheck++;
		if ( iRoundCheck >= BATTLE_TURN_RECHECK )
		{
			increaseBattleRounds( kBattleDefinition);
			iTotalRounds = kBattleDefinition.getNumRangedRounds() + kBattleDefinition.getNumMeleeRounds();
			iRoundCheck = 0;
		}

		// Make sure to clear the battle plan, we may have to do this again if we can't find a plan that works.
		kBattleDefinition.clearBattleRounds();

		// Create the round list
		CvBattleRound kRound;
		kBattleDefinition.setBattleRound(iTotalRounds, kRound);

		// For the attacker and defender
		for ( i = 0; i < BATTLE_UNIT_COUNT; i++ )
		{
			// Gather some initial information
			BattleUnitTypes unitType = (BattleUnitTypes) i;
			aiUnitsBegin[unitType] = kBattleDefinition.getUnit(unitType)->getSubUnitsAlive(kBattleDefinition.getDamage(unitType, BATTLE_TIME_BEGIN));
			aiToKillRanged[unitType] = computeUnitsToDie( kBattleDefinition, true, unitType);
			aiToKillMelee[unitType] = computeUnitsToDie( kBattleDefinition, false, unitType);
			aiUnitsEnd[unitType] = aiUnitsBegin[unitType] - aiToKillMelee[unitType] - aiToKillRanged[unitType];

			// Make sure that if they aren't dead at the end, they have at least one unit left
			if ( aiUnitsEnd[unitType] == 0 && !kBattleDefinition.getUnit(unitType)->isDead() )
			{
				aiUnitsEnd[unitType]++;
				if ( aiToKillMelee[unitType] > 0 )
				{
					aiToKillMelee[unitType]--;
				}
				else
				{
					aiToKillRanged[unitType]--;
				}
			}

			// If one unit is the loser, make sure that at least one of their units dies in the last round
			if ( aiUnitsEnd[unitType] == 0 )
			{
				kBattleDefinition.getBattleRound(iTotalRounds - 1).addNumKilled(unitType, 1);
				if ( aiToKillMelee[unitType] > 0)
				{
					aiToKillMelee[unitType]--;
				}
				else
				{
					aiToKillRanged[unitType]--;
				}
			}

			// Randomize in which round each death occurs
			bIsLoser = aiUnitsEnd[unitType] == 0;

			// Randomize the ranged deaths
			for ( j = 0; j < aiToKillRanged[unitType]; j++ )
			{
				iRoundIndex = GC.getGame().getSorenRandNum( range( kBattleDefinition.getNumRangedRounds(), 0, kBattleDefinition.getNumRangedRounds()), "Ranged combat death");
				kBattleDefinition.getBattleRound(iRoundIndex).addNumKilled(unitType, 1);
			}

			// Randomize the melee deaths
			for ( j = 0; j < aiToKillMelee[unitType]; j++ )
			{
				iRoundIndex = GC.getGame().getSorenRandNum( range( kBattleDefinition.getNumMeleeRounds() - (bIsLoser ? 1 : 2 ), 0, kBattleDefinition.getNumMeleeRounds()), "Melee combat death");
				kBattleDefinition.getBattleRound(kBattleDefinition.getNumRangedRounds() + iRoundIndex).addNumKilled(unitType, 1);
			}

			// Compute alive sums
			int iNumberKilled = 0;
			for(int j=0;j<kBattleDefinition.getNumBattleRounds();j++)
			{
				CvBattleRound &round = kBattleDefinition.getBattleRound(j);
				round.setRangedRound(j < kBattleDefinition.getNumRangedRounds());
				iNumberKilled += round.getNumKilled(unitType);
				round.setNumAlive(unitType, aiUnitsBegin[unitType] - iNumberKilled);
			}
		}

		// Now compute wave sizes
		for(int i=0;i<kBattleDefinition.getNumBattleRounds();i++)
		{
			CvBattleRound &round = kBattleDefinition.getBattleRound(i);
			round.setWaveSize(computeWaveSize(round.isRangedRound(), round.getNumAlive(BATTLE_UNIT_ATTACKER) + round.getNumKilled(BATTLE_UNIT_ATTACKER), round.getNumAlive(BATTLE_UNIT_DEFENDER) + round.getNumKilled(BATTLE_UNIT_DEFENDER)));
		}

		if ( iTotalRounds > 400 )
		{
			kBattleDefinition.setNumMeleeRounds(1);
			kBattleDefinition.setNumRangedRounds(0);
			break;
		}
	}
	while ( !verifyRoundsValid( kBattleDefinition ));

	//add a little extra time for leader to surrender
	bool attackerLeader = false;
	bool defenderLeader = false;
	bool attackerDie = false;
	bool defenderDie = false;
	int lastRound = kBattleDefinition.getNumBattleRounds() - 1;
	if(kBattleDefinition.getUnit(BATTLE_UNIT_ATTACKER)->getLeaderUnitType() != NO_UNIT)
		attackerLeader = true;
	if(kBattleDefinition.getUnit(BATTLE_UNIT_DEFENDER)->getLeaderUnitType() != NO_UNIT)
		defenderLeader = true;
	if(kBattleDefinition.getBattleRound(lastRound).getNumAlive(BATTLE_UNIT_ATTACKER) == 0)
		attackerDie = true;
	if(kBattleDefinition.getBattleRound(lastRound).getNumAlive(BATTLE_UNIT_DEFENDER) == 0)
		defenderDie = true;

	int extraTime = 0;
	if((attackerLeader && attackerDie) || (defenderLeader && defenderDie))
		extraTime = BATTLE_TURNS_MELEE;

	if ( (!kBattleDefinition.getUnit(BATTLE_UNIT_ATTACKER)->isUsingDummyEntities() && kBattleDefinition.getUnit(BATTLE_UNIT_ATTACKER)->isInViewport() && showSeigeTower(kBattleDefinition.getUnit(BATTLE_UNIT_ATTACKER))) || //K-mod
		 (!kBattleDefinition.getUnit(BATTLE_UNIT_DEFENDER)->isUsingDummyEntities() && kBattleDefinition.getUnit(BATTLE_UNIT_DEFENDER)->isInViewport() && showSeigeTower(kBattleDefinition.getUnit(BATTLE_UNIT_DEFENDER))) )  //K-mod
	{
		extraTime = BATTLE_TURNS_MELEE;
	}

	return BATTLE_TURNS_SETUP + BATTLE_TURNS_ENDING + kBattleDefinition.getNumMeleeRounds() * BATTLE_TURNS_MELEE + kBattleDefinition.getNumRangedRounds() * BATTLE_TURNS_MELEE + extraTime;
}

//------------------------------------------------------------------------------------------------
// FUNCTION:	CvBattleManager::computeDeadUnits
//! \brief		Computes the number of units dead, for either the ranged or melee portion of combat.
//! \param		kDefinition The battle definition.
//! \param		bRanged true if computing the number of units that die during the ranged portion of combat,
//!					false if computing the number of units that die during the melee portion of combat.
//! \param		iUnit The index of the unit to compute (BATTLE_UNIT_ATTACKER or BATTLE_UNIT_DEFENDER).
//! \retval		The number of units that should die for the given unit in the given portion of combat
//------------------------------------------------------------------------------------------------
int CvUnit::computeUnitsToDie( const CvBattleDefinition & kDefinition, bool bRanged, BattleUnitTypes iUnit ) const
{
	FAssertMsg( iUnit == BATTLE_UNIT_ATTACKER || iUnit == BATTLE_UNIT_DEFENDER, "Invalid unit index");

	BattleTimeTypes iBeginIndex = bRanged ? BATTLE_TIME_BEGIN : BATTLE_TIME_RANGED;
	BattleTimeTypes iEndIndex = bRanged ? BATTLE_TIME_RANGED : BATTLE_TIME_END;
	return kDefinition.getUnit(iUnit)->getSubUnitsAlive(kDefinition.getDamage(iUnit, iBeginIndex)) -
		kDefinition.getUnit(iUnit)->getSubUnitsAlive( kDefinition.getDamage(iUnit, iEndIndex));
}

//------------------------------------------------------------------------------------------------
// FUNCTION:    CvUnit::verifyRoundsValid
//! \brief      Verifies that all rounds in the battle plan are valid
//! \param      vctBattlePlan The battle plan
//! \retval     true if the battle plan (seems) valid, false otherwise
//------------------------------------------------------------------------------------------------
bool CvUnit::verifyRoundsValid( const CvBattleDefinition & battleDefinition ) const
{
	PROFILE_EXTRA_FUNC();
	for(int i=0;i<battleDefinition.getNumBattleRounds();i++)
	{
		if(!battleDefinition.getBattleRound(i).isValid())
			return false;
	}
	return true;
}

//------------------------------------------------------------------------------------------------
// FUNCTION:    CvUnit::increaseBattleRounds
//! \brief      Increases the number of rounds in the battle.
//! \param      kBattleDefinition The definition of the battle
//------------------------------------------------------------------------------------------------
void CvUnit::increaseBattleRounds( CvBattleDefinition & kBattleDefinition ) const
{
	if ( kBattleDefinition.getUnit(BATTLE_UNIT_ATTACKER)->isRanged() && kBattleDefinition.getUnit(BATTLE_UNIT_DEFENDER)->isRanged())
	{
		kBattleDefinition.addNumRangedRounds(1);
	}
	else
	{
		kBattleDefinition.addNumMeleeRounds(1);
	}
}

//------------------------------------------------------------------------------------------------
// FUNCTION:    CvUnit::computeWaveSize
//! \brief      Computes the wave size for the round.
//! \param      bRangedRound true if the round is a ranged round
//! \param		iAttackerMax The maximum number of attackers that can participate in a wave (alive)
//! \param		iDefenderMax The maximum number of Defenders that can participate in a wave (alive)
//! \retval     The desired wave size for the given parameters
//------------------------------------------------------------------------------------------------
int CvUnit::computeWaveSize( bool bRangedRound, int iAttackerMax, int iDefenderMax ) const
{
	FAssertMsg( getCombatUnit() != NULL, "You must be fighting somebody!" );
	int aiDesiredSize[BATTLE_UNIT_COUNT];
	if ( bRangedRound )
	{
		aiDesiredSize[BATTLE_UNIT_ATTACKER] = getUnitInfo().getRangedWaveSize();
		aiDesiredSize[BATTLE_UNIT_DEFENDER] = getCombatUnit()->getUnitInfo().getRangedWaveSize();
	}
	else
	{
		aiDesiredSize[BATTLE_UNIT_ATTACKER] = getUnitInfo().getMeleeWaveSize();
		aiDesiredSize[BATTLE_UNIT_DEFENDER] = getCombatUnit()->getUnitInfo().getMeleeWaveSize();
	}

	aiDesiredSize[BATTLE_UNIT_DEFENDER] = aiDesiredSize[BATTLE_UNIT_DEFENDER] <= 0 ? iDefenderMax : aiDesiredSize[BATTLE_UNIT_DEFENDER];
	aiDesiredSize[BATTLE_UNIT_ATTACKER] = aiDesiredSize[BATTLE_UNIT_ATTACKER] <= 0 ? iDefenderMax : aiDesiredSize[BATTLE_UNIT_ATTACKER];
	return (
		std::min(
			std::min(aiDesiredSize[BATTLE_UNIT_ATTACKER], iAttackerMax),
			std::min(aiDesiredSize[BATTLE_UNIT_DEFENDER], iDefenderMax)
		)
	);
}

bool CvUnit::isTargetOf(const CvUnit& attacker) const
{
	PROFILE_EXTRA_FUNC();

	const CvUnitInfo& attackerInfo = attacker.getUnitInfo();

	if (getUnitType() != NO_UNIT && attackerInfo.isTargetUnit(getUnitType()))
	{
		return true;
	}

	const CvUnitInfo& ourInfo = getUnitInfo();

	if (attacker.getUnitType() != NO_UNIT && ourInfo.isDefendAgainstUnit(attacker.getUnitType()))
	{
		return true;
	}

	for (std::map<UnitCombatTypes, UnitCombatKeyedInfo>::const_iterator it = m_unitCombatKeyedInfo.begin(), end = m_unitCombatKeyedInfo.end(); it != end; ++it)
	{
		if (it->second.m_bHasUnitCombat && (attackerInfo.getTargetUnitCombat(it->first) || attacker.hasTargetUnitCombat(it->first)))
		{
			return true;
		}
	}
	for (std::map<UnitCombatTypes, UnitCombatKeyedInfo>::const_iterator it = attacker.m_unitCombatKeyedInfo.begin(), end = attacker.m_unitCombatKeyedInfo.end(); it != end; ++it)
	{
		if (it->second.m_bHasUnitCombat && ourInfo.getDefenderUnitCombat(it->first))
		{
			return true;
		}
	}
	return false;
}

bool CvUnit::isEnemy(TeamTypes eTeam, const CvPlot* pPlot, const CvUnit* pUnit) const
{
	if (pUnit && (isBarbCoExist() && pUnit->isHominid() || pUnit->isBarbCoExist() && isHominid()))
	{
		return false;
	}
	return atWar(GET_PLAYER(getCombatOwner(eTeam, pPlot ? pPlot : plot())).getTeam(), eTeam);
}

bool CvUnit::isPotentialEnemy(TeamTypes eTeam, const CvPlot* pPlot, const CvUnit* pUnit) const
{
	if (pUnit && (isBarbCoExist() && pUnit->isHominid() || pUnit->isBarbCoExist() && isHominid()))
	{
		return false;
	}
	return ::isPotentialEnemy(GET_PLAYER(getCombatOwner(eTeam, pPlot ? pPlot : plot())).getTeam(), eTeam);
}

bool CvUnit::isSuicide() const
{
	return m_pUnitInfo->isSuicide() || getKamikazePercent() != 0;
}

int CvUnit::getDropRange() const
{
	return (m_pUnitInfo->getDropRange() + getExtraDropRange());
}

void CvUnit::getDefenderCombatValues(const CvUnit& kDefender, const CvPlot* pPlot, int iOurStrength, int iOurFirepower, int& iTheirOdds, int& iTheirStrength, int& iOurDamage, int& iTheirDamage, CombatDetails* pTheirDetails, const CvUnit* pDefender) const
{
	//TB Combat Mod begin
	iTheirStrength = std::max(1,kDefender.currCombatStr(pPlot, this, pTheirDetails));
	int iTheirFirepower = std::max(1, kDefender.currFirepower(pPlot, this));

	if (kDefender.getCombatPowerShots() > 0)
	{
		iTheirStrength += ((iTheirStrength * kDefender.powerShotCombatModifierTotal())/100);
		iTheirFirepower += ((iTheirFirepower * kDefender.powerShotCombatModifierTotal())/100);
	}
	if (getCombatPowerShots() > 0)
	{
		iOurStrength += ((iOurStrength * powerShotCombatModifierTotal())/100);
		iOurFirepower += ((iOurFirepower * powerShotCombatModifierTotal())/100);
	}

#ifdef STRENGTH_IN_NUMBERS
	if (GC.getGame().isOption(GAMEOPTION_COMBAT_STRENGTH_IN_NUMBERS))
	{
		int iTheirSupportStrength = kDefender.getDefenderSupportValue(this);
		int iOurSupportStrength = getAttackerSupportValue();
		iOurStrength += iOurSupportStrength;
		iOurFirepower += iOurSupportStrength;
		iTheirStrength += iTheirSupportStrength;
		iTheirFirepower += iTheirSupportStrength;
	}
#endif // STRENGTH_IN_NUMBERS

	//TB Combat Mod end

	FAssert((iOurStrength + iTheirStrength) > 0);
	FAssert((iOurFirepower + iTheirFirepower) > 0);

	iTheirOdds = ((GC.getCOMBAT_DIE_SIDES() * iTheirStrength) / (iOurStrength + iTheirStrength));

	// Free wins against NPC
	if (isNPC())
	{
		if (!kDefender.isNPC() && GET_PLAYER(kDefender.getOwner()).getWinsVsBarbs() < GC.getHandicapInfo(GET_PLAYER(kDefender.getOwner()).getHandicapType()).getFreeWinsVsBarbs())
		{
			iTheirOdds =  std::max((90 * GC.getCOMBAT_DIE_SIDES()) / 100, iTheirOdds);
		}
	}
	else if (kDefender.isNPC() && GET_PLAYER(getOwner()).getWinsVsBarbs() < GC.getHandicapInfo(GET_PLAYER(getOwner()).getHandicapType()).getFreeWinsVsBarbs())
	{
		iTheirOdds = std::min((10 * GC.getCOMBAT_DIE_SIDES()) / 100, iTheirOdds);
	}

	int iStrengthFactor = ((iOurFirepower + iTheirFirepower + 1) / 2);
	//TB Combat Mods Begin
	CvUnit* pAttacker = (CvUnit*)this;
	int iAttackArmorTotal = armorVSOpponentProbTotal(pDefender);
	int iDefendPunctureTotal = kDefender.punctureVSOpponentProbTotal(pAttacker);
	int iAttackPunctureTotal = punctureVSOpponentProbTotal(pDefender);
	int iDefendArmorTotal = kDefender.armorVSOpponentProbTotal(pAttacker);
	if (kDefender.getCombatPowerShots() > 0)
	{
		iDefendPunctureTotal += kDefender.powerShotPunctureModifierTotal();
	}
	if (getCombatPowerShots() > 0)
	{
		iAttackPunctureTotal += powerShotPunctureModifierTotal();
	}

	int iUnmodifiedDefenderArmor = (iDefendArmorTotal - iAttackPunctureTotal);
	int iUnmodifiedAttackerArmor = (iAttackArmorTotal - iDefendPunctureTotal);
	int iModifiedDefenderArmorZero = (iUnmodifiedDefenderArmor < 0 ? 0 : iUnmodifiedDefenderArmor);
	int iModifiedAttackerArmorZero = (iUnmodifiedAttackerArmor < 0 ? 0 : iUnmodifiedAttackerArmor);
	int iModifiedDefenderArmor = (iModifiedDefenderArmorZero < 95 ? iModifiedDefenderArmorZero : 95);
	int iModifiedAttackerArmor = (iModifiedAttackerArmorZero < 95 ? iModifiedAttackerArmorZero: 95);

	int iDefenderArmor = (100 - iModifiedDefenderArmor);
	int iAttackerArmor = (100 - iModifiedAttackerArmor);
	// UncutDragon
/* original code
	iOurDamage = std::max(1, ((GC.getDefineINT("COMBAT_DAMAGE") * (iTheirFirepower + iStrengthFactor)) / (iOurFirepower + iStrengthFactor)));
	iTheirDamage = std::max(1, ((GC.getDefineINT("COMBAT_DAMAGE") * (iOurFirepower + iStrengthFactor)) / (iTheirFirepower + iStrengthFactor)));
*/	// modified by both UncutDragon and TB
	int iDefendDamageModifierTotal = kDefender.damageModifierTotal();
	int iAttackDamageModifierTotal = damageModifierTotal();

	int iOurDamageBase = ((GC.getCOMBAT_DAMAGE() * (iTheirFirepower + iStrengthFactor)) / std::max(1, (iOurFirepower + iStrengthFactor)));
	int iTheirDamageBase = ((GC.getCOMBAT_DAMAGE() * (iOurFirepower + iStrengthFactor)) / std::max(1, (iTheirFirepower + iStrengthFactor)));
	int iOurDamageModified = iOurDamageBase + ((iOurDamageBase * iDefendDamageModifierTotal)/100);
	int iTheirDamageModified = iTheirDamageBase + ((iTheirDamageBase * iAttackDamageModifierTotal)/100);
	int iOurDamageArmor = (iOurDamageModified * iAttackerArmor)/100;
	int iTheirDamageArmor = (iTheirDamageModified * iDefenderArmor)/100;
	iOurDamage  = std::max(1, iOurDamageArmor);
	iTheirDamage  = std::max(1, iTheirDamageArmor);
	//iOurDamage = std::max(1, ((((GC.getCOMBAT_DAMAGE() * (iTheirFirepower + iStrengthFactor)) / (iOurFirepower + iStrengthFactor)) * iAttackerArmor)/100));
	//iTheirDamage = std::max(1, ((((GC.getCOMBAT_DAMAGE() * (iOurFirepower + iStrengthFactor)) / (iTheirFirepower + iStrengthFactor)) * iDefenderArmor)/100));
	// /UncutDragon
	//TB Combat Mods End
/************************************************************************************************/
/* BETTER_BTS_AI_MOD                       END                                                  */
/************************************************************************************************/
	iTheirStrength = std::max(1,iTheirStrength);
}

int CvUnit::getTriggerValue(EventTriggerTypes eTrigger, const CvPlot* pPlot, bool bCheckPlot) const
{
	PROFILE_EXTRA_FUNC();
	const CvEventTriggerInfo& kTrigger = GC.getEventTriggerInfo(eTrigger);
	if (kTrigger.getNumUnits() <= 0)
	{
		return MIN_INT;
	}

	if (isDead())
	{
		return MIN_INT;
	}

	if (kTrigger.getNumUnitsRequired() > 0)
	{
		bool bFoundValid = false;
		for (int i = 0; i < kTrigger.getNumUnitsRequired(); ++i)
		{
			if (getUnitType() == kTrigger.getUnitRequired(i))
			{
				bFoundValid = true;
				break;
			}
		}

		if (!bFoundValid)
		{
			return MIN_INT;
		}
	}

	if (bCheckPlot && plot() && kTrigger.isUnitsOnPlot())
	{
		if (!plot()->canTrigger(eTrigger, getOwner()))
		{
			return MIN_INT;
		}
	}

	int iValue = 0;

	if (0 == getDamage() && kTrigger.getUnitDamagedWeight() > 0)
	{
		return MIN_INT;
	}

	//	Call out to Python last as its the most expensive part of the calcuation
	//	and we'll often have decided the trigger is inapplicable before this
	if (!CvString(kTrigger.getPythonCanDoUnit()).empty())
	{
		if (!Cy::call<bool>(PYRandomEventModule, kTrigger.getPythonCanDoUnit(), Cy::Args()
			<< eTrigger
			<< getOwner()
			<< getID()))
		{
			return MIN_INT;
		}
	}

	iValue += getDamage() * kTrigger.getUnitDamagedWeight();

	iValue += getExperience() * kTrigger.getUnitExperienceWeight();

	if (NULL != pPlot)
	{
		iValue += plotDistance(getX(), getY(), pPlot->getX(), pPlot->getY()) * kTrigger.getUnitDistanceWeight();
	}

	return iValue;
}

bool CvUnit::canApplyEvent(EventTypes eEvent) const
{
	const CvEventInfo& kEvent = GC.getEventInfo(eEvent);

	if (0 != kEvent.getUnitExperience())
	{
		if (!canAcquirePromotionAny())
		{
			return false;
		}
	}
	return true;
}

void CvUnit::applyEvent(EventTypes eEvent)
{
	if (!canApplyEvent(eEvent))
	{
		return;
	}

	const CvEventInfo& kEvent = GC.getEventInfo(eEvent);

	if (0 != kEvent.getUnitExperience())
	{
		setDamage(0);
		changeExperience(kEvent.getUnitExperience());
	}


	if (kEvent.getUnitImmobileTurns() > 0)
	{
		changeImmobileTimer(kEvent.getUnitImmobileTurns());


		CvWString szText = gDLL->getText("TXT_KEY_EVENT_UNIT_IMMOBILE", getNameKey(), kEvent.getUnitImmobileTurns());
		AddDLLMessage(getOwner(), false, GC.getEVENT_MESSAGE_TIME(), szText, "AS2D_UNITGIFTED", MESSAGE_TYPE_INFO, getButton(), (ColorTypes)GC.getInfoTypeForString("COLOR_UNIT_TEXT"), getX(), getY(), true, true);
	}

	CvWString szNameKey(kEvent.getUnitNameKey());

	if (!szNameKey.empty())
	{
		setName(gDLL->getText(kEvent.getUnitNameKey()));
	}

	if (kEvent.isDisbandUnit())
	{
		kill(false, NO_PLAYER, true);
	}
}

const CvArtInfoUnit* CvUnit::getArtInfo(int i, EraTypes eEra) const
{
	return m_pUnitInfo->getArtInfo(i, eEra, (UnitArtStyleTypes) GC.getCivilizationInfo(getCivilizationType()).getUnitArtStyleType());
}

const char* CvUnit::getButton() const
{
	const CvArtInfoUnit* pArtInfo = getArtInfo(0, GET_PLAYER(getOwner()).getCurrentEra());

	if (NULL != pArtInfo)
	{
		return pArtInfo->getButton();
	}

	return m_pUnitInfo->getButton();
}

int CvUnit::getGroupSize() const
{
	if (GC.getGame().isOption(GAMEOPTION_COMBAT_SIZE_MATTERS) && groupRank() > 0)
	{
		return groupRank();
	}
	return m_pUnitInfo->getGroupSize();
}

int CvUnit::getGroupDefinitions() const
{
	return m_pUnitInfo->getGroupDefinitions();
}

int CvUnit::getUnitGroupRequired(int i) const
{
	return m_pUnitInfo->getUnitGroupRequired(i);
}

bool CvUnit::isRenderAlways() const
{
	return m_pUnitInfo->isRenderAlways();
}

float CvUnit::getAnimationMaxSpeed() const
{
	return m_pUnitInfo->getUnitMaxSpeed();
}

float CvUnit::getAnimationPadTime() const
{
	return m_pUnitInfo->getUnitPadTime();
}

const char* CvUnit::getFormationType() const
{
	return m_pUnitInfo->getFormationType();
}

bool CvUnit::isMechUnit() const
{
	return m_pUnitInfo->isMechUnit();
}

bool CvUnit::isRenderBelowWater() const
{
	return m_pUnitInfo->isRenderBelowWater();
}

int CvUnit::getRenderPriority(UnitSubEntityTypes eUnitSubEntity, int iMeshGroupType, int UNIT_MAX_SUB_TYPES) const
{
	if (eUnitSubEntity == UNIT_SUB_ENTITY_SIEGE_TOWER)
	{
		return (getOwner() * (GC.getNumUnitInfos() + 2) * UNIT_MAX_SUB_TYPES) + iMeshGroupType;
	}
	else
	{
		return (getOwner() * (GC.getNumUnitInfos() + 2) * UNIT_MAX_SUB_TYPES) + m_eUnitType * UNIT_MAX_SUB_TYPES + iMeshGroupType;
	}
}

bool CvUnit::isAlwaysHostile(const CvPlot* pPlot) const
{
	if (!m_pUnitInfo->isAlwaysHostile() && getHiddenNationalityCount() < 1)
	{
		return false;
	}

	if (pPlot && pPlot->isCity(true, getTeam()))
	{
		if (isBlendIntoCity())
		{
			return isAssassin() && pPlot == plot();
		}

		return pPlot->getOwner() != getOwner() && (!isBarbCoExist() || !pPlot->isHominid());
	}

	return true;
}

bool CvUnit::verifyStackValid()
{
	PROFILE_EXTRA_FUNC();
	if (isDead()) return true;

	const CvPlot* pPlot = plot();
	if (!canCoexistAlwaysOnPlot(*pPlot))
	{
		foreach_ (const CvUnit* unit, pPlot->units())
		{
			if (unit != this
			&& isEnemy(unit->getTeam(), NULL, unit)
			&& !isInvisible(unit->getTeam())
			&& !unit->canCoexistWithTeamOnPlot(getTeam(), *pPlot))
			{
				return jumpToNearestValidPlot();
			}
		}
	}
	return true;
}


//check if quick combat
bool CvUnit::isCombatVisible(const CvUnit* pDefender) const
{
	if (isHuman())
	{
		if (!GET_PLAYER(getOwner()).isOption(PLAYEROPTION_QUICK_ATTACK))
		{
			return true;
		}
	}
	else if (pDefender && pDefender->isHuman() && !GET_PLAYER(pDefender->getOwner()).isOption(PLAYEROPTION_QUICK_DEFENSE))
	{
		return true;
	}
	return false;
}

// used by the executable for the red glow and plot indicators
bool CvUnit::shouldShowEnemyGlow(TeamTypes eForTeam) const
{
	if (isDelayedDeath() || getDomainType() == DOMAIN_AIR || !canFight())
	{
		return false;
	}

	const CvPlot* pPlot = plot();
	if (pPlot == NULL)
	{
		return false;
	}

	const TeamTypes ePlotTeam = pPlot->getTeam();
	if (ePlotTeam != eForTeam || !isEnemy(ePlotTeam))
	{
		return false;
	}

	return true;
}

bool CvUnit::shouldShowFoundBorders() const
{
	return isFound();
}


void CvUnit::cheat(bool bCtrl, bool bAlt, bool bShift)
{
	if (bCtrl && (gDLL->getChtLvl() > 0 || GC.getGame().isDebugMode()))
	{
		setPromotionReady(true);
	}
}

float CvUnit::getHealthBarModifier() const
{
	if (GC.getGame().isOption(GAMEOPTION_COMBAT_SIZE_MATTERS))
	{
		const int iWidthDivisor = (1 + (int)GET_PLAYER(getOwner()).getCurrentEra()) * 4;
		return ((GC.getDefineFLOAT("HEALTH_BAR_WIDTH") / iWidthDivisor) / (GC.getGame().getBestLandUnitCombat() * 2));
	}
	return (GC.getDefineFLOAT("HEALTH_BAR_WIDTH") / (GC.getGame().getBestLandUnitCombat() * 2));
}

void CvUnit::getLayerAnimationPaths(std::vector<AnimationPathTypes>& aAnimationPaths) const
{
	PROFILE_EXTRA_FUNC();
	for (int i = 0; i < GC.getNumPromotionInfos(); ++i)
	{
		if (isHasPromotion((PromotionTypes)i))
		{
			const AnimationPathTypes eAnimationPath = (AnimationPathTypes)GC.getPromotionInfo((PromotionTypes)i).getLayerAnimationPath();
			if (eAnimationPath != ANIMATIONPATH_NONE)
			{
				aAnimationPaths.push_back(eAnimationPath);
			}
		}
	}
}

int CvUnit::getSelectionSoundScript() const
{
	int iScriptId = getArtInfo(0, GET_PLAYER(getOwner()).getCurrentEra())->getSelectionSoundScriptId();
	if (iScriptId == -1)
	{
		iScriptId = GC.getCivilizationInfo(getCivilizationType()).getSelectionSoundScriptId();
	}
	return iScriptId;
}


// Dale - AB: Bombing
bool CvUnit::canAirBomb1() const
{
	if (!GC.isDCM_AIR_BOMBING())
	{
		return false;
	}
	if (!m_pUnitInfo->getDCMAirBomb1())
	{
		return false;
	}
	if (getDomainType() != DOMAIN_AIR)
	{
		return false;
	}

	if (getAirBombBaseRate() == 0)
	{
		return false;
	}

	if (isMadeAttack())
	{
		return false;
	}

	return true;
}


bool CvUnit::canAirBomb1At(const CvPlot* pPlot, int iX, int iY) const
{
	if (!canAirBomb1())
	{
		return false;
	}

	const CvPlot* pTargetPlot = GC.getMap().plot(iX, iY);
	if (plotDistance(pPlot->getX(), pPlot->getY(), pTargetPlot->getX(), pTargetPlot->getY()) > airRange()
	|| pTargetPlot->isOwned() && !atWar(pTargetPlot->getTeam(), getTeam()))
	{
		return false;
	}

	const CvCity* pCity = pTargetPlot->getPlotCity();
	if (pCity != NULL && pCity->isBombardable(this))
	{
		return true;
	}
	if (pTargetPlot->isImprovementDestructible())
	{
		return true;
	}
	return false;
}


bool CvUnit::airBomb1(int iX, int iY)
{
	PROFILE_EXTRA_FUNC();
	if (!canAirBomb1At(plot(), iX, iY))
	{
		return false;
	}

	CvPlot* pPlot = GC.getMap().plot(iX, iY);

	if (interceptTest(pPlot))
	{
		return true;
	}
	CvWString szBuffer;

	CvCity* pCity = pPlot->getPlotCity();
	if (pCity != NULL)
	{
		pCity->changeDefenseDamage(getAirBombCurrRate());

		changeExperience(GC.getDefineINT("MIN_EXPERIENCE_PER_COMBAT"), maxXPValue(NULL, pCity->isHominid()), pCity->getOwner() == getOwner());


		szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_DEFENSES_REDUCED_TO", pCity->getNameKey(), pCity->getDefenseModifier(false), getNameKey());
		AddDLLMessage(pCity->getOwner(), false, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_BOMBARDED", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_RED(), pCity->getX(), pCity->getY(), true, true);

		szBuffer = gDLL->getText("TXT_KEY_MISC_ENEMY_DEFENSES_REDUCED_TO", getNameKey(), pCity->getNameKey(), pCity->getDefenseModifier(false));
		AddDLLMessage(getOwner(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_BOMBARD", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_GREEN(), pCity->getX(), pCity->getY());
	}
	else
	{
		if (pPlot->getImprovementType() != NO_IMPROVEMENT)
		{
			if (GC.getGame().getSorenRandNum(getAirBombCurrRate(), "Air Bomb - Offense") >=
					GC.getGame().getSorenRandNum(GC.getImprovementInfo(pPlot->getImprovementType()).getAirBombDefense(), "Air Bomb - Defense"))
			{
				{

					szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_UNIT_DESTROYED_IMP", getNameKey(), GC.getImprovementInfo(pPlot->getImprovementType()).getTextKeyWide());
					AddDLLMessage(getOwner(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_PILLAGE", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_GREEN(), pPlot->getX(), pPlot->getY());
				}

				if (pPlot->isOwned())
				{
					{

						szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_IMP_WAS_DESTROYED", GC.getImprovementInfo(pPlot->getImprovementType()).getTextKeyWide(), getNameKey(), GET_PLAYER(getOwner()).getCivilizationAdjectiveKey());
						AddDLLMessage(pPlot->getOwner(), false, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_PILLAGED", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_RED(), pPlot->getX(), pPlot->getY(), true, true);
					}
					changeExperience(GC.getDefineINT("MIN_EXPERIENCE_PER_COMBAT"), maxXPValue(NULL, pPlot->isHominid()), true, pPlot->getOwner() == getOwner());
				}

				pPlot->setImprovementType(GC.getImprovementInfo(pPlot->getImprovementType()).getImprovementPillage());

#ifdef OUTBREAKS_AND_AFFLICTIONS
				//Afflict
				int iDistanceAttackCommunicability = 0;
				bool bAffliction = false;
				if (GC.getGame().isOption(GAMEOPTION_COMBAT_OUTBREAKS_AND_AFFLICTIONS))
				{
					for (int iI = 0; iI < GC.getNumPromotionLineInfos(); iI++)
					{
						if (GC.getPromotionLineInfo((PromotionLineTypes)iI).isAffliction() && !GC.getPromotionLineInfo((PromotionLineTypes)iI).isCritical())
						{
							//Distance Communicability
							iDistanceAttackCommunicability = getDistanceAttackCommunicability((PromotionLineTypes)iI);
							bool bDistAttComm = iDistanceAttackCommunicability > 0;
							PromotionLineTypes eAfflictionLine = ((PromotionLineTypes)iI);
							bool bAffonAtt = (hasAfflictOnAttackType(eAfflictionLine) && isAfflictOnAttackTypeDistance(eAfflictionLine));
							if (bDistAttComm || bAffonAtt)
							{
								bAffliction = true;
								foreach_(CvUnit* pLoopUnit, pPlot->units())
								{
									if (bDistAttComm && pLoopUnit->checkContractDisease(eAfflictionLine, iDistanceAttackCommunicability))
									{
										pLoopUnit->afflict(eAfflictionLine);
									}
									if (bAffonAtt)
									{
										int iAttackersPoisonChance = getAfflictOnAttackTypeProbability(eAfflictionLine) - pLoopUnit->fortitudeTotal() - pLoopUnit->getUnitAfflictionTolerance(eAfflictionLine);

										if (GC.getGame().getSorenRandNum(100, "AttackersPoisonRoll") < iAttackersPoisonChance)
										{
											pLoopUnit->afflict(eAfflictionLine, true, this);
										}
									}
								}
							}
						}
					}
				}
#endif // OUTBREAKS_AND_AFFLICTIONS
			}
			else
			{

				szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_UNIT_FAIL_DESTROY_IMP", getNameKey(), GC.getImprovementInfo(pPlot->getImprovementType()).getTextKeyWide());
				AddDLLMessage(getOwner(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_BOMB_FAILS", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_RED(), pPlot->getX(), pPlot->getY());
			}
		}
	}

	setReconPlot(pPlot);

	setMadeAttack(true);
	changeMoves(GC.getMOVE_DENOMINATOR());

	addMission(CvAirMissionDefinition(MISSION_AIRBOMB, pPlot, this));

	if (isSuicide())
	{
		kill(true);
	}
	return true;
}

bool CvUnit::canAirBomb2() const
{
	if (!GC.isDCM_AIR_BOMBING())
	{
		return false;
	}
	if (!m_pUnitInfo->getDCMAirBomb2())
	{
		return false;
	}
	if (getDomainType() != DOMAIN_AIR)
	{
		return false;
	}
	if (getAirBombBaseRate() == 0)
	{
		return false;
	}
	if (isMadeAttack())
	{
		return false;
	}
	return true;
}


bool CvUnit::canAirBomb2At(const CvPlot* pPlot, int iX, int iY) const
{
	if (!canAirBomb2())
	{
		return false;
	}
	const CvPlot* pTargetPlot = GC.getMap().plot(iX, iY);
	if (plotDistance(pPlot->getX(), pPlot->getY(), pTargetPlot->getX(), pTargetPlot->getY()) > airRange())
	{
		return false;
	}
	if (pTargetPlot->isOwned() && !atWar(pTargetPlot->getTeam(), getTeam()))
	{
		return false;
	}
	return pTargetPlot->getPlotCity() != NULL;
}


bool CvUnit::airBomb2(int iX, int iY)
{
	PROFILE_EXTRA_FUNC();
	CvCity* pCity;
	CvPlot* pPlot;
	CvWString szBuffer;
	int build, iI, iAttempts, iMaxAttempts;
	bool bNoTarget = true;
	bool abTech1 = false;
	bool abTech2 = false;
	CLinkList<int> buildingList;

	if (!canAirBomb2At(plot(), iX, iY))
	{
		return false;
	}
	pPlot = GC.getMap().plot(iX, iY);
	if (interceptTest(pPlot))
	{
		return true;
	}

	pCity = pPlot->getPlotCity();

	for (iI = 0; iI < GC.getNumTechInfos(); iI++)
	{
		if (GC.getTechInfo((TechTypes)iI).getDCMAirBombTech1())
		{
            if (GET_TEAM(GET_PLAYER(getOwner()).getTeam()).isHasTech((TechTypes)iI))
			{
				abTech1 = true;
			}
		}
		if (GC.getTechInfo((TechTypes)iI).getDCMAirBombTech2())
		{
            if (GET_TEAM(GET_PLAYER(getOwner()).getTeam()).isHasTech((TechTypes)iI))
			{
				abTech2 = true;
			}
		}
	}
	if (pCity != NULL)
	{
		buildingList.clear();
		for (iI = 0; iI < GC.getNumBuildingInfos(); iI++)
		{
			if (GC.getBuildingInfo((BuildingTypes)iI).getDCMAirbombMission() == 2)
			{
				buildingList.insertAtEnd(iI);
			}
		}
		if (buildingList.getLength() > 0)
		{
			iI = GC.getGame().getSorenRandNum(buildingList.getLength(), "Airbomb building");
			build = buildingList.nodeNum(iI)->m_data;
			if (pCity->isActiveBuilding((BuildingTypes)build))
			{
				bNoTarget = false;
			}
			if (abTech1)
			{
				iAttempts = 0;
				if (abTech2)
				{
					iMaxAttempts = 8;
				}
				else
				{
					iMaxAttempts = 4;
				}
				while (bNoTarget)
				{
					iAttempts++;
					iI = GC.getGame().getSorenRandNum(buildingList.getLength(), "Airbomb building");
					build = buildingList.nodeNum(iI)->m_data;
					if (pCity->isActiveBuilding((BuildingTypes)build) || iAttempts > iMaxAttempts)
					{
						bNoTarget = false;
					}
				}
			}
			if (pCity->isActiveBuilding((BuildingTypes)build))
			{
				bNoTarget = false;
				changeExperience(GC.getDefineINT("MIN_EXPERIENCE_PER_COMBAT"), maxXPValue(NULL, pCity->isHominid()), true, pCity->getOwner() == getOwner());

				pCity->changeHasBuilding((BuildingTypes)build, false);
				{

					szBuffer = gDLL->getText("TXT_KEY_MISC_ENEMY_AIRBOMB2SUCCESS", GC.getBuildingInfo((BuildingTypes)build).getTextKeyWide(), pCity->getNameKey());
					AddDLLMessage(pCity->getOwner(), false, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_BOMBARDED", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_RED(), pCity->getX(), pCity->getY(), true, true);
					szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_AIRBOMB2SUCCESS", GC.getBuildingInfo((BuildingTypes)build).getTextKeyWide(), pCity->getNameKey());
					AddDLLMessage(getOwner(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_BOMBARD", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_GREEN(), pCity->getX(), pCity->getY(), true, true);
				}

#ifdef OUTBREAKS_AND_AFFLICTIONS
				//Afflict
				int iDistanceAttackCommunicability = 0;
				bool bAffliction = false;
				if (GC.getGame().isOption(GAMEOPTION_COMBAT_OUTBREAKS_AND_AFFLICTIONS))
				{
					for (int iI = 0; iI < GC.getNumPromotionLineInfos(); iI++)
					{
						if (GC.getPromotionLineInfo((PromotionLineTypes)iI).isAffliction() && !GC.getPromotionLineInfo((PromotionLineTypes)iI).isCritical())
						{
							//Distance Communicability
							iDistanceAttackCommunicability = getDistanceAttackCommunicability((PromotionLineTypes)iI);
							bool bDistAttComm = iDistanceAttackCommunicability > 0;
							PromotionLineTypes eAfflictionLine = ((PromotionLineTypes)iI);
							bool bAffonAtt = (hasAfflictOnAttackType(eAfflictionLine) && isAfflictOnAttackTypeDistance(eAfflictionLine));
							if (bDistAttComm || bAffonAtt)
							{
								bAffliction = true;
								foreach_(CvUnit* pLoopUnit, pPlot->units())
								{
									if (bDistAttComm)
									{
										if (pLoopUnit->checkContractDisease(eAfflictionLine, iDistanceAttackCommunicability))
										{
											pLoopUnit->afflict(eAfflictionLine);
										}
										if (pCity != NULL)
										{
											pCity->changePromotionLineAfflictionAttackCommunicability(eAfflictionLine, iDistanceAttackCommunicability);
										}
									}
									if (bAffonAtt)
									{
										int iAttackersPoisonChance = getAfflictOnAttackTypeProbability(eAfflictionLine) - pLoopUnit->fortitudeTotal() - pLoopUnit->getUnitAfflictionTolerance(eAfflictionLine);

										if (GC.getGame().getSorenRandNum(100, "AttackersPoisonRoll") < iAttackersPoisonChance)
										{
											pLoopUnit->afflict(eAfflictionLine, true, this);
										}
									}
								}
							}
						}
					}
				}
#endif // OUTBREAKS_AND_AFFLICTIONS
			}
			else
			{

				szBuffer = gDLL->getText("TXT_KEY_MISC_ENEMY_AIRBOMB2FAIL", pCity->getNameKey());
				AddDLLMessage(pCity->getOwner(), false, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_BOMBARDED", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_RED(), pCity->getX(), pCity->getY(), true, true);
				szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_AIRBOMB2FAIL", pCity->getNameKey());
				AddDLLMessage(getOwner(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_BOMBARD", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_GREEN(), pCity->getX(), pCity->getY(), true, true);
			}
		}
		if(bNoTarget)
		{
			if(pCity->getPopulation() > 1)
			{
				if(GC.getGame().getSorenRandNum(5, "Airbomb population") < 2)
				{
					pCity->changePopulation(-1);

					{

						szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_AIRBOMB_POP");
						AddDLLMessage(getOwner(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_BOMBARD", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_GREEN(), pCity->getX(), pCity->getY(), true, true);
						szBuffer = gDLL->getText("TXT_KEY_MISC_ENEMY_AIRBOMB_POP");
						AddDLLMessage(pCity->getOwner(), false, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_BOMBARDED", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_RED(), pCity->getX(), pCity->getY(), true, true);
					}
				}
			}
		}
	}
	setReconPlot(pPlot);
	setMadeAttack(true);
	changeMoves(GC.getMOVE_DENOMINATOR());

	addMission(CvAirMissionDefinition(MISSION_AIRBOMB, pPlot, this));

	if (isSuicide())
	{
		kill(true);
	}
	return true;
}

bool CvUnit::canAirBomb3() const
{
	if (!GC.isDCM_AIR_BOMBING())
	{
		return false;
	}
	if (!m_pUnitInfo->getDCMAirBomb3())
	{
		return false;
	}
	if (getDomainType() != DOMAIN_AIR)
	{
		return false;
	}
	if (getAirBombBaseRate() == 0)
	{
		return false;
	}
	if (isMadeAttack())
	{
		return false;
	}
	return true;
}


bool CvUnit::canAirBomb3At(const CvPlot* pPlot, int iX, int iY) const
{
	if (!canAirBomb3())
	{
		return false;
	}
	const CvPlot* pTargetPlot = GC.getMap().plot(iX, iY);
	if (plotDistance(pPlot->getX(), pPlot->getY(), pTargetPlot->getX(), pTargetPlot->getY()) > airRange())
	{
		return false;
	}
	if (pTargetPlot->isOwned())
	{
		if (!atWar(pTargetPlot->getTeam(), getTeam()))
		{
			return false;
		}
	}
	const CvCity* pCity = pTargetPlot->getPlotCity();
	if (pCity == NULL)
	{
		return false;
	}
	return true;
}


bool CvUnit::airBomb3(int iX, int iY)
{
	PROFILE_EXTRA_FUNC();
	CvCity* pCity;
	CvPlot* pPlot;
	CvWString szBuffer;
	int build, iI, iAttempts, iMaxAttempts;
	bool bNoTarget = true;
	bool abTech1 = false;
	bool abTech2 = false;
	CLinkList<int> buildingList;
	bool bSuccess = false;

	if (!canAirBomb3At(plot(), iX, iY))
	{
		return false;
	}
	pPlot = GC.getMap().plot(iX, iY);
	if (interceptTest(pPlot))
	{
		return true;
	}

	pCity = pPlot->getPlotCity();

	for (iI = 0; iI < GC.getNumTechInfos(); iI++)
	{
		if (GC.getTechInfo((TechTypes)iI).getDCMAirBombTech1())
		{
            if (GET_TEAM(GET_PLAYER(getOwner()).getTeam()).isHasTech((TechTypes)iI))
			{
				abTech1 = true;
			}
		}
		if (GC.getTechInfo((TechTypes)iI).getDCMAirBombTech2())
		{
            if (GET_TEAM(GET_PLAYER(getOwner()).getTeam()).isHasTech((TechTypes)iI))
			{
				abTech2 = true;
			}
		}
	}
	if (pCity != NULL)
	{
		buildingList.clear();
		for (iI = 0; iI < GC.getNumBuildingInfos(); iI++)
		{
			if (GC.getBuildingInfo((BuildingTypes)iI).getDCMAirbombMission() == 3)
			{
				buildingList.insertAtEnd(iI);
			}
		}
		if (buildingList.getLength() > 0)
		{
			iI = GC.getGame().getSorenRandNum(buildingList.getLength(), "Airbomb building");
			build = buildingList.nodeNum(iI)->m_data;
			if (pCity->isActiveBuilding((BuildingTypes)build))
			{
				bNoTarget = false;
			}
			if (abTech1)
			{
				iAttempts = 0;
				if (abTech2)
				{
					iMaxAttempts = 8;
				}
				else
				{
					iMaxAttempts = 4;
				}
				while (bNoTarget)
				{
					iAttempts++;
					iI = GC.getGame().getSorenRandNum(buildingList.getLength(), "Airbomb building");
					build = buildingList.nodeNum(iI)->m_data;
					if (pCity->isActiveBuilding((BuildingTypes)build) || iAttempts > iMaxAttempts)
					{
						bNoTarget = false;
					}
				}
			}
			if (pCity->isActiveBuilding((BuildingTypes)build))
			{
				pCity->changeHasBuilding((BuildingTypes)build, false);

				changeExperience(GC.getDefineINT("MIN_EXPERIENCE_PER_COMBAT"), maxXPValue(NULL, pCity->isHominid()), true, pCity->getOwner() == getOwner());
				{

					szBuffer = gDLL->getText("TXT_KEY_MISC_ENEMY_AIRBOMB3SUCCESS", GC.getBuildingInfo((BuildingTypes)build).getTextKeyWide(), pCity->getNameKey());
					AddDLLMessage(pCity->getOwner(), false, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_BOMBARDED", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_RED(), pCity->getX(), pCity->getY(), true, true);
					szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_AIRBOMB3SUCCESS", GC.getBuildingInfo((BuildingTypes)build).getTextKeyWide(), pCity->getNameKey());
					AddDLLMessage(getOwner(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_BOMBARD", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_GREEN(), pCity->getX(), pCity->getY(), true, true);
				}
				bSuccess = true;
			}
			else
			{

				szBuffer = gDLL->getText("TXT_KEY_MISC_ENEMY_AIRBOMB3FAIL", pCity->getNameKey());
				AddDLLMessage(pCity->getOwner(), false, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_BOMBARDED", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_RED(), pCity->getX(), pCity->getY(), true, true);
				szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_AIRBOMB3FAIL", pCity->getNameKey());
				AddDLLMessage(getOwner(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_BOMBARD", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_GREEN(), pCity->getX(), pCity->getY(), true, true);
			}
		}
		if(bNoTarget)
		{
			if(pCity->getPopulation() > 1)
			{
				if(GC.getGame().getSorenRandNum(5, "Airbomb population") < 1)
				{
					pCity->changePopulation(-1);

					{

						szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_AIRBOMB_POP");
						AddDLLMessage(getOwner(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_BOMBARD", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_GREEN(), pCity->getX(), pCity->getY(), true, true);
						szBuffer = gDLL->getText("TXT_KEY_MISC_ENEMY_AIRBOMB_POP");
						AddDLLMessage(pCity->getOwner(), false, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_BOMBARDED", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_RED(), pCity->getX(), pCity->getY(), true, true);
					}
					bSuccess = true;
				}
			}
		}
	}
	setReconPlot(pPlot);
	setMadeAttack(true);
	changeMoves(GC.getMOVE_DENOMINATOR());
#ifdef OUTBREAKS_AND_AFFLICTIONS
	if (bSuccess)
	{
		//Afflict
		int iDistanceAttackCommunicability = 0;
		bool bAffliction = false;
		if (GC.getGame().isOption(GAMEOPTION_COMBAT_OUTBREAKS_AND_AFFLICTIONS))
		{
			for (int iI = 0; iI < GC.getNumPromotionLineInfos(); iI++)
			{
				if (GC.getPromotionLineInfo((PromotionLineTypes)iI).isAffliction() && !GC.getPromotionLineInfo((PromotionLineTypes)iI).isCritical())
				{
					//Distance Communicability
					iDistanceAttackCommunicability = getDistanceAttackCommunicability((PromotionLineTypes)iI);
					bool bDistAttComm = iDistanceAttackCommunicability > 0;
					PromotionLineTypes eAfflictionLine = ((PromotionLineTypes)iI);
					bool bAffonAtt = (hasAfflictOnAttackType(eAfflictionLine) && isAfflictOnAttackTypeDistance(eAfflictionLine));
					if (bDistAttComm || bAffonAtt)
					{
						bAffliction = true;
						foreach_(CvUnit* pLoopUnit, pPlot->units())
						{
							if (bDistAttComm)
							{
								if (pLoopUnit->checkContractDisease(eAfflictionLine, iDistanceAttackCommunicability))
								{
									pLoopUnit->afflict(eAfflictionLine);
								}
								if (pCity != NULL)
								{
									pCity->changePromotionLineAfflictionAttackCommunicability(eAfflictionLine, iDistanceAttackCommunicability);
								}
							}
							if (bAffonAtt)
							{
								int iAttackersPoisonChance = getAfflictOnAttackTypeProbability(eAfflictionLine) - pLoopUnit->fortitudeTotal() - pLoopUnit->getUnitAfflictionTolerance(eAfflictionLine);

								if (GC.getGame().getSorenRandNum(100, "AttackersPoisonRoll") < iAttackersPoisonChance)
								{
									pLoopUnit->afflict(eAfflictionLine, true, this);
								}
							}
						}
					}
				}
			}
		}
	}
#endif // OUTBREAKS_AND_AFFLICTIONS
	addMission(CvAirMissionDefinition(MISSION_AIRBOMB, pPlot, this));

	if (isSuicide())
	{
		kill(true);
	}
	return true;
}

bool CvUnit::canAirBomb4() const
{
	if (!GC.isDCM_AIR_BOMBING())
	{
		return false;
	}
	if (!m_pUnitInfo->getDCMAirBomb4())
	{
		return false;
	}
	if (getDomainType() != DOMAIN_AIR)
	{
		return false;
	}
	if (getAirBombBaseRate() == 0)
	{
		return false;
	}
	if (isMadeAttack())
	{
		return false;
	}
	return true;
}


bool CvUnit::canAirBomb4At(const CvPlot* pPlot, int iX, int iY) const
{
	PROFILE_EXTRA_FUNC();
	if (!canAirBomb4())
	{
		return false;
	}
	const CvPlot* pTargetPlot = GC.getMap().plot(iX, iY);
	if (plotDistance(pPlot->getX(), pPlot->getY(), pTargetPlot->getX(), pTargetPlot->getY()) > airRange())
	{
		return false;
	}
	if (pTargetPlot->isOwned())
	{
		if (!atWar(pTargetPlot->getTeam(), getTeam()))
		{
			return false;
		}
	}
	if (pTargetPlot->getPlotCity() != NULL
	|| (pTargetPlot->getImprovementType() != NO_IMPROVEMENT && GC.getImprovementInfo(pTargetPlot->getImprovementType()).isActsAsCity()))
	{
		for (int iI = 0; iI < MAX_PLAYERS; ++iI)
		{
			if (atWar(GET_PLAYER((PlayerTypes)iI).getTeam(), getTeam()))
			{
				if (algo::any_of(GET_PLAYER((PlayerTypes)iI).units(),
					CvUnit::fn::plot() == pTargetPlot && CvUnit::fn::getDomainType() == DOMAIN_SEA))
				{
					return true;
				}
			}
		}
	}
	return false;
}


bool CvUnit::airBomb4(int iX, int iY)
{
	PROFILE_EXTRA_FUNC();
	CvUnit* pUnit;
	CvWString szBuffer;
	bool bSuccess = false, bNoTarget = true;
	int iDamage, iUnitDamage;

	if (!canAirBomb4At(plot(), iX, iY))
	{
		return false;
	}
	CvPlot* pPlot = GC.getMap().plot(iX, iY);
	if (interceptTest(pPlot))
	{
		return true;
	}

	CvCity* pCity = pPlot->getPlotCity();
	int iCount = algo::count_if(pPlot->units(), CvUnit::fn::getDomainType() == DOMAIN_SEA);
	iCount = (GC.getGame().getSorenRandNum(iCount, "Choose ship") + 1);
	CLLNode<IDInfo>* pUnitNode = pPlot->headUnitNode();
	while (iCount > 0)
	{
		CvUnit* pLoopUnit = ::getUnit(pUnitNode->m_data);
		pUnitNode = pPlot->nextUnitNode(pUnitNode);
		if (pLoopUnit->getDomainType() == DOMAIN_SEA)
		{
			iCount--;
			pUnit = pLoopUnit;
		}
	}

	{
		if (pUnit != NULL)
		{
			bNoTarget = false;
			changeExperience(GC.getDefineINT("MIN_EXPERIENCE_PER_COMBAT"), maxXPValue(pUnit), true, pPlot->getOwner() == getOwner());

			iDamage = (airCombatDamage(pUnit) * 2);
			iUnitDamage = std::max(pUnit->getDamage(), std::min((pUnit->getDamage() + iDamage), airCombatLimit(pUnit)));

			{

				szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_ARE_ATTACKED_BY_AIR", pUnit->getNameKey(), getNameKey(), -(((iUnitDamage - pUnit->getDamage()) * 100) / pUnit->getMaxHP()));
				AddDLLMessage(pUnit->getOwner(), false, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_AIR_ATTACK", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_RED(), pPlot->getX(), pPlot->getY(), true, true);
				szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_ATTACK_BY_AIR", getNameKey(), pUnit->getNameKey(), -(((iUnitDamage - pUnit->getDamage()) * 100) / pUnit->getMaxHP()));
				AddDLLMessage(getOwner(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_AIR_ATTACKED", MESSAGE_TYPE_INFO, pUnit->getButton(), GC.getCOLOR_GREEN(), pPlot->getX(), pPlot->getY(), true, true);
			}
			bSuccess = true;
			pUnit->setDamage(iUnitDamage, getOwner());
			//TB Combat Mod begin
			if (dealsColdDamage())
			{
				pUnit->setColdDamage(iUnitDamage);
			}
			//TB Combat mod end
			if (GC.getGame().getSorenRandNum(100, "Spin the dice") < 50)
			{
				pUnit->setDamage(pUnit->getMaxHP());

				{

					szBuffer = gDLL->getText("TXT_KEY_MISC_ENEMYSINK_AIRBOMB4SUCCESS", pUnit->getNameKey());
					AddDLLMessage(pUnit->getOwner(), false, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_BOMBARDED", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_RED(), pPlot->getX(), pPlot->getY(), true, true);
					szBuffer = gDLL->getText("TXT_KEY_MISC_YOUSINK_AIRBOMB4SUCCESS", pUnit->getNameKey());
					AddDLLMessage(getOwner(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_BOMBARD", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_GREEN(), pPlot->getX(), pPlot->getY(), true, true);
				}
			}
		}
		else
		{

			szBuffer = gDLL->getText("TXT_KEY_MISC_ENEMY_AIRBOMB4FAIL", pCity->getNameKey());
			AddDLLMessage(pCity->getOwner(), false, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_BOMBARDED", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_RED(), pPlot->getX(), pPlot->getY(), true, true);
			szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_AIRBOMB4FAIL", pCity->getNameKey());
			AddDLLMessage(getOwner(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_BOMBARD", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_GREEN(), pPlot->getX(), pPlot->getY(), true, true);
		}
		if(bNoTarget)
		{
			if (pCity != NULL)
			{
				if(pCity->getPopulation() > 1)
				{
					if(GC.getGame().getSorenRandNum(5, "Airbomb population") < 1)
					{
						pCity->changePopulation(-1);
						bSuccess = true;

						{

							szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_AIRBOMB_POP");
							AddDLLMessage(getOwner(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_BOMBARD", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_GREEN(), pPlot->getX(), pPlot->getY(), true, true);
							szBuffer = gDLL->getText("TXT_KEY_MISC_ENEMY_AIRBOMB_POP");
							AddDLLMessage(pCity->getOwner(), false, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_BOMBARDED", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_RED(), pPlot->getX(), pPlot->getY(), true, true);
						}
					}
				}
			}
		}
	}
	setReconPlot(pPlot);
	setMadeAttack(true);
	changeMoves(GC.getMOVE_DENOMINATOR());
#ifdef OUTBREAKS_AND_AFFLICTIONS
	if (bSuccess)
	{
		//Afflict
		int iDistanceAttackCommunicability = 0;
		bool bAffliction = false;
		if (GC.getGame().isOption(GAMEOPTION_COMBAT_OUTBREAKS_AND_AFFLICTIONS))
		{
			for (int iI = 0; iI < GC.getNumPromotionLineInfos(); iI++)
			{
				if (GC.getPromotionLineInfo((PromotionLineTypes)iI).isAffliction() && !GC.getPromotionLineInfo((PromotionLineTypes)iI).isCritical())
				{
					//Distance Communicability
					iDistanceAttackCommunicability = getDistanceAttackCommunicability((PromotionLineTypes)iI);
					bool bDistAttComm = iDistanceAttackCommunicability > 0;
					PromotionLineTypes eAfflictionLine = ((PromotionLineTypes)iI);
					bool bAffonAtt = (hasAfflictOnAttackType(eAfflictionLine) && isAfflictOnAttackTypeDistance(eAfflictionLine));
					if (bDistAttComm || bAffonAtt)
					{
						bAffliction = true;
						foreach_(CvUnit* pLoopUnit, pPlot->units())
						{
							if (bDistAttComm)
							{
								if (pLoopUnit->checkContractDisease(eAfflictionLine, iDistanceAttackCommunicability))
								{
									pLoopUnit->afflict(eAfflictionLine);
								}
								if (pCity != NULL)
								{
									pCity->changePromotionLineAfflictionAttackCommunicability(eAfflictionLine, iDistanceAttackCommunicability);
								}
							}
							if (bAffonAtt)
							{
								int iAttackersPoisonChance = getAfflictOnAttackTypeProbability(eAfflictionLine) - pLoopUnit->fortitudeTotal() - pLoopUnit->getUnitAfflictionTolerance(eAfflictionLine);

								if (GC.getGame().getSorenRandNum(100, "AttackersPoisonRoll") < iAttackersPoisonChance)
								{
									pLoopUnit->afflict(eAfflictionLine, true, this);
								}
							}
						}
					}
				}
			}
		}
	}
#endif // OUTBREAKS_AND_AFFLICTIONS
	addMission(CvAirMissionDefinition(MISSION_AIRBOMB, pPlot, this));

	if (isSuicide())
	{
		kill(true);
	}
	return true;
}

bool CvUnit::canAirBomb5() const
{
	if (!GC.isDCM_AIR_BOMBING())
	{
		return false;
	}
	if (!m_pUnitInfo->getDCMAirBomb5())
	{
		return false;
	}
	if (getDomainType() != DOMAIN_AIR)
	{
		return false;
	}
	if (getAirBombBaseRate() == 0)
	{
		return false;
	}
	if (isMadeAttack())
	{
		return false;
	}
	return true;
}


bool CvUnit::canAirBomb5At(const CvPlot* pPlot, int iX, int iY) const
{
	if (!canAirBomb5())
	{
		return false;
	}
	const CvPlot* pTargetPlot = GC.getMap().plot(iX, iY);
	if (plotDistance(pPlot->getX(), pPlot->getY(), pTargetPlot->getX(), pTargetPlot->getY()) > airRange())
	{
		return false;
	}
	if (pTargetPlot->isOwned())
	{
		if (!atWar(pTargetPlot->getTeam(), getTeam()))
		{
			return false;
		}
	}
	const CvCity* pCity = pTargetPlot->getPlotCity();
	if (pCity == NULL)
	{
		return false;
	}
	return true;
}


bool CvUnit::airBomb5(int iX, int iY)
{
	PROFILE_EXTRA_FUNC();
	CvCity* pCity;
	CvPlot* pPlot;
	CvWString szBuffer;
	bool bNoTarget = true;
	bool bSuccess = false;

	if (!canAirBomb5At(plot(), iX, iY))
	{
		return false;
	}
	pPlot = GC.getMap().plot(iX, iY);
	if (interceptTest(pPlot))
	{
		return true;
	}

	pCity = pPlot->getPlotCity();

	if (pCity != NULL)
	{
		if (GC.getGame().getSorenRandNum(100, "Airbomb") < 50)
		{
			bNoTarget = false;
			pCity->setProductionProgress(pCity->getProductionProgress() / 2);
			bSuccess = true;
			{

				szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_AIRBOMB5SUCCESS", pCity->getNameKey());
				AddDLLMessage(getOwner(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_BOMBARD", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_GREEN(), pCity->getX(), pCity->getY(), true, true);
				szBuffer = gDLL->getText("TXT_KEY_MISC_ENEMY_AIRBOMB5SUCCESS", pCity->getNameKey());
				AddDLLMessage(pCity->getOwner(), false, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_BOMBARDED", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_RED(), pCity->getX(), pCity->getY(), true, true);
			}
			changeExperience(GC.getDefineINT("MIN_EXPERIENCE_PER_COMBAT"), maxXPValue(NULL, pCity->isHominid()), true, pCity->getOwner() == getOwner());
		}
		else
		{

			szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_AIRBOMB5FAIL", pCity->getNameKey());
			AddDLLMessage(getOwner(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_BOMBARD", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_GREEN(), pCity->getX(), pCity->getY(), true, true);
			szBuffer = gDLL->getText("TXT_KEY_MISC_ENEMY_AIRBOMB5FAIL", pCity->getNameKey());
			AddDLLMessage(pCity->getOwner(), false, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_BOMBARDED", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_RED(), pCity->getX(), pCity->getY(), true, true);
		}
		if(bNoTarget)
		{
			if(pCity->getPopulation() > 1)
			{
				if(GC.getGame().getSorenRandNum(5, "Airbomb population") < 1)
				{
					pCity->changePopulation(-1);
					bSuccess = true;

					{

						szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_AIRBOMB_POP");
						AddDLLMessage(getOwner(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_BOMBARD", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_GREEN(), pCity->getX(), pCity->getY(), true, true);
						szBuffer = gDLL->getText("TXT_KEY_MISC_ENEMY_AIRBOMB_POP");
						AddDLLMessage(pCity->getOwner(), false, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_BOMBARDED", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_RED(), pCity->getX(), pCity->getY(), true, true);
					}
				}
			}
		}
	}
	setReconPlot(pPlot);
	setMadeAttack(true);
	changeMoves(GC.getMOVE_DENOMINATOR());
#ifdef OUTBREAKS_AND_AFFLICTIONS
	if (bSuccess)
	{
		//Afflict
		int iDistanceAttackCommunicability = 0;
		bool bAffliction = false;
		if (GC.getGame().isOption(GAMEOPTION_COMBAT_OUTBREAKS_AND_AFFLICTIONS))
		{
			for (int iI = 0; iI < GC.getNumPromotionLineInfos(); iI++)
			{
				if (GC.getPromotionLineInfo((PromotionLineTypes)iI).isAffliction() && !GC.getPromotionLineInfo((PromotionLineTypes)iI).isCritical())
				{
					//Distance Communicability
					iDistanceAttackCommunicability = getDistanceAttackCommunicability((PromotionLineTypes)iI);
					bool bDistAttComm = iDistanceAttackCommunicability > 0;
					PromotionLineTypes eAfflictionLine = ((PromotionLineTypes)iI);
					bool bAffonAtt = (hasAfflictOnAttackType(eAfflictionLine) && isAfflictOnAttackTypeDistance(eAfflictionLine));
					if (bDistAttComm || bAffonAtt)
					{
						bAffliction = true;
						foreach_(CvUnit* pLoopUnit, pPlot->units())
						{
							if (bDistAttComm)
							{
								if (pLoopUnit->checkContractDisease(eAfflictionLine, iDistanceAttackCommunicability))
								{
									pLoopUnit->afflict(eAfflictionLine);
								}
								if (pCity != NULL)
								{
									pCity->changePromotionLineAfflictionAttackCommunicability(eAfflictionLine, iDistanceAttackCommunicability);
								}
							}
							if (bAffonAtt)
							{
								int iAttackersPoisonChance = getAfflictOnAttackTypeProbability(eAfflictionLine) - pLoopUnit->fortitudeTotal() - pLoopUnit->getUnitAfflictionTolerance(eAfflictionLine);

								if (GC.getGame().getSorenRandNum(100, "AttackersPoisonRoll") < iAttackersPoisonChance)
								{
									pLoopUnit->afflict(eAfflictionLine, true, this);
								}
							}
						}
					}
				}
			}
		}
	}
#endif // OUTBREAKS_AND_AFFLICTIONS
	addMission(CvAirMissionDefinition(MISSION_AIRBOMB, pPlot, this));

	if (isSuicide())
	{
		kill(true);
	}
	return true;
}
// ! Dale - AB: Bombing

// Dale - RB: Field Bombard
bool CvUnit::canRBombard(bool bEver) const
{
	if (!GC.isDCM_RANGE_BOMBARD())
	{
		return false;
	}

	//No longer evaluates the unit itself so much as its Combat Classes (the weapon ones are the source of the ability)
	if (getBaseDCMBombRange() < 1)
	{
        return false;
	}

	if (isOnlyDefensive() && !hasRBombardForceAbility())
	{
		return false;
	}

	if (getDomainType() == DOMAIN_AIR)
	{
		return false;
	}

	if (isMadeAttack() && !bEver)
	{
		return false;
	}

	if (isCargo() && !bEver)
	{
		return false;
	}

	return true;
}

bool CvUnit::canBombardAtRanged(const CvPlot* pPlot, int iX, int iY) const
{
	if (!canRBombard() || iX < 0 || iY < 0)
	{
		return false;
	}
	CvPlot* pTargetPlot = GC.getMap().plot(iX, iY);

	if (plotDistance(pPlot->getX(), pPlot->getY(), pTargetPlot->getX(), pTargetPlot->getY()) > getDCMBombRange())
	{
		return false;
	}
	const bool bNotMyTerritory = pTargetPlot->getTeam() != getTeam();

	if (pTargetPlot->isOwned() && bNotMyTerritory && !atWar(pTargetPlot->getTeam(), getTeam()))
	{
		return false;
	}

	if (pTargetPlot->getNumVisiblePotentialEnemyDefenders(this) > 0)
	{
		return true;
	}
	if (bNotMyTerritory)
	{
		if (pTargetPlot->isImprovementDestructible())
		{
			return true;
		}
		CvCity* pCity = pTargetPlot->getPlotCity();

		if (pCity != NULL && pCity->isBombardable(this))
		{
			return true;
		}
	}
	return false;
}

// RevolutionDCM - significant chances to this function
bool CvUnit::bombardRanged(int iX, int iY, bool sAttack)
{
	if (!canBombardAtRanged(plot(), iX, iY))
	{
		return false;
	}
	CvPlot* pPlot = GC.getMap().plot(iX, iY);

	if (pPlot == NULL)
	{
		return false;
	}
	CvWString szBuffer;

	CvUnit* pLoopUnit = NULL;
	CvCity* pCity = pPlot->getPlotCity();

	if (pCity != NULL)
	{
		pLoopUnit = pPlot->getBestDefender(NO_PLAYER, getOwner(), this, true);
		if (pLoopUnit != NULL)
		{
			//TB Combat Mod adjustment
			//We have Bombard Defense Values in the city and it would be best if it came into play rather than a static modifier
			//Also... why would we want a city that still has better stronger defenses to be MORE vulnerable to bombard attack??? Eugh...
			const int iBombardDefense =
			(
				pCity->getBuildingBombardDefense()
				*
				pCity->getDefenseModifier(false) / std::max(1, pCity->getTotalDefense(false))
			);
			// standard odds made worse if greater than one tile out
			const int odds = 100 + iBombardDefense + (plotDistance(getX(), getY(), pPlot->getX(), pPlot->getY()) - 1) * 30;

			// RevolutionDCM - change proposal to ranged bombardment. Only collateral damage can be issued.
			if (GC.getGame().getSorenRandNum(odds, "Bombard Accuracy") <= getDCMBombAccuracy())
			{
				{

					szBuffer = gDLL->getText("TXT_KEY_HAS_RANGED_BOMBARD_ATTACKED", getNameKey());
					AddDLLMessage(getOwner(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_BOMBARDED", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_GREEN(), getX(), getY());
					szBuffer = gDLL->getText("TXT_KEY_HAS_BEEN_RANGED_BOMBARD_ATTACKED", getNameKey());
					AddDLLMessage(pLoopUnit->getOwner(), false, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_BOMBARDED", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_RED(), getX(), getY(), true, true);
				}
				rBombardCombat(pPlot, pLoopUnit);
				changeExperience100(100, -1, true, pLoopUnit->getOwner() == getOwner());
			}
			else
			{

				szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_BOMB_MISSED", getNameKey());
				AddDLLMessage(getOwner(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_BOMBARDED", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_RED(), getX(), getY());
				szBuffer = gDLL->getText("TXT_KEY_MISC_ENEMY_BOMB_MISSED", getNameKey());
				AddDLLMessage(pLoopUnit->getOwner(), false, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_BOMBARDED", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_GREEN(), getX(), getY(), true, true);
			}
		}
	}
	else
	{
		// Field bombard case.
		pLoopUnit = pPlot->getBestDefender(NO_PLAYER, getOwner(), this, true);
		if (pLoopUnit != NULL)
		{
			// standard odds made worse if greater than one tile out
			const int odds = 100 + 30*(plotDistance(getX(), getY(), pPlot->getX(), pPlot->getY()) - 1);

			//RevolutionDCM - change proposal to ranged bombardment. Only collateral damage can be issued.
			if (GC.getGame().getSorenRandNum(odds, "Bombard Accuracy") <= getDCMBombAccuracy())
			{
				{

					szBuffer = gDLL->getText("TXT_KEY_HAS_RANGED_BOMBARD_ATTACKED", getNameKey());
					AddDLLMessage(getOwner(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_BOMBARDED", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_GREEN(), getX(), getY());
					szBuffer = gDLL->getText("TXT_KEY_HAS_BEEN_RANGED_BOMBARD_ATTACKED", getNameKey());
					AddDLLMessage(pLoopUnit->getOwner(), false, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_BOMBARDED", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_RED(), getX(), getY(), true, true);
				}
				rBombardCombat(pPlot, pLoopUnit);
				changeExperience100(100, -1, true, pLoopUnit->getOwner() == getOwner());
			}
			else
			{

				szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_BOMB_MISSED", getNameKey());
				AddDLLMessage(getOwner(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_BOMBARDED", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_RED(), getX(), getY());
				szBuffer = gDLL->getText("TXT_KEY_MISC_ENEMY_BOMB_MISSED", getNameKey());
				AddDLLMessage(pLoopUnit->getOwner(), false, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_BOMBARDED", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_GREEN(), getX(), getY(), true, true);
			}
		}
		// Plot bombardment
		else if (pPlot->getImprovementType() != NO_IMPROVEMENT)
		{
			if (
				GC.getGame().getSorenRandNum(getBombardRate(), "Bomb - Offense")
				>=
				GC.getGame().getSorenRandNum(GC.getImprovementInfo(pPlot->getImprovementType()).getAirBombDefense(), "Bomb - Defense")
			)
			{
				{

					szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_UNIT_DESTROYED_IMP", getNameKey(), GC.getImprovementInfo(pPlot->getImprovementType()).getTextKeyWide());
					AddDLLMessage(getOwner(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_PILLAGE", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_GREEN(), pPlot->getX(), pPlot->getY());
					if (pPlot->isOwned())
					{
						szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_IMP_WAS_DESTROYED", GC.getImprovementInfo(pPlot->getImprovementType()).getTextKeyWide(), getNameKey(), GET_PLAYER(getOwner()).getCivilizationAdjectiveKey());
						AddDLLMessage(pPlot->getOwner(), false, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_PILLAGE", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_RED(), pPlot->getX(), pPlot->getY(), true, true);
					}
				}
				pPlot->setImprovementType(GC.getImprovementInfo(pPlot->getImprovementType()).getImprovementPillage());
				changeExperience100(100, -1, true);
			}
			else
			{

				szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_UNIT_FAIL_DESTROY_IMP", getNameKey(), GC.getImprovementInfo(pPlot->getImprovementType()).getTextKeyWide());
				AddDLLMessage(getOwner(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_BOMB_FAILS", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_RED(), pPlot->getX(), pPlot->getY());
			}
		}
	}

	if (!sAttack)
	{
		setMadeAttack(true);
		changeMoves(GC.getMOVE_DENOMINATOR());
	}

	addMission(CvMissionDefinition(MISSION_BOMBARD, pPlot, this, pLoopUnit, GC.getMissionInfo(MISSION_RBOMBARD).getTime()* gDLL->getSecsPerTurn()));

	return true;
}

// RevolutionDCM - ranged bombard
// Estimate if a unit stack is worth range bombarding
bool CvUnit::isRbombardable(int iMinStack) const
{
	PROFILE_EXTRA_FUNC();
	int collateralCount = 0;
	int averageDamage = 0;
	int averageProtection = 0;
	int seigeCount = 0;

	CvUnit* nextUnit = NULL;
	int unitCount = plot()->getNumUnits();
	if (unitCount >= iMinStack)
	{
		for (int i = 0; i < unitCount; i++)
		{
			nextUnit = plot()->getUnitByIndex(i);
			if (nextUnit != NULL)
			{
				if (nextUnit->canRBombard())
				{
					seigeCount++;
				}
				averageDamage += nextUnit->getDamage();
				//TB Combat Mods begin (fortified collateral defense) Reference to iCollatDef was nextUnit->getCollateralDamageProtection()
				//int iFortDef = nextUnit->fortifyCollateralDefenseModifier();
				//int iFortDefzero = iFortDef < 0 ? 0 : iFortDef;
				int iStdDef = nextUnit->getCollateralDamageProtection();
				int iUncheckedDef = /*iFortDefzero +*/ iStdDef;
				int iUncheckedDefzero = iUncheckedDef < 0 ? 0 : iUncheckedDef;
				int iCollatDef = iUncheckedDefzero > 100 ? 100 : iUncheckedDefzero;
				averageProtection += iCollatDef;
				//TB Combat Mods end
			}
		}
		if (unitCount > 0)
		{
			collateralCount = unitCount - seigeCount;
			averageDamage /= unitCount;
			averageProtection /= unitCount;
			if (collateralCount > 1 && collateralCount < 8 && averageDamage < 40 && averageProtection < 10)
			{
				return true;
			}
		}
	}
	return false;
}

int CvUnit::getRbombardSeigeCount(const CvPlot* pPlot) const
{
	return pPlot ? algo::count_if(pPlot->units(), CvUnit::fn::canRBombard()) : 0;
}

void CvUnit::doOpportunityFire()
{
	PROFILE_EXTRA_FUNC();
	//TB Notes regarding Opportunity Fire:
	//While the mechanism has been updated to only target the strongest adjacent unit with this opportunity fire, there is still some work here to do.
	//There is absolutely zero resistability to this damage and no potential for failure to strike, making it far more powerful than any player determined
	//action.  Once I get to focusing in on the Bombard function and adding some more dynamics there to address the above noted issues,
	//I'll have to enforce those mechanisms onto this Opportunity Fire process as well.
	int iUnitDamage = 0;
	int iVolumeDefenders = 0;
	int iBestUnitStr = 0;
	int ipDefenderStr = 0;
	CvPlot* pAttackPlot = NULL;
	CvUnit* pDefender = NULL;
	CvWString szBuffer;
	CvUnit* pBestUnit;

	if (!GC.isDCM_OPP_FIRE() || getBombardRate() <= 0 || getDCMBombRange() <= 0)
	{
		return;
	}

	if (getFortifyTurns() > 0)
	{
		foreach_(CvPlot* pLoopPlot, plot()->adjacent())
		{
			iVolumeDefenders = pLoopPlot->getNumUnits();
			if (iVolumeDefenders > 0)
			{
				pBestUnit = NULL;
				pBestUnit = pLoopPlot->getBestDefender(NO_PLAYER, getOwner(), this, true);
				if (pBestUnit != NULL)
				{
					iBestUnitStr = pBestUnit->currCombatStr(pLoopPlot, this);
					if (pDefender != NULL)
					{
						if (iBestUnitStr > ipDefenderStr)
						{
							pDefender = pBestUnit;
							pAttackPlot = pLoopPlot;
							ipDefenderStr = pDefender->currCombatStr(pLoopPlot, this);
						}
					}
					else
					{
						pDefender = pBestUnit;
						pAttackPlot = pLoopPlot;
						ipDefenderStr = pDefender->currCombatStr(pLoopPlot, this);
					}
				}
			}
		}
		if (pDefender != NULL)
		{
			iUnitDamage = (GC.getGame().getSorenRandNum(getBombardRate(), "Bombard damage") * 5);
			pDefender->changeDamage(iUnitDamage, getOwner());
			//TB Combat Mod begin
			if (dealsColdDamage())
			{
				pDefender->changeColdDamage(iUnitDamage);
			}
			//TB Combat Mod end

			{
				szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_OPP_FIRE", getNameKey(), pDefender->getNameKey());
				AddDLLMessage(getOwner(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_OUR_WITHDRAWL", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_GREEN(), pAttackPlot->getX(), pAttackPlot->getY(), true, true);
				szBuffer = gDLL->getText("TXT_KEY_MISC_ENEMY_OPP_FIRE", getNameKey(), pDefender->getNameKey());
				AddDLLMessage(pDefender->getOwner(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_THEIR_WITHDRAWL", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_RED(), pAttackPlot->getX(), pAttackPlot->getY(), true, true);
			}

			// Bombard entity mission
			addMission(CvMissionDefinition(MISSION_BOMBARD, pAttackPlot, this, pDefender));
		}
	}
}
// ! Dale - SA: Opp Fire

// Dale - SA: Active Defense
void CvUnit::doActiveDefense()
{
	PROFILE_EXTRA_FUNC();
	int iDamage, iUnitDamage;
	CvUnit* pDefender = NULL;
	CvCity* pCity = NULL;
	bool bSuccess = false;
	CvWString szBuffer;
	if (!GC.isDCM_ACTIVE_DEFENSE())
	{
		return;
	}
	if (getGroup()->getActivityType() != ACTIVITY_INTERCEPT)
	{
		return;
	}
	foreach_(CvPlot* pLoopPlot, plot()->rect(2, 2))
	{
		if (pLoopPlot->getNumUnits() > 0)
		{
			pDefender = airStrikeTarget(pLoopPlot);
			if (pDefender != NULL)
			{
				iDamage = airCombatDamage(pDefender);
				iUnitDamage = std::max(pDefender->getDamage(), std::min((pDefender->getDamage() + iDamage), airCombatLimit(pDefender)));

				{

					szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_ARE_ATTACKED_BY_AIR", pDefender->getNameKey(), getNameKey(), -(((iUnitDamage - pDefender->getDamage()) * 100) / pDefender->getMaxHP()));
					AddDLLMessage(pDefender->getOwner(), false, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_AIR_ATTACK", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_RED(), pLoopPlot->getX(), pLoopPlot->getY(), true, true);
					szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_ATTACK_BY_AIR", getNameKey(), pDefender->getNameKey(), -(((iUnitDamage - pDefender->getDamage()) * 100) / pDefender->getMaxHP()));
					AddDLLMessage(getOwner(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_AIR_ATTACKED", MESSAGE_TYPE_INFO, pDefender->getButton(), GC.getCOLOR_GREEN(), pLoopPlot->getX(), pLoopPlot->getY());
				}
				collateralCombat(pLoopPlot, pDefender);
				pDefender->setDamage(iUnitDamage, getOwner());
				bSuccess = true;
				//TB Combat Mod begin
				if (dealsColdDamage())
				{
					pDefender->setColdDamage(iUnitDamage);
				}
				//TB Combat mod end
				if (pLoopPlot->isActiveVisible(false) && (!pDefender->isUsingDummyEntities() && pDefender->isInViewport()))
				{
					setCombatTimer(GC.getMissionInfo(MISSION_AIRSTRIKE).getTime());
					GC.getGame().incrementTurnTimer(getCombatTimer());

					addMission(CvAirMissionDefinition(MISSION_AIRSTRIKE, pLoopPlot, this, pDefender));
				}
			}
		}
#ifdef OUTBREAKS_AND_AFFLICTIONS
		if (bSuccess)
		{
			//Afflict
			int iDistanceAttackCommunicability = 0;
			bool bAffliction = false;
			if (GC.getGame().isOption(GAMEOPTION_COMBAT_OUTBREAKS_AND_AFFLICTIONS))
			{
				for (int iI = 0; iI < GC.getNumPromotionLineInfos(); iI++)
				{
					if (GC.getPromotionLineInfo((PromotionLineTypes)iI).isAffliction() && !GC.getPromotionLineInfo((PromotionLineTypes)iI).isCritical())
					{
						//Distance Communicability
						iDistanceAttackCommunicability = getDistanceAttackCommunicability((PromotionLineTypes)iI);
						bool bDistAttComm = iDistanceAttackCommunicability > 0;
						PromotionLineTypes eAfflictionLine = ((PromotionLineTypes)iI);
						bool bAffonAtt = (hasAfflictOnAttackType(eAfflictionLine) && isAfflictOnAttackTypeDistance(eAfflictionLine));
						if (bDistAttComm || bAffonAtt)
						{
							bAffliction = true;
							foreach_(CvUnit* pLoopUnit, pLoopPlot->units())
							{
								if (bDistAttComm)
								{
									if (pLoopUnit->checkContractDisease(eAfflictionLine, iDistanceAttackCommunicability))
									{
										pLoopUnit->afflict(eAfflictionLine);
									}
									pCity = pLoopPlot->getPlotCity();
									if (pCity != NULL)
									{
										pCity->changePromotionLineAfflictionAttackCommunicability(eAfflictionLine, iDistanceAttackCommunicability);
									}
								}
								if (bAffonAtt)
								{
									int iAttackersPoisonChance = getAfflictOnAttackTypeProbability(eAfflictionLine) - pLoopUnit->fortitudeTotal() - pLoopUnit->getUnitAfflictionTolerance(eAfflictionLine);

									if (GC.getGame().getSorenRandNum(100, "AttackersPoisonRoll") < iAttackersPoisonChance)
									{
										pLoopUnit->afflict(eAfflictionLine, true, this);
									}
								}
							}
						}
					}
				}
			}
		}
#endif // OUTBREAKS_AND_AFFLICTIONS
	}
}
// ! Dale - SA: Active Defense

// Dale - FE: Fighters
bool CvUnit::canFEngage() const
{
	if(!GC.isDCM_FIGHTER_ENGAGE())
	{
		return false;
	}
	if (!m_pUnitInfo->getDCMFighterEngage())
	{
		return false;
	}
	if (getDomainType() != DOMAIN_AIR)
	{
		return false;
	}
	if (isMadeAttack())
	{
		return false;
	}
//	if (isCargo())
//	{
//		return false;
//	}
	return true;
}

bool CvUnit::canFEngageAt(const CvPlot* pPlot, int iX, int iY) const
{
	PROFILE_EXTRA_FUNC();
	if (!canFEngage())
	{
		return false;
	}
	if (iX < 0 || iY < 0)
	{
		return false;
	}
	const CvPlot* pTargetPlot = GC.getMap().plot(iX, iY);

	if (plotDistance(pPlot->getX(), pPlot->getY(), pTargetPlot->getX(), pTargetPlot->getY()) > airRange())
	{
		return false;
	}
	if (pTargetPlot->isOwned() && pTargetPlot->getTeam() != getTeam()
	&& !atWar(pTargetPlot->getTeam(), getTeam()))
	{
		return false;
	}
	for (int iI = 0; iI < MAX_PLAYERS; ++iI)
	{
		if (atWar(GET_PLAYER((PlayerTypes)iI).getTeam(), getTeam())
		&& algo::any_of(GET_PLAYER((PlayerTypes)iI).units(), CvUnit::fn::plot() == pTargetPlot && CvUnit::fn::getDomainType() == DOMAIN_AIR))
		{
			return true;
		}
	}
	return false;
}

bool CvUnit::fighterEngage(int iX, int iY)
{
	PROFILE_EXTRA_FUNC();
	if (!canFEngageAt(plot(), iX, iY))
	{
		return false;
	}
	CvPlot* pPlot = GC.getMap().plot(iX, iY);

	if (interceptTest(pPlot))
	{
		return true;
	}
	int iCount = algo::count_if(pPlot->units(), CvUnit::fn::getDomainType() == DOMAIN_AIR);
	iCount = 1 + GC.getGame().getSorenRandNum(iCount, "Choose plane");
	CvUnit* pDefender = NULL;
	CLLNode<IDInfo>* pUnitNode = pPlot->headUnitNode();
	while (iCount > 0)
	{
		CvUnit* pLoopUnit = ::getUnit(pUnitNode->m_data);
		if (pLoopUnit->getDomainType() == DOMAIN_AIR)
		{
			iCount--;
			pDefender = pLoopUnit;
		}
		pUnitNode = pPlot->nextUnitNode(pUnitNode);
	}
	if (pDefender != NULL)
	{
		CvAirMissionDefinition kAirMission(MISSION_AIRSTRIKE, pPlot, this, pDefender);
		resolveAirCombat(pDefender, pPlot, kAirMission);
		if (kAirMission.isValid())
		{
			setCombatTimer(GC.getMissionInfo(MISSION_AIRSTRIKE).getTime());
			GC.getGame().incrementTurnTimer(getCombatTimer());
			addMission(kAirMission);
		}

		if (isDead())
		{

			CvWString szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_SHOT_DOWN_ENEMY", pDefender->getNameKey(), getNameKey(), getVisualCivAdjective(pDefender->getTeam()));
			AddDLLMessage(pDefender->getOwner(), false, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_INTERCEPT", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_GREEN(), pPlot->getX(), pPlot->getY(), true, true);
			szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_UNIT_SHOT_DOWN", getNameKey(), pDefender->getNameKey());
			AddDLLMessage(getOwner(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_INTERCEPTED", MESSAGE_TYPE_INFO, pDefender->getButton(), GC.getCOLOR_RED(), pPlot->getX(), pPlot->getY());
		}
		else if (kAirMission.getDamage(BATTLE_UNIT_ATTACKER) > 0)
		{

			CvWString szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_HURT_ENEMY_AIR", pDefender->getNameKey(), getNameKey(), -(kAirMission.getDamage(BATTLE_UNIT_ATTACKER)), getVisualCivAdjective(pDefender->getTeam()));
			AddDLLMessage(pDefender->getOwner(), false, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_INTERCEPT", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_GREEN(), pPlot->getX(), pPlot->getY(), true, true);
			szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_AIR_UNIT_HURT", getNameKey(), pDefender->getNameKey(), -(kAirMission.getDamage(BATTLE_UNIT_ATTACKER)));
			AddDLLMessage(getOwner(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_INTERCEPTED", MESSAGE_TYPE_INFO, pDefender->getButton(), GC.getCOLOR_RED(), pPlot->getX(), pPlot->getY());
		}
		if (pDefender->isDead())
		{

			CvWString szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_SHOT_DOWN_ENEMY", getNameKey(), pDefender->getNameKey(), pDefender->getVisualCivAdjective(getTeam()));
			AddDLLMessage(getOwner(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_INTERCEPT", MESSAGE_TYPE_INFO, pDefender->getButton(), GC.getCOLOR_GREEN(), pPlot->getX(), pPlot->getY(), true, true);
			szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_UNIT_SHOT_DOWN", pDefender->getNameKey(), getNameKey());
			AddDLLMessage(pDefender->getOwner(), false, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_INTERCEPTED", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_RED(), pPlot->getX(), pPlot->getY());
		}
		else if (kAirMission.getDamage(BATTLE_UNIT_DEFENDER) > 0)
		{

			CvWString szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_DAMAGED_ENEMY_AIR", getNameKey(), pDefender->getNameKey(), -(kAirMission.getDamage(BATTLE_UNIT_DEFENDER)), pDefender->getVisualCivAdjective(getTeam()));
			AddDLLMessage(getOwner(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_INTERCEPT", MESSAGE_TYPE_INFO, pDefender->getButton(), GC.getCOLOR_GREEN(), pPlot->getX(), pPlot->getY(), true, true);
			szBuffer = gDLL->getText("TXT_KEY_MISC_YOUR_AIR_UNIT_DAMAGED", pDefender->getNameKey(), getNameKey(), -(kAirMission.getDamage(BATTLE_UNIT_DEFENDER)));
			AddDLLMessage(pDefender->getOwner(), false, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_INTERCEPTED", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_RED(), pPlot->getX(), pPlot->getY());
		}
		if (0 == kAirMission.getDamage(BATTLE_UNIT_ATTACKER) + kAirMission.getDamage(BATTLE_UNIT_DEFENDER))
		{

			CvWString szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_ABORTED_ENEMY_AIR", pDefender->getNameKey(), getNameKey(), getVisualCivAdjective(getTeam()));
			AddDLLMessage(pDefender->getOwner(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_INTERCEPT", MESSAGE_TYPE_INFO, pDefender->getButton(), GC.getCOLOR_GREEN(), pPlot->getX(), pPlot->getY(), true, true);
			szBuffer = gDLL->getText("TXT_KEY_MISC_YOUR_AIR_UNIT_ABORTED", getNameKey(), pDefender->getNameKey());
			AddDLLMessage(getOwner(), false, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_INTERCEPTED", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_RED(), pPlot->getX(), pPlot->getY());
		}
	}
	setMadeAttack(true);
	changeMoves(GC.getMOVE_DENOMINATOR());
	return true;
}
// ! Dale - FE: Fighters


// IDW start
// unit influences combat area after victory
// returns influence 10x int % in defended plot
// also handles emergency drafting???
int CvUnit::doVictoryInfluence(CvUnit* pLoserUnit, bool bAttacking, bool bWithdrawal)
{
	PROFILE_FUNC();
	if (pLoserUnit == NULL)
	{
		FErrorMsg("This can maybe occur, investigate when time allows");
		return 0; // this is not ideal, but if unit is deleted before this calculation we dont want the ctd
	}

	if (!pLoserUnit->canDefend() || isAnimal() || pLoserUnit->isAnimal())
		return 0; // no influence from worker capture or animal kill

	if (isAlwaysHostile(plot()) || pLoserUnit->isAlwaysHostile(pLoserUnit->plot()))
		return 0;

	if (GC.isIDW_NO_BARBARIAN_INFLUENCE() && (isHominid() || pLoserUnit->isHominid()))
		return 0;

	if (GC.isIDW_NO_NAVAL_INFLUENCE() && DOMAIN_SEA == getDomainType())
		return 0;

	const PlayerTypes pLoserPlayer = pLoserUnit->getOwner();

	if (pLoserPlayer < 0 || pLoserPlayer > MAX_PLAYERS)
	{
		FErrorMsg("This can maybe occur, investigate when time allows");
		return 0; // Bad unit owner TODO find out why gets passed in
	}

	CvPlot* pWinnerPlot = plot();
	CvPlot* pLoserPlot = pLoserUnit->plot();

	const CvPlot* pDefenderPlot = bAttacking ? pLoserPlot : pWinnerPlot;
	bool bFieldCombat = true;
	const int iWinnerCultureBefore = pDefenderPlot->getCulture(getOwner()); //used later for influence %

	// Multipliers are percents, stored as *100. E.g., 1 = 0.1%, 100 = 1%, 10,000 = 100%
	int iWinnerPlotMultiplier = 100 * GC.getIDW_WINNER_PLOT_MULTIPLIER();
	int iLoserPlotMultiplier = 100 * GC.getIDW_LOSER_PLOT_MULTIPLIER();
	// Unused currently
	if (bWithdrawal)
	{
		iWinnerPlotMultiplier /= 3;
		iLoserPlotMultiplier /= 3;
	}
	if (pLoserPlot->isEnemyCity(*this, true)) // city combat
	{
		const CvCity* pLoserCity = pLoserPlot->getPlotCity();
		int iDefenders = pLoserPlot->getNumVisibleEnemyDefenders(this);

		// Couldn't figure out how to count leading zeroes for ghetto log2(city pop)
		// int iEmergencyDefenderLimit = 15 - countl_zero((uint16_t)(pLoserPlot->getPlotCity()->getPopulation()));
		// This is effectively same though; thresholds at 4, 16, 36, 64, vs 4, 8, 16, 32, 64, etc
		int iEmergencyDefenderLimit = 3 + intSqrt((uint)(pLoserCity->getPopulation())) / 2;

		if (GC.isIDW_EMERGENCY_DRAFT_ENABLED() && iDefenders < iEmergencyDefenderLimit)
		{
			const int iAttackerCulturePercent = pLoserPlot->calculateCulturePercent(getOwner(), 1);

			// if attacker culture has not yet surpassed threshold & defender can still draft,
			// city is not captured yet but emergency militia is drafted
			if (iAttackerCulturePercent / 10 < GC.getIDW_EMERGENCY_DRAFT_CULTURE_THRESHOLD()
				&& pLoserCity->getPopulation() >= GC.getIDW_EMERGENCY_DRAFT_MIN_POPULATION())
			{
				pLoserPlot->getPlotCity()->emergencyConscript();
				iDefenders++;

				// Draft twice if under 1/2 defender threshold
				if (iDefenders * 2 <= iEmergencyDefenderLimit
					&& pLoserCity->getPopulation() >= GC.getIDW_EMERGENCY_DRAFT_MIN_POPULATION())
				{
					pLoserPlot->getPlotCity()->emergencyConscript();
					iDefenders++;
				}

				CvWString szBuffer = gDLL->getText("TXT_KEY_MISC_CITY_MILITIA_EMERGED",
					GET_PLAYER(getOwner()).getCivilizationAdjective(), iAttackerCulturePercent/10,
					iAttackerCulturePercent % 10, GC.getIDW_EMERGENCY_DRAFT_CULTURE_THRESHOLD());
				AddDLLMessage(pLoserPlayer, false, GC.getEVENT_MESSAGE_TIME(),
					szBuffer, "AS2D_UNIT_BUILD_UNIT", MESSAGE_TYPE_INFO, getButton(),
					GC.getCOLOR_GREEN(), pLoserPlot->getX(), pLoserPlot->getY(), true, true);
				AddDLLMessage(getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
					szBuffer, "AS2D_UNIT_BUILD_UNIT", MESSAGE_TYPE_INFO, getButton(),
					GC.getCOLOR_RED(), pLoserPlot->getX(), pLoserPlot->getY());
			}
		}
		if (iDefenders == 0) // City Capture
		{
			const int iNoCityDefenderMultiplier = GC.getIDW_NO_CITY_DEFENDER_MULTIPLIER();

			influencePlots(pLoserPlot, pLoserPlayer, iLoserPlotMultiplier * iNoCityDefenderMultiplier / 100);
			influencePlots(pWinnerPlot, pLoserPlayer, iWinnerPlotMultiplier * iNoCityDefenderMultiplier / 100);
			bFieldCombat = false;
		}
	}
	else if (pLoserPlot->isActsAsCity() && pLoserPlot->getNumVisibleEnemyDefenders(this) == 0)
	{
		// Fort captured
		const int iFortCaptureMultiplier = GC.getIDW_FORT_CAPTURE_MULTIPLIER();

		influencePlots(pLoserPlot, pLoserPlayer, iLoserPlotMultiplier * iFortCaptureMultiplier / 100);
		influencePlots(pWinnerPlot, pLoserPlayer, iWinnerPlotMultiplier * iFortCaptureMultiplier / 100);
		bFieldCombat = false;
	}
	if (bFieldCombat)
	{
		influencePlots(pLoserPlot, pLoserPlayer, iLoserPlotMultiplier);
		influencePlots(pWinnerPlot, pLoserPlayer, iWinnerPlotMultiplier);
	}

	// calculate influence % in defended plot (to be displayed in game log)
	const int iTotalCulture = pDefenderPlot->countTotalCulture();

	if (iTotalCulture > 0)
	{
		return (pDefenderPlot->getCulture(getOwner()) - iWinnerCultureBefore) * 1000 / iTotalCulture;
	}
    return 0;
}

// unit influences given plot and surounding area i.e. transfers culture from target civ to unit's owner
void CvUnit::influencePlots(CvPlot* pCentralPlot, const PlayerTypes eTargetPlayer, const int iLocationMultiplier)
{
	PROFILE_EXTRA_FUNC();
	FASSERT_BOUNDS(0, MAX_PLAYERS, eTargetPlayer);

	// get influence radius
	const int iInfluenceRadius = GC.getIDW_INFLUENCE_RADIUS();
	if (iInfluenceRadius < 0) return;

	// calculate base multiplier used for all plots
	int iMultiplier = GC.getIDW_BASE_COMBAT_INFLUENCE() * iLocationMultiplier / 100;
	if (iMultiplier < 1) return;

	if (NO_UNIT != getLeaderUnitType()) // if led
	{
		iMultiplier *= GC.getIDW_LEADER_MULTIPLIER();
		iMultiplier /= 100;
	}
	if (iMultiplier < 1) return;

	const int iCityPlotMultiplier = GC.isIDW_EMERGENCY_DRAFT_ENABLED() ? 100 : GC.getIDW_CITY_TILE_MULTIPLIER();

	for (int iDX = -iInfluenceRadius; iDX <= iInfluenceRadius; iDX++)
	{
		for (int iDY = -iInfluenceRadius; iDY <= iInfluenceRadius; iDY++)
		{
			const int iDistance = plotDistance(0, 0, iDX, iDY);

			if (iDistance <= iInfluenceRadius)
			{
				CvPlot* pLoopPlot = plotXY(pCentralPlot->getX(), pCentralPlot->getY(), iDX, iDY);

				if (pLoopPlot != NULL)
				{
					const int iTargetCulture = pLoopPlot->getCulture(eTargetPlayer);
					if (iTargetCulture < 1) continue;

					int iMult = iMultiplier;
					// calculate distance multiplier for current plot
					int iDistanceMultiplier = 100 / intPow((iDistance + 1), 2);
					if (iDistanceMultiplier < 1) continue;

					// Cities gain reduced culture transfer if not emergency draft,
					// also halved if city has protected culture
					if (pLoopPlot->isCity())
					{
						iMult *= iCityPlotMultiplier;
						iMult /= 100;
						if (pLoopPlot->getPlotCity()->isProtectedCulture())
							iMult /= 2;
					}
					// and non cities avoid culture transfer, if they are protected
					else if (pLoopPlot->getWorkingCity() != NULL && pLoopPlot->getWorkingCity()->isProtectedCulture())
						continue;

					if (iMult < 1) continue;

					// Removing a total of 1e6
					int iCultureTransfer = iMult * iDistanceMultiplier / 100 * iTargetCulture / 10000;

					// Catch potential unlikely overflows?
					if (iCultureTransfer < 0) iCultureTransfer = 0;

					if (iTargetCulture < iCultureTransfer)
					{
						// cannot transfer more culture than remaining target culure
						iCultureTransfer = iTargetCulture;
					}
					if (iCultureTransfer == iTargetCulture
					&& pLoopPlot->isActsAsCity()) // fort, must not lose all culture when it may still be garrisoned)
					{
						iCultureTransfer--;
					}

					if (iCultureTransfer > 0)
					{
						// target player's culture in plot is lowered
						pLoopPlot->changeCulture(eTargetPlayer, -iCultureTransfer, false);
						// owners's culture in plot is raised
					}
						pLoopPlot->changeCulture(getOwner(), iCultureTransfer, true);
				}
			}
		}
	}
}


// unit influences current tile via pillaging
// returns influence 10x int % in pillaged plot
int CvUnit::doPillageInfluence()
{
	if (isAnimal() || isHiddenNationality())
	{
		return 0;
	}
	if (isHominid() && GC.isIDW_NO_BARBARIAN_INFLUENCE())
	{
		return 0;
	}
	if (DOMAIN_SEA == getDomainType() && GC.isIDW_NO_NAVAL_INFLUENCE())
	{
		return 0;
	}

	CvPlot* pPlot = plot();
	if (pPlot == NULL)
	{
		FErrorMsg("pPlot == NULL; should not happen");
		return 0;
	}
	if (pPlot->getWorkingCity() != NULL && pPlot->getWorkingCity()->isProtectedCulture())
	{
		return 0;
	}

	const PlayerTypes eTargetPlayer = pPlot->getOwner();
	const int iTargetCulture = pPlot->getCulture(eTargetPlayer);
	if (iTargetCulture < 1)
	{
		FErrorMsg("iTargetCulture < 1; should not happen");
		return 0;
	}
	int iCultureTransfer = GC.getIDW_BASE_PILLAGE_INFLUENCE() * iTargetCulture / 100;
	if (iCultureTransfer < 1)
		iCultureTransfer = 1;
	// cannot transfer more culture than remaining target culure
	if (iTargetCulture <= iCultureTransfer)
	{
		iCultureTransfer = iTargetCulture;
	}

	if (iCultureTransfer > 0)
	{
		const int iOurCultureBefore = pPlot->getCulture(getOwner()); //used later for influence %

		pPlot->changeCulture(eTargetPlayer, -iCultureTransfer, false);
		pPlot->changeCulture(getOwner(), iCultureTransfer, true);

		// calculate 10x influence % in pillaged plot (to be displayed in game log)
		return (pPlot->getCulture(getOwner()) - iOurCultureBefore) * 1000 / pPlot->countTotalCulture();
	}
	return 0;
}
// ------ END InfluenceDrivenWar ---------------------------------


bool CvUnit::canPerformInquisition(const CvPlot* pPlot) const
{
	if (!m_pUnitInfo->isInquisitor())
	{
		return false;
	}
	const CvCity* pCity = pPlot->getPlotCity();

	if (pCity == NULL)
	{
		return false;
	}
	if (GET_PLAYER(getOwner()).getStateReligion() == NO_RELIGION)
	{
		return false;
	}
	if (!pCity->isHasReligion(GET_PLAYER(getOwner()).getStateReligion()))
	{
		return false;
	}
	// Allow inquisitions in vassals
	if (pCity->getTeam() != getTeam() && !GET_TEAM(pCity->getTeam()).isVassal(getTeam()))
	{
		return false;
	}
	if (!pCity->isInquisitionConditions() || !GET_PLAYER(getOwner()).isInquisitionConditions())
	{
		return false;
	}
	if (GET_PLAYER(getOwner()).getStateReligion() != GET_PLAYER(pCity->getOwner()).getStateReligion())
	{
		return false;
	}
	return true;
}


bool CvUnit::performInquisition()
{
	PROFILE_EXTRA_FUNC();
	const CvPlot* pPlot = plot();

	if (!canPerformInquisition(pPlot))
	{
		return false;
	}
	CvCity* pCity = pPlot->getPlotCity();

	if (pCity != NULL)
	{
		CvWString szBuffer;

		for (int iI = 0; iI < MAX_PC_PLAYERS; iI++)
		{
			const CvPlayer& kLoopPlayer = GET_PLAYER((PlayerTypes)iI);
			if (kLoopPlayer.isAlive()
			&& (pPlot->isVisible(kLoopPlayer.getTeam(), true) || pPlot->isRevealed(kLoopPlayer.getTeam(), true)))
			{
				gDLL->getInterfaceIFace()->playGeneralSound("AS3D_UN_CHRIST_MISSIONARY_ACTIVATE", pPlot->getPoint());
			}
		}

		int iHolyCityVal = 0;
		int iReligionCount = 0;
		for (int iI = 0; iI < GC.getNumReligionInfos(); iI++)
		{
			if ((ReligionTypes)iI != GET_PLAYER(getOwner()).getStateReligion() && pCity->isHasReligion((ReligionTypes)iI))
			{
				iReligionCount++;
				if (pCity->isHolyCity((ReligionTypes)iI))
				{
					iHolyCityVal = 50;
				}
			}
		}
		int iCompensationGold = 0;

		if (GC.getGame().getSorenRandNum(100, "Inquisition Persection Chance") < std::max(25, (95 - iHolyCityVal - (5 * iReligionCount))))
		{
			// Change memory if we are removing a religion that is another player's state religion
			for (int iI = 0; iI < MAX_PC_PLAYERS; iI++)
			{
				CvPlayer& kLoopPlayer = GET_PLAYER((PlayerTypes)iI);
				if (kLoopPlayer.isAlive()
				&& (pPlot->isVisible(kLoopPlayer.getTeam(), false) || pPlot->isRevealed(kLoopPlayer.getTeam(), false))
				&& GET_TEAM(kLoopPlayer.getTeam()).isHasMet(GET_PLAYER(getOwner()).getTeam()))
				{
					for (int iJ = 0; iJ < GC.getNumReligionInfos(); iJ++)
					{
						if (GET_PLAYER(getOwner()).getStateReligion() != (ReligionTypes)iJ
						// if the player has the holy city, or has the religion as a state religion.
						&& (kLoopPlayer.hasHolyCity((ReligionTypes)iJ) || pCity->isHasReligion((ReligionTypes)iJ) && kLoopPlayer.getStateReligion() == (ReligionTypes)iJ))
						{
							kLoopPlayer.AI_changeMemoryCount(getOwner(), MEMORY_INQUISITION, 1);
							break;
						}
					}
				}
			}
			//Remove temples, monasteries, etc...
			{
				std::vector<BuildingTypes> temp;

				foreach_(const BuildingTypes eType, pCity->getHasBuildings())
				{
					const CvBuildingInfo& buildingX = GC.getBuildingInfo(eType);
					if (buildingX.getPrereqReligion() == NO_RELIGION)
					{
						continue;
					}
					for (int iJ = 0; iJ < GC.getNumReligionInfos(); iJ++)
					{
						if (GET_PLAYER(getOwner()).getStateReligion() != iJ && buildingX.getPrereqReligion() == iJ)
						{
							temp.push_back(eType);
							iCompensationGold += buildingX.getProductionCost() * GC.getGameSpeedInfo(GC.getGame().getGameSpeedType()).getHammerCostPercent() / std::max(1, GC.getDefineINT("INQUISITION_BUILDING_GOLD_DIVISOR"));
							break;
						}
					}
				}
				foreach_(const BuildingTypes eType, temp)
				{
					pCity->changeHasBuilding(eType, false);
				}
			}
			//Remove the Religion & Holy Cities
			for (int iI = 0; iI < GC.getNumReligionInfos(); iI++)
			{
				if (GET_PLAYER(getOwner()).getStateReligion() != (ReligionTypes)iI)
				{
					if (pCity->isHolyCity((ReligionTypes)iI))
					{
						//TODO: This value needs to be set from python
						if (GC.getDefineINT("OC_RESPAWN_HOLY_CITIES"))
						{
							GC.getGame().setHolyCity((ReligionTypes)iI, NULL , false);
							iCompensationGold += GC.getDefineINT("HOLYCITY_REMOVAL_GOLD");
							pCity->setHasReligion((ReligionTypes)iI, false, false, false);

							//Find the best place to replace the holy city
							PlayerTypes eBestPlayer = NO_PLAYER;
							int iBestCount = 0;
							for (int iJ = 0; iJ < MAX_PC_PLAYERS; iJ++)
							{
								const CvPlayerAI& kLoopPlayer = GET_PLAYER((PlayerTypes)iJ);

								if (kLoopPlayer.isAlive())
								{
									const int iCount = kLoopPlayer.getHasReligionCount((ReligionTypes)iI);
									if (iCount > iBestCount)
									{
										iBestCount = iCount;
										eBestPlayer = (PlayerTypes)iJ;
									}
								}
							}
							//Relocate the holy city
							if (eBestPlayer != NO_PLAYER)
							{
								const CvPlayerAI& kPlayer = GET_PLAYER(eBestPlayer);
								foreach_(const CvCity* pLoopCity, kPlayer.cities())
								{
									if (pLoopCity->isHasReligion((ReligionTypes)iI))
									{
										GC.getGame().setHolyCity((ReligionTypes)iI, pLoopCity, true);
										//TODO: Create a text entry: "A Holy City Religion has been Respawned"
										{

											szBuffer = gDLL->getText("TXT_KEY_MSG_HOLY_CITY_RESPAWNED");
											AddDLLMessage(
												GC.getGame().getActivePlayer(), true, GC.getEVENT_MESSAGE_TIME(),
												szBuffer, "AS2D_DISCOVERBONUS", MESSAGE_TYPE_MAJOR_EVENT,
												"Art/Interface/Buttons/TerrainFeatures/Forest.dds",
												ColorTypes(8), getX(), getY(), false, false
											);
										}
										break;
									}
								}
							}
						}
					}
					else if (pCity->isHasReligion((ReligionTypes)iI))
					{
						pCity->setHasReligion((ReligionTypes)iI, false, false, false);
						iCompensationGold += GC.getDefineINT("RELIGION_REMOVAL_GOLD");
					}
				}
			}

			for (int iI = 0; iI < MAX_PC_PLAYERS; iI++)
			{
				const CvPlayer& kLoopPlayer = GET_PLAYER((PlayerTypes)iI);
				if (kLoopPlayer.isAlive()
				&& (pPlot->isVisible(kLoopPlayer.getTeam(), true) || pPlot->isRevealed(kLoopPlayer.getTeam(), true)))
				{
					szBuffer = gDLL->getText("TXT_KEY_MSG_INQUISITION", pCity->getNameKey());
					AddDLLMessage(((PlayerTypes)iI), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_PLAGUE", MESSAGE_TYPE_MAJOR_EVENT, getButton() , ColorTypes(8), getX(), getY(), true, true);
				}
			}

			//Increase Temp Anger
			pCity->changeHurryAngerTimer(pCity->flatHurryAngerLength());
			if (GC.getGame().isOption(GAMEOPTION_UNSUPPORTED_REVOLUTION))
			{
				//Avoid setting the Rev Index below 0...
				pCity->changeLocalRevIndex(-std::min(pCity->getRevolutionIndex(), iCompensationGold));
			}
			else GET_PLAYER(getOwner()).changeGold(iCompensationGold);
		}
		//Inquisition Fails...
		else
		{
			for (int iI = 0; iI < MAX_PC_PLAYERS; iI++)
			{
				const CvPlayer& kLoopPlayer = GET_PLAYER((PlayerTypes)iI);
				if (kLoopPlayer.isAlive()
				&& (pPlot->isVisible(kLoopPlayer.getTeam(), true) || pPlot->isRevealed(kLoopPlayer.getTeam(), true)))
				{
					szBuffer = gDLL->getText("TXT_KEY_MSG_INQUISITION_FAIL", pCity->getNameKey());
					AddDLLMessage(((PlayerTypes)iI), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_SABOTAGE", MESSAGE_TYPE_MAJOR_EVENT, getButton() , ColorTypes(8), getX(), getY(), true, true);
				}
			}
			pCity->changeHurryAngerTimer(pCity->flatHurryAngerLength());

			if (GC.getGame().isOption(GAMEOPTION_UNSUPPORTED_REVOLUTION))
			{
				pCity->changeLocalRevIndex(iCompensationGold / 2);
			}
		}
		if (pPlot->isActiveVisible(false))
		{
			NotifyEntity(MISSION_INQUISITION);
		}
	}
	kill(true, NO_PLAYER, true);
	return true;
}


bool CvUnit::canTradeUnit(PlayerTypes eReceivingPlayer) const
{
	PROFILE_EXTRA_FUNC();
	if (eReceivingPlayer == NO_PLAYER || eReceivingPlayer > MAX_PLAYERS)
	{
		return false;
	}
	if (hasCargo())
	{
		return false;
	}
	if (getDomainType() == DOMAIN_SEA)
	{
		CvArea* pWaterArea;
		bool bCoast = false;
		foreach_(const CvCity* pLoopCity, GET_PLAYER(eReceivingPlayer).cities())
		{
			if ((pWaterArea = pLoopCity->waterArea()) != NULL && !pWaterArea->isLake())
			{
				bCoast = true;
				break;
			}
		}
		if (!bCoast)
		{
			return false;
		}
	}
	return true;
}

void CvUnit::tradeUnit(PlayerTypes eReceivingPlayer)
{
	if (eReceivingPlayer == NO_PLAYER)
	{
		return;
	}
	CvPlayerAI& receiver = GET_PLAYER(eReceivingPlayer);
	CvCity* pBestCity = NULL;

	if (getDomainType() == DOMAIN_SEA)
	{
		pBestCity = receiver.findBestCoastalCity();
	}
	else pBestCity = receiver.getCapitalCity();

	CvUnit* pTradeUnit = receiver.initUnit(
		getUnitType(), pBestCity->getX(), pBestCity->getY(), AI_getUnitAIType(), NO_DIRECTION,
		GC.getGame().getSorenRandNum(10000, "AI Unit Birthmark")
	);
	if (pTradeUnit != NULL)
	{
		pTradeUnit->convert(this);
		if (receiver.isHumanPlayer())
		{
			AddDLLMessage(
				eReceivingPlayer, false, GC.getEVENT_MESSAGE_TIME(),
				gDLL->getText(
					"TXT_KEY_MISC_TRADED_UNIT_TO_YOU",
					GET_PLAYER(getOwner()).getNameKey(), pTradeUnit->getNameKey()
				),
				"AS2D_UNITGIFTED", MESSAGE_TYPE_INFO, pTradeUnit->getButton(),
				GC.getCOLOR_WHITE(), pTradeUnit->getX(), pTradeUnit->getY(), true, true
			);
		}
	}
}

void CvUnit::spyNuke(int iX, int iY, bool bCaught)
{
	PROFILE_EXTRA_FUNC();

	CvWString szBuffer;
	CvPlot* pPlot = GC.getMap().plot(iX, iY);
	bool nukedTeams[MAX_PC_TEAMS];

	for (int iI = 0; iI < MAX_PC_TEAMS; iI++)
	{
		nukedTeams[iI] = isNukeVictim(pPlot, (TeamTypes)iI, 0);
	}

	if (bCaught)
	{
		nukeDiplomacy(nukedTeams);
		szBuffer = gDLL->getText("TXT_KEY_MISC_NUKE_ENEMY_SPY", GET_PLAYER(getOwner()).getNameKey(), GET_PLAYER(pPlot->getOwner()).getNameKey());
	}
	else szBuffer = gDLL->getText("TXT_KEY_MISC_NUKE_UNKNOWN", GET_PLAYER(pPlot->getOwner()).getNameKey());


	for (int iI = 0; iI < MAX_PC_PLAYERS; iI++)
	{
		if (GET_PLAYER((PlayerTypes)iI).isAlive())
		{
			AddDLLMessage(
				(PlayerTypes)iI, iI == getOwner(), GC.getEVENT_MESSAGE_TIME(),
				szBuffer, "AS2D_NUKE_EXPLODES", MESSAGE_TYPE_MAJOR_EVENT, getButton(),
				GC.getCOLOR_RED(), pPlot->getX(), pPlot->getY(), true, true
			);
		}
	}

	//This is just so the espionage mission makes the cool explosion effect.
	if (GC.getInfoTypeForString("EFFECT_ICBM_NUCLEAR_EXPLOSION") != -1)
	{
		gDLL->getEngineIFace()->TriggerEffect((EffectTypes)GC.getInfoTypeForString("EFFECT_ICBM_NUCLEAR_EXPLOSION"), pPlot->getPoint(), 0);
		gDLL->getInterfaceIFace()->playGeneralSound("AS2D_NUKE_EXPLODES", pPlot->getPoint());
	}
	pPlot->nukeExplosion(0);
}


bool CvUnit::canClaimTerritory(const CvPlot* pPlot) const
{
	if (!GET_PLAYER(getOwner()).hasFixedBorders())
	{
		return false;
	}

	if (isNPC() || m_pUnitInfo->isAlwaysHostile() || isHiddenNationality() || !m_pUnitInfo->isPillage())
	{
		return false;
	}

	if (pPlot != NULL)
	{
		if (getOwner() == pPlot->getOwner())
		{
			return false;
		}
		// if we or someone else (a friend) already claimed this plot in this turn
		if (pPlot->getClaimingOwner() != NO_PLAYER)
		{
			return false;
		}

		if (!pPlot->isPotentialCityWork())
		{
			return false;
		}

		if (pPlot->isCity() || pPlot->isCity(true) && !GET_TEAM(getTeam()).isAtWar(pPlot->getTeam()))
		{
			return false;
		}

		if (GC.getGame().getModderGameOption(MODDERGAMEOPTION_CANNOT_CLAIM_OCEAN) && pPlot->isWater())
		{
			return false;
		}

		/* cannot claim plots adjacent to someone else's city */
		if (pPlot->getAdjacentCity(pPlot->getOwner()) != NULL)
		{
			return false;
		}

		if (!pPlot->isOwned() || potentialWarAction(pPlot))
		{
			return true;
		}
		return false;
	}
	return true;
}

bool CvUnit::claimTerritory()
{
	//logging::logMsg("C2C.log", "%S claims territory from %S at (%d, %d)", GET_PLAYER(getOwner()).getCivilizationShortDescription(), GET_PLAYER(plot()->getOwner()).getCivilizationShortDescription(), getX(), getY());
	CvPlot* pPlot = plot();

	if (!canClaimTerritory(pPlot))
	{
		return false;
	}
	PlayerTypes pPlayerThatLostTerritory = NO_PLAYER;

	if (pPlot->isOwned())
	{
		pPlayerThatLostTerritory = pPlot->getOwner();
		TeamTypes tTeamThatLostTerritory = GET_PLAYER(pPlayerThatLostTerritory).getTeam();

		GET_TEAM(tTeamThatLostTerritory).changeWarWeariness(getTeam(), *pPlot, GC.getDefineINT("WW_PLOT_CAPTURED"));
		GET_TEAM(getTeam()).changeWarWeariness(tTeamThatLostTerritory, *pPlot, GC.getDefineINT("WW_CAPTURED_PLOT"));
		GET_TEAM(getTeam()).AI_changeWarSuccess(tTeamThatLostTerritory, GC.getDefineINT("WAR_SUCCESS_PLOT_CAPTURING"));
	}
	pPlot->setClaimingOwner(getOwner());

	if (pPlayerThatLostTerritory != NO_PLAYER)
	{
		CvWString szBuffer;
		CvCity *pNearestCity = GC.getMap().findCity(pPlot->getX(), pPlot->getY(), pPlayerThatLostTerritory, NO_TEAM, false);

		if (pNearestCity != NULL)
		{
			szBuffer = gDLL->getText("TXT_KEY_MISSION_CLAIM_TERRITORY_CIV_SUCCESS_NEAR", GET_PLAYER(getOwner()).getCivilizationAdjectiveKey(), pNearestCity->getName().GetCString());
		}
		else
		{
			szBuffer = gDLL->getText("TXT_KEY_MISSION_CLAIM_TERRITORY_CIV_SUCCESS", GET_PLAYER(getOwner()).getCivilizationAdjectiveKey());
		}
		AddDLLMessage(pPlayerThatLostTerritory, true, GC.getEVENT_MESSAGE_TIME(), szBuffer, GC.getEraInfo(GC.getGame().getCurrentEra()).getAudioUnitDefeatScript(), MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_RED(), pPlot->getX(), pPlot->getY());
	}
	finishMoves();

	return true;
}

int CvUnit::surroundedDefenseModifier(const CvPlot *pPlot, const CvUnit *pDefender) const
{
	PROFILE_EXTRA_FUNC();
	if (!GC.getGame().isOption(GAMEOPTION_COMBAT_SURROUND_DESTROY))
	{
		return 0;
	}
	const DirectionTypes dtDirectionAttacker = directionXY(pPlot, plot());
	int iExtraModifier = 0;
	//TB Combat Mods Begin (Enclose)
	int iEnclose = 0;
	//TB Combat Mods End
	const bool bAttackerHN = isHiddenNationality();
	const bool bActAsHominid = isHominid() || isBarbCoExist();
	const bool bSeaCombat = pPlot->isWater();

	for (int iI = 0; iI < NUM_DIRECTION_TYPES; iI++)
	{
		if (iI != dtDirectionAttacker)
		{
			const CvPlot* plotX = plotDirection(pPlot, static_cast<DirectionTypes>(iI));

			if (plotX != NULL && bSeaCombat == plotX->isWater())
			{
				const CvUnit* pBestUnit = NULL;
				int iLowestCurrCombatStr = INT_MAX;

				foreach_(const CvUnit* unitX, plotX->units())
				{
					if (unitX->getTeam() == getTeam()
					&& bAttackerHN == unitX->isHiddenNationality()
					&& unitX->canAttack(*pDefender)
					&& unitX->canEnterPlot(pPlot, MoveCheck::IgnoreAttack))
					{
						iEnclose += unitX->encloseTotal();

						const int iTmpCurrCombatStrOnly = pDefender->currCombatStr(NULL, unitX, NULL, false);
						const int iTmpCurrCombatStr = std::max(1, iTmpCurrCombatStrOnly - iTmpCurrCombatStrOnly * unitX->unnerveTotal() / 100);

						if (iTmpCurrCombatStr < iLowestCurrCombatStr)
						{
							iLowestCurrCombatStr = iTmpCurrCombatStr;
							pBestUnit = unitX;
						}
					}
				}

				if (pBestUnit != NULL)
				{
					const double fAttDeffFactor = static_cast<double>(pBestUnit->currCombatStr(pPlot, pBestUnit, NULL, false)) / iLowestCurrCombatStr;

					if (fAttDeffFactor != 0)
					{
						/* surrounding distance = 1, 2, 3 or 4; the bigger the better */
						int iSurroundingDistanceFactor;

						switch (abs(std::min(abs(iI - dtDirectionAttacker), abs(abs(iI - dtDirectionAttacker) - 8))))
						{
							case 1:
								iSurroundingDistanceFactor = GC.getSAD_FACTOR_1();
								break;
							case 2:
								iSurroundingDistanceFactor = GC.getSAD_FACTOR_2();
								break;
							case 3:
								iSurroundingDistanceFactor = GC.getSAD_FACTOR_3();
								break;
							case 4:
								iSurroundingDistanceFactor = GC.getSAD_FACTOR_4();
								break;
							default:
								iSurroundingDistanceFactor = GC.getSAD_FACTOR_1();
								break;
						}
						if (fAttDeffFactor == 1)
						{
							iExtraModifier += iSurroundingDistanceFactor;
						}
						else
						{
							iExtraModifier += int(iSurroundingDistanceFactor * ((fAttDeffFactor - 1.0) * pow(abs(fAttDeffFactor - 1.0), -0.75) + 1.0));
						}
					}
				}
			}
		}
	}
	//TB Combat Mods Begin (SAD mods)
	const int iSurroundModifier = std::min(GC.getSAD_MAX_MODIFIER() + iEnclose, iExtraModifier);

	return iSurroundModifier + iSurroundModifier * lungeTotal() / 100;
	//TB Combat Mods End (SAD mods)
}


bool CvUnit::isCanMovePeaks() const
{
	return m_iCanMovePeaksCount > 0;
}

void CvUnit::changeCanMovePeaksCount(int iChange)
{
	m_iCanMovePeaksCount += iChange;
	FASSERT_NOT_NEGATIVE(m_iCanMovePeaksCount);
}

// Koshling - enhanced mountaineering mode to differentiate between ability to move through
//	mountains, and ability to lead a stack through mountains
bool CvUnit::isCanLeadThroughPeaks() const
{
	return m_iCanLeadThroughPeaksCount > 0;
}

void CvUnit::changeCanLeadThroughPeaksCount(int iChange)
{
	m_iCanLeadThroughPeaksCount += iChange;
	FASSERT_NOT_NEGATIVE(m_iCanLeadThroughPeaksCount);
}


int CvUnit::getMaxHurryFood() const
{
	return std::max(0, m_pUnitInfo->getBaseFoodChange() * GC.getGameSpeedInfo(GC.getGame().getGameSpeedType()).getHammerCostPercent() / 100);
}

int CvUnit::getHurryFood(const CvPlot* pPlot) const
{
	const CvCity* pCity = pPlot->getPlotCity();
	if (pCity == NULL) return 0;

	return std::max(0, std::min(pCity->growthThreshold() - pCity->getFood(), getMaxHurryFood()));
}

bool CvUnit::canHurryFood(const CvPlot* pPlot) const
{
	if (isDelayedDeath() || getHurryFood(pPlot) == 0)
	{
		return false;
	}

	const CvCity* pCity = pPlot->getPlotCity();
	if (pCity == NULL || pCity->getOwner() != getOwner() || pCity->getFoodTurnsLeft() == 1)
	{
		return false;
	}
	return true;
}


bool CvUnit::hurryFood()
{
	if (!canHurryFood(plot()))
	{
		return false;
	}

	CvCity* pCity = plot()->getPlotCity();

	if (pCity != NULL)
	{
		pCity->changeFood(getHurryFood(plot()));
	}

	if (plot()->isActiveVisible(false))
	{
		NotifyEntity(MISSION_HURRY_FOOD);
	}

	kill(true, NO_PLAYER, true);

	return true;
}

bool CvUnit::sleepForEspionage()
{
	if (!canSleep() || !canEspionage(plot(), true) || getFortifyTurns() == GC.getMAX_FORTIFY_TURNS())
	{
		return false;
	}
	m_iSleepTimer = 1;

	return true;
}


UnitCompCommander* CvUnit::getCommanderComp() const
{
	return m_commander;
}

bool CvUnit::isCommander() const
{
	return m_commander != NULL;
}

bool CvUnit::isCommanderReady() const
{
	return m_commander ? m_commander->isReady() : false;
}

void CvUnit::setCommander(bool bNewVal)
{
	PROFILE_EXTRA_FUNC();
	if (isCommander() == bNewVal || getDomainType() == DOMAIN_SEA) return;

	if (bNewVal)
	{
		m_commander = new UnitCompCommander(this, m_pUnitInfo);

		foreach_(const UnitCombatTypes eSubCombat, m_pUnitInfo->getSubCombatTypes())
		{
			if (GC.getUnitCombatInfo(eSubCombat).getQualityBase() > -10)
			{
				setHasUnitCombat(eSubCombat, false);
			}
		}
		plot()->countCommander(true, this);
	}
	else
	{
		if (m_commander->isReady())
		{
			plot()->countCommander(false, this);
		}
		delete m_commander;
		m_commander = NULL;
	}
	GET_PLAYER(getOwner()).listCommander(bNewVal, this);
}


CvUnit* CvUnit::getCommander() const
{
	PROFILE_FUNC();

	const CvPlot* pPlot = plot();
	if (pPlot == NULL || !pPlot->inCommandField(getOwner()) || getDomainType() == DOMAIN_SEA)
	{
		return NULL;
	}

	CvUnit* pBestCommander = getLastCommander();
	if (pBestCommander)
	{
		const int cachedDistance = plotDistance(pBestCommander->getX(), pBestCommander->getY(), getX(), getY());
		if (cachedDistance <= pBestCommander->getCommanderComp()->getCommandRange())
		{
			return pBestCommander;
		}
		pBestCommander = NULL;
	}

	int iBestCommanderDistance = std::numeric_limits<int>::max();
	int iBestCommanderXP = -1;

	const CvPlayer& player = GET_PLAYER(getOwner());
	const std::vector<CvUnit*>& commanders = player.getCommanders();

	for (std::vector<CvUnit*>::const_iterator it = commanders.begin(); it != commanders.end(); ++it)
	{
		CvUnit* com = *it;
		UnitCompCommander* comComp = com->getCommanderComp();
		if (comComp == NULL)
			continue;  // scurit si jamais a renvoie NULL
		if (comComp->getControlPointsLeft() <= 0)
			continue;

		const CvPlot* comPlot = com->plot();
		FAssertMsg(comPlot != NULL, "Unexpected... CTD incoming");

		const int iDistance = plotDistance(comPlot->getX(), comPlot->getY(), getX(), getY());
		if (iDistance > comComp->getCommandRange())
			continue;

		const int iXP = com->getExperience();
		if (
			pBestCommander == NULL ||
			iDistance < iBestCommanderDistance ||
			(iDistance == iBestCommanderDistance && iXP > iBestCommanderXP)
		)
		{
			pBestCommander = com;
			iBestCommanderDistance = iDistance;
			iBestCommanderXP = iXP;
			if (iDistance == 0) break; // Early exit: best possible
		}
	}
	m_iCommanderID = pBestCommander ? pBestCommander->getID() : -1;
	return pBestCommander;
}

void CvUnit::tryUseCommander()
{
	CvUnit* pCommander = getCommander();

	if (pCommander) //commander is used when any unit under his command fights in combat
	{
		m_iUsedCommanderID = pCommander->getID();

		pCommander->m_commander->changeControlPointsLeft(-1);

		if (!pCommander->m_commander->isReady())
		{
			FlushCombatStrCache(NULL);
			nullLastCommander();
		}
	}
}

void CvUnit::nullLastCommander()
{
	m_iCommanderID = -1;
}

// This only exist during combat with the purpose of remembering what commander should get exp.
CvUnit* CvUnit::getUsedCommander() const
{
	return (m_iUsedCommanderID == -1 ? NULL : GET_PLAYER(getOwner()).getUnit(m_iUsedCommanderID));
}

// This ties a commander to this unit for as long as said commander is valid;
//	it cease to be valid mid combat when it expends its last CP.
CvUnit* CvUnit::getLastCommander() const
{
	return (m_iCommanderID == -1 ? NULL : GET_PLAYER(getOwner()).getUnit(m_iCommanderID));
}


UnitCompCommodore* CvUnit::getCommodoreComp() const
{
	return m_commodore;
}

bool CvUnit::isCommodore() const
{
	return m_commodore != NULL;
}

bool CvUnit::isCommodoreReady() const
{
	return m_commodore ? m_commodore->isReady() : false;
}

void CvUnit::setCommodore(bool bNewVal)
{
	PROFILE_EXTRA_FUNC();
	if (isCommodore() == bNewVal) return;

	if (bNewVal)
	{
		m_commodore = new UnitCompCommodore(this, m_pUnitInfo);

		foreach_(const UnitCombatTypes eSubCombat, m_pUnitInfo->getSubCombatTypes())
		{
			if (GC.getUnitCombatInfo(eSubCombat).getQualityBase() > -10)
			{
				setHasUnitCombat(eSubCombat, false);
			}
		}
		plot()->countCommodore(true, this);
	}
	else
	{
		if (m_commodore->isReady())
		{
			plot()->countCommodore(false, this);
		}
		delete m_commodore;
		m_commodore = NULL;
	}
	GET_PLAYER(getOwner()).listCommodore(bNewVal, this);
}

CvUnit* CvUnit::getCommodore() const
{
	PROFILE_FUNC();

	const CvPlot* pPlot = plot();
	if (pPlot == NULL || !pPlot->inCommandCommodoreField(getOwner()) || getDomainType() == DOMAIN_LAND)
	{
		return NULL;
	}

	CvUnit* pBestCommodore = getLastCommodore();
	if (pBestCommodore)
	{
		const int cachedDistance = plotDistance(pBestCommodore->getX(), pBestCommodore->getY(), getX(), getY());
		if (cachedDistance <= pBestCommodore->getCommodoreComp()->getCommandRange())
		{
			return pBestCommodore;
		}
		// The one we used would have been the cached one so will have to search again
		pBestCommodore = NULL;
	}

	int iBestCommodoreDistance = std::numeric_limits<int>::max();
	int iBestCommodoreXP = -1;

	const CvPlayer& player = GET_PLAYER(getOwner());
	const std::vector<CvUnit*>& commodores = player.getCommodores();

	for (std::vector<CvUnit*>::const_iterator it = commodores.begin(); it != commodores.end(); ++it)
	{
		CvUnit* com = *it;
		UnitCompCommodore* comComp = com->getCommodoreComp();
		if (comComp == NULL)
			continue;  // scurit si jamais a renvoie NULL
		if (comComp->getControlPointsLeft() <= 0)
			continue;

		const CvPlot* comPlot = com->plot();
		FAssertMsg(comPlot != NULL, "Unexpected... CTD incoming");

		const int iDistance = plotDistance(comPlot->getX(), comPlot->getY(), getX(), getY());
		if (iDistance > comComp->getCommandRange())
			continue;

		const int iXP = com->getExperience();
		if (
			pBestCommodore == NULL ||
			iDistance < iBestCommodoreDistance ||
			(iDistance == iBestCommodoreDistance && iXP > iBestCommodoreXP)
		)
		{
			pBestCommodore = com;
			iBestCommodoreDistance = iDistance;
			iBestCommodoreXP = iXP;
			if (iDistance == 0) break; // Early exit: best possible
		}
	}
	m_iCommodoreID = pBestCommodore ? pBestCommodore->getID() : -1;
	return pBestCommodore;

}

void CvUnit::tryUseCommodore()
{
	CvUnit* pCommodore = getCommodore();

	if (pCommodore) //commodore is used when any unit under his command fights in combat
	{
		m_iUsedCommodoreID = pCommodore->getID();

		pCommodore->m_commodore->changeControlPointsLeft(-1);

		if (!pCommodore->m_commodore->isReady())
		{
			FlushCombatStrCache(NULL);
			nullLastCommodore();
		}
	}
}

void CvUnit::nullLastCommodore()
{
	m_iCommodoreID = -1;
}

// This only exist during combat with the purpose of remembering what commodore should get exp.
CvUnit* CvUnit::getUsedCommodore() const
{
	return (m_iUsedCommodoreID == -1 ? NULL : GET_PLAYER(getOwner()).getUnit(m_iUsedCommodoreID));
}

// This ties a commodore to this unit for as long as said commodore is valid;
//	it cease to be valid mid combat when it expends its last CP.
CvUnit* CvUnit::getLastCommodore() const
{
	return (m_iCommodoreID == -1 ? NULL : GET_PLAYER(getOwner()).getUnit(m_iCommodoreID));
}


int CvUnit::interceptionChance(const CvPlot* pPlot) const
{
	PROFILE_EXTRA_FUNC();
	int iNoInterceptionChanceTimes100 = 10000;

	for (int iI = 0; iI < MAX_PLAYERS; iI++)
	{
		if (GET_PLAYER((PlayerTypes)iI).isAlive() && !isInvisible(GET_PLAYER((PlayerTypes)iI).getTeam(), false, false))
		{
			foreach_(const CvUnit* pLoopUnit, GET_PLAYER((PlayerTypes)iI).units())
			{
				if (pLoopUnit->canAirDefend() && !pLoopUnit->isMadeInterception() && isEnemy(pLoopUnit->getTeam(), NULL, pLoopUnit)
				&& (pLoopUnit->getDomainType() != DOMAIN_AIR || !pLoopUnit->hasMoved() && pLoopUnit->getGroup()->getActivityType() == ACTIVITY_INTERCEPT)
				&& plotDistance(pLoopUnit->getX(), pLoopUnit->getY(), pPlot->getX(), pPlot->getY()) <= pLoopUnit->airRange())
				{
					const int iValue = pLoopUnit->currInterceptionProbability();

					if (iValue > 0)
					{
						if (iValue > 99) return 100;

						iNoInterceptionChanceTimes100 *= 100 - iValue;
						iNoInterceptionChanceTimes100 /= 100;
						if (iNoInterceptionChanceTimes100 < 100)
						{
							return 100;
						}
					}
				}
			}
		}
	}
	return 100 - iNoInterceptionChanceTimes100 / 100;
}

PlayerTypes CvUnit::getOriginalOwner() const
{
	return m_eOriginalOwner;
}

void CvUnit::doBattleFieldPromotions(CvUnit* pDefender, const CombatDetails& cdDefenderDetails, const CvPlot* pPlot, bool bAttackerHasLostNoHP, bool bAttackerWithdrawn, int iAttackerInitialDamage, int iWinningOdds, int iInitialAttXP, int iInitialAttGGXP, int iDefenderInitialDamage, int iInitialDefXP, int iInitialDefGGXP, bool& bAttackerPromoted, bool& bDefenderPromoted, int iNonLethalAttackWinChance, int iNonLethalDefenseWinChance, int iDefenderFirstStrikes, int iAttackerFirstStrikes)
{
	PROFILE_EXTRA_FUNC();
	if (!GC.getGame().getModderGameOption(MODDERGAMEOPTION_BATTLEFIELD_PROMOTIONS) ||
		getUnitCombatType() == NO_UNITCOMBAT || pDefender->getUnitCombatType() == NO_UNITCOMBAT)
	{
		return;
	}

	bool bNoDefBon = noDefensiveBonus();
	std::vector<PromotionTypes> aAttackerAvailablePromotions;
	std::vector<PromotionTypes> aDefenderAvailablePromotions;
	for (int iI = 0; iI < GC.getNumPromotionInfos(); iI++)
	{
		const PromotionTypes promotionType = static_cast<PromotionTypes>(iI);
		const CvPromotionInfo& kPromotion = GC.getPromotionInfo(promotionType);
		/* Block These Promotions */
		if (kPromotion.getKamikazePercent() > 0 ||
			kPromotion.isLeader() ||
			kPromotion.hasNegativeEffects())
		{
			continue;
		}

		//TB Combat Mods Begin
		if (pDefender->isDead() || m_combatResult.bDefenderKnockedBack)
		{
			if (!canAcquirePromotion(promotionType)) //attacker can not acquire this promotion
			{
				continue;
			}
			//* attacker may receive pursuit
			if (m_combatResult.bDefenderWithdrawn && kPromotion.getPursuitChange() > 0)
			{
				aAttackerAvailablePromotions.push_back(promotionType);
			}
			if (m_combatResult.bDefenderPursued && kPromotion.getPursuitChange() > 0)
			{
				aAttackerAvailablePromotions.push_back(promotionType);
			}
			//* attacker was attacking a fortified defender and may receive Overrun
			if (cdDefenderDetails.iFortifyModifier > 0 && kPromotion.getOverrunChange() > 0)
			{
				aAttackerAvailablePromotions.push_back(promotionType);
			}
			//* attacker was unyielding against a Repel
			if (!bNoDefBon)
			{
				if (m_combatResult.bAttackerRefusedtoYield && kPromotion.getUnyieldingChange() > 0)
				{
					aAttackerAvailablePromotions.push_back(promotionType);
				}
			}
			//* attacker Knocked back defender
			if (m_combatResult.bDefenderKnockedBack && kPromotion.getKnockbackChange() > 0)
			{
				aAttackerAvailablePromotions.push_back(promotionType);
			}
			//* attacker was attacking with S&D bonus
			if (kPromotion.getLungeChange() > 0 && surroundedDefenseModifier(pPlot, pDefender) != 0)
			{
				aAttackerAvailablePromotions.push_back(promotionType);
			}
			//* attacker had less dodge than defender's precision
			if (kPromotion.getDodgeModifierChange() > 0 && (dodgeVSOpponentProbTotal(pDefender) < pDefender->precisionVSOpponentProbTotal(this)))
			{
				aAttackerAvailablePromotions.push_back(promotionType);
			}
			//* defender had more dodge than attacker's precision
			if (kPromotion.getPrecisionModifierChange() > 0 && (pDefender->dodgeVSOpponentProbTotal(this) > precisionVSOpponentProbTotal(pDefender)))
			{
				aAttackerAvailablePromotions.push_back(promotionType);
			}
			//* attacker is developing critical chance
			if (kPromotion.getCriticalModifierChange() > 0 && (criticalVSOpponentProbTotal(pDefender) > 0))
			{
				aAttackerAvailablePromotions.push_back(promotionType);
			}
			//* attacker is developing endurance
			if (kPromotion.getEnduranceChange() > 0 && (enduranceTotal() > 0))
			{
				aAttackerAvailablePromotions.push_back(promotionType);
			}
			//TB Combat Mods End
			//* attacker was crossing river
			if (kPromotion.isRiver() && cdDefenderDetails.iRiverAttackModifier != 0)	//this bonus is being applied to defender
			{
				aAttackerAvailablePromotions.push_back(promotionType);
			}
			//* attack from water
			if (kPromotion.isAmphib() && cdDefenderDetails.iAmphibAttackModifier != 0)
			{
				aAttackerAvailablePromotions.push_back(promotionType);
			}
			//* attack terrain
			if (kPromotion.getTerrainAttackPercent((int)pPlot->getTerrainType()) > 0)
			{
				aAttackerAvailablePromotions.push_back(promotionType);
			}
			//* attack feature
			if (pPlot->getFeatureType() != NO_FEATURE &&
				kPromotion.getFeatureAttackPercent((int)pPlot->getFeatureType()) > 0)
			{
				aAttackerAvailablePromotions.push_back(promotionType);
			}
			//* attack hills
			if (kPromotion.getHillsAttackPercent() > 0 && pPlot->isHills())
			{
				aAttackerAvailablePromotions.push_back(promotionType);
			}
			//* attack city
			if (kPromotion.getCityAttackPercent() > 0 && pPlot->isCity(true))	//count forts too
			{
				aAttackerAvailablePromotions.push_back(promotionType);
			}
			//* first strikes/chanses promotions
			if ((kPromotion.getFirstStrikesChange() > 0 ||
				kPromotion.getChanceFirstStrikesChange() > 0) && (firstStrikes() > 0 || chanceFirstStrikes() > 0))
			{
				aAttackerAvailablePromotions.push_back(promotionType);
			}
			//* unit combat mod
			if (kPromotion.getUnitCombatModifierPercent((int)pDefender->getUnitCombatType()) > 0)
			{
				aAttackerAvailablePromotions.push_back(promotionType);
			}
			//TB Combat Mods Begin * anti-barbarian combat mod
			if (kPromotion.getVSBarbsChange() > 0 && (pDefender->isHominid()))
			{
				aAttackerAvailablePromotions.push_back(promotionType);
			}
			if (kPromotion.getStrengthChange() > 0)
			{
				aAttackerAvailablePromotions.push_back(promotionType);
			}
			if (kPromotion.getAttackCombatModifierChange() > 0)
			{
				aAttackerAvailablePromotions.push_back(promotionType);
			}
			//TB Combat Mods End
			//* combat strength promotions
			if (kPromotion.getCombatPercent() > 0 && !kPromotion.isAmphib())
			{
				aAttackerAvailablePromotions.push_back(promotionType);
			}
			//* domain mod
			if (kPromotion.getDomainModifierPercent((int)pDefender->getDomainType()))
			{
				aAttackerAvailablePromotions.push_back(promotionType);
			}
			//* blitz
			if (kPromotion.isBlitz() && bAttackerHasLostNoHP)
			{
				aAttackerAvailablePromotions.push_back(promotionType);
			}
		}	//if defender is dead or withdrawn
		//* defender withdrawn, give him withdrawal promo
		else if (m_combatResult.bDefenderWithdrawn)
		{
			if (kPromotion.getWithdrawalChange() > 0 &&
				pDefender->canAcquirePromotion(promotionType))
			{
				aDefenderAvailablePromotions.push_back(promotionType);
			}
		}
		//* attacker withdrawn
		else if (bAttackerWithdrawn)
		{
			if (kPromotion.getWithdrawalChange() > 0 &&
				canAcquirePromotion(promotionType))
			{
				aAttackerAvailablePromotions.push_back(promotionType);
			}
			if (kPromotion.getPursuitChange() > 0 &&
				pDefender->canAcquirePromotion(promotionType))
			{
				aDefenderAvailablePromotions.push_back(promotionType);
			}
		}
		//* attacker is presumably dead
		else
		{
			FAssertMsg(isDead(), "Attacker is expected to be dead");
			if (!pDefender->canAcquirePromotion(promotionType))
			{
				continue;
			}
			//TB Combat Mods Begin
				//* Defender may recieve pursuit
			if (m_combatResult.bAttackerPursued && kPromotion.getPursuitChange() > 0)
			{
				aDefenderAvailablePromotions.push_back(promotionType);
			}
			//* Defender Repelled Attacker
			if (!bNoDefBon)
			{
				if (m_combatResult.bAttackerRepelled && kPromotion.getRepelChange() > 0)
				{
					aDefenderAvailablePromotions.push_back(promotionType);
				}
				//* Defender Repelled Attacker while Fortified
				if (m_combatResult.bAttackerRepelled && cdDefenderDetails.iFortifyModifier > 0 && kPromotion.getFortRepelChange() > 0)
				{
					aDefenderAvailablePromotions.push_back(promotionType);
				}
			}
			//* Defender Refused to be Knocked Back
			if (m_combatResult.bDefenderRefusedtoYield && kPromotion.getUnyieldingChange() > 0)
			{
				aDefenderAvailablePromotions.push_back(promotionType);
			}
			//* Defender Suffered Surround and Destroy Modifier
			if (kPromotion.getDynamicDefenseChange() > 0 && surroundedDefenseModifier(pPlot, pDefender) != 0)
			{
				aDefenderAvailablePromotions.push_back(promotionType);
			}
			if (kPromotion.getStrengthChange() > 0)
			{
				aDefenderAvailablePromotions.push_back(promotionType);
			}
			if (kPromotion.getAnimalIgnoresBordersChange() > 0 && pDefender->isAnimal() && !GC.getGame().isOption(GAMEOPTION_ANIMAL_STAY_OUT))
			{
				aDefenderAvailablePromotions.push_back(promotionType);
			}
			//TB Combat Mods End
			//* defend terrain
			if (!noDefensiveBonus() && (kPromotion.getTerrainDefensePercent((int)pPlot->getTerrainType()) > 0))
			{
				aDefenderAvailablePromotions.push_back(promotionType);
			}
			//* defend feature
			if (!noDefensiveBonus() && (pPlot->getFeatureType() != NO_FEATURE &&
				kPromotion.getFeatureDefensePercent((int)pPlot->getFeatureType()) > 0))
			{
				aDefenderAvailablePromotions.push_back(promotionType);
			}
			//* defend hills
			if (!noDefensiveBonus() && (kPromotion.getHillsDefensePercent() > 0 && pPlot->isHills()))
			{
				aDefenderAvailablePromotions.push_back(promotionType);
			}
			//* defend city
			if (!noDefensiveBonus() && kPromotion.getCityDefensePercent() > 0 && pPlot->isCity(true))	//count forts too
			{
				aDefenderAvailablePromotions.push_back(promotionType);
			}
			//* first strikes/chanses promotions
			if ((kPromotion.getFirstStrikesChange() > 0 ||
				kPromotion.getChanceFirstStrikesChange() > 0) &&
				(pDefender->firstStrikes() > 0 || pDefender->chanceFirstStrikes() > 0))
			{
				aDefenderAvailablePromotions.push_back(promotionType);
			}
			//* unit combat mod vs attacker unit type
			if (kPromotion.getUnitCombatModifierPercent((int)getUnitCombatType()) > 0)
			{
				aDefenderAvailablePromotions.push_back(promotionType);
			}
			//TB Combat Mods Begin * anti-barbarian combat mod
			if (kPromotion.getVSBarbsChange() > 0 && isHominid())
			{
				aDefenderAvailablePromotions.push_back(promotionType);
			}

			if (!noDefensiveBonus() && kPromotion.getDefenseCombatModifierChange() > 0)
			{
				aDefenderAvailablePromotions.push_back(promotionType);
			}
			//* defemder had less dodge than attacker's precision
			if (kPromotion.getDodgeModifierChange() > 0 && (pDefender->dodgeVSOpponentProbTotal(this) < precisionVSOpponentProbTotal(pDefender)))
			{
				aDefenderAvailablePromotions.push_back(promotionType);
			}
			//* attacker had more dodge than defender's precision
			if (kPromotion.getPrecisionModifierChange() > 0 && (dodgeVSOpponentProbTotal(pDefender) > pDefender->precisionVSOpponentProbTotal(this)))
			{
				aDefenderAvailablePromotions.push_back(promotionType);
			}
			//* defender is developing critical chance
			if (kPromotion.getCriticalModifierChange() > 0 && (pDefender->criticalVSOpponentProbTotal(this) > 0))
			{
				aDefenderAvailablePromotions.push_back(promotionType);
			}
			//* defender is developing endurance
			if (kPromotion.getEnduranceChange() > 0 && (pDefender->enduranceTotal() > 0))
			{
				aDefenderAvailablePromotions.push_back(promotionType);
			}
			//TB Combat Mods End
			//* combat strength promotions
			if (kPromotion.getCombatPercent() > 0)
			{
				aDefenderAvailablePromotions.push_back(promotionType);
			}
			//* domain mod
			if (kPromotion.getDomainModifierPercent((int)getDomainType()))
			{
				aDefenderAvailablePromotions.push_back(promotionType);
			}
		}	//if attacker withdrawn
	}	//end promotion types cycle

	//promote attacker:
	if (!isDead() && aAttackerAvailablePromotions.size() > 0)
	{
		FAssertMsg(getMaxHP() - iAttackerInitialDamage > 0, "Attacker is Dead!");
		int iHealthPercent = (getMaxHP() - getDamage()) * 100 / std::max(1, getMaxHP() - iAttackerInitialDamage);
		iNonLethalAttackWinChance *= 10;
		int iOdds = std::max(iWinningOdds, iNonLethalAttackWinChance);
		int iPromotionChance = (GC.getCOMBAT_DIE_SIDES() - iOdds)/* * (100 + iPromotionChanceModifier) / 100*/;

		int iFirstStrikes = 1 + iAttackerFirstStrikes;
		iFirstStrikes = std::max(1, iFirstStrikes);

		iPromotionChance /= iFirstStrikes;
		if (GC.getGame().getSorenRandNum(GC.getCOMBAT_DIE_SIDES(), "Occasional Promotion") < iPromotionChance)
		{
			//select random promotion from available
			PromotionTypes ptPromotion = aAttackerAvailablePromotions[
				GC.getGame().getSorenRandNum(aAttackerAvailablePromotions.size(), "Select Promotion Type")];
			//promote
			//TB Combat Mod next line
			setHasPromotion(ptPromotion, true, false);
			bAttackerPromoted = true;

			setExperience100(iInitialAttXP);
			GET_PLAYER(getOwner()).setCombatExperience(iInitialAttGGXP, getGGExperienceEarnedTowardsType());

			//show message
			const CvWString szBuffer = gDLL->getText("TXT_KEY_MISC_YOUR_UNIT_PROMOTED_IN_BATTLE", getNameKey(), GC.getPromotionInfo(ptPromotion).getText());
			AddDLLMessage(
				getOwner(), false, GC.getEVENT_MESSAGE_TIME(), szBuffer,
				GC.getPromotionInfo((PromotionTypes)0).getSound(), MESSAGE_TYPE_INFO, NULL,
				GC.getCOLOR_GREEN(), getX(), getY()
			);
		}
	}

	//promote defender:
	if (!pDefender->isDead() && aDefenderAvailablePromotions.size() > 0)
	{
		FAssertMsg(pDefender->getMaxHP() - iDefenderInitialDamage > 0, "Defender is Dead!");
		int iHealthPercent = (pDefender->getMaxHP() - pDefender->getDamage()) * 100 / std::max(1, pDefender->getMaxHP() - iDefenderInitialDamage);
		iNonLethalDefenseWinChance *= 10;
		iNonLethalDefenseWinChance = std::max(0, (GC.getCOMBAT_DIE_SIDES() - iNonLethalDefenseWinChance));
		int iOdds = std::min(iWinningOdds, iNonLethalDefenseWinChance);
		int iPromotionChance = iOdds/* * (100 + iPromotionChanceModifier) / 100*/;
		int iFirstStrikes = 1 + iDefenderFirstStrikes;
		//change to stealth strikes if stealth combat
		iFirstStrikes = std::max(1, iFirstStrikes);
		iPromotionChance /= iFirstStrikes;
		if (GC.getGame().getSorenRandNum(GC.getCOMBAT_DIE_SIDES(), "Occasional Promotion") < iPromotionChance)
		{
			//select random promotion from available
			PromotionTypes ptPromotion = aDefenderAvailablePromotions[
				GC.getGame().getSorenRandNum(aDefenderAvailablePromotions.size(), "Select Promotion Type")];
			//promote
			//TB Combat Mod next line
			pDefender->setHasPromotion(ptPromotion, true, false);

			pDefender->setExperience100(iInitialDefXP);
			GET_PLAYER(pDefender->getOwner()).setCombatExperience(iInitialDefGGXP, pDefender->getGGExperienceEarnedTowardsType());
			bDefenderPromoted = true;

			//show message
			{

				CvWString szBuffer = gDLL->getText("TXT_KEY_MISC_YOUR_UNIT_PROMOTED_IN_BATTLE", pDefender->getNameKey(),
					GC.getPromotionInfo(ptPromotion).getText());
				AddDLLMessage(
					pDefender->getOwner(), false, GC.getEVENT_MESSAGE_TIME(), szBuffer,
					GC.getPromotionInfo((PromotionTypes)0).getSound(), MESSAGE_TYPE_INFO, NULL,
					GC.getCOLOR_GREEN(), pPlot->getX(), pPlot->getY());
			}
		}
	}
}


void CvUnit::doDynamicXP(CvUnit* pDefender, const CvPlot* pPlot, int iAttackerInitialDamage, int iAttackerWinOdds, int iDefenderInitialDamage, bool bPromotion, bool bDefPromotion)
{
	if (!isDead() && !pDefender->isDead())
	{
		// Combat aborted before conclusion, withdrawals and the like.
		if (!bPromotion && attackXPValue() > 0)
		{
			applyDynamicXP(
				getEngagementDynamicXP(
					pDefender, GC.getCOMBAT_DIE_SIDES() - iAttackerWinOdds,
					iDefenderInitialDamage,
					iAttackerInitialDamage,
					50 * defenseXPValue()
				),
				pPlot->getOwner() == getOwner(),
				100 * maxXPValue(this)
			);
		}
		if (!bDefPromotion && pDefender->defenseXPValue() > 0)
		{
			pDefender->applyDynamicXP(
				pDefender->getEngagementDynamicXP(
					this, iAttackerWinOdds,
					iAttackerInitialDamage,
					iDefenderInitialDamage,
					50 * pDefender->defenseXPValue()
				),
				pPlot->getOwner() == pDefender->getOwner(),
				100 * pDefender->maxXPValue(this)
			);
		}
	}
	else if (!bPromotion && !isDead() && attackXPValue() > 0)
	{
		applyDynamicXP(
			getVanquishDynamicXP(
				GC.getCOMBAT_DIE_SIDES() - iAttackerWinOdds, iAttackerInitialDamage, 100 * attackXPValue()
			),
			pPlot->getOwner() == getOwner(),
			100 * maxXPValue(pDefender)
		);
	}
	else if (!bDefPromotion && !pDefender->isDead() && pDefender->defenseXPValue() > 0)
	{
		pDefender->applyDynamicXP(
			pDefender->getVanquishDynamicXP(
				iAttackerWinOdds, iDefenderInitialDamage, 100 * pDefender->defenseXPValue()
			),
			pPlot->getOwner() == pDefender->getOwner(),
			100 * pDefender->maxXPValue(this)
		);
	}
}

int CvUnit::getEngagementDynamicXP(const CvUnit* enemy, const int iLoseOdds, const int iInitialDamageEnemy, const int iInitialDamage, const int iMaxXP) const
{
	const int iHealthPercentLost = 1000 - (getMaxHP() - getDamage()) * 1000 / (getMaxHP() - iInitialDamage);
	const int iHealthPercentLostEnemy = 1000 - (enemy->getMaxHP() - enemy->getDamage()) * 1000 / (enemy->getMaxHP() - iInitialDamageEnemy);
	const int iMod = iHealthPercentLost + 3*iHealthPercentLostEnemy + 6*iLoseOdds;

	// Damage done, modified by chance to lose and damage received.
	return range((iHealthPercentLostEnemy + 1) * (iLoseOdds + 1) * (1000 + iMod) / 1000000, 0, iMaxXP);
}

int CvUnit::getVanquishDynamicXP(const int iLoseOdds, const int iInitialDamage, const int iMaxXP) const
{
	const int iMinXP = 1 + std::min(GC.getGame().getSorenRandNum(15, ""), iMaxXP);
	const int iMaxHP = getMaxHP();
	const int iHealthPercentLost = 1000 - (iMaxHP - getDamage()) * 1000 / (iMaxHP - iInitialDamage);

	FAssertMsg(iMaxHP - iInitialDamage > 0, "Applying exp to a dead unit!");

	// First factor of 10 means that if the unit lose 99.9% of its max life it will get 10 times more XP.
	const int iMod = 10 * iHealthPercentLost * iMaxHP / (iMaxHP + 10 * iInitialDamage);

	// Chance of losing, modified by hardship of winning,
	//	where an outworn unit doesn't learn as much from hardship as a combat ready unit.
	return range(iLoseOdds * (1000 + iMod) / 1000, iMinXP, iMaxXP);
}

void CvUnit::applyDynamicXP(const int iExperience, const bool bHomeTerritory, int iMaxTotalXP)
{
	// Toffer - Allow a little xp against animals and barbs if above the max with dynamic XP.
	//	The diminshing return of dynamic XP makes it somewhat of a natural xp limiter against weak foes even before reaching the limit.
	if (iMaxTotalXP > -1 && getExperience100() + iExperience > iMaxTotalXP)
	{
		iMaxTotalXP = std::max(iMaxTotalXP, getExperience100() + iExperience / 10);
	}
	changeExperience100(iExperience, iMaxTotalXP, true, bHomeTerritory, true);
}



bool CvUnit::isTerrainProtected(TerrainTypes eIndex) const
{
	FASSERT_BOUNDS(0, GC.getNumTerrainInfos(), eIndex);
	return getTerrainProtectedCount(eIndex) > 0;
}

int CvUnit::getTerrainProtectedCount(TerrainTypes eIndex) const
{
	FASSERT_BOUNDS(0, GC.getNumTerrainInfos(), eIndex);

	const TerrainKeyedInfo* info = findTerrainKeyedInfo(eIndex);

	int iTotal = info ? info->m_iTerrainProtected : 0;

	if (!isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander)
		{
			iTotal += pCommander->getTerrainProtectedCount(eIndex);
		}
	}

	if (!isCommodore())
    	{
    		const CvUnit* pCommodore = getCommodore();
    		if (pCommodore)
    		{
    			iTotal += pCommodore->getTerrainProtectedCount(eIndex);
    		}
    	}
	return iTotal;
}


void CvUnit::changeTerrainProtected(TerrainTypes eIndex, int iChange)
{
	FASSERT_BOUNDS(0, GC.getNumTerrainInfos(), eIndex);

	if (iChange != 0)
	{
		findOrCreateTerrainKeyedInfo(eIndex)->m_iTerrainProtected += iChange;
	}
}


int CvUnit::getZoneOfControlCount() const
{
	return m_iZoneOfControlCount;
}

bool CvUnit::isZoneOfControl() const
{
	return (getZoneOfControlCount() > 0);
}

void CvUnit::changeZoneOfControlCount(int iChange)
{
	m_iZoneOfControlCount += iChange;
	if (isZoneOfControl())
	{
		GC.getGame().toggleAnyoneHasUnitZoneOfControl();
	}
	//TB Combat Mod Debug
	FASSERT_NOT_NEGATIVE(getZoneOfControlCount());
}

bool CvUnit::isAutoPromoting() const
{
	return m_bAutoPromoting;
}
void CvUnit::setAutoPromoting(bool bNewValue)
{
	m_bAutoPromoting = bNewValue;
	if (bNewValue)
	{
		//Force recalculation
		setPromotionReady(false);
		testPromotionReady();
	}
}

bool CvUnit::isAutoUpgrading() const
{
	return m_bAutoUpgrading;
}

void CvUnit::setAutoUpgrading(bool bNewValue)
{
	m_bAutoUpgrading = bNewValue;
}


bool CvUnit::canShadow() const
{
	if (!canAttack())
	{
		return false;
	}

	if (GET_PLAYER(getOwner()).isModderOption(MODDEROPTION_HIDE_AUTO_PROTECT))
	{
		return false;
	}

	return true;
}

bool CvUnit::canShadowAt(const CvPlot* pShadowPlot, CvUnit* pShadowUnit) const
{
	if (!canShadow() || !pShadowPlot)
	{
		return false;
	}

	if (!pShadowUnit)
	{
		pShadowUnit = pShadowPlot->getCenterUnit(false);
	}
	if (!pShadowUnit
	|| pShadowUnit == this
	|| pShadowUnit->getTeam() != getTeam()
	|| pShadowUnit->baseMoves() > baseMoves())
	{
		return false;
	}

	int iPathTurns;
	if (!generatePath(pShadowPlot, 0, true, &iPathTurns))
	{
		return false;
	}
	return true;
}

CvUnit* CvUnit::getShadowUnit() const
{
	return getUnit(m_shadowUnit);
}


void CvUnit::setShadowUnit(const CvUnit* pUnit)
{
	if (pUnit != NULL)
	{
		m_shadowUnit = pUnit->getIDInfo();
	}
	else
	{
		m_shadowUnit.reset();
	}
}


CvProperties* CvUnit::getProperties()
{
	return &m_Properties;
}

const CvProperties* CvUnit::getPropertiesConst() const
{
	return &m_Properties;
}

void CvUnit::addMission(const CvMissionDefinition& mission)
{
	if (mission.isValid())
	{
		gDLL->getEntityIFace()->AddMission(&mission);
	}
}

bool CvUnit::isArcher() const
{
	return isHasUnitCombat(GC.getUNITCOMBAT_ARCHER());
}

//TB Combat Mods begin
bool CvUnit::isPromotionOverriden(PromotionTypes ePromotionType) const
{
	PROFILE_EXTRA_FUNC();
	if (isHasPromotion(ePromotionType))
	{
		for (int iI = 0; iI < GC.getNumPromotionInfos(); iI++)
		{
			const PromotionTypes ePromotion = ((PromotionTypes)iI);
			if (isHasPromotion(ePromotion))
			{
				if (GC.getPromotionInfo(ePromotionType).getPromotionLine() != NO_PROMOTIONLINE)
				{
					if (GC.getPromotionInfo(ePromotionType).getPromotionLine() == GC.getPromotionInfo(ePromotion).getPromotionLine())
					{
						if (GC.getPromotionInfo(ePromotionType).getLinePriority() < GC.getPromotionInfo(ePromotion).getLinePriority())
						{
							return true;
						}
					}
				}
			}
		}
	}
	return false;
}


#ifdef OUTBREAKS_AND_AFFLICTIONS
bool CvUnit::canCure(const CvPlot* pPlot, PromotionLineTypes eAfflictionLine) const
{
	PROFILE_EXTRA_FUNC();
	if (!GC.getGame().isOption(GAMEOPTION_COMBAT_OUTBREAKS_AND_AFFLICTIONS))
	{
		return false;
	}

	if (hasCureAfflictionType(eAfflictionLine))
	{
		//Check our current tile
		foreach_(const CvUnit* pLoopUnit, pPlot->units())
		{
			if (pLoopUnit->getTeam() == getTeam())
			{
				if (pLoopUnit->hasAfflictionLine(eAfflictionLine))
				{
					return true;
				}
			}
		}
	}
	return false;
}

bool CvUnit::CureAffliction(PromotionLineTypes eAfflictionLine)
{
	PROFILE_EXTRA_FUNC();
	const CvPlot* pPlot = plot();

	if (!canCure(pPlot, eAfflictionLine))
	{
		return false;
	}

	//Check our current tile
	foreach_(CvUnit* pLoopUnit, pPlot->units())
	{
		if (pLoopUnit->getTeam() == getTeam())
		{
			if (pLoopUnit->hasAfflictionLine(eAfflictionLine))
			{
				pLoopUnit->recover(eAfflictionLine);

				if (pPlot->isActiveVisible(false))
				{
					NotifyEntity(MISSION_CURE);
				}
				break;
			}
		}
	}
	return false;
}

int CvUnit::getTotalCommunicableExposure(PromotionLineTypes eAfflictionLine) const
{
	//const CvPromotionLineInfo& kAffliction = GC.getPromotionLineInfo(eAfflictionLine);
	const CvPlot* pPlot = plot();
	if (pPlot == NULL)
	{
		return 0;
	}

	int	iTileCommunicability = pPlot->getCommunicability(eAfflictionLine, false, true, true);
	int iUnitCommunicability = getUnitCommunicability(eAfflictionLine);
	int iCityCommunicability = getCityCommunicability(eAfflictionLine);
	int iTotal = iTileCommunicability + iUnitCommunicability + iCityCommunicability;
	return iTotal;
}

int CvUnit::getCityCommunicability(PromotionLineTypes eAfflictionLine) const
{
	PROFILE_EXTRA_FUNC();
	CvPlot* pPlot = plot();
	if (pPlot == NULL)
	{
		return 0;
	}

	CvCity* pCity = pPlot->getPlotCity();
	int iCommunicability = 0;

	if (pCity != NULL && pCity->hasAfflictionType(eAfflictionLine)
	&& !GC.getPromotionLineInfo(eAfflictionLine).isNoSpreadCitytoUnit())
	{
		for (int iI = 0; iI < GC.getPromotionLineInfo(eAfflictionLine).getNumBuildings(); iI++)
		{
			BuildingTypes eAfflictionBuilding = (BuildingTypes)GC.getPromotionLineInfo(eAfflictionLine).getBuilding(iI);
			if (pCity->isActiveBuilding(eAfflictionBuilding))
			{
				iCommunicability += GC.getBuildingInfo(eAfflictionBuilding).getTradeCommunicability();
			}
		}
	}
	return iCommunicability;
}

int CvUnit::getUnitCommunicability(PromotionLineTypes eAfflictionLine) const
{
	PROFILE_EXTRA_FUNC();
	int iWorstCommunicability = 0;
	int iCommunicability = 0;
	const CvPlot* pPlot = plot();
	if (pPlot == NULL)
	{
		return 0;
	}

	if (!GC.getPromotionLineInfo(eAfflictionLine).isNoSpreadUnitProximity())
	{
		const int iBaseCommunicability = GC.getPromotionLineInfo(eAfflictionLine).getCommunicability();
		foreach_(const CvUnit* pLoopUnit, pPlot->units())
		{
			if (pLoopUnit != this && pLoopUnit->hasAfflictionLine(eAfflictionLine))
			{
				iCommunicability = iBaseCommunicability;
				iCommunicability += pLoopUnit->worsenedProbabilitytoAfflict(eAfflictionLine);
				if (iWorstCommunicability < iCommunicability)
				{
					iWorstCommunicability = iCommunicability;
				}
			}
		}
	}
	return iWorstCommunicability;
}

void CvUnit::doOvercomeAttempt(PromotionLineTypes eAfflictionLine)
{
	CvWString szBuffer;
	int iOvercomeChance = getChancetoOvercome(eAfflictionLine);
	int iOvercomeRollResult;

	iOvercomeRollResult = GC.getGame().getSorenRandNum(100, "Overcome");
	if (iOvercomeRollResult < iOvercomeChance)
	{
		recover(eAfflictionLine);
	}
}

int CvUnit::getChancetoOvercome(PromotionLineTypes eAfflictionLine) const
{
	if (eAfflictionLine == NO_PROMOTIONLINE)
	{
		return 0;
	}
	PropertyTypes eProperty = GC.getPromotionLineInfo(eAfflictionLine).getPropertyType();
	if (eProperty == NO_PROPERTY)
	{
		return 0;
	}

	int iChance = GC.getPromotionLineInfo(eAfflictionLine).getOvercomeProbability();
	iChance += fortitudeTotal();
	iChance += getFortitudeModifierTypeAmount(eAfflictionLine);
	iChance += aidVolume(plot(), eProperty);
	iChance += currentOvercome(eAfflictionLine);
	iChance += getUnitAfflictionTolerance(eAfflictionLine);
	iChance += getOvercomeChange(eAfflictionLine);
	iChance += (GC.getPromotionLineInfo(eAfflictionLine).getWorsenedOvercomeIncrementModifier() * (getAfflictionLineCount(eAfflictionLine)-1));

	iChance *= GC.getPromotionLineInfo(eAfflictionLine).getOvercomeModifier();
	iChance /= 100;
	return iChance;
}

int CvUnit::currentOvercome(PromotionLineTypes eAfflictionLine) const
{
	return (GC.getPromotionLineInfo(eAfflictionLine).getOvercomeAdjperTurn() * getAfflictionTurnCount(eAfflictionLine));
}

int CvUnit::getAfflictionTurnCount(PromotionLineTypes ePromotionLineType) const
{
	FASSERT_BOUNDS(0, GC.getNumPromotionLineInfos(), ePromotionLineType);

	const PromotionLineKeyedInfo* info = findPromotionLineKeyedInfo(ePromotionLineType);

	return info == NULL ? 0 : info->m_iAfflictionTurnTypeCount;
}

void CvUnit::changeAfflictionTurnCount(PromotionLineTypes ePromotionLineType, int iChange)
{
	FASSERT_BOUNDS(0, GC.getNumPromotionLineInfos(), ePromotionLineType);

	if (iChange != 0)
	{
		PromotionLineKeyedInfo* info = findOrCreatePromotionLineKeyedInfo(ePromotionLineType);

		info->m_iAfflictionTurnTypeCount += iChange;
	}
}

void CvUnit::setAfflictionTurnCount(PromotionLineTypes ePromotionLineType, int iChange)
{
	FASSERT_BOUNDS(0, GC.getNumPromotionLineInfos(), ePromotionLineType);

	PromotionLineKeyedInfo* info = findOrCreatePromotionLineKeyedInfo(ePromotionLineType, iChange != 0);

	if (info != NULL)
	{
		info->m_iAfflictionTurnTypeCount = iChange;
	}
}

int CvUnit::aidVolume(const CvPlot* pPlot, PropertyTypes eProperty) const
{
	PROFILE_FUNC();

	const CvCity* pCity = pPlot->getPlotCity();

	int iTotalAid = 0;

	if (pPlot->isCity(true, getTeam()))
	{
		if (pCity && !pCity->isOccupation())
		{
			iTotalAid += pCity->getAidRate(eProperty);
		}
	}

	int iBestAid = 0;

	foreach_(const CvUnit* pLoopUnit, pPlot->units())
	{
		if (pLoopUnit->getTeam() == getTeam())
		{
			const int iAid = pLoopUnit->aidTotal(eProperty);

			if (iAid > iBestAid)
			{
				iBestAid = iAid;
			}
		}
	}

	iTotalAid += iBestAid;

	return iTotalAid;
}

int CvUnit::getAfflictionHitCount(PromotionTypes ePromotionType) const
{
	FASSERT_BOUNDS(0, GC.getNumPromotionInfos(), ePromotionType);

	const PromotionKeyedInfo* info = findPromotionKeyedInfo(ePromotionType);

	return info == NULL ? 0 : info->m_iAfflictionHitCount;
}

void CvUnit::changeAfflictionHitCount(PromotionTypes ePromotionType, int iChange)
{
	FASSERT_BOUNDS(0, GC.getNumPromotionInfos(), ePromotionType);

	if (iChange != 0)
	{
		PromotionKeyedInfo* info = findOrCreatePromotionKeyedInfo(ePromotionType);

		info->m_iAfflictionHitCount += iChange;
	}
}

void CvUnit::setAfflictionHitCount(PromotionTypes ePromotionType, int iChange)
{
	FASSERT_BOUNDS(0, GC.getNumPromotionInfos(), ePromotionType);

	PromotionKeyedInfo* info = findOrCreatePromotionKeyedInfo(ePromotionType, iChange != 0);

	if (info != NULL)
	{
		info->m_iAfflictionHitCount = iChange;
	}
}

bool CvUnit::removeAfflictionHits(PromotionTypes ePromotionType)
{
	int iStrChange;
	int iCombChange;

	iStrChange = -(GC.getPromotionInfo(ePromotionType).getStrAdjperTurn() * getAfflictionHitCount(ePromotionType));
	iCombChange = -(GC.getPromotionInfo(ePromotionType).getWeakenperTurn() * getAfflictionHitCount(ePromotionType));
	changeExtraStrength(iStrChange);
	changeExtraCombatPercent(iCombChange);
	return true;
}

bool CvUnit::updateAfflictionHits(PromotionTypes ePromotionType)
{
	int iStrChange;
	int iCombChange;
	int iDamageChange;

	iStrChange = GC.getPromotionInfo(ePromotionType).getStrAdjperTurn();
	iCombChange = GC.getPromotionInfo(ePromotionType).getWeakenperTurn();
	iDamageChange = (GC.getPromotionInfo(ePromotionType).getDamageperTurn() + getDamage());

	changeExtraStrength(iStrChange);
	changeExtraCombatPercent(iCombChange);
	changeDamage(iDamageChange);
	return true;
}

bool CvUnit::checkContractDisease(PromotionLineTypes eAfflictionLine, int iCommunicableExposure)
{
	PROFILE_FUNC();

	bool bCheck = false;
	for (int iI = 0; iI < GC.getPromotionLineInfo(eAfflictionLine).getNumPromotions(); iI++)
	{
		PromotionTypes eAffliction = (PromotionTypes)GC.getPromotionLineInfo(eAfflictionLine).getPromotion(iI);
		if (GC.getPromotionInfo(eAffliction).getLinePriority() == (getAfflictionLineCount(eAfflictionLine)+1))
		{
			if (canAcquirePromotion(eAffliction, PromotionRequirements::Afflict | PromotionRequirements::ForFree))
			{
				bCheck = true;
				break;
			}
		}
	}
	if (bCheck)
	{
		int iChancetoContract = getChancetoContract(eAfflictionLine, iCommunicableExposure);//yeah... needing work. redundancies.

		int iContractRollResult = GC.getGame().getSorenRandNum(100, "Unit Outbreak Check");
		if (iContractRollResult < iChancetoContract)
		{
			return true;
		}
	}

	return false;
}

int CvUnit::getChancetoContract(PromotionLineTypes eAfflictionLine, int iCommunicableExposure) const
{
	if (eAfflictionLine == NO_PROMOTIONLINE)
	{
		return 0;
	}
	PropertyTypes eProperty = GC.getPromotionLineInfo(eAfflictionLine).getPropertyType();
	if (eProperty == NO_PROPERTY)
	{
		return 0;
	}

	int	iContract = GC.getPromotionLineInfo(eAfflictionLine).getCommunicability();
	if (iCommunicableExposure > 0 && iCommunicableExposure > iContract)
	{
		iContract = iCommunicableExposure;
	}
	iContract += getContractChanceChange(eAfflictionLine);
	iContract -= fortitudeTotal();
	iContract -= getFortitudeModifierTypeAmount(eAfflictionLine);
	iContract -= getUnitAfflictionTolerance(eAfflictionLine);
	if (hasAfflictionLine(eAfflictionLine))
	{
		iContract += (getAfflictionLineCount(eAfflictionLine) * GC.getPromotionLineInfo(eAfflictionLine).getWorseningProbabilityIncrementModifier());
	}
	int iChanceModifier = GC.getPromotionLineInfo(eAfflictionLine).getOutbreakModifier();
	iContract *= iChanceModifier;
	iContract /= 100;
	return iContract;
}

int CvUnit::getUnitAfflictionTolerance(PromotionLineTypes ePromotionLineType) const
{
	FASSERT_BOUNDS(0, GC.getNumPromotionLineInfos(), ePromotionLineType);

	const PromotionLineKeyedInfo* info = findPromotionLineKeyedInfo(ePromotionLineType);

	return info == NULL ? 0 : info->m_iAfflictionTypeTolerance;
}

void CvUnit::changeUnitAfflictionTolerance(PromotionLineTypes ePromotionLineType, int iChange)
{
	FASSERT_BOUNDS(0, GC.getNumPromotionLineInfos(), ePromotionLineType);

	if (iChange != 0)
	{
		PromotionLineKeyedInfo* info = findOrCreatePromotionLineKeyedInfo(ePromotionLineType);

		info->m_iAfflictionTypeTolerance = std::max(0, info->m_iAfflictionTypeTolerance + iChange);
	}
}

void CvUnit::setUnitAfflictionTolerance(PromotionLineTypes ePromotionLineType, int iChange)
{
	FASSERT_BOUNDS(0, GC.getNumPromotionLineInfos(), ePromotionLineType);

	PromotionLineKeyedInfo* info = findOrCreatePromotionLineKeyedInfo(ePromotionLineType, iChange != 0);

	if (info != NULL)
	{
		info->m_iAfflictionTypeTolerance = iChange;
	}
}

int CvUnit::getContractChanceChange(PromotionLineTypes eAfflictionLine) const
{
	PROFILE_EXTRA_FUNC();
	int iI;
	int iModifier = 0;

	for (iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
	{
		UnitCombatTypes eUnitCombat = ((UnitCombatTypes)iI);
		if (isHasUnitCombat(eUnitCombat))
		{
			iModifier += GC.getPromotionLineInfo(eAfflictionLine).getUnitCombatContractChanceChange(iI);
		}
	}

	for (iI = 0; iI < GC.getNumTechInfos(); iI++)
	{
		TechTypes eTech = ((TechTypes)iI);
		if (GET_TEAM(getTeam()).isHasTech(eTech))
		{
			iModifier += GC.getPromotionLineInfo(eAfflictionLine).getTechContractChanceChange(iI);
		}
	}

	return iModifier;
}

int CvUnit::getOvercomeChange(PromotionLineTypes eAfflictionLine) const
{
	PROFILE_EXTRA_FUNC();
	int iI;
	int iModifier = 0;

	for (iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
	{
		UnitCombatTypes eUnitCombat = ((UnitCombatTypes)iI);
		if (isHasUnitCombat(eUnitCombat))
		{
			iModifier += GC.getPromotionLineInfo(eAfflictionLine).getUnitCombatOvercomeChange(iI);
		}
	}

	for (iI = 0; iI < GC.getNumTechInfos(); iI++)
	{
		TechTypes eTech = ((TechTypes)iI);
		if (GET_TEAM(getTeam()).isHasTech(eTech))
		{
			iModifier += GC.getPromotionLineInfo(eAfflictionLine).getTechOvercomeChange(iI);
		}
	}

	return iModifier;
}

int CvUnit::getFortitudeModifierTypeAmount(PromotionLineTypes ePromotionLineType) const
{
	PROFILE_EXTRA_FUNC();
	FASSERT_BOUNDS(0, GC.getNumPromotionLineInfos(), ePromotionLineType);

	const PromotionLineKeyedInfo* info = findPromotionLineKeyedInfo(ePromotionLineType);

	int iEvaluation = (info == NULL ? 0 : info->m_iFortitudeModifierAmount);
	const int iNum = m_pUnitInfo->getNumAfflictionFortitudeModifiers();

	for (int iI = 0; iI < iNum; iI++)
	{
		const PromotionLineTypes eAfflictionLine = m_pUnitInfo->getAfflictionFortitudeModifier(iI).ePromotionLine;
		if (eAfflictionLine == ePromotionLineType)
		{
			iEvaluation += m_pUnitInfo->getAfflictionFortitudeModifier(iI).iModifier;
		}
	}
	return iEvaluation;
}

void CvUnit::changeFortitudeModifierTypeAmount(PromotionLineTypes ePromotionLineType, int iChange)
{
	FASSERT_BOUNDS(0, GC.getNumPromotionLineInfos(), ePromotionLineType);

	if (iChange != 0)
	{
		PromotionLineKeyedInfo* info = findOrCreatePromotionLineKeyedInfo(ePromotionLineType);

		info->m_iFortitudeModifierAmount += iChange;
	}
}

void CvUnit::setFortitudeModifierTypeAmount(PromotionLineTypes ePromotionLineType, int iChange)
{
	FASSERT_BOUNDS(0, GC.getNumPromotionLineInfos(), ePromotionLineType);

	PromotionLineKeyedInfo* info = findOrCreatePromotionLineKeyedInfo(ePromotionLineType, iChange != 0);

	if (info != NULL)
	{
		info->m_iFortitudeModifierAmount = iChange;
	}
}
#endif // OUTBREAKS_AND_AFFLICTIONS

int CvUnit::getCityRepel() const
{
	if (noDefensiveBonus())
	{
		return 0;
	}
	PROFILE_FUNC();

	UnitCombatTypes eUnitCombat;
	int iI;
	CvCity* pCity;
	int iCityRepel = 0;

	if (plot() != NULL)
	{
		if (plot()->getPlotCity() != NULL)
		{
			pCity = plot()->getPlotCity();
			iCityRepel += pCity->getExtraLocalRepel();

			for(iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
			{
				eUnitCombat = ((UnitCombatTypes)iI);
				if (isHasUnitCombat(eUnitCombat))
				{
					iCityRepel += pCity->getUnitCombatRepelModifierTotal(eUnitCombat);
				}
			}
		}
	}
	return iCityRepel;
}

#ifdef STRENGTH_IN_NUMBERS

int CvUnit::getCityFrontSupportPercentModifier() const
{
	PROFILE_FUNC();

	CvCity* pCity;
	int iModifier = 0;
	if (plot() != NULL)
	{
		if (plot()->getPlotCity() != NULL)
		{
			pCity = plot()->getPlotCity();
			iModifier += pCity->getTotalFrontSupportPercentModifier();
		}
	}
	return iModifier;
}

int CvUnit::getCityShortRangeSupportPercentModifier() const
{
	PROFILE_FUNC();

	CvCity* pCity;
	int iModifier = 0;
	if (plot() != NULL)
	{
		if (plot()->getPlotCity() != NULL)
		{
			pCity = plot()->getPlotCity();
			iModifier += pCity->getTotalShortRangeSupportPercentModifier();
		}
	}
	return iModifier;
}

int CvUnit::getCityMediumRangeSupportPercentModifier() const
{
	PROFILE_FUNC();

	CvCity* pCity;
	int iModifier = 0;
	if (plot() != NULL)
	{
		if (plot()->getPlotCity() != NULL)
		{
			pCity = plot()->getPlotCity();
			iModifier += pCity->getTotalMediumRangeSupportPercentModifier();
		}
	}
	return iModifier;
}

int CvUnit::getCityLongRangeSupportPercentModifier() const
{
	PROFILE_FUNC();

	CvCity* pCity;
	int iModifier = 0;
	if (plot() != NULL)
	{
		if (plot()->getPlotCity() != NULL)
		{
			pCity = plot()->getPlotCity();
			iModifier += pCity->getTotalLongRangeSupportPercentModifier();
		}
	}
	return iModifier;
}

int CvUnit::getCityFlankSupportPercentModifier() const
{
	PROFILE_FUNC();

	CvCity* pCity;
	int iModifier = 0;
	if (plot() != NULL)
	{
		if (plot()->getPlotCity() != NULL)
		{
			pCity = plot()->getPlotCity();
			iModifier += pCity->getTotalFlankSupportPercentModifier();
		}
	}
	return iModifier;
}

int CvUnit::getExtraFrontSupportPercent(bool bIgnoreCommanders, bool bIgnoreCommodores) const
{
	if (!bIgnoreCommanders && !isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander)
		{
			return m_iExtraFrontSupportPercent + pCommander->m_iExtraFrontSupportPercent;
		}
	}
	if (!bIgnoreCommodores && !isCommodore())
    	{
    		const CvUnit* pCommodore = getCommodore();
    		if (pCommodore)
    		{
    			return m_iExtraFrontSupportPercent + pCommodore->m_iExtraFrontSupportPercent;
    		}
    	}
	return m_iExtraFrontSupportPercent;
}

void CvUnit::changeExtraFrontSupportPercent(int iChange)
{
	m_iExtraFrontSupportPercent +=iChange;
	FASSERT_NOT_NEGATIVE(m_iExtraFrontSupportPercent);
}

int CvUnit::getExtraShortRangeSupportPercent(bool bIgnoreCommanders, bool bIgnoreCommodores) const
{
	if (!bIgnoreCommanders && !isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander)
		{
			return m_iExtraShortRangeSupportPercent + pCommander->m_iExtraShortRangeSupportPercent;
		}
	}
	if (!bIgnoreCommodores && !isCommodore())
    	{
    		const CvUnit* pCommodore = getCommodore();
    		if (pCommodore)
    		{
    			return m_iExtraShortRangeSupportPercent + pCommodore->m_iExtraShortRangeSupportPercent;
    		}
    	}
	return m_iExtraShortRangeSupportPercent;
}

void CvUnit::changeExtraShortRangeSupportPercent(int iChange)
{
	m_iExtraShortRangeSupportPercent +=iChange;
	FASSERT_NOT_NEGATIVE(m_iExtraShortRangeSupportPercent);
}

int CvUnit::getExtraMediumRangeSupportPercent(bool bIgnoreCommanders, bool bIgnoreCommodores) const
{
	if (!bIgnoreCommanders && !isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander)
		{
			return m_iExtraMediumRangeSupportPercent + pCommander->m_iExtraMediumRangeSupportPercent;
		}
	}
	if (!bIgnoreCommodores && !isCommodore())
    	{
    		const CvUnit* pCommodore = getCommodore();
    		if (pCommodore)
    		{
    			return m_iExtraMediumRangeSupportPercent + pCommodore->m_iExtraMediumRangeSupportPercent;
    		}
    	}
	return m_iExtraMediumRangeSupportPercent;
}

void CvUnit::changeExtraMediumRangeSupportPercent(int iChange)
{
	m_iExtraMediumRangeSupportPercent +=iChange;
	FASSERT_NOT_NEGATIVE(m_iExtraMediumRangeSupportPercent);
}

int CvUnit::getExtraLongRangeSupportPercent(bool bIgnoreCommanders, bool bIgnoreCommodores) const
{
	if (!bIgnoreCommanders && !isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander)
		{
			return m_iExtraLongRangeSupportPercent + pCommander->m_iExtraLongRangeSupportPercent;
		}
	}
	if (!bIgnoreCommodores && !isCommodore())
    	{
    		const CvUnit* pCommodore = getCommodore();
    		if (pCommodore)
    		{
    			return m_iExtraLongRangeSupportPercent + pCommodore->m_iExtraLongRangeSupportPercent;
    		}
    	}
	return m_iExtraLongRangeSupportPercent;
}

void CvUnit::changeExtraLongRangeSupportPercent(int iChange)
{
	m_iExtraLongRangeSupportPercent +=iChange;
	FASSERT_NOT_NEGATIVE(m_iExtraLongRangeSupportPercent);
}

int CvUnit::getExtraFlankSupportPercent(bool bIgnoreCommanders, bool bIgnoreCommodores) const
{
	if (!bIgnoreCommanders && !isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander)
		{
			return m_iExtraFlankSupportPercent + pCommander->m_iExtraFlankSupportPercent;
		}
	}
	if (!bIgnoreCommodores && !isCommodore())
    	{
    		const CvUnit* pCommodore = getCommodore();
    		if (pCommodore)
    		{
    			return m_iExtraFlankSupportPercent + pCommodore->m_iExtraFlankSupportPercent;
    		}
    	}
	return m_iExtraFlankSupportPercent;
}

void CvUnit::changeExtraFlankSupportPercent(int iChange)
{
	m_iExtraFlankSupportPercent +=iChange;
	FASSERT_NOT_NEGATIVE(m_iExtraFlankSupportPercent);
}

int CvUnit::frontSupportPercentTotal() const
{
	return std::max(0, (m_pUnitInfo->getFrontSupportPercent() + getExtraFrontSupportPercent() + getCityFrontSupportPercentModifier()));
}

int CvUnit::shortRangeSupportPercentTotal() const
{
	return std::max(0, (m_pUnitInfo->getShortRangeSupportPercent() + getExtraShortRangeSupportPercent() + getCityShortRangeSupportPercentModifier()));
}

int CvUnit::mediumRangeSupportPercentTotal() const
{
	return std::max(0, (m_pUnitInfo->getMediumRangeSupportPercent() + getExtraMediumRangeSupportPercent() + getCityMediumRangeSupportPercentModifier()));
}

int CvUnit::longRangeSupportPercentTotal() const
{
	return std::max(0, (m_pUnitInfo->getLongRangeSupportPercent() + getExtraLongRangeSupportPercent() + getCityLongRangeSupportPercentModifier()));
}

int CvUnit::flankSupportPercentTotal() const
{
	return std::max(0, (m_pUnitInfo->getFlankSupportPercent() + getExtraFlankSupportPercent() + getCityFlankSupportPercentModifier()));
}

bool CvUnit::isFrontSupporter() const
{
	return (std::max(0, (m_pUnitInfo->getFrontSupportPercent() + getExtraFrontSupportPercent())) > 0);
}

bool CvUnit::isShortRangeSupporter() const
{
	return (std::max(0, (m_pUnitInfo->getShortRangeSupportPercent() + getExtraShortRangeSupportPercent())) > 0);
}

bool CvUnit::isMediumRangeSupporter() const
{
	return (std::max(0, (m_pUnitInfo->getMediumRangeSupportPercent() + getExtraMediumRangeSupportPercent())) > 0);
}

bool CvUnit::isLongRangeSupporter() const
{
	return (std::max(0, (m_pUnitInfo->getLongRangeSupportPercent() + getExtraLongRangeSupportPercent())) > 0);
}

bool CvUnit::isFlankSupporter() const
{
	return (std::max(0, (m_pUnitInfo->getFlankSupportPercent() + getExtraFlankSupportPercent())) > 0);
}

CvPlot* CvUnit::getAttackFromPlot() const
{
	return GC.getMap().plotSorenINLINE(m_iAttackFromPlotX, m_iAttackFromPlotY);
}

void CvUnit::setAttackFromPlot(const CvPlot* pNewValue)
{
	if (getAttackFromPlot() != pNewValue)
	{
		if (pNewValue != NULL)
		{
			m_iAttackFromPlotX = pNewValue->getX();
			m_iAttackFromPlotY = pNewValue->getY();
		}
		else
		{
			m_iAttackFromPlotX = INVALID_PLOT_COORD;
			m_iAttackFromPlotY = INVALID_PLOT_COORD;
		}
	}
}

int CvUnit::getAttackerSupportValue() const
{
	if (!GC.getGame().isOption(GAMEOPTION_COMBAT_STRENGTH_IN_NUMBERS))
	{
		return 0;
	}
	PROFILE_FUNC();

	CvPlot* aPlot = getAttackFromPlot();
	CvPlot* pPlot = getAttackPlot();
	CvUnit* pDefender;
	pDefender = pPlot->getBestDefender(NO_PLAYER, getOwner(), this, true);
	int iTotalSupport = 0;
	int iFrontOne = getAttackerFirstFrontSupportValue(aPlot, pPlot, pDefender);
	int iFrontTwo = getAttackerSecondFrontSupportValue(aPlot, pPlot, pDefender);
	int iShortOne = getAttackerFirstShortRangeSupportValue(aPlot, pPlot, pDefender);
	int iShortTwo = getAttackerSecondShortRangeSupportValue(aPlot, pPlot, pDefender);
	int iMedOne = getAttackerFirstMediumRangeSupportValue(aPlot, pPlot, pDefender);
	int iMedTwo = getAttackerSecondMediumRangeSupportValue(aPlot, pPlot, pDefender);
	int iLongOne = getAttackerFirstLongRangeSupportValue(aPlot, pPlot, pDefender);
	int iLongTwo = getAttackerSecondLongRangeSupportValue(aPlot, pPlot, pDefender);
	int iFlankOne = getAttackerFirstFlankSupportValue(aPlot, pPlot, pDefender);
	int iFlankTwo = getAttackerSecondFlankSupportValue(aPlot, pPlot, pDefender);
	iTotalSupport = (iFrontOne + iFrontTwo + iShortOne + iShortTwo + iMedOne + iMedTwo + iLongOne + iLongTwo + iFlankOne + iFlankTwo);
	return iTotalSupport;
}

int CvUnit::getAttackerFirstFrontSupportValue(const CvPlot* aPlot, const CvPlot* pPlot, const CvUnit* pDefender) const
{
	PROFILE_FUNC();

	CvUnit* pBestUnit;
	CvUnit* pAttacker;

	int iBestCurrCombatStr = 0;
	int iLowestCurrDefenderCombatStr = 0;
	int iBestFrontSupport = 0;

	int iFrontSupportPercent = 0;

	foreach_(CvUnit* pLoopUnit, aPlot->units())
	{
		if (pLoopUnit->isAttacking())
		{
			pAttacker = pLoopUnit;
		}
		if (pLoopUnit->getTeam() == getTeam() && !(pLoopUnit->isAttacking()) && !(pLoopUnit->isSupporting()) && (pLoopUnit->canAttack()) && (pLoopUnit->isFrontSupporter()))
		{
			iFrontSupportPercent = pLoopUnit->frontSupportPercentTotal();
			// if pDefender == null - use the last config of maxCombatStr where pAttacker == this, else - use the pDefender to find the best attacker
			if (pDefender != NULL)
			{
				int iTmpCurrDefenderCombatStr = pDefender->currCombatStr(NULL, pLoopUnit);
				iTmpCurrDefenderCombatStr -= ((iTmpCurrDefenderCombatStr * iFrontSupportPercent)/100);

				if (iTmpCurrDefenderCombatStr < iLowestCurrDefenderCombatStr)
				{
					iLowestCurrDefenderCombatStr = iTmpCurrDefenderCombatStr;
					pBestUnit = pLoopUnit;
				}
			}
			else
			{
				//TB Combat Mods begin
				int iTmpCurrCombatStr = pLoopUnit->currCombatStr(pPlot, pLoopUnit);
				iTmpCurrCombatStr = ((iTmpCurrCombatStr * iFrontSupportPercent)/100);
				//TB Combat Mods end

				if (iTmpCurrCombatStr > iBestCurrCombatStr)
				{
					iBestCurrCombatStr = iTmpCurrCombatStr;
					pBestUnit = pLoopUnit;
				}
			}
		}
	}

	if (pBestUnit != NULL)
	{
		pBestUnit->setSupportCount(1);
		pAttacker->setAttackerFirstFrontSupportingUnit(pBestUnit);
		iBestFrontSupport = pBestUnit->currCombatStr(pPlot, pLoopUnit) * pBestUnit->frontSupportPercentTotal() / 100;
	}

	return iBestFrontSupport;
}

int CvUnit::getAttackerSecondFrontSupportValue(const CvPlot* aPlot, const CvPlot* pPlot, const CvUnit* pDefender) const
{
	PROFILE_FUNC();

	CvUnit* pBestUnit;
	CvUnit* pAttacker;

	int iBestCurrCombatStr = 0;
	int iLowestCurrDefenderCombatStr = 0;
	int iBestFrontSupport = 0;

	int iFrontSupportPercent = 0;

	foreach_(CvUnit* pLoopUnit, aPlot->units())
	{
		if (pLoopUnit->isAttacking())
		{
			pAttacker = pLoopUnit;
		}

		if (pLoopUnit->getTeam() == getTeam() && !(pLoopUnit->isAttacking()) && !(pLoopUnit->isSupporting()) && (pLoopUnit->canAttack()) && (pLoopUnit->isFrontSupporter()))
		{
			iFrontSupportPercent = pLoopUnit->frontSupportPercentTotal();
			// if pDefender == null - use the last config of maxCombatStr where pAttacker == this, else - use the pDefender to find the best attacker
			if (pDefender != NULL)
			{
				int iTmpCurrDefenderCombatStr = pDefender->currCombatStr(NULL, pLoopUnit);
				iTmpCurrDefenderCombatStr -= ((iTmpCurrDefenderCombatStr * iFrontSupportPercent)/100);

				if (iTmpCurrDefenderCombatStr < iLowestCurrDefenderCombatStr)
				{
					iLowestCurrDefenderCombatStr = iTmpCurrDefenderCombatStr;
					pBestUnit = pLoopUnit;
				}
			}
			else
			{
				//TB Combat Mods begin
				int iTmpCurrCombatStr = pLoopUnit->currCombatStr(pPlot, pLoopUnit);
				iTmpCurrCombatStr = ((iTmpCurrCombatStr * iFrontSupportPercent)/100);
				//TB Combat Mods end

				if (iTmpCurrCombatStr > iBestCurrCombatStr)
				{
					iBestCurrCombatStr = iTmpCurrCombatStr;
					pBestUnit = pLoopUnit;
				}
			}
		}
	}

	if (pBestUnit != NULL)
	{
		pBestUnit->setSupportCount(1);
		pAttacker->setAttackerSecondFrontSupportingUnit(pBestUnit);
		iBestFrontSupport = pBestUnit->currCombatStr(pPlot, pLoopUnit) * pBestUnit->frontSupportPercentTotal() / 100;
	}

	return iBestFrontSupport;
}

int CvUnit::getAttackerFirstShortRangeSupportValue(const CvPlot* aPlot, const CvPlot* pPlot, const CvUnit* pDefender) const
{
	PROFILE_FUNC();

	CvUnit* pBestUnit;
	CvUnit* pAttacker;

	int iBestCurrCombatStr = 0;
	int iLowestCurrDefenderCombatStr = 0;
	int iBestShortRangeSupport = 0;

	int iShortRangeSupportPercent = 0;

	foreach_(CvUnit* pLoopUnit, aPlot->units())
	{
		if (pLoopUnit->isAttacking())
		{
			pAttacker = pLoopUnit;
		}

		if (pLoopUnit->getTeam() == getTeam() && !(pLoopUnit->isAttacking()) && !(pLoopUnit->isSupporting()) && (pLoopUnit->canAttack()) && (pLoopUnit->isShortRangeSupporter()))
		{
			iShortRangeSupportPercent = pLoopUnit->shortRangeSupportPercentTotal();
			// if pDefender == null - use the last config of maxCombatStr where pAttacker == this, else - use the pDefender to find the best attacker
			if (pDefender != NULL)
			{
				int iTmpCurrDefenderCombatStr = pDefender->currCombatStr(NULL, pLoopUnit);
				iTmpCurrDefenderCombatStr -= ((iTmpCurrDefenderCombatStr * iShortRangeSupportPercent)/100);

				if (iTmpCurrDefenderCombatStr < iLowestCurrDefenderCombatStr)
				{
					iLowestCurrDefenderCombatStr = iTmpCurrDefenderCombatStr;
					pBestUnit = pLoopUnit;
				}
			}
			else
			{
				//TB Combat Mods begin
				const int iTmpCurrCombatStr = pLoopUnit->currCombatStr(pPlot, pLoopUnit) * iShortRangeSupportPercent / 100;
				//TB Combat Mods end

				if (iTmpCurrCombatStr > iBestCurrCombatStr)
				{
					iBestCurrCombatStr = iTmpCurrCombatStr;
					pBestUnit = pLoopUnit;
				}
			}
		}
	}

	if (pBestUnit != NULL)
	{
		pBestUnit->setSupportCount(1);
		pAttacker->setAttackerFirstShortRangeSupportingUnit(pBestUnit);
		iBestShortRangeSupport = pBestUnit->currCombatStr(pPlot, pLoopUnit) * pBestUnit->shortRangeSupportPercentTotal() / 100;
	}

	return iBestShortRangeSupport;
}

int CvUnit::getAttackerSecondShortRangeSupportValue(const CvPlot* aPlot, const CvPlot* pPlot, const CvUnit* pDefender) const
{
	PROFILE_FUNC();

	CvUnit* pBestUnit;
	CvUnit* pAttacker;

	int iBestCurrCombatStr = 0;
	int iLowestCurrDefenderCombatStr = 0;
	int iBestShortRangeSupport = 0;

	int iShortRangeSupportPercent = 0;

	foreach_(CvUnit* pLoopUnit, aPlot->units())
	{
		if (pLoopUnit->isAttacking())
		{
			pAttacker = pLoopUnit;
		}

		if (pLoopUnit->getTeam() == getTeam() && !(pLoopUnit->isAttacking()) && !(pLoopUnit->isSupporting()) && (pLoopUnit->canAttack()) && (pLoopUnit->isShortRangeSupporter()))
		{
			iShortRangeSupportPercent = pLoopUnit->shortRangeSupportPercentTotal();
			// if pDefender == null - use the last config of maxCombatStr where pAttacker == this, else - use the pDefender to find the best attacker
			if (pDefender != NULL)
			{
				int iTmpCurrDefenderCombatStr = pDefender->currCombatStr(NULL, pLoopUnit);
				iTmpCurrDefenderCombatStr -= ((iTmpCurrDefenderCombatStr * iShortRangeSupportPercent)/100);

				if (iTmpCurrDefenderCombatStr < iLowestCurrDefenderCombatStr)
				{
					iLowestCurrDefenderCombatStr = iTmpCurrDefenderCombatStr;
					pBestUnit = pLoopUnit;
				}
			}
			else
			{
				//TB Combat Mods begin
				int iTmpCurrCombatStr = pLoopUnit->currCombatStr(pPlot, pLoopUnit);
				iTmpCurrCombatStr = ((iTmpCurrCombatStr * iShortRangeSupportPercent)/100);
				//TB Combat Mods end

				if (iTmpCurrCombatStr > iBestCurrCombatStr)
				{
					iBestCurrCombatStr = iTmpCurrCombatStr;
					pBestUnit = pLoopUnit;
				}
			}
		}
	}

	if (pBestUnit != NULL)
	{
		pBestUnit->setSupportCount(1);
		pAttacker->setAttackerSecondShortRangeSupportingUnit(pBestUnit);
		iBestShortRangeSupport = pBestUnit->currCombatStr(pPlot, pLoopUnit) * pBestUnit->shortRangeSupportPercentTotal() / 100;
	}

	return iBestShortRangeSupport;
}

int CvUnit::getAttackerFirstMediumRangeSupportValue(const CvPlot* aPlot, const CvPlot* pPlot, const CvUnit* pDefender) const
{
	PROFILE_FUNC();

	CvUnit* pBestUnit;
	CvUnit* pAttacker;

	int iBestCurrCombatStr = 0;
	int iLowestCurrDefenderCombatStr = 0;
	int iBestMediumRangeSupport = 0;

	int iMediumRangeSupportPercent = 0;

	foreach_(CvUnit* pLoopUnit, aPlot->units())
	{
		if (pLoopUnit->isAttacking())
		{
			pAttacker = pLoopUnit;
		}

		if (pLoopUnit->getTeam() == getTeam() && !(pLoopUnit->isAttacking()) && !(pLoopUnit->isSupporting()) && (pLoopUnit->canAttack()) && (pLoopUnit->isMediumRangeSupporter()))
		{
			iMediumRangeSupportPercent = pLoopUnit->mediumRangeSupportPercentTotal();
			// if pDefender == null - use the last config of maxCombatStr where pAttacker == this, else - use the pDefender to find the best attacker
			if (pDefender != NULL)
			{
				int iTmpCurrDefenderCombatStr = pDefender->currCombatStr(NULL, pLoopUnit);
				iTmpCurrDefenderCombatStr -= ((iTmpCurrDefenderCombatStr * iMediumRangeSupportPercent)/100);

				if (iTmpCurrDefenderCombatStr < iLowestCurrDefenderCombatStr)
				{
					iLowestCurrDefenderCombatStr = iTmpCurrDefenderCombatStr;
					pBestUnit = pLoopUnit;
				}
			}
			else
			{
				//TB Combat Mods begin
				int iTmpCurrCombatStr = pLoopUnit->currCombatStr(pPlot, pLoopUnit);
				iTmpCurrCombatStr = ((iTmpCurrCombatStr * iMediumRangeSupportPercent)/100);
				//TB Combat Mods end

				if (iTmpCurrCombatStr > iBestCurrCombatStr)
				{
					iBestCurrCombatStr = iTmpCurrCombatStr;
					pBestUnit = pLoopUnit;
				}
			}
		}
	}

	if (pBestUnit != NULL)
	{
		pBestUnit->setSupportCount(1);
		pAttacker->setAttackerFirstMediumRangeSupportingUnit(pBestUnit);
		iBestMediumRangeSupport = pBestUnit->currCombatStr(pPlot, pLoopUnit) * pBestUnit->mediumRangeSupportPercentTotal() / 100;
	}

	return iBestMediumRangeSupport;
}

int CvUnit::getAttackerSecondMediumRangeSupportValue(const CvPlot* aPlot, const CvPlot* pPlot, const CvUnit* pDefender) const
{
	PROFILE_FUNC();

	CvUnit* pBestUnit;
	CvUnit* pAttacker;

	int iBestCurrCombatStr = 0;
	int iLowestCurrDefenderCombatStr = 0;
	int iBestMediumRangeSupport = 0;

	int iMediumRangeSupportPercent = 0;

	foreach_(CvUnit* pLoopUnit, aPlot->units())
	{
		if (pLoopUnit->isAttacking())
		{
			pAttacker = pLoopUnit;
		}

		if (pLoopUnit->getTeam() == getTeam() && !(pLoopUnit->isAttacking()) && !(pLoopUnit->isSupporting()) && (pLoopUnit->canAttack()) && (pLoopUnit->isMediumRangeSupporter()))
		{
			iMediumRangeSupportPercent = pLoopUnit->mediumRangeSupportPercentTotal();
			// if pDefender == null - use the last config of maxCombatStr where pAttacker == this, else - use the pDefender to find the best attacker
			if (pDefender != NULL)
			{
				int iTmpCurrDefenderCombatStr = pDefender->currCombatStr(NULL, pLoopUnit);
				iTmpCurrDefenderCombatStr -= ((iTmpCurrDefenderCombatStr * iMediumRangeSupportPercent)/100);

				if (iTmpCurrDefenderCombatStr < iLowestCurrDefenderCombatStr)
				{
					iLowestCurrDefenderCombatStr = iTmpCurrDefenderCombatStr;
					pBestUnit = pLoopUnit;
				}
			}
			else
			{
				//TB Combat Mods begin
				const int iTmpCurrCombatStr = pLoopUnit->currCombatStr(pPlot, pLoopUnit) * iMediumRangeSupportPercent / 100;
				//TB Combat Mods end

				if (iTmpCurrCombatStr > iBestCurrCombatStr)
				{
					iBestCurrCombatStr = iTmpCurrCombatStr;
					pBestUnit = pLoopUnit;
				}
			}
		}
	}

	if (pBestUnit != NULL)
	{
		pBestUnit->setSupportCount(1);
		pAttacker->setAttackerSecondMediumRangeSupportingUnit(pBestUnit);
		iBestMediumRangeSupport = pBestUnit->currCombatStr(pPlot, pLoopUnit) * pBestUnit->mediumRangeSupportPercentTotal() / 100;
	}

	return iBestMediumRangeSupport;
}

int CvUnit::getAttackerFirstLongRangeSupportValue(const CvPlot* aPlot, const CvPlot* pPlot, const CvUnit* pDefender) const
{
	PROFILE_FUNC();

	CvUnit* pBestUnit;
	CvUnit* pAttacker;

	int iBestCurrCombatStr = 0;
	int iLowestCurrDefenderCombatStr = 0;
	int iBestLongRangeSupport = 0;

	int iLongRangeSupportPercent = 0;

	foreach_(CvUnit* pLoopUnit, aPlot->units())
	{
		if (pLoopUnit->isAttacking())
		{
			pAttacker = pLoopUnit;
		}

		if (pLoopUnit->getTeam() == getTeam() && !(pLoopUnit->isAttacking()) && !(pLoopUnit->isSupporting()) && (pLoopUnit->canAttack()) && (pLoopUnit->isLongRangeSupporter()))
		{
			iLongRangeSupportPercent = pLoopUnit->longRangeSupportPercentTotal();
			// if pDefender == null - use the last config of maxCombatStr where pAttacker == this, else - use the pDefender to find the best attacker
			if (pDefender != NULL)
			{
				int iTmpCurrDefenderCombatStr = pDefender->currCombatStr(NULL, pLoopUnit);
				iTmpCurrDefenderCombatStr -= ((iTmpCurrDefenderCombatStr * iLongRangeSupportPercent)/100);

				if (iTmpCurrDefenderCombatStr < iLowestCurrDefenderCombatStr)
				{
					iLowestCurrDefenderCombatStr = iTmpCurrDefenderCombatStr;
					pBestUnit = pLoopUnit;
				}
			}
			else
			{
				//TB Combat Mods begin
				int iTmpCurrCombatStr = pLoopUnit->currCombatStr(pPlot, pLoopUnit);
				iTmpCurrCombatStr = ((iTmpCurrCombatStr * iLongRangeSupportPercent)/100);
				//TB Combat Mods end

				if (iTmpCurrCombatStr > iBestCurrCombatStr)
				{
					iBestCurrCombatStr = iTmpCurrCombatStr;
					pBestUnit = pLoopUnit;
				}
			}
		}
	}

	if (pBestUnit != NULL)
	{
		pBestUnit->setSupportCount(1);
		pAttacker->setAttackerFirstLongRangeSupportingUnit(pBestUnit);
		iBestLongRangeSupport = pBestUnit->currCombatStr(pPlot, pLoopUnit) * pBestUnit->longRangeSupportPercentTotal() / 100;
	}

	return iBestLongRangeSupport;
}

int CvUnit::getAttackerSecondLongRangeSupportValue(const CvPlot* aPlot, const CvPlot* pPlot, const CvUnit* pDefender) const
{
	PROFILE_FUNC();

	CvUnit* pBestUnit;
	CvUnit* pAttacker;

	int iBestCurrCombatStr = 0;
	int iLowestCurrDefenderCombatStr = 0;

	foreach_(CvUnit* pLoopUnit, aPlot->units())
	{
		if (pLoopUnit->isAttacking())
		{
			pAttacker = pLoopUnit;
		}

		if (pLoopUnit->getTeam() == getTeam() && !(pLoopUnit->isAttacking()) && !(pLoopUnit->isSupporting()) && (pLoopUnit->canAttack()) && (pLoopUnit->isLongRangeSupporter()))
		{
			// if pDefender == null - use the last config of maxCombatStr where pAttacker == this, else - use the pDefender to find the best attacker
			if (pDefender != NULL)
			{
				int iTmpCurrDefenderCombatStr = pDefender->currCombatStr(NULL, pLoopUnit);
				iTmpCurrDefenderCombatStr -= ((iTmpCurrDefenderCombatStr * pLoopUnit->longRangeSupportPercentTotal())/100);

				if (iTmpCurrDefenderCombatStr < iLowestCurrDefenderCombatStr)
				{
					iLowestCurrDefenderCombatStr = iTmpCurrDefenderCombatStr;
					pBestUnit = pLoopUnit;
				}
			}
			else
			{
				//TB Combat Mods begin
				int iTmpCurrCombatStr = pLoopUnit->currCombatStr(pPlot, pLoopUnit);
				iTmpCurrCombatStr = ((iTmpCurrCombatStr * pLoopUnit->longRangeSupportPercentTotal())/100);
				//TB Combat Mods end

				if (iTmpCurrCombatStr > iBestCurrCombatStr)
				{
					iBestCurrCombatStr = iTmpCurrCombatStr;
					pBestUnit = pLoopUnit;
				}
			}
		}
	}

	if (pBestUnit == NULL)
	{
		return 0;
	}
	pBestUnit->setSupportCount(1);
	pAttacker->setAttackerSecondLongRangeSupportingUnit(pBestUnit);
	return pBestUnit->currCombatStr(pPlot, pLoopUnit) * pBestUnit->longRangeSupportPercentTotal() / 100;
}


int CvUnit::getAttackerFirstFlankSupportValue(const CvPlot* aPlot, const CvPlot* pPlot, const CvUnit* pDefender) const
{
	PROFILE_FUNC();

	CvUnit* pBestUnit;
	CvUnit* pAttacker;

	int iBestCurrCombatStr = 0;
	int iLowestCurrDefenderCombatStr = 0;
	int iBestFlankSupport = 0;

	int iFlankSupportPercent = 0;

	foreach_(const CvUnit* pLoopUnit, aPlot->units())
	{
		if (pLoopUnit->isAttacking())
		{
			pAttacker = pLoopUnit;
		}

		if (pLoopUnit->getTeam() == getTeam() && !(pLoopUnit->isAttacking()) && !(pLoopUnit->isSupporting()) && (pLoopUnit->canAttack()) && (pLoopUnit->isFlankSupporter()))
		{
			iFlankSupportPercent = pLoopUnit->flankSupportPercentTotal();
			// if pDefender == null - use the last config of maxCombatStr where pAttacker == this, else - use the pDefender to find the best attacker
			if (pDefender != NULL)
			{
				int iTmpCurrDefenderCombatStr = pDefender->currCombatStr(NULL, pLoopUnit);
				iTmpCurrDefenderCombatStr -= ((iTmpCurrDefenderCombatStr * iFlankSupportPercent)/100);

				if (iTmpCurrDefenderCombatStr < iLowestCurrDefenderCombatStr)
				{
					iLowestCurrDefenderCombatStr = iTmpCurrDefenderCombatStr;
					pBestUnit = pLoopUnit;
				}
			}
			else
			{
				//TB Combat Mods begin
				int iTmpCurrCombatStr = pLoopUnit->currCombatStr(pPlot, pLoopUnit);
				iTmpCurrCombatStr = ((iTmpCurrCombatStr * iFlankSupportPercent)/100);
				//TB Combat Mods end

				if (iTmpCurrCombatStr > iBestCurrCombatStr)
				{
					iBestCurrCombatStr = iTmpCurrCombatStr;
					pBestUnit = pLoopUnit;
				}
			}
		}
	}

	if (pBestUnit != NULL)
	{
		pBestUnit->setSupportCount(1);
		pAttacker->setAttackerFirstFlankSupportingUnit(pBestUnit);
		iBestFlankSupport = pBestUnit->currCombatStr(pPlot, pLoopUnit) * pBestUnit->flankSupportPercentTotal() / 100;
	}

	return iBestFlankSupport;
}

int CvUnit::getAttackerSecondFlankSupportValue(const CvPlot* aPlot, const CvPlot* pPlot, const CvUnit* pDefender) const
{
	PROFILE_FUNC();

	CvUnit* pBestUnit;
	CvUnit* pAttacker;

	int iBestCurrCombatStr = 0;
	int iLowestCurrDefenderCombatStr = 0;
	int iBestFlankSupport = 0;

	int iFlankSupportPercent = 0;

	foreach_(const CvUnit* pLoopUnit, aPlot->units())
	{
		if (pLoopUnit->isAttacking())
		{
			pAttacker = pLoopUnit;
		}

		if (pLoopUnit->getTeam() == getTeam() && !(pLoopUnit->isAttacking()) && !(pLoopUnit->isSupporting()) && (pLoopUnit->canAttack()) && (pLoopUnit->isFlankSupporter()))
		{
			iFlankSupportPercent = pLoopUnit->flankSupportPercentTotal();
			// if pDefender == null - use the last config of maxCombatStr where pAttacker == this, else - use the pDefender to find the best attacker
			if (pDefender != NULL)
			{
				int iTmpCurrDefenderCombatStr = pDefender->currCombatStr(NULL, pLoopUnit);
				iTmpCurrDefenderCombatStr -= ((iTmpCurrDefenderCombatStr * iFlankSupportPercent)/100);

				if (iTmpCurrDefenderCombatStr < iLowestCurrDefenderCombatStr)
				{
					iLowestCurrDefenderCombatStr = iTmpCurrDefenderCombatStr;
					pBestUnit = pLoopUnit;
				}
			}
			else
			{
				//TB Combat Mods begin
				int iTmpCurrCombatStr = pLoopUnit->currCombatStr(pPlot, pLoopUnit);
				iTmpCurrCombatStr = ((iTmpCurrCombatStr * iFlankSupportPercent)/100);
				//TB Combat Mods end

				if (iTmpCurrCombatStr > iBestCurrCombatStr)
				{
					iBestCurrCombatStr = iTmpCurrCombatStr;
					pBestUnit = pLoopUnit;
				}
			}
		}
	}

	if (pBestUnit != NULL)
	{
		pBestUnit->setSupportCount(1);
		pAttacker->setAttackerSecondFlankSupportingUnit(pBestUnit);
		iBestFlankSupport = pBestUnit->currCombatStr(pPlot, pLoopUnit) * pBestUnit->flankSupportPercentTotal() / 100;
	}

	return iBestFlankSupport;
}

CvUnit* CvUnit::getAttackerFirstFrontSupportingUnit() const
{
	return getUnit(afIUnit);
}

CvUnit* CvUnit::getAttackerSecondFrontSupportingUnit() const
{
	return getUnit(afIIUnit);
}

CvUnit* CvUnit::getAttackerFirstShortRangeSupportingUnit() const
{
	return getUnit(asrIUnit);
}

CvUnit* CvUnit::getAttackerSecondShortRangeSupportingUnit() const
{
	return getUnit(asrIIUnit);
}

CvUnit* CvUnit::getAttackerFirstMediumRangeSupportingUnit() const
{
	return getUnit(amrIUnit);
}

CvUnit* CvUnit::getAttackerSecondMediumRangeSupportingUnit() const
{
	return getUnit(amrIIUnit);
}

CvUnit* CvUnit::getAttackerFirstLongRangeSupportingUnit() const
{
	return getUnit(alrIUnit);
}

CvUnit* CvUnit::getAttackerSecondLongRangeSupportingUnit() const
{
	return getUnit(alrIIUnit);
}

CvUnit* CvUnit::getAttackerFirstFlankSupportingUnit() const
{
	return getUnit(aflIUnit);
}

CvUnit* CvUnit::getAttackerSecondFlankSupportingUnit() const
{
	return getUnit(aflIIUnit);
}

void CvUnit::setAttackerFirstFrontSupportingUnit(CvUnit* pBestUnit)
{
	afIUnit = pBestUnit->getIDInfo();
}

void CvUnit::setAttackerSecondFrontSupportingUnit(CvUnit* pBestUnit)
{
	afIIUnit = pBestUnit->getIDInfo();
}

void CvUnit::setAttackerFirstShortRangeSupportingUnit(CvUnit* pBestUnit)
{
	asrIUnit = pBestUnit->getIDInfo();
}

void CvUnit::setAttackerSecondShortRangeSupportingUnit(CvUnit* pBestUnit)
{
	asrIIUnit = pBestUnit->getIDInfo();
}

void CvUnit::setAttackerFirstMediumRangeSupportingUnit(CvUnit* pBestUnit)
{
	amrIUnit = pBestUnit->getIDInfo();
}

void CvUnit::setAttackerSecondMediumRangeSupportingUnit(CvUnit* pBestUnit)
{
	amrIIUnit = pBestUnit->getIDInfo();
}

void CvUnit::setAttackerFirstLongRangeSupportingUnit(CvUnit* pBestUnit)
{
	alrIUnit = pBestUnit->getIDInfo();
}

void CvUnit::setAttackerSecondLongRangeSupportingUnit(CvUnit* pBestUnit)
{
	alrIIUnit = pBestUnit->getIDInfo();
}

void CvUnit::setAttackerFirstFlankSupportingUnit(CvUnit* pBestUnit)
{
	aflIUnit = pBestUnit->getIDInfo();
}

void CvUnit::setAttackerSecondFlankSupportingUnit(CvUnit* pBestUnit)
{
	aflIIUnit = pBestUnit->getIDInfo();
}

int CvUnit::getDefenderSupportValue(const CvUnit* pAttacker) const
{
	if (!GC.getGame().isOption(GAMEOPTION_COMBAT_STRENGTH_IN_NUMBERS))
	{
		return 0;
	}
	PROFILE_FUNC();

	CvPlot* pPlot = plot();

	int iTotalSupport = 0;
	iTotalSupport += getDefenderFirstFrontSupportValue(pAttacker, pPlot);
	iTotalSupport += getDefenderSecondFrontSupportValue(pAttacker, pPlot);
	iTotalSupport += getDefenderFirstShortRangeSupportValue(pAttacker, pPlot);
	iTotalSupport += getDefenderSecondShortRangeSupportValue(pAttacker, pPlot);
	iTotalSupport += getDefenderFirstMediumRangeSupportValue(pAttacker, pPlot);
	iTotalSupport += getDefenderSecondMediumRangeSupportValue(pAttacker, pPlot);
	iTotalSupport += getDefenderFirstLongRangeSupportValue(pAttacker, pPlot);
	iTotalSupport += getDefenderSecondLongRangeSupportValue(pAttacker, pPlot);
	iTotalSupport += getDefenderFirstFlankSupportValue(pAttacker, pPlot);
	iTotalSupport += getDefenderSecondFlankSupportValue(pAttacker, pPlot);

	return iTotalSupport;
}

int CvUnit::getDefenderFirstFrontSupportValue(const CvUnit* pAttacker, const CvPlot* pPlot) const
{
	PROFILE_FUNC();

	CvUnit* pBestUnit = NULL;
	CvUnit* pDefender = NULL;

	int iBestCurrCombatStr = 0;
	int iStrongestCurrCombatStr = 0;

	int iFrontSupportPercent = 0;

	foreach_(CvUnit* pLoopUnit, pPlot->units())
	{
		if (pLoopUnit->isDefending())
		{
			pDefender = pLoopUnit;
		}
		if (pLoopUnit->getTeam() == getTeam() && !(pLoopUnit->isDefending()) && !(pLoopUnit->isSupporting()) && (pLoopUnit->canDefend()) && (pLoopUnit->isFrontSupporter()))
		{
			iFrontSupportPercent = pLoopUnit->frontSupportPercentTotal();
			int iTmpCurrDefenderCombatStr = currCombatStr(pPlot, pAttacker);
			iTmpCurrDefenderCombatStr -= ((iTmpCurrDefenderCombatStr * iFrontSupportPercent)/100);

			if (iTmpCurrDefenderCombatStr > iStrongestCurrCombatStr)
			{
				iStrongestCurrCombatStr = iTmpCurrDefenderCombatStr;
				pBestUnit = pLoopUnit;
			}
		}
	}

	if (pBestUnit != NULL)
	{
		pBestUnit->setSupportCount(1);
		pDefender->setDefenderFirstFrontSupportingUnit(pBestUnit);
	}

	return iStrongestCurrCombatStr;
}

int CvUnit::getDefenderSecondFrontSupportValue(const CvUnit* pAttacker, const CvPlot* pPlot) const
{
	PROFILE_FUNC();

	CvUnit* pBestUnit = NULL;
	CvUnit* pDefender = NULL;

	int iBestCurrCombatStr = 0;
	int iStrongestCurrCombatStr = 0;

	int iFrontSupportPercent = 0;

	foreach_(CvUnit* pLoopUnit, pPlot->units())
	{
		if (pLoopUnit->isDefending())
		{
			pDefender = pLoopUnit;
		}

		if (pLoopUnit->getTeam() == getTeam() && !(pLoopUnit->isDefending()) && !(pLoopUnit->isSupporting()) && (pLoopUnit->canDefend()) && (pLoopUnit->isFrontSupporter()))
		{
			iFrontSupportPercent = pLoopUnit->frontSupportPercentTotal();
			int iTmpCurrDefenderCombatStr = currCombatStr(pPlot, pAttacker);
			iTmpCurrDefenderCombatStr -= ((iTmpCurrDefenderCombatStr * iFrontSupportPercent)/100);

			if (iTmpCurrDefenderCombatStr > iStrongestCurrCombatStr)
			{
				iStrongestCurrCombatStr = iTmpCurrDefenderCombatStr;
				pBestUnit = pLoopUnit;
			}
		}
	}

	if (pBestUnit != NULL)
	{
		pBestUnit->setSupportCount(1);
		pDefender->setDefenderSecondFrontSupportingUnit(pBestUnit);
	}

	return iStrongestCurrCombatStr;
}

int CvUnit::getDefenderFirstShortRangeSupportValue(const CvUnit* pAttacker, const CvPlot* pPlot) const
{
	PROFILE_FUNC();

	CvUnit* pBestUnit = NULL;
	CvUnit* pDefender = NULL;

	int iBestCurrCombatStr = 0;
	int iStrongestCurrCombatStr = 0;

	int iShortRangeSupportPercent = 0;

	foreach_(CvUnit* pLoopUnit, pPlot->units())
	{
		if (pLoopUnit->isDefending())
		{
			pDefender = pLoopUnit;
		}

		if (pLoopUnit->getTeam() == getTeam() && !(pLoopUnit->isDefending()) && !(pLoopUnit->isSupporting()) && (pLoopUnit->canDefend()) && (pLoopUnit->isShortRangeSupporter()))
		{
			iShortRangeSupportPercent = pLoopUnit->shortRangeSupportPercentTotal();
			int iTmpCurrDefenderCombatStr = currCombatStr(pPlot, pAttacker);
			iTmpCurrDefenderCombatStr -= ((iTmpCurrDefenderCombatStr * iShortRangeSupportPercent)/100);

			if (iTmpCurrDefenderCombatStr > iStrongestCurrCombatStr)
			{
				iStrongestCurrCombatStr = iTmpCurrDefenderCombatStr;
				pBestUnit = pLoopUnit;
			}
		}
	}

	if (pBestUnit != NULL)
	{
		pBestUnit->setSupportCount(1);
		pDefender->setDefenderFirstShortRangeSupportingUnit(pBestUnit);
	}

	return iStrongestCurrCombatStr;
}

int CvUnit::getDefenderSecondShortRangeSupportValue(const CvUnit* pAttacker, const CvPlot* pPlot) const
{
	PROFILE_FUNC();

	CvUnit* pBestUnit = NULL;
	CvUnit* pDefender = NULL;

	int iBestCurrCombatStr = 0;
	int iStrongestCurrCombatStr = 0;

	int iShortRangeSupportPercent = 0;

	foreach_(CvUnit* pLoopUnit, pPlot->units())
	{
		if (pLoopUnit->isDefending())
		{
			pDefender = pLoopUnit;
		}

		if (pLoopUnit->getTeam() == getTeam() && !(pLoopUnit->isDefending()) && !(pLoopUnit->isSupporting()) && (pLoopUnit->canDefend()) && (pLoopUnit->isShortRangeSupporter()))
		{
			iShortRangeSupportPercent = pLoopUnit->shortRangeSupportPercentTotal();
			int iTmpCurrDefenderCombatStr = currCombatStr(pPlot, pAttacker);
			iTmpCurrDefenderCombatStr -= ((iTmpCurrDefenderCombatStr * iShortRangeSupportPercent)/100);

			if (iTmpCurrDefenderCombatStr > iStrongestCurrCombatStr)
			{
				iStrongestCurrCombatStr = iTmpCurrDefenderCombatStr;
				pBestUnit = pLoopUnit;
			}
		}
	}

	if (pBestUnit != NULL)
	{
		pBestUnit->setSupportCount(1);
		pDefender->setDefenderSecondShortRangeSupportingUnit(pBestUnit);
	}

	return iStrongestCurrCombatStr;
}

int CvUnit::getDefenderFirstMediumRangeSupportValue(const CvUnit* pAttacker, const CvPlot* pPlot) const
{
	PROFILE_FUNC();

	CvUnit* pBestUnit = NULL;
	CvUnit* pDefender = NULL;

	int iBestCurrCombatStr = 0;
	int iStrongestCurrCombatStr = 0;

	int iMediumRangeSupportPercent = 0;

	foreach_(CvUnit* pLoopUnit, pPlot->units())
	{
		if (pLoopUnit->isDefending())
		{
			pDefender = pLoopUnit;
		}

		if (pLoopUnit->getTeam() == getTeam() && !(pLoopUnit->isDefending()) && !(pLoopUnit->isSupporting()) && (pLoopUnit->canDefend()) && (pLoopUnit->isMediumRangeSupporter()))
		{
			iMediumRangeSupportPercent = pLoopUnit->mediumRangeSupportPercentTotal();
			int iTmpCurrDefenderCombatStr = currCombatStr(pPlot, pAttacker);
			iTmpCurrDefenderCombatStr -= ((iTmpCurrDefenderCombatStr * iMediumRangeSupportPercent)/100);

			if (iTmpCurrDefenderCombatStr > iStrongestCurrCombatStr)
			{
				iStrongestCurrCombatStr = iTmpCurrDefenderCombatStr;
				pBestUnit = pLoopUnit;
			}
		}
	}

	if (pBestUnit != NULL)
	{
		pBestUnit->setSupportCount(1);
		pDefender->setDefenderFirstMediumRangeSupportingUnit(pBestUnit);
	}

	return iStrongestCurrCombatStr;
}

int CvUnit::getDefenderSecondMediumRangeSupportValue(const CvUnit* pAttacker, const CvPlot* pPlot) const
{
	PROFILE_FUNC();

	CvUnit* pBestUnit = NULL;
	CvUnit* pDefender = NULL;

	int iBestCurrCombatStr = 0;
	int iStrongestCurrCombatStr = 0;

	int iMediumRangeSupportPercent = 0;

	foreach_(CvUnit* pLoopUnit, pPlot->units())
	{
		if (pLoopUnit->isDefending())
		{
			pDefender = pLoopUnit;
		}

		if (pLoopUnit->getTeam() == getTeam() && !(pLoopUnit->isDefending()) && !(pLoopUnit->isSupporting()) && (pLoopUnit->canDefend()) && (pLoopUnit->isMediumRangeSupporter()))
		{
			iMediumRangeSupportPercent = pLoopUnit->mediumRangeSupportPercentTotal();
			int iTmpCurrDefenderCombatStr = currCombatStr(pPlot, pAttacker);
			iTmpCurrDefenderCombatStr -= ((iTmpCurrDefenderCombatStr * iMediumRangeSupportPercent)/100);

			if (iTmpCurrDefenderCombatStr > iStrongestCurrCombatStr)
			{
				iStrongestCurrCombatStr = iTmpCurrDefenderCombatStr;
				pBestUnit = pLoopUnit;
			}
		}
	}

	if (pBestUnit != NULL)
	{
		pBestUnit->setSupportCount(1);
		pDefender->setDefenderSecondMediumRangeSupportingUnit(pBestUnit);
	}

	return iStrongestCurrCombatStr;
}

int CvUnit::getDefenderFirstLongRangeSupportValue(const CvUnit* pAttacker, const CvPlot* pPlot) const
{
	PROFILE_FUNC();

	CvUnit* pBestUnit = NULL;
	CvUnit* pDefender = NULL;

	int iBestCurrCombatStr = 0;
	int iStrongestCurrCombatStr = 0;

	int iLongRangeSupportPercent = 0;

	foreach_(CvUnit* pLoopUnit, pPlot->units())
	{
		if (pLoopUnit->isDefending())
		{
			pDefender = pLoopUnit;
		}

		if (pLoopUnit->getTeam() == getTeam() && !(pLoopUnit->isDefending()) && !(pLoopUnit->isSupporting()) && (pLoopUnit->canDefend()) && (pLoopUnit->isLongRangeSupporter()))
		{
			iLongRangeSupportPercent = pLoopUnit->longRangeSupportPercentTotal();
			int iTmpCurrDefenderCombatStr = currCombatStr(pPlot, pAttacker);
			iTmpCurrDefenderCombatStr -= ((iTmpCurrDefenderCombatStr * iLongRangeSupportPercent)/100);

			if (iTmpCurrDefenderCombatStr > iStrongestCurrCombatStr)
			{
				iStrongestCurrCombatStr = iTmpCurrDefenderCombatStr;
				pBestUnit = pLoopUnit;
			}
		}
	}

	if (pBestUnit != NULL)
	{
		pBestUnit->setSupportCount(1);
		pDefender->setDefenderFirstLongRangeSupportingUnit(pBestUnit);
	}

	return iStrongestCurrCombatStr;
}

int CvUnit::getDefenderSecondLongRangeSupportValue(const CvUnit* pAttacker, const CvPlot* pPlot) const
{
	PROFILE_FUNC();

	CvUnit* pBestUnit = NULL;
	CvUnit* pDefender = NULL;

	int iBestCurrCombatStr = 0;
	int iStrongestCurrCombatStr = 0;

	int iLongRangeSupportPercent = 0;

	foreach_(CvUnit* pLoopUnit, pPlot->units())
	{
		if (pLoopUnit->isDefending())
		{
			pDefender = pLoopUnit;
		}

		if (pLoopUnit->getTeam() == getTeam() && !(pLoopUnit->isDefending()) && !(pLoopUnit->isSupporting()) && (pLoopUnit->canDefend()) && (pLoopUnit->isLongRangeSupporter()))
		{
			iLongRangeSupportPercent = pLoopUnit->longRangeSupportPercentTotal();
			int iTmpCurrDefenderCombatStr = currCombatStr(pPlot, pAttacker);
			iTmpCurrDefenderCombatStr -= ((iTmpCurrDefenderCombatStr * iLongRangeSupportPercent)/100);

			if (iTmpCurrDefenderCombatStr > iStrongestCurrCombatStr)
			{
				iStrongestCurrCombatStr = iTmpCurrDefenderCombatStr;
				pBestUnit = pLoopUnit;
			}
		}
	}

	if (pBestUnit != NULL)
	{
		pBestUnit->setSupportCount(1);
		pDefender->setDefenderSecondLongRangeSupportingUnit(pBestUnit);
	}

	return iStrongestCurrCombatStr;
}

int CvUnit::getDefenderFirstFlankSupportValue(const CvUnit* pAttacker, const CvPlot* pPlot) const
{
	PROFILE_FUNC();

	CvUnit* pBestUnit = NULL;
	CvUnit* pDefender = NULL;

	int iBestCurrCombatStr = 0;
	int iStrongestCurrCombatStr = 0;

	int iFlankSupportPercent = 0;

	foreach_(CvUnit* pLoopUnit, pPlot->units())
	{
		if (pLoopUnit->isDefending())
		{
			pDefender = pLoopUnit;
		}

		if (pLoopUnit->getTeam() == getTeam() && !(pLoopUnit->isDefending()) && !(pLoopUnit->isSupporting()) && (pLoopUnit->canDefend()) && (pLoopUnit->isFlankSupporter()))
		{
			iFlankSupportPercent = pLoopUnit->flankSupportPercentTotal();
			int iTmpCurrDefenderCombatStr = currCombatStr(pPlot, pAttacker);
			iTmpCurrDefenderCombatStr -= ((iTmpCurrDefenderCombatStr * iFlankSupportPercent)/100);

			if (iTmpCurrDefenderCombatStr > iStrongestCurrCombatStr)
			{
				iStrongestCurrCombatStr = iTmpCurrDefenderCombatStr;
				pBestUnit = pLoopUnit;
			}
		}
	}

	if (pBestUnit != NULL)
	{
		pBestUnit->setSupportCount(1);
		pDefender->setDefenderFirstFlankSupportingUnit(pBestUnit);
	}

	return iStrongestCurrCombatStr;
}

int CvUnit::getDefenderSecondFlankSupportValue(const CvUnit* pAttacker, const CvPlot* pPlot) const
{
	PROFILE_FUNC();

	CvUnit* pBestUnit = NULL;
	CvUnit* pDefender = NULL;

	int iBestCurrCombatStr = 0;
	int iStrongestCurrCombatStr = 0;

	int iFlankSupportPercent = 0;

	foreach_(CvUnit* pLoopUnit, pPlot->units())
	{
		if (pLoopUnit->isDefending())
		{
			pDefender = pLoopUnit;
		}

		if (pLoopUnit->getTeam() == getTeam() && !(pLoopUnit->isDefending()) && !(pLoopUnit->isSupporting()) && (pLoopUnit->canDefend()) && (pLoopUnit->isFlankSupporter()))
		{
			iFlankSupportPercent = pLoopUnit->flankSupportPercentTotal();
			int iTmpCurrDefenderCombatStr = currCombatStr(pPlot, pAttacker);
			iTmpCurrDefenderCombatStr -= ((iTmpCurrDefenderCombatStr * iFlankSupportPercent)/100);

			if (iTmpCurrDefenderCombatStr > iStrongestCurrCombatStr)
			{
				iStrongestCurrCombatStr = iTmpCurrDefenderCombatStr;
				pBestUnit = pLoopUnit;
			}
		}
	}

	if (pBestUnit != NULL)
	{
		pBestUnit->setSupportCount(1);
		pDefender->setDefenderSecondFlankSupportingUnit(pBestUnit);
	}

	return iStrongestCurrCombatStr;
}

CvUnit* CvUnit::getDefenderFirstFrontSupportingUnit() const
{
	return getUnit(dfIUnit);
}

CvUnit* CvUnit::getDefenderSecondFrontSupportingUnit() const
{
	return getUnit(dfIIUnit);
}

CvUnit* CvUnit::getDefenderFirstShortRangeSupportingUnit() const
{
	return getUnit(dsrIUnit);
}

CvUnit* CvUnit::getDefenderSecondShortRangeSupportingUnit() const
{
	return getUnit(dsrIIUnit);
}

CvUnit* CvUnit::getDefenderFirstMediumRangeSupportingUnit() const
{
	return getUnit(dmrIUnit);
}

CvUnit* CvUnit::getDefenderSecondMediumRangeSupportingUnit() const
{
	return getUnit(dmrIIUnit);
}

CvUnit* CvUnit::getDefenderFirstLongRangeSupportingUnit() const
{
	return getUnit(dlrIUnit);
}

CvUnit* CvUnit::getDefenderSecondLongRangeSupportingUnit() const
{
	return getUnit(dlrIIUnit);
}

CvUnit* CvUnit::getDefenderFirstFlankSupportingUnit() const
{
	return getUnit(dflIUnit);
}

CvUnit* CvUnit::getDefenderSecondFlankSupportingUnit() const
{
	return getUnit(dflIIUnit);
}

void CvUnit::setDefenderFirstFrontSupportingUnit(CvUnit* pBestUnit)
{
	dfIUnit = pBestUnit->getIDInfo();
}

void CvUnit::setDefenderSecondFrontSupportingUnit(CvUnit* pBestUnit)
{
	dfIIUnit = pBestUnit->getIDInfo();
}

void CvUnit::setDefenderFirstShortRangeSupportingUnit(CvUnit* pBestUnit)
{
	dsrIUnit = pBestUnit->getIDInfo();
}

void CvUnit::setDefenderSecondShortRangeSupportingUnit(CvUnit* pBestUnit)
{
	dsrIIUnit = pBestUnit->getIDInfo();
}

void CvUnit::setDefenderFirstMediumRangeSupportingUnit(CvUnit* pBestUnit)
{
	dmrIUnit = pBestUnit->getIDInfo();
}

void CvUnit::setDefenderSecondMediumRangeSupportingUnit(CvUnit* pBestUnit)
{
	dmrIIUnit = pBestUnit->getIDInfo();
}

void CvUnit::setDefenderFirstLongRangeSupportingUnit(CvUnit* pBestUnit)
{
	dlrIUnit = pBestUnit->getIDInfo();
}

void CvUnit::setDefenderSecondLongRangeSupportingUnit(CvUnit* pBestUnit)
{
	dlrIIUnit = pBestUnit->getIDInfo();
}

void CvUnit::setDefenderFirstFlankSupportingUnit(CvUnit* pBestUnit)
{
	dflIUnit = pBestUnit->getIDInfo();
}

void CvUnit::setDefenderSecondFlankSupportingUnit(CvUnit* pBestUnit)
{
	dflIIUnit = pBestUnit->getIDInfo();
}

bool CvUnit::isSupporting()
{
	return (m_iSupportCount > 0);
}

void CvUnit::setSupportCount(int iChange)
{
	m_iSupportCount = iChange;
}

void CvUnit::ClearSupports()
{
	CvUnit* AttackFrontOne = getAttackerFirstFrontSupportingUnit();
	if (AttackFrontOne != NULL)
	{
		AttackFrontOne->setSupportCount(0);
		afIUnit.reset();
	}
	CvUnit* AttackFrontTwo = getAttackerSecondFrontSupportingUnit();
	if (AttackFrontTwo != NULL)
	{
		AttackFrontTwo->setSupportCount(0);
		afIIUnit.reset();
	}
	CvUnit* AttackShortRangeOne = getAttackerFirstShortRangeSupportingUnit();
	if (AttackShortRangeOne != NULL)
	{
		AttackShortRangeOne->setSupportCount(0);
		asrIUnit.reset();
	}
	CvUnit* AttackShortRangeTwo = getAttackerSecondShortRangeSupportingUnit();
	if (AttackShortRangeTwo != NULL)
	{
		AttackShortRangeTwo->setSupportCount(0);
		asrIIUnit.reset();
	}
	CvUnit* AttackMediumRangeOne = getAttackerFirstMediumRangeSupportingUnit();
	if (AttackMediumRangeOne != NULL)
	{
		AttackMediumRangeOne->setSupportCount(0);
		amrIUnit.reset();
	}
	CvUnit* AttackMediumRangeTwo = getAttackerSecondMediumRangeSupportingUnit();
	if (AttackMediumRangeTwo != NULL)
	{
		AttackMediumRangeTwo->setSupportCount(0);
		amrIIUnit.reset();
	}
	CvUnit* AttackLongRangeOne = getAttackerFirstLongRangeSupportingUnit();
	if (AttackLongRangeOne != NULL)
	{
		AttackLongRangeOne->setSupportCount(0);
		alrIUnit.reset();
	}
	CvUnit* AttackLongRangeTwo = getAttackerSecondLongRangeSupportingUnit();
	if (AttackLongRangeTwo != NULL)
	{
		AttackLongRangeTwo->setSupportCount(0);
		alrIIUnit.reset();
	}
	CvUnit* AttackFlankOne = getAttackerFirstFlankSupportingUnit();
	if (AttackFlankOne != NULL)
	{
		AttackFlankOne->setSupportCount(0);
		aflIUnit.reset();
	}
	CvUnit* AttackFlankTwo = getAttackerSecondFlankSupportingUnit();
	if (AttackFlankTwo != NULL)
	{
		AttackFlankTwo->setSupportCount(0);
		aflIIUnit.reset();
	}
	CvUnit* DefendFrontOne = getDefenderFirstFrontSupportingUnit();
	if (DefendFrontOne != NULL)
	{
		DefendFrontOne->setSupportCount(0);
		dfIUnit.reset();
	}
	CvUnit* DefendFrontTwo = getDefenderSecondFrontSupportingUnit();
	if (DefendFrontTwo != NULL)
	{
		DefendFrontTwo->setSupportCount(0);
		dfIIUnit.reset();
	}
	CvUnit* DefendShortRangeOne = getDefenderFirstShortRangeSupportingUnit();
	if (DefendShortRangeOne != NULL)
	{
		DefendShortRangeOne->setSupportCount(0);
		dsrIUnit.reset();
	}
	CvUnit* DefendShortRangeTwo = getDefenderSecondShortRangeSupportingUnit();
	if (DefendShortRangeTwo != NULL)
	{
		DefendShortRangeTwo->setSupportCount(0);
		dsrIIUnit.reset();
	}
	CvUnit* DefendMediumRangeOne = getDefenderFirstMediumRangeSupportingUnit();
	if (DefendMediumRangeOne != NULL)
	{
		DefendMediumRangeOne->setSupportCount(0);
		dmrIUnit.reset();
	}
	CvUnit* DefendMediumRangeTwo = getDefenderSecondMediumRangeSupportingUnit();
	if (DefendMediumRangeTwo != NULL)
	{
		DefendMediumRangeTwo->setSupportCount(0);
		dmrIIUnit.reset();
	}
	CvUnit* DefendLongRangeOne = getDefenderFirstLongRangeSupportingUnit();
	if (DefendLongRangeOne != NULL)
	{
		DefendLongRangeOne->setSupportCount(0);
		dlrIUnit.reset();
	}
	CvUnit* DefendLongRangeTwo = getDefenderSecondLongRangeSupportingUnit();
	if (DefendLongRangeTwo != NULL)
	{
		DefendLongRangeTwo->setSupportCount(0);
		dlrIIUnit.reset();
	}
	CvUnit* DefendFlankOne = getDefenderFirstFlankSupportingUnit();
	if (DefendFlankOne != NULL)
	{
		DefendFlankOne->setSupportCount(0);
		dflIUnit.reset();
	}
	CvUnit* DefendFlankTwo = getDefenderSecondFlankSupportingUnit();
	if (DefendFlankTwo != NULL)
	{
		DefendFlankTwo->setSupportCount(0);
		dflIIUnit.reset();
	}
}
#endif // #ifdef STRENGTH_IN_NUMBERS

void CvUnit::checkPromotionObsoletion()
{
	PROFILE_FUNC();

	if ((isCommander())||(isCommodore()))
	{
		for (int iI = GC.getNumUnitCombatInfos() - 1; iI > -1; iI--)
		{
			const UnitCombatTypes eUnitCombatX = static_cast<UnitCombatTypes>(iI);
			if (
				isHasUnitCombat(eUnitCombatX)
			&&	(
					GC.getUnitCombatInfo(eUnitCombatX).getGroupBase() > -10
					||
					GC.getUnitCombatInfo(eUnitCombatX).getQualityBase() > -10
				)
			)
			{
				setHasUnitCombat(eUnitCombatX, false);
			}
		}
	}

	while (true)
	{
		bool bRemovalMade = false;
		for (int iI = GC.getNumPromotionInfos() - 1; iI > -1; iI--)
		{
			const PromotionTypes ePromotion = static_cast<PromotionTypes>(iI);
			const CvPromotionInfo& promotionInfo = GC.getPromotionInfo(ePromotion);
			bool bPromo =
			(
				!promotionInfo.isEquipment()
#ifdef OUTBREAKS_AND_AFFLICTIONS
				&& !promotionInfo.isAffliction()
#endif
			);
			bool bPromotionFree = isPromotionFree(ePromotion);

			if (isHasPromotion(ePromotion) && !canKeepPromotion(ePromotion, bPromotionFree, true))
			{
				if (bPromotionFree)
				{
					setHasPromotion(ePromotion, false, true);
					bRemovalMade = true;
				}
				else if (bPromo)
				{
					//	The retrain mechanism relies on knowing if a promotion was free or not, but in
					//	saves from older versions we don't have that information, and many promotions that
					//	actually were free will not be flagged as such.  In such cases you'll get to retrain
					//	things you really shouldn't, but we don't allow more total retrains than your level

					changeRetrainsAvailable(1);
					setHasPromotion(ePromotion, false, false);
					bRemovalMade = true;
				}
			}
		}
		if (!bRemovalMade)
		{
			break;
		}
	}
}

int CvUnit::getColdDamage() const
{
	return m_iColdDamage;
}

void CvUnit::changeColdDamage(int iChange)
{
	if (hasImmunitytoColdDamage())
	{
		m_iColdDamage = 0;
	}
	else
	{
		m_iColdDamage += iChange;
	}
}

void CvUnit::setColdDamage(int iChange)
{
	if (hasImmunitytoColdDamage())
	{
		m_iColdDamage = 0;
	}
	else
	{
	m_iColdDamage = iChange;
	}
}

int CvUnit::getCombatPowerShots() const
{
	return m_iCombatPowerShots;
}

void CvUnit::setCombatPowerShots(int iNewValue)
{
	m_iCombatPowerShots = iNewValue;
	FASSERT_NOT_NEGATIVE(getCombatPowerShots());
}

void CvUnit::changeCombatPowerShots(int iChange)
{
	setCombatPowerShots(m_iCombatPowerShots + iChange);
}

int CvUnit::getCombatKnockbacks() const
{
	return m_iCombatKnockbacks;
}

void CvUnit::setCombatKnockbacks(int iNewValue)
{
	m_iCombatKnockbacks = iNewValue;
	FASSERT_NOT_NEGATIVE(getCombatKnockbacks());
}

void CvUnit::changeCombatKnockbacks(int iChange)
{
	setCombatKnockbacks(m_iCombatKnockbacks + iChange);
}

int CvUnit::getCombatRepels() const
{
	if (noDefensiveBonus())
	{
		return 0;
	}
	return m_iCombatRepels;
}

void CvUnit::setCombatRepels(int iNewValue)
{
	m_iCombatRepels = iNewValue;
	FASSERT_NOT_NEGATIVE(getCombatRepels());
}

void CvUnit::changeCombatRepels(int iChange)
{
	setCombatRepels(m_iCombatRepels + iChange);
}

#ifdef OUTBREAKS_AND_AFFLICTIONS
void CvUnit::checkForCritical(int iDamage, CvUnit* pOpponent)
{
	PROFILE_FUNC();

	if (!GC.getGame().isOption(GAMEOPTION_COMBAT_OUTBREAKS_AND_AFFLICTIONS))
	{
		return;
	}
	int iCritChance = (iDamage * 10);
	int iCritChanceModifier = pOpponent->criticalVSOpponentProbTotal(this);
	if (pOpponent->getCombatPowerShots() > 0 )
	{
		iCritChanceModifier += pOpponent->powerShotCriticalModifierTotal();
	}
	iCritChance += ((iCritChance * iCritChanceModifier)/100);
	if (GC.getGame().getSorenRandNum(10000, "CriticalHitRoll") < iCritChance)
	{
		assignCritical(pOpponent);
	}
}

void CvUnit::assignCritical(CvUnit* pOpponent)
{
	PROFILE_EXTRA_FUNC();
	std::vector<PromotionTypes> aAvailableCriticals;
	PromotionLineTypes eAfflictionLine = NO_PROMOTIONLINE;
	int iLinePriority = 0;
	int iLowestLinePriority = MAX_INT;
	PromotionTypes eCurrentAffliction = NO_PROMOTION;
	for (int iI = 0; iI < GC.getNumPromotionLineInfos(); iI++)	//loop through promotions
	{
		if (GC.getPromotionLineInfo((PromotionLineTypes)iI).isCritical())
		{
			eAfflictionLine = (PromotionLineTypes)iI;
			iLowestLinePriority = MAX_INT;
			eCurrentAffliction = NO_PROMOTION;
			for (int iJ = 0; iJ < GC.getPromotionLineInfo(eAfflictionLine).getNumPromotions(); iJ++)
			{
				PromotionTypes eAffliction = (PromotionTypes)GC.getPromotionLineInfo(eAfflictionLine).getPromotion(iJ);
				iLinePriority = GC.getPromotionInfo(eAffliction).getLinePriority();
				if (!isHasPromotion(eAffliction) && iLinePriority < iLowestLinePriority)
				{
					iLowestLinePriority = iLinePriority;
					eCurrentAffliction = eAffliction;
				}

				const CvPromotionInfo& kCritical = GC.getPromotionInfo(eCurrentAffliction);
				PromotionTypes eCritical = (eCurrentAffliction);
				if (kCritical.isAffliction() && kCritical.isCritical())
				{
					if (canAcquirePromotion(eCritical, PromotionRequirements::Afflict) && pOpponent->canInflictCritical(eCritical))
					{
						aAvailableCriticals.push_back(eCritical);
					}
				}
			}
		}
	}
	if (aAvailableCriticals.size() > 0)
	{
		int iCritRolled = GC.getGame().getSorenRandNum(aAvailableCriticals.size(), "CriticalSelectionRoll");
		PromotionTypes eCritical = aAvailableCriticals[iCritRolled];
		setHasPromotion(eCritical, true);
		eAfflictionLine = ((PromotionLineTypes)GC.getPromotionInfo(eCritical).getPromotionLine());
		if (!hasAfflictionLine(eAfflictionLine))
		{
			GET_PLAYER(getOwner()).changePlayerWideAfflictionCount(eAfflictionLine, 1);
		}

		const CvWString szBuffer = gDLL->getText("TXT_KEY_MISC_CRITICAL_SUFFERED", pOpponent->getNameKey(), getNameKey(), GC.getPromotionInfo(eCritical).getDescription());
		AddDLLMessage(getOwner(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_POSITIVE_DINK", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_RED(), getX(), getY());
		const CvWString szBuffer2 = gDLL->getText("TXT_KEY_MISC_CRITICAL_INFLICTED", pOpponent->getNameKey(), getNameKey(), GC.getPromotionInfo(eCritical).getDescription());
		AddDLLMessage(pOpponent->getOwner(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer2, "AS2D_POSITIVE_DINK", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_GREEN(), getX(), getY());
	}
}
#endif // OUTBREAKS_AND_AFFLICTIONS


bool CvUnit::canKeepPromotion(PromotionTypes ePromotion, bool bAssertFree, bool bMessageOnFalse) const
{
	PROFILE_FUNC();

	if (ePromotion == NO_PROMOTION)
	{
		FErrorMsg("Invalid promotion");
		return false;
	}
	bool bPromo = false;

	const CvPromotionInfo& promo = GC.getPromotionInfo(ePromotion);

#ifdef OUTBREAKS_AND_AFFLICTIONS
	const bool bAfflict = promo.isAffliction();
#endif
	if (promo.isEquipment()
#ifdef OUTBREAKS_AND_AFFLICTIONS
		|| bAfflict
#endif
		)
	{
		bPromo = false;
	}
	else
	{
		bPromo = true;
	}

	const bool bIsFreePromotion = (
		bAssertFree
		||
		isPromotionFree(ePromotion)
		||
		GET_PLAYER(getOwner()).isFreePromotion(getUnitCombatType(), ePromotion)
		||
		promo.isZeroesXP()
		||
		promo.isForOffset()
	);

	if (promo.isRBombardPrereq() && !canRBombard(true))
	{
		if (bMessageOnFalse)
		{
			if (bPromo && !bIsFreePromotion)
			{
				AddDLLMessage(
					getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
					gDLL->getText(
						"TXT_KEY_MISC_OBSOLETED_PROMOTION_RBOMBARD_CAN_RETRAIN",
						getNameKey(), promo.getDescription()
					),
					"AS2D_POSITIVE_DINK", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_GREEN(), getX(), getY()
				);
			}
			else
			{
				AddDLLMessage(
					getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
					gDLL->getText(
						"TXT_KEY_MISC_OBSOLETED_PROMOTION_RBOMBARD_NO_RETRAIN",
						getNameKey(), promo.getDescription()
					),
					"AS2D_POSITIVE_DINK", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_RED(), getX(), getY()
				);
			}
		}
		return false;
	}

	if (promo.isCargoPrereq() && !isCarrier())
	{
		if (bMessageOnFalse)
		{
			if (bPromo && !bIsFreePromotion)
			{
				AddDLLMessage(
					getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
					gDLL->getText(
						"TXT_KEY_MISC_OBSOLETED_PROMOTION_CARRIER_CAN_RETRAIN",
						getNameKey(), promo.getDescription()
					),
					"AS2D_POSITIVE_DINK", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_GREEN(), getX(), getY()
				);
			}
			else
			{
				AddDLLMessage(
					getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
					gDLL->getText(
						"TXT_KEY_MISC_OBSOLETED_PROMOTION_CARRIER_NO_RETRAIN",
						getNameKey(), promo.getDescription()
					),
					"AS2D_POSITIVE_DINK", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_RED(), getX(), getY()
				);
			}
		}
		return false;
	}

	if (promo.getObsoleteTech() != NO_TECH && GET_TEAM(getTeam()).isHasTech(promo.getObsoleteTech()))
	{
		if (bMessageOnFalse)
		{
			if (bPromo && !bIsFreePromotion)
			{
				AddDLLMessage(
					getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
					gDLL->getText(
						"TXT_KEY_MISC_OBSOLETED_PROMOTION_TECH_CAN_RETRAIN",
						getNameKey(), promo.getDescription()
					),
					"AS2D_POSITIVE_DINK", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_GREEN(), getX(), getY()
				);
			}
			else
			{
				AddDLLMessage(
					getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
					gDLL->getText(
						"TXT_KEY_MISC_OBSOLETED_PROMOTION_TECH_NO_RETRAIN",
						getNameKey(), promo.getDescription()
					),
					"AS2D_POSITIVE_DINK", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_RED(), getX(), getY()
				);
			}
		}
		return false;
	}

	if (promo.isNotOnDomainType(getDomainType())
	||  promo.getPromotionLine() != NO_PROMOTIONLINE
	&&  GC.getPromotionLineInfo(promo.getPromotionLine()).isNotOnDomainType(getDomainType()))
	{
		if (bMessageOnFalse)
		{
			if (bPromo && !bIsFreePromotion)
			{
				AddDLLMessage(
					getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
					gDLL->getText(
						"TXT_KEY_MISC_OBSOLETED_PROMOTION_DOMAIN_CAN_RETRAIN",
						getNameKey(), promo.getDescription()
					),
					"AS2D_POSITIVE_DINK", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_GREEN(), getX(), getY()
				);
			}
			else
			{
				AddDLLMessage(
					getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
					gDLL->getText(
						"TXT_KEY_MISC_OBSOLETED_PROMOTION_DOMAIN_NO_RETRAIN",
						getNameKey(), promo.getDescription()
					),
					"AS2D_POSITIVE_DINK", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_RED(), getX(), getY()
				);
			}
		}
		return false;
	}

	if (!promo.isPlotPrereqsKeepAfter())
	{
		bool bValid = true;
		{
			if (plot() != NULL)
			{


				const TerrainTypes eTerrain = plot()->getTerrainType();

				for (int iI = 0; iI < promo.getNumPrereqTerrainTypes(); iI++)
				{
					const TerrainTypes ePrereqTerrain = (TerrainTypes)promo.getPrereqTerrainType(iI);
					if (ePrereqTerrain != NO_TERRAIN)
					{
						bValid = false;
						if (ePrereqTerrain == GC.getTERRAIN_PEAK())
						{
							if (plot()->isAsPeak())
							{
								bValid = true;
								break;
							}
						}
						else if (ePrereqTerrain == GC.getTERRAIN_HILL())
						{
							if (plot()->isHills())
							{
								bValid = true;
								break;
							}
						}
						else if (ePrereqTerrain == eTerrain)
						{
							bValid = true;
							break;
						}
					}
				}
				if (!bValid)
				{
					if (bMessageOnFalse)
					{
						if (bPromo && !bIsFreePromotion)
						{
							AddDLLMessage(
								getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
								gDLL->getText(
									"TXT_KEY_MISC_OBSOLETED_PROMOTION_TERRAIN_CAN_RETRAIN",
									getNameKey(), promo.getDescription()
								),
								"AS2D_POSITIVE_DINK", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_GREEN(), getX(), getY()
							);
						}
						else
						{
							AddDLLMessage(
								getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
								gDLL->getText(
									"TXT_KEY_MISC_OBSOLETED_PROMOTION_TERRAIN_NO_RETRAIN",
									getNameKey(), promo.getDescription()
								),
								"AS2D_POSITIVE_DINK", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_RED(), getX(), getY()
							);
						}
					}
					return false;
				}
			}
		}
		{
			const FeatureTypes eFeature = plot()->getFeatureType();

			for (int iI = 0; iI < promo.getNumPrereqFeatureTypes(); iI++)
			{
				const FeatureTypes ePrereqFeature = (FeatureTypes)promo.getPrereqFeatureType(iI);

				if (ePrereqFeature != NO_FEATURE)
				{
					if (eFeature == ePrereqFeature)
					{
						bValid = true;
						break;
					}
					else bValid = false;
				}
			}
			if (!bValid)
			{
				if (bMessageOnFalse)
				{
					if (bPromo && !bIsFreePromotion)
					{
						AddDLLMessage(
							getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
							gDLL->getText(
								"TXT_KEY_MISC_OBSOLETED_PROMOTION_FEATURE_CAN_RETRAIN",
								getNameKey(), promo.getDescription()
							),
							"AS2D_POSITIVE_DINK", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_GREEN(), getX(), getY()
						);
					}
					else
					{
						AddDLLMessage(
							getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
							gDLL->getText(
								"TXT_KEY_MISC_OBSOLETED_PROMOTION_FEATURE_NO_RETRAIN",
								getNameKey(), promo.getDescription()
							),
							"AS2D_POSITIVE_DINK", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_RED(), getX(), getY()
						);
					}
				}
				return false;
			}
		}
		{
			const BonusTypes eBonus = plot()->getBonusType(getTeam());

			for (int iI = 0; iI < promo.getNumPrereqPlotBonusTypes(); iI++)
			{
				const BonusTypes ePrereqBonus = (BonusTypes)promo.getPrereqPlotBonusType(iI);
				if (ePrereqBonus != NO_BONUS)
				{
					bValid = false;
					if (eBonus == ePrereqBonus)
					{
						bValid = true;
						break;
					}
				}
			}
			if (!bValid)
			{
				if (bMessageOnFalse)
				{
					if (bPromo && !bIsFreePromotion)
					{
						AddDLLMessage(
							getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
							gDLL->getText(
								"TXT_KEY_MISC_OBSOLETED_PROMOTION_PLOT_BONUS_CAN_RETRAIN",
								getNameKey(), promo.getDescription()
							),
							"AS2D_POSITIVE_DINK", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_GREEN(), getX(), getY()
						);
					}
					else
					{
						AddDLLMessage(
							getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
							gDLL->getText(
								"TXT_KEY_MISC_OBSOLETED_PROMOTION_PLOT_BONUS_NO_RETRAIN",
								getNameKey(), promo.getDescription()
							),
							"AS2D_POSITIVE_DINK", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_RED(), getX(), getY()
						);
					}
				}
				return false;
			}
		}
		{
			//Improvements and buildings are OR statements between all of them.
			bValid = false;
			bool bRequire = false;
			const ImprovementTypes eImprovement = plot()->getImprovementType();

			for (int iI = 0; iI < promo.getNumPrereqImprovementTypes(); iI++)
			{
				const ImprovementTypes ePrereqImprovement = (ImprovementTypes)promo.getPrereqImprovementType(iI);

				if (ePrereqImprovement != NO_IMPROVEMENT)
				{
					bRequire = true;
					if (ePrereqImprovement == GC.getIMPROVEMENT_CITY())
					{
						if (plot()->isCity(true))
						{
							bValid = true;
							break;
						}
					}
					if (eImprovement == ePrereqImprovement)
					{
						bValid = true;
						break;
					}
				}
			}
			const int iNumPrereqLocalBuilding = promo.getNumPrereqLocalBuildingTypes();

			if (!bValid && iNumPrereqLocalBuilding > 0)
			{
				bRequire = true;
				for (int iI = 0; iI < iNumPrereqLocalBuilding; iI++)
				{
					if (plot()->isCity(false))
					{
						const CvCity* pCity = plot()->getPlotCity();
						if (pCity->isActiveBuilding((BuildingTypes)promo.getPrereqLocalBuildingType(iI)))
						{
							bValid = true;
							break;
						}
					}
				}
			}
			if (bRequire && !bValid)
			{
				if (bMessageOnFalse)
				{
					if (bPromo && !bIsFreePromotion)
					{
						AddDLLMessage(
							getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
							gDLL->getText(
								"TXT_KEY_MISC_OBSOLETED_PROMOTION_IMP_CITY_CAN_RETRAIN",
								getNameKey(), promo.getDescription()
							),
							"AS2D_POSITIVE_DINK", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_GREEN(), getX(), getY()
						);
					}
					else
					{
						AddDLLMessage(
							getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
							gDLL->getText(
								"TXT_KEY_MISC_OBSOLETED_PROMOTION_IMP_CITY_NO_RETRAIN",
								getNameKey(), promo.getDescription()
							),
							"AS2D_POSITIVE_DINK", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_RED(), getX(), getY()
						);
					}
				}
				return false;
			}
			//Improvements and buildings are OR statements between all of them.
		}
	}

	if (!bIsFreePromotion)
	{
#ifdef OUTBREAKS_AND_AFFLICTIONS
		if (!bAfflict)
#endif
		{
			const PromotionTypes ePromotionPrerequisite = promo.getPrereqPromotion();
			const PromotionTypes ePromotionPrerequisite1 = promo.getPrereqOrPromotion1();
			const PromotionTypes ePromotionPrerequisite2 = promo.getPrereqOrPromotion2();

			if (ePromotionPrerequisite != NO_PROMOTION && !isHasPromotion(ePromotionPrerequisite)
			|| (ePromotionPrerequisite1 != NO_PROMOTION || ePromotionPrerequisite2 != NO_PROMOTION)
			&& (ePromotionPrerequisite1 == NO_PROMOTION || !isHasPromotion(ePromotionPrerequisite1))
			&& (ePromotionPrerequisite2 == NO_PROMOTION || !isHasPromotion(ePromotionPrerequisite2)))
			{
				if (bMessageOnFalse)
				{
					if (bPromo && !isPromotionFree(ePromotion))
					{
						AddDLLMessage(
							getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
							gDLL->getText(
								"TXT_KEY_MISC_OBSOLETED_PROMOTION_PROMOPREREQ_CAN_RETRAIN",
								getNameKey(), promo.getDescription()
							),
							"AS2D_POSITIVE_DINK", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_GREEN(), getX(), getY()
						);
					}
					else
					{
						AddDLLMessage(
							getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
							gDLL->getText(
								"TXT_KEY_MISC_OBSOLETED_PROMOTION_PROMOPREREQ_NO_RETRAIN",
								getNameKey(), promo.getDescription()
							),
							"AS2D_POSITIVE_DINK", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_RED(), getX(), getY()
						);
					}
				}
				return false;
			}
		}
	}

	if (!isPromotionValid(ePromotion, bIsFreePromotion, true))
	{
		if (bMessageOnFalse)
		{
			if (bPromo && !bIsFreePromotion)
			{
				AddDLLMessage(
					getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
					gDLL->getText(
						"TXT_KEY_MISC_OBSOLETED_PROMOTION_INVALIDATE_CAN_RETRAIN",
						getNameKey(), promo.getDescription()
					),
					"AS2D_POSITIVE_DINK", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_GREEN(), getX(), getY()
				);
			}
			else
			{
				AddDLLMessage(
					getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
					gDLL->getText(
						"TXT_KEY_MISC_OBSOLETED_PROMOTION_INVALIDATE_NO_RETRAIN",
						getNameKey(), promo.getDescription()
					),
					"AS2D_POSITIVE_DINK", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_RED(), getX(), getY()
				);
			}
		}
		return false;
	}
	return true;
}

int CvUnit::getPromotionFreeCount(PromotionTypes ePromotion) const
{
	FASSERT_BOUNDS(0, GC.getNumPromotionInfos(), ePromotion);

	const PromotionKeyedInfo* info = findPromotionKeyedInfo(ePromotion);

	return info == NULL ? 0 : info->m_iPromotionFreeCount;
}

bool CvUnit::isPromotionFree(PromotionTypes ePromotion) const
{
	return getPromotionFreeCount(ePromotion) > 0;
}

void CvUnit::setPromotionFreeCount(PromotionTypes ePromotion, int iChange)
{
	FASSERT_BOUNDS(0, GC.getNumPromotionInfos(), ePromotion);

	PromotionKeyedInfo* info = findOrCreatePromotionKeyedInfo(ePromotion, iChange != 0);

	if (info != NULL)
	{
		info->m_iPromotionFreeCount = iChange;
	}
}

void CvUnit::checkFreetoCombatClass()
{
	PROFILE_EXTRA_FUNC();
	for (int iI = GC.getNumUnitCombatInfos() -1; iI > -1; iI--)
	{
		if (isHasUnitCombat(static_cast<UnitCombatTypes>(iI)))
		{
			for (int iK = GC.getNumPromotionInfos() - 1; iK > -1; iK--)
			{
				const PromotionTypes ePromo = static_cast<PromotionTypes>(iK);
				const CvPromotionInfo& promoInfo = GC.getPromotionInfo(ePromo);

				if (promoInfo.isFreetoUnitCombat(iI))
				{
					PromotionRequirements::flags promoFlags = PromotionRequirements::None;

					if (promoInfo.isEquipment()) promoFlags |= PromotionRequirements::Equip;
#ifdef OUTBREAKS_AND_AFFLICTIONS
					if (promoInfo.isAffliction()) promoFlags |= PromotionRequirements::Afflict;
#endif
					if (promoFlags == PromotionRequirements::None) promoFlags = PromotionRequirements::Promote;

					if (canAcquirePromotion(ePromo, promoFlags))
					{
						setHasPromotion(ePromo, true, true);
					}
				}
			}
		}
	}
}
//TB Combat Mods end

bool CvUnit::meetsUnitSelectionCriteria(const CvUnitSelectionCriteria* criteria) const
{
	if (criteria != NULL)
	{
		if (criteria->m_eUnitAI != NO_UNITAI && AI_getUnitAIType() != criteria->m_eUnitAI)
		{
			return false;
		}

		if ((criteria->m_bNoNegativeProperties || criteria->m_bPropertyBeneficial)
		&& AI_beneficialPropertyValueToCity(NULL, NO_PROPERTY) < 0)
		{
			return false;
		}

		if (criteria->m_eProperty != NO_PROPERTY)
		{
			const int iPropertyDelta = AI_beneficialPropertyValueToCity(NULL, criteria->m_eProperty);

			if (iPropertyDelta == 0)
			{
				return false;
			}
			if (iPropertyDelta > 0)
			{
				if (!criteria->m_bPropertyBeneficial)
				{
					return false;
				}
			}
			else if (criteria->m_bPropertyBeneficial)
			{
				return false;
			}
		}

		if (criteria->m_bIsHealer)
		{
			if (criteria->m_eHealUnitCombat == NO_UNITCOMBAT && ( getSameTileHeal() == 0 && getAdjacentTileHeal() == 0 ))
			{
				return false;
			}
			if (getBestHealingTypeConst() != criteria->m_eHealUnitCombat || getNumHealSupportTotal() < 1)
			{
				return false;
			}
		}

		if (criteria->m_bIsCommander && !isCommander())
		{
			return false;
		}

		if (criteria->m_bIsCommodore && !isCommodore())
        {
        	return false;
        }
	}

	return true;
}

bool CvUnit::shouldUseWithdrawalOddsCap() const
{
    static bool bCached = false;
    static bool bCachedResult;

    if ( bCached )
    {
        return bCachedResult;
    }

    bCachedResult = isPursuitinUse();
    bCached = true;

    return bCachedResult;
}

bool CvUnit::isPursuitinUse() const
{
	PROFILE_EXTRA_FUNC();
	bool bInUse = false;
	int iI;

	for (iI = 0; iI < GC.getNumUnitInfos(); iI++)
	{
		if (GC.getUnitInfo((UnitTypes)iI).getPursuit() > 0)
		{
			bInUse = true;
		}
	}
	if (!bInUse)
	{
		for (iI = 0; iI < GC.getNumPromotionInfos(); iI++)
		{
			if (GC.getPromotionInfo((PromotionTypes)iI).getPursuitChange() > 0)
			{
				bInUse = true;
			}
		}
	}
	return bInUse;
}

bool CvUnit::canSwitchEquipment(PromotionTypes eEquipment) const
{
	PROFILE_FUNC();

	FASSERT_BOUNDS(NO_PROMOTION, GC.getNumPromotionInfos(), eEquipment);

	if (eEquipment == NO_PROMOTION
	|| getUnitCombatType() == NO_UNITCOMBAT
	|| isHasPromotion(eEquipment))
	{
		return false;
	}

	if (!isPromotionValid(eEquipment))
	{
		return false;
	}
	const CvPromotionInfo& equipment = GC.getPromotionInfo(eEquipment);

	if (!equipment.isEquipment())
	{
		return false;
	}
	CvCity* pCity = plot()->getPlotCity();

	if (!pCity->isFreePromotion(eEquipment))
	{
		return false;
	}

	if (equipment.getPromotionLine() != NO_PROMOTIONLINE)
	{
		bool bValid = false;
		for (int iI = 0; iI < GC.getNumPromotionInfos(); iI++)
		{
			const PromotionTypes ePromoToReplace = static_cast<PromotionTypes>(iI);
			const CvPromotionInfo& promoX = GC.getPromotionInfo(ePromoToReplace);

			if (promoX.isEquipment()
			&&  promoX.getPromotionLine() == equipment.getPromotionLine()
			&&  isHasPromotion(ePromoToReplace)
			&&  equipment.getLinePriority() >= promoX.getLinePriority())
			{
				bValid = true;
				break;
			}
		}
		if (!bValid)
		{
			return false;
		}
	}

	{
		const PromotionTypes ePromotionPrerequisite = equipment.getPrereqPromotion();

		if (ePromotionPrerequisite != NO_PROMOTION && !isHasPromotion(ePromotionPrerequisite))
		{
			return false;
		}
	}
	{
		const PromotionTypes ePromotionPrerequisite1 = equipment.getPrereqOrPromotion1();
		const PromotionTypes ePromotionPrerequisite2 = equipment.getPrereqOrPromotion2();

		if ((ePromotionPrerequisite1 != NO_PROMOTION || ePromotionPrerequisite2 != NO_PROMOTION)
		&&  (ePromotionPrerequisite1 == NO_PROMOTION || !isHasPromotion(ePromotionPrerequisite1))
		&&  (ePromotionPrerequisite2 == NO_PROMOTION || !isHasPromotion(ePromotionPrerequisite2)))
		{
			return false;
		}
	}

	foreach_(const BonusTypes ePrereqBonus, equipment.getPrereqBonuses())
	{
		if (ePrereqBonus != NO_BONUS && !pCity->hasBonus(ePrereqBonus))
		{
			return false;
		}
	}

	if (equipment.isNotOnDomainType(getDomainType())
	||  equipment.getPromotionLine() != NO_PROMOTIONLINE
	&&  GC.getPromotionLineInfo(equipment.getPromotionLine()).isNotOnDomainType(getDomainType()))
	{
		return false;
	}

	if (equipment.getStateReligionPrereq() != NO_RELIGION
	&& GET_PLAYER(getOwner()).getStateReligion() != equipment.getStateReligionPrereq())
	{
		return false;
	}

	return true;
}

void CvUnit::reEquip(PromotionTypes eEquipment)
{
	PROFILE_EXTRA_FUNC();
	bool bReplaced = false;

	for (int iI = 0; iI < GC.getNumPromotionInfos() && !bReplaced; iI++)
	{
		if (GC.getPromotionInfo((PromotionTypes)iI).isEquipment())
		{
			const PromotionTypes ePromoToReplace = ((PromotionTypes)iI);
			if (isHasPromotion(ePromoToReplace) && GC.getPromotionInfo(ePromoToReplace).getPromotionLine() == GC.getPromotionInfo(eEquipment).getPromotionLine())
			{
				if (GC.getPromotionInfo(ePromoToReplace).getLinePriority() == GC.getPromotionInfo(eEquipment).getLinePriority())
				{
					setHasPromotion(ePromoToReplace, false);
					bReplaced = true;
				}
			}
		}
	}
	setHasPromotion(eEquipment, true);
	//	Koshling - testing promotion readiness here is uneccessary since CvUnit::doTurn
	//	will do it.  It is alo now dangerous to do it here (or indeed anywhere but controlled
	//	places) becaue it is not thread-safe and needs to run strictly on the main thread
	//testPromotionReady();

	if (IsSelected())
	{
		gDLL->getInterfaceIFace()->playGeneralSound(GC.getPromotionInfo(eEquipment).getSound());

		gDLL->getInterfaceIFace()->setDirty(UnitInfo_DIRTY_BIT, true);

// BUG - Update Plot List - start
		gDLL->getInterfaceIFace()->setDirty(PlotListButtons_DIRTY_BIT, true);
// BUG - Update Plot List - end
	}
	else
	{
		setInfoBarDirty(true);
	}

	CvEventReporter::getInstance().unitPromoted(this, eEquipment);
}

void CvUnit::statusUpdate(PromotionTypes eStatus)
{
	PROFILE_EXTRA_FUNC();
	bool bReplaced = false;

	for (int iI = 0; iI < GC.getNumPromotionInfos() && !bReplaced; iI++)
	{
		if (GC.getPromotionInfo((PromotionTypes)iI).isStatus())
		{
			const PromotionTypes ePromoToReplace = ((PromotionTypes)iI);
			if (isHasPromotion(ePromoToReplace) && GC.getPromotionInfo(ePromoToReplace).getPromotionLine() == GC.getPromotionInfo(eStatus).getPromotionLine())
			{
				if (GC.getPromotionInfo(ePromoToReplace).getLinePriority() != GC.getPromotionInfo(eStatus).getLinePriority())
				{
					setHasPromotion(ePromoToReplace, false, true);
					bReplaced = true;
				}
			}
		}
	}
	setHasPromotion(eStatus, true, true);
	//	Koshling - testing promotion readiness here is uneccessary since CvUnit::doTurn
	//	will do it.  It is alo now dangerous to do it here (or indeed anywhere but controlled
	//	places) becaue it is not thread-safe and needs to run strictly on the main thread
	//testPromotionReady();

	if (IsSelected())
	{
		gDLL->getInterfaceIFace()->playGeneralSound(GC.getPromotionInfo(eStatus).getSound());

		gDLL->getInterfaceIFace()->setDirty(UnitInfo_DIRTY_BIT, true);

// BUG - Update Plot List - start
		gDLL->getInterfaceIFace()->setDirty(PlotListButtons_DIRTY_BIT, true);
// BUG - Update Plot List - end
	}
	else
	{
		setInfoBarDirty(true);
	}

	//CvEventReporter::getInstance().unitPromoted(this, eStatus);
}

int CvUnit::flankingStrengthbyUnitCombatTotal(UnitCombatTypes eCombatType) const
{
	return (
		std::max(
			0,
			m_pUnitInfo->getFlankingStrengthbyUnitCombatType(eCombatType)
			+ getExtraFlankingStrengthbyUnitCombatType(eCombatType, isCommander(), isCommodore)
		)
	);
}

int CvUnit::getExtraFlankingStrengthbyUnitCombatType(UnitCombatTypes eIndex, const bool bCommander, const bool bCommodore) const
{
	FASSERT_BOUNDS(0, GC.getNumUnitCombatInfos(), eIndex);

	const UnitCombatKeyedInfo* info = findUnitCombatKeyedInfo(eIndex);

	if (!bCommander)
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander)
		{
			return (info ? info->m_iExtraFlankingStrengthbyUnitCombatType : 0) + pCommander->getExtraFlankingStrengthbyUnitCombatType(eIndex);
		}
	}
	if (!bCommodore)
    	{
    		const CvUnit* pCommodore = getCommodore();
    		if (pCommodore)
    		{
    			return (info ? info->m_iExtraFlankingStrengthbyUnitCombatType : 0) + pCommodore->getExtraFlankingStrengthbyUnitCombatType(eIndex);
    		}
    	}
	return info ? info->m_iExtraFlankingStrengthbyUnitCombatType : 0;
}


void CvUnit::changeExtraFlankingStrengthbyUnitCombatType(UnitCombatTypes eIndex, int iChange)
{
	FASSERT_BOUNDS(0, GC.getNumUnitCombatInfos(), eIndex);

	if (iChange != 0)
	{
		findOrCreateUnitCombatKeyedInfo(eIndex)->m_iExtraFlankingStrengthbyUnitCombatType += iChange;
	}
}


int CvUnit::withdrawOnTerrainTotal(TerrainTypes eTerrainType) const
{
	return (
		std::max(
			0,
			m_pUnitInfo->getWithdrawOnTerrainType(eTerrainType)
			+ getExtraWithdrawOnTerrainType(eTerrainType, isCommander(), isCommodore())
		)
	);
}

int CvUnit::getExtraWithdrawOnTerrainType(TerrainTypes eIndex, const bool bCommander, const bool bCommodore) const
{
	FASSERT_BOUNDS(0, GC.getNumTerrainInfos(), eIndex);

	const TerrainKeyedInfo* info = findTerrainKeyedInfo(eIndex);

	if (!bCommander)
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander)
		{
			return (info ? info->m_iExtraWithdrawOnTerrainType : 0) + pCommander->getExtraWithdrawOnTerrainType(eIndex);
		}
	}
	if (!bCommodore)
    	{
    		const CvUnit* pCommodore = getCommodore();
    		if (pCommodore)
    		{
    			return (info ? info->m_iExtraWithdrawOnTerrainType : 0) + pCommodore->getExtraWithdrawOnTerrainType(eIndex);
    		}
    	}
	return info ? info->m_iExtraWithdrawOnTerrainType : 0;
}


void CvUnit::changeExtraWithdrawOnTerrainType(TerrainTypes eIndex, int iChange)
{
	FASSERT_BOUNDS(0, GC.getNumTerrainInfos(), eIndex);

	if (iChange != 0)
	{
		TerrainKeyedInfo* info = findOrCreateTerrainKeyedInfo(eIndex);

		info->m_iExtraWithdrawOnTerrainType += iChange;
	}
}


int CvUnit::withdrawOnFeatureTotal(FeatureTypes eFeatureType) const
{
	return (
		std::max(
			0,
			m_pUnitInfo->getWithdrawOnFeatureType(eFeatureType)
			+ getExtraWithdrawOnFeatureType(eFeatureType, isCommander(), isCommodore())
		)
	);
}

int CvUnit::getExtraWithdrawOnFeatureType(FeatureTypes eIndex, const bool bCommander, const bool bCommodore) const
{
	FASSERT_BOUNDS(0, GC.getNumFeatureInfos(), eIndex);

	const FeatureKeyedInfo* info = findFeatureKeyedInfo(eIndex);

	if (!bCommander)
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander)
		{
			return (info ? info->m_iExtraWithdrawOnFeatureType : 0) + pCommander->getExtraWithdrawOnFeatureType(eIndex);
		}
	}
	if (!bCommodore)
    	{
    		const CvUnit* pCommodore = getCommodore();
    		if (pCommodore)
    		{
    			return (info ? info->m_iExtraWithdrawOnFeatureType : 0) + pCommodore->getExtraWithdrawOnFeatureType(eIndex);
    		}
    	}
	return info ? info->m_iExtraWithdrawOnFeatureType : 0;
}


void CvUnit::changeExtraWithdrawOnFeatureType(FeatureTypes eIndex, int iChange)
{
	FASSERT_BOUNDS(0, GC.getNumFeatureInfos(), eIndex);

	if (iChange != 0)
	{
		findOrCreateFeatureKeyedInfo(eIndex)->m_iExtraWithdrawOnFeatureType += iChange;
	}
}


int CvUnit::withdrawVSUnitCombatTotal(UnitCombatTypes eCombatType) const
{
	return (
		std::max(
			0,
			m_pUnitInfo->getWithdrawVSUnitCombatType(eCombatType)
			+ getExtraWithdrawVSUnitCombatType(eCombatType, isCommander(), isCommodore())
		)
	);
}


int CvUnit::getExtraWithdrawVSUnitCombatType(UnitCombatTypes eIndex, const bool bCommander, const bool bCommodore) const
{
	FASSERT_BOUNDS(0, GC.getNumUnitCombatInfos(), eIndex);

	const UnitCombatKeyedInfo* info = findUnitCombatKeyedInfo(eIndex);

	if (!bCommander)
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander)
		{
			return (info ? info->m_iExtraWithdrawVSUnitCombatType : 0) + pCommander->getExtraWithdrawVSUnitCombatType(eIndex);
		}
	}
	if (!bCommodore)
    	{
    		const CvUnit* pCommodore = getCommodore();
    		if (pCommodore)
    		{
    			return (info ? info->m_iExtraWithdrawVSUnitCombatType : 0) + pCommodore->getExtraWithdrawVSUnitCombatType(eIndex);
    		}
    	}
	return info ? info->m_iExtraWithdrawVSUnitCombatType : 0;
}


void CvUnit::changeExtraWithdrawVSUnitCombatType(UnitCombatTypes eIndex, int iChange)
{
	FASSERT_BOUNDS(0, GC.getNumUnitCombatInfos(), eIndex);

	if (iChange != 0)
	{
		findOrCreateUnitCombatKeyedInfo(eIndex)->m_iExtraWithdrawVSUnitCombatType += iChange;
	}
}


int CvUnit::pursuitVSUnitCombatTotal(UnitCombatTypes eCombatType) const
{
	return (
		std::max(
			0,
			m_pUnitInfo->getPursuitVSUnitCombatType(eCombatType)
			+ getExtraPursuitVSUnitCombatType(eCombatType, isCommander(), isCommodore())
		)
	);
}

int CvUnit::getExtraPursuitVSUnitCombatType(UnitCombatTypes eIndex, const bool bCommander, const bool bCommodore) const
{
	FASSERT_BOUNDS(0, GC.getNumUnitCombatInfos(), eIndex);

	const UnitCombatKeyedInfo* info = findUnitCombatKeyedInfo(eIndex);

	if (!bCommander)
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander)
		{
			return (info ? info->m_iExtraPursuitVSUnitCombatType : 0) + pCommander->getExtraPursuitVSUnitCombatType(eIndex);
		}
	}
	if (!bCommodore)
    	{
    		const CvUnit* pCommodore = getCommodore();
    		if (pCommodore)
    		{
    			return (info ? info->m_iExtraPursuitVSUnitCombatType : 0) + pCommodore->getExtraPursuitVSUnitCombatType(eIndex);
    		}
    	}
	return info ? info->m_iExtraPursuitVSUnitCombatType : 0;
}

void CvUnit::changeExtraPursuitVSUnitCombatType(UnitCombatTypes eIndex, int iChange)
{
	FASSERT_BOUNDS(0, GC.getNumUnitCombatInfos(), eIndex);

	if (iChange != 0)
	{
		findOrCreateUnitCombatKeyedInfo(eIndex)->m_iExtraPursuitVSUnitCombatType += iChange;
	}
}


int CvUnit::repelVSUnitCombatTotal(UnitCombatTypes eCombatType) const
{
	return (
		noDefensiveBonus() ? 0
		:
		std::max(
			0,
			m_pUnitInfo->getRepelVSUnitCombatType(eCombatType)
			+ getExtraRepelVSUnitCombatType(eCombatType, isCommander(), isCommodore())
		)
	);
}

int CvUnit::getExtraRepelVSUnitCombatType(UnitCombatTypes eIndex, const bool bCommander, const bool bCommodore) const
{
	FASSERT_BOUNDS(0, GC.getNumUnitCombatInfos(), eIndex);

	const UnitCombatKeyedInfo* info = findUnitCombatKeyedInfo(eIndex);

	if (!bCommander)
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander)
		{
			return (info ? info->m_iExtraRepelVSUnitCombatType : 0) + pCommander->getExtraRepelVSUnitCombatType(eIndex);
		}
	}
	if (!bCommodore)
    	{
    		const CvUnit* pCommodore = getCommodore();
    		if (pCommodore)
    		{
    			return (info ? info->m_iExtraRepelVSUnitCombatType : 0) + pCommodore->getExtraRepelVSUnitCombatType(eIndex);
    		}
    	}
	return info ? info->m_iExtraRepelVSUnitCombatType : 0;
}


void CvUnit::changeExtraRepelVSUnitCombatType(UnitCombatTypes eIndex, int iChange)
{
	FASSERT_BOUNDS(0, GC.getNumUnitCombatInfos(), eIndex);

	if (iChange != 0)
	{
		findOrCreateUnitCombatKeyedInfo(eIndex)->m_iExtraRepelVSUnitCombatType += iChange;
	}
}


int CvUnit::knockbackVSUnitCombatTotal(UnitCombatTypes eCombatType) const
{
	return (
		std::max(
			0,
			m_pUnitInfo->getKnockbackVSUnitCombatType(eCombatType)
			+ getExtraKnockbackVSUnitCombatType(eCombatType, isCommander(), isCommodore())
		)
	);
}

int CvUnit::getExtraKnockbackVSUnitCombatType(UnitCombatTypes eIndex, const bool bCommander, const bool bCommodore) const
{
	FASSERT_BOUNDS(0, GC.getNumUnitCombatInfos(), eIndex);

	const UnitCombatKeyedInfo* info = findUnitCombatKeyedInfo(eIndex);

	if (!bCommander)
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander)
		{
			return (info ? info->m_iExtraKnockbackVSUnitCombatType : 0) + pCommander->getExtraKnockbackVSUnitCombatType(eIndex);
		}
	}
	if (!bCommodore)
	{
		const CvUnit* pCommodore = getCommodore();
		if (pCommodore)
		{
			return (info ? info->m_iExtraKnockbackVSUnitCombatType : 0) + pCommodore->getExtraKnockbackVSUnitCombatType(eIndex);
		}
	}
	return info ? info->m_iExtraKnockbackVSUnitCombatType : 0;
}

void CvUnit::changeExtraKnockbackVSUnitCombatType(UnitCombatTypes eIndex, int iChange)
{
	FASSERT_BOUNDS(0, GC.getNumUnitCombatInfos(), eIndex);

	if (iChange != 0)
	{
		findOrCreateUnitCombatKeyedInfo(eIndex)->m_iExtraKnockbackVSUnitCombatType += iChange;
	}
}


int CvUnit::punctureVSUnitCombatTotal(UnitCombatTypes eCombatType) const
{
	return (
		std::max(
			0,
			m_pUnitInfo->getPunctureVSUnitCombatType(eCombatType)
			+ getExtraPunctureVSUnitCombatType(eCombatType, isCommander(), isCommodore())
		)
	);
}

int CvUnit::getExtraPunctureVSUnitCombatType(UnitCombatTypes eIndex, const bool bCommander, const bool bCommodore) const
{
	FASSERT_BOUNDS(0, GC.getNumUnitCombatInfos(), eIndex);

	const UnitCombatKeyedInfo* info = findUnitCombatKeyedInfo(eIndex);

	if (!bCommander)
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander)
		{
			return (info ? info->m_iExtraPunctureVSUnitCombatType : 0) + pCommander->getExtraPunctureVSUnitCombatType(eIndex);
		}
	}
	if (!bCommodore)
    	{
    		const CvUnit* pCommodore = getCommodore();
    		if (pCommodore)
    		{
    			return (info ? info->m_iExtraPunctureVSUnitCombatType : 0) + pCommodore->getExtraPunctureVSUnitCombatType(eIndex);
    		}
    	}
	return info ? info->m_iExtraPunctureVSUnitCombatType : 0;
}


void CvUnit::changeExtraPunctureVSUnitCombatType(UnitCombatTypes eIndex, int iChange)
{
	FASSERT_BOUNDS(0, GC.getNumUnitCombatInfos(), eIndex);

	if (iChange != 0)
	{
		findOrCreateUnitCombatKeyedInfo(eIndex)->m_iExtraPunctureVSUnitCombatType += iChange;
	}
}


int CvUnit::armorVSUnitCombatTotal(UnitCombatTypes eCombatType) const
{
	return (
		std::max(
			0,
			m_pUnitInfo->getArmorVSUnitCombatType(eCombatType)
			+ getExtraArmorVSUnitCombatType(eCombatType, isCommander(), isCommodore())
		)
	);
}

int CvUnit::getExtraArmorVSUnitCombatType(UnitCombatTypes eIndex, const bool bCommander, const bool bCommodore) const
{
	FASSERT_BOUNDS(0, GC.getNumUnitCombatInfos(), eIndex);

	const UnitCombatKeyedInfo* info = findUnitCombatKeyedInfo(eIndex);

	if (!bCommander)
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander)
		{
			return (info ? info->m_iExtraArmorVSUnitCombatType : 0) + pCommander->getExtraArmorVSUnitCombatType(eIndex);
		}
	}
	if (!bCommodore)
    	{
    		const CvUnit* pCommodore = getCommodore();
    		if (pCommodore)
    		{
    			return (info ? info->m_iExtraArmorVSUnitCombatType : 0) + pCommodore->getExtraArmorVSUnitCombatType(eIndex);
    		}
    	}
	return info ? info->m_iExtraArmorVSUnitCombatType : 0;
}

void CvUnit::changeExtraArmorVSUnitCombatType(UnitCombatTypes eIndex, int iChange)
{
	FASSERT_BOUNDS(0, GC.getNumUnitCombatInfos(), eIndex);

	if (iChange != 0)
	{
		findOrCreateUnitCombatKeyedInfo(eIndex)->m_iExtraArmorVSUnitCombatType += iChange;
	}
}


int CvUnit::dodgeVSUnitCombatTotal(UnitCombatTypes eCombatType) const
{
	return (
		std::max(
			0,
			m_pUnitInfo->getDodgeVSUnitCombatType(eCombatType)
			+ getExtraDodgeVSUnitCombatType(eCombatType, isCommander(), isCommodore())
		)
	);
}

int CvUnit::getExtraDodgeVSUnitCombatType(UnitCombatTypes eIndex, const bool bCommander, const bool bCommodore) const
{
	FASSERT_BOUNDS(0, GC.getNumUnitCombatInfos(), eIndex);

	const UnitCombatKeyedInfo* info = findUnitCombatKeyedInfo(eIndex);

	if (!bCommander)
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander)
		{
			return (info ? info->m_iExtraDodgeVSUnitCombatType : 0) + pCommander->getExtraDodgeVSUnitCombatType(eIndex);
		}
	}
	if (!bCommodore)
    	{
    		const CvUnit* pCommodore = getCommodore();
    		if (pCommodore)
    		{
    			return (info ? info->m_iExtraDodgeVSUnitCombatType : 0) + pCommodore->getExtraDodgeVSUnitCombatType(eIndex);
    		}
    	}
	return info ? info->m_iExtraDodgeVSUnitCombatType : 0;
}

void CvUnit::changeExtraDodgeVSUnitCombatType(UnitCombatTypes eIndex, int iChange)
{
	FASSERT_BOUNDS(0, GC.getNumUnitCombatInfos(), eIndex);

	if (iChange != 0)
	{
		findOrCreateUnitCombatKeyedInfo(eIndex)->m_iExtraDodgeVSUnitCombatType += iChange;
	}
}


int CvUnit::precisionVSUnitCombatTotal(UnitCombatTypes eCombatType) const
{
	return (
		std::max(
			0,
			m_pUnitInfo->getPrecisionVSUnitCombatType(eCombatType)
			+ getExtraPrecisionVSUnitCombatType(eCombatType, isCommander(), isCommodore())
		)
	);
}

int CvUnit::getExtraPrecisionVSUnitCombatType(UnitCombatTypes eIndex, const bool bCommander, const bool bCommodore) const
{
	FASSERT_BOUNDS(0, GC.getNumUnitCombatInfos(), eIndex);

	const UnitCombatKeyedInfo* info = findUnitCombatKeyedInfo(eIndex);

	if (!bCommander)
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander)
		{
			return (info ? info->m_iExtraPrecisionVSUnitCombatType : 0) + pCommander->getExtraPrecisionVSUnitCombatType(eIndex);
		}
	}
	if (!bCommodore)
    	{
    		const CvUnit* pCommodore = getCommodore();
    		if (pCommodore)
    		{
    			return (info ? info->m_iExtraPrecisionVSUnitCombatType : 0) + pCommodore->getExtraPrecisionVSUnitCombatType(eIndex);
    		}
    	}
	return info ? info->m_iExtraPrecisionVSUnitCombatType : 0;
}

void CvUnit::changeExtraPrecisionVSUnitCombatType(UnitCombatTypes eIndex, int iChange)
{
	FASSERT_BOUNDS(0, GC.getNumUnitCombatInfos(), eIndex);

	if (iChange != 0)
	{
		findOrCreateUnitCombatKeyedInfo(eIndex)->m_iExtraPrecisionVSUnitCombatType += iChange;
	}
}


int CvUnit::criticalVSUnitCombatTotal(UnitCombatTypes eCombatType) const
{
	return (
		std::max(
			0,
			m_pUnitInfo->getCriticalVSUnitCombatType(eCombatType)
			+ getExtraCriticalVSUnitCombatType(eCombatType, isCommander(), isCommodore())
		)
	);
}

int CvUnit::getExtraCriticalVSUnitCombatType(UnitCombatTypes eIndex, const bool bCommander, const bool bCommodore) const
{
	FASSERT_BOUNDS(0, GC.getNumUnitCombatInfos(), eIndex);

	const UnitCombatKeyedInfo* info = findUnitCombatKeyedInfo(eIndex);

	if (!bCommander)
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander)
		{
			return (info ? info->m_iExtraCriticalVSUnitCombatType : 0) + pCommander->getExtraCriticalVSUnitCombatType(eIndex);
		}
	}
	if (!bCommodore)
    	{
    		const CvUnit* pCommodore = getCommodore();
    		if (pCommodore)
    		{
    			return (info ? info->m_iExtraCriticalVSUnitCombatType : 0) + pCommodore->getExtraCriticalVSUnitCombatType(eIndex);
    		}
    	}
	return info ? info->m_iExtraCriticalVSUnitCombatType : 0;
}

void CvUnit::changeExtraCriticalVSUnitCombatType(UnitCombatTypes eIndex, int iChange)
{
	FASSERT_BOUNDS(0, GC.getNumUnitCombatInfos(), eIndex);

	if (iChange != 0)
	{
		findOrCreateUnitCombatKeyedInfo(eIndex)->m_iExtraCriticalVSUnitCombatType += iChange;
	}
}


int CvUnit::roundStunVSUnitCombatTotal(UnitCombatTypes eCombatType) const
{
	return (
		std::max(
			0,
			m_pUnitInfo->getRoundStunVSUnitCombatType(eCombatType)
			+ getExtraRoundStunVSUnitCombatType(eCombatType, isCommander(), isCommodore())
		)
	);
}

int CvUnit::getExtraRoundStunVSUnitCombatType(UnitCombatTypes eIndex, const bool bCommander, const bool bCommodore) const
{
	FASSERT_BOUNDS(0, GC.getNumUnitCombatInfos(), eIndex);

	const UnitCombatKeyedInfo* info = findUnitCombatKeyedInfo(eIndex);

	if (!bCommander)
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander)
		{
			return (info ? info->m_iExtraRoundStunVSUnitCombatType : 0) + pCommander->getExtraRoundStunVSUnitCombatType(eIndex);
		}
	}
	if (!bCommodore)
    	{
    		const CvUnit* pCommodore = getCommodore();
    		if (pCommodore)
    		{
    			return (info ? info->m_iExtraRoundStunVSUnitCombatType : 0) + pCommodore->getExtraRoundStunVSUnitCombatType(eIndex);
    		}
    	}
	return info ? info->m_iExtraRoundStunVSUnitCombatType : 0;
}

void CvUnit::changeExtraRoundStunVSUnitCombatType(UnitCombatTypes eIndex, int iChange)
{
	FASSERT_BOUNDS(0, GC.getNumUnitCombatInfos(), eIndex);

	if (iChange != 0)
	{
		findOrCreateUnitCombatKeyedInfo(eIndex)->m_iExtraRoundStunVSUnitCombatType += iChange;
	}
}


int CvUnit::getExtraRoundStunProb(const bool bCommander, const bool bCommodore) const
{
	if (!bCommander)
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander)
		{
			return m_iExtraRoundStunProb + pCommander->m_iExtraRoundStunProb;
		}
	}
	if (!bCommodore)
    	{
    		const CvUnit* pCommodore = getCommodore();
    		if (pCommodore)
    		{
    			return m_iExtraRoundStunProb + pCommodore->m_iExtraRoundStunProb;
    		}
    	}
	return m_iExtraRoundStunProb;
}

void CvUnit::changeExtraRoundStunProb(int iChange)
{
	m_iExtraRoundStunProb +=iChange;
	FASSERT_NOT_NEGATIVE(m_iExtraRoundStunProb);
}

int CvUnit::roundStunProbTotal() const
{
	return std::max(0, m_pUnitInfo->getRoundStunProb() + getExtraRoundStunProb(isCommander(), isCommodore()));
}

int CvUnit::roundStunVSOpponentProbTotal(CvUnit* pOpponent) const
{
	PROFILE_EXTRA_FUNC();
	int iRoundStunBase = roundStunProbTotal();

	for (std::map<UnitCombatTypes, UnitCombatKeyedInfo>::const_iterator it = pOpponent->m_unitCombatKeyedInfo.begin(), end = pOpponent->m_unitCombatKeyedInfo.end(); it != end; ++it)
	{
		if (it->second.m_bHasUnitCombat)
		{
			iRoundStunBase += roundStunVSUnitCombatTotal(it->first);
		}
	}
	return std::max(0, iRoundStunBase);
}

int CvUnit::getCombatStuns() const
{
	return m_iCombatStuns;
}

void CvUnit::setCombatStuns(int iNewValue)
{
	FASSERT_NOT_NEGATIVE(iNewValue);
	m_iCombatStuns = iNewValue;
}

void CvUnit::changeCombatStuns(int iChange)
{
	setCombatStuns(getCombatStuns() + iChange);
}

void CvUnit::checkForStun(int iDamage, CvUnit* pOpponent)
{
	PROFILE_FUNC();

	int iStunChancefromDamage = (iDamage * 100);
	int iStunChanceModifier = pOpponent->roundStunVSOpponentProbTotal(this);
	int iStunCriticalModifier = pOpponent->criticalVSOpponentProbTotal(this);
	int iStunResistance = enduranceTotal()*10;
	int iStunChanceTotal = 0;
	int iStunVolume = 0;

	if (iStunChanceModifier > 0) //|| pOpponent->dealsElectricalDamage())
	{
		if (pOpponent->getCombatPowerShots() > 0 )
		{
			iStunCriticalModifier += pOpponent->powerShotCriticalModifierTotal();
		}
		iStunChanceModifier += iStunCriticalModifier;
		//if (pOpponent->dealsElectricalDamage())
		//{
		//	iStunChanceModifier += 100;
		//}
		iStunChanceModifier -= iStunResistance;

		iStunChanceTotal = std::min(((iStunChancefromDamage * iStunChanceModifier)/100), 9500);
	}
	if (iStunChanceTotal > 0)
	{
		if (GC.getGame().getSorenRandNum(10000, "StunRoll") < iStunChanceTotal)
		{
			changeCombatStuns(1);
			iStunVolume += 1;
			if (GC.getGame().getSorenRandNum(100000, "StunRoll2") <iStunChanceTotal)
			{
				changeCombatStuns(1);
				iStunVolume += 1;
				if (GC.getGame().getSorenRandNum(1000000, "StunRoll3") <iStunChanceTotal)
				{
					changeCombatStuns(1);
					iStunVolume += 1;
				}
			}
		}
	}
	if (iStunVolume > 0)
	{

		const CvWString szBuffer = gDLL->getText("TXT_KEY_MISC_STUN_SUFFERED", pOpponent->getNameKey(), getNameKey(), iStunVolume);
		AddDLLMessage(getOwner(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_POSITIVE_DINK", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_RED(), getX(), getY());
		const CvWString szBuffer2 = gDLL->getText("TXT_KEY_MISC_STUN_INFLICTED", pOpponent->getNameKey(), getNameKey(), iStunVolume);
		AddDLLMessage(pOpponent->getOwner(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer2, "AS2D_POSITIVE_DINK", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_GREEN(), getX(), getY());
	}
}

int CvUnit::withdrawVSOpponentProbTotal(const CvUnit* pOpponent, const CvPlot* pPlot) const
{
	PROFILE_FUNC();

	TerrainTypes eTerrain = pPlot->getTerrainType();
	FeatureTypes eFeature = pPlot->getFeatureType();
	bool bHill = pPlot->isHills();
	bool bPeak = pPlot->isAsPeak();

	int iBase = withdrawalProbability();
	for (std::map<UnitCombatTypes, UnitCombatKeyedInfo>::const_iterator it = pOpponent->m_unitCombatKeyedInfo.begin(), end = pOpponent->m_unitCombatKeyedInfo.end(); it != end; ++it)
	{
		if (it->second.m_bHasUnitCombat)
		{
			iBase += withdrawVSUnitCombatTotal(it->first);
		}
	}

	for (int iI = 0; iI < GC.getNumTerrainInfos(); iI++)
	{
		if (eTerrain == (TerrainTypes)iI ||
			(bPeak && (TerrainTypes)iI == GC.getTERRAIN_PEAK()) ||
			(bHill && (TerrainTypes)iI == GC.getTERRAIN_HILL()))
		{
			iBase += withdrawOnTerrainTotal((TerrainTypes)iI);
		}
	}

	for (int iI = 0; iI < GC.getNumFeatureInfos(); iI++)
	{
		if (eFeature == (FeatureTypes)iI)
		{
			iBase += withdrawOnFeatureTotal((FeatureTypes)iI);
		}
	}

	int iTotal = std::max(0, iBase);

	if (GC.getGame().isOption(GAMEOPTION_COMBAT_FIGHT_OR_FLIGHT))
	{
		return iTotal;
	}
	return getDiminishingReturn(iTotal);
}

int CvUnit::pursuitVSOpponentProbTotal(const CvUnit* pOpponent) const
{
	PROFILE_FUNC();

	if (!isPursuitPossible(pOpponent))
	{
		return 0;
	}

	int iBase = pursuitProbability();

	for (std::map<UnitCombatTypes, UnitCombatKeyedInfo>::const_iterator it = pOpponent->m_unitCombatKeyedInfo.begin(), end = pOpponent->m_unitCombatKeyedInfo.end(); it != end; ++it)
	{
		if (it->second.m_bHasUnitCombat)
		{
			iBase += pursuitVSUnitCombatTotal(it->first);
		}
	}
	int iTotal = std::max(0, iBase);

	return iTotal;
}

int CvUnit::repelVSOpponentProbTotal(const CvUnit* pOpponent) const
{
	PROFILE_EXTRA_FUNC();
	if (noDefensiveBonus())
	{
		return 0;
	}
	const CvCity* pCity = plot()->getPlotCity();

	int iBase = repelTotal();

	for (std::map<UnitCombatTypes, UnitCombatKeyedInfo>::const_iterator it = pOpponent->m_unitCombatKeyedInfo.begin(), end = pOpponent->m_unitCombatKeyedInfo.end(); it != end; ++it)
	{
		if (it->second.m_bHasUnitCombat)
		{
			iBase += repelVSUnitCombatTotal(it->first);
		}

		if (plot()->isCity(false, getTeam()))
		{
			iBase += pCity->getUnitCombatRepelAgainstModifierTotal(it->first);
		}
	}

	int iTotal = std::max(0, iBase);

	return iTotal;
}

int CvUnit::knockbackVSOpponentProbTotal(const CvUnit* pOpponent) const
{
	PROFILE_EXTRA_FUNC();
	int iBase = knockbackTotal();
	for (std::map<UnitCombatTypes, UnitCombatKeyedInfo>::const_iterator it = pOpponent->m_unitCombatKeyedInfo.begin(), end = pOpponent->m_unitCombatKeyedInfo.end(); it != end; ++it)
	{
		if (it->second.m_bHasUnitCombat)
		{
			iBase += knockbackVSUnitCombatTotal(it->first);
		}
	}
	int iTotal = std::max(0, iBase);

	return iTotal;
}

int CvUnit::punctureVSOpponentProbTotal(const CvUnit* pOpponent) const
{
	PROFILE_EXTRA_FUNC();
	int iBase = punctureTotal();
	for (std::map<UnitCombatTypes, UnitCombatKeyedInfo>::const_iterator it = pOpponent->m_unitCombatKeyedInfo.begin(), end = pOpponent->m_unitCombatKeyedInfo.end(); it != end; ++it)
	{
		if (it->second.m_bHasUnitCombat)
		{
			iBase += punctureVSUnitCombatTotal(it->first);
		}
	}
	int iTotal = std::max(0, iBase);

	return iTotal;
}

int CvUnit::armorVSOpponentProbTotal(const CvUnit* pOpponent) const
{
	PROFILE_EXTRA_FUNC();
	int iBase = armorTotal();
	for (std::map<UnitCombatTypes, UnitCombatKeyedInfo>::const_iterator it = pOpponent->m_unitCombatKeyedInfo.begin(), end = pOpponent->m_unitCombatKeyedInfo.end(); it != end; ++it)
	{
		if (it->second.m_bHasUnitCombat)
		{
			iBase += armorVSUnitCombatTotal(it->first);
		}
	}
	int iTotal = std::max(0, iBase);

	return iTotal;
}

int CvUnit::dodgeVSOpponentProbTotal(const CvUnit* pOpponent) const
{
	PROFILE_EXTRA_FUNC();
	int iBase = dodgeTotal();
	for (std::map<UnitCombatTypes, UnitCombatKeyedInfo>::const_iterator it = pOpponent->m_unitCombatKeyedInfo.begin(), end = pOpponent->m_unitCombatKeyedInfo.end(); it != end; ++it)
	{
		if (it->second.m_bHasUnitCombat)
		{
			iBase += dodgeVSUnitCombatTotal(it->first);
		}
	}
	int iTotal = std::max(0, iBase);

	return iTotal;
}

int CvUnit::precisionVSOpponentProbTotal(const CvUnit* pOpponent) const
{
	PROFILE_EXTRA_FUNC();
	int iBase = precisionTotal();
	for (std::map<UnitCombatTypes, UnitCombatKeyedInfo>::const_iterator it = pOpponent->m_unitCombatKeyedInfo.begin(), end = pOpponent->m_unitCombatKeyedInfo.end(); it != end; ++it)
	{
		if (it->second.m_bHasUnitCombat)
		{
			iBase += precisionVSUnitCombatTotal(it->first);
		}
	}
	int iTotal = std::max(0, iBase);

	return iTotal;
}

int CvUnit::criticalVSOpponentProbTotal(const CvUnit* pOpponent) const
{
	PROFILE_EXTRA_FUNC();
	int iBase = criticalModifierTotal();
	for (std::map<UnitCombatTypes, UnitCombatKeyedInfo>::const_iterator it = pOpponent->m_unitCombatKeyedInfo.begin(), end = pOpponent->m_unitCombatKeyedInfo.end(); it != end; ++it)
	{
		if (it->second.m_bHasUnitCombat)
		{
			iBase += criticalVSUnitCombatTotal(it->first);
		}
	}
	int iTotal = std::max(0, iBase);

	return iTotal;
}

bool CvUnit::canInflictCritical(PromotionTypes eCritical) const
{
	PROFILE_EXTRA_FUNC();
	if (GC.getPromotionLineInfo((PromotionLineTypes)GC.getPromotionInfo(eCritical).getPromotionLine()).getNumCriticalOriginCombatClassTypes() > 0)
	{
		for (int iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
		{
			if (isHasUnitCombat((UnitCombatTypes)iI) && GC.getPromotionLineInfo((PromotionLineTypes)GC.getPromotionInfo(eCritical).getPromotionLine()).isCriticalOriginCombatClassType(iI))
			{
				return true;
			}
		}
	}
	else
	{
		return true;
	}
	return false;
}

#ifdef OUTBREAKS_AND_AFFLICTIONS
int CvUnit::getAfflictionLineCount(PromotionLineTypes ePromotionLineType) const
{
	FASSERT_BOUNDS(0, GC.getNumPromotionLineInfos(), ePromotionLineType);

	const PromotionLineKeyedInfo* info = findPromotionLineKeyedInfo(ePromotionLineType);

	return info == NULL ? 0 : info->m_iAfflictionLineCount;
}

bool CvUnit::hasAfflictionLine(PromotionLineTypes ePromotionLineType) const
{
	FASSERT_BOUNDS(0, GC.getNumPromotionLineInfos(), ePromotionLineType);
	return (getAfflictionLineCount(ePromotionLineType) > 0);
}

void CvUnit::changeAfflictionLineCount(PromotionLineTypes ePromotionLineType, int iChange)
{
	FASSERT_BOUNDS(0, GC.getNumPromotionLineInfos(), ePromotionLineType);

	if (iChange != 0)
	{
		PromotionLineKeyedInfo* info = findOrCreatePromotionLineKeyedInfo(ePromotionLineType);

		info->m_iAfflictionLineCount += iChange;
	}
}

void CvUnit::afflict(PromotionLineTypes eAfflictionLine, bool bPoisoned, CvUnit* pOpponent, bool bTrap, int iTrapDmg)
{
	PROFILE_EXTRA_FUNC();
	int iI;
	CvWString szBuffer;
	PromotionTypes eAfflictionHad = NO_PROMOTION;
	PromotionTypes eAfflictionGained = NO_PROMOTION;
	bool bAfflicted = false;
	for (iI = 0; iI < GC.getPromotionLineInfo(eAfflictionLine).getNumPromotions(); iI++)
	{
		const PromotionTypes eAffliction = (PromotionTypes)GC.getPromotionLineInfo(eAfflictionLine).getPromotion(iI);
		if (GC.getPromotionInfo(eAffliction).getLinePriority() == getAfflictionLineCount(eAfflictionLine))
		{
			eAfflictionHad = eAffliction;
		}
		if (GC.getPromotionInfo(eAffliction).getLinePriority() == (getAfflictionLineCount(eAfflictionLine)+1))
		{
			eAfflictionGained = eAffliction;
			bAfflicted = true;
		}
	}
	if (bAfflicted)
	{
		changeAfflictionLineCount(eAfflictionLine, 1);
		setHasPromotion(eAfflictionGained, true, true, false);
		{
			if (getAfflictionLineCount(eAfflictionLine) == 1)
			{
				GET_PLAYER(getOwner()).changePlayerWideAfflictionCount(eAfflictionLine, 1);
				if (!bTrap)
				{
					if (pOpponent != NULL)
					{
						if (bPoisoned)
						{
							//messages that introduce the affliction from battle as a poisoning

							const CvWString szBuffer = gDLL->getText("TXT_KEY_MISC_AFFLICT_SUFFERED_POISON_BATTLE_FIRST", getNameKey(), pOpponent->getNameKey(), GC.getPromotionInfo(eAfflictionGained).getTextKeyWide());
							AddDLLMessage(getOwner(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_POSITIVE_DINK", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_RED(), getX(), getY());
							const CvWString szBuffer2 = gDLL->getText("TXT_KEY_MISC_AFFLICT_DELIVERED_POISON_BATTLE_FIRST", getNameKey(), pOpponent->getNameKey(), GC.getPromotionInfo(eAfflictionGained).getTextKeyWide());
							AddDLLMessage(pOpponent->getOwner(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer2, "AS2D_POSITIVE_DINK", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_GREEN(), getX(), getY());
						}
						else
						{
							//messages that introduce the affliction from battle as a disease

							const CvWString szBuffer = gDLL->getText("TXT_KEY_MISC_AFFLICT_SUFFERED_DISEASE_BATTLE_FIRST", getNameKey(), GC.getPromotionInfo(eAfflictionGained).getTextKeyWide(), pOpponent->getNameKey());
							AddDLLMessage(getOwner(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_POSITIVE_DINK", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_RED(), getX(), getY());
							const CvWString szBuffer2 = gDLL->getText("TXT_KEY_MISC_AFFLICT_DELIVERED_DISEASE_BATTLE_FIRST", pOpponent->getNameKey(), GC.getPromotionInfo(eAfflictionGained).getTextKeyWide(), getNameKey());
							AddDLLMessage(pOpponent->getOwner(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer2, "AS2D_POSITIVE_DINK", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_GREEN(), getX(), getY());
						}
					}
					else
					{
						//message that introduces the disease affliction to the unit (only to the owner)

						const CvWString szBuffer = gDLL->getText("TXT_KEY_MISC_AFFLICT_SUFFERED_DISEASE_FIRST", getNameKey(), GC.getPromotionInfo(eAfflictionGained).getTextKeyWide());
						AddDLLMessage(getOwner(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_POSITIVE_DINK", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_RED(), getX(), getY());
					}
				}
			}
			else
			{
				if (!bTrap)
				{
					if (pOpponent != NULL)
					{
						if (bPoisoned)
						{
							//messages that worsen the affliction from battle as a poisoning

							const CvWString szBuffer = gDLL->getText("TXT_KEY_MISC_AFFLICT_SUFFERED_POISON_BATTLE_ADDITIONAL", getNameKey(), pOpponent->getNameKey(), GC.getPromotionInfo(eAfflictionGained).getTextKeyWide());
							AddDLLMessage(getOwner(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_POSITIVE_DINK", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_RED(), getX(), getY());
							const CvWString szBuffer2 = gDLL->getText("TXT_KEY_MISC_AFFLICT_DELIVERED_POISON_BATTLE_ADDITIONAL", getNameKey(), pOpponent->getNameKey(), GC.getPromotionInfo(eAfflictionGained).getTextKeyWide());
							AddDLLMessage(pOpponent->getOwner(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer2, "AS2D_POSITIVE_DINK", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_GREEN(), getX(), getY());
						}
						else
						{
							//messages that worsen the affliction from battle as a disease

							const CvWString szBuffer = gDLL->getText("TXT_KEY_MISC_AFFLICT_SUFFERED_DISEASE_BATTLE_ADDITIONAL", getNameKey(), GC.getPromotionInfo(eAfflictionGained).getTextKeyWide(), pOpponent->getNameKey());
							AddDLLMessage(getOwner(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_POSITIVE_DINK", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_RED(), getX(), getY());
							const CvWString szBuffer2 = gDLL->getText("TXT_KEY_MISC_AFFLICT_DELIVERED_DISEASE_BATTLE_ADDITIONAL", pOpponent->getNameKey(), GC.getPromotionInfo(eAfflictionGained).getTextKeyWide(), getNameKey());
							AddDLLMessage(pOpponent->getOwner(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer2, "AS2D_POSITIVE_DINK", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_GREEN(), getX(), getY());
						}
					}
					else
					{
						//message that states the affliction to the unit has worsened (only to the owner)

						const CvWString szBuffer = gDLL->getText("TXT_KEY_MISC_AFFLICT_SUFFERED_DISEASE_ADDITIONAL", getNameKey(), GC.getPromotionInfo(eAfflictionHad).getTextKeyWide(), GC.getPromotionInfo(eAfflictionGained).getTextKeyWide());
						AddDLLMessage(getOwner(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_POSITIVE_DINK", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_RED(), getX(), getY());
					}
				}
			}
			if (bTrap)
			{
				if (iTrapDmg > 0)
				{

					const CvWString szBuffer = gDLL->getText("TXT_KEY_MISC_TRAP_TRIGGERED_ALSO_AFFLICTION_SUFFERED", getNameKey(), GC.getPromotionInfo(eAfflictionGained).getTextKeyWide(), pOpponent->getNameKey());
					AddDLLMessage(getOwner(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_POSITIVE_DINK", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_RED(), getX(), getY());
					const CvWString szBuffer2 = gDLL->getText("TXT_KEY_MISC_TRAP_TRIGGERED_ALSO_AFFLICTION_INFLICTED", getNameKey(), GC.getPromotionInfo(eAfflictionGained).getTextKeyWide(), pOpponent->getNameKey());
					AddDLLMessage(pOpponent->getOwner(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer2, "AS2D_POSITIVE_DINK", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_GREEN(), getX(), getY());
				}
				else
				{

					const CvWString szBuffer = gDLL->getText("TXT_KEY_MISC_TRAP_TRIGGERED_AFFLICTION_SUFFERED", getNameKey(), GC.getPromotionInfo(eAfflictionGained).getTextKeyWide(), pOpponent->getNameKey());
					AddDLLMessage(getOwner(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_POSITIVE_DINK", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_RED(), getX(), getY());
					const CvWString szBuffer2 = gDLL->getText("TXT_KEY_MISC_TRAP_TRIGGERED_AFFLICTION_INFLICTED", getNameKey(), GC.getPromotionInfo(eAfflictionGained).getTextKeyWide(), pOpponent->getNameKey());
					AddDLLMessage(pOpponent->getOwner(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer2, "AS2D_POSITIVE_DINK", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_GREEN(), getX(), getY());
				}
			}
		}
	}
}

void CvUnit::recover(PromotionLineTypes eAfflictionLine)
{
	PROFILE_EXTRA_FUNC();
	int iI;
	CvWString szBuffer;
	PromotionTypes eAfflictionHad = NO_PROMOTION;
	PromotionTypes eAfflictionGained = NO_PROMOTION;
	for (iI = 0; iI < GC.getPromotionLineInfo(eAfflictionLine).getNumPromotions(); iI++)
	{
		const PromotionTypes eAffliction = (PromotionTypes)GC.getPromotionLineInfo(eAfflictionLine).getPromotion(iI);
		if (GC.getPromotionInfo(eAffliction).getLinePriority() == (getAfflictionLineCount(eAfflictionLine)))
		{
			eAfflictionHad = eAffliction;
			changeAfflictionLineCount(eAfflictionLine, -1);
			setHasPromotion(eAffliction, false, true, false);
			break;
		}
	}
	if (getAfflictionLineCount(eAfflictionLine) > 0)
	{
		for (iI = 0; iI < GC.getPromotionLineInfo(eAfflictionLine).getNumPromotions(); iI++)
		{
			const PromotionTypes eAffliction = (PromotionTypes)GC.getPromotionLineInfo(eAfflictionLine).getPromotion(iI);
			if (GC.getPromotionInfo(eAffliction).getLinePriority() == (getAfflictionLineCount(eAfflictionLine)))
			{
				eAfflictionGained = eAffliction;
				setHasPromotion(eAffliction, true, true, false);


				const CvWString szBuffer = gDLL->getText("TXT_KEY_MISC_OVERCOME_IMPROVE", getNameKey(), eAfflictionHad, eAfflictionGained);
				AddDLLMessage(getOwner(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_POSITIVE_DINK", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_RED(), getX(), getY());
				break;
			}
		}
	}
	else
	{
		GET_PLAYER(getOwner()).changePlayerWideAfflictionCount(eAfflictionLine, -1);

		const CvWString szBuffer = gDLL->getText("TXT_KEY_MISC_OVERCOME_COMPLETE", getNameKey(), eAfflictionHad);
		AddDLLMessage(getOwner(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_POSITIVE_DINK", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_RED(), getX(), getY());
	}
}

int CvUnit::getAfflictOnAttackTypeProbability(PromotionLineTypes ePromotionLineType) const
{
	PROFILE_EXTRA_FUNC();
	FASSERT_BOUNDS(0, GC.getNumPromotionLineInfos(), ePromotionLineType);

	const PromotionLineKeyedInfo* info = findPromotionLineKeyedInfo(ePromotionLineType);

	int iEvaluation = (info == NULL ? 0 : info->m_iAfflictOnAttackTypeProbability);
	const int iNum = m_pUnitInfo->getNumAfflictOnAttackTypes();

	for (int iI = 0; iI < iNum; iI++)
	{
		const PromotionLineTypes eAfflictionLine = m_pUnitInfo->getAfflictOnAttackType(iI).eAfflictionLine;
		if (eAfflictionLine == ePromotionLineType)
		{
			iEvaluation += m_pUnitInfo->getAfflictOnAttackType(iI).iProbability;
		}
	}
	if (GC.getPromotionLineInfo(ePromotionLineType).isPoison())
	{
		iEvaluation += poisonProbabilityModifierTotal();
	}
	return std::max(0, iEvaluation);
}

void CvUnit::changeAfflictOnAttackTypeProbability(PromotionLineTypes ePromotionLineType, int iChange)
{
	FASSERT_BOUNDS(0, GC.getNumPromotionLineInfos(), ePromotionLineType);

	if (iChange != 0)
	{
		PromotionLineKeyedInfo* info = findOrCreatePromotionLineKeyedInfo(ePromotionLineType);

		info->m_iAfflictOnAttackTypeProbability += iChange;
	}
}

void CvUnit::setAfflictOnAttackTypeProbability(PromotionLineTypes ePromotionLineType, int iChange)
{
	FASSERT_BOUNDS(0, GC.getNumPromotionLineInfos(), ePromotionLineType);

	PromotionLineKeyedInfo* info = findOrCreatePromotionLineKeyedInfo(ePromotionLineType, iChange != 0);

	if (info != NULL)
	{
		info->m_iAfflictOnAttackTypeProbability = iChange;
	}
}

bool CvUnit::hasAfflictOnAttackType(PromotionLineTypes ePromotionLineType) const
{
	PROFILE_EXTRA_FUNC();
	FASSERT_BOUNDS(0, GC.getNumPromotionLineInfos(), ePromotionLineType);

	const PromotionLineKeyedInfo* info = findPromotionLineKeyedInfo(ePromotionLineType);

	int iEvaluation = (info == NULL ? 0 : info->m_iAfflictOnAttackTypeCount);
	const int iNum = m_pUnitInfo->getNumAfflictOnAttackTypes();

	for (int iI = 0; iI < iNum; iI++)
	{
		const PromotionLineTypes eAfflictionLine = m_pUnitInfo->getAfflictOnAttackType(iI).eAfflictionLine;
		if (eAfflictionLine == ePromotionLineType)
		{
			iEvaluation += 1;
		}
	}
	return (iEvaluation > 0);
}

int CvUnit::getAfflictOnAttackTypeCount(PromotionLineTypes ePromotionLineType) const
{
	FASSERT_BOUNDS(0, GC.getNumPromotionLineInfos(), ePromotionLineType);

	const PromotionLineKeyedInfo* info = findPromotionLineKeyedInfo(ePromotionLineType);

	return info == NULL ? 0 : info->m_iAfflictOnAttackTypeCount;
}

void CvUnit::changeAfflictOnAttackTypeCount(PromotionLineTypes ePromotionLineType, int iChange)
{
	FASSERT_BOUNDS(0, GC.getNumPromotionLineInfos(), ePromotionLineType);

	if (iChange != 0)
	{
		PromotionLineKeyedInfo* info = findOrCreatePromotionLineKeyedInfo(ePromotionLineType);

		info->m_iAfflictOnAttackTypeCount += iChange;
	}

}

void CvUnit::setAfflictOnAttackTypeCount(PromotionLineTypes ePromotionLineType, int iChange)
{
	FASSERT_BOUNDS(0, GC.getNumPromotionLineInfos(), ePromotionLineType);

	PromotionLineKeyedInfo* info = findOrCreatePromotionLineKeyedInfo(ePromotionLineType, iChange != 0);

	if (info != NULL)
	{
		info->m_iAfflictOnAttackTypeCount = iChange;
	}
}

int CvUnit::getAfflictOnAttackTypeImmediateCount(PromotionLineTypes ePromotionLineType) const//
{
	FASSERT_BOUNDS(0, GC.getNumPromotionLineInfos(), ePromotionLineType);

	const PromotionLineKeyedInfo* info = findPromotionLineKeyedInfo(ePromotionLineType);

	return info == NULL ? 0 : info->m_iAfflictOnAttackTypeImmediateCount;
}

bool CvUnit::isAfflictOnAttackTypeImmediate(PromotionLineTypes ePromotionLineType) const
{
	PROFILE_EXTRA_FUNC();
	FASSERT_BOUNDS(0, GC.getNumPromotionLineInfos(), ePromotionLineType);

	const PromotionLineKeyedInfo* info = findPromotionLineKeyedInfo(ePromotionLineType);

	int iEvaluation = (info == NULL ? 0 : info->m_iAfflictOnAttackTypeImmediateCount);
	const int iNum = m_pUnitInfo->getNumAfflictOnAttackTypes();

	for (int iI = 0; iI < iNum; iI++)
	{
		const PromotionLineTypes eAfflictionLine = m_pUnitInfo->getAfflictOnAttackType(iI).eAfflictionLine;
		if (eAfflictionLine == ePromotionLineType)
		{
			iEvaluation += m_pUnitInfo->getAfflictOnAttackType(iI).iImmediate;
			break;
		}
	}
	return (iEvaluation > 0);
}

void CvUnit::changeAfflictOnAttackTypeImmediateCount(PromotionLineTypes ePromotionLineType, int iChange)
{
	FASSERT_BOUNDS(0, GC.getNumPromotionLineInfos(), ePromotionLineType);

	if (iChange != 0)
	{
		PromotionLineKeyedInfo* info = findOrCreatePromotionLineKeyedInfo(ePromotionLineType);

		info->m_iAfflictOnAttackTypeImmediateCount += iChange;
	}
}

void CvUnit::setAfflictOnAttackTypeImmediateCount(PromotionLineTypes ePromotionLineType, int iChange)
{
	FASSERT_BOUNDS(0, GC.getNumPromotionLineInfos(), ePromotionLineType);

	PromotionLineKeyedInfo* info = findOrCreatePromotionLineKeyedInfo(ePromotionLineType, iChange != 0);

	if (info != NULL)
	{
		info->m_iAfflictOnAttackTypeImmediateCount = iChange;
	}
}

int CvUnit::getAfflictOnAttackTypeMeleeCount(PromotionLineTypes ePromotionLineType) const//
{
	FASSERT_BOUNDS(0, GC.getNumPromotionLineInfos(), ePromotionLineType);

	const PromotionLineKeyedInfo* info = findPromotionLineKeyedInfo(ePromotionLineType);

	return info == NULL ? 0 : info->m_iAfflictOnAttackTypeMeleeCount;
}

bool CvUnit::isAfflictOnAttackTypeMelee(PromotionLineTypes ePromotionLineType) const
{
	PROFILE_EXTRA_FUNC();
	FASSERT_BOUNDS(0, GC.getNumPromotionLineInfos(), ePromotionLineType);

	const PromotionLineKeyedInfo* info = findPromotionLineKeyedInfo(ePromotionLineType);

	int iEvaluation = (info == NULL ? 0 : info->m_iAfflictOnAttackTypeMeleeCount);
	const int iNum = m_pUnitInfo->getNumAfflictOnAttackTypes();

	for (int iI = 0; iI < iNum; iI++)
	{
		const PromotionLineTypes eAfflictionLine = m_pUnitInfo->getAfflictOnAttackType(iI).eAfflictionLine;
		if (eAfflictionLine == ePromotionLineType)
		{
			iEvaluation += m_pUnitInfo->getAfflictOnAttackType(iI).iMelee;
			break;
		}
	}
	return (iEvaluation > 0);
}

void CvUnit::changeAfflictOnAttackTypeMeleeCount(PromotionLineTypes ePromotionLineType, int iChange)
{
	FASSERT_BOUNDS(0, GC.getNumPromotionLineInfos(), ePromotionLineType);

	if (iChange != 0)
	{
		PromotionLineKeyedInfo* info = findOrCreatePromotionLineKeyedInfo(ePromotionLineType);

		info->m_iAfflictOnAttackTypeMeleeCount += iChange;
	}
}

void CvUnit::setAfflictOnAttackTypeMeleeCount(PromotionLineTypes ePromotionLineType, int iChange)
{
	FASSERT_BOUNDS(0, GC.getNumPromotionLineInfos(), ePromotionLineType);

	PromotionLineKeyedInfo* info = findOrCreatePromotionLineKeyedInfo(ePromotionLineType, iChange != 0);

	if (info != NULL)
	{
		info->m_iAfflictOnAttackTypeMeleeCount = iChange;
	}
}

int CvUnit::getAfflictOnAttackTypeDistanceCount(PromotionLineTypes ePromotionLineType) const//
{
	FASSERT_BOUNDS(0, GC.getNumPromotionLineInfos(), ePromotionLineType);

	const PromotionLineKeyedInfo* info = findPromotionLineKeyedInfo(ePromotionLineType);

	return info == NULL ? 0 : info->m_iAfflictOnAttackTypeDistanceCount;
}

bool CvUnit::isAfflictOnAttackTypeDistance(PromotionLineTypes ePromotionLineType) const
{
	PROFILE_EXTRA_FUNC();
	FASSERT_BOUNDS(0, GC.getNumPromotionLineInfos(), ePromotionLineType);

	const PromotionLineKeyedInfo* info = findPromotionLineKeyedInfo(ePromotionLineType);

	int iEvaluation = (info == NULL ? 0 : info->m_iAfflictOnAttackTypeDistanceCount);
	const int iNum = m_pUnitInfo->getNumAfflictOnAttackTypes();

	for (int iI = 0; iI < iNum; iI++)
	{
		const PromotionLineTypes eAfflictionLine = m_pUnitInfo->getAfflictOnAttackType(iI).eAfflictionLine;
		if (eAfflictionLine == ePromotionLineType)
		{
			iEvaluation += m_pUnitInfo->getAfflictOnAttackType(iI).iDistance;
			break;
		}
	}
	return (iEvaluation > 0);
}

void CvUnit::changeAfflictOnAttackTypeDistanceCount(PromotionLineTypes ePromotionLineType, int iChange)
{
	FASSERT_BOUNDS(0, GC.getNumPromotionLineInfos(), ePromotionLineType);

	if (iChange != 0)
	{
		PromotionLineKeyedInfo* info = findOrCreatePromotionLineKeyedInfo(ePromotionLineType);

		info->m_iAfflictOnAttackTypeDistanceCount += iChange;
	}
}

void CvUnit::setAfflictOnAttackTypeDistanceCount(PromotionLineTypes ePromotionLineType, int iChange)
{
	FASSERT_BOUNDS(0, GC.getNumPromotionLineInfos(), ePromotionLineType);

	PromotionLineKeyedInfo* info = findOrCreatePromotionLineKeyedInfo(ePromotionLineType, iChange!= 0);

	if (info != 0)
	{
		info->m_iAfflictOnAttackTypeDistanceCount = iChange;
	}
}
//
int CvUnit::getAfflictOnAttackTypeAttemptedCount(PromotionLineTypes ePromotionLineType) const
{
	FASSERT_BOUNDS(0, GC.getNumPromotionLineInfos(), ePromotionLineType);

	const PromotionLineKeyedInfo* info = findPromotionLineKeyedInfo(ePromotionLineType);

	return info == NULL ? 0 : info->m_iAfflictOnAttackTypeAttemptedCount;
}

bool CvUnit::isAfflictOnAttackTypeAttempted(PromotionLineTypes ePromotionLineType) const
{
	FASSERT_BOUNDS(0, GC.getNumPromotionLineInfos(), ePromotionLineType);
	const PromotionLineKeyedInfo* info = findPromotionLineKeyedInfo(ePromotionLineType);

	return info ? info->m_iAfflictOnAttackTypeAttemptedCount > 0 : false;
}

void CvUnit::changeAfflictOnAttackTypeAttemptedCount(PromotionLineTypes ePromotionLineType, int iChange)
{
	FASSERT_BOUNDS(0, GC.getNumPromotionLineInfos(), ePromotionLineType);

	if (iChange != 0)
	{
		PromotionLineKeyedInfo* info = findOrCreatePromotionLineKeyedInfo(ePromotionLineType);

		info->m_iAfflictOnAttackTypeAttemptedCount += iChange;
	}
}

void CvUnit::setAfflictOnAttackTypeAttemptedCount(PromotionLineTypes ePromotionLineType, int iChange)
{
	FASSERT_BOUNDS(0, GC.getNumPromotionLineInfos(), ePromotionLineType);

	PromotionLineKeyedInfo* info = findOrCreatePromotionLineKeyedInfo(ePromotionLineType, iChange != 0);

	if (info != NULL)
	{
		info->m_iAfflictOnAttackTypeAttemptedCount = iChange;
	}
}

int CvUnit::worsenedProbabilitytoAfflict(PromotionLineTypes eAfflictionLine) const
{
	const int iLinePriority = getAfflictionLineCount(eAfflictionLine) - 1;
	const int iProbabilityMultiplier = GC.getPromotionLineInfo(eAfflictionLine).getWorsenedCommunicabilityIncrementModifier();
	return (iLinePriority * iProbabilityMultiplier);
}
#endif // OUTBREAKS_AND_AFFLICTIONS


int CvUnit::getHealUnitCombatCount() const
{
	return m_iHealUnitCombatCount;
}

int CvUnit::getHealUnitCombatTypeTotal(UnitCombatTypes eUnitCombatType) const
{
	FASSERT_BOUNDS(0, GC.getNumUnitCombatInfos(), eUnitCombatType);

	const UnitCombatKeyedInfo* info = findUnitCombatKeyedInfo(eUnitCombatType);

	return std::max(0, info ? info->m_iHealUnitCombatTypeVolume : 0);
}

void CvUnit::changeHealUnitCombatTypeVolume(UnitCombatTypes eUnitCombatType, int iChange)
{
	FASSERT_BOUNDS(0, GC.getNumUnitCombatInfos(), eUnitCombatType);

	if (iChange != 0)
	{
		UnitCombatKeyedInfo* info = findOrCreateUnitCombatKeyedInfo(eUnitCombatType);

		if (info->m_iHealUnitCombatTypeVolume > 0)
		{
			m_iHealUnitCombatCount -= info->m_iHealUnitCombatTypeVolume;
		}
		info->m_iHealUnitCombatTypeVolume += iChange;

		if (info->m_iHealUnitCombatTypeVolume > 0)
		{
			m_iHealUnitCombatCount += info->m_iHealUnitCombatTypeVolume;
		}
	}
}

int CvUnit::getHealUnitCombatTypeAdjacentTotal(UnitCombatTypes eUnitCombatType) const
{
	FASSERT_BOUNDS(0, GC.getNumUnitCombatInfos(), eUnitCombatType);

	const UnitCombatKeyedInfo* info = findUnitCombatKeyedInfo(eUnitCombatType);

	return std::max(0, info ? info->m_iHealUnitCombatTypeAdjacentVolume : 0);
}

void CvUnit::changeHealUnitCombatTypeAdjacentVolume(UnitCombatTypes eUnitCombatType, int iChange)
{
	FASSERT_BOUNDS(0, GC.getNumUnitCombatInfos(), eUnitCombatType);

	if (iChange != 0)
	{
		UnitCombatKeyedInfo* info = findOrCreateUnitCombatKeyedInfo(eUnitCombatType);

		if (info->m_iHealUnitCombatTypeAdjacentVolume > 0)
		{
			m_iHealUnitCombatCount -= info->m_iHealUnitCombatTypeAdjacentVolume;
		}
		info->m_iHealUnitCombatTypeAdjacentVolume += iChange;

		if (info->m_iHealUnitCombatTypeAdjacentVolume > 0)
		{
			m_iHealUnitCombatCount += info->m_iHealUnitCombatTypeAdjacentVolume;
		}
	}
}

void CvUnit::doSetUnitCombats()
{
	PROFILE_EXTRA_FUNC();
	if (getUnitCombatType() != NO_UNITCOMBAT)
	{
		setHasUnitCombat(getUnitCombatType(), true);
	}
	foreach_(const UnitCombatTypes eSubCombat, m_pUnitInfo->getSubCombatTypes())
	{
		setHasUnitCombat(eSubCombat, true);
	}
	const EraTypes eEra =
	(
		m_pUnitInfo->getPrereqAndTech() > -1
		?
		(EraTypes)GC.getTechInfo((TechTypes)m_pUnitInfo->getPrereqAndTech()).getEra()
		:
		GC.getGame().getCurrentEra()
	);
	for (int iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
	{
		if (GC.getUnitCombatInfo((UnitCombatTypes)iI).getEra() == eEra)
		{
			setHasUnitCombat((UnitCombatTypes)iI, true, false);
			break;
		}
	}
	if (GC.getGame().isOption(GAMEOPTION_COMBAT_SIZE_MATTERS))
	{
		setSMValues();
	}
}

void CvUnit::setFreePromotion(PromotionTypes ePromotion, bool bAdding, TraitTypes eTrait)
{
	PROFILE_EXTRA_FUNC();
	const CvPlayer& pPlayer = GET_PLAYER(getOwner());

	if (bAdding && !isHasPromotion(ePromotion))
	{
		if (m_pUnitInfo->getFreePromotions((int)ePromotion)
		|| (NO_UNIT != getUnitType() && pPlayer.isFreePromotion(getUnitType(), ePromotion)))
		{
			setHasPromotion(ePromotion, true, true);
			return;
		}

		for (std::map<UnitCombatTypes, UnitCombatKeyedInfo>::const_iterator it = m_unitCombatKeyedInfo.begin(), end = m_unitCombatKeyedInfo.end(); it != end; ++it)
		{
			if (it->second.m_bHasUnitCombat)
			{
				if (pPlayer.isFreePromotion(it->first, ePromotion))
				{
					setHasPromotion(ePromotion, true, true);
					return;
				}

				if (eTrait == NO_TRAIT)
				{
					for (int iK = GC.getNumTraitInfos() - 1; iK > -1; iK--)
					{
						if (pPlayer.hasTrait((TraitTypes)iK) && GC.getTraitInfo((TraitTypes)iK).isFreePromotionUnitCombats(ePromotion, it->first))
						{
							setHasPromotion(ePromotion, true, true, false, false, true);
							return;
						}
					}
				}
				else if (GC.getTraitInfo(eTrait).isFreePromotionUnitCombats(ePromotion, it->first))
				{
					setHasPromotion(ePromotion, true, true, false, false, true);
					return;
				}
			}
		}
	}
	//Remove trait derived promotions if trait has been removed
	if (!bAdding && isPromotionFromTrait(ePromotion) && isHasPromotion(ePromotion))
	{
		for (std::map<UnitCombatTypes, UnitCombatKeyedInfo>::const_iterator it = m_unitCombatKeyedInfo.begin(), end = m_unitCombatKeyedInfo.end(); it != end; ++it)
		{
			if (it->second.m_bHasUnitCombat)
			{
				if (eTrait == NO_TRAIT)
				{
					for (int iK = GC.getNumTraitInfos() - 1; iK > -1; iK--)
					{
						if (!pPlayer.hasTrait((TraitTypes)iK) && GC.getTraitInfo((TraitTypes)iK).isFreePromotionUnitCombats((int)ePromotion, it->first))
						{
							setHasPromotion(ePromotion, false, true, false, false, true);
							return;
						}
					}
				}
				else if (GC.getTraitInfo(eTrait).isFreePromotionUnitCombats((int)ePromotion, it->first))
				{
					setHasPromotion(ePromotion, false, true, false, false, true);
					return;
				}
			}
		}
	}
}

void CvUnit::doSetFreePromotions(bool bAdding, TraitTypes eTrait)
{
	PROFILE_EXTRA_FUNC();
	for (int iI = GC.getNumPromotionInfos() - 1; iI > -1; iI--)
	{
		setFreePromotion(static_cast<PromotionTypes>(iI), bAdding, eTrait);
	}
	if (bAdding)
	{
		checkFreetoCombatClass();
	}
	if (GC.getGame().getModderGameOption(MODDERGAMEOPTION_STARSIGNS))
	{
		doStarsign();
	}
}

int CvUnit::getRetrainsAvailable() const
{
	return m_iRetrainsAvailable;
}

void CvUnit::setRetrainsAvailable(int iNewValue)
{
	m_iRetrainsAvailable = iNewValue;
	FASSERT_NOT_NEGATIVE(getRetrainsAvailable());
}

void CvUnit::changeRetrainsAvailable(int iChange)
{
	setRetrainsAvailable(getRetrainsAvailable() + iChange);
}

int CvUnit::getExperiencefromWithdrawal(const int iWithdrawalProbability) const
{
	return std::max(1, GC.getEXPERIENCE_FROM_WITHDRAWL() * (100 - iWithdrawalProbability));
}


void CvUnit::changeExtraCaptureProbabilityModifier(int iChange)
{
	m_iExtraCaptureProbabilityModifier += iChange;
}

int CvUnit::captureProbabilityTotal() const
{
	int iData = m_pUnitInfo->getCaptureProbabilityModifier() + m_iExtraCaptureProbabilityModifier;

	if (!isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander)
		{
			iData += pCommander->m_iExtraCaptureProbabilityModifier;
		}
	}
	if (!isCommodore())
    	{
    		const CvUnit* pCommodore = getCommodore();
    		if (pCommodore)
    		{
    			iData += pCommodore->m_iExtraCaptureProbabilityModifier;
    		}
    	}
	iData += GET_PLAYER(getOwner()).getExtraNationalCaptureProbabilityModifier();

	if (plot()->isCity(false, getTeam()))
	{
		iData += plot()->getPlotCity()->getExtraLocalCaptureProbabilityModifier();
	}
	return std::max(0, iData);
}


void CvUnit::changeExtraCaptureResistanceModifier(int iChange)
{
	m_iExtraCaptureResistanceModifier += iChange;
}

int CvUnit::captureResistanceTotal() const
{
	int iData = m_pUnitInfo->getCaptureResistanceModifier() + m_iExtraCaptureResistanceModifier;

	if (!isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander)
		{
			iData += pCommander->m_iExtraCaptureResistanceModifier;
		}
	}
	if (!isCommodore())
    	{
    		const CvUnit* pCommodore = getCommodore();
    		if (pCommodore)
    		{
    			iData += pCommodore->m_iExtraCaptureResistanceModifier;
    		}
    	}
	iData += GET_PLAYER(getOwner()).getExtraNationalCaptureResistanceModifier();

	if (plot()->isCity(false, getTeam()))
	{
		iData += plot()->getPlotCity()->getExtraLocalCaptureResistanceModifier();
	}
	return std::max(0, iData);
}


void CvUnit::changeExtraBreakdownChance(int iChange)
{
	m_iExtraBreakdownChance += iChange;
}

int CvUnit::breakdownChanceTotal() const
{
	int iData = m_pUnitInfo->getBreakdownChance() + m_iExtraBreakdownChance;

	if (!isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander)
		{
			iData += pCommander->m_iExtraBreakdownChance;
		}
	}
	if (!isCommodore())
    	{
    		const CvUnit* pCommodore = getCommodore();
    		if (pCommodore)
    		{
    			iData += pCommodore->m_iExtraBreakdownChance;
    		}
    	}
	return std::max(0, iData);
}


void CvUnit::changeExtraBreakdownDamage(int iChange)
{
	m_iExtraBreakdownDamage +=iChange;
}

int CvUnit::breakdownDamageTotal() const
{
	int iData = m_pUnitInfo->getBreakdownDamage() + m_iExtraBreakdownDamage;
	if (!isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander)
		{
			iData += pCommander->m_iExtraBreakdownDamage;
		}
	}
	if (!isCommodore())
    	{
    		const CvUnit* pCommodore = getCommodore();
    		if (pCommodore)
    		{
    			iData += pCommodore->m_iExtraBreakdownDamage;
    		}
    	}
	return std::max(0, iData);
}

void CvUnit::changeExtraTaunt(int iChange)
{
	m_iExtraTaunt += iChange;
}

int CvUnit::tauntTotal() const
{
	return std::max(0, m_pUnitInfo->getTaunt() + m_iExtraTaunt);
}

int CvUnit::getExtraCombatModifierPerSizeMore() const
{
	return std::max(0, m_iExtraCombatModifierPerSizeMore);
}

void CvUnit::changeExtraCombatModifierPerSizeMore(int iChange)
{
	m_iExtraCombatModifierPerSizeMore += iChange;
}

void CvUnit::setExtraCombatModifierPerSizeMore(int iChange)
{
	m_iExtraCombatModifierPerSizeMore = iChange;
}

int CvUnit::combatModifierPerSizeMoreTotal() const
{
	int iData = m_pUnitInfo->getCombatModifierPerSizeMore();
	iData += getExtraCombatModifierPerSizeMore();
	return iData;
}

int CvUnit::getExtraCombatModifierPerSizeLess() const
{
	return std::max(0, m_iExtraCombatModifierPerSizeLess);
}

void CvUnit::changeExtraCombatModifierPerSizeLess(int iChange)
{
	m_iExtraCombatModifierPerSizeLess += iChange;
}

void CvUnit::setExtraCombatModifierPerSizeLess(int iChange)
{
	m_iExtraCombatModifierPerSizeLess = iChange;
}

int CvUnit::combatModifierPerSizeLessTotal() const
{
	int iData = m_pUnitInfo->getCombatModifierPerSizeLess();
	iData += getExtraCombatModifierPerSizeLess();
	return iData;
}

int CvUnit::getExtraCombatModifierPerVolumeMore() const
{
	return std::max(0, m_iExtraCombatModifierPerVolumeMore);
}

void CvUnit::changeExtraCombatModifierPerVolumeMore(int iChange)
{
	m_iExtraCombatModifierPerVolumeMore += iChange;
}

void CvUnit::setExtraCombatModifierPerVolumeMore(int iChange)
{
	m_iExtraCombatModifierPerVolumeMore = iChange;
}

int CvUnit::combatModifierPerVolumeMoreTotal() const
{
	int iData = m_pUnitInfo->getCombatModifierPerVolumeMore();
	iData += getExtraCombatModifierPerVolumeMore();
	return iData;
}

int CvUnit::getExtraCombatModifierPerVolumeLess() const
{
	return std::max(0, m_iExtraCombatModifierPerVolumeLess);
}

void CvUnit::changeExtraCombatModifierPerVolumeLess(int iChange)
{
	m_iExtraCombatModifierPerVolumeLess += iChange;
}

void CvUnit::setExtraCombatModifierPerVolumeLess(int iChange)
{
	m_iExtraCombatModifierPerVolumeLess = iChange;
}

int CvUnit::combatModifierPerVolumeLessTotal() const
{
	int iData = m_pUnitInfo->getCombatModifierPerVolumeLess();
	iData += getExtraCombatModifierPerVolumeLess();
	return iData;
}

int CvUnit::getExtraStrengthModifier() const
{
	return m_iExtraStrengthModifier;
}

void CvUnit::changeExtraStrengthModifier(int iChange)
{
	m_iExtraStrengthModifier += iChange;
}

void CvUnit::setExtraStrengthModifier(int iChange)
{
	m_iExtraStrengthModifier = iChange;
}

void CvUnit::checkCityAttackDefensesDamage(CvCity* pCity, const std::vector<UnitCombatTypes>& kDamagableUnitCombatTypes)
{
	PROFILE_EXTRA_FUNC();
	//Here we cycle through each active building in the city that's triggering the fact that it can possibly damage the attacking unit here and make a check
	//using the building's % chance to damage - Dodge.  Then if it hits, deals DamageToAttacker modified by the unit's Armor.
	//Then battle would proceed as normal.
	const int iUnitDodge = dodgeTotal() - 100;
	const int iUnitArmor = armorTotal();

	foreach_(const BuildingTypes eType, pCity->getHasBuildings())
	{
		if (pCity->isDisabledBuilding(eType))
		{
			continue;
		}
		const CvBuildingInfo& buildingX = GC.getBuildingInfo(eType);

		if (!buildingX.isDamageAttackerCapable())
		{
			continue;
		}
		const bool bSpecific = !buildingX.isDamageAllAttackers();

		for (uint16_t iJ = 0; iJ < kDamagableUnitCombatTypes.size(); iJ++)
		{
			if (bSpecific && !buildingX.isMayDamageAttackingUnitCombatType(kDamagableUnitCombatTypes[iJ]))
			{
				continue;
			}
			if (GC.getGame().getSorenRandNum(100, "BuildingAttackRoll") < buildingX.getDamageAttackerChance() - iUnitDodge)
			{
				int iBuildingAttackDamageBase = buildingX.getDamageToAttacker();
				if (!buildingX.isDamageToAttackerIgnoresArmor())
				{
					iBuildingAttackDamageBase -= iUnitArmor;
				}

				if (iBuildingAttackDamageBase > 0)
				{
					changeDamage(iBuildingAttackDamageBase, getOwner());

					if (isHuman())
					{
						AddDLLMessage(
							getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
							gDLL->getText(
								"TXT_KEY_MISC_ATTACKER_SUFFERS_BUILDING_DAMAGE",
								getNameKey(), pCity->getNameKey(), buildingX.getTextKeyWide(), iBuildingAttackDamageBase
							),
							"AS2D_COMBAT", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_RED(), pCity->getX(), pCity->getY()
						);
					}

					if (GET_PLAYER(pCity->getOwner()).isHumanPlayer())
					{
						AddDLLMessage(
							pCity->getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
							gDLL->getText(
								"TXT_KEY_MISC_BUILDING_DAMAGED_ATTACKER",
								getNameKey(), pCity->getNameKey(), buildingX.getTextKeyWide(), iBuildingAttackDamageBase
							),
							"AS2D_POSITIVE_DINK", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_GREEN(), pCity->getX(), pCity->getY()
						);
					}
				}
			}
			// Don't continue over the other combat types for this building.
			break; // A building can only attack a specific unit once per turn.
		}
	}
}

bool CvUnit::isBreakdownCombat(const CvPlot* pPlot, bool bSamePlot) const
{
	//only if attacking unit has the ability and is not currently engaged in a distance counterattack as it approaches.
	if (breakdownChanceTotal() > 0 && breakdownDamageTotal() > 0 && !bSamePlot)
	{
		if (pPlot->isCity(false))
		{
			const CvCity* pCity = pPlot->getPlotCity();
			//Only if the city still has some defenses left to damage.
			if (pCity->isBombardable(this))
			{
				return true;
			}
		}
	}
	return false;
}

void CvUnit::resolveBreakdownAttack(const CvPlot* pPlot, const int AdjustedRepel)
{
	if (!pPlot->isCity(false))
	{
		return;
	}

	CvCity* pCity = pPlot->getPlotCity();

	FAssertMsg(pCity != NULL, "Breakdown Target City is not assigned a valid value");

	const int iNormalDamage = breakdownDamageTotal();
	int iTrueDamage = iNormalDamage + iNormalDamage * std::max(0, 100 - pCity->getBuildingBombardDefense()) / 100;

	if (iNormalDamage > 0)
	{
		iTrueDamage = std::max(1, iTrueDamage);
	}

	if (std::max(5, breakdownChanceTotal() - AdjustedRepel) > GC.getGame().getSorenRandNum(100, "BreakdownAttackRoll"))
	{
		pCity->changeDefenseModifier(-iTrueDamage);

		CvWString szBuffer = gDLL->getText("TXT_KEY_MISC_DEFENSES_IN_CITY_REDUCED_TO", pCity->getNameKey(), pCity->getDefenseModifier(false), GET_PLAYER(getOwner()).getNameKey());
		AddDLLMessage(pCity->getOwner(), false, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_BOMBARDED", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_RED(), pCity->getX(), pCity->getY(), true, true);

		szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_REDUCE_CITY_DEFENSES", getNameKey(), pCity->getNameKey(), pCity->getDefenseModifier(false));
		AddDLLMessage(getOwner(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_BOMBARD", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_GREEN(), pCity->getX(), pCity->getY());
	}
}

int CvUnit::getDiminishingReturn(int i) const
{
	PROFILE_EXTRA_FUNC();
	if (i < 51)
	{
		return i;
	}
	int iA = 0;
	int iB = 100;

	for (int iC = i; iC > 0; iC /= 2)
	{
		iB /= 2;
		iA += iB;
		i -= iB;
		i /= 2;
		if (i < iB/2 + 1)
		{
			i += iA;
			return i;
		}
	}
	return 0;
}

bool CvUnit::isPursuitPossible(const CvUnit* pOpponent) const
{
	bool bAnswer = true;
	if (GC.getGame().isOption(GAMEOPTION_COMBAT_FIGHT_OR_FLIGHT) && GC.getGame().isOption(GAMEOPTION_COMBAT_SIZE_MATTERS))
	{
		if (pOpponent->canFliesToMove() && !canFliesToMove())
		{
			bAnswer = false;
		}
	}
	return bAnswer;
}

bool CvUnit::hasCannotMergeSplit() const
{
	return getCannotMergeSplitCount() > 0;
}

int CvUnit::getCannotMergeSplitCount() const
{
	return m_iCannotMergeSplitCount;
}

void CvUnit::changeCannotMergeSplitCount(int iNewValue)
{
	m_iCannotMergeSplitCount += iNewValue;
}

int CvUnit::getQualityBaseTotal() const
{
	return m_iQualityBaseTotal;
}

void CvUnit::setQualityBaseTotal(int iNewValue)
{
	m_iQualityBaseTotal = iNewValue;
}

int CvUnit::getGroupBaseTotal() const
{
	return m_iGroupBaseTotal;
}

void CvUnit::setGroupBaseTotal(int iNewValue)
{
	m_iGroupBaseTotal = iNewValue;
}

int CvUnit::getSizeBaseTotal() const
{
	return m_iSizeBaseTotal;
}

void CvUnit::setSizeBaseTotal(int iNewValue)
{
	m_iSizeBaseTotal = iNewValue;
}

int CvUnit::getExtraQuality() const
{
	return m_iExtraQuality;
}

void CvUnit::changeExtraQuality(int iChange)
{
	m_iExtraQuality += iChange;
}

int CvUnit::getExtraGroup() const
{
	return m_iExtraGroup;
}

void CvUnit::changeExtraGroup(int iChange)
{
	GET_PLAYER(getOwner()).changeUnitCountSM(m_eUnitType, -intPow(3, groupRank()-1));
	m_iExtraGroup += iChange;
	GET_PLAYER(getOwner()).changeUnitCountSM(m_eUnitType, intPow(3, groupRank()-1));
}

int CvUnit::getExtraSize() const
{
	return m_iExtraSize;
}

void CvUnit::changeExtraSize(int iChange)
{
	m_iExtraSize += iChange;
}

int CvUnit::qualityRank() const
{
	FASSERT_NOT_NEGATIVE(getQualityBaseTotal());
	return (getQualityBaseTotal() + getExtraQuality());
}

int CvUnit::groupRank() const
{
	FASSERT_NOT_NEGATIVE(getGroupBaseTotal());
	return (getGroupBaseTotal() + getExtraGroup());
}

int CvUnit::sizeRank() const
{
	FASSERT_NOT_NEGATIVE(getSizeBaseTotal());
	return (getSizeBaseTotal() + getExtraSize());
}

// (bAutocheck = true) check will be ordering a 4th potentially mergable unit to
// split instead during it's check processing.
// The thinking behind this method is that when we merge 3 units we want a 4th one that
// was capable of it to be present and to split so that the unit count remains the same
// and for the alternative strategy of splitting to be equally expressed.
// For defense this means you create fodder flak to hold off minimalist unit count
// armies, buying time, and a strong lead defender to make a tough stand
// For attack you have a strong lead attacker to bust through stiff opposition and some
// smaller units to wipe up defenders weakened by collateral (or splitting strategies
// to delay the capture of the city or position.)
// After a few round of such merging among particular types in the same location will
// create a nice gradient of unit group sizes.  Should be interesting to see its effect in play.
// TBSPLIT
bool CvUnit::canMerge(bool bAutocheck) const
{
	PROFILE_EXTRA_FUNC();
	FAssertMsg(plot(), "canMerge expects unit plot to be valid");


	if (!GC.getGame().isOption(GAMEOPTION_COMBAT_SIZE_MATTERS))
	{
		return false;
	}

	if (isHuman() && getGroup()->getNumUnits() > 1)
	{
		return false;
	}

	if (isHurt()
		|| isDead()
		|| isInBattle()
		|| isCargo()
		|| hasCargo()
		|| isSpy()
		|| hasMoved()
		|| groupRank() >= eraGroupMergeLimit()
		|| isInhibitMerge())
	{
		return false;
	}

	if (hasCannotMergeSplit())
	{
		return false;
	}

	if (baseWorkRate() > 0)
	{
		return false;
	}

	CvPlot* pPlot = plot();
	int iValidUnitCount = 0;
	foreach_(const CvUnit* pLoopUnit, pPlot->units())
	{
		if (pLoopUnit->getOwner() == getOwner() && pLoopUnit->getID() != getID()

			&& pLoopUnit->getUnitType() == getUnitType()
			&& pLoopUnit->groupRank() == groupRank()
			&& pLoopUnit->qualityRank() == qualityRank()

			&& !pLoopUnit->isHurt()
			&& !pLoopUnit->isDead()
			&& !pLoopUnit->isInBattle()
			&& !pLoopUnit->isCargo()
			&& !pLoopUnit->hasCargo()
			&& !pLoopUnit->isSpy()
			&& !pLoopUnit->hasMoved()
			&& pLoopUnit->baseWorkRate() < 1
			&& pLoopUnit->groupRank() < pLoopUnit->eraGroupMergeLimit()

			&& !pLoopUnit->hasCannotMergeSplit()
			)
		{
			if (!bAutocheck)
			{
				iValidUnitCount++;
			}
			else if (pLoopUnit->AI_getUnitAIType() == AI_getUnitAIType())
			{
				iValidUnitCount++;
			}
			if (bAutocheck && iValidUnitCount == 3)
			{
				return true;
			}
		}
	}
	if (iValidUnitCount >= 2)
	{
		return true;
	}

	return false;
}


bool CvUnit::canSplit() const
{

	if (!GC.getGame().isOption(GAMEOPTION_COMBAT_SIZE_MATTERS))
	{
		return false;
	}

	if (isHurt() || isDead() || isInBattle() || isCargo() || hasCargo() || isSpy() || hasMoved() || isInhibitSplit() )
	{
		return false;
	}

	if (hasCannotMergeSplit())
	{
		return false;
	}

	if (baseWorkRate() > 0)
	{
		return false;
	}

	if (groupRank() <= eraGroupSplitLimit())
	{
		return false;
	}
	return true;
}

// Helpers
bool CvUnit::isGroupUpgradePromotion(PromotionTypes promotion) const
{
	return GC.getPromotionInfo(promotion).getGroupChange() > 0 &&
		(canAcquirePromotion(promotion, PromotionRequirements::Promote | PromotionRequirements::ForOffset) || canAcquirePromotion(promotion));
}

bool CvUnit::isGroupDowngradePromotion(PromotionTypes promotion) const
{
	return GC.getPromotionInfo(promotion).getGroupChange() < 0 &&
		(canAcquirePromotion(promotion, PromotionRequirements::Promote | PromotionRequirements::ForOffset) || canAcquirePromotion(promotion));
}

bool CvUnit::isQualityUpgradePromotion(PromotionTypes promotion) const
{
	return GC.getPromotionInfo(promotion).getQualityChange() > 0 &&
		(canAcquirePromotion(promotion, PromotionRequirements::Promote | PromotionRequirements::ForOffset) || canAcquirePromotion(promotion));
}

bool CvUnit::isQualityDowngradePromotion(PromotionTypes promotion) const
{
	return GC.getPromotionInfo(promotion).getQualityChange() < 0 &&
		(canAcquirePromotion(promotion, PromotionRequirements::Promote | PromotionRequirements::ForOffset) || canAcquirePromotion(promotion));
}


void CvUnit::doMerge()
{
	PROFILE_EXTRA_FUNC();
	FAssertMsg(plot() != NULL, "doMerge requires CvUnit plot to be valid");
	GET_PLAYER(getOwner()).setBaseMergeSelectionUnit(getID());
	if (isHuman())
	{
		CvPopupInfo* pInfo = new CvPopupInfo(BUTTONPOPUP_CHOOSE_MERGE_UNIT);
		pInfo->setData1(getID());
		pInfo->setData2(getX());
		pInfo->setData3(getY());
		gDLL->getInterfaceIFace()->addPopup(pInfo, getOwner(), true);
	}
	else
	{
		CvPlot* pPlot = plot();
		CvUnit* pUnit1 = GET_PLAYER(getOwner()).getUnit(GET_PLAYER(getOwner()).getBaseMergeSelectionUnit());
		CvSelectionGroup* pMergingGroup = pUnit1->getGroup();

		foreach_(const CvUnit* pLoopUnit, pPlot->units())
		{
			if (pLoopUnit->getOwner() == getOwner()
				&& pLoopUnit->getID() != pUnit1->getID()

				&& pLoopUnit->getUnitType() == pUnit1->getUnitType()
				&& pLoopUnit->groupRank() == pUnit1->groupRank()
				&& pLoopUnit->qualityRank() == pUnit1->qualityRank()
				&& pLoopUnit->AI_getUnitAIType() == pUnit1->AI_getUnitAIType()

				&& !pLoopUnit->isHurt()
				&& !pLoopUnit->isDead()
				&& !pLoopUnit->isInBattle()
				&& !pLoopUnit->isCargo()
				&& !pLoopUnit->hasCargo()
				&& !pLoopUnit->isSpy()
				&& !pLoopUnit->hasMoved()
				)
			{
				if (GET_PLAYER(getOwner()).getFirstMergeSelectionUnit() == FFreeList::INVALID_INDEX)
				{
					GET_PLAYER(getOwner()).setFirstMergeSelectionUnit(pLoopUnit->getID());
				}
				else if (GET_PLAYER(getOwner()).getSecondMergeSelectionUnit() == FFreeList::INVALID_INDEX)
				{
					GET_PLAYER(getOwner()).setSecondMergeSelectionUnit(pLoopUnit->getID());
					break;
				}
			}
		}

		CvUnit* pUnit2 = GET_PLAYER(getOwner()).getUnit(GET_PLAYER(getOwner()).getFirstMergeSelectionUnit());
		CvUnit* pUnit3 = GET_PLAYER(getOwner()).getUnit(GET_PLAYER(getOwner()).getSecondMergeSelectionUnit());
		UnitTypes eUnitType = pUnit1->getUnitType();

		CvUnit* pkMergedUnit = GET_PLAYER(getOwner()).initUnit(eUnitType, pPlot->getX(), pPlot->getY(), NO_UNITAI, NO_DIRECTION, GC.getGame().getSorenRandNum(10000, "AI Unit Birthmark"));
		/*PROFILE_FUNC();*/
		pUnit1->setFortifyTurns(0);
		pUnit2->setFortifyTurns(0);
		pUnit3->setFortifyTurns(0);

		int iTotalGroupOffset = 1;
		int iTotalQualityOffset = 0;
		for (int iI = 0; iI < GC.getNumPromotionInfos(); iI++)
		{
			PromotionTypes ePromotion = ((PromotionTypes)iI);
			if (GC.getPromotionInfo(ePromotion).getGroupChange() == 0 && GC.getPromotionInfo(ePromotion).getQualityChange() == 0)
			{
				if (pUnit1->isHasPromotion(ePromotion) || pUnit2->isHasPromotion(ePromotion) || pUnit3->isHasPromotion(ePromotion))
				{
					if (GC.getPromotionInfo(ePromotion).isLeader())
					{
						pkMergedUnit->setHasPromotion(ePromotion, true, true);
					}
#ifdef OUTBREAKS_AND_AFFLICTIONS
					else if (GC.getPromotionInfo(ePromotion).getPromotionLine() != NO_PROMOTIONLINE && GC.getPromotionLineInfo(GC.getPromotionInfo(ePromotion).getPromotionLine()).isAffliction())
					{
						if (GC.getGame().isOption(GAMEOPTION_COMBAT_OUTBREAKS_AND_AFFLICTIONS))
						{
							pkMergedUnit->afflict(GC.getPromotionInfo(ePromotion).getPromotionLine());
						}
					}
#endif
					else if (pUnit1->isPromotionFree(ePromotion) || pUnit2->isPromotionFree((PromotionTypes)iI) || pUnit3->isPromotionFree((PromotionTypes)iI))
					{
						pkMergedUnit->setHasPromotion(ePromotion, true, true);
					}
					else if (pUnit1->isHasPromotion(ePromotion) && pUnit2->isHasPromotion(ePromotion) && pUnit3->isHasPromotion(ePromotion))
					{
						pkMergedUnit->setHasPromotion(ePromotion, true, false);
						pkMergedUnit->changeLevel(1);
					}
				}
				if (pUnit1->isHasPromotion(ePromotion))
				{
					if (GC.getPromotionInfo(ePromotion).isEquipment())
					{
						pkMergedUnit->setHasPromotion(ePromotion, true, true);
					}
				}
				// Must include an adjustment here when equipments are able to be inventoried - Shouldn't just lose the 2nd and 3rd unit's equipment.
			}
			else if (GC.getPromotionInfo(ePromotion).getQualityChange() != 0)
			{
				if (pUnit1->isHasPromotion(ePromotion) || pUnit2->isHasPromotion(ePromotion) || pUnit3->isHasPromotion(ePromotion))
				{
					iTotalQualityOffset += GC.getPromotionInfo((PromotionTypes)iI).getQualityChange();
				}
			}
			else if (GC.getPromotionInfo(ePromotion).getGroupChange() != 0)
			{
				if (pUnit1->isHasPromotion(ePromotion) || pUnit2->isHasPromotion(ePromotion) || pUnit3->isHasPromotion(ePromotion))
				{
					iTotalGroupOffset += GC.getPromotionInfo((PromotionTypes)iI).getGroupChange();
				}
			}
		}

		bool bNormalizedGroup = CvUnit::normalizeUnitPromotions(pkMergedUnit, iTotalGroupOffset,
			bind(&CvUnit::isGroupUpgradePromotion, pkMergedUnit, _2),
			bind(&CvUnit::isGroupDowngradePromotion, pkMergedUnit, _2)
		);
		FAssertMsg(bNormalizedGroup, "Could not apply required number of group promotions on merged units");

		bool bNormalizedQuality = CvUnit::normalizeUnitPromotions(pkMergedUnit, iTotalQualityOffset,
			bind(&CvUnit::isQualityUpgradePromotion, pkMergedUnit, _2),
			bind(&CvUnit::isQualityDowngradePromotion, pkMergedUnit, _2)
		);
		FAssertMsg(bNormalizedQuality, "Could not apply required number of quality promotions on merged units");

		//Set New Experience
		int iXP1 = pUnit1->getExperience100();
		int iXP2 = pUnit2->getExperience100();
		int iXP3 = pUnit3->getExperience100();
		int iXP = iXP1 + iXP2 + iXP3;
		if (iXP != 0)
		{
			iXP /= 3;
		}
		pkMergedUnit->setExperience100(iXP);

		pkMergedUnit->checkFreetoCombatClass();
		pkMergedUnit->setGameTurnCreated(pUnit1->getGameTurnCreated());
		pkMergedUnit->m_eOriginalOwner = pUnit1->getOriginalOwner();
		pkMergedUnit->setAutoPromoting(pUnit1->isAutoPromoting());
		pkMergedUnit->testPromotionReady();
		pkMergedUnit->setName(pUnit1->getNameNoDesc());
		
		pkMergedUnit->AI_setUnitAIType(pUnit1->AI_getUnitAIType());
		if (pUnit2->AI_getUnitAIType() == pUnit3->AI_getUnitAIType() && pkMergedUnit->AI_getUnitAIType() != pUnit2->AI_getUnitAIType())
		{
			pkMergedUnit->AI_setUnitAIType(pUnit2->AI_getUnitAIType());
		}

		if (pUnit1->getLeaderUnitType() != NO_UNIT)
		{
			pkMergedUnit->setLeaderUnitType(pUnit1->getLeaderUnitType());
		}
		if (pUnit2->getLeaderUnitType() != NO_UNIT && pkMergedUnit->getLeaderUnitType() == NO_UNIT)
		{
			pkMergedUnit->setLeaderUnitType(pUnit2->getLeaderUnitType());
		}
		if (pUnit3->getLeaderUnitType() != NO_UNIT && pkMergedUnit->getLeaderUnitType() == NO_UNIT)
		{
			pkMergedUnit->setLeaderUnitType(pUnit3->getLeaderUnitType());
		}
		pkMergedUnit->setInhibitSplit(true);
		pkMergedUnit->joinGroup(pMergingGroup);

		GET_PLAYER(getOwner()).setBaseMergeSelectionUnit(FFreeList::INVALID_INDEX);
		GET_PLAYER(getOwner()).setFirstMergeSelectionUnit(FFreeList::INVALID_INDEX);
		GET_PLAYER(getOwner()).setSecondMergeSelectionUnit(FFreeList::INVALID_INDEX);

		pUnit1->joinGroup(NULL);
		pUnit2->joinGroup(NULL);
		pUnit3->joinGroup(NULL);

		pUnit1->getGroup()->AI_setMissionAI(MISSIONAI_DELIBERATE_KILL, NULL, NULL);
		pUnit1->kill(true, NO_PLAYER, true);
		pUnit2->getGroup()->AI_setMissionAI(MISSIONAI_DELIBERATE_KILL, NULL, NULL);
		pUnit2->kill(true, NO_PLAYER, true);
		pUnit3->getGroup()->AI_setMissionAI(MISSIONAI_DELIBERATE_KILL, NULL, NULL);
		pUnit3->kill(true, NO_PLAYER, true);
	}
}

void CvUnit::doSplit()
{
	GET_PLAYER(getOwner()).setSplittingUnit(getID());
	if (isHuman())
	{
		CvPopupInfo* pInfo = new CvPopupInfo(BUTTONPOPUP_CONFIRM_SPLIT_UNIT);
		pInfo->setData1(getID());
		pInfo->setData2(getX());
		pInfo->setData3(getY());
		gDLL->getInterfaceIFace()->addPopup(pInfo, getOwner(), true);
	}
	else
	{
		CvUnit* pUnit0 = GET_PLAYER(getOwner()).getUnit(GET_PLAYER(getOwner()).getSplittingUnit());
		const UnitTypes eUnitType = pUnit0->getUnitType();
		CvUnit* pUnit1 = GET_PLAYER(getOwner()).initUnit(eUnitType, pUnit0->getX(), pUnit0->getY(), NO_UNITAI, NO_DIRECTION, GC.getGame().getSorenRandNum(10000, "AI Unit Birthmark"));
		CvUnit* pUnit2 = GET_PLAYER(getOwner()).initUnit(eUnitType, pUnit0->getX(), pUnit0->getY(), NO_UNITAI, NO_DIRECTION, GC.getGame().getSorenRandNum(10000, "AI Unit Birthmark"));
		CvUnit* pUnit3 = GET_PLAYER(getOwner()).initUnit(eUnitType, pUnit0->getX(), pUnit0->getY(), NO_UNITAI, NO_DIRECTION, GC.getGame().getSorenRandNum(10000, "AI Unit Birthmark"));

		PROFILE_FUNC();

		// Toffer - Remove any potential buildup promotions
		pUnit0->setFortifyTurns(0);

		int iTotalGroupOffset = -1;
		int iTotalQualityOffset = 0;

		for (int iI = GC.getNumPromotionInfos() -1; iI > -1; iI--)
		{
			const PromotionTypes ePromoX = static_cast<PromotionTypes>(iI);

			if (!pUnit0->isHasPromotion(ePromoX) || pUnit1->isHasPromotion(ePromoX))
			{
				// Toffer - If pUnit1 has it then pUnit2 and 3 should also have it at this point.
				continue;
			}

			if (GC.getPromotionInfo(ePromoX).getQualityChange() != 0)
			{
				iTotalQualityOffset += GC.getPromotionInfo((PromotionTypes)iI).getQualityChange();
			}
			else if (GC.getPromotionInfo(ePromoX).getGroupChange() != 0)
			{
				iTotalGroupOffset += GC.getPromotionInfo((PromotionTypes)iI).getGroupChange();
			}
			else if (GC.getPromotionInfo(ePromoX).isLeader())
			{
				pUnit1->setHasPromotion(ePromoX, true, true);
			}
#ifdef OUTBREAKS_AND_AFFLICTIONS
			else if (GC.getGame().isOption(GAMEOPTION_COMBAT_OUTBREAKS_AND_AFFLICTIONS))
			{
				const PromotionLineTypes ePromoLine = GC.getPromotionInfo(ePromoX).getPromotionLine();

				if (ePromoLine != NO_PROMOTIONLINE && GC.getPromotionLineInfo(ePromoLine).isAffliction())
				{
					pUnit1->afflict(ePromoLine);
					pUnit2->afflict(ePromoLine);
					pUnit3->afflict(ePromoLine);
				}
			}
#endif
			else if (GC.getPromotionInfo(ePromoX).isEquipment())
			{
				pUnit1->setHasPromotion(ePromoX, true, true);
				pUnit2->setHasPromotion(ePromoX, true, true);
				pUnit3->setHasPromotion(ePromoX, true, true);
			}
			else if (pUnit0->isPromotionFree(ePromoX))
			{
				pUnit1->setHasPromotion(ePromoX, true, true);
			}
			else
			{
				pUnit1->setHasPromotion(ePromoX, true, false);
				pUnit2->setHasPromotion(ePromoX, true, false);
				pUnit3->setHasPromotion(ePromoX, true, false);
			}
		}

		std::vector<CvUnit*> newUnits;
		newUnits.push_back(pUnit1);
		newUnits.push_back(pUnit2);
		newUnits.push_back(pUnit3);

		const bool bNormalizedGroup = CvUnit::normalizeUnitPromotions(newUnits, iTotalGroupOffset,
			bind(isGroupUpgradePromotion, pUnit1, _2),
			bind(isGroupDowngradePromotion, pUnit1, _2)
		);
		FAssertMsg(bNormalizedGroup, "Could not apply required number of group promotions on split units");

		const bool bNormalizedQuality = CvUnit::normalizeUnitPromotions(newUnits, iTotalQualityOffset,
			bind(isQualityUpgradePromotion, pUnit1, _2),
			bind(isQualityDowngradePromotion, pUnit1, _2)
		);
		FAssertMsg(bNormalizedQuality, "Could not apply required number of quality promotions on split units");

		if (pUnit0->getLeaderUnitType() != NO_UNIT)
		{
			pUnit1->setLeaderUnitType(pUnit0->getLeaderUnitType());
		}
		CvSelectionGroup* pSplittingGroup = pUnit0->getGroup();

		foreach_(CvUnit* unit, newUnits)
		{
			unit->setInhibitMerge(true);
			//Set New Experience
			unit->setExperience100(pUnit0->getExperience100());
			unit->setLevel(pUnit0->getLevel());
			unit->setGameTurnCreated(pUnit0->getGameTurnCreated());
			unit->m_eOriginalOwner = pUnit0->getOriginalOwner();
			unit->setAutoPromoting(pUnit0->isAutoPromoting());
			unit->setName(pUnit0->getNameNoDesc());
			unit->joinGroup(pSplittingGroup);
		}

		GET_PLAYER(getOwner()).setSplittingUnit(FFreeList::INVALID_INDEX);

		pUnit0->kill(true, NO_PLAYER, true);
	}
}

void CvUnit::setGGExperienceEarnedTowardsType()
{
	PROFILE_EXTRA_FUNC();
	//TB notes: This has been setup to allow the UnitCombat tag to take multiple entries but has not been setup to manage this in CvUnit.
	//It paves the way for future potential but leaves the design where it is for now where only the first definition the unit finds will be established.
	//(No examples of setting up a singular text reference on a delayed resolution was part of the motivation here)
	//But it could also lead to a deepening of this system later.
	//ONLY the Primary Category UnitCombats should define what type of general pts are generated by that unit.
	//OR Alternatively, subselections of a given Primary Category (for example: UNITCOMBAT_CIVILIAN) could give its sub-selections designations instead (like UNITCOMBAT_LAW_ENFORCEMENT and UNITCOMBAT_HEALER)
	//In this case, we'd probably want a Great Citizen to give pts to UNITCOMBAT_CIVILIAN when settled in the city BUT such a unit would come more from the GP mechanism instead.

	for (int iI = GC.getNumUnitCombatInfos() - 1; iI > -1; iI--)
	{
		const UnitCombatTypes eType = static_cast<UnitCombatTypes>(iI);

		if (isHasUnitCombat(eType))
		{
			for (int iJ = GC.getUnitCombatInfo(eType).getNumGGptsforUnitTypes() - 1; iJ > -1; iJ--)
			{
				if (GC.getUnitCombatInfo(eType).getGGptsforUnitType(iJ) > -1)
				{
					m_eGGExperienceEarnedTowardsType = static_cast<UnitTypes>(GC.getUnitCombatInfo(eType).getGGptsforUnitType(iJ));
					return;
				}
			}
		}
	}
	m_eGGExperienceEarnedTowardsType = GC.getUNIT_GREAT_GENERAL();
}

UnitTypes CvUnit::getGGExperienceEarnedTowardsType() const
{
	return m_eGGExperienceEarnedTowardsType;
}

int CvUnit::eraGroupMergeLimit() const
{
	return m_pUnitInfo->getBaseGroupRank() + GET_PLAYER(getOwner()).getCurrentEra() + 1;
}

int CvUnit::eraGroupSplitLimit() const
{
	return std::max(1, m_pUnitInfo->getBaseGroupRank() - GET_PLAYER(getOwner()).getCurrentEra() - 1);
}

DomainTypes CvUnit::getDomainCargo() const
{
	if (m_eNewDomainCargo != NO_DOMAIN)
	{
		return m_eNewDomainCargo;
	}
	return (DomainTypes)m_pUnitInfo->getDomainCargo();
}

void CvUnit::setNewDomainCargo(DomainTypes eDomain)
{
	m_eNewDomainCargo = eDomain;
}

SpecialUnitTypes CvUnit::getSpecialCargo() const
{
	if (m_eNewSpecialCargo != NO_SPECIALUNIT)
	{
		return m_eNewSpecialCargo;
	}
	return (SpecialUnitTypes)m_pUnitInfo->getSpecialCargo();
}

void CvUnit::setNewSpecialCargo(SpecialUnitTypes eSpecialUnit)
{
	m_eNewSpecialCargo = eSpecialUnit;
}

SpecialUnitTypes CvUnit::getSMNotSpecialCargo() const
{
	if (m_eNewSMNotSpecialCargo != NO_SPECIALUNIT)
	{
		return m_eNewSMNotSpecialCargo;
	}
	return (SpecialUnitTypes)m_pUnitInfo->getSMNotSpecialCargo();
}

void CvUnit::setNewSMNotSpecialCargo(SpecialUnitTypes eSpecialUnit)
{
	m_eNewSMNotSpecialCargo = eSpecialUnit;
}
//
void CvUnit::changeSMCargoSpace(int iChange)
{
	if (iChange != 0)
	{
		m_iSMCargoCapacity += iChange;
		FASSERT_NOT_NEGATIVE(m_iSMCargoCapacity);
		setInfoBarDirty(true);
	}
}

int CvUnit::SMcargoSpaceFilter() const
{
	if (getSMCargoCapacity() == 0)
	{
		return SMcargoCapacityPreCheck();
	}
	return getSMCargoCapacity();
}

int CvUnit::SMcargoCapacityPreCheck() const
{
	if (isCarrier())
	{
		return std::max(1, 100 + getCargoCapacitybyType(100));
	}
	return 0;
}

int CvUnit::getSMCargoCapacity() const
{
	return m_iSMCargoCapacity;
}

void CvUnit::setSMCargoCapacity()
{
	m_iSMCargoCapacity = applySMRank(
		SMcargoCapacityPreCheck(), getSizeMattersSpacialOffsetValue(), GC.getSIZE_MATTERS_MOST_VOLUMETRIC_MULTIPLIER()
		);
	FASSERT_NOT_NEGATIVE(m_iSMCargoCapacity);
}

int CvUnit::getExtraMaxHP() const
{
	return m_iExtraMaxHP;
}

void CvUnit::changeExtraMaxHP(int iChange)
{
	m_iExtraMaxHP += iChange;
}

int CvUnit::getMaxHP() const
{
	int iMaxHP = 0;
	if (!GC.getGame().isOption(GAMEOPTION_COMBAT_SIZE_MATTERS) || getSMHPValue() == 0)
	{
		iMaxHP = HPValueTotalPreCheck();
	}
	else
	{
		iMaxHP = getSMHPValue();
	}
	return std::max(1, iMaxHP);
}

int CvUnit::HPValueTotalPreCheck() const
{
	return std::max(1, m_pUnitInfo->getMaxHP() + getExtraMaxHP());
}

int CvUnit::getSMHPValue() const
{
	return m_iSMHPValue;
}

void CvUnit::setSMHPValue()
{
	m_iSMHPValue =
	(
		applySMRank(
			HPValueTotalPreCheck(),
			getSizeMattersOffsetValue(),
			GC.getSIZE_MATTERS_MOST_MULTIPLIER()
		)
	);
	FASSERT_NOT_NEGATIVE(m_iSMHPValue);
}

int CvUnit::getPowerValueTotal() const
{
	return GC.getGame().isOption(GAMEOPTION_COMBAT_SIZE_MATTERS) ? m_iSMPowerValue : m_pUnitInfo->getPowerValue();
}

void CvUnit::setSMPowerValue(bool bForLoad)
{
	const int oldSMPowerValue = m_iSMPowerValue;
	const int m_iSMPowerValue = applySMRank(m_pUnitInfo->getPowerValue(), getSizeMattersOffsetValue(), GC.getSIZE_MATTERS_MOST_MULTIPLIER());
	FASSERT_NOT_NEGATIVE(m_iSMPowerValue);
	if (!bForLoad)
	{
		const int iChange = m_iSMPowerValue - oldSMPowerValue;
		GET_PLAYER(getOwner()).changeUnitPower(iChange);
	}
}

int CvUnit::assetValueTotal() const
{
	return GC.getGame().isOption(GAMEOPTION_COMBAT_SIZE_MATTERS) ? m_iSMAssetValue : m_pUnitInfo->getAssetValue();
}

void CvUnit::setSMAssetValue(bool bForLoad)
{
	const int offsetValue = getSizeMattersOffsetValue();
	if (offsetValue != -15) // Special Case for size cat undefined units
	{
		const int oldSMAssetValue = m_iSMAssetValue;
		m_iSMAssetValue = applySMRank(m_pUnitInfo->getAssetValue(), offsetValue, GC.getSIZE_MATTERS_MOST_MULTIPLIER());
		if (!bForLoad)
		{
			const int iChange = m_iSMAssetValue - oldSMAssetValue;
			GET_PLAYER(getOwner()).changeAssets(iChange);
		}
		FAssertOptionRecalcMsg(GAMEOPTION_COMBAT_SIZE_MATTERS, m_iSMAssetValue >= 0, "Asset value fell below 0");
	}
}

int CvUnit::getCargoVolumeModifier() const
{
	return m_iSMCargoVolumeModifier;
}

void CvUnit::setCargoVolumeModifier(int iNewValue)
{
	m_iSMCargoVolumeModifier = iNewValue;
}

void CvUnit::changeCargoVolumeModifier(int iChange)
{
	setCargoVolumeModifier(getCargoVolumeModifier() + iChange);
}

int CvUnit::getCargoVolume() const
{
	return m_iSMCargoVolume;
}

void CvUnit::setCargoVolume(int iNewValue)
{
	m_iSMCargoVolume = iNewValue;
}

void CvUnit::changeCargoVolume(int iChange)
{
	setCargoVolume(getCargoVolume() + iChange);
}

int CvUnit::getExtraCargoVolume() const
{
	return m_iSMExtraCargoVolume;
}

void CvUnit::setExtraCargoVolume(int iNewValue)
{
	m_iSMExtraCargoVolume = iNewValue;
	if (GC.getGame().isOption(GAMEOPTION_COMBAT_SIZE_MATTERS))
	{
		setSMCargoVolume();
	}
}

void CvUnit::changeExtraCargoVolume(int iChange)
{
	setExtraCargoVolume(getExtraCargoVolume() + iChange);
}

int CvUnit::getSMCargoVolumeBase() const
{
	return std::max(0, 100 + getExtraCargoVolume());
}

int CvUnit::SMCargoVolume() const
{
	if (!GC.getGame().isOption(GAMEOPTION_COMBAT_SIZE_MATTERS))
		return 0;

	return std::max(1, getCargoVolume() == 0 ? getSMCargoVolumeBase() : getCargoVolume()) + isCarrier() * SMgetCargo();
}

void CvUnit::setSMCargoVolume()
{
	m_iSMCargoVolume =
	(
		std::max(
			1,
			applySMRank(
				getSMCargoVolumeBase(),
				getSizeMattersSpacialOffsetValue(),
				GC.getSIZE_MATTERS_MOST_VOLUMETRIC_MULTIPLIER()
			)
		)
	);
}

int CvUnit::getSizeMattersOffsetValue() const
{
	return qualityRank() + groupRank() + sizeRank() - 15;
}

int CvUnit::getSizeMattersSpacialOffsetValue() const
{
	return groupRank() + sizeRank() - 10;
}

int CvUnit::getCargoCapacitybyType(int iValue) const
{
	const SpecialUnitTypes eSpecialUnitDefined = getSpecialCargo();
	const SpecialUnitTypes eSpecialUnitDefinedNot = getSMNotSpecialCargo();

	int rankChange = 0;
	if (eSpecialUnitDefined == GC.getSPECIALUNIT_PEOPLE()
	|| eSpecialUnitDefined == GC.getSPECIALUNIT_MISSILE())
	{
		rankChange = -3;
	}
	else if (eSpecialUnitDefined == GC.getSPECIALUNIT_FIGHTER()
		|| eSpecialUnitDefined == GC.getSPECIALUNIT_SEAPLANE()
		|| eSpecialUnitDefinedNot == GC.getSPECIALUNIT_MISSILE())
	{
		rankChange = -1;
	}
	return applySMRank(iValue, rankChange, GC.getSIZE_MATTERS_MOST_VOLUMETRIC_MULTIPLIER());
}

bool CvUnit::isCarrier() const
{
	return getSpecialCargo() != NO_SPECIALUNIT || getDomainCargo() != NO_DOMAIN;
}

bool CvUnit::isUnitAtBaseGroup() const
{
	return m_pUnitInfo->getBaseGroupRank() == groupRank();
}

bool CvUnit::isUnitAboveBaseGroup() const
{
	return groupRank() > m_pUnitInfo->getBaseGroupRank();
}

bool CvUnit::isUnitBelowBaseGroup() const
{
	return groupRank() < m_pUnitInfo->getBaseGroupRank();
}

//Model of how to use Size Matters Most Multiplicative plug in.
//optional - if there is a flat +/- modifier it plugs in here in the Extra functions
//Confusingly, this is often already in place and is sometimes not well named but is convenient to keep as was.
//Often needs to be moved next to those functions below.
int CvUnit::getExtraBombardRate() const
{
	if (!isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander)
		{
			return m_iExtraBombardRate + pCommander->m_iExtraBombardRate;
		}
	}
	if (!isCommodore())
    	{
    		const CvUnit* pCommodore = getCommodore();
    		if (pCommodore)
    		{
    			return m_iExtraBombardRate + pCommodore->m_iExtraBombardRate;
    		}
    	}
	return m_iExtraBombardRate;
}

void CvUnit::changeExtraBombardRate(int iChange)
{
	m_iExtraBombardRate += iChange;
	if (GC.getGame().isOption(GAMEOPTION_COMBAT_SIZE_MATTERS))
	{
		setSMBombardRate();
	}
	FASSERT_NOT_NEGATIVE(m_iExtraBombardRate);
}

// The call that plugs into the rest of the code (final value) - this can be plugged into the existing final - or even be renamed to the existing final (though experience has shown me this causes me tremendous confusion!)
int CvUnit::getBombardRate() const
{
	if (GC.getGame().isOption(GAMEOPTION_COMBAT_SIZE_MATTERS))
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander)
		{
			return m_iSMBombardRate + pCommander->m_iExtraBombardRate;
		}

		const CvUnit* pCommodore = getCommodore();
        if (pCommodore)
        {
        	return m_iSMBombardRate + pCommodore->m_iExtraBombardRate;
        }
		return m_iSMBombardRate;
	}
	return std::max(0, m_pUnitInfo->getBombardRate() + getExtraBombardRate());
}


////The active call to establish the current proper adjusted value.
////This is the core multiplicative method being utilized.
void CvUnit::setSMBombardRate()
{
	m_iSMBombardRate = applySMRank(std::max(0, m_pUnitInfo->getBombardRate() + m_iExtraBombardRate), getSizeMattersOffsetValue(), GC.getSIZE_MATTERS_MOST_MULTIPLIER());

	// optional but most of these should be above or equal to 0.
	FASSERT_NOT_NEGATIVE(m_iSMBombardRate);
}


int CvUnit::getAirBombCurrRate() const
{
	return getAirBombBaseRate() * getHP() / getMaxHP();
}

int CvUnit::getAirBombBaseRate() const//The call that plugs into the rest of the code (final value) - this can be plugged into the existing final - or even be renamed to the existing final (though experience has shown me this causes me tremendous confusion!)
{
	if (!GC.getGame().isOption(GAMEOPTION_COMBAT_SIZE_MATTERS)
	//if the current final result of the SMM multiplicative mechanism is nothing but an empty shell
	//then this is the first time it's being run so we take from the base value to start.
	//Either that or the base is 0 anyhow.
	|| getSMAirBombBaseRate() == 0)
	{
		return getSMAirBombBaseRateTotalBase();
	}
	return getSMAirBombBaseRate();
}

int CvUnit::getSMAirBombBaseRateTotalBase() const//The total before the Size Matters multiplicative method adjusts for the final value.
{
	return m_pUnitInfo->getBombRate();//Unit base.
}

int CvUnit::getSMAirBombBaseRate() const//The final result of the Multiplicative adjustment
{
	return m_iSMAirBombBaseRate;//A separate (likely new) data storage to track the multiplicated value.
}

//The active call to establish the current proper adjusted value.
//This is the core multiplicative method being utilized.
void CvUnit::setSMAirBombBaseRate()
{
	m_iSMAirBombBaseRate =
	(
		applySMRank
		(
			getSMAirBombBaseRateTotalBase(),
			getSizeMattersOffsetValue(),
			GC.getSIZE_MATTERS_MOST_MULTIPLIER()
		)
	);
	//optional but most of these should be above or equal to 0.
	FASSERT_NOT_NEGATIVE(m_iSMAirBombBaseRate);
	m_iSMAirBombBaseRate = std::max(0, m_iSMAirBombBaseRate);
}

int CvUnit::workRate(bool bMax) const
{
	PROFILE_EXTRA_FUNC();
	if (!bMax && !canMove())
	{
		return 0;
	}
	int iRate = baseWorkRate();

	if (iRate == 0)
	{
		return 0;
	}
	int iWorkMod = getWorkModifier() + GET_PLAYER(getOwner()).getWorkerSpeedModifier();

	const CvPlot* pPlot = plot();
	for (int iI = 0; iI < GC.getNumFeatureInfos(); iI++)
	{
		if (pPlot->getFeatureType() == (FeatureTypes)iI)
		{
			iWorkMod += featureWorkPercent((FeatureTypes)iI);
		}
	}
	iWorkMod += terrainWorkPercent(pPlot->getTerrainType());
	{
		const BuildTypes eBuild = getBuildType();

		if (eBuild != NO_BUILD)
		{
			iWorkMod += buildWorkPercent(eBuild);
		}
	}

	if (pPlot->isHills())
	{
		iWorkMod += hillsWorkModifier();
	}
	else if (pPlot->isAsPeak())
	{
		iWorkMod += peaksWorkModifier();
	}

	if (GET_PLAYER(getOwner()).isNormalAI())
	{
		iWorkMod += (
			GC.getHandicapInfo(GC.getGame().getHandicapType()).getAIWorkRateModifier()
			-
			GC.getHandicapInfo(GC.getGame().getHandicapType()).getAIPerEraModifier() * GET_PLAYER(getOwner()).getCurrentEra()
		);
	}
	return getModifiedIntValue(iRate, iWorkMod);
}

// The call that plugs into the rest of the code (final value)
// This can be plugged into the existing final, or even be renamed to the existing final (though experience has shown me this causes me tremendous confusion!)
int CvUnit::baseWorkRate() const
{
	if (!GC.getGame().isOption(GAMEOPTION_COMBAT_SIZE_MATTERS)
	//if the current final result of the SMM multiplicative mechanism is nothing but an empty shell
	//then this is the first time it's being run so we take from the base value to start.
	//Either that or the base is 0 anyhow.
	|| getSMBaseWorkRate() == 0)
	{
		return std::max(0, baseWorkRatePreCheck());
	}
	return std::max(0, getSMBaseWorkRate());
}

int CvUnit::baseWorkRatePreCheck() const//The total before the Size Matters multiplicative method adjusts for the final value.
{
	return std::max(0, m_pUnitInfo->getWorkRate());
}

int CvUnit::getSMBaseWorkRate() const//The final result of the Multiplicative adjustment
{
	return m_iSMBaseWorkRate;//A separate (likely new) data storage to track the multiplicated value.
}

//The active call to establish the current proper adjusted value.
//This is the core multiplicative method being utilized.
void CvUnit::setSMBaseWorkRate()
{
	m_iSMBaseWorkRate =
	(
		applySMRank
		(
			baseWorkRatePreCheck(),
			getSizeMattersSpacialOffsetValue(),
			GC.getSIZE_MATTERS_MOST_VOLUMETRIC_MULTIPLIER()
		)
	);
	//optional but most of these should be above or equal to 0.
	FASSERT_NOT_NEGATIVE(m_iSMBaseWorkRate);
	m_iSMBaseWorkRate = std::max(0, m_iSMBaseWorkRate);
}

int CvUnit::getRevoltProtection() const
{
	return m_pUnitInfo->getCultureGarrisonValue() + m_iRevoltProtection;
}

void CvUnit::changeRevoltProtection(int iChange)
{
	if (iChange != 0)
	{
		m_iRevoltProtection += iChange;
		/*
		if (GC.getGame().isOption(GAMEOPTION_COMBAT_SIZE_MATTERS))
		{
			setSMRevoltProtection();
		}
		*/
		setInfoBarDirty(true);
	}
}

//need to change references to getRevoltProtection to the following:
int CvUnit::revoltProtectionTotal() const
{
	return getRevoltProtection();
}
/* flabbert - disabling size matters revolt protection, it seems to give some weird results
	// The call that plugs into the rest of the code (final value).
	// This can be plugged into the existing final, or even be renamed to the existing final (though experience has shown me this causes me tremendous confusion!).

	if (!GC.getGame().isOption(GAMEOPTION_COMBAT_SIZE_MATTERS)
	// if the current final result of the SMM multiplicative mechanism is nothing but an empty shell
	// then this is the first time it's being run so we take from the base value to start.
	// Either that or the base is 0 anyhow.
	|| getSMRevoltProtection() == 0)
	{
		return getRevoltProtection();
	}
	 return std::max(0, getSMRevoltProtection());
}

int CvUnit::getSMRevoltProtection() const//The final result of the Multiplicative adjustment
{
	return m_iSMRevoltProtection;//A separate (likely new) data storage to track the multiplicated value.
}

//The active call to establish the current proper adjusted value.
//This is the core multiplicative method being utilized.
void CvUnit::setSMRevoltProtection()
{
	m_iSMRevoltProtection =
	(
		applySMRank
		(
			getRevoltProtection(),
			getSizeMattersOffsetValue(),
			GC.getSIZE_MATTERS_MOST_MULTIPLIER()
		)
	);
	// optional but most of these should be above or equal to 0.
	FASSERT_NOT_NEGATIVE(m_iSMRevoltProtection);
	m_iSMRevoltProtection = std::max(0, m_iSMRevoltProtection);
}
*/

bool CvUnit::canPerformActionSM() const
{
	return GC.getGame().isOption(GAMEOPTION_COMBAT_SIZE_MATTERS) ? isUnitAtBaseGroup() : true;
}

void CvUnit::setSMValues(bool bForLoad)
{
	CvUnit* pTransportUnit = NULL;

	if (!bForLoad && isCargo())
	{
		pTransportUnit = getTransportUnit();
		setTransportUnit(NULL);
	}
	setSMStrength();
	setSMHPValue();
	setSMAssetValue(bForLoad);
	setSMPowerValue(bForLoad);
	setSMCargoCapacity();
	setSMCargoVolume();
	setSMBombardRate();
	setSMAirBombBaseRate();
	setSMBaseWorkRate();
	//setSMRevoltProtection();
	//many missions may require the unit be at base unit defined group size.
		//construct or force a building - code adjusted.
		//
	//property modifiers - huge issues here since they don't compile and become a part of the unit data
		//perhaps if we changed the way that worked they could be modified at the actual unit level.
		//for now property modifying unit types as defined by their general CC categories will have to remain unmergable/unsplittable.
	if (!bForLoad && pTransportUnit != NULL)
	{
		setTransportUnit(pTransportUnit);
	}
}

int CvUnit::rBombardDamage() const
{
	return std::max(0, m_pUnitInfo->getRBombardDamage() + getBaseRBombardDamage() + getExtraRBombardDamage());
}

int CvUnit::getExtraRBombardDamage() const
{
	if (!isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander)
		{
			return m_iExtraRBombardDamage + pCommander->m_iExtraRBombardDamage;
		}
	}
	if (!isCommodore())
    {
    	const CvUnit* pCommodore = getCommodore();
    	if (pCommodore)
    	{
    		return m_iExtraRBombardDamage + pCommodore->m_iExtraRBombardDamage;
    	}
    }
	return m_iExtraRBombardDamage;
}

void CvUnit::changeExtraRBombardDamage(int iChange)
{
	m_iExtraRBombardDamage += iChange;
	FASSERT_NOT_NEGATIVE(m_iExtraRBombardDamage);
}

int CvUnit::getBaseRBombardDamage() const
{
	return m_iBaseRBombardDamage;
}

void CvUnit::changeBaseRBombardDamage(int iChange, bool bAdding, UnitCombatTypes eUnitCombat)
{
	PROFILE_EXTRA_FUNC();
	if (bAdding && iChange > m_iBaseRBombardDamage)
	{
		m_iBaseRBombardDamage = iChange;
	}
	int iBestValue = 0;
	if (!bAdding && iChange == m_iBaseRBombardDamage)
	{
		for (int iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
		{
			if ((UnitCombatTypes)iI != eUnitCombat && isHasUnitCombat((UnitCombatTypes)iI))
			{
				const int iValue = GC.getUnitCombatInfo((UnitCombatTypes)iI).getRBombardDamageBase();

				if (iValue > iBestValue)
				{
					iBestValue = iValue;
				}
			}
		}
		m_iBaseRBombardDamage = iBestValue;
	}
	FASSERT_NOT_NEGATIVE(getBaseRBombardDamage());
}

int CvUnit::rBombardDamageLimit() const
{
	return
	(
		std::max
		(
			0,
			(
				m_pUnitInfo->getRBombardDamageLimit()
				+ getBaseRBombardDamageLimit()
				+ getExtraRBombardDamageLimit()
			)
			* GC.getMAX_HIT_POINTS() / 100
		)
	);
}

int CvUnit::getExtraRBombardDamageLimit() const
{
	if (!isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander)
		{
			return m_iExtraRBombardDamageLimit + pCommander->m_iExtraRBombardDamageLimit;
		}
	}
	if (!isCommodore())
    	{
    		const CvUnit* pCommodore = getCommodore();
    		if (pCommodore)
    		{
    			return m_iExtraRBombardDamageLimit + pCommodore->m_iExtraRBombardDamageLimit;
    		}
    	}
	return m_iExtraRBombardDamageLimit;
}

void CvUnit::changeExtraRBombardDamageLimit(int iChange)
{
	m_iExtraRBombardDamageLimit += iChange;
	FASSERT_NOT_NEGATIVE(m_iExtraRBombardDamageLimit);
}

int CvUnit::getBaseRBombardDamageLimit() const
{
	return m_iBaseRBombardDamageLimit;
}

void CvUnit::changeBaseRBombardDamageLimit(int iChange, bool bAdding, UnitCombatTypes eUnitCombat)
{
	PROFILE_EXTRA_FUNC();
	if (bAdding && iChange > m_iBaseRBombardDamageLimit)
	{
		m_iBaseRBombardDamageLimit = iChange;
	}
	int iBestValue = 0;
	if (!bAdding && iChange == m_iBaseRBombardDamageLimit)
	{
		for (int iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
		{
			if ((UnitCombatTypes)iI != eUnitCombat && isHasUnitCombat((UnitCombatTypes)iI))
			{
				const int iValue = GC.getUnitCombatInfo((UnitCombatTypes)iI).getRBombardDamageLimitBase();

				if (iValue > iBestValue)
				{
					iBestValue = iValue;
				}
			}
		}
		m_iBaseRBombardDamageLimit = iBestValue;
	}
	FASSERT_NOT_NEGATIVE(getBaseRBombardDamageLimit());
}

int CvUnit::rBombardDamageMaxUnits() const
{
	return
	(
		std::max
		(
			0,
			m_pUnitInfo->getRBombardDamageMaxUnits()
			+ getBaseRBombardDamageMaxUnits()
			+ getExtraRBombardDamageMaxUnits()
		)
	);
}

int CvUnit::getExtraRBombardDamageMaxUnits() const
{
	if (!isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander)
		{
			return m_iExtraRBombardDamageMaxUnits + pCommander->m_iExtraRBombardDamageMaxUnits;
		}
	}
	if (!isCommodore())
    	{
    		const CvUnit* pCommodore = getCommodore();
    		if (pCommodore)
    		{
    			return m_iExtraRBombardDamageMaxUnits + pCommodore->m_iExtraRBombardDamageMaxUnits;
    		}
    	}
	return m_iExtraRBombardDamageMaxUnits;
}

void CvUnit::changeExtraRBombardDamageMaxUnits(int iChange)
{
	m_iExtraRBombardDamageMaxUnits += iChange;
	FASSERT_NOT_NEGATIVE(m_iExtraRBombardDamageMaxUnits);
}

int CvUnit::getBaseRBombardDamageMaxUnits() const
{
	return m_iBaseRBombardDamageMaxUnits;
}

void CvUnit::changeBaseRBombardDamageMaxUnits(int iChange, bool bAdding, UnitCombatTypes eUnitCombat)
{
	PROFILE_EXTRA_FUNC();
	if (bAdding && iChange > m_iBaseRBombardDamageMaxUnits)
	{
		m_iBaseRBombardDamageMaxUnits = iChange;
	}
	int iBestValue = 0;
	if (!bAdding && iChange == m_iBaseRBombardDamageMaxUnits)
	{
		for (int iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
		{
			if ((UnitCombatTypes)iI != eUnitCombat && isHasUnitCombat((UnitCombatTypes)iI))
			{
				const int iValue = GC.getUnitCombatInfo((UnitCombatTypes)iI).getRBombardDamageMaxUnitsBase();

				if (iValue > iBestValue)
				{
					iBestValue = iValue;
				}
			}
		}
		m_iBaseRBombardDamageMaxUnits = iBestValue;
	}
	FASSERT_NOT_NEGATIVE(getBaseRBombardDamageMaxUnits());
}

int CvUnit::getDCMBombRange() const
{
	return std::max(0, m_pUnitInfo->getDCMBombRange() + getBaseDCMBombRange() + getExtraDCMBombRange());
}

int CvUnit::getExtraDCMBombRange() const
{
	if (!isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander)
		{
			return m_iExtraDCMBombRange + pCommander->m_iExtraDCMBombRange;
		}
	}
	if (!isCommodore())
    	{
    		const CvUnit* pCommodore = getCommodore();
    		if (pCommodore)
    		{
    			return m_iExtraDCMBombRange + pCommodore->m_iExtraDCMBombRange;
    		}
    	}
	return m_iExtraDCMBombRange;
}

void CvUnit::changeExtraDCMBombRange(int iChange)
{
	m_iExtraDCMBombRange += iChange;
}

int CvUnit::getBaseDCMBombRange() const
{
	return m_iBaseDCMBombRange;
}

void CvUnit::changeBaseDCMBombRange(int iChange, bool bAdding, UnitCombatTypes eUnitCombat)
{
	PROFILE_EXTRA_FUNC();
	if (bAdding && iChange > m_iBaseDCMBombRange)
	{
		m_iBaseDCMBombRange = iChange;
	}
	int iBestValue = 0;
	if (!bAdding && iChange == m_iBaseDCMBombRange)
	{
		for (int iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
		{
			if ((UnitCombatTypes)iI != eUnitCombat && isHasUnitCombat((UnitCombatTypes)iI))
			{
				const int iValue = GC.getUnitCombatInfo((UnitCombatTypes)iI).getDCMBombRangeBase();

				if (iValue > iBestValue)
				{
					iBestValue = iValue;
				}
			}
		}
		m_iBaseDCMBombRange = iBestValue;
	}
	FASSERT_NOT_NEGATIVE(getBaseDCMBombRange());
}

int CvUnit::getDCMBombAccuracy() const
{
	return std::max(0, m_pUnitInfo->getDCMBombAccuracy() + getBaseDCMBombAccuracy() + getExtraDCMBombAccuracy());
}

int CvUnit::getExtraDCMBombAccuracy() const
{
	if (!isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander)
		{
			return m_iExtraDCMBombAccuracy + pCommander->m_iExtraDCMBombAccuracy;
		}
	}
	if (!isCommodore())
    	{
    		const CvUnit* pCommodore = getCommodore();
    		if (pCommodore)
    		{
    			return m_iExtraDCMBombAccuracy + pCommodore->m_iExtraDCMBombAccuracy;
    		}
    	}
	return m_iExtraDCMBombAccuracy;
}

void CvUnit::changeExtraDCMBombAccuracy(int iChange)
{
	m_iExtraDCMBombAccuracy += iChange;
}

int CvUnit::getBaseDCMBombAccuracy() const
{
	return m_iBaseDCMBombAccuracy;
}

void CvUnit::changeBaseDCMBombAccuracy(int iChange, bool bAdding, UnitCombatTypes eUnitCombat)
{
	PROFILE_EXTRA_FUNC();
	if (bAdding && iChange > m_iBaseDCMBombAccuracy)
	{
		m_iBaseDCMBombAccuracy = iChange;
	}
	int iBestValue = 0;
	if (!bAdding && iChange == m_iBaseDCMBombAccuracy)
	{
		for (int iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
		{
			if ((UnitCombatTypes)iI != eUnitCombat && isHasUnitCombat((UnitCombatTypes)iI))
			{
				const int iValue = GC.getUnitCombatInfo((UnitCombatTypes)iI).getDCMBombAccuracyBase();

				if (iValue > iBestValue)
				{
					iBestValue = iValue;
				}
			}
		}
		m_iBaseDCMBombAccuracy = iBestValue;
	}
	FASSERT_NOT_NEGATIVE(getBaseDCMBombAccuracy());
}

bool CvUnit::isRBombardDirect() const
{
	return m_iBombardDirectCount > 0;
}

void CvUnit::changeBombardDirectCount(int iChange)
{
	m_iBombardDirectCount += iChange;
}


int CvUnit::getNoSelfHealCount() const
{
	return m_iNoSelfHealCount;
}

bool CvUnit::hasNoSelfHeal() const
{
	return getNoSelfHealCount() + m_pUnitInfo->isNoSelfHeal() > 0;
}

void CvUnit::changeNoSelfHealCount(int iChange)
{
	m_iNoSelfHealCount += iChange;
	FASSERT_NOT_NEGATIVE(getNoSelfHealCount());
}

int CvUnit::getSelfHealModifierTotal() const
{
	return m_pUnitInfo->getSelfHealModifier() + m_iExtraSelfHealModifier;
}

void CvUnit::changeExtraSelfHealModifier(int iChange)
{
	m_iExtraSelfHealModifier += iChange;
}

int CvUnit::getNumHealSupportTotal() const
{
	return std::max(0, m_pUnitInfo->getNumHealSupport() + m_iExtraNumHealSupport);
}

void CvUnit::changeExtraNumHealSupport(int iChange)
{
	m_iExtraNumHealSupport += iChange;
}

int CvUnit::getHealSupportUsedTotal() const
{
	return m_iHealSupportUsed;
}

void CvUnit::changeHealSupportUsed(int iChange)
{
	m_iHealSupportUsed += iChange;
}

void CvUnit::setHealSupportUsed(int iChange)
{
	m_iHealSupportUsed = iChange;
}

int CvUnit::getHealSupportRemaining() const
{
	return std::max(0, getNumHealSupportTotal() - getHealSupportUsedTotal());
}

bool CvUnit::hasHealSupportRemaining() const
{
	return getHealSupportRemaining() > 0;
}

MissionTypes CvUnit::getSleepType() const
{
	return m_eSleepType;
}

void CvUnit::setSleepType(MissionTypes eSleepType)
{
	m_eSleepType = eSleepType;
}

void CvUnit::establishBuildups()
{
	PROFILE_EXTRA_FUNC();
	m_bHasBuildUp = false;

	for (std::map<PromotionLineTypes, PromotionLineKeyedInfo>::iterator it = m_promotionLineKeyedInfo.begin(), end = m_promotionLineKeyedInfo.end(); it != end; ++it)
	{
		it->second.m_bValidBuildUp = false;
	}

	for (int iI = GC.getNumPromotionLineInfos() - 1; iI > -1; iI--)
	{
		const PromotionLineTypes ePromotionLine = static_cast<PromotionLineTypes>(iI);
		const CvPromotionLineInfo& kPromotionLine = GC.getPromotionLineInfo(ePromotionLine);
		if (kPromotionLine.isBuildUp())
		{
			for (int iJ = 0; iJ < kPromotionLine.getNumPromotions(); iJ++)
			{
				const PromotionTypes ePromotion = (PromotionTypes)kPromotionLine.getPromotion(iJ);
				if (GC.getPromotionInfo(ePromotion).getLinePriority() == 1
				&& canAcquirePromotion(ePromotion, PromotionRequirements::IgnoreHas | PromotionRequirements::ForFree | PromotionRequirements::ForBuildUp))
				{
					PromotionLineKeyedInfo* info = findOrCreatePromotionLineKeyedInfo(ePromotionLine);

					info->m_bValidBuildUp = true;
					m_bHasBuildUp = true;
					break;
				}
			}
		}
	}
}

PromotionLineTypes CvUnit::getBuildUpType() const
{
	return m_eCurrentBuildUpType;
}

void CvUnit::setBuildUpType(PromotionLineTypes ePromotionLine, MissionTypes eSleepType)
{
	PROFILE_EXTRA_FUNC();
	if (isHuman())
	{
		// Buildup chosen
		if (ePromotionLine != NO_PROMOTIONLINE)
		{
			if (m_eCurrentBuildUpType != ePromotionLine)
			{
				if (m_iBuildUpTurns > 0)
				{
					clearBuildups();
				}
				m_bIsBuildUp = true;
				m_eCurrentBuildUpType = ePromotionLine;
			}
			GC.getGame().updateSelectionListInternal();
			return;
		}
		// Choose buildup popup
		if (eSleepType != MISSION_AUTO_BUILDUP && eSleepType != MISSION_HEAL_BUILDUP)
		{
			CvPopupInfo* pInfo = new CvPopupInfo(BUTTONPOPUP_CHOOSE_BUILDUP);
			pInfo->setData1(getID());
			gDLL->getInterfaceIFace()->addPopup(pInfo, getOwner());
			return;
		}
	}

	// AI buildup evaluation
	const bool bCanHeal = getHealUnitCombatCount() > 0 || getSameTileHeal() > 0 || getAdjacentTileHeal() > 0;
	const bool bMustHeal = getDamage() > 0;
	int iBestValue = 0;

	if (isHuman() && eSleepType == MISSION_HEAL_BUILDUP && (bMustHeal || bCanHeal))
	{
		PromotionLineTypes eAssignPromotionLine = NO_PROMOTIONLINE;

		for (std::map<PromotionLineTypes, PromotionLineKeyedInfo>::const_iterator it = m_promotionLineKeyedInfo.begin(), end = m_promotionLineKeyedInfo.end(); it != end; ++it)
		{
			if (it->second.m_bValidBuildUp)
			{
				const PromotionLineTypes ePotentialPromotionLine = it->first;
				const CvPromotionLineInfo& kPotentialPromotionLine = GC.getPromotionLineInfo(ePotentialPromotionLine);

				for (int iI = 0; iI < kPotentialPromotionLine.getNumPromotions(); iI++)
				{
					const PromotionTypes ePromotion = (PromotionTypes)kPotentialPromotionLine.getPromotion(iI);
					const CvPromotionInfo& kPromotion = GC.getPromotionInfo(ePromotion);

					if (kPromotion.getLinePriority() == 1
					&& canAcquirePromotion(ePromotion, PromotionRequirements::IgnoreHas | PromotionRequirements::ForFree | PromotionRequirements::ForBuildUp))
					{
						int iValue = 0;
						if (bCanHeal)
						{
							for (int iJ = 0; iJ < kPromotion.getNumHealUnitCombatChangeTypes(); iJ++)
							{
								iValue += kPromotion.getHealUnitCombatChangeType(iJ).iHeal * getHealUnitCombatTypeTotal((UnitCombatTypes)kPromotion.getHealUnitCombatChangeType(iJ).eUnitCombat);
								iValue += kPromotion.getHealUnitCombatChangeType(iJ).iAdjacentHeal * getHealUnitCombatTypeAdjacentTotal((UnitCombatTypes)kPromotion.getHealUnitCombatChangeType(iJ).eUnitCombat);
							}
							iValue += kPromotion.getSameTileHealChange() * 100;
							iValue += kPromotion.getAdjacentTileHealChange() * 10;
						}
						if (bMustHeal)
						{
							iValue += kPromotion.getSelfHealModifier() * 100;
						}
						if (iValue > iBestValue)
						{
							iBestValue = iValue;
							eAssignPromotionLine = ePotentialPromotionLine;
						}
					}
				}
			}
		}
		if (eAssignPromotionLine == NO_PROMOTIONLINE && isBuildUpable())
		{
			FErrorMsg("This shouldn't happen");
			// Try again
			establishBuildups();

			if (isBuildUpable())
			{
				setBuildUpType(NO_PROMOTIONLINE, MISSION_AUTO_BUILDUP);
			}
			return;
		}

		if (eAssignPromotionLine != m_eCurrentBuildUpType)
		{
			if (m_iBuildUpTurns > 0)
			{
				clearBuildups();
			}
			m_eCurrentBuildUpType = eAssignPromotionLine;

			if (m_eCurrentBuildUpType != NO_PROMOTIONLINE)
			{
				m_bIsBuildUp = true;
			}
		}
		return;
	}
	// Here is were we can implement some AI selection methodology.
	PromotionLineTypes eAssignPromotionLine = NO_PROMOTIONLINE;

	for (std::map<PromotionLineTypes, PromotionLineKeyedInfo>::const_iterator it = m_promotionLineKeyedInfo.begin(), end = m_promotionLineKeyedInfo.end(); it != end; ++it)
	{
		if (it->second.m_bValidBuildUp)
		{
			const PromotionLineTypes ePotentialPromotionLine = it->first;
			const CvPromotionLineInfo& kPotentialPromotionLine = GC.getPromotionLineInfo(ePotentialPromotionLine);
			for (int iI = 0; iI < kPotentialPromotionLine.getNumPromotions(); iI++)
			{
				const PromotionTypes ePromotion = (PromotionTypes)kPotentialPromotionLine.getPromotion(iI);
				if (GC.getPromotionInfo(ePromotion).getLinePriority() == 1
				&& canAcquirePromotion(ePromotion, PromotionRequirements::IgnoreHas | PromotionRequirements::ForFree | PromotionRequirements::ForBuildUp))
				{
					const int iValue = std::max(1, GET_PLAYER(getOwner()).AI_promotionValue(ePromotion, getUnitType(), this, AI_getUnitAIType(), true));

					if (iValue > iBestValue)
					{
						if (gUnitLogLevel > 3) //TO DO
						{
								const CvWString strUnitAIType = GC.getUnitAIInfo(AI_getUnitAIType()).getType();
								CvWString szDesc = GC.getPromotionInfo(ePromotion).getDescription();
								//const CvWString strCriteria = criteria.GetDescription();								
								logAiEvaluations(4,"    %S find better Eval (%d > %d) to buildup %S with %S, unit AI %S", GET_PLAYER(getOwner()).getCivilizationDescription(0), iValue, iBestValue, getName(0).GetCString(), szDesc.GetCString(), strUnitAIType.GetCString());
						}
						iBestValue = iValue;
						eAssignPromotionLine = ePotentialPromotionLine;


					}
					else
					{
						if (gUnitLogLevel > 3) //TO DO
						{
							const CvWString strUnitAIType = GC.getUnitAIInfo(AI_getUnitAIType()).getType();
							CvWString szDesc = GC.getPromotionInfo(ePromotion).getDescription();
							//const CvWString strCriteria = criteria.GetDescription();

							logAiEvaluations(2, "    %S will not choose that prom (%d <= %d) to buildup %S with %S, unit AI %S", GET_PLAYER(getOwner()).getCivilizationDescription(0), iValue, iBestValue, getName(0).GetCString(), szDesc.GetCString(), strUnitAIType.GetCString());
						}
					}
				}
			}
		}
	}
	if (eAssignPromotionLine == NO_PROMOTIONLINE && isBuildUpable())
	{
		FErrorMsg("This shouldn't happen");
		// Try again
		establishBuildups();

		if (isBuildUpable())
		{
			setBuildUpType(NO_PROMOTIONLINE, MISSION_AUTO_BUILDUP);
		}
		return;
	}

	if (eAssignPromotionLine != m_eCurrentBuildUpType)
	{
		if (m_iBuildUpTurns > 0)
		{
			clearBuildups();
		}
		m_eCurrentBuildUpType = eAssignPromotionLine;

		if (m_eCurrentBuildUpType != NO_PROMOTIONLINE)
		{
			m_bIsBuildUp = true;
		}
	}
}

void CvUnit::clearBuildups()
{
	PROFILE_EXTRA_FUNC();
	for (int iJ = 0; iJ < GC.getNumPromotionLineInfos(); iJ++)
	{
		if (GC.getPromotionLineInfo((PromotionLineTypes)iJ).isBuildUp())
		{
			const PromotionLineTypes ePromotionLine = ((PromotionLineTypes)iJ);
			for (int iI = 0; iI < GC.getPromotionLineInfo(ePromotionLine).getNumPromotions(); iI++)
			{
				const PromotionTypes ePromotion = (PromotionTypes)GC.getPromotionLineInfo(ePromotionLine).getPromotion(iI);
				if (isHasPromotion(ePromotion))
				{
					setHasPromotion(ePromotion, false, true, false, false);
				}
			}
		}
	}
	m_iBuildUpTurns = 0;
	m_eCurrentBuildUpType = NO_PROMOTIONLINE;
	setSleepType(NO_MISSION);
	m_bIsBuildUp = false;
	setInfoBarDirty(true);
}

void CvUnit::incrementBuildUp()
{
	PROFILE_EXTRA_FUNC();
	if (getBuildUpType() == NO_PROMOTIONLINE)
	{
		FErrorMsg("Units build up status corrupted")
		clearBuildups();
		getGroup()->setActivityType(ACTIVITY_AWAKE);
		return;
	}
	m_iBuildUpTurns++;

	const PromotionLineTypes ePromotionLine = getBuildUpType();

	// AI units will reconsider its buildup on regular intervals.
	if (!isHuman() && 0 == (m_iBuildUpTurns % 11))
	{
		for (int iI = 0; iI < GC.getPromotionLineInfo(ePromotionLine).getNumPromotions(); iI++)
		{
			const PromotionTypes ePromotion = (PromotionTypes)GC.getPromotionLineInfo(ePromotionLine).getPromotion(iI);

			if (GC.getPromotionInfo(ePromotion).getLinePriority() == 1
			&& GET_PLAYER(getOwner()).AI_promotionValue(ePromotion, getUnitType(), this, AI_getUnitAIType(), true) < 10)
			{
				clearBuildups();
				getGroup()->setActivityType(ACTIVITY_AWAKE);
				return;
			}
		}
	}

	for (int iI = 0; iI < GC.getPromotionLineInfo(ePromotionLine).getNumPromotions(); iI++)
	{
		const PromotionTypes ePromotion = (PromotionTypes)GC.getPromotionLineInfo(ePromotionLine).getPromotion(iI);

		if (!isHasPromotion(ePromotion)
		&& GC.getPromotionInfo(ePromotion).getLinePriority() <= m_iBuildUpTurns
		&& canAcquirePromotion(ePromotion, PromotionRequirements::ForFree | PromotionRequirements::ForBuildUp))
		{
			setHasPromotion(ePromotion, true, true, false, false);
		}
	}
}

bool CvUnit::isInhibitMerge() const
{
	return m_bInhibitMerge;
}

void CvUnit::setInhibitMerge(bool bNewValue)
{
	m_bInhibitMerge = bNewValue;
}

bool CvUnit::isInhibitSplit() const
{
	return m_bInhibitSplit;
}

void CvUnit::setInhibitSplit(bool bNewValue)
{
	m_bInhibitSplit = bNewValue;
}

bool CvUnit::isBuildUp() const
{
	return m_bIsBuildUp;
}

void CvUnit::setSpecialUnit(bool bChange, SpecialUnitTypes eSpecialUnit)
{
	m_eSpecialUnit = bChange ? eSpecialUnit : (SpecialUnitTypes)m_pUnitInfo->getSpecialUnitType();
}

bool CvUnit::isHiddenNationality() const
{
	return 0 < getHiddenNationalityCount() + m_pUnitInfo->isHiddenNationality();
}

void CvUnit::doHNCapture()
{
	PROFILE_EXTRA_FUNC();
	for (int iI = 0; iI < GC.getNumPromotionInfos(); iI++)
	{
		if (GC.getPromotionInfo((PromotionTypes)iI).isSetOnHNCapture()
		&& canAcquirePromotion((PromotionTypes)iI, PromotionRequirements::ForFree))
		{
			setHasPromotion((PromotionTypes)iI, true, true, false, false);
			m_bHasHNCapturePromotion = true;
			return;
		}
	}
}

void CvUnit::removeHNCapturePromotion()
{
	PROFILE_EXTRA_FUNC();
	for (int iI = 0; iI < GC.getNumPromotionInfos(); iI++)
	{
		if (GC.getPromotionInfo((PromotionTypes)iI).isSetOnHNCapture() && isHasPromotion((PromotionTypes)iI))
		{
			setHasPromotion((PromotionTypes)iI, false, true, false, false);
			m_bHasHNCapturePromotion = false;
			return;
		}
	}
}

void CvUnit::processLoadedSpecialUnit(bool bChange, SpecialUnitTypes eSpecialUnit)
{
	const CvSpecialUnitInfo& kSpecialUnit = GC.getSpecialUnitInfo(eSpecialUnit);
	const int iChange = (bChange ? 1 : -1);

	changeExtraCombatPercent(kSpecialUnit.getCombatPercent() * iChange);
	changeExtraWithdrawal(kSpecialUnit.getWithdrawalChange() * iChange);
	changeExtraPursuit(kSpecialUnit.getPursuitChange() * iChange);
}

bool CvUnit::hasBuild(BuildTypes eBuild) const
{
	return isWorker() && (m_pUnitInfo->hasBuild(eBuild) || m_worker->hasExtraBuild(eBuild));
}

void CvUnit::changeExtraBuildType(bool bChange, BuildTypes eBuild)
{
	if (eBuild != NO_BUILD)
	{
		if (bChange)
		{
			if (!isWorker())
			{
				m_worker = new UnitCompWorker();
			}
			m_worker->setExtraBuild(eBuild);
		}
		else if (isWorker())
		{
			m_worker->setExtraBuild(eBuild, false);

			if (m_pUnitInfo->getNumBuilds() == 0 && m_worker->getExtraBuilds().size() == 0)
			{
				CvCity* city = GET_PLAYER(getOwner()).getCity(m_worker->getAssignedCity());
				if (city)
				{
					OutputDebugString(CvString::format("Worker at (%d,%d) stopped being a worker with mission for city %S\n", getX(), getY(), city->getName().GetCString()).c_str());
					city->setWorkerHave(getID(), false);
				}
				delete m_worker;
				m_worker = NULL;
			}
		}
	}
}

bool CvUnit::isExcile() const
{
	int iCount = m_iExcileCount;
	if (m_pUnitInfo->isExcile())
	{
		iCount++;
	}
	return (iCount > 0);
}

void CvUnit::changeExcileCount(int iChange)
{
	m_iExcileCount += iChange;
}

bool CvUnit::isPassage() const
{
	int iCount = m_iPassageCount;
	if (m_pUnitInfo->isPassage())
	{
		iCount++;
	}
	return (iCount > 0);
}

void CvUnit::changePassageCount(int iChange)
{
	m_iPassageCount += iChange;
}

bool CvUnit::isNoNonOwnedCityEntry() const
{
	int iCount = m_iNoNonOwnedCityEntryCount;
	if (m_pUnitInfo->isNoNonOwnedCityEntry())
	{
		iCount++;
	}
	return (iCount > 0);
}

void CvUnit::changeNoNonOwnedCityEntryCount(int iChange)
{
	m_iNoNonOwnedCityEntryCount += iChange;
}

bool CvUnit::isBarbCoExist() const
{
	return m_iBarbCoExistCount + m_pUnitInfo->isBarbCoExist() > 0;
}

void CvUnit::changeBarbCoExistCount(int iChange)
{
	m_iBarbCoExistCount += iChange;
}

bool CvUnit::isBlendIntoCity() const
{
	int iCount = m_iBlendIntoCityCount;
	if (m_pUnitInfo->isBlendIntoCity())
	{
		iCount++;
	}
	return (iCount > 0 || (isAnimal() && canAnimalIgnoresCities()));
}

void CvUnit::changeBlendIntoCityCount(int iChange)
{
	m_iBlendIntoCityCount += iChange;
}

bool CvUnit::isUpgradeAnywhere() const
{
	int iCount = m_iUpgradeAnywhereCount;
	if (m_pUnitInfo->isUpgradeAnywhere())
	{
		iCount++;
	}
	return (iCount > 0);
}

void CvUnit::changeUpgradeAnywhereCount(int iChange)
{
	m_iUpgradeAnywhereCount += iChange;
}

// Only used when unit spot stats change, not when the sight area of this unit change.
void CvUnit::updateSpotIntensity(const InvisibleTypes eInvisibleType, const bool bSameTile)
{
	PROFILE_EXTRA_FUNC();
	if (!GC.getGame().isOption(GAMEOPTION_COMBAT_HIDE_SEEK))
	{
		return;
	}
	std::vector<InvisibleTypes> aSeeInvisibleTypes;

	if (eInvisibleType == NO_INVISIBLE)
	{
		for (int iI = GC.getNumInvisibleInfos() - 1; iI > -1; iI--)
		{
			aSeeInvisibleTypes.push_back(static_cast<InvisibleTypes>(iI));
		}
	}
	else aSeeInvisibleTypes.push_back(eInvisibleType);

	const bool bAerial = getDomainType() == DOMAIN_AIR;

	const int iRange = bSameTile ? 0 : visibilityRange(plot());

	for (int i = aSeeInvisibleTypes.size() - 1; i > -1; i--)
	{
		const InvisibleTypes eInvisible = aSeeInvisibleTypes[i];

		for (int dx = -iRange; dx <= iRange; dx++)
		{
			for (int dy = -iRange; dy <= iRange; dy++)
			{
				CvPlot* pPlot = plotXY(getX(), getY(), dx, dy);

				if (NULL != pPlot && (bAerial || plot()->canSeePlot(pPlot, getTeam())))
				{
					const int iDistance = std::max(abs(dx), abs(dy));

					if (iDistance > 0)
					{
						pPlot->setSpotIntensity(
							getTeam(), eInvisible, getID(),
							visibilityIntensityTotal(eInvisible) - std::max(0, iDistance - visibilityIntensityRangeTotal(eInvisible))
						);
					}
					else
					{
						pPlot->setSpotIntensity(
							getTeam(), eInvisible, getID(),
							visibilityIntensityTotal(eInvisible) + visibilityIntensitySameTileTotal(eInvisible)
						);
					}
				}
			}
		}
	}
}

int CvUnit::visibilityIntensityTotal(InvisibleTypes eInvisibleType) const
{
	int iAmount = (
		m_pUnitInfo->getVisibilityIntensityType(eInvisibleType)
		+ getExtraVisibilityIntensityType(eInvisibleType)
		+ extraVisibleTerrain(eInvisibleType, plot()->getTerrainType())
	);

	if (plot()->isAsPeak())
	{
		iAmount += extraVisibleTerrain(eInvisibleType, GC.getTERRAIN_PEAK());
	}
	else if (plot()->isHills())
	{
		iAmount += extraVisibleTerrain(eInvisibleType, GC.getTERRAIN_HILL());
	}
	const FeatureTypes eFeature = plot()->getFeatureType();
	if (eFeature != NO_FEATURE)
	{
		iAmount += extraVisibleFeature(eInvisibleType, eFeature);
	}
	const ImprovementTypes eImprovement = plot()->getImprovementType();
	if (eImprovement != NO_IMPROVEMENT)
	{
		iAmount += extraVisibleImprovement(eInvisibleType, eImprovement);
	}
	if (plot()->isCity(true))
	{
		iAmount += extraVisibleImprovement(eInvisibleType, GC.getIMPROVEMENT_CITY());
	}
	return iAmount;
}

int CvUnit::getExtraVisibilityIntensityType(InvisibleTypes eIndex) const
{
	FASSERT_BOUNDS(0, GC.getNumInvisibleInfos(), eIndex);

	if (!isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander)
		{
			return m_aiExtraVisibilityIntensity[eIndex] + pCommander->m_aiExtraVisibilityIntensity[eIndex];
		}
	}
	if (!isCommodore())
    	{
    		const CvUnit* pCommodore = getCommodore();
    		if (pCommodore)
    		{
    			return m_aiExtraVisibilityIntensity[eIndex] + pCommodore->m_aiExtraVisibilityIntensity[eIndex];
    		}
    	}
	return m_aiExtraVisibilityIntensity[eIndex];
}


void CvUnit::changeExtraVisibilityIntensityType(InvisibleTypes eIndex, int iChange)
{
	FASSERT_BOUNDS(0, GC.getNumInvisibleInfos(), eIndex);
	if (iChange != 0)
	{
		m_aiExtraVisibilityIntensity[eIndex] += iChange;
		updateSpotIntensity(eIndex);
	}
}

bool CvUnit::hasInvisibilityType(InvisibleTypes eInvisibleType) const
{
	return !isNegatesInvisible(eInvisibleType) && !m_pUnitInfo->isNoInvisibility() && getNoInvisibilityCount() < 1;
}

int CvUnit::invisibilityIntensityTotal(InvisibleTypes eType) const
{
	int iAmount = (
		m_pUnitInfo->getInvisibilityIntensityType(eType)
		+ getExtraInvisibilityIntensityType(eType)
		+ extraInvisibleTerrain(eType, plot()->getTerrainType())
	);

	if (plot()->isAsPeak())
	{
		iAmount += extraInvisibleTerrain(eType, GC.getTERRAIN_PEAK());
	}
	else if (plot()->isHills())
	{
		iAmount += extraInvisibleTerrain(eType, GC.getTERRAIN_HILL());
	}
	const FeatureTypes eFeature = plot()->getFeatureType();
	if (eFeature != NO_FEATURE)
	{
		iAmount += extraInvisibleFeature(eType, eFeature);
	}
	const ImprovementTypes eImprovement = plot()->getImprovementType();
	if (eImprovement != NO_IMPROVEMENT)
	{
		iAmount += extraInvisibleImprovement(eType, eImprovement);
	}
	if (plot()->isCity(true))
	{
		iAmount += extraInvisibleImprovement(eType, GC.getIMPROVEMENT_CITY());
	}
	return iAmount;
}

int CvUnit::getExtraInvisibilityIntensityType(InvisibleTypes eIndex) const
{
	FASSERT_BOUNDS(0, GC.getNumInvisibleInfos(), eIndex);

	if (!isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander)
		{
			return m_aiExtraInvisibilityIntensity[eIndex] + pCommander->m_aiExtraInvisibilityIntensity[eIndex];
		}
	}
	if (!isCommodore())
    	{
    		const CvUnit* pCommodore = getCommodore();
    		if (pCommodore)
    		{
    			return m_aiExtraInvisibilityIntensity[eIndex] + pCommodore->m_aiExtraInvisibilityIntensity[eIndex];
    		}
    	}
	return m_aiExtraInvisibilityIntensity[eIndex];
}


void CvUnit::changeExtraInvisibilityIntensityType(InvisibleTypes eIndex, int iChange)
{
	FASSERT_BOUNDS(0, GC.getNumInvisibleInfos(), eIndex);
	m_aiExtraInvisibilityIntensity[eIndex] += iChange;
}

bool CvUnit::hasAnyInvisibilityType() const
{
	return m_bHasAnyInvisibility;
}

void CvUnit::setHasAnyInvisibility()
{
	PROFILE_EXTRA_FUNC();
	if (m_pUnitInfo->isNoInvisibility() || getNoInvisibilityCount() > 0)
	{
		m_bHasAnyInvisibility = false;
		return;
	}
	for (int iI = GC.getNumInvisibleInfos() - 1; iI > -1; iI--)
	{
		if (!isNegatesInvisible((InvisibleTypes)iI))
		{
			m_bHasAnyInvisibility = true;
			return;
		}
	}
	m_bHasAnyInvisibility = false;
}

int CvUnit::visibilityIntensityRangeTotal(InvisibleTypes eInvisibleType) const
{
	int iAmount = (
		m_pUnitInfo->getVisibilityIntensityRangeType(eInvisibleType)
		+ getExtraVisibilityIntensityRangeType(eInvisibleType)
		+ extraVisibleTerrainRange(eInvisibleType, plot()->getTerrainType())
	);

	if (plot()->isAsPeak())
	{
		iAmount += extraVisibleTerrainRange(eInvisibleType, GC.getTERRAIN_PEAK());
	}
	else if (plot()->isHills())
	{
		iAmount += extraVisibleTerrainRange(eInvisibleType, GC.getTERRAIN_HILL());
	}
	const FeatureTypes eFeature = plot()->getFeatureType();
	if (eFeature != NO_FEATURE)
	{
		iAmount += extraVisibleFeatureRange(eInvisibleType, eFeature);
	}
	const ImprovementTypes eImprovement = plot()->getImprovementType();
	if (eImprovement != NO_IMPROVEMENT)
	{
		iAmount += extraVisibleImprovementRange(eInvisibleType, eImprovement);
	}
	if (plot()->isCity(true))
	{
		iAmount += extraVisibleImprovementRange(eInvisibleType, GC.getIMPROVEMENT_CITY());
	}
	return std::max(0, iAmount);
}

int CvUnit::getExtraVisibilityIntensityRangeType(InvisibleTypes eIndex) const
{
	FASSERT_BOUNDS(0, GC.getNumInvisibleInfos(), eIndex);
	return m_aiExtraVisibilityIntensityRange[eIndex];
}


void CvUnit::changeExtraVisibilityIntensityRangeType(InvisibleTypes eIndex, int iChange)
{
	FASSERT_BOUNDS(0, GC.getNumInvisibleInfos(), eIndex);
	if (iChange != 0)
	{
		m_aiExtraVisibilityIntensityRange[eIndex] += iChange;
		updateSpotIntensity(eIndex);
	}
}

int CvUnit::visibilityIntensitySameTileTotal(InvisibleTypes eType) const
{
	FASSERT_BOUNDS(0, GC.getNumInvisibleInfos(), eType);
	return m_aiExtraVisibilityIntensitySameTile[eType];
}


void CvUnit::changeExtraVisibilityIntensitySameTileType(InvisibleTypes eIndex, int iChange)
{
	FASSERT_BOUNDS(0, GC.getNumInvisibleInfos(), eIndex);
	if (iChange != 0)
	{
		m_aiExtraVisibilityIntensitySameTile[eIndex] += iChange;
		updateSpotIntensity(eIndex, true);
	}
}

int CvUnit::getNumExtraInvisibleTerrains() const
{
	return (int)m_aExtraInvisibleTerrains.size();
}

InvisibleTerrainChanges& CvUnit::getExtraInvisibleTerrain(int iIndex)
{
	return m_aExtraInvisibleTerrains[iIndex];
}

void CvUnit::changeExtraInvisibleTerrain(InvisibleTypes eInvisible, TerrainTypes eTerrain, int iChange)
{
	PROFILE_EXTRA_FUNC();
	bool bFound = false;
	int iSize = getNumExtraInvisibleTerrains();
	for (int iI = 0; iI < iSize; iI++)
	{
		if (m_aExtraInvisibleTerrains[iI].eInvisible == eInvisible && m_aExtraInvisibleTerrains[iI].eTerrain == eTerrain)
		{
			m_aExtraInvisibleTerrains[iI].iIntensity += iChange;
			if (m_aExtraInvisibleTerrains[iI].iIntensity == 0)
			{
				m_aExtraInvisibleTerrains.erase(m_aExtraInvisibleTerrains.begin()+iI);
			}
			bFound = true;
			break;
		}
	}
	if (!bFound)
	{
		const int iISize = iSize;
		iSize++;
		m_aExtraInvisibleTerrains.resize(iSize);
		m_aExtraInvisibleTerrains[iISize].eInvisible = eInvisible;
		m_aExtraInvisibleTerrains[iISize].eTerrain = eTerrain;
		m_aExtraInvisibleTerrains[iISize].iIntensity = iChange;
	}
}

int CvUnit::extraInvisibleTerrain(InvisibleTypes eInvisible, TerrainTypes eTerrain) const
{
	PROFILE_EXTRA_FUNC();
	for (int iI = 0; iI < getNumExtraInvisibleTerrains(); iI++)
	{
		if (m_aExtraInvisibleTerrains[iI].eInvisible == eInvisible && m_aExtraInvisibleTerrains[iI].eTerrain == eTerrain)
		{
			return m_aExtraInvisibleTerrains[iI].iIntensity;
		}
	}
	return 0;
}

int CvUnit::getNumExtraInvisibleFeatures() const
{
	return (int)m_aExtraInvisibleFeatures.size();
}

InvisibleFeatureChanges& CvUnit::getExtraInvisibleFeature(int iIndex)
{
	return m_aExtraInvisibleFeatures[iIndex];
}

void CvUnit::changeExtraInvisibleFeature(InvisibleTypes eInvisible, FeatureTypes eFeature, int iChange)
{
	PROFILE_EXTRA_FUNC();
	bool bFound = false;
	int iSize = getNumExtraInvisibleFeatures();
	for (int iI = 0; iI < iSize; iI++)
	{
		if (m_aExtraInvisibleFeatures[iI].eInvisible == eInvisible && m_aExtraInvisibleFeatures[iI].eFeature == eFeature)
		{
			m_aExtraInvisibleFeatures[iI].iIntensity += iChange;
			if (m_aExtraInvisibleFeatures[iI].iIntensity == 0)
			{
				m_aExtraInvisibleFeatures.erase(m_aExtraInvisibleFeatures.begin()+iI);
			}
			bFound = true;
			break;
		}
	}
	if (!bFound)
	{
		const int iISize = iSize;
		iSize++;
		m_aExtraInvisibleFeatures.resize(iSize);
		m_aExtraInvisibleFeatures[iISize].eInvisible = eInvisible;
		m_aExtraInvisibleFeatures[iISize].eFeature = eFeature;
		m_aExtraInvisibleFeatures[iISize].iIntensity = iChange;
	}
}

int CvUnit::extraInvisibleFeature(InvisibleTypes eInvisible, FeatureTypes eFeature) const
{
	PROFILE_EXTRA_FUNC();
	for (int iI = 0; iI < getNumExtraInvisibleFeatures(); iI++)
	{
		if (m_aExtraInvisibleFeatures[iI].eInvisible == eInvisible && m_aExtraInvisibleFeatures[iI].eFeature == eFeature)
		{
			return m_aExtraInvisibleFeatures[iI].iIntensity;
		}
	}
	return 0;
}

int CvUnit::getNumExtraInvisibleImprovements() const
{
	return (int)m_aExtraInvisibleImprovements.size();
}

InvisibleImprovementChanges& CvUnit::getExtraInvisibleImprovement(int iIndex)
{
	return m_aExtraInvisibleImprovements[iIndex];
}

void CvUnit::changeExtraInvisibleImprovement(InvisibleTypes eInvisible, ImprovementTypes eImprovement, int iChange)
{
	PROFILE_EXTRA_FUNC();
	bool bFound = false;
	int iSize = getNumExtraInvisibleImprovements();
	for (int iI = 0; iI < iSize; iI++)
	{
		if (m_aExtraInvisibleImprovements[iI].eInvisible == eInvisible && m_aExtraInvisibleImprovements[iI].eImprovement == eImprovement)
		{
			m_aExtraInvisibleImprovements[iI].iIntensity += iChange;
			if (m_aExtraInvisibleImprovements[iI].iIntensity == 0)
			{
				m_aExtraInvisibleImprovements.erase(m_aExtraInvisibleImprovements.begin()+iI);
			}
			bFound = true;
			break;
		}
	}
	if (!bFound)
	{
		const int iISize = iSize;
		iSize++;
		m_aExtraInvisibleImprovements.resize(iSize);
		m_aExtraInvisibleImprovements[iISize].eInvisible = eInvisible;
		m_aExtraInvisibleImprovements[iISize].eImprovement = eImprovement;
		m_aExtraInvisibleImprovements[iISize].iIntensity = iChange;
	}
}

int CvUnit::extraInvisibleImprovement(InvisibleTypes eInvisible, ImprovementTypes eImprovement) const
{
	PROFILE_EXTRA_FUNC();
	for (int iI = 0; iI < getNumExtraInvisibleImprovements(); iI++)
	{
		if (m_aExtraInvisibleImprovements[iI].eInvisible == eInvisible && m_aExtraInvisibleImprovements[iI].eImprovement == eImprovement)
		{
			return m_aExtraInvisibleImprovements[iI].iIntensity;
		}
	}
	return 0;
}

int CvUnit::getNumExtraVisibleTerrains() const
{
	return (int)m_aExtraVisibleTerrains.size();
}

InvisibleTerrainChanges& CvUnit::getExtraVisibleTerrain(int iIndex)
{
	return m_aExtraVisibleTerrains[iIndex];
}

void CvUnit::changeExtraVisibleTerrain(InvisibleTypes eInvisible, TerrainTypes eTerrain, int iChange)
{
	PROFILE_EXTRA_FUNC();
	if (iChange == 0)
	{
		return;
	}
	bool bFound = false;
	const int iSize = getNumExtraVisibleTerrains();
	for (int iI = 0; iI < iSize; iI++)
	{
		if (m_aExtraVisibleTerrains[iI].eInvisible == eInvisible && m_aExtraVisibleTerrains[iI].eTerrain == eTerrain)
		{
			m_aExtraVisibleTerrains[iI].iIntensity += iChange;
			if (m_aExtraVisibleTerrains[iI].iIntensity == 0)
			{
				m_aExtraVisibleTerrains.erase(m_aExtraVisibleTerrains.begin()+iI);
			}
			bFound = true;
			break;
		}
	}
	if (!bFound)
	{
		m_aExtraVisibleTerrains.resize(iSize + 1);
		m_aExtraVisibleTerrains[iSize].eInvisible = eInvisible;
		m_aExtraVisibleTerrains[iSize].eTerrain = eTerrain;
		m_aExtraVisibleTerrains[iSize].iIntensity = iChange;
	}
	updateSpotIntensity(eInvisible);
}

int CvUnit::extraVisibleTerrain(InvisibleTypes eInvisible, TerrainTypes eTerrain) const
{
	PROFILE_EXTRA_FUNC();
	for (int iI = 0; iI < getNumExtraVisibleTerrains(); iI++)
	{
		if (m_aExtraVisibleTerrains[iI].eInvisible == eInvisible && m_aExtraVisibleTerrains[iI].eTerrain == eTerrain)
		{
			return m_aExtraVisibleTerrains[iI].iIntensity;
		}
	}
	return 0;
}

int CvUnit::getNumExtraVisibleFeatures() const
{
	return (int)m_aExtraVisibleFeatures.size();
}

InvisibleFeatureChanges& CvUnit::getExtraVisibleFeature(int iIndex)
{
	return m_aExtraVisibleFeatures[iIndex];
}

void CvUnit::changeExtraVisibleFeature(InvisibleTypes eInvisible, FeatureTypes eFeature, int iChange)
{
	PROFILE_EXTRA_FUNC();
	if (iChange == 0)
	{
		return;
	}
	const int iSize = getNumExtraVisibleFeatures();
	bool bFound = false;
	for (int iI = 0; iI < iSize; iI++)
	{
		if (m_aExtraVisibleFeatures[iI].eInvisible == eInvisible && m_aExtraVisibleFeatures[iI].eFeature == eFeature)
		{
			m_aExtraVisibleFeatures[iI].iIntensity += iChange;
			if (m_aExtraVisibleFeatures[iI].iIntensity == 0)
			{
				m_aExtraVisibleFeatures.erase(m_aExtraVisibleFeatures.begin()+iI);
			}
			bFound = true;
			break;
		}
	}
	if (!bFound)
	{
		m_aExtraVisibleFeatures.resize(iSize + 1);
		m_aExtraVisibleFeatures[iSize].eInvisible = eInvisible;
		m_aExtraVisibleFeatures[iSize].eFeature = eFeature;
		m_aExtraVisibleFeatures[iSize].iIntensity = iChange;
	}
	updateSpotIntensity(eInvisible);
}

int CvUnit::extraVisibleFeature(InvisibleTypes eInvisible, FeatureTypes eFeature) const
{
	PROFILE_EXTRA_FUNC();
	for (int iI = 0; iI < getNumExtraVisibleFeatures(); iI++)
	{
		if (m_aExtraVisibleFeatures[iI].eInvisible == eInvisible && m_aExtraVisibleFeatures[iI].eFeature == eFeature)
		{
			return m_aExtraVisibleFeatures[iI].iIntensity;
		}
	}
	return 0;
}

int CvUnit::getNumExtraVisibleImprovements() const
{
	return (int)m_aExtraVisibleImprovements.size();
}

InvisibleImprovementChanges& CvUnit::getExtraVisibleImprovement(int iIndex)
{
	return m_aExtraVisibleImprovements[iIndex];
}

void CvUnit::changeExtraVisibleImprovement(InvisibleTypes eInvisible, ImprovementTypes eImprovement, int iChange)
{
	PROFILE_EXTRA_FUNC();
	if (iChange == 0)
	{
		return;
	}
	const int iSize = getNumExtraVisibleImprovements();
	bool bFound = false;
	for (int iI = 0; iI < iSize; iI++)
	{
		if (m_aExtraVisibleImprovements[iI].eInvisible == eInvisible && m_aExtraVisibleImprovements[iI].eImprovement == eImprovement)
		{
			m_aExtraVisibleImprovements[iI].iIntensity += iChange;
			if (m_aExtraVisibleImprovements[iI].iIntensity == 0)
			{
				m_aExtraVisibleImprovements.erase(m_aExtraVisibleImprovements.begin()+iI);
			}
			bFound = true;
			break;
		}
	}
	if (!bFound)
	{
		m_aExtraVisibleImprovements.resize(iSize + 1);
		m_aExtraVisibleImprovements[iSize].eInvisible = eInvisible;
		m_aExtraVisibleImprovements[iSize].eImprovement = eImprovement;
		m_aExtraVisibleImprovements[iSize].iIntensity = iChange;
	}
	updateSpotIntensity(eInvisible);
}

int CvUnit::extraVisibleImprovement(InvisibleTypes eInvisible, ImprovementTypes eImprovement) const
{
	PROFILE_EXTRA_FUNC();
	for (int iI = 0; iI < getNumExtraVisibleImprovements(); iI++)
	{
		if (m_aExtraVisibleImprovements[iI].eInvisible == eInvisible && m_aExtraVisibleImprovements[iI].eImprovement == eImprovement)
		{
			return m_aExtraVisibleImprovements[iI].iIntensity;
		}
	}
	return 0;
}

int CvUnit::getNumExtraVisibleTerrainRanges() const
{
	return (int)m_aExtraVisibleTerrainRanges.size();
}

InvisibleTerrainChanges& CvUnit::getExtraVisibleTerrainRange(int iIndex)
{
	return m_aExtraVisibleTerrainRanges[iIndex];
}

void CvUnit::changeExtraVisibleTerrainRange(InvisibleTypes eInvisible, TerrainTypes eTerrain, int iChange)
{
	PROFILE_EXTRA_FUNC();
	if (iChange == 0)
	{
		return;
	}
	const int iSize = getNumExtraVisibleTerrainRanges();
	bool bFound = false;
	for (int iI = 0; iI < iSize; iI++)
	{
		if (m_aExtraVisibleTerrainRanges[iI].eInvisible == eInvisible && m_aExtraVisibleTerrainRanges[iI].eTerrain == eTerrain)
		{
			m_aExtraVisibleTerrainRanges[iI].iIntensity += iChange;
			if (m_aExtraVisibleTerrainRanges[iI].iIntensity == 0)
			{
				m_aExtraVisibleTerrainRanges.erase(m_aExtraVisibleTerrainRanges.begin()+iI);
			}
			bFound = true;
			break;
		}
	}
	if (!bFound)
	{
		m_aExtraVisibleTerrainRanges.resize(iSize + 1);
		m_aExtraVisibleTerrainRanges[iSize].eInvisible = eInvisible;
		m_aExtraVisibleTerrainRanges[iSize].eTerrain = eTerrain;
		m_aExtraVisibleTerrainRanges[iSize].iIntensity = iChange;
	}
	updateSpotIntensity(eInvisible);
}

int CvUnit::extraVisibleTerrainRange(InvisibleTypes eInvisible, TerrainTypes eTerrain) const
{
	PROFILE_EXTRA_FUNC();
	for (int iI = 0; iI < getNumExtraVisibleTerrainRanges(); iI++)
	{
		if (m_aExtraVisibleTerrainRanges[iI].eInvisible == eInvisible && m_aExtraVisibleTerrainRanges[iI].eTerrain == eTerrain)
		{
			return m_aExtraVisibleTerrainRanges[iI].iIntensity;
		}
	}
	return 0;
}

int CvUnit::getNumExtraVisibleFeatureRanges() const
{
	return (int)m_aExtraVisibleFeatureRanges.size();
}

InvisibleFeatureChanges& CvUnit::getExtraVisibleFeatureRange(int iIndex)
{
	return m_aExtraVisibleFeatureRanges[iIndex];
}

void CvUnit::changeExtraVisibleFeatureRange(InvisibleTypes eInvisible, FeatureTypes eFeature, int iChange)
{
	PROFILE_EXTRA_FUNC();
	if (iChange == 0)
	{
		return;
	}
	const int iSize = getNumExtraVisibleFeatureRanges();
	bool bFound = false;
	for (int iI = 0; iI < iSize; iI++)
	{
		if (m_aExtraVisibleFeatureRanges[iI].eInvisible == eInvisible && m_aExtraVisibleFeatureRanges[iI].eFeature == eFeature)
		{
			m_aExtraVisibleFeatureRanges[iI].iIntensity += iChange;
			if (m_aExtraVisibleFeatureRanges[iI].iIntensity == 0)
			{
				m_aExtraVisibleFeatureRanges.erase(m_aExtraVisibleFeatureRanges.begin()+iI);
			}
			bFound = true;
			break;
		}
	}
	if (!bFound)
	{
		m_aExtraVisibleFeatureRanges.resize(iSize + 1);
		m_aExtraVisibleFeatureRanges[iSize].eInvisible = eInvisible;
		m_aExtraVisibleFeatureRanges[iSize].eFeature = eFeature;
		m_aExtraVisibleFeatureRanges[iSize].iIntensity = iChange;
	}
	updateSpotIntensity(eInvisible);
}

int CvUnit::extraVisibleFeatureRange(InvisibleTypes eInvisible, FeatureTypes eFeature) const
{
	PROFILE_EXTRA_FUNC();
	for (int iI = 0; iI < getNumExtraVisibleFeatureRanges(); iI++)
	{
		if (m_aExtraVisibleFeatureRanges[iI].eInvisible == eInvisible && m_aExtraVisibleFeatureRanges[iI].eFeature == eFeature)
		{
			return m_aExtraVisibleFeatureRanges[iI].iIntensity;
		}
	}
	return 0;
}

int CvUnit::getNumExtraVisibleImprovementRanges() const
{
	return (int)m_aExtraVisibleImprovementRanges.size();
}

InvisibleImprovementChanges& CvUnit::getExtraVisibleImprovementRange(int iIndex)
{
	return m_aExtraVisibleImprovementRanges[iIndex];
}

void CvUnit::changeExtraVisibleImprovementRange(InvisibleTypes eInvisible, ImprovementTypes eImprovement, int iChange)
{
	PROFILE_EXTRA_FUNC();
	if (iChange == 0)
	{
		return;
	}
	const int iSize = getNumExtraVisibleImprovementRanges();
	bool bFound = false;
	for (int iI = 0; iI < iSize; iI++)
	{
		if (m_aExtraVisibleImprovementRanges[iI].eInvisible == eInvisible && m_aExtraVisibleImprovementRanges[iI].eImprovement == eImprovement)
		{
			m_aExtraVisibleImprovementRanges[iI].iIntensity += iChange;
			if (m_aExtraVisibleImprovementRanges[iI].iIntensity == 0)
			{
				m_aExtraVisibleImprovementRanges.erase(m_aExtraVisibleImprovementRanges.begin()+iI);
			}
			bFound = true;
			break;
		}
	}
	if (!bFound)
	{
		m_aExtraVisibleImprovementRanges.resize(iSize + 1);
		m_aExtraVisibleImprovementRanges[iSize].eInvisible = eInvisible;
		m_aExtraVisibleImprovementRanges[iSize].eImprovement = eImprovement;
		m_aExtraVisibleImprovementRanges[iSize].iIntensity = iChange;
	}
	updateSpotIntensity(eInvisible);
}

int CvUnit::extraVisibleImprovementRange(InvisibleTypes eInvisible, ImprovementTypes eImprovement) const
{
	PROFILE_EXTRA_FUNC();
	for (int iI = 0; iI < getNumExtraVisibleImprovementRanges(); iI++)
	{
		if (m_aExtraVisibleImprovementRanges[iI].eInvisible == eInvisible && m_aExtraVisibleImprovementRanges[iI].eImprovement == eImprovement)
		{
			return m_aExtraVisibleImprovementRanges[iI].iIntensity;
		}
	}
	return 0;
}

#ifdef OUTBREAKS_AND_AFFLICTIONS
int CvUnit::getNumExtraAidChanges() const
{
	return (int)m_aExtraAidChanges.size();
}

AidStruct& CvUnit::getExtraAidChange(int iIndex)
{
	return m_aExtraAidChanges[iIndex];
}

void CvUnit::changeExtraAidChange(PropertyTypes eProperty, int iChange)
{
	PROFILE_EXTRA_FUNC();
	if (iChange == 0)
		return;

	bool bFound = false;
	int iSize = getNumExtraAidChanges();
	for (int iI = 0; iI < iSize; iI++)
	{
		if (m_aExtraAidChanges[iI].eProperty == eProperty)
		{
			m_aExtraAidChanges[iI].iChange += iChange;
			if (m_aExtraAidChanges[iI].iChange == 0)
			{
				m_aExtraAidChanges.erase(m_aExtraAidChanges.begin()+iI);
			}
			bFound = true;
			break;
		}
	}
	if (!bFound)
	{
		const int iISize = iSize;
		iSize++;
		m_aExtraAidChanges.resize(iSize);
		m_aExtraAidChanges[iISize].eProperty = eProperty;
		m_aExtraAidChanges[iISize].iChange = iChange;
	}
}

int CvUnit::extraAidChange(PropertyTypes eProperty) const
{
	PROFILE_EXTRA_FUNC();
	for (int iI = 0; iI < getNumExtraAidChanges(); iI++)
	{
		if (m_aExtraAidChanges[iI].eProperty == eProperty)
		{
			return m_aExtraAidChanges[iI].iChange;
		}
	}
	return 0;
}
#endif

bool CvUnit::isNegatesInvisible(InvisibleTypes eInvisible) const
{
	FASSERT_BOUNDS(0, GC.getNumInvisibleInfos(), eInvisible);

	if (GC.getInvisibleInfo(eInvisible).isIntrinsic() && !GC.getGame().isOption(GAMEOPTION_COMBAT_SIZE_MATTERS))
	{
		return true;
	}
	return (getNegatesInvisibleCount(eInvisible) > 0 || isRevealed());
}
int CvUnit::getNegatesInvisibleCount(InvisibleTypes eInvisible) const
{
	FASSERT_BOUNDS(0, GC.getNumInvisibleInfos(), eInvisible);
	return m_aiNegatesInvisibleCount[eInvisible];
}
void CvUnit::changeNegatesInvisibleCount(InvisibleTypes eInvisible, int iChange)
{
	FASSERT_BOUNDS(0, GC.getNumInvisibleInfos(), eInvisible);
	m_aiNegatesInvisibleCount[eInvisible] += iChange;
	setHasAnyInvisibility();
}

bool CvUnit::hasInvisibleAbility() const
{
	if (GC.getGame().isOption(GAMEOPTION_COMBAT_HIDE_SEEK))
	{
		return hasAnyInvisibilityType();
	}

	if ((InvisibleTypes)m_pUnitInfo->getInvisibleType() != NO_INVISIBLE)
	{
		return true;
	}

	return false;
}

bool CvUnit::isCriminal() const
{
	return getInsidiousnessTotal(true) > 0;
}

int CvUnit::getInsidiousnessTotal(bool bCriminalCheck) const
{
	int iTotal = m_pUnitInfo->getInsidiousness();
	iTotal += m_iExtraInsidiousness;
	if (!bCriminalCheck && iTotal > 0)
	{
		if (plot() != NULL)
		{
			const CvCity* pCity = plot()->getPlotCity();
			if (pCity != NULL)
			{
				iTotal += pCity->getExtraInsidiousness();
				iTotal += pCity->getSpecialistInsidiousness();
			}
		}
	}
	return iTotal;
}

void CvUnit::changeExtraInsidiousness(int iChange)
{
	m_iExtraInsidiousness += iChange;
}

int CvUnit::getInvestigationTotal() const
{
	int iTotal = m_pUnitInfo->getInvestigation();
	iTotal += m_iExtraInvestigation;
	return iTotal;
}

void CvUnit::changeExtraInvestigation(int iChange)
{
	m_iExtraInvestigation += iChange;
}

bool CvUnit::criminalSuccessCheck()
{
	int iDice = 1000;
	int iInsidious = getInsidiousnessTotal();
	int iInvestigate = 0;
	int iChance = 0;
	int iRoll = 0;

	if (plot() == NULL)
	{
		return false;
	}

	CvCity* pCity = plot()->getPlotCity();
	bool bSuccess = true;
	if (pCity != NULL)
	{
		iInvestigate = pCity->getInvestigationTotal(true);
		iChance = std::max(0, iInvestigate - iInsidious);
		iRoll = GC.getGame().getSorenRandNum(iDice, "InvestigationRoll");
		if (iRoll < iChance)
		{
			makeWanted(pCity);
			bSuccess = false;
		}
		else
		{
			//Avoided being Investigated
			changeExperience100(5);
		}
	}
	return bSuccess;
}

void CvUnit::doInsidiousnessVSInvestigationCheck()
{
	int iDice = 1000;
	int iInsidious = getInsidiousnessTotal();
	int iInvestigate = 0;
	int iChance = 0;
	int iRoll = 0;

	if (plot() == NULL)
	{
		return;
	}

	CvCity* pCity = plot()->getPlotCity();

	if (pCity != NULL)
	{
		iInvestigate = pCity->getInvestigationTotal(true);
		iChance = std::max(0, iInvestigate - iInsidious);
		iRoll = GC.getGame().getSorenRandNum(iDice, "InvestigationRoll");
		if (iRoll < iChance)
		{
			makeWanted(pCity);
		}
		else
		{
			//Avoided being Investigated
			changeExperience100(5);
		}
	}
}

void CvUnit::doRemoveInvestigatedPromotionCheck()
{
	PROFILE_EXTRA_FUNC();
	if (plot() != NULL &&
		(!plot()->isVisible(GET_PLAYER(m_pPlayerInvestigated).getTeam(), false) ||
		(plot()->getOwner() != m_pPlayerInvestigated && (isInvisible(GET_PLAYER(m_pPlayerInvestigated).getTeam(), false, false) || m_pPlayerInvestigated == getOwner()))))
	{
		int iI = 0;
		for (iI = 0; iI < GC.getNumPromotionInfos(); iI++)
		{
			if (GC.getPromotionInfo((PromotionTypes)iI).isSetOnInvestigated() && isHasPromotion((PromotionTypes)iI) )
			{
				PromotionTypes ePromotion = ((PromotionTypes)iI);
				setHasPromotion(ePromotion, false, true, false, false);
				m_pPlayerInvestigated = NO_PLAYER;
			}
		}
	}
}

bool CvUnit::isWantedbyPlayer(PlayerTypes ePlayer) const
{
	return (m_pPlayerInvestigated == ePlayer);
}

bool CvUnit::isWanted() const
{
	return (m_pPlayerInvestigated != NO_PLAYER);
}


void CvUnit::attackSamePlotSpecifiedUnit(CvUnit* pSelectedDefender)
{
	PROFILE_FUNC();

	FAssert(getCombatTimer() == 0);
	m_combatResult.iTurnCount = 0;
	//TB Note: No Strength in numbers possible on such a same plot attack.
	CvPlot* pPlot = plot();
	setAttackPlot(pPlot, false);

	updateCombat(pSelectedDefender, true);
}

bool CvUnit::canArrest() const
{
	//is Law Enforcement? - does not check city modifiers, only base
	if (getInvestigationTotal() > 0)
	{
		if (isCargo())
		{
			return false;
		}
		const CvPlot* pPlot = plot();
		if (canMove() && canAttack() && !isDead() && !isInBattle() && !isCargo()) // && getGroup()->getNumUnits() == 1)
		{
			if (pPlot != NULL)
			{
				if (!(pPlot->isValidDomainForAction(*this)))
				{
					return false;
				}
				if (pPlot->getNumVisibleWantedCriminals(getOwner()) > 0)
				{
					return true;
				}
			}
		}
	}
	return false;
}

void CvUnit::doArrest()
{
	PROFILE_EXTRA_FUNC();

	if (isHuman())
	{
		CvPopupInfo* pInfo = new CvPopupInfo(BUTTONPOPUP_CHOOSE_ARREST_UNIT);
		pInfo->setData1(getID());
		pInfo->setData2(getX());
		pInfo->setData3(getY());
		pInfo->setFlags(getOwner());
		gDLL->getInterfaceIFace()->addPopup(pInfo, getOwner(), true);
		return;
	}
	CvUnit* pBestUnit = NULL;
	{
		int iBestOdds = 0;
		foreach_(CvUnit* unitX, plot()->units())
		{
			if (unitX->isWanted()
			&&  unitX->getID() != getID()
			&& !unitX->isInvisible(GET_PLAYER(getOwner()).getTeam(), false)
			&& !unitX->isDead()
			&& !unitX->isInBattle()
			&& !unitX->isSpy())
			{
				const int iOdds = getCombatOdds(this, unitX);
				if (iOdds > 50 && iOdds > iBestOdds)
				{
					iBestOdds = iOdds;
					pBestUnit = unitX;
				}
			}
		}
	}
	if (pBestUnit)
	{
		attackSamePlotSpecifiedUnit(pBestUnit);
		setMadeAttack(true);
		changeMoves(GC.getMOVE_DENOMINATOR());
	}
}

bool CvUnit::canAmbush(const CvPlot* pPlot, bool bAssassinate) const
{
	if (!GC.getGame().isOption(GAMEOPTION_COMBAT_WITHOUT_WARNING))
	{
		return false;
	}

	if (pPlot == NULL)
	{
		return false;
	}

	if (!canAttack())
	{
		return false;
	}

	if (isCargo())
	{
		return false;
	}

	if (!(pPlot->isValidDomainForAction(*this)))
	{
		return false;
	}

	if (bAssassinate && !isAssassin())
	{
		return false;
	}

	if (!bAssassinate && pPlot->isCity(false)) //true->false Calvitix (to be able to attack animals in fort)
	{
		return false;
	}

	if (isBlitz() || !isMadeAttack())
	{
		const CvUnit* pDefender = pPlot->getBestDefender(NO_PLAYER, getOwner(), this, true, true, false, bAssassinate);
		if (pDefender != NULL)
		{
			if (!pDefender->isInvisible(getTeam(), false))
			{
				return true;
			}
		}
		if (pPlot->isVisiblePotentialEnemyDefender(this) || pPlot->isVisiblePotentialEnemyDefenderless(this))
		{
			foreach_(CvUnit* pLoopUnit, pPlot->units())
			{
				if (bAssassinate && !pLoopUnit->isTargetOf(*this))
				{
					continue;
				}
				if (canAttack(*pLoopUnit))
				{
					return true;
				}
			}
		}
	}
	return false;
}

bool CvUnit::doAmbush(bool bAssassinate)
{

	if (!canAmbush(plot(), bAssassinate))
	{
		return false;
	}
	if (bAssassinate && !isAssassin())
	{
		return false;
	}
	if (bAssassinate && plot()->isCity(false))
	{
		doInsidiousnessVSInvestigationCheck();
	}
	if (GET_PLAYER(getOwner()).getAmbushingUnit() == FFreeList::INVALID_INDEX)
	{
		//Get best attacker from selected and send it to be the one selected to attack by setting it as the ambushing unit.
		if (isHuman())
		{
			GET_PLAYER(getOwner()).setAmbushingUnit(getID(), bAssassinate);
			CvPopupInfo* pInfo = new CvPopupInfo(BUTTONPOPUP_CONFIRM_AMBUSH); // BUTTONPOPUP_CONFIRM_AMBUSH);
			pInfo->setData1(getID());
			pInfo->setData2(getX());
			pInfo->setData3(getY());
			pInfo->setFlags(AMBUSH_FLAG);
			//pInfo->setPythonModule("AmbushPopup");
			//pInfo->setOnClickedPythonCallback("onAmbushPopup");
			gDLL->getInterfaceIFace()->addPopup(pInfo, getOwner(), true);
		}
		else
		{
			GET_PLAYER(getOwner()).setAmbushingUnit(getID());
			CvPlot* pPlot = plot();
			if (pPlot != NULL)
			{
				CvUnit* pDefender;
				if (bAssassinate && GC.getGame().isModderGameOption(MODDERGAMEOPTION_ASSASSINATE_CHOICE))
				{
					pDefender = pPlot->getWorstDefender(NO_PLAYER, getOwner(), this, true, true, false, bAssassinate);
				}
				else
				{
					pDefender = pPlot->getBestDefender(NO_PLAYER, getOwner(), this, true, true, false, bAssassinate);
				}
				
				if (pDefender != NULL)
				{
					attackSamePlotSpecifiedUnit(pDefender);
					setMadeAttack(true); //Calvitix (if ambush succes, cannot attack anymore)
					changeMoves(GC.getMOVE_DENOMINATOR());
				}
			}
			GET_PLAYER(getOwner()).setAmbushingUnit(FFreeList::INVALID_INDEX);
		}
	}
	return true;
}

void CvUnit::enactAmbush(bool bAssassinate, CvUnit * pSelectedDefender)
{
	CvPlot* pPlot = plot();
	CvUnit* pDefender = NULL;
	if (!pSelectedDefender)
	{
		pDefender = pPlot->getBestDefender(NO_PLAYER, getOwner(), this, !gDLL->altKey(), NO_TEAM == getDeclareWarMove(pPlot), false, bAssassinate);
	}
	else
	{
		pDefender = pSelectedDefender;
	}
	if (pDefender != NULL)
	{
		attackSamePlotSpecifiedUnit(pDefender);
		setMadeAttack(true); //Calvitix (if ambush succes, cannot attack anymore)
		changeMoves(GC.getMOVE_DENOMINATOR());
	}
}

void CvUnit::changeDebugCount(int iChange)
{
	//TB: disabled while recalculating vision every round.
	m_iDebugCount += iChange;
	//assert disabled until I need to run a new test
	/*FAssert(m_iDebugCount >= 0 && m_iDebugCount <= 1);*/
}

void CvUnit::setDebugCount(int iValue)
{
	//TB: disabled while recalculating vision every round.
	m_iDebugCount = iValue;
	FAssert(m_iDebugCount >= 0 && m_iDebugCount <= 1);
}

bool CvUnit::isAssassin() const
{
	return m_iAssassinCount + m_pUnitInfo->isAssassin() > 0;
}

int CvUnit::getAssassinCount() const
{
	return m_iAssassinCount;
}

void CvUnit::changeAssassinCount(int iChange)
{
	m_iAssassinCount += iChange;
}

int CvUnit::stealthStrikesTotal() const
{
	if (!GC.getGame().isOption(GAMEOPTION_COMBAT_WITHOUT_WARNING))
	{
		return 0;
	}
	int iAnswer = m_pUnitInfo->getStealthStrikes();
	iAnswer += getExtraStealthStrikes();

	return iAnswer;
}

int CvUnit::getExtraStealthStrikes() const
{
	if (!GC.getGame().isOption(GAMEOPTION_COMBAT_WITHOUT_WARNING))
	{
		return 0;
	}
	return m_iExtraStealthStrikes;
}

void CvUnit::changeExtraStealthStrikes(int iChange)
{
	m_iExtraStealthStrikes += iChange;
}

int CvUnit::stealthCombatModifierTotal() const
{
	if (!GC.getGame().isOption(GAMEOPTION_COMBAT_WITHOUT_WARNING))
	{
		return 0;
	}
	int iAnswer = m_pUnitInfo->getStealthCombatModifier();
	iAnswer += getExtraStealthCombatModifier();

	return iAnswer;
}

int CvUnit::getExtraStealthCombatModifier() const
{
	if (!GC.getGame().isOption(GAMEOPTION_COMBAT_WITHOUT_WARNING))
	{
		return 0;
	}
	return m_iExtraStealthCombatModifier;
}

void CvUnit::changeExtraStealthCombatModifier(int iChange)
{
	m_iExtraStealthCombatModifier += iChange;
}

bool CvUnit::hasStealthDefense() const
{
	if (!GC.getGame().isOption(GAMEOPTION_COMBAT_WITHOUT_WARNING))
	{
		return false;
	}
	int iCount = getStealthDefenseCount();
	if (m_pUnitInfo->isStealthDefense())
	{
		iCount++;
	}
	return (iCount > 0);
}

int CvUnit::getStealthDefenseCount() const
{
	return m_iStealthDefenseCount;
}

void CvUnit::changeStealthDefenseCount(int iChange)
{
	m_iStealthDefenseCount += iChange;
}

void CvUnit::reveal()
{
	m_bRevealed = true;
}

bool CvUnit::isRevealed() const
{
	return m_bRevealed;
}

void CvUnit::doSetDefaultStatuses()
{
	PROFILE_EXTRA_FUNC();
	std::vector<int> m_iDefaultStatusTypes;
	m_iDefaultStatusTypes.clear();
	//Step 1: Assign all statuses from defaults into a local vector to create a singular list
	for (int iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
	{
		if (isHasUnitCombat((UnitCombatTypes)iI))
		{
			const UnitCombatTypes eUnitCombat = ((UnitCombatTypes)iI);
			for (int iJ = 0; iJ < GC.getUnitCombatInfo(eUnitCombat).getNumDefaultStatusTypes(); iJ++)
			{
				m_iDefaultStatusTypes.push_back(GC.getUnitCombatInfo(eUnitCombat).getDefaultStatusType(iJ));
			}
		}
	}
	//Step 2: Compare all statuses in the list to all other statuses in the list to check for the same promotionline.
	//If one of them has the iLinePriority 1 promo in that set, this is supposed to indicate NO status from this group.
	//Let it take default by erasing out of the list any other default statuses in this status group (promotionline).
	for (int iI = 0; iI < (int)m_iDefaultStatusTypes.size(); iI++)
	{
		const PromotionTypes ePromotion = (PromotionTypes)m_iDefaultStatusTypes[iI];
		const PromotionLineTypes ePromotionLine = GC.getPromotionInfo(ePromotion).getPromotionLine();
		for (int iJ = 0; iJ < (int)m_iDefaultStatusTypes.size(); iJ++)
		{
			const PromotionTypes pPromotion = (PromotionTypes)m_iDefaultStatusTypes[iJ];
			const PromotionLineTypes pPromotionLine = GC.getPromotionInfo(pPromotion).getPromotionLine();
			if (pPromotionLine == ePromotionLine && ePromotion != pPromotion)
			{
				if (GC.getPromotionInfo(ePromotion).getLinePriority() == 1)
				{
					m_iDefaultStatusTypes.erase(m_iDefaultStatusTypes.begin()+iJ);
				}
				else if (GC.getPromotionInfo(pPromotion).getLinePriority() == 1)
				{
					m_iDefaultStatusTypes.erase(m_iDefaultStatusTypes.begin()+iI);
				}
			}
		}
	}
	//Step 3: Assign default statuses.
	//The order now doesn't matter so if there are differing statuses in the same group then the last to be set takes precedence.
	for (int iI = 0; iI < (int)m_iDefaultStatusTypes.size(); iI++)
	{
		const PromotionTypes ePromotion = (PromotionTypes)m_iDefaultStatusTypes[iI];
		if (canAcquirePromotion(ePromotion, PromotionRequirements::ForStatus))
		{
			statusUpdate(ePromotion);
		}
	}
}

int CvUnit::trapDamageMaxTotal() const
{
	int iAnswer = m_pUnitInfo->getTrapDamageMax();
	iAnswer += getExtraTrapDamageMax();

	return iAnswer;
}

int CvUnit::getExtraTrapDamageMax() const
{
	return m_iExtraTrapDamageMax;
}

void CvUnit::changeExtraTrapDamageMax(int iChange)
{
	m_iExtraTrapDamageMax += iChange;
}

int CvUnit::trapDamageMinTotal() const
{
	int iAnswer = m_pUnitInfo->getTrapDamageMin();
	iAnswer += getExtraTrapDamageMin();

	return iAnswer;
}

int CvUnit::getExtraTrapDamageMin() const
{
	return m_iExtraTrapDamageMin;
}

void CvUnit::changeExtraTrapDamageMin(int iChange)
{
	m_iExtraTrapDamageMin += iChange;
}

int CvUnit::trapComplexityTotal() const
{
	int iAnswer = m_pUnitInfo->getTrapComplexity();
	iAnswer += getExtraTrapComplexity();

	return iAnswer;
}

int CvUnit::getExtraTrapComplexity() const
{
	return m_iExtraTrapComplexity;
}

void CvUnit::changeExtraTrapComplexity(int iChange)
{
	m_iExtraTrapComplexity += iChange;
}

int CvUnit::trapNumTriggers() const
{
	int iAnswer = m_pUnitInfo->getNumTriggers();
	iAnswer += getExtraNumTriggers();

	return iAnswer;
}

int CvUnit::getExtraNumTriggers() const
{
	return m_iExtraNumTriggers;
}

void CvUnit::changeExtraNumTriggers(int iChange)
{
	m_iExtraNumTriggers += iChange;
}

int CvUnit::trapNumTriggersRemaining() const
{
	int iAnswer = trapNumTriggers();
	iAnswer -= getNumTimesTriggered();

	return iAnswer;
}

int CvUnit::getNumTimesTriggered() const
{
	return m_iNumTimesTriggered;
}

void CvUnit::changeNumTimesTriggered(int iChange)
{
	m_iNumTimesTriggered += iChange;
}

bool CvUnit::isTriggerBeforeAttack() const
{
	int iAnswer = 0;
	if (m_pUnitInfo->isTriggerBeforeAttack())
	{
		iAnswer++;
	}
	iAnswer += getTriggerBeforeAttackCount();

	return (iAnswer > 0);
}

int CvUnit::getTriggerBeforeAttackCount() const
{
	return m_iTriggerBeforeAttackCount;
}

void CvUnit::changeTriggerBeforeAttackCount(int iChange)
{
	m_iTriggerBeforeAttackCount += iChange;
}

int CvUnit::getTrapSetWithPromotionCount(PromotionTypes ePromotion) const
{
	FASSERT_BOUNDS(0, GC.getNumPromotionInfos(), ePromotion);

	const PromotionKeyedInfo* info = findPromotionKeyedInfo(ePromotion);

	return info == NULL ? 0 : info->m_iTrapSetWithPromotionCount;
}

bool CvUnit::hasTrapSetWithPromotion(PromotionTypes ePromotion) const
{
	FASSERT_BOUNDS(0, GC.getNumPromotionInfos(), ePromotion);
	return (getTrapSetWithPromotionCount(ePromotion) > 0);
}

void CvUnit::changeTrapSetWithPromotionCount(PromotionTypes ePromotion, int iChange)
{
	FASSERT_BOUNDS(0, GC.getNumPromotionInfos(), ePromotion);

	if (iChange != 0)
	{
		PromotionKeyedInfo* info = findOrCreatePromotionKeyedInfo(ePromotion);

		info->m_iTrapSetWithPromotionCount += iChange;
	}
}
//

int CvUnit::getTrapImmunityUnitCombatCount(UnitCombatTypes eUnitCombat) const
{
	FASSERT_BOUNDS(0, GC.getNumUnitCombatInfos(), eUnitCombat);

	const UnitCombatKeyedInfo* info = findUnitCombatKeyedInfo(eUnitCombat);

	return info ? info->m_iTrapImmunityUnitCombatCount : 0;
}

bool CvUnit::hasTrapImmunityUnitCombat(UnitCombatTypes eUnitCombat) const
{
	FASSERT_BOUNDS(0, GC.getNumUnitCombatInfos(), eUnitCombat);
	return (getTrapImmunityUnitCombatCount(eUnitCombat) > 0);
}

void CvUnit::changeTrapImmunityUnitCombatCount(UnitCombatTypes eUnitCombat, int iChange)
{
	FASSERT_BOUNDS(0, GC.getNumUnitCombatInfos(), eUnitCombat);

	if (iChange != 0)
	{
		UnitCombatKeyedInfo* info = findOrCreateUnitCombatKeyedInfo(eUnitCombat);

		info->m_iTrapImmunityUnitCombatCount += iChange;
	}
}

bool CvUnit::hasTargetUnitCombat(UnitCombatTypes eUnitCombat) const
{
	FASSERT_BOUNDS(0, GC.getNumUnitCombatInfos(), eUnitCombat);

	const UnitCombatKeyedInfo* info = findUnitCombatKeyedInfo(eUnitCombat);
	return (info ? info->m_iTargetUnitCombatCount > 0 : false);
}

void CvUnit::changeTargetUnitCombatCount(UnitCombatTypes eUnitCombat, int iChange)
{
	FASSERT_BOUNDS(0, GC.getNumUnitCombatInfos(), eUnitCombat);

	if (iChange != 0)
	{
		findOrCreateUnitCombatKeyedInfo(eUnitCombat)->m_iTargetUnitCombatCount += iChange;
	}
}

int CvUnit::trapDisableUnitCombatTotal(UnitCombatTypes eCombatType) const
{
	return std::max(0, m_pUnitInfo->getTrapDisableUnitCombatType(eCombatType) + getExtraTrapDisableUnitCombatType(eCombatType));
}

int CvUnit::getExtraTrapDisableUnitCombatType(UnitCombatTypes eIndex) const
{
	FASSERT_BOUNDS(0, GC.getNumUnitCombatInfos(), eIndex);

	const UnitCombatKeyedInfo* info = findUnitCombatKeyedInfo(eIndex);

	return info ? info->m_iExtraTrapDisableUnitCombatType : 0;
}

void CvUnit::changeExtraTrapDisableUnitCombatType(UnitCombatTypes eIndex, int iChange)
{
	FASSERT_BOUNDS(0, GC.getNumUnitCombatInfos(), eIndex);

	if (iChange != 0)
	{
		UnitCombatKeyedInfo* info = findOrCreateUnitCombatKeyedInfo(eIndex);

		info->m_iExtraTrapDisableUnitCombatType += iChange;
	}
}

bool CvUnit::hasExtraTrapDisableUnitCombatType(UnitCombatTypes eIndex) const
{
	return (getExtraTrapDisableUnitCombatType(eIndex) != 0);
}
//

int CvUnit::trapAvoidanceUnitCombatTotal(UnitCombatTypes eCombatType) const
{
	int iAmount = m_pUnitInfo->getTrapAvoidanceUnitCombatType(eCombatType);

	iAmount += getExtraTrapAvoidanceUnitCombatType(eCombatType);

	return std::max(0,iAmount);
}

int CvUnit::getExtraTrapAvoidanceUnitCombatType(UnitCombatTypes eIndex) const
{
	FASSERT_BOUNDS(0, GC.getNumUnitCombatInfos(), eIndex);

	const UnitCombatKeyedInfo* info = findUnitCombatKeyedInfo(eIndex);

	return  info ? info->m_iExtraTrapAvoidanceUnitCombatType : 0;
}

void CvUnit::changeExtraTrapAvoidanceUnitCombatType(UnitCombatTypes eIndex, int iChange)
{
	FASSERT_BOUNDS(0, GC.getNumUnitCombatInfos(), eIndex);

	if (iChange != 0)
	{
		UnitCombatKeyedInfo* info = findOrCreateUnitCombatKeyedInfo(eIndex);

		info->m_iExtraTrapAvoidanceUnitCombatType += iChange;
	}
}

bool CvUnit::hasExtraTrapAvoidanceUnitCombatType(UnitCombatTypes eIndex) const
{
	return (getExtraTrapAvoidanceUnitCombatType(eIndex) != 0);
}

int CvUnit::trapTriggerUnitCombatTotal(UnitCombatTypes eCombatType) const
{
	int iAmount = m_pUnitInfo->getTrapTriggerUnitCombatType(eCombatType);

	iAmount += getExtraTrapTriggerUnitCombatType(eCombatType);

	return std::max(0,iAmount);
}

int CvUnit::getExtraTrapTriggerUnitCombatType(UnitCombatTypes eIndex) const
{
	FASSERT_BOUNDS(0, GC.getNumUnitCombatInfos(), eIndex);

	const UnitCombatKeyedInfo* info = findUnitCombatKeyedInfo(eIndex);

	return info ? info->m_iExtraTrapTriggerUnitCombatType : 0;
}

void CvUnit::changeExtraTrapTriggerUnitCombatType(UnitCombatTypes eIndex, int iChange)
{
	FASSERT_BOUNDS(0, GC.getNumUnitCombatInfos(), eIndex);

	if (iChange != 0)
	{
		UnitCombatKeyedInfo* info = findOrCreateUnitCombatKeyedInfo(eIndex);

		info->m_iExtraTrapTriggerUnitCombatType += iChange;
	}
}

bool CvUnit::hasExtraTrapTriggerUnitCombatType(UnitCombatTypes eIndex) const
{
	return (getExtraTrapTriggerUnitCombatType(eIndex) != 0);
}

bool CvUnit::isTrap() const
{
	return (trapNumTriggers() > 0);
}

bool CvUnit::isArmedTrap() const
{
	return (isTrap() && isArmed());
}

// pUnit is the unit setting the trap
void CvUnit::setTrap(CvUnit* pUnit)
{
	PROFILE_EXTRA_FUNC();
	m_bIsArmed = true;
	for (int iI = 0; iI < GC.getNumPromotionInfos(); iI++)
	{
		if (pUnit->hasTrapSetWithPromotion((PromotionTypes)iI)
		&& canAcquirePromotion((PromotionTypes)iI, PromotionRequirements::ForFree))
		{
			setHasPromotion((PromotionTypes)iI, true, true, false, false);
		}
	}
}

bool CvUnit::isArmed() const
{
	return m_bIsArmed || getImmobileTimer() > 0;
}

void CvUnit::doTrap(CvUnit* pUnit)
{
	PROFILE_EXTRA_FUNC();
	//pUnit is the unit moving onto the trap
	if (!isArmed())
	{
		return;
	}

	//Establish Base Trigger Chance, Avoidance, Disable and Immunities.
	bool bImmune = false;
	int iTriggerPercent = 0;
	int iTrapAvoidance = 0;
	int iTrapDisable = 0;
	int iTrapComplexity = trapComplexityTotal();
	UnitCombatTypes eUnitCombat = NO_UNITCOMBAT;

	for (int iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
	{
		if (isHasUnitCombat((UnitCombatTypes)iI))
		{
			eUnitCombat = (UnitCombatTypes)iI;
			if (pUnit->hasTrapImmunityUnitCombat(eUnitCombat))
			{
				bImmune = true;
			}
			if (pUnit->trapAvoidanceUnitCombatTotal(eUnitCombat) > iTrapAvoidance)
			{
				iTrapAvoidance = pUnit->trapAvoidanceUnitCombatTotal(eUnitCombat);
			}
			if (pUnit->trapDisableUnitCombatTotal(eUnitCombat) > iTrapDisable)
			{
				iTrapDisable = pUnit->trapDisableUnitCombatTotal(eUnitCombat);
			}
		}
		if (pUnit->isHasUnitCombat((UnitCombatTypes)iI))
		{
			eUnitCombat = (UnitCombatTypes)iI;
			if (trapTriggerUnitCombatTotal(eUnitCombat) > 0)
			{
				//Cumulative so that multiple factors can come into play programmed on the trap itself (size/volume in addition to a base amount)
				iTriggerPercent += trapTriggerUnitCombatTotal(eUnitCombat);
			}
		}
	}
	//final trigger chance is reduced by the avoidance ability
	iTriggerPercent -= iTrapAvoidance;

	//Establish % chance to disable: Ability to disable this type of trap minus the complexity factor of the trap (which can be as low as 0 for very easily disabled traps)
	iTrapDisable -= iTrapComplexity;
	bool bTrapDisabled = false;
	if (!isInvisible(pUnit->getTeam(),false,false))
	{
		//Step 1: Disable check
		if (iTrapDisable > 0)
		{
			if (GC.getGame().getSorenRandNum(100, "Trap Disable Check") < iTrapDisable)
			{
				bTrapDisabled = doTrapDisable(pUnit);
			}
		}
	}
	if (!bTrapDisabled)
	{
		//Step 1: Trigger check
		if (iTriggerPercent > 0)
		{
			if (GC.getGame().getSorenRandNum(100, "Trap Trigger Check") < iTriggerPercent)
			{
				doTrapTrigger(pUnit, bImmune);
			}
		}
	}
}

void CvUnit::doTrapTrigger(CvUnit* pUnit, bool bImmune)
{
	PROFILE_EXTRA_FUNC();
	CvWString szBuffer;
	int iTrapDmgMin = trapDamageMinTotal();
	int iTrapDmgMax = trapDamageMaxTotal();
	int iTrapDmg = 0;
	int iTrapDmgRange = iTrapDmgMax - iTrapDmgMin;
	changeNumTimesTriggered(1);
	int iDodge = pUnit->dodgeVSOpponentProbTotal(this);
	int iPrecision = precisionVSOpponentProbTotal(pUnit);
	int iArmor = 100 - pUnit->armorVSOpponentProbTotal(this);
	int iChanceToDodge = iDodge - iPrecision;
	if (!bImmune && iChanceToDodge > GC.getGame().getSorenRandNum(100, "Trap Dodge Check"))
	{
		//Trap deals damage, inflicts affliction, and/or nuclear effect
		//damage
		if (iTrapDmgMax > 0)
		{
			iTrapDmg = GC.getGame().getSorenRandNum(iTrapDmgRange, "Trap Damage Check");
			iTrapDmg += iTrapDmgMin;
			iTrapDmg *= iArmor;
			iTrapDmg /= 100;
			if (iTrapDmg > 0)
			{
				pUnit->changeDamage(iTrapDmg, getOwner());
				//message

				const CvWString szBuffer = gDLL->getText("TXT_KEY_MISC_TRAP_TRIGGERED_DAMAGE_SUFFERED", pUnit->getNameKey(), getNameKey(), iTrapDmg);
				AddDLLMessage(pUnit->getOwner(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_POSITIVE_DINK", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_RED(), getX(), getY());
				const CvWString szBuffer2 = gDLL->getText("TXT_KEY_MISC_TRAP_TRIGGERED_DAMAGE_INFLICTED", getNameKey(), pUnit->getNameKey(), iTrapDmg);
				AddDLLMessage(getOwner(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer2, "AS2D_POSITIVE_DINK", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_GREEN(), getX(), getY());
			}
		}
#ifdef OUTBREAKS_AND_AFFLICTIONS
		//afflict
		if (GC.getGame().isOption(GAMEOPTION_COMBAT_OUTBREAKS_AND_AFFLICTIONS))
		{
			for (int iI = 0; iI < GC.getNumPromotionLineInfos(); iI++)
			{
				if (GC.getPromotionLineInfo((PromotionLineTypes)iI).isAffliction())
				{
					if (hasAfflictOnAttackType((PromotionLineTypes)iI) && isAfflictOnAttackTypeMelee((PromotionLineTypes)iI))
					{
						const PromotionLineTypes eAfflictionLine = ((PromotionLineTypes)iI);
						const int iAfflictChance = getAfflictOnAttackTypeProbability(eAfflictionLine) - pUnit->fortitudeTotal() - pUnit->getUnitAfflictionTolerance(eAfflictionLine);
						const int iAfflictCheckResult = GC.getGame().getSorenRandNum(100, "Trap Affliction Check");
						if (iAfflictCheckResult < iAfflictChance)
						{
							pUnit->afflict(eAfflictionLine, false, this, true, iTrapDmg);
						}
					}
				}
			}
		}
#endif
		//nuclear
		if (nukeRange() == 0 && plot() != NULL)
		{
			nuke(getX(), getY(), true);
		}
	}

	if (trapNumTriggersRemaining() <= 0)
	{
		kill(false, getOwner());
	}
}

bool CvUnit::doTrapDisable(CvUnit* pUnit)
{
	if (!pUnit->isNoCapture() && m_pUnitInfo->getUnitCaptureType() != NO_UNIT)
	{
		setCapturingPlayer(pUnit->getOwner());
		setCapturingUnit(pUnit);
	}
	kill(false, pUnit->getOwner(), true);
	return true;
}

void CvUnit::changeHiddenNationalityCount(int iValue)
{
	m_iHiddenNationalityCount += iValue;
}

int CvUnit::getHiddenNationalityCount() const
{
	return m_iHiddenNationalityCount;
}

int CvUnit::getNoCaptureCount() const
{
	return m_iNoCaptureCount;
}

void CvUnit::changeNoCaptureCount(int iChange)
{
	m_iNoCaptureCount += iChange;
}

void CvUnit::makeWanted(const CvCity* pCity)
{
	PROFILE_EXTRA_FUNC();
	if (pCity == NULL)
	{
		return;
	}
	//Is now Wanted
	for (int iI = 0; iI < GC.getNumPromotionInfos(); iI++)
	{
		const PromotionTypes ePromotion = (PromotionTypes)iI;

		if (GC.getPromotionInfo(ePromotion).isSetOnInvestigated()
		&& canAcquirePromotion(ePromotion, PromotionRequirements::ForFree))
		{
			setHasPromotion(ePromotion, true, true, false, false);
			m_pPlayerInvestigated = pCity->getOwner();
			// This is something it has to manage on its own
			if (getGroup()->getNumUnits() > 1)
			{
				joinGroup(NULL);
			}
			//do message
			const CvWString szBuffer = gDLL->getText("TXT_KEY_MISC_INVESTIGATED_WANTED_RESULT", pCity->getNameKey());
			AddDLLMessage(pCity->getOwner(), false, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_POSITIVE_DINK", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_HIGHLIGHT_TEXT(), pCity->getX(), pCity->getY(), true, true);

			const CvWString szBuffer2 = gDLL->getText("TXT_KEY_MISC_INVESTIGATED_BECOME_WANTED", getNameKey(), pCity->getNameKey());
			AddDLLMessage(getOwner(), false, GC.getEVENT_MESSAGE_TIME(), szBuffer2, "AS2D_EXPOSED", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_RED(), pCity->getX(), pCity->getY(), true, true);
			return;
		}
	}
}

#ifdef OUTBREAKS_AND_AFFLICTIONS
int CvUnit::getDistanceAttackCommunicability(PromotionLineTypes eAfflictionLine) const
{
	PROFILE_EXTRA_FUNC();
	FASSERT_BOUNDS(0, GC.getNumPromotionLineInfos(), eAfflictionLine);

	const PromotionLineKeyedInfo* info = findPromotionLineKeyedInfo(eAfflictionLine);

	int iDistanceAttackCommunicability = (info == NULL ? 0 : info->m_iDistanceAttackCommunicability);

	for (int iI = 0; iI < m_pUnitInfo->getNumDistanceAttackCommunicabilityTypeChanges(); iI++)
	{
		if (m_pUnitInfo->getDistanceAttackCommunicabilityTypeChange(iI).eAfflictionLine == eAfflictionLine)
		{
			iDistanceAttackCommunicability += m_pUnitInfo->getDistanceAttackCommunicabilityTypeChange(iI).iChange;
		}
	}

	return iDistanceAttackCommunicability;
}

void CvUnit::changeDistanceAttackCommunicability(PromotionLineTypes eAfflictionLine, int iChange)
{
	FASSERT_BOUNDS(0, GC.getNumPromotionLineInfos(), eAfflictionLine);

	if (iChange != 0)
	{
		PromotionLineKeyedInfo* info = findOrCreatePromotionLineKeyedInfo(eAfflictionLine);

		info->m_iDistanceAttackCommunicability += iChange;
	}
}

void CvUnit::setDistanceAttackCommunicability(PromotionLineTypes eAfflictionLine, int iValue)
{
	FASSERT_BOUNDS(0, GC.getNumPromotionLineInfos(), eAfflictionLine);

	PromotionLineKeyedInfo* info = findOrCreatePromotionLineKeyedInfo(eAfflictionLine, iValue != 0);

	if (info != NULL)
	{
		info->m_iDistanceAttackCommunicability = iValue;
	}
}
#endif // OUTBREAKS_AND_AFFLICTIONS

void CvUnit::setCityOfOrigin(CvCity* pCity)
{
	m_iXOrigin = pCity->getX();
	m_iYOrigin = pCity->getY();

}

void CvUnit::clearCityOfOrigin()
{
	m_iXOrigin = INVALID_PLOT_COORD;
	m_iYOrigin = INVALID_PLOT_COORD;
}

CvCity* CvUnit::getCityOfOrigin() const
{
	const CvPlot* pPlot = GC.getMap().plotSorenINLINE(m_iXOrigin, m_iYOrigin);
	CvCity* pCity;
	if (pPlot != NULL)
	{
		pCity = pPlot->getPlotCity();
		if (pCity != NULL)
		{
			return pCity;
		}
	}
	return NULL;
}

bool CvUnit::isPromotionFromTrait(PromotionTypes ePromotion) const
{
	FASSERT_BOUNDS(0, GC.getNumPromotionInfos(), ePromotion);

	const PromotionKeyedInfo* info = findPromotionKeyedInfo(ePromotion);

	return info == NULL ? false : info->m_iPromotionFromTraitCount > 0;
}

void CvUnit::setPromotionFromTrait(PromotionTypes ePromotion, bool iChange)
{
	FASSERT_BOUNDS(0, GC.getNumPromotionInfos(), ePromotion);

	PromotionKeyedInfo* info = findOrCreatePromotionKeyedInfo(ePromotion, iChange != 0);

	if (info != NULL)
	{
		info->m_iPromotionFromTraitCount = iChange;
	}
}

bool CvUnit::isGatherHerd() const
{
	return (getGatherHerdCount() > 0);
}
int CvUnit::getGatherHerdCount() const
{
	int iTotal = getExtraGatherHerdCount();
	if (m_pUnitInfo->isGatherHerd())
	{
		iTotal++;
	}
	return iTotal;
}
int CvUnit::getExtraGatherHerdCount() const
{
	return m_iExtraGatherHerdCount;
}
void CvUnit::changeExtraGatherHerdCount(int iChange)
{
	m_iExtraGatherHerdCount += iChange;
}

void CvUnit::defineReligion()
{PROFILE_EXTRA_FUNC();
	//call this when a unitcombat that has a religion is processed in and for all units when the state religion is changed.
	//Check for dedicated faith by unit type, assign it and let it not be changeable unless the unit type changes
	if (!m_bIsReligionLocked)//purely meaning the unit has an overriding religious unitcombat in its base definition (like a missionary, crusader or hellsmouth dog would)
	{
		if (m_eReligionType == NO_RELIGION)
		{
			UnitCombatTypes eUnitCombat;

			for (int iI = -1; iI < m_pUnitInfo->getNumSubCombatTypes(); iI++)
			{
				if (iI > -1)
				{
					eUnitCombat = (UnitCombatTypes)m_pUnitInfo->getSubCombatType(iI);
				}
				else
				{
					eUnitCombat = (UnitCombatTypes)m_pUnitInfo->getUnitCombatType();

					if (eUnitCombat == NO_UNITCOMBAT) continue;
				}
				const ReligionTypes eOriginalCombatReligion = GC.getUnitCombatInfo(eUnitCombat).getReligion();

				if (eOriginalCombatReligion != NO_RELIGION)
				{
					m_eReligionType = eOriginalCombatReligion;
					m_bIsReligionLocked = true;
					break;
				}
			}
		}
		if (m_eReligionType == NO_RELIGION)
		{
			//if not locked by innate type, after changes in unitcombat process function we'll call this function IF the unitcombat has a religion.
			//This function is also called if the state religion changes so if we find a unit combat has defined m_eReligionType then we'll not bother with switching to the state religion so check here first
			bool bFound = false;
			for (int iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
			{
				if (isHasUnitCombat((UnitCombatTypes)iI))
				{
					const ReligionTypes eUnitCombatReligion = GC.getUnitCombatInfo((UnitCombatTypes)iI).getReligion();
					if (eUnitCombatReligion != NO_RELIGION)
					{
						m_eReligionType = eUnitCombatReligion; //Let's assume there's only going to be one of these on a unit ever - it only ever comes up if the unit isn't locked with a pre-defined one anyhow
						//and unitcombats that assign a religion should be rare to assign unless we are more advanced into the Ideas project where the city will assign its religion type to all units that it produces.
						//There could be promos that assign overriding religious types but we'll cross that bridge when we get there.
						bFound = true;
						break;//thus we stop at the first one we find
					}
				}
			}
			if (!bFound)
			{
				m_eReligionType = GET_PLAYER(getOwner()).getStateReligion();//NO_RELIGION is a perfectly satisfactory answer here.
			}
		}
	}
	//else do nothing - if the religion is locked we're done here.
}

ReligionTypes CvUnit::getReligion() const
{
	return m_eReligionType;
}

bool CvUnit::isWorker() const
{
	return m_worker != NULL;
}

UnitCompWorker* CvUnit::getWorkerComponent() const
{
	return m_worker;
}

void CvUnit::deselect(const bool bQuick)
{
	if (IsSelected())
	{
		if (gDLL->getInterfaceIFace()->getLengthSelectionList() > 1)
		{
			gDLL->getInterfaceIFace()->removeFromSelectionList(this);
		}
		else if (bQuick || GET_PLAYER(GC.getGame().getActivePlayer()).isOption(PLAYEROPTION_QUICK_MOVES))
		{
			GC.getGame().updateSelectionListInternal();
		}
	}
}

void CvUnit::forceInvalidCoordinates()
{
	m_iX = INVALID_PLOT_COORD;
	m_iY = INVALID_PLOT_COORD;
}

void CvUnit::doStarsign()
{
	// Do not give starsigns to units created from a unit split/merge action.
	if (GET_PLAYER(getOwner()).getSplittingUnit() != FFreeList::INVALID_INDEX
	|| GET_PLAYER(getOwner()).getBaseMergeSelectionUnit() != FFreeList::INVALID_INDEX
	|| GC.getGame().getSorenRandNum(49, "Seventh son of seventh son") > 0)
	{
		return;
	}
	const CvTeam& team = GET_TEAM(getTeam());
	if (team.isHasTech((TechTypes)GC.getDefineINT("STARSIGN_TECH_END"))
	|| !team.isHasTech((TechTypes)GC.getDefineINT("STARSIGN_TECH_START")))
	{
		return;
	}
	if (team.isHasTech((TechTypes)GC.getDefineINT("STARSIGN_TECH_NERF")))
	{
		if (GC.getGame().getSorenRandNum(4, "3/4 probability after Astronomy") == 0)
		{
			return;
		}
	}
	else if (!team.isHasTech((TechTypes)GC.getDefineINT("STARSIGN_TECH_BOOST")))
	{
		if (GC.getGame().getSorenRandNum(2, "1/2 probability before Astrology") > 0)
		{
			return;
		}
	}
	std::vector<PromotionTypes> starsigns;
	int iCount = 0;
	for (int iI = GC.getNumStarsigns() - 1; iI > -1; iI--)
	{
		const PromotionTypes ePromo = GC.getStarsign(iI);
		if (canKeepPromotion(ePromo, true))
		{
			starsigns.push_back(ePromo);
			iCount++;
		}
	}
	if (iCount == 0)
	{
		return;
	}
	const PromotionTypes ePromo = starsigns[GC.getGame().getSorenRandNum(iCount, "random pick")];

	setHasPromotion(ePromo, true, true);

	if (isHuman())
	{
		CvWString szBuffer;

		if (plot()->getPlotCity())
			szBuffer = gDLL->getText("TXT_KEY_MSG_STARSIGN_BUILD", plot()->getPlotCity()->getNameKey());
		else
			szBuffer = gDLL->getText("TXT_KEY_MSG_STARSIGN_CREATE");

		AddDLLMessage(
			getOwner(), false, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_POSITIVE_DINK",
			MESSAGE_TYPE_INFO, GC.getPromotionInfo(ePromo).getButton(),
			GC.getCOLOR_WHITE(), getX(), getY(), true, true
		);
	}
}


