// unit.cpp

#include "CvGameCoreDLL.h"
#include "CvArea.h"
#include "CvBuildingInfo.h"
#include "CvCity.h"
#include "CvEventReporter.h"
#include "CvGameAI.h"
#include "CvGlobals.h"
#include "CvImprovementInfo.h"
#include "CvInfos.h"
#include "CvMap.h"
#include "CvPlayerAI.h"
#include "CvPlot.h"
#include "CvPopupInfo.h"
#include "CvPython.h"
#include "CvSelectionGroup.h"
#include "CvTeamAI.h"
#include "CvUnit.h"
#include "CvUnitSelectionCriteria.h"
#include "CvViewport.h"
#include "CvDLLEngineIFaceBase.h"
#include "CvDLLInterfaceIFaceBase.h"
#include "CvDLLEntity.h"
#include "CvDLLEntityIFaceBase.h"
#include "CvDLLFAStarIFaceBase.h"
#include "CvDLLUtilityIFaceBase.h"
#include "CyPlot.h"
#include "CyUnit.h"
#ifdef USE_OLD_PATH_GENERATOR
#include "FAStarNode.h"
#endif

static CvEntity* g_dummyEntity = NULL;
static CvUnit*	 g_dummyUnit = NULL;
static int		 g_numEntities = 0;
static int		 g_dummyUsage = 0;
static bool		 g_bUseDummyEntities = false;

//	static buffers allocated once and used during read and write only
int*	CvUnit::g_paiTempPromotionFreeCount = NULL;
int*	CvUnit::g_paiTempAfflictOnAttackCount = NULL;
int*	CvUnit::g_paiTempCureAfflictionCount = NULL;
int*	CvUnit::g_paiTempCureAfflictionTypeCount = NULL;
int*	CvUnit::g_paiTempAfflictionLineCount = NULL;
int*	CvUnit::g_paiTempAfflictionTurnCount = NULL;
int*	CvUnit::g_paiTempAfflictionTurnTypeCount = NULL;
int*	CvUnit::g_paiTempAfflictionHitCount = NULL;
int*	CvUnit::g_paiTempAfflictionTolerance = NULL;
int*	CvUnit::g_paiTempTrapImmunityUnitCombatCount = NULL;
int*	CvUnit::g_paiTempTargetUnitCombatCount = NULL;
int*	CvUnit::g_paiTempExtraTrapDisableUnitCombatType = NULL;
int*	CvUnit::g_paiTempExtraTrapAvoidanceUnitCombatType = NULL;
int*	CvUnit::g_paiTempExtraTrapTriggerUnitCombatType = NULL;
int*	CvUnit::g_paiTempAfflictionTypeTolerance = NULL;
int*	CvUnit::g_paiTempFortitudeModifierTypeAmount = NULL;
int*	CvUnit::g_paiTempFortitudeModifierAmount = NULL;
int*	CvUnit::g_paiTempTrapSetWithPromotionCount = NULL;
int*	CvUnit::g_paiTempPromotionFromTraitCount = NULL;
int*	CvUnit::g_paiTempAfflictOnAttackTypeProbability = NULL;
int*	CvUnit::g_paiTempAfflictOnAttackTypeCount = NULL;
int*	CvUnit::g_paiTempAfflictOnAttackTypeImmediateCount = NULL;
int*	CvUnit::g_paiTempAfflictOnAttackTypeMeleeCount = NULL;
int*	CvUnit::g_paiTempAfflictOnAttackTypeDistanceCount = NULL;
int*	CvUnit::g_paiTempAfflictOnAttackTypeAttemptedCount = NULL;
int*	CvUnit::g_paiTempDistanceAttackCommunicability = NULL;
bool*	CvUnit::g_pabTempValidBuildUp = NULL;
//Team Project (4)
//WorkRateMod
//ls612: Terrain Work Modifiers
int*	CvUnit::g_paiTempExtraBuildWorkPercent = NULL;
int*	CvUnit::g_paiTempExtraUnitCombatModifier = NULL;
bool*	CvUnit::g_pabTempHasPromotion = NULL;
bool*	CvUnit::g_pabTempHasUnitCombat = NULL;
int*	CvUnit::g_paiTempSubCombatTypeCount = NULL;
int*	CvUnit::g_paiTempOngoingTrainingCount = NULL;
int*	CvUnit::g_paiTempRemovesUnitCombatTypeCount = NULL;
int*	CvUnit::g_paiTempExtraFlankingStrengthbyUnitCombatType = NULL;
int*	CvUnit::g_paiTempExtraWithdrawVSUnitCombatType = NULL;
int*	CvUnit::g_paiTempExtraPursuitVSUnitCombatType = NULL;
int*	CvUnit::g_paiTempExtraRepelVSUnitCombatType = NULL;
int*	CvUnit::g_paiTempExtraKnockbackVSUnitCombatType = NULL;
int*	CvUnit::g_paiTempExtraPunctureVSUnitCombatType = NULL;
int*	CvUnit::g_paiTempExtraArmorVSUnitCombatType = NULL;
int*	CvUnit::g_paiTempExtraDodgeVSUnitCombatType = NULL;
int*	CvUnit::g_paiTempExtraPrecisionVSUnitCombatType = NULL;
int*	CvUnit::g_paiTempExtraCriticalVSUnitCombatType = NULL;
int*	CvUnit::g_paiTempExtraRoundStunVSUnitCombatType = NULL;
int*	CvUnit::g_paiTempHealUnitCombatTypeVolume = NULL;
int*	CvUnit::g_paiTempHealUnitCombatTypeAdjacentVolume = NULL;
int*	CvUnit::g_paiTempHealAsDamage = NULL;
bool	CvUnit::m_staticsInitialized = false;

bool CvUnit::isDummyEntity(const CvEntity* entity)
{
	return (entity == g_dummyEntity);
}

bool CvUnit::isRealEntity(const CvEntity* entity)
{
	return (entity != NULL && entity != g_dummyEntity);
}

// Public Functions...
#pragma warning( disable : 4355 )
CvUnit::CvUnit(bool bIsDummy) : m_GameObject(this),
m_Properties(this)
{
	m_aiExtraDomainModifier = new int[NUM_DOMAIN_TYPES];
	m_aiExtraVisibilityIntensity = new int[GC.getNumInvisibleInfos()];
	m_aiExtraInvisibilityIntensity = new int[GC.getNumInvisibleInfos()];
	m_aiExtraVisibilityIntensityRange = new int[GC.getNumInvisibleInfos()];
	m_aiExtraVisibilityIntensitySameTile = new int[GC.getNumInvisibleInfos()];
	m_aiNegatesInvisibleCount = new int[GC.getNumInvisibleInfos()];
	m_aExtraInvisibleTerrains.clear();
	m_aExtraInvisibleFeatures.clear();
	m_aExtraInvisibleImprovements.clear();
	m_aExtraVisibleTerrains.clear();
	m_aExtraVisibleFeatures.clear();
	m_aExtraVisibleImprovements.clear();
	m_aExtraVisibleTerrainRanges.clear();
	m_aExtraVisibleFeatureRanges.clear();
	m_aExtraVisibleImprovementRanges.clear();

	m_iMaxMoveCacheTurn = -1;

	if (g_dummyUnit == NULL && !bIsDummy)
	{
		g_dummyUnit = new CvUnitAI(true);

		if (GC.getENABLE_DYNAMIC_UNIT_ENTITIES())
		{
			g_bUseDummyEntities = true;
		}
	}

	if (!g_bUseDummyEntities)
	{
		CvDLLEntity::createUnitEntity(this); // create and attach entity to unit
	}
	else if (g_dummyEntity == NULL)
	{
		CvDLLEntity::createUnitEntity(this); // create and attach entity to unit

		g_dummyEntity = getEntity();
	}
	else
	{
		setEntity(g_dummyEntity);
		g_dummyUsage++;
	}

	bGraphicsSetup = false;

	reset(0, NO_UNIT, NO_PLAYER, true);

	if (!m_staticsInitialized)
	{
		//	Allocate static buffers to be used during read and write
		g_paiTempPromotionFreeCount = new int[GC.getNumPromotionInfos()];
		g_paiTempAfflictOnAttackCount = new int[GC.getNumPromotionInfos()];
		g_paiTempCureAfflictionCount = new int[GC.getNumPromotionInfos()];
		g_paiTempCureAfflictionTypeCount = new int[GC.getNumPromotionLineInfos()];
		g_paiTempAfflictionLineCount = new int[GC.getNumPromotionLineInfos()];
		g_paiTempAfflictionTurnCount = new int[GC.getNumPromotionInfos()];
		g_paiTempAfflictionTurnTypeCount = new int[GC.getNumPromotionLineInfos()];
		g_paiTempAfflictionHitCount = new int[GC.getNumPromotionInfos()];
		g_paiTempAfflictionTolerance = new int[GC.getNumPromotionInfos()];
		g_paiTempTrapImmunityUnitCombatCount = new int[GC.getNumUnitCombatInfos()];
		g_paiTempTargetUnitCombatCount = new int[GC.getNumUnitCombatInfos()];
		g_paiTempExtraTrapDisableUnitCombatType = new int[GC.getNumUnitCombatInfos()];
		g_paiTempExtraTrapAvoidanceUnitCombatType = new int[GC.getNumUnitCombatInfos()];
		g_paiTempExtraTrapTriggerUnitCombatType = new int[GC.getNumUnitCombatInfos()];
		g_paiTempAfflictionTypeTolerance = new int[GC.getNumPromotionLineInfos()];
		g_paiTempFortitudeModifierTypeAmount = new int[GC.getNumPromotionInfos()];
		g_paiTempFortitudeModifierAmount = new int[GC.getNumPromotionLineInfos()];
		g_paiTempTrapSetWithPromotionCount = new int[GC.getNumPromotionInfos()];
		g_paiTempPromotionFromTraitCount = new int [GC.getNumPromotionInfos()];
		g_paiTempAfflictOnAttackTypeProbability = new int[GC.getNumPromotionLineInfos()];
		g_paiTempAfflictOnAttackTypeCount = new int[GC.getNumPromotionLineInfos()];
		g_paiTempAfflictOnAttackTypeImmediateCount = new int[GC.getNumPromotionLineInfos()];
		g_paiTempAfflictOnAttackTypeMeleeCount = new int[GC.getNumPromotionLineInfos()];
		g_paiTempAfflictOnAttackTypeDistanceCount = new int[GC.getNumPromotionLineInfos()];
		g_paiTempAfflictOnAttackTypeAttemptedCount = new int[GC.getNumPromotionLineInfos()];
		g_paiTempDistanceAttackCommunicability = new int[GC.getNumPromotionLineInfos()];
		g_pabTempValidBuildUp = new bool[GC.getNumPromotionLineInfos()];
		g_paiTempExtraBuildWorkPercent = new int [GC.getNumBuildInfos()];
		g_paiTempExtraUnitCombatModifier = new int[GC.getNumUnitCombatInfos()];
		g_pabTempHasPromotion = new bool[GC.getNumPromotionInfos()];
		g_pabTempHasUnitCombat = new bool[GC.getNumUnitCombatInfos()];
		g_paiTempSubCombatTypeCount = new int[GC.getNumUnitCombatInfos()];
		g_paiTempOngoingTrainingCount = new int[GC.getNumUnitCombatInfos()];
		g_paiTempRemovesUnitCombatTypeCount = new int[GC.getNumUnitCombatInfos()];
		g_paiTempExtraFlankingStrengthbyUnitCombatType = new int[GC.getNumUnitCombatInfos()];
		g_paiTempExtraWithdrawVSUnitCombatType = new int[GC.getNumUnitCombatInfos()];
		g_paiTempExtraPursuitVSUnitCombatType = new int[GC.getNumUnitCombatInfos()];
		g_paiTempExtraRepelVSUnitCombatType = new int[GC.getNumUnitCombatInfos()];
		g_paiTempExtraKnockbackVSUnitCombatType = new int[GC.getNumUnitCombatInfos()];
		g_paiTempExtraPunctureVSUnitCombatType = new int[GC.getNumUnitCombatInfos()];
		g_paiTempExtraArmorVSUnitCombatType = new int[GC.getNumUnitCombatInfos()];
		g_paiTempExtraDodgeVSUnitCombatType = new int[GC.getNumUnitCombatInfos()];
		g_paiTempExtraPrecisionVSUnitCombatType = new int[GC.getNumUnitCombatInfos()];
		g_paiTempExtraCriticalVSUnitCombatType = new int[GC.getNumUnitCombatInfos()];
		g_paiTempExtraRoundStunVSUnitCombatType = new int[GC.getNumUnitCombatInfos()];
		g_paiTempHealUnitCombatTypeVolume = new int[GC.getNumUnitCombatInfos()];
		g_paiTempHealUnitCombatTypeAdjacentVolume = new int[GC.getNumUnitCombatInfos()];
		g_paiTempHealAsDamage = new int[GC.getNumUnitCombatInfos()];

		m_staticsInitialized = true;
	}
}


CvUnit::~CvUnit()
{
	if (!isUsingDummyEntities())
	{
		// Don't need to remove entity when the app is shutting down, or crash can occur
		if (!gDLL->GetDone() && GC.IsGraphicsInitialized())
		{
			gDLL->getEntityIFace()->RemoveUnitFromBattle(this);
			CvDLLEntity::removeEntity(); // remove entity from engine
		}
		CvDLLEntity::destroyEntity(); // delete CvUnitEntity and detach from us
	}
	SAFE_DELETE_ARRAY(m_aiExtraDomainModifier);
	SAFE_DELETE_ARRAY(m_aiExtraVisibilityIntensity);
	SAFE_DELETE_ARRAY(m_aiExtraInvisibilityIntensity);
	SAFE_DELETE_ARRAY(m_aiExtraVisibilityIntensityRange);
	SAFE_DELETE_ARRAY(m_aiExtraVisibilityIntensitySameTile);
	SAFE_DELETE_ARRAY(m_aiNegatesInvisibleCount);
	SAFE_DELETE(m_commander);
	SAFE_DELETE(m_worker);
}


bool CvUnit::isUsingDummyEntities() const
{
	const CvEntity* entity = getEntity();

	return entity != NULL && g_dummyEntity == entity;
}

void CvUnit::reloadEntity(bool bForceLoad)
{
	const bool bNeedsRealEntity =
	(
		!g_bUseDummyEntities || bForceLoad
		||
		plot() != NULL && plot()->isActiveVisible(false)
		&&
		(plot()->getCenterUnit() == this || getOwner() == GC.getGame().getActivePlayer())
	);

	//OutputDebugString(CvString::format("reloadEntity for %08lx\n", this).c_str());
	if ( !IsSelected() )
	{
		if ( !isUsingDummyEntities() ) //&& !bNeedsRealEntity )
		{
			//destroy old entity
			if (!gDLL->GetDone() && GC.IsGraphicsInitialized())						// don't need to remove entity when the app is shutting down, or crash can occur
			{
				gDLL->getEntityIFace()->RemoveUnitFromBattle(this);
				CvDLLEntity::removeEntity();		// remove entity from engine
			}

			CvDLLEntity::destroyEntity();			// delete CvUnitEntity and detach from us
			g_numEntities--;

			setEntity(NULL);
		}
		else if ( isUsingDummyEntities() && bNeedsRealEntity )
		{
			g_dummyUsage--;

			setEntity(NULL);
		}

		if ( getEntity() == NULL )
		{
			if ( g_bUseDummyEntities )
			{
				if ( bNeedsRealEntity )
				{
					//create new one
					CvDLLEntity::createUnitEntity(this);		// create and attach entity to unit
					g_numEntities++;

					bGraphicsSetup = false;
				}
				else
				{
					setEntity(g_dummyEntity);
					g_dummyUsage++;
				}

				//	Log every now and again in non final release builds
				if ( g_numEntities%100 == 0 )
				{
					OutputDebugString(CvString::format("Dummy unit entity usage: %d, real %d\n", g_dummyUsage, g_numEntities).c_str());
				}
			}
			else if ( plot() != NULL ) //create new one
			{
				CvDLLEntity::createUnitEntity(this);		// create and attach entity to unit
				bGraphicsSetup = false;
			}
		}

		if ( !bGraphicsSetup && bNeedsRealEntity && plot() != NULL )
		{
			setupGraphical();

			bGraphicsSetup = true;
		}

	}
	else
	{
		OutputDebugString("Reload of selected unit\n");
	}
}

void CvUnit::changeIdentity(UnitTypes eUnit)
{
	reset(getID(), eUnit, getOwner(), false, true);
	//	Same id is now a differnt unit - make sure no old cached path info
	//	gets used for it
	CvPlot::NextCachePathEpoch();
}

void CvUnit::init(int iID, UnitTypes eUnit, UnitAITypes eUnitAI, PlayerTypes eOwner, int iX, int iY, DirectionTypes eFacingDirection, int iBirthmark)
{
	FASSERT_BOUNDS(0, GC.getNumUnitInfos(), eUnit);

	//	If the current viewport is not yet initialized center it on the first unit created for the active player
	if (GC.getGame().getActivePlayer() == eOwner
	&& GC.getCurrentViewport()->getState() == VIEWPORT_MODE_UNINITIALIZED
	&& UNIT_BIRTHMARK_TEMP_UNIT != iBirthmark)
	{
		GC.getCurrentViewport()->setOffsetToShow(iX, iY);
	}
	//--------------------------------
	// Init saved data
	reset(iID, eUnit, eOwner);

	if (eOwner != NO_PLAYER && eUnitAI == UNITAI_SUBDUED_ANIMAL)
	{
		GET_PLAYER(eOwner).NoteAnimalSubdued();
	}
	// Koshling -  moved this earlier to get unitAI set up so that
	// constraint checking on the unitAI can work more uniformly
	AI_init(eUnitAI, iBirthmark);

	if (eFacingDirection == NO_DIRECTION)
		m_eFacingDirection = DIRECTION_SOUTH;
	else m_eFacingDirection = eFacingDirection;

	//--------------------------------
	// Init containers

	//--------------------------------
	// Init pre-setup() data
	//GC.getGame().logOOSSpecial(13, getID(), iX, iY);
	setXY(iX, iY, false, true, false, false, true);

	if (plot()->getPlotCity() != NULL)
	{
		setCityOfOrigin(plot()->getPlotCity());
	}

	//TB OOS fix - POSSIBLE that this represents a fix but I consider it a longshot since they should really mean the same thing (-1)
	if (getGroup() == NULL)
	{
		::MessageBox(
			NULL, getGroupID() == FFreeList::INVALID_INDEX ?
				"Unit with NULL group ID after set position in init\n"
				:
				"Unit with no group after set position in init\n",
			"CvGameCoreDLL Diagnostics", MB_OK
		);
	}
	// ! TB

	if (!isTempUnit())
	{
		if (m_pUnitInfo->getNumBuilds() > 0)
		{
			m_worker = new UnitCompWorker();
		}
		const int iNumNames = m_pUnitInfo->getNumUnitNames();

		if (GC.getGame().getUnitCreatedCount(getUnitType()) < iNumNames)
		{
			const int iOffset = GC.getGame().getSorenRandNum(iNumNames, "Unit name selection");

			for (int iI = 0; iI < iNumNames; iI++)
			{
				CvWString szName = gDLL->getText(m_pUnitInfo->getUnitNames((iI + iOffset) % iNumNames));

				if (!GC.getGame().isGreatPersonBorn(szName))
				{
					setName(szName);
					GC.getGame().addGreatPersonBornName(szName);
					break;
				}
			}
		}
		setGameTurnCreated(GC.getGame().getGameTurn());
		calcUpkeep100(); // This updates total upkeep on the player level too

		GC.getGame().incrementUnitCreatedCount(eUnit);
		GET_PLAYER(getOwner()).changeUnitCount(eUnit, 1);

		if (m_pUnitInfo->getNukeRange() != -1)
		{
			GET_PLAYER(getOwner()).changeNumNukeUnits(1);
		}

		if (m_pUnitInfo->isMilitarySupport())
		{
			GET_PLAYER(getOwner()).changeNumMilitaryUnits(1);
		}

		doSetUnitCombats();
		doSetFreePromotions(true);
		doSetDefaultStatuses();
		if (GC.getGame().isOption(GAMEOPTION_SIZE_MATTERS))
		{
			setSMValues();

			// if unit doesn't have a group rank, it doesn't count as a SM unit at all
			if (groupRank() > 0)
			{
				GET_PLAYER(getOwner()).changeUnitCountSM(eUnit, intPow(3, groupRank()-1));
			}
		}
		else
		{
			GET_PLAYER(getOwner()).changeAssets(m_pUnitInfo->getAssetValue());
			GET_PLAYER(getOwner()).changeUnitPower(m_pUnitInfo->getPowerValue());
		}
		//--------------------------------
		// Init non-saved data
		setupGraphical();

		//--------------------------------
		// Init other game data
		plot()->updateCenterUnit();

		plot()->setFlagDirty(true);

		if (getDomainType() == DOMAIN_LAND && baseCombatStr() > 0
		&& (GC.getGame().getBestLandUnit() == NO_UNIT || baseCombatStrNonGranular() > GC.getGame().getBestLandUnitCombat()))
		{
			GC.getGame().setBestLandUnit(getUnitType());
		}

		if (getOwner() == GC.getGame().getActivePlayer())
		{
			gDLL->getInterfaceIFace()->setDirty(GameData_DIRTY_BIT, true);
		}

		if (isWorldUnit(eUnit))
		{
			for (int iI = 0; iI < MAX_PLAYERS; iI++)
			{
				if (GET_PLAYER((PlayerTypes)iI).isAlive())
				{

					if (GET_TEAM(getTeam()).isHasMet(GET_PLAYER((PlayerTypes)iI).getTeam()))
					{
						AddDLLMessage(
							(PlayerTypes) iI, false, GC.getEVENT_MESSAGE_TIME(),
							gDLL->getText("TXT_KEY_MISC_SOMEONE_CREATED_UNIT", GET_PLAYER(getOwner()).getNameKey(), getNameKey()),
							"AS2D_WONDER_UNIT_BUILD", MESSAGE_TYPE_MAJOR_EVENT, getButton(),
							GC.getCOLOR_UNIT_TEXT(), getX(), getY(), true, true
						);
					}
					else
					{
						AddDLLMessage(
							(PlayerTypes) iI, false, GC.getEVENT_MESSAGE_TIME(),
							gDLL->getText("TXT_KEY_MISC_UNKNOWN_CREATED_UNIT", getNameKey()),
							"AS2D_WONDER_UNIT_BUILD", MESSAGE_TYPE_MAJOR_EVENT, getButton(),
							GC.getCOLOR_UNIT_TEXT()
						);
					}
				}
			}
			GC.getGame().addReplayMessage(
				REPLAY_MESSAGE_MAJOR_EVENT, getOwner(),
				gDLL->getText("TXT_KEY_MISC_SOMEONE_CREATED_UNIT", GET_PLAYER(getOwner()).getNameKey(), getNameKey()),
				getX(), getY(), GC.getCOLOR_UNIT_TEXT()
			);
		}
		setGGExperienceEarnedTowardsType();

		if (GC.getGame().isOption(GAMEOPTION_HIDE_AND_SEEK))
		{
			setHasAnyInvisibility();
		}
		establishBuildups();

		CvEventReporter::getInstance().unitCreated(this);
	}
}


// FUNCTION: reset()
// Initializes data members that are serialized.
void CvUnit::reset(int iID, UnitTypes eUnit, PlayerTypes eOwner, bool bConstructorCall, bool bIdentityChange)
{
	clearCityOfOrigin();

	m_iHealUnitCombatCount = 0;

	m_iDCMBombRange = 0;
	m_iDCMBombAccuracy = 0;

	m_iID = iID;
	if (!bIdentityChange)
	{
		m_iGroupID = FFreeList::INVALID_INDEX;
	}
	m_iHotKeyNumber = -1;
	m_iX = INVALID_PLOT_COORD;
	m_iY = INVALID_PLOT_COORD;
	m_iLastMoveTurn = 0;
	m_iReconX = INVALID_PLOT_COORD;
	m_iReconY = INVALID_PLOT_COORD;
	m_iGameTurnCreated = 0;
	m_iDamage = 0;
	m_iMoves = 0;
	m_iExperience = 0;
	m_iLevel = 1;
	m_iCargo = 0;
	m_iSMCargo = 0;
	m_iAttackPlotX = INVALID_PLOT_COORD;
	m_iAttackPlotY = INVALID_PLOT_COORD;
	m_iCombatTimer = 0;
	m_iCombatFirstStrikes = 0;
	m_iFortifyTurns = 0;
	m_iBuildUpTurns = 0;
	m_iBlitzCount = 0;
	m_iRBombardForceAbilityCount = 0;
	m_iAmphibCount = 0;
	m_iRiverCount = 0;
	m_iEnemyRouteCount = 0;
	m_iAlwaysHealCount = 0;
	m_iHillsDoubleMoveCount = 0;
	m_iImmuneToFirstStrikesCount = 0;
	m_iAlwaysInvisibleCount = 0;

	m_iDefensiveVictoryMoveCount = 0;
	m_iFreeDropCount = 0;
	m_iOffensiveVictoryMoveCount = 0;

	m_iOneUpCount = 0;
	m_iPillageCultureCount = 0;
	m_iPillageEspionageCount = 0;
	m_iPillageMarauderCount = 0;
	m_iPillageOnMoveCount = 0;
	m_iPillageOnVictoryCount = 0;
	m_iPillageResearchCount = 0;
	m_iAirCombatLimitChange = 0;
	m_iCelebrityHappy = 0;
	m_iCollateralDamageLimitChange = 0;
	m_iCollateralDamageMaxUnitsChange = 0;
	m_iCombatLimitChange = 0;
	m_iExtraDropRange = 0;

	m_iSurvivorChance = 0;
	m_iVictoryAdjacentHeal = 0;
	m_iVictoryHeal = 0;
	m_iVictoryStackHeal = 0;

	m_iExtraVisibilityRange = 0;
	m_iExtraMoves = 0;
	m_iExtraMoveDiscount = 0;
	m_iExtraAirRange = 0;
	m_iExtraIntercept = 0;
	m_iExtraEvasion = 0;
	m_iExtraFirstStrikes = 0;
	m_iExtraChanceFirstStrikes = 0;
	m_iExtraWithdrawal = 0;
	//TB Combat Mods Begin
	m_iExtraAttackCombatModifier = 0;
	m_iExtraDefenseCombatModifier = 0;
	m_iExtraPursuit = 0;
	m_iExtraEarlyWithdraw = 0;
	m_iExtraVSBarbs = 0;
	m_iExtraReligiousCombatModifier = 0;
	m_iExtraArmor = 0;
	m_iExtraPuncture = 0;
	m_iExtraOverrun = 0;
	m_iExtraRepel = 0;
	m_iExtraFortRepel = 0;
	m_iExtraRepelRetries = 0;
	m_iExtraUnyielding = 0;
	m_iExtraKnockback = 0;
	m_iExtraKnockbackRetries = 0;
	m_iStampedeCount = 0;
	m_iAttackOnlyCitiesCount = 0;
	m_iIgnoreNoEntryLevelCount = 0;
	m_iIgnoreZoneofControlCount = 0;
	m_iFliesToMoveCount = 0;
	m_iExtraStrAdjperRnd = 0;
	m_iExtraStrAdjperAtt = 0;
	m_iExtraStrAdjperDef = 0;
	m_iExtraWithdrawAdjperAtt = 0;
	m_iExtraUnnerve = 0;
	m_iExtraEnclose = 0;
	m_iExtraLunge = 0;
	m_iExtraDynamicDefense = 0;
	m_iExtraStrength = 0;
	m_iSMStrength = 0;
	m_iAnimalIgnoresBordersCount = 0;
	m_iOnslaughtCount = 0;
	m_iExtraFortitude = 0;
#ifdef STRENGTH_IN_NUMBERS
	m_iExtraFrontSupportPercent = 0;
	m_iExtraShortRangeSupportPercent = 0;
	m_iExtraMediumRangeSupportPercent = 0;
	m_iExtraLongRangeSupportPercent = 0;
	m_iExtraFlankSupportPercent = 0;
	m_iSupportCount = 0;
	m_iAttackFromPlotX = INVALID_PLOT_COORD;
	m_iAttackFromPlotY = INVALID_PLOT_COORD;
#endif // STRENGTH_IN_NUMBERS
	m_iExtraDodgeModifier = 0;
	m_iExtraPrecisionModifier = 0;
	m_iExtraPowerShots = 0;
	m_iExtraPowerShotCombatModifier = 0;
	m_iExtraPowerShotPunctureModifier = 0;
	m_iExtraPowerShotPrecisionModifier = 0;
	m_iExtraPowerShotCriticalModifier = 0;
	m_iExtraCriticalModifier = 0;
	m_iExtraEndurance = 0;
	m_iColdDamage = 0;
	m_iDealColdDamageCount = 0;
	m_iColdImmuneCount = 0;
	m_iCombatPowerShots = 0;
	m_iCombatKnockbacks = 0;
	m_iCombatRepels = 0;
	m_iExtraRoundStunProb = 0;
	m_iCombatStuns = 0;
	m_iExtraPoisonProbabilityModifier = 0;
	m_iRetrainsAvailable = 0;
	m_iQualityBaseTotal = 0;
	m_iGroupBaseTotal = 0;
	m_iSizeBaseTotal = 0;
	m_iExtraQuality = 0;
	m_iExtraGroup = 0;
	m_iExtraSize = 0;
	m_iSMCargoVolume = 0;
	m_iSMExtraCargoVolume = 0;
	m_iSMCargoVolumeModifier = 0;
	m_iCannotMergeSplitCount = 0;

	m_iExtraCaptureProbabilityModifier = 0;
	m_iExtraCaptureResistanceModifier = 0;

	m_iExtraBreakdownChance = 0;
	m_iExtraBreakdownDamage = 0;
	m_iExtraTaunt = 0;
	m_iExtraCombatModifierPerSizeMore = 0;
	m_iExtraCombatModifierPerSizeLess = 0;
	m_iExtraCombatModifierPerVolumeMore = 0;
	m_iExtraCombatModifierPerVolumeLess = 0;
	m_iExtraMaxHP = 0;
	m_iExtraStrengthModifier = 0;
	m_iExtraDamageModifier = 0;
	m_iExtraUpkeep100 = 0;
	m_iUpkeepModifier = 0;
	m_iUpkeepMultiplierSM = 0;
	m_iUpkeep100 = 0;
	m_iSMAssetValue = 0;
	m_iSMPowerValue = 0;
	m_iSMHPValue = 0;
	m_iExtraRBombardDamage = 0;
	m_iExtraRBombardDamageLimit = 0;
	m_iExtraRBombardDamageMaxUnits = 0;
	m_iExtraDCMBombRange = 0;
	m_iExtraDCMBombAccuracy = 0;
	m_iBaseRBombardDamage = 0;
	m_iBaseRBombardDamageLimit = 0;
	m_iBaseRBombardDamageMaxUnits = 0;
	m_iBaseDCMBombRange = 0;
	m_iBaseDCMBombAccuracy = 0;
	m_iBombardDirectCount = 0;
	//TB Combat Mods End
	m_iExtraCollateralDamage = 0;
	m_iExtraBombardRate = 0;
	m_iSMBombardRate = 0;
	m_iSMAirBombBaseRate = 0;
	m_iSMBaseWorkRate = 0;
	m_iSMRevoltProtection = 0;
	m_iExtraEnemyHeal = 0;
	m_iExtraNeutralHeal = 0;
	m_iExtraFriendlyHeal = 0;
	m_iSameTileHeal = 0;
	m_iAdjacentTileHeal = 0;
	m_iExtraCombatPercent = 0;
	m_iExtraCityAttackPercent = 0;
	m_iExtraCityDefensePercent = 0;
	m_iExtraHillsAttackPercent = 0;
	m_iExtraHillsDefensePercent = 0;

	m_iRevoltProtection = 0;
	m_iCollateralDamageProtection = 0;
	m_iPillageChange = 0;
	m_iUpgradeDiscount = 0;
	m_iExperiencePercent = 0;
	m_iKamikazePercent = 0;
	m_eFacingDirection = DIRECTION_SOUTH;
	m_iImmobileTimer = 0;

	m_bCanRespawn = false; // Koshling - intentionally not saved - m_bCanrespawn should never persist in saves
	// as it is used only within a combat round and set upon unit death IF the unit has outstanding oneUpCount.
	// In some circumstances an autosave can save a state where the unit has just been respawned,
	// but m_bCanRespawn has not yet been reset at the start of the next turn, which leaves it bugged in the next turn's combat.

	m_bSurvivor = false;
	m_bMadeAttack = false;
	//TB Combat Mods (Att&DefCounters)
	m_iRoundCount = 0;
	m_iAttackCount = 0;
	m_iDefenseCount = 0;
	//TB Combat Mods end
	m_bMadeInterception = false;
	m_bPromotionReady = false;
	m_bDeathDelay = false;
	m_bCombatFocus = false;
	m_bInfoBarDirty = false;
	m_bBlockading = false;
	m_bAirCombat = false;
	m_bHasBuildUp = false;
	m_bInhibitMerge = false;
	m_bInhibitSplit = false;
	m_bIsBuildUp = false;
	m_bIsReligionLocked = false;

	m_iCanMovePeaksCount = 0;
	// Koshling - enhanced mountaineering mode to differentiate between ability to move through
	// mountains, and ability to lead a stack through mountains
	m_iCanLeadThroughPeaksCount = 0;

	if (eUnit != NO_UNIT)
	{
		m_movementCharacteristicsHash = GC.getUnitInfo(eUnit).getZobristValue();
	}

	m_iSleepTimer = 0;
	//@MOD Commanders: reset parameters
	m_iCommanderID = -1;
	m_iCommanderCacheTurn = -1;
	m_eOriginalOwner = eOwner;
	m_eNewDomainCargo = NO_DOMAIN;
	m_eNewSpecialCargo = NO_SPECIALUNIT;
	m_eNewSMSpecialCargo = NO_SPECIALUNIT;
	m_eNewSMNotSpecialCargo = NO_SPECIALUNIT;
	m_eSpecialUnit = NO_SPECIALUNIT;
	m_eSleepType = NO_MISSION;
	m_iZoneOfControlCount = 0;
	m_iExcileCount = 0;
	m_iPassageCount = 0;
	m_iNoNonOwnedCityEntryCount = 0;
	m_iBarbCoExistCount = 0;
	m_iBlendIntoCityCount = 0;
	m_iUpgradeAnywhereCount = 0;
	m_bAutoPromoting = false;
	m_bAutoUpgrading = false;
	m_iHiddenNationalityCount = 0;
	m_bHasHNCapturePromotion = false;
	m_bHasAnyInvisibility = false;
	m_bRevealed = false;
	m_shadowUnit.reset();
	m_eDesiredDiscoveryTech = NO_TECH;

	m_eOwner = eOwner;
	m_eCapturingPlayer = NO_PLAYER;
	m_eUnitType = eUnit;
	m_eReligionType = NO_RELIGION;
	m_pUnitInfo = (NO_UNIT != m_eUnitType) ? &GC.getUnitInfo(m_eUnitType) : NULL;
	m_iBaseCombat = (NO_UNIT != m_eUnitType) ? m_pUnitInfo->getCombat() : 0;
	m_eLeaderUnitType = NO_UNIT;
	m_eGGExperienceEarnedTowardsType = NO_UNIT;
	m_iCargoCapacity = 0;
	m_iSMCargoCapacity = 0;
	m_iExtraSelfHealModifier = 0;
	m_iExtraNumHealSupport = 0;
	m_iHealSupportUsed = 0;
	m_iExtraInsidiousness = 0;
	m_iExtraInvestigation = 0;
	m_iNoSelfHealCount = 0;
	m_iDebugCount = 0;
	m_iAssassinCount = 0;
	m_iExtraStealthStrikes = 0;
	m_iExtraStealthCombatModifier = 0;
	m_iStealthDefenseCount = 0;
	m_iOnlyDefensiveCount = 0;
	m_iNoInvisibilityCount = 0;
	m_iNoCaptureCount = 0;
	m_iExtraTrapDamageMax = 0;
	m_iExtraTrapDamageMin = 0;
	m_iExtraTrapComplexity = 0;
	m_iExtraNumTriggers = 0;
	m_iNumTimesTriggered = 0;
	m_iTriggerBeforeAttackCount = 0;
	m_iExtraNoDefensiveBonusCount = 0;
	m_iExtraGatherHerdCount = 0;
	m_bIsArmed = false;
	m_eCurrentBuildUpType = NO_PROMOTIONLINE;

	m_eCapturingUnit.reset();
	m_combatUnit.reset();
	m_transportUnit.reset();
#ifdef STRENGTH_IN_NUMBERS
	//TB Combat Mods begin
	afIUnit.reset();
	afIIUnit.reset();
	asrIUnit.reset();
	asrIIUnit.reset();
	amrIUnit.reset();
	amrIIUnit.reset();
	alrIUnit.reset();
	alrIIUnit.reset();
	aflIUnit.reset();
	aflIIUnit.reset();
	dfIUnit.reset();
	dfIIUnit.reset();
	dsrIUnit.reset();
	dsrIIUnit.reset();
	dmrIUnit.reset();
	dmrIIUnit.reset();
	dlrIUnit.reset();
	dlrIIUnit.reset();
	dflIUnit.reset();
	dflIIUnit.reset();
	//TB Combat Mods end
#endif // STRENGTH_IN_NUMBERS

	for (int iI = 0; iI < NUM_DOMAIN_TYPES; iI++)
	{
		m_aiExtraDomainModifier[iI] = 0;
	}

	for (int iI = 0; iI < GC.getNumInvisibleInfos(); iI++)
	{
		m_aiExtraVisibilityIntensity[iI] = 0;
		m_aiExtraInvisibilityIntensity[iI] = 0;
		m_aiExtraVisibilityIntensityRange[iI] = 0;
		m_aiExtraVisibilityIntensitySameTile[iI] = 0;
		m_aiNegatesInvisibleCount[iI] = 0;
	}

	m_aExtraInvisibleTerrains.clear();
	m_aExtraInvisibleFeatures.clear();
	m_aExtraInvisibleImprovements.clear();
	m_aExtraVisibleTerrains.clear();
	m_aExtraVisibleFeatures.clear();
	m_aExtraVisibleImprovements.clear();
	m_aExtraVisibleTerrainRanges.clear();
	m_aExtraVisibleFeatureRanges.clear();
	m_aExtraVisibleImprovementRanges.clear();
	m_szName.clear();
	m_szScriptData = "";

	m_aExtraAidChanges.clear();

	if (!bConstructorCall)
	{
		FAssertMsg((0 < GC.getNumPromotionInfos()), "GC.getNumPromotionInfos() is not greater than zero but an array is being allocated in CvUnit::reset");

		m_promotionKeyedInfo.clear();
		m_promotionLineKeyedInfo.clear();
		m_terrainKeyedInfo.clear();
		m_featureKeyedInfo.clear();
		m_unitCombatKeyedInfo.clear();

		if (!bIdentityChange)
		{
			AI_reset(NO_UNITAI, true);
		}
	}
	m_pPlayerInvestigated = NO_PLAYER;
	m_Properties.clear();

	// Toffer - UnitComponents
	m_commander = NULL;
	m_worker = NULL;
}

CvUnit& CvUnit::operator=(const CvUnit& other)
{
	//uninit();
	//clearCityOfOrigin();

	//static_cast<CvUnitAI&>(*this) = static_cast<const CvUnitAI&>(other);

	m_iHealUnitCombatCount = other.m_iHealUnitCombatCount;
	m_iDCMBombRange = other.m_iDCMBombRange;
	m_iDCMBombAccuracy = other.m_iDCMBombAccuracy;
	//m_iID = other.m_iID;
	//if (!bIdentityChange)
	//{
	//	m_iGroupID = other.m_iGroupID;
	//}
	m_iHotKeyNumber = other.m_iHotKeyNumber;
	//m_iX = other.m_iX;
	//m_iY = other.m_iY;
	m_iLastMoveTurn = other.m_iLastMoveTurn;
	m_iReconX = other.m_iReconX;
	m_iReconY = other.m_iReconY;
	m_iGameTurnCreated = other.m_iGameTurnCreated;
	m_iDamage = other.m_iDamage;
	m_iMoves = other.m_iMoves;
	m_iExperience = other.m_iExperience;
	m_iLevel = other.m_iLevel;
	m_iCargo = other.m_iCargo;
	m_iSMCargo = other.m_iSMCargo;
	m_iAttackPlotX = other.m_iAttackPlotX;
	m_iAttackPlotY = other.m_iAttackPlotY;
	m_iCombatTimer = other.m_iCombatTimer;
	m_iCombatFirstStrikes = other.m_iCombatFirstStrikes;
	m_iFortifyTurns = other.m_iFortifyTurns;
	m_iBuildUpTurns = other.m_iBuildUpTurns;
	m_iBlitzCount = other.m_iBlitzCount;
	m_iRBombardForceAbilityCount = other.m_iRBombardForceAbilityCount;
	m_iAmphibCount = other.m_iAmphibCount;
	m_iRiverCount = other.m_iRiverCount;
	m_iEnemyRouteCount = other.m_iEnemyRouteCount;
	m_iAlwaysHealCount = other.m_iAlwaysHealCount;
	m_iHillsDoubleMoveCount = other.m_iHillsDoubleMoveCount;
	m_iImmuneToFirstStrikesCount = other.m_iImmuneToFirstStrikesCount;
	m_iAlwaysInvisibleCount = other.m_iAlwaysInvisibleCount;
	m_iDefensiveVictoryMoveCount = other.m_iDefensiveVictoryMoveCount;
	m_iFreeDropCount = other.m_iFreeDropCount;
	m_iOffensiveVictoryMoveCount = other.m_iOffensiveVictoryMoveCount;
	m_iOneUpCount = other.m_iOneUpCount;
	m_iPillageCultureCount = other.m_iPillageCultureCount;
	m_iPillageEspionageCount = other.m_iPillageEspionageCount;
	m_iPillageMarauderCount = other.m_iPillageMarauderCount;
	m_iPillageOnMoveCount = other.m_iPillageOnMoveCount;
	m_iPillageOnVictoryCount = other.m_iPillageOnVictoryCount;
	m_iPillageResearchCount = other.m_iPillageResearchCount;
	m_iAirCombatLimitChange = other.m_iAirCombatLimitChange;
	m_iCelebrityHappy = other.m_iCelebrityHappy;
	m_iCollateralDamageLimitChange = other.m_iCollateralDamageLimitChange;
	m_iCollateralDamageMaxUnitsChange = other.m_iCollateralDamageMaxUnitsChange;
	m_iCombatLimitChange = other.m_iCombatLimitChange;
	m_iExtraDropRange = other.m_iExtraDropRange;
	m_iSurvivorChance = other.m_iSurvivorChance;
	m_iVictoryAdjacentHeal = other.m_iVictoryAdjacentHeal;
	m_iVictoryHeal = other.m_iVictoryHeal;
	m_iVictoryStackHeal = other.m_iVictoryStackHeal;
	m_iExtraVisibilityRange = other.m_iExtraVisibilityRange;
	m_iExtraMoves = other.m_iExtraMoves;
	m_iExtraMoveDiscount = other.m_iExtraMoveDiscount;
	m_iExtraAirRange = other.m_iExtraAirRange;
	m_iExtraIntercept = other.m_iExtraIntercept;
	m_iExtraEvasion = other.m_iExtraEvasion;
	m_iExtraFirstStrikes = other.m_iExtraFirstStrikes;
	m_iExtraChanceFirstStrikes = other.m_iExtraChanceFirstStrikes;
	m_iExtraWithdrawal = other.m_iExtraWithdrawal;
	m_iExtraAttackCombatModifier = other.m_iExtraAttackCombatModifier;
	m_iExtraDefenseCombatModifier = other.m_iExtraDefenseCombatModifier;
	m_iExtraPursuit = other.m_iExtraPursuit;
	m_iExtraEarlyWithdraw = other.m_iExtraEarlyWithdraw;
	m_iExtraVSBarbs = other.m_iExtraVSBarbs;
	m_iExtraReligiousCombatModifier = other.m_iExtraReligiousCombatModifier;
	m_iExtraArmor = other.m_iExtraArmor;
	m_iExtraPuncture = other.m_iExtraPuncture;
	m_iExtraOverrun = other.m_iExtraOverrun;
	m_iExtraRepel = other.m_iExtraRepel;
	m_iExtraFortRepel = other.m_iExtraFortRepel;
	m_iExtraRepelRetries = other.m_iExtraRepelRetries;
	m_iExtraUnyielding = other.m_iExtraUnyielding;
	m_iExtraKnockback = other.m_iExtraKnockback;
	m_iExtraKnockbackRetries = other.m_iExtraKnockbackRetries;
	m_iStampedeCount = other.m_iStampedeCount;
	m_iAttackOnlyCitiesCount = other.m_iAttackOnlyCitiesCount;
	m_iIgnoreNoEntryLevelCount = other.m_iIgnoreNoEntryLevelCount;
	m_iIgnoreZoneofControlCount = other.m_iIgnoreZoneofControlCount;
	m_iFliesToMoveCount = other.m_iFliesToMoveCount;
	m_iExtraStrAdjperRnd = other.m_iExtraStrAdjperRnd;
	m_iExtraStrAdjperAtt = other.m_iExtraStrAdjperAtt;
	m_iExtraStrAdjperDef = other.m_iExtraStrAdjperDef;
	m_iExtraWithdrawAdjperAtt = other.m_iExtraWithdrawAdjperAtt;
	m_iExtraUnnerve = other.m_iExtraUnnerve;
	m_iExtraEnclose = other.m_iExtraEnclose;
	m_iExtraLunge = other.m_iExtraLunge;
	m_iExtraDynamicDefense = other.m_iExtraDynamicDefense;
	m_iExtraStrength = other.m_iExtraStrength;
	m_iSMStrength = other.m_iSMStrength;
	m_iAnimalIgnoresBordersCount = other.m_iAnimalIgnoresBordersCount;
	m_iOnslaughtCount = other.m_iOnslaughtCount;
	m_iExtraFortitude = other.m_iExtraFortitude;
#ifdef STRENGTH_IN_NUMBERS
	m_iExtraFrontSupportPercent = other.m_iExtraFrontSupportPercent;
	m_iExtraShortRangeSupportPercent = other.m_iExtraShortRangeSupportPercent;
	m_iExtraMediumRangeSupportPercent = other.m_iExtraMediumRangeSupportPercent;
	m_iExtraLongRangeSupportPercent = other.m_iExtraLongRangeSupportPercent;
	m_iExtraFlankSupportPercent = other.m_iExtraFlankSupportPercent;
	m_iSupportCount = other.m_iSupportCount;
	m_iAttackFromPlotX = other.m_iAttackFromPlotX;
	m_iAttackFromPlotY = other.m_iAttackFromPlotY;
#endif // STRENGTH_IN_NUMBERS
	m_iExtraDodgeModifier = other.m_iExtraDodgeModifier;
	m_iExtraPrecisionModifier = other.m_iExtraPrecisionModifier;
	m_iExtraPowerShots = other.m_iExtraPowerShots;
	m_iExtraPowerShotCombatModifier = other.m_iExtraPowerShotCombatModifier;
	m_iExtraPowerShotPunctureModifier = other.m_iExtraPowerShotPunctureModifier;
	m_iExtraPowerShotPrecisionModifier = other.m_iExtraPowerShotPrecisionModifier;
	m_iExtraPowerShotCriticalModifier = other.m_iExtraPowerShotCriticalModifier;
	m_iExtraCriticalModifier = other.m_iExtraCriticalModifier;
	m_iExtraEndurance = other.m_iExtraEndurance;
	m_iColdDamage = other.m_iColdDamage;
	m_iDealColdDamageCount = other.m_iDealColdDamageCount;
	m_iColdImmuneCount = other.m_iColdImmuneCount;
	m_iCombatPowerShots = other.m_iCombatPowerShots;
	m_iCombatKnockbacks = other.m_iCombatKnockbacks;
	m_iCombatRepels = other.m_iCombatRepels;
	m_iExtraRoundStunProb = other.m_iExtraRoundStunProb;
	m_iCombatStuns = other.m_iCombatStuns;
	m_iExtraPoisonProbabilityModifier = other.m_iExtraPoisonProbabilityModifier;
	m_iRetrainsAvailable = other.m_iRetrainsAvailable;
	m_iQualityBaseTotal = other.m_iQualityBaseTotal;
	m_iGroupBaseTotal = other.m_iGroupBaseTotal;
	m_iSizeBaseTotal = other.m_iSizeBaseTotal;
	m_iExtraQuality = other.m_iExtraQuality;
	m_iExtraGroup = other.m_iExtraGroup;
	m_iExtraSize = other.m_iExtraSize;
	m_iSMCargoVolume = other.m_iSMCargoVolume;
	m_iSMExtraCargoVolume = other.m_iSMExtraCargoVolume;
	m_iSMCargoVolumeModifier = other.m_iSMCargoVolumeModifier;
	m_iCannotMergeSplitCount = other.m_iCannotMergeSplitCount;
	m_iExtraCaptureProbabilityModifier = other.m_iExtraCaptureProbabilityModifier;
	m_iExtraCaptureResistanceModifier = other.m_iExtraCaptureResistanceModifier;
	m_iExtraBreakdownChance = other.m_iExtraBreakdownChance;
	m_iExtraBreakdownDamage = other.m_iExtraBreakdownDamage;
	m_iExtraTaunt = other.m_iExtraTaunt;
	m_iExtraCombatModifierPerSizeMore = other.m_iExtraCombatModifierPerSizeMore;
	m_iExtraCombatModifierPerSizeLess = other.m_iExtraCombatModifierPerSizeLess;
	m_iExtraCombatModifierPerVolumeMore = other.m_iExtraCombatModifierPerVolumeMore;
	m_iExtraCombatModifierPerVolumeLess = other.m_iExtraCombatModifierPerVolumeLess;
	m_iExtraMaxHP = other.m_iExtraMaxHP;
	m_iExtraStrengthModifier = other.m_iExtraStrengthModifier;
	m_iExtraDamageModifier = other.m_iExtraDamageModifier;
	m_iExtraUpkeep100 = other.m_iExtraUpkeep100;
	m_iUpkeepModifier = other.m_iUpkeepModifier;
	m_iUpkeepMultiplierSM = other.m_iUpkeepMultiplierSM;
	m_iUpkeep100 = other.m_iUpkeep100;
	m_iSMAssetValue = other.m_iSMAssetValue;
	m_iSMPowerValue = other.m_iSMPowerValue;
	m_iSMHPValue = other.m_iSMHPValue;
	m_iExtraRBombardDamage = other.m_iExtraRBombardDamage;
	m_iExtraRBombardDamageLimit = other.m_iExtraRBombardDamageLimit;
	m_iExtraRBombardDamageMaxUnits = other.m_iExtraRBombardDamageMaxUnits;
	m_iExtraDCMBombRange = other.m_iExtraDCMBombRange;
	m_iExtraDCMBombAccuracy = other.m_iExtraDCMBombAccuracy;
	m_iBaseRBombardDamage = other.m_iBaseRBombardDamage;
	m_iBaseRBombardDamageLimit = other.m_iBaseRBombardDamageLimit;
	m_iBaseRBombardDamageMaxUnits = other.m_iBaseRBombardDamageMaxUnits;
	m_iBaseDCMBombRange = other.m_iBaseDCMBombRange;
	m_iBaseDCMBombAccuracy = other.m_iBaseDCMBombAccuracy;
	m_iBombardDirectCount = other.m_iBombardDirectCount;
	m_iExtraCollateralDamage = other.m_iExtraCollateralDamage;
	m_iExtraBombardRate = other.m_iExtraBombardRate;
	m_iSMBombardRate = other.m_iSMBombardRate;
	m_iSMAirBombBaseRate = other.m_iSMAirBombBaseRate;
	m_iSMBaseWorkRate = other.m_iSMBaseWorkRate;
	m_iSMRevoltProtection = other.m_iSMRevoltProtection;
	m_iExtraEnemyHeal = other.m_iExtraEnemyHeal;
	m_iExtraNeutralHeal = other.m_iExtraNeutralHeal;
	m_iExtraFriendlyHeal = other.m_iExtraFriendlyHeal;
	m_iSameTileHeal = other.m_iSameTileHeal;
	m_iAdjacentTileHeal = other.m_iAdjacentTileHeal;
	m_iExtraCombatPercent = other.m_iExtraCombatPercent;
	m_iExtraCityAttackPercent = other.m_iExtraCityAttackPercent;
	m_iExtraCityDefensePercent = other.m_iExtraCityDefensePercent;
	m_iExtraHillsAttackPercent = other.m_iExtraHillsAttackPercent;
	m_iExtraHillsDefensePercent = other.m_iExtraHillsDefensePercent;
	m_iRevoltProtection = other.m_iRevoltProtection;
	m_iCollateralDamageProtection = other.m_iCollateralDamageProtection;
	m_iPillageChange = other.m_iPillageChange;
	m_iUpgradeDiscount = other.m_iUpgradeDiscount;
	m_iExperiencePercent = other.m_iExperiencePercent;
	m_iKamikazePercent = other.m_iKamikazePercent;
	m_eFacingDirection = other.m_eFacingDirection;
	m_iImmobileTimer = other.m_iImmobileTimer;
	m_bCanRespawn = other.m_bCanRespawn;
	m_bSurvivor = other.m_bSurvivor;
	m_bMadeAttack = other.m_bMadeAttack;
	m_iRoundCount = other.m_iRoundCount;
	m_iAttackCount = other.m_iAttackCount;
	m_iDefenseCount = other.m_iDefenseCount;
	m_bMadeInterception = other.m_bMadeInterception;
	m_bPromotionReady = other.m_bPromotionReady;
	m_bDeathDelay = other.m_bDeathDelay;
	m_bCombatFocus = other.m_bCombatFocus;
	m_bInfoBarDirty = other.m_bInfoBarDirty;
	m_bBlockading = other.m_bBlockading;
	m_bAirCombat = other.m_bAirCombat;
	m_bHasBuildUp = other.m_bHasBuildUp;
	m_bInhibitMerge = other.m_bInhibitMerge;
	m_bInhibitSplit = other.m_bInhibitSplit;
	m_bIsBuildUp = other.m_bIsBuildUp;
	m_bIsReligionLocked = other.m_bIsReligionLocked;
	m_iCanMovePeaksCount = other.m_iCanMovePeaksCount;
	m_iCanLeadThroughPeaksCount = other.m_iCanLeadThroughPeaksCount;
	m_movementCharacteristicsHash = other.m_movementCharacteristicsHash;
	m_iSleepTimer = other.m_iSleepTimer;
	m_iCommanderID = other.m_iCommanderID;
	m_iCommanderCacheTurn = other.m_iCommanderCacheTurn;
	m_eOriginalOwner = other.m_eOriginalOwner;
	m_eNewDomainCargo = other.m_eNewDomainCargo;
	m_eNewSpecialCargo = other.m_eNewSpecialCargo;
	m_eNewSMSpecialCargo = other.m_eNewSMSpecialCargo;
	m_eNewSMNotSpecialCargo = other.m_eNewSMNotSpecialCargo;
	m_eSpecialUnit = other.m_eSpecialUnit;
	m_eSleepType = other.m_eSleepType;
	m_iZoneOfControlCount = other.m_iZoneOfControlCount;
	m_iExcileCount = other.m_iExcileCount;
	m_iPassageCount = other.m_iPassageCount;
	m_iNoNonOwnedCityEntryCount = other.m_iNoNonOwnedCityEntryCount;
	m_iBarbCoExistCount = other.m_iBarbCoExistCount;
	m_iBlendIntoCityCount = other.m_iBlendIntoCityCount;
	m_iUpgradeAnywhereCount = other.m_iUpgradeAnywhereCount;
	m_bAutoPromoting = other.m_bAutoPromoting;
	m_bAutoUpgrading = other.m_bAutoUpgrading;
	m_iHiddenNationalityCount = other.m_iHiddenNationalityCount;
	m_bHasHNCapturePromotion = other.m_bHasHNCapturePromotion;
	m_bHasAnyInvisibility = other.m_bHasAnyInvisibility;
	m_bRevealed = other.m_bRevealed;
	m_shadowUnit = other.m_shadowUnit;
	m_eDesiredDiscoveryTech = other.m_eDesiredDiscoveryTech;
	m_eOwner = other.m_eOwner;
	m_eCapturingPlayer = other.m_eCapturingPlayer;
	m_eUnitType = other.m_eUnitType;
	m_eReligionType = other.m_eReligionType;
	m_pUnitInfo = other.m_pUnitInfo;
	m_iBaseCombat = other.m_iBaseCombat;
	m_eLeaderUnitType = other.m_eLeaderUnitType;
	m_eGGExperienceEarnedTowardsType = other.m_eGGExperienceEarnedTowardsType;
	m_iCargoCapacity = other.m_iCargoCapacity;
	m_iSMCargoCapacity = other.m_iSMCargoCapacity;
	m_iExtraSelfHealModifier = other.m_iExtraSelfHealModifier;
	m_iExtraNumHealSupport = other.m_iExtraNumHealSupport;
	m_iHealSupportUsed = other.m_iHealSupportUsed;
	m_iExtraInsidiousness = other.m_iExtraInsidiousness;
	m_iExtraInvestigation = other.m_iExtraInvestigation;
	m_iNoSelfHealCount = other.m_iNoSelfHealCount;
	m_iDebugCount = other.m_iDebugCount;
	m_iAssassinCount = other.m_iAssassinCount;
	m_iExtraStealthStrikes = other.m_iExtraStealthStrikes;
	m_iExtraStealthCombatModifier = other.m_iExtraStealthCombatModifier;
	m_iStealthDefenseCount = other.m_iStealthDefenseCount;
	m_iOnlyDefensiveCount = other.m_iOnlyDefensiveCount;
	m_iNoInvisibilityCount = other.m_iNoInvisibilityCount;
	m_iNoCaptureCount = other.m_iNoCaptureCount;
	m_iExtraTrapDamageMax = other.m_iExtraTrapDamageMax;
	m_iExtraTrapDamageMin = other.m_iExtraTrapDamageMin;
	m_iExtraTrapComplexity = other.m_iExtraTrapComplexity;
	m_iExtraNumTriggers = other.m_iExtraNumTriggers;
	m_iNumTimesTriggered = other.m_iNumTimesTriggered;
	m_iTriggerBeforeAttackCount = other.m_iTriggerBeforeAttackCount;
	m_iExtraNoDefensiveBonusCount = other.m_iExtraNoDefensiveBonusCount;
	m_iExtraGatherHerdCount = other.m_iExtraGatherHerdCount;
	m_bIsArmed = other.m_bIsArmed;
	m_eCurrentBuildUpType = other.m_eCurrentBuildUpType;
	m_eCapturingUnit = other.m_eCapturingUnit;
	m_combatUnit = other.m_combatUnit;
	m_transportUnit = other.m_transportUnit;
#ifdef STRENGTH_IN_NUMBERS
	afIUnit = other.afIUnit;
	afIIUnit = other.afIIUnit;
	asrIUnit = other.asrIUnit;
	asrIIUnit = other.asrIIUnit;
	amrIUnit = other.amrIUnit;
	amrIIUnit = other.amrIIUnit;
	alrIUnit = other.alrIUnit;
	alrIIUnit = other.alrIIUnit;
	aflIUnit = other.aflIUnit;
	aflIIUnit = other.aflIIUnit;
	dfIUnit = other.dfIUnit;
	dfIIUnit = other.dfIIUnit;
	dsrIUnit = other.dsrIUnit;
	dsrIIUnit = other.dsrIIUnit;
	dmrIUnit = other.dmrIUnit;
	dmrIIUnit = other.dmrIIUnit;
	dlrIUnit = other.dlrIUnit;
	dlrIIUnit = other.dlrIIUnit;
	dflIUnit = other.dflIUnit;
	dflIIUnit = other.dflIIUnit;
#endif // STRENGTH_IN_NUMBERS

	m_aExtraInvisibleTerrains = other.m_aExtraInvisibleTerrains;
	m_aExtraInvisibleFeatures = other.m_aExtraInvisibleFeatures;
	m_aExtraInvisibleImprovements = other.m_aExtraInvisibleImprovements;
	m_aExtraVisibleTerrains = other.m_aExtraVisibleTerrains;
	m_aExtraVisibleFeatures = other.m_aExtraVisibleFeatures;
	m_aExtraVisibleImprovements = other.m_aExtraVisibleImprovements;
	m_aExtraVisibleTerrainRanges = other.m_aExtraVisibleTerrainRanges;
	m_aExtraVisibleFeatureRanges = other.m_aExtraVisibleFeatureRanges;
	m_aExtraVisibleImprovementRanges = other.m_aExtraVisibleImprovementRanges;
	m_szName = other.m_szName;
	m_szScriptData = other.m_szScriptData;
	m_aExtraAidChanges = other.m_aExtraAidChanges;

	if (!other.m_promotionKeyedInfo.empty())
		m_promotionKeyedInfo = other.m_promotionKeyedInfo;

	if (!other.m_promotionLineKeyedInfo.empty())
		m_promotionLineKeyedInfo = other.m_promotionLineKeyedInfo;

	if (!other.m_terrainKeyedInfo.empty())
		m_terrainKeyedInfo = other.m_terrainKeyedInfo;

	if (!other.m_featureKeyedInfo.empty())
		m_featureKeyedInfo = other.m_featureKeyedInfo;

	if (!other.m_unitCombatKeyedInfo.empty())
		m_unitCombatKeyedInfo = other.m_unitCombatKeyedInfo;

	m_pPlayerInvestigated = other.m_pPlayerInvestigated;
	m_Properties = other.m_Properties;

	return *this;
}

//////////////////////////////////////
// graphical only setup
//////////////////////////////////////
void CvUnit::setupGraphical()
{
	PROFILE_FUNC();

	if (!GC.IsGraphicsInitialized() || !isInViewport())
	{
		return;
	}

	if (!isUsingDummyEntities())
	{
		CvDLLEntity::setup();
	}

	if (getGroup()->getActivityType() == ACTIVITY_INTERCEPT)
	{
		airCircle(true);
	}
	else
	{
		/* billw - This forces multi-unit graphics to update.
			If it isn't done then only 1 unit shows up, then the rest appear 10s or more later.
			I tried every other command on the CvDLLEntityIFaceBase to trigger update
			of these graphics (I didn't test every animation and mission type though),
			but only found this one that actually works.
		*/
		ExecuteMove(0, false);

		/* TEST CODE (billw 21/9/2019) >>>>>>
		// Anyone can remove this later if no problems show up with using ExecuteMode(0, false) above

		static int mode = 1;
		switch (mode)
		{
			case 0: ExecuteMove(0, false); break;
			case 1: SetPosition(plot()); break;
			case 2: {
				static AnimationTypes eAnim = NONE_ANIMATION;
				static float fSpeed = 1.0f;
				static bool bQueue = false;
				static int iLayer = 0;
				static float fStartPct = 0.0f;
				static float fEndPct = 1.0f;
				PlayAnimation(eAnim, fSpeed, bQueue, iLayer, fStartPct, fEndPct);
				break;
			};
			case 3: setVisible(true); break;
			case 4: setVisible(false); setVisible(true); break;
			case 5: gDLL->getEntityIFace()->updatePosition(getEntity()); break;
			case 6: MoveTo(plot()); break;
			case 7: QueueMove(plot()); break;
			case 8: {
				static MissionTypes eMission = NO_MISSION;
				NotifyEntity(eMission);
				break;
			}
			case 9: gDLL->getEntityIFace()->updateGraphicEra(getUnitEntity()); break;
			case 10: gDLL->getEntityIFace()->showPromotionGlow(getUnitEntity(), true); break;
			case 11: gDLL->getEntityIFace()->updateEnemyGlow(getUnitEntity()); break;
			case 12: gDLL->getEntityIFace()->updatePromotionLayers(getUnitEntity()); break;
			case 13: gDLL->getEntityIFace()->StopAnimation(getEntity()); break;
			default: break;
		};
		<<<<< TEST CODE */
	}
}


// Toffer - 04.04.20
// bKillOriginal is only used by worldbuilder at this time, when duplicating unit and changing unit owner.
// Reason is that delayed death does not happen before exiting worldbuilder, and
// it's messy to have a bunch of units on the map marked for death with no idea which ones that are marked.
// Also reduce the amount of code needed to process to duplicate a unit, as it doesn't have to call convert twice when keeping the original.
void CvUnit::convert(CvUnit* pUnit, const bool bKillOriginal)
{
	PROFILE_FUNC();

	setFortifyTurns(0);

	if (GC.getGame().isOption(GAMEOPTION_SIZE_MATTERS))
	{
		int iTotalGroupOffset = 0;
		int iTotalQualityOffset = 0;

		for (int iI = GC.getNumPromotionInfos() - 1; iI > -1; iI--)
		{
			const PromotionTypes ePromoX = static_cast<PromotionTypes>(iI);

			if (pUnit->isHasPromotion(ePromoX))
			{
				if (GC.getPromotionInfo(ePromoX).getGroupChange() != 0)
				{
					iTotalGroupOffset += GC.getPromotionInfo(ePromoX).getGroupChange();
				}
				else if (GC.getPromotionInfo(ePromoX).getQualityChange() != 0)
				{
					iTotalQualityOffset += GC.getPromotionInfo(ePromoX).getQualityChange();
				}
				else if (!isHasPromotion(ePromoX)) //see note below on this situation with true for bDying
				{
					setHasPromotion(ePromoX, true, pUnit->isPromotionFree(ePromoX), true);
				}
			}
		}

		const bool bNormalizedGroup = CvUnit::normalizeUnitPromotions(this, iTotalGroupOffset,
			bind(&CvUnit::isGroupUpgradePromotion, this, _2),
			bind(&CvUnit::isGroupDowngradePromotion, this, _2)
		);
		FAssertMsg(bNormalizedGroup, "Could not apply required number of group promotions on converted unit");

		const bool bNormalizedQuality = CvUnit::normalizeUnitPromotions(this, iTotalQualityOffset,
			bind(&CvUnit::isQualityUpgradePromotion, this, _2),
			bind(&CvUnit::isQualityDowngradePromotion, this, _2)
		);
		FAssertMsg(bNormalizedQuality, "Could not apply required number of quality promotions on converted unit");
	}
	else
	{
		for (int iI = GC.getNumPromotionInfos() - 1; iI > -1; iI--)
		{
			const PromotionTypes ePromoX = static_cast<PromotionTypes>(iI);

			if (pUnit->isHasPromotion(ePromoX) && !isHasPromotion(ePromoX))
			{
				// TB - bDying is set to true to temporarily avoid obsoletion checks until AFTER all promos are assigned
				// as sometimes promos would be lost because prereqs simply weren't assigned yet due to the order in which they were established.
				setHasPromotion(ePromoX, true, pUnit->isPromotionFree(ePromoX), true);
			}
		}
	}
	//TB Combat Mod end

	if (pUnit->getCityOfOrigin() != NULL)
	{
		setCityOfOrigin(pUnit->getCityOfOrigin());
	}
	setGameTurnCreated(pUnit->getGameTurnCreated());

	const int iCurrentHPCap = pUnit->getMaxHP()-1;
	setDamage(std::min(iCurrentHPCap, pUnit->getDamage()));
	//TB Combat Mod next line
	setColdDamage(std::min(iCurrentHPCap, pUnit->getColdDamage()));
	setMoves(pUnit->getMoves());
	setImmobileTimer(pUnit->getImmobileTimer());

	m_eOriginalOwner = pUnit->getOriginalOwner();
	m_eNewDomainCargo = pUnit->getDomainCargo();
	m_eNewSpecialCargo = pUnit->getSpecialCargo();
	m_eNewSMSpecialCargo = pUnit->getSMSpecialCargo();
	m_eNewSMNotSpecialCargo = pUnit->getSMNotSpecialCargo();
	m_eSpecialUnit = pUnit->getSpecialUnitType();
	m_eSleepType = NO_MISSION;
	m_iHiddenNationalityCount = pUnit->getHiddenNationalityCount();
	setAutoPromoting(pUnit->isAutoPromoting());
	setAutoUpgrading(pUnit->isAutoUpgrading());
	m_eCurrentBuildUpType = NO_PROMOTIONLINE;

	setLevel(pUnit->getLevel());
	const int iOldModifier = std::max(1, 100 + GET_PLAYER(pUnit->getOwner()).getLevelExperienceModifier());
	const int iOurModifier = std::max(1, 100 + GET_PLAYER(getOwner()).getLevelExperienceModifier());
	setExperience(std::max(0, (pUnit->getExperience() * iOurModifier) / iOldModifier));

	setName(pUnit->getNameNoDesc());

	if (pUnit->isDescInName() && getBugOptionBOOL("MiscHover__UpdateUnitNameOnUpgrade", true, "BUG_UPDATE_UNIT_NAME_ON_UPGRADE"))
	{
		CvWString szUnitType(pUnit->getDescription());

		m_szName.replace(m_szName.find(szUnitType), szUnitType.length(), getDescription());
	}

	if (pUnit->getLeaderUnitType() != NO_UNIT)
	{
		setLeaderUnitType(pUnit->getLeaderUnitType());
	}

	if (GC.getGame().isOption(GAMEOPTION_HIDE_AND_SEEK))
	{
		setHasAnyInvisibility();
	}

	CvUnit* pTransportUnit = pUnit->getTransportUnit();
	if (pTransportUnit != NULL)
	{
		pUnit->setTransportUnit(NULL);
		setTransportUnit(pTransportUnit);
	}

	std::vector<CvUnit*> aCargoUnits;
	pUnit->getCargoUnits(aCargoUnits);
	pUnit->validateCargoUnits();
	foreach_(CvUnit* pCargo, aCargoUnits)
	{
		// Check cargo types and capacity when upgrading transports
		if (GC.getGame().isOption(GAMEOPTION_SIZE_MATTERS))
		{
			if (SMcargoSpaceAvailable(pCargo->getSpecialUnitType(), pCargo->getDomainType()) > pCargo->getCargoVolume())
			{
				pCargo->setTransportUnit(NULL);
				pCargo->setTransportUnit(this);
			}
			else
			{
				pCargo->setTransportUnit(NULL);
				pCargo->jumpToNearestValidPlot();
			}
		}
		else if (cargoSpaceAvailable(pCargo->getSpecialUnitType(), pCargo->getDomainType()) > 0)
		{
			pCargo->setTransportUnit(NULL);
			pCargo->setTransportUnit(this);
		}
		else
		{
			pCargo->setTransportUnit(NULL);
			pCargo->jumpToNearestValidPlot();
		}
	}
	validateCargoUnits();

	if (bKillOriginal)
	{
		pUnit->getGroup()->AI_setMissionAI(MISSIONAI_DELIBERATE_KILL, NULL, NULL);
		pUnit->kill(true, NO_PLAYER, true);
	}
}


void CvUnit::kill(bool bDelay, PlayerTypes ePlayer, bool bMessaged)
{
	// If it's already dead (but delayed death in process) don't try to re-kill it.
	if (m_bDeathDelay)
	{
		return;
	}
	killUnconditional(bDelay, ePlayer, bMessaged);
}

void CvUnit::killUnconditional(bool bDelay, PlayerTypes ePlayer, bool bMessaged)
{
	PROFILE_FUNC();

	CvWString szBuffer;

	if (m_combatResult.bDeathMessaged)
	{
		bMessaged = true;
	}

	const PlayerTypes eOwner = getOwner();
	CvPlayerAI& owner = GET_PLAYER(eOwner);

	CvPlot* pPlot = plot();

	if (pPlot != NULL)
	{
		std::vector<IDInfo> oldUnits;

		oldUnits.clear();
		CLLNode<IDInfo>* pUnitNode = pPlot->headUnitNode();

		while (pUnitNode != NULL)
		{
			oldUnits.push_back(pUnitNode->m_data);
			pUnitNode = pPlot->nextUnitNode(pUnitNode);
		}

		for (uint i = 0; i < oldUnits.size(); i++)
		{
			CvUnit* pLoopUnit = ::getUnit(oldUnits[i]);

			if (pLoopUnit != NULL && pLoopUnit->getTransportUnit() == this)
			{
				//save old units because kill will clear the static list
				std::vector<IDInfo> tempUnits = oldUnits;

				if (pPlot->isValidDomainForLocation(*pLoopUnit))
				{
					pLoopUnit->setCapturingPlayer(NO_PLAYER);
					pLoopUnit->setCapturingUnit(this);
				}

				bool bSurvived = false;
				CvPlot* pRescuePlot = NULL;

				if (GC.getDefineINT("WAR_PRIZES") && pPlot->isWater())
				{
					foreach_(CvPlot* pAdjacentPlot, plot()->adjacent())
					{
						if (!pAdjacentPlot->isWater() && !pAdjacentPlot->isVisibleEnemyUnit(pLoopUnit))
						{
							pRescuePlot = pAdjacentPlot;
							if (GC.getGame().getSorenRandNum(10, "Unit Survives Drowning") <= 2)
							{
								bSurvived = true;
							}
							break;
						}
					}
				}
				if (bSurvived)
				{
					FAssertMsg(pRescuePlot != NULL, "pRescuePlot is expected to be a valid plot!");
					pLoopUnit->setDamage(GC.getGame().getSorenRandNum(pLoopUnit->getHP(), "Survival Damage"), NO_PLAYER);
					pLoopUnit->move(pRescuePlot, false);

					szBuffer = gDLL->getText("TXT_KEY_MISC_UNIT_SURVIVED_TRANSPORT_SINKING", pLoopUnit->getNameKey(), getNameKey());
					AddDLLMessage(pLoopUnit->getOwner(), false, GC.getEVENT_MESSAGE_TIME(), szBuffer, NULL, MESSAGE_TYPE_MINOR_EVENT);
				}
				else
				{
					szBuffer = gDLL->getText("TXT_KEY_MISC_UNIT_DROWNED", pLoopUnit->getNameKey());
					AddDLLMessage(eOwner, true, GC.getEVENT_MESSAGE_TIME(), szBuffer, GC.getEraInfo(GC.getGame().getCurrentEra()).getAudioUnitDefeatScript(), MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_RED(), getX(), getY());
					bMessaged = true;
					pLoopUnit->kill(false, ePlayer, bMessaged);

					oldUnits = tempUnits;
				}
			}
		}

		if (ePlayer != NO_PLAYER)
		{
			CvEventReporter::getInstance().unitKilled(this, ePlayer);

			if (NO_UNIT != getLeaderUnitType() || GC.getUnitInfo(getUnitType()).getMaxGlobalInstances() == 1)
			{
				for (int iI = 0; iI < MAX_PC_PLAYERS; iI++)
				{
					if (GET_PLAYER((PlayerTypes)iI).isAlive() && !bMessaged)
					{
						szBuffer = gDLL->getText("TXT_KEY_MISC_GENERAL_KILLED", getNameKey());
						AddDLLMessage(eOwner, true, GC.getEVENT_MESSAGE_TIME(), szBuffer, GC.getEraInfo(GC.getGame().getCurrentEra()).getAudioUnitDefeatScript(), MESSAGE_TYPE_MAJOR_EVENT, NULL, GC.getCOLOR_RED(), getX(), getY());
						bMessaged = true;
					}
				}
			}
		}
		/* This is interrupting other messages and not coming up when it should be anyhow.
		if (!bMessaged)
		{

			szBuffer = gDLL->getText("TXT_KEY_MISC_UNIT_DEATH", getNameKey());
			AddDLLMessage(eOwner, true, GC.getEVENT_MESSAGE_TIME(), szBuffer, GC.getEraInfo(GC.getGame().getCurrentEra()).getAudioUnitDefeatScript(), MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_RED(), getX(), getY());
			m_combatResult.bDeathMessaged = false;
			bMessaged = true;
		}
		*/
		if (bDelay)
		{
			startDelayedDeath();
			return;
		}

		if (isCanRespawn())
		{
			const CvCity* pCapitalCity = owner.getCapitalCity();
			if ( pCapitalCity != NULL && pCapitalCity->plot() != plot())
			{
				//GC.getGame().logOOSSpecial(14, getID(), pCapitalCity->getX(), pCapitalCity->getY());
				setXY(pCapitalCity->getX(), pCapitalCity->getY(), false, false, false);
				setDamage(getMaxHP() * 9/10);
				changeOneUpCount(-1);
				const CvWString szBuffer = gDLL->getText("TXT_KEY_MISC_BATTLEFIELD_EVAC", getNameKey());
				AddDLLMessage(eOwner, true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_POSITIVE_DINK", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_GREEN(), getX(), getY());
				m_bDeathDelay = false;
				return;
			}
		}

		if (isSurvivor())
		{
			setDamage(getMaxHP() - std::max(1,(getSurvivorChance() / 1000)));
			CvWString szBuffer = gDLL->getText("TXT_KEY_MISC_YOUR_UNIT_IS_HARDCORE", getNameKey());
			AddDLLMessage(eOwner, true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_POSITIVE_DINK", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_GREEN(), getX(), getY());
			m_bDeathDelay = false;
			//	Only applies to THIS combat - it might be attacked again the same turn
			setSurvivor(false);
			return;
		}

		if (isMadeAttack() && nukeRange() != -1)
		{
			CvPlot* pTarget = getAttackPlot();
			if (pTarget)
			{
				pTarget->nukeExplosion(nukeRange(), this);
				setAttackPlot(NULL, false);
			}
		}
		finishMoves();
		m_iDamage = getMaxHP(); // Toffer - Makes isDead() True

		if (IsSelected() && gDLL->getInterfaceIFace()->getLengthSelectionList() == 1)
		{
			if (!gDLL->getInterfaceIFace()->isFocused() && !gDLL->getInterfaceIFace()->isCitySelection() && !gDLL->getInterfaceIFace()->isDiploOrPopupWaiting())
			{
				GC.getGame().updateSelectionList();
			}

			if (IsSelected())
			{
				gDLL->getInterfaceIFace()->setCycleSelectionCounter(1);
			}
			else
			{
				gDLL->getInterfaceIFace()->setDirty(SelectionCamera_DIRTY_BIT, true);
			}
		}
		gDLL->getInterfaceIFace()->removeFromSelectionList(this);

		// XXX this is NOT a hack, without it, the game crashes.
		if (!isUsingDummyEntities() && isInViewport())
		{
			gDLL->getEntityIFace()->RemoveUnitFromBattle(this);
		}

		FAssertMsg(!isCombat(), "isCombat did not return false as expected");

		if (getTransportUnit() != NULL)
		{
			setTransportUnit(NULL);
		}
		setReconPlot(NULL);
		setBlockading(false);
		/*
		if (isZoneOfControl())
		{
			foreach_(CvPlot* pAdjacentPlot, plot()->adjacent())
			{
				pAdjacentPlot->clearZoneOfControlCache();
			}
		}
		*/
		FAssertMsg(getAttackPlot() == NULL, "The current unit instance's attack plot is expected to be NULL");
		FAssertMsg(getCombatUnit() == NULL, "The current unit instance's combat unit is expected to be NULL");
	}

	owner.changeUnitUpkeep(-getUpkeep100(), m_pUnitInfo->isMilitarySupport());

	owner.changeUnitCount(m_eUnitType, -1);
	if (GC.getGame().isOption(GAMEOPTION_SIZE_MATTERS)
	// if unit doesn't have a group rank, it doesn't count as a SM unit at all
	&& groupRank() > 0)
	{
		owner.changeUnitCountSM(m_eUnitType, -intPow(3, groupRank()-1));
	}

	if (m_pUnitInfo->getNukeRange() != -1)
	{
		owner.changeNumNukeUnits(-1);
	}

	if (m_pUnitInfo->isMilitarySupport())
	{
		owner.changeNumMilitaryUnits(-1);
	}

	owner.changeAssets(-assetValueTotal());
	owner.changeUnitPower(-getPowerValueTotal());

	if (pPlot != NULL)
	{
		OutputDebugString(CvString::format("Unit %S of player %S killed\n", getName().GetCString(), owner.getCivilizationDescription(0)).c_str());

		owner.AI_changeNumAIUnits(AI_getUnitAIType(), -1);
		AI_killed(); // Update AI counts for this unit
		//GC.getGame().logOOSSpecial(15, getID(), INVALID_PLOT_COORD, INVALID_PLOT_COORD);
		setXY(INVALID_PLOT_COORD, INVALID_PLOT_COORD, true);

		joinGroup(NULL, false, false);

		CvEventReporter::getInstance().unitLost(this);

		PlayerTypes eCapturingPlayer = getCapturingPlayer();
		UnitTypes eCaptureUnitType = getCaptureUnitType();

		if (eCapturingPlayer != NO_PLAYER && eCaptureUnitType != NO_UNIT && !GET_PLAYER(eCapturingPlayer).isNPC())
		{
			CvUnit* pkCapturedUnit = GET_PLAYER(eCapturingPlayer).initUnit(eCaptureUnitType, pPlot->getX(), pPlot->getY(), NO_UNITAI, NO_DIRECTION, GC.getGame().getSorenRandNum(10000, "AI Unit Birthmark"));

			if (pkCapturedUnit != NULL)
			{
				CvEventReporter::getInstance().unitCaptured(eOwner, getUnitType(), pkCapturedUnit);

				if (getCapturingUnit() != NULL && getCapturingUnit()->isHiddenNationality())
				{
					pkCapturedUnit->doHNCapture();
				}

				szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_CAPTURED_UNIT", GC.getUnitInfo(eCaptureUnitType).getTextKeyWide());
				AddDLLMessage(eCapturingPlayer, true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_UNITCAPTURE", MESSAGE_TYPE_INFO, pkCapturedUnit->getButton(), GC.getCOLOR_GREEN(), pPlot->getX(), pPlot->getY());

				// Add a captured mission
				addMission(CvMissionDefinition(MISSION_CAPTURED, pPlot, pkCapturedUnit));

				pkCapturedUnit->finishMoves();

				if (!GET_PLAYER(eCapturingPlayer).isHuman())
				{
					pPlot = pkCapturedUnit->plot();
					if (pPlot && !pPlot->isCity(false)
					&& GC.getDefineINT("AI_CAN_DISBAND_UNITS") && GET_PLAYER(eCapturingPlayer).AI_getPlotDanger(pPlot))
					{
						pkCapturedUnit->kill(false, NO_PLAYER, true);
					}
				}
			}
		}
		owner.deleteUnit(getID());
	}
}


void CvUnit::NotifyEntity(MissionTypes eMission)
{
	if ( !isUsingDummyEntities() && isInViewport() )
	{
		gDLL->getEntityIFace()->NotifyEntity(getUnitEntity(), eMission);
	}
}


void CvUnit::doTurn()
{
	PROFILE("CvUnit::doTurn()");

	FAssertMsg(!isDead(), "isDead did not return false as expected");
	FAssertMsg(getGroup() != NULL, "getGroup() is not expected to be equal with NULL");

	if (isCommander())
	{
		m_commander->restoreControlPoints();
	}
	gDLL->getInterfaceIFace()->setDirty(InfoPane_DIRTY_BIT, true);
	m_iCommanderID = -1;	//reset used commander for combat units

	m_bRevealed = false;
	if (m_bHasHNCapturePromotion && getOwner() == plot()->getOwner())
	{
		removeHNCapturePromotion();
	}

	if (getInsidiousnessTotal(true) > 0)
	{
		if (plot()->isCity(false))
		{
			doInsidiousnessVSInvestigationCheck();
		}
		else if (m_pPlayerInvestigated != NO_PLAYER)
		{
			doRemoveInvestigatedPromotionCheck();
		}
	}

	testPromotionReady();
	if (isBlockading())
	{
		collectBlockadeGold();
	}

	if (isSpy() && isIntruding() && !isCargo())
	{
		const TeamTypes eTeam = plot()->getTeam();

		if (NO_TEAM != eTeam)
		{
			if (GET_TEAM(getTeam()).isOpenBorders(eTeam))
			{
				testSpyIntercepted(plot()->getOwner(), GC.getDefineINT("ESPIONAGE_SPY_NO_INTRUDE_INTERCEPT_MOD"));
			}
			else
			{
				testSpyIntercepted(plot()->getOwner(), GC.getDefineINT("ESPIONAGE_SPY_INTERCEPT_MOD"));
			}
		}
	}

	if (baseCombatStr() > 0)
	{
		if (plot()->getFeatureTurnDamage() != 0)
		{
			changeDamagePercent(plot()->getFeatureTurnDamage(), NO_PLAYER);
		}

		if (plot()->getTerrainTurnDamage(this) != 0)
		{
			changeDamagePercent(plot()->getTerrainTurnDamage(this), NO_PLAYER);
			//TB Combat Mod
			if (GC.getTerrainInfo(plot()->getTerrainType()).isColdDamage())
			{
				changeColdDamage(plot()->getTerrainTurnDamage(this));
			}
			//TB Combat Mod
		}
	}

	const bool bHasMoved = hasMoved();
	const bool bHeal = ((bHasMoved && isAlwaysHeal()) || !bHasMoved);

#ifdef OUTBREAKS_AND_AFFLICTIONS
	if (GC.getGame().isOption(GAMEOPTION_OUTBREAKS_AND_AFFLICTIONS))
	{
		doAffliction(bHeal);
	}
#endif

	if (bHeal && isHurt())
	{
		doHeal();
	}

	if (!bHasMoved)
	{
		setFortifyTurns(getFortifyTurns() + 1);

		if (isBuildUp())
		{
			incrementBuildUp();
		}
	}

	if (isCanRespawn())
	{
		setCanRespawn(false);
	}

	if (isSurvivor())
	{
		setSurvivor(false);
	}

	if (isSpy() && m_iSleepTimer > 0 && getFortifyTurns() == GC.getMAX_FORTIFY_TURNS())
	{
		getGroup()->setActivityType(ACTIVITY_AWAKE);
		m_iSleepTimer = 0;
	}

	if (getDesiredDiscoveryTech() != NO_TECH && canDiscover() && getDesiredDiscoveryTech() == getDiscoveryTech())
	{
		getGroup()->setActivityType(ACTIVITY_AWAKE);
		setDesiredDiscoveryTech(NO_TECH);
		discover();
	}

	changeImmobileTimer(-1);
	//TB Combat Mods (Att&DefCounter)
	if (getAttackCount()>0)
	{
		int AttackCountResetVal = -(getAttackCount());
		changeAttackCount(AttackCountResetVal);
	}
	if (getDefenseCount()>0)
	{
		int DefenseCountResetVal = -(getDefenseCount());
		changeDefenseCount(DefenseCountResetVal);
	}
	//TB Combat Mods (Att&DefCounter) end

	setMadeAttack(false);
	setMadeInterception(false);

	setReconPlot(NULL);

	if (isExcile() && (plot()->getOwner() == getOwner() || plot()->getOwner() == getOriginalOwner()))
	{
		jumpToNearestValidPlot(false);
	}

	setMoves(0);
}


void CvUnit::updateAirStrike(CvPlot* pPlot, bool bQuick, bool bFinish)
{
	bool bVisible = false;

	if (!bFinish)
	{
		if (isFighting())
		{
			return;
		}

		if (!bQuick)
		{
			// Always show human air strikes
			bVisible = isHuman() || isCombatVisible(NULL);
		}

		// Dale - NB: A-Bomb
		if (canNuke(pPlot))
		{
			kill(true, NO_PLAYER, true);
			return;
		}
		// ! Dale

		//if (!airStrike(pPlot))
		//{
		//	return;
		//}

		if (airStrike(pPlot) && bVisible)
		{
			setCombatTimer(GC.getMissionInfo(MISSION_AIRSTRIKE).getTime());
			GC.getGame().incrementTurnTimer(getCombatTimer());

			addMission(CvAirMissionDefinition(MISSION_AIRSTRIKE, pPlot, this, NULL, getCombatTimer() * gDLL->getSecsPerTurn()));

			return;
		}
	}

	CvUnit *pDefender = getCombatUnit();
	if (pDefender != NULL)
	{
		pDefender->setCombatUnit(NULL);
	}
	setCombatUnit(NULL);
	setAttackPlot(NULL, false);

	getGroup()->clearMissionQueue();

	if (isSuicide() && !isDead())
	{
		kill(true);
	}
}

void CvUnit::resolveAirCombat(CvUnit* pInterceptor, CvPlot* pPlot, CvAirMissionDefinition& kBattle)
{
	CvWString szBuffer;

	int iTheirStrength = (DOMAIN_AIR == pInterceptor->getDomainType() ? pInterceptor->airCurrCombatStr(this) : pInterceptor->currCombatStr(NULL, NULL));
	int iOurStrength = (DOMAIN_AIR == getDomainType() ? airCurrCombatStr(pInterceptor) : currCombatStr(NULL, NULL));
	int iTotalStrength = iOurStrength + iTheirStrength;
	if (0 == iTotalStrength)
	{
		FErrorMsg("error");
		return;
	}

/********************************************************************************/
/* 	BETTER_BTS_AI_MOD						10/19/08	Roland J & jdog5000	*/
/* 																			*/
/* 	Combat mechanics														*/
/********************************************************************************/
	/*
	int iOurOdds = (100 * iOurStrength) / std::max(1, iTotalStrength);

	int iOurRoundDamage = (pInterceptor->currInterceptionProbability() * GC.getDefineINT("MAX_INTERCEPTION_DAMAGE")) / 100;
	int iTheirRoundDamage = (currInterceptionProbability() * GC.getDefineINT("MAX_INTERCEPTION_DAMAGE")) / 100;
	if (getDomainType() == DOMAIN_AIR)
	{
		iTheirRoundDamage = std::max(GC.getDefineINT("MIN_INTERCEPTION_DAMAGE"), iTheirRoundDamage);
	}

	//original BTS code
	int iTheirDamage = 0;
	int iOurDamage = 0;

	for (int iRound = 0; iRound < GC.getDefineINT("INTERCEPTION_MAX_ROUNDS"); ++iRound)
	*/
	// For air v air, more rounds and factor in strength for per round damage
	int iOurOdds = (100 * iOurStrength) / std::max(1, iTotalStrength);
	int iMaxRounds = 0;
	int iOurRoundDamage = 0;
	int iTheirRoundDamage = 0;

	// Air v air is more like standard combat
	// Round damage in this case will now depend on strength and interception probability
	if( GC.getBBAI_AIR_COMBAT() && (DOMAIN_AIR == pInterceptor->getDomainType() && DOMAIN_AIR == getDomainType()) )
	{
		int iBaseDamage = GC.getDefineINT("AIR_COMBAT_DAMAGE");
		int iOurFirepower = ((airMaxCombatStr(pInterceptor) + iOurStrength + 1) / 2);
		int iTheirFirepower = ((pInterceptor->airMaxCombatStr(this) + iTheirStrength + 1) / 2);

		int iStrengthFactor = ((iOurFirepower + iTheirFirepower + 1) / 2);

		int iTheirInterception = std::max(pInterceptor->maxInterceptionProbability(),2*GC.getDefineINT("MIN_INTERCEPTION_DAMAGE"));
		int iOurInterception = std::max(maxInterceptionProbability(),2*GC.getDefineINT("MIN_INTERCEPTION_DAMAGE"));

		iOurRoundDamage = std::max(1, ((iBaseDamage * (iTheirFirepower + iStrengthFactor) * iTheirInterception) / ((iOurFirepower + iStrengthFactor) * 100)));
		iTheirRoundDamage = std::max(1, ((iBaseDamage * (iOurFirepower + iStrengthFactor) * iOurInterception) / ((iTheirFirepower + iStrengthFactor) * 100)));

		iMaxRounds = 2*GC.getDefineINT("INTERCEPTION_MAX_ROUNDS") - 1;
	}
	else
	{
		iOurRoundDamage = (pInterceptor->currInterceptionProbability() * GC.getDefineINT("MAX_INTERCEPTION_DAMAGE")) / 100;
		iTheirRoundDamage = (currInterceptionProbability() * GC.getDefineINT("MAX_INTERCEPTION_DAMAGE")) / 100;
		if (getDomainType() == DOMAIN_AIR)
		{
			iTheirRoundDamage = std::max(GC.getDefineINT("MIN_INTERCEPTION_DAMAGE"), iTheirRoundDamage);
		}

		iMaxRounds = GC.getDefineINT("INTERCEPTION_MAX_ROUNDS");
	}

	int iTheirDamage = 0;
	int iOurDamage = 0;

	for (int iRound = 0; iRound < iMaxRounds; ++iRound)
/********************************************************************************/
/* 	BETTER_BTS_AI_MOD						END								*/
/********************************************************************************/
	{
		if (GC.getGame().getSorenRandNum(100, "Air combat") < iOurOdds)
		{
			if (DOMAIN_AIR == pInterceptor->getDomainType())
			{
				iTheirDamage += iTheirRoundDamage;
				pInterceptor->changeDamage(iTheirRoundDamage, getOwner());
				//TB Combat Mod begin
				if (dealsColdDamage())
				{
					pInterceptor->changeColdDamage(iTheirRoundDamage);
				}
				//TB Combat Mod end
				if (pInterceptor->isDead())
				{
					break;
				}
#ifdef OUTBREAKS_AND_AFFLICTIONS
				//here we go with afflict on attack
				if (GC.getGame().isOption(GAMEOPTION_OUTBREAKS_AND_AFFLICTIONS))
				{
					for (int iI = 0; iI < GC.getNumPromotionLineInfos(); iI++)
					{
						if (GC.getPromotionLineInfo((PromotionLineTypes)iI).isAffliction() && !GC.getPromotionLineInfo((PromotionLineTypes)iI).isCritical())
						{
							PromotionLineTypes eAfflictionLine = ((PromotionLineTypes)iI);
							if (hasAfflictOnAttackType(eAfflictionLine) && isAfflictOnAttackTypeDistance(eAfflictionLine))
							{
								int iAttackersPoisonChance = getAfflictOnAttackTypeProbability(eAfflictionLine) - pInterceptor->fortitudeTotal() - pInterceptor->getUnitAfflictionTolerance(eAfflictionLine);

								if (GC.getGame().getSorenRandNum(100, "AttackersPoisonRoll") < iAttackersPoisonChance)
								{
									pInterceptor->afflict(eAfflictionLine, true, this);
								}
							}
						}
					}
				}
#endif // OUTBREAKS_AND_AFFLICTIONS
			}
		}
		else
		{
			iOurDamage += iOurRoundDamage;
			changeDamage(iOurRoundDamage, pInterceptor->getOwner());
			//TB Combat Mod begin
			if (pInterceptor->dealsColdDamage())
			{
				changeColdDamage(iOurRoundDamage);
			}
			//TB Combat Mod end
			if (isDead())
			{
				break;
			}
#ifdef OUTBREAKS_AND_AFFLICTIONS
			if (GC.getGame().isOption(GAMEOPTION_OUTBREAKS_AND_AFFLICTIONS))
			{
				for (int iI = 0; iI < GC.getNumPromotionLineInfos(); iI++)
				{
					if (GC.getPromotionLineInfo((PromotionLineTypes)iI).isAffliction() && !GC.getPromotionLineInfo((PromotionLineTypes)iI).isCritical())
					{
						PromotionLineTypes eAfflictionLine = ((PromotionLineTypes)iI);
						if (pInterceptor->hasAfflictOnAttackType(eAfflictionLine) && pInterceptor->isAfflictOnAttackTypeDistance(eAfflictionLine))
						{
							int iAttackersPoisonChance = pInterceptor->getAfflictOnAttackTypeProbability(eAfflictionLine) - fortitudeTotal() - getUnitAfflictionTolerance(eAfflictionLine);

							if (GC.getGame().getSorenRandNum(100, "AttackersPoisonRoll") < iAttackersPoisonChance)
							{
								afflict(eAfflictionLine, true, pInterceptor);
							}
						}
					}
				}
			}
#endif // OUTBREAKS_AND_AFFLICTIONS
		}
	}

	if (isDead())
	{
		if (iTheirRoundDamage > 0)
		{
			int iExperience = pInterceptor->defenseXPValue();
			iExperience = (iExperience * iOurStrength) / std::max(1, iTheirStrength);
			iExperience = range(iExperience, GC.getMIN_EXPERIENCE_PER_COMBAT(), GC.getMAX_EXPERIENCE_PER_COMBAT());
			pInterceptor->changeExperience(iExperience, pInterceptor->maxXPValue(this), true, pPlot->getOwner() == pInterceptor->getOwner(), true);
		}
	}
	else if (pInterceptor->isDead())
	{
		int iExperience = attackXPValue();
		iExperience = (iExperience * iTheirStrength) / std::max(1, iOurStrength);
		iExperience = range(iExperience, GC.getMIN_EXPERIENCE_PER_COMBAT(), GC.getMAX_EXPERIENCE_PER_COMBAT());
		changeExperience(iExperience, maxXPValue(pInterceptor), true, pPlot->getOwner() == getOwner(), true);
	}
	else if (iOurDamage > 0)
	{
		if (iTheirRoundDamage > 0)
		{
			pInterceptor->changeExperience100(getExperiencefromWithdrawal(iOurOdds) * 10, pInterceptor->maxXPValue(this), true, pPlot->getOwner() == pInterceptor->getOwner(), true);
		}
	}
	else if (iTheirDamage > 0)
	{
		changeExperience100(getExperiencefromWithdrawal(iOurOdds) * 10, maxXPValue(pInterceptor), true, pPlot->getOwner() == getOwner(), true);
	}

	kBattle.setDamage(BATTLE_UNIT_ATTACKER, iOurDamage);
	kBattle.setDamage(BATTLE_UNIT_DEFENDER, iTheirDamage);
}


void CvUnit::updateAirCombat(bool bQuick)
{
	CvUnit* pInterceptor = NULL;
	bool bFinish = false;

	FAssert(getDomainType() == DOMAIN_AIR || getDropRange() > 0);

	if (getCombatTimer() > 0)
	{
		changeCombatTimer(-1);

		if (getCombatTimer() > 0)
		{
			return;
		}
		else
		{
			bFinish = true;
		}
	}

	CvPlot* pPlot = getAttackPlot();
	if (pPlot == NULL)
	{
		return;
	}

	if (bFinish)
	{
		pInterceptor = getCombatUnit();
	}
	else
	{
		pInterceptor = bestInterceptor(pPlot);
	}


	if (pInterceptor == NULL)
	{
		setAttackPlot(NULL, false);
		setCombatUnit(NULL);

		getGroup()->clearMissionQueue();

		return;
	}

	//check if quick combat
	bool bVisible = false;
	if (!bQuick)
	{
		bVisible = isCombatVisible(pInterceptor);
	}

	//if not finished and not fighting yet, set up combat damage and mission
	if (!bFinish)
	{
		if (!isFighting())
		{
			if (plot()->isFighting() || pPlot->isFighting())
			{
				return;
			}

			setMadeAttack(true);

			setCombatUnit(pInterceptor, true);
			pInterceptor->setCombatUnit(this, false);
		}

		FAssertMsg(pInterceptor != NULL, "Defender is not assigned a valid value");

		FAssertMsg(plot()->isFighting(), "Current unit instance plot is not fighting as expected");
		FAssertMsg(pInterceptor->plot()->isFighting(), "pPlot is not fighting as expected");

		CvAirMissionDefinition kAirMission(getDomainType() == DOMAIN_AIR ? MISSION_AIRSTRIKE : MISSION_PARADROP, pPlot, this, pInterceptor, GC.getMissionInfo(MISSION_AIRSTRIKE).getTime() * gDLL->getSecsPerTurn());
		resolveAirCombat(pInterceptor, pPlot, kAirMission);

		if (!bVisible)
		{
			bFinish = true;
		}
		else
		{
			setCombatTimer(GC.getMissionInfo(MISSION_AIRSTRIKE).getTime());
			GC.getGame().incrementTurnTimer(getCombatTimer());
			addMission(kAirMission);
		}

		changeMoves(GC.getMOVE_DENOMINATOR());
		if (DOMAIN_AIR != pInterceptor->getDomainType())
		{
			pInterceptor->setMadeInterception(true);
		}

		if (isDead())
		{

			CvWString szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_SHOT_DOWN_ENEMY", pInterceptor->getNameKey(), getNameKey(), getVisualCivAdjective(pInterceptor->getTeam()));
			AddDLLMessage(pInterceptor->getOwner(), false, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_INTERCEPT", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_GREEN(), pPlot->getX(), pPlot->getY(), true, true);

			szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_UNIT_SHOT_DOWN", getNameKey(), pInterceptor->getNameKey());
			AddDLLMessage(getOwner(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_INTERCEPTED", MESSAGE_TYPE_INFO, pInterceptor->getButton(), GC.getCOLOR_RED(), pPlot->getX(), pPlot->getY());
		}
		else if (kAirMission.getDamage(BATTLE_UNIT_ATTACKER) > 0)
		{

			CvWString szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_HURT_ENEMY_AIR", pInterceptor->getNameKey(), getNameKey(), -(kAirMission.getDamage(BATTLE_UNIT_ATTACKER)), getVisualCivAdjective(pInterceptor->getTeam()));
			AddDLLMessage(pInterceptor->getOwner(), false, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_INTERCEPT", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_GREEN(), pPlot->getX(), pPlot->getY(), true, true);

			szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_AIR_UNIT_HURT", getNameKey(), pInterceptor->getNameKey(), -(kAirMission.getDamage(BATTLE_UNIT_ATTACKER)));
			AddDLLMessage(getOwner(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_INTERCEPTED", MESSAGE_TYPE_INFO, pInterceptor->getButton(), GC.getCOLOR_RED(), pPlot->getX(), pPlot->getY());
		}

		if (pInterceptor->isDead())
		{

			CvWString szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_SHOT_DOWN_ENEMY", getNameKey(), pInterceptor->getNameKey(), pInterceptor->getVisualCivAdjective(getTeam()));
			AddDLLMessage(getOwner(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_INTERCEPT", MESSAGE_TYPE_INFO, pInterceptor->getButton(), GC.getCOLOR_GREEN(), pPlot->getX(), pPlot->getY(), true, true);

			szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_UNIT_SHOT_DOWN", pInterceptor->getNameKey(), getNameKey());
			AddDLLMessage(pInterceptor->getOwner(), false, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_INTERCEPTED", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_RED(), pPlot->getX(), pPlot->getY());
		}
		else if (kAirMission.getDamage(BATTLE_UNIT_DEFENDER) > 0)
		{

			CvWString szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_DAMAGED_ENEMY_AIR", getNameKey(), pInterceptor->getNameKey(), -(kAirMission.getDamage(BATTLE_UNIT_DEFENDER)), pInterceptor->getVisualCivAdjective(getTeam()));
			AddDLLMessage(getOwner(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_INTERCEPT", MESSAGE_TYPE_INFO, pInterceptor->getButton(), GC.getCOLOR_GREEN(), pPlot->getX(), pPlot->getY(), true, true);

			szBuffer = gDLL->getText("TXT_KEY_MISC_YOUR_AIR_UNIT_DAMAGED", pInterceptor->getNameKey(), getNameKey(), -(kAirMission.getDamage(BATTLE_UNIT_DEFENDER)));
			AddDLLMessage(pInterceptor->getOwner(), false, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_INTERCEPTED", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_RED(), pPlot->getX(), pPlot->getY());
		}

		if (0 == kAirMission.getDamage(BATTLE_UNIT_ATTACKER) + kAirMission.getDamage(BATTLE_UNIT_DEFENDER))
		{

			CvWString szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_ABORTED_ENEMY_AIR", pInterceptor->getNameKey(), getNameKey(), getVisualCivAdjective(getTeam()));
			AddDLLMessage(pInterceptor->getOwner(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_INTERCEPT", MESSAGE_TYPE_INFO, pInterceptor->getButton(), GC.getCOLOR_GREEN(), pPlot->getX(), pPlot->getY(), true, true);

			szBuffer = gDLL->getText("TXT_KEY_MISC_YOUR_AIR_UNIT_ABORTED", getNameKey(), pInterceptor->getNameKey());
			AddDLLMessage(getOwner(), false, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_INTERCEPTED", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_RED(), pPlot->getX(), pPlot->getY());
		}
	}

	if (bFinish)
	{
		setAttackPlot(NULL, false);
		setCombatUnit(NULL);
		pInterceptor->setCombatUnit(NULL);

		if (!isDead() && isSuicide())
		{
			kill(true);
		}
	}
}

namespace {
	bool unitsAtWar(const TeamTypes ourTeam, const CvUnit* theirUnit)
	{
		return GET_TEAM(theirUnit->getTeam()).isAtWar(ourTeam);
	}

	bool plotHasEnemy(const TeamTypes ourTeam, const CvPlot* ignorePlot, const CvPlot* plot)
	{
		return plot != ignorePlot && algo::any_of(plot->units(), bind(unitsAtWar, ourTeam, _1));
	}

	bool plotHasAdjacentEnemy(const TeamTypes ourTeam, const CvPlot* ignorePlot, const CvPlot* plot)
	{
		return algo::any_of(plot->adjacent(), bind(plotHasEnemy, ourTeam, ignorePlot, _1));
	}

	bool canWithdrawToPlot(const CvUnit* withdrawingUnit, const CvPlot* toPlot)
	{
		return withdrawingUnit->canMoveInto(toPlot)
			&& !plotHasEnemy(withdrawingUnit->getTeam(), withdrawingUnit->plot(), toPlot)
			// && !plotHasAdjacentEnemy(withdrawingUnit.getTeam(), *withdrawingUnit.plot(), toPlot)
			;
	}

	bst::optional<CvPlot*> selectWithdrawPlot(bool bSamePlotCombat, const CvUnit* withdrawingUnit)
	{
		if (bSamePlotCombat)
		{
			return withdrawingUnit->plot();
		}

		return algo::find_if(withdrawingUnit->plot()->adjacent(), bind(canWithdrawToPlot, withdrawingUnit, _1));
	}
}

void CvUnit::resolveCombat(CvUnit* pDefender, CvPlot* pPlot, CvBattleDefinition& kBattle, bool bSamePlot)
{
	PROFILE_FUNC();

	CombatDetails cdAttackerDetails;
	CombatDetails cdDefenderDetails;

	AI_setPredictedHitPoints(-1);
	pDefender->AI_setPredictedHitPoints(-1);
	int iAttackerStrength = currCombatStr(NULL, NULL, &cdAttackerDetails);
	int iAttackerFirepower = currFirepower(NULL, NULL);
	int iDefenderStrength = 0;
	int iAttackerDamage = 0;
	int iDefenderDamage = 0;
	int iDefenderOdds = 0;

	bool bAttackerWithdrawn = false;
	//TB Combat Mods Begin
	m_combatResult.bAttackerPursued = false;
	m_combatResult.bDefenderPursued = false;
	m_combatResult.bAttackerPursuedSustain = false;
	m_combatResult.bDefenderPursuedSustain = false;
	m_combatResult.bAttackerRepelled = false;
	m_combatResult.bAttackerRefusedtoYield = false;
	m_combatResult.bDefenderRefusedtoYield = false;
	m_combatResult.bDefenderKnockedBack = false;
	m_combatResult.bAttackerStampedes = false;
	m_combatResult.bAttackerWithdraws = false;
	m_combatResult.bAttackerOnslaught = false;
	m_combatResult.bAttackerInjured = false;
	m_combatResult.bDefenderInjured = false;
	m_combatResult.bDeathMessaged = true;
	m_combatResult.bDefenderHitAttackerWithDistanceAttack = false;
	m_combatResult.bAttackerHitDefenderWithDistanceAttack = false;
	m_combatResult.bNeverMelee = true;
	int temporarypursuit = 0;
	int iDefenderDodge = pDefender->dodgeVSOpponentProbTotal(this);
	int iDefenderPrecision = pDefender->precisionVSOpponentProbTotal(this);
	int iAttackerDodge = dodgeVSOpponentProbTotal(pDefender);
	int iAttackerPrecision = precisionVSOpponentProbTotal(pDefender);
	bool bBreakdown = false;
	int iDefenderFirstStrikes = pDefender->getCombatFirstStrikes();
	int iAttackerFirstStrikes = getCombatFirstStrikes();
	//TB Combat Mods End
	bool bAttackerHasLostNoHP = true;
	int iAttackerInitialDamage = getDamage();
	int iDefenderInitialDamage = pDefender->getDamage();
	int iDefenderCombatRoll = 0;
	int iAttackerCombatRoll = 0;
	int WithdrawalRollResult = 0;
	int DefenderWithdrawalRollResult = 0;
	int RepelRollResult = 0;
	int PursuitRollResult = 0;
	int iAttackerHitModifier = 0;
	int iDefenderHitModifier = 0;
	int iAttackerOdds = 0;
	int	iDefenderHitChance = 0;
	int	iAttackerHitChance = 0;
	int iInitialDefXP = pDefender->getExperience100();
	int iInitialAttXP = getExperience100();
	int iInitialAttGGXP = GET_PLAYER(getOwner()).getCombatExperience();
	int iInitialDefGGXP = GET_PLAYER(pDefender->getOwner()).getCombatExperience();
	const bool bDynamicXP = GC.getGame().isModderGameOption(MODDERGAMEOPTION_IMPROVED_XP);
	bool bDoDynamic = true;

	getDefenderCombatValues(*pDefender, pPlot, iAttackerStrength, iAttackerFirepower, iDefenderOdds, iDefenderStrength, iAttackerDamage, iDefenderDamage, &cdDefenderDetails, pDefender);
	int iInitialAttackerStrength = iAttackerStrength;
	int iInitialDefenderStrength = iDefenderStrength;
#ifdef OUTBREAKS_AND_AFFLICTIONS
	//TB Combat Mods Begin
	for (int iI = 0; iI < GC.getNumPromotionLineInfos(); iI++)
	{
		if (hasAfflictOnAttackType((PromotionLineTypes)iI))
		{
			setAfflictOnAttackTypeAttemptedCount((PromotionLineTypes)iI, 0);
		}
		if (pDefender->hasAfflictOnAttackType((PromotionLineTypes)iI))
		{
			pDefender->setAfflictOnAttackTypeAttemptedCount((PromotionLineTypes)iI, 0);
		}
	}
#endif
	//  Determine Attack Withdraw odds
	int iHitLimitThem = pDefender->getMaxHP() - combatLimit(pDefender);

	int iNeededRoundsUs = (iDefenderDamage == 0 ? MAX_INT : (std::max(0, pDefender->getHP() - iHitLimitThem) + iDefenderDamage - 1 ) / iDefenderDamage);
	int iNeededRoundsThem = (iAttackerDamage == 0 ? MAX_INT : (std::max(0, getHP()) + iAttackerDamage - 1 ) / iAttackerDamage);
	int iAttackerWithdraw = withdrawVSOpponentProbTotal(pDefender, pPlot);
	int iDefenderPursuit = pDefender->pursuitVSOpponentProbTotal(this);
	int iAttackerEarly = earlyWithdrawTotal();

	int AdjustedAttWithdrawalstep1 = iAttackerWithdraw - iDefenderPursuit;
	int AdjustedAttWithdrawalstep2 = std::min(100, AdjustedAttWithdrawalstep1);
	int AdjustedAttWithdrawal = std::max(0, AdjustedAttWithdrawalstep2);

	int expectedrndcnt = std::min(iNeededRoundsUs, iNeededRoundsThem);
	int expectedrnds = ((expectedrndcnt * iAttackerEarly)/100);

	int y = AdjustedAttWithdrawal;
	int z = AdjustedAttWithdrawal;
	int Time;
	for (Time = 0; Time < expectedrnds; ++Time)
	{
		z += ((AdjustedAttWithdrawal * y)/100);
		y = ((AdjustedAttWithdrawal * (100 - z))/100);	//	Prob next round is prob per round times prob you haven't already
	}

	int EvaluatedAttWithdrawOdds = z;


	int iAttackerKnockback = knockbackVSOpponentProbTotal(pDefender);
	int iDefenderUnyielding = pDefender->unyieldingTotal();
	int iAttackerKnockbackTries = knockbackRetriesTotal();

	int AdjustedKnockbackstep1 = iAttackerKnockback - iDefenderUnyielding;
	int AdjustedKnockbackstep2 = ((AdjustedKnockbackstep1 > 100) ? 100 : AdjustedKnockbackstep1);
	int AdjustedKnockback = ((AdjustedKnockbackstep2 < 0) ? 0 : AdjustedKnockbackstep2);

	y = AdjustedKnockback;
	z = AdjustedKnockback;

	for (Time = 0; Time < iAttackerKnockbackTries; ++Time)
	{
		z += ((AdjustedKnockback * y)/100);
		y = ((AdjustedKnockback * (100 - z))/100);	//	Prob next round is prob per round times prob you haven't already
	}

	int EvaluatedKnockbackOdds = z;
	//Original: int iAttackerKillOdds = iDefenderOdds * (100 - withdrawalProbability()) / 100;
	int iAttackerKillOdds = iDefenderOdds * (100 - (EvaluatedAttWithdrawOdds)) / 100;

	iAttackerKillOdds *= (100 - (EvaluatedKnockbackOdds));
	iAttackerKillOdds /= 100;
	//TB Combat Mods End

	if (isHuman() || pDefender->isHuman())
	{
		//Added ST
		CyArgsList pyArgsCD;
		pyArgsCD.add(gDLL->getPythonIFace()->makePythonObject(&cdAttackerDetails));
		pyArgsCD.add(gDLL->getPythonIFace()->makePythonObject(&cdDefenderDetails));
		pyArgsCD.add(getCombatOdds(this, pDefender));
		CvEventReporter::getInstance().genericEvent("combatLogCalc", pyArgsCD.makeFunctionArgs());
	}

	collateralCombat(pPlot, pDefender);

	int iCloseCombatRoundNum = -1;
	//bool bTryMobileWithdraw = false;	//if unit will be trying to withdraw from a plot it occupies
	//if (pPlot->getNumDefenders(pDefender->getOwner()) == 1 && pDefender->baseMoves() > baseMoves())	//must be faster than attacker
	//{
	//	bTryMobileWithdraw = true;
	//}
	int iWinningOdds = getCombatOdds(this, pDefender);
	bool bDefenderSkirmish = false; //iWinningOdds > 60;
	m_combatResult.bDefenderWithdrawn = false;
	m_combatResult.pPlot = NULL;
	m_combatResult.iTurnCount++;
	//Compile the Repel values only once as necessary
	int iDefenderRepel = pDefender->repelVSOpponentProbTotal(this);
	int iAttackerUnyielding = unyieldingTotal();

	int AdjustedRepelstep1 = iDefenderRepel - iAttackerUnyielding;
	int AdjustedRepelstep2 = ((AdjustedRepelstep1 > 100) ? 100 : AdjustedRepelstep1);
	int AdjustedRepel = ((AdjustedRepelstep2 < 0) ? 0 : AdjustedRepelstep2);
	bool bNoFurtherDamagetoDefender = false;


	int iDefenderWithdraw = pDefender->withdrawVSOpponentProbTotal(this, pPlot);
	int iAttackerPursuit = pursuitVSOpponentProbTotal(pDefender);
	int iDefenderEarlyWithdraw = pDefender->earlyWithdrawTotal();

	int AdjustedDefWithdrawstep1 = iDefenderWithdraw - iAttackerPursuit;
	int AdjustedDefWithdrawstep2 = ((AdjustedDefWithdrawstep1 > 100) ? 100 : AdjustedDefWithdrawstep1);
	int AdjustedDefWithdraw = ((AdjustedDefWithdrawstep2 < 0) ? 0 : AdjustedDefWithdrawstep2);

	bool bVanillaCombat = GC.getGame().isOption(GAMEOPTION_VANILLA_COMBAT_ENGINE);
	if (bVanillaCombat)
	{
		iAttackerStrength = currCombatStr(NULL, NULL, &cdAttackerDetails);
		iAttackerFirepower = currFirepower(NULL, NULL);
		getDefenderCombatValues(*pDefender, pPlot, iAttackerStrength, iAttackerFirepower, iDefenderOdds, iDefenderStrength, iAttackerDamage, iDefenderDamage, &cdDefenderDetails, pDefender);
		iDefenderHitChance = std::max(5, iDefenderOdds + ((iDefenderHitModifier * iDefenderOdds)/100));
		iAttackerHitChance = std::max(5, iAttackerOdds + ((iAttackerHitModifier * iAttackerOdds)/100));
	}

	while (true)
	{
		//TB Combat Mods (StrAdjperRnd) begin
		changeRoundCount(1);
		pDefender->changeRoundCount(1);
		if (!bVanillaCombat)
		{
			iAttackerStrength = currCombatStr(NULL, NULL, &cdAttackerDetails);
			iAttackerFirepower = currFirepower(NULL, NULL);
			getDefenderCombatValues(*pDefender, pPlot, iAttackerStrength, iAttackerFirepower, iDefenderOdds, iDefenderStrength, iAttackerDamage, iDefenderDamage, &cdDefenderDetails, pDefender);
			iDefenderHitChance = std::max(5, iDefenderOdds + ((iDefenderHitModifier * iDefenderOdds)/100));
			iAttackerHitChance = std::max(5, iAttackerOdds + ((iAttackerHitModifier * iAttackerOdds)/100));
		}

		//Check if this is a Breakdown Attack round and adjust the local bool so as to avoid reprocessing the Breakdown check multiple times per round.
		if (isBreakdownCombat(pPlot, bSamePlot) && /*getCombatFirstStrikes() == 0 &&*/ pDefender->getCombatFirstStrikes() == 0)
		{
			bBreakdown = true;
		}
		else
		{
			bBreakdown = false;
		}
		//TB Combat Mods (StrAdjperRnd) end

		//TB Combat Mods begin
		if (getCombatPowerShots() > 0)
		{
			iAttackerPrecision += powerShotPrecisionModifierTotal();
		}
		if (pDefender->getCombatPowerShots() > 0)
		{
			iDefenderPrecision += pDefender->powerShotPrecisionModifierTotal();
		}
		iAttackerHitModifier = iAttackerPrecision - iDefenderDodge;
		iDefenderHitModifier = iDefenderPrecision - iAttackerDodge;
		iAttackerOdds = std::max((GC.getCOMBAT_DIE_SIDES() - iDefenderOdds), 0);
		iDefenderCombatRoll = GC.getGame().getSorenRandNum(GC.getCOMBAT_DIE_SIDES(), "DefenderCombatRoll");
		iAttackerCombatRoll = GC.getGame().getSorenRandNum(GC.getCOMBAT_DIE_SIDES(), "AttackerCombatRoll");
		WithdrawalRollResult = GC.getGame().getSorenRandNum(100, "Withdrawal");
		DefenderWithdrawalRollResult = GC.getGame().getSorenRandNum(100, "DefenderWithdrawal");
		RepelRollResult = GC.getGame().getSorenRandNum(100, "Repel");
		PursuitRollResult = GC.getGame().getSorenRandNum(100, "Pursuit");
		//Breakdown attack round?  If so we make the damage the defender would be dealt 0 and the chance of the attcker
		//hitting absolute so as to get through all normal checks to roll the chance for damaging the defenses while the
		//unit really does not engage in any counterattack against the defender.
		//TB Breakdown Adjustment: Finding this is probably not appropriate.  Better to allow actual combat to take place though
		//we may need to reduce the strengths on Rams some...  I'll probably end up making this more what I was looking for
		//when I get into the H2H/Distance mechanism.
		//if (bBreakdown)
		//{
		//	iDefenderDamage = 0;
		//	iAttackerHitChance = 10000;
		//}

		//TB Combat Mods (Breakdown) begin
		//Changes: No longer requires any particular combat result to make happen - previously attacker had to hit and since it had originally been setup to always hit so long as first strikes weren't taking place, the ram was rarely doing much damage.
		//I had made all rams immune to first strike though I'd prefer not to at this point... I can take that away now and allow the first strike rounds to take place as intended.
		if (bBreakdown)
		{
			resolveBreakdownAttack(pPlot, AdjustedRepel);
			changeExperience100(10, MAX_INT, false, false, true);
		}
		bool bNeitherRanged = (!pDefender->isRanged() && !isRanged());
		bool bDefenderRangedbutOutofFS = (pDefender->isRanged() && pDefender->getCombatFirstStrikes() < 1);
		bool bDefenderNotRanged = (pDefender->isRanged());
		bool bAttackerRangedbutOutofFS = (pDefender->isRanged() && pDefender->getCombatFirstStrikes() < 1);
		bool bAttackerNotRanged = (isRanged());
		if (bNeitherRanged ||
			((bDefenderRangedbutOutofFS || bDefenderNotRanged) &&
			(bAttackerRangedbutOutofFS || bAttackerNotRanged)))
		{
			m_combatResult.bNeverMelee = false;
		}
		//Defender's attack round
		if (pDefender->getCombatStuns() == 0 && iDefenderCombatRoll < iDefenderHitChance)
		{
			if (getCombatFirstStrikes() == 0)
			{
				//TB Combat Mods Begin
				//Original Code:
				//if (getDamage() + iAttackerDamage >= getMaxHP()&& GC.getGame().getSorenRandNum(100, "Withdrawal") < withdrawalProbability())
				//{
				//	flankingStrikeCombat(pPlot, iAttackerStrength, iAttackerFirepower, iAttackerKillOdds, iDefenderDamage, pDefender, bSamePlot);

				//	bAttackerWithdrawn = true;

/**	Great Generals From Barbarian Combat Start													**/

				//if (!bDynamicXP)
				//	changeExperience(GC.getDefineINT("EXPERIENCE_FROM_WITHDRAWL"), maxXPValue(pDefender), true, pPlot->getOwner() == getOwner(), true);

// BUG - Combat Events - start
				//	CvEventReporter::getInstance().combatRetreat(this, pDefender);
// BUG - Combat Events - end
				//	break;
				//}

				//New Coding (Attacker Attempts Withdrawal):

				if ((getDamage() + iAttackerDamage) >= withdrawalHP(getMaxHP(), iAttackerEarly) && iAttackerWithdraw > 0)
				{
					if (WithdrawalRollResult < AdjustedAttWithdrawal)
					{
						flankingStrikeCombat(pPlot, iAttackerStrength, iAttackerFirepower, iAttackerKillOdds, iDefenderDamage, pDefender);
						bAttackerWithdrawn = true;

						changeExperience100(getExperiencefromWithdrawal(AdjustedAttWithdrawal) * 10, MAX_INT, true, pPlot->getOwner() == getOwner(), true);

						int iExperience = defenseXPValue();
						iExperience = ((iExperience * iInitialAttackerStrength) / iInitialDefenderStrength);
						iExperience = range(iExperience, GC.getMIN_EXPERIENCE_PER_COMBAT(), GC.getMAX_EXPERIENCE_PER_COMBAT());
						changeExperience100(iExperience * 10, MAX_INT, true, pPlot->getOwner() == getOwner(), true);
						pDefender->changeExperience100(10, MAX_INT, true, pPlot->getOwner() == pDefender->getOwner(), true);
						bDoDynamic = false;

// BUG - Combat Events - start
						CvEventReporter::getInstance().combatRetreat(this, pDefender);
						m_combatResult.bAttackerWithdraws = true;
						m_combatResult.bDeathMessaged = false;
// BUG - Combat Events - end
						break;
					}
					else if ((WithdrawalRollResult < iAttackerWithdraw) && (WithdrawalRollResult > AdjustedAttWithdrawal))
					{
						if ((getDamage() + iAttackerDamage) < getMaxHP())
						{
							m_combatResult.bAttackerPursuedSustain = true;
						}
						else
						{
							m_combatResult.bAttackerPursued = true;
						}
					}
				}
				//TB Combat Mod (Afflict) begin
				if (iAttackerDamage > 0)
				{
					m_combatResult.bAttackerInjured = true;
				}
				//TB Combat Mod (Afflict) end
				changeDamage(iAttackerDamage, pDefender->getOwner());
				//TB Combat Mod begin
				checkForStun(iAttackerDamage, pDefender);
#ifdef OUTBREAKS_AND_AFFLICTIONS
				checkForCritical(iAttackerDamage, pDefender);
#endif
				if (pDefender->dealsColdDamage())
				{
					changeColdDamage(iAttackerDamage);
				}
				//TB Combat Mod end

				bAttackerHasLostNoHP = false;

				if (pDefender->getCombatFirstStrikes() > 0 && pDefender->isRanged())
				{
					kBattle.addFirstStrikes(BATTLE_UNIT_DEFENDER, 1);
					kBattle.addDamage(BATTLE_UNIT_ATTACKER, BATTLE_TIME_RANGED, iAttackerDamage);
				}

				cdAttackerDetails.iCurrHitPoints = getHP();

				if (isHuman() || pDefender->isHuman())
				{
					CyArgsList pyArgs;
					pyArgs.add(gDLL->getPythonIFace()->makePythonObject(&cdAttackerDetails));
					pyArgs.add(gDLL->getPythonIFace()->makePythonObject(&cdDefenderDetails));
					pyArgs.add(1);
					pyArgs.add(iAttackerDamage);
					CvEventReporter::getInstance().genericEvent("combatLogHit", pyArgs.makeFunctionArgs());
				}
				//TB Combat Mods Begin (Repel)
				//within the 'after attacker's first strikes segment'


				if (pDefender->getCombatRepels() > 0)
				{
					if (RepelRollResult < AdjustedRepel)
					{
						m_combatResult.bAttackerRepelled = true;
						m_combatResult.bDeathMessaged = false;

						pDefender->changeExperience100(getExperiencefromWithdrawal(AdjustedRepel) * 15, MAX_INT, true, pPlot->getOwner() == getOwner(), true);
						bDoDynamic = false;

						break;
					}
					else if (RepelRollResult < iDefenderRepel && RepelRollResult > AdjustedRepel)
					{
						if ((pDefender->getDamage() + iDefenderDamage) < pDefender->getMaxHP())
						{
							m_combatResult.bAttackerRefusedtoYieldSustain = true;
						}
						else
						{
							m_combatResult.bAttackerRefusedtoYield = true;
						}
					}
				}
				if (pDefender->getCombatFirstStrikes() > 0 && pDefender->isRanged())
				{
					m_combatResult.bDefenderHitAttackerWithDistanceAttack = true;
				}
#ifdef OUTBREAKS_AND_AFFLICTIONS
				if (GC.getGame().isOption(GAMEOPTION_OUTBREAKS_AND_AFFLICTIONS))
				{
					PROFILE("CvUnit::resolveCombat.Afflictions");

					for (int iI = 0; iI < GC.getNumPromotionLineInfos(); iI++)
					{
						if (GC.getPromotionLineInfo((PromotionLineTypes)iI).isAffliction() && !GC.getPromotionLineInfo((PromotionLineTypes)iI).isCritical())
						{
							PromotionLineTypes eAfflictionLine = ((PromotionLineTypes)iI);
							if (pDefender->hasAfflictOnAttackType(eAfflictionLine) &&
								pDefender->isAfflictOnAttackTypeImmediate(eAfflictionLine) &&
								pDefender->isAfflictOnAttackTypeAttempted(eAfflictionLine) == false)
							{
								bool bDistanceQualified = ((pDefender->getCombatFirstStrikes() > 0 && pDefender->isAfflictOnAttackTypeDistance(eAfflictionLine) && pDefender->isRanged()) ||
															((pDefender->getCombatFirstStrikes() < 1 || !pDefender->isRanged()) && pDefender->isAfflictOnAttackTypeMelee(eAfflictionLine) && !(getCombatFirstStrikes() > 0 && isRanged())));
								if (bDistanceQualified)
								{
									int iDefendersPoisonChance = pDefender->getAfflictOnAttackTypeProbability(eAfflictionLine) - fortitudeTotal() - getUnitAfflictionTolerance(eAfflictionLine);
									if (GC.getGame().getSorenRandNum(100, "DefendersPoisonRoll") < iDefendersPoisonChance)
									{
										afflict(eAfflictionLine, true, pDefender);
									}
									pDefender->changeAfflictOnAttackTypeAttemptedCount(eAfflictionLine, 1);
								}
							}
						}
					}
				}
#endif // OUTBREAKS_AND_AFFLICTIONS
			}
		}
		//Attacker's attack round
		if (getCombatStuns() == 0 && ((bVanillaCombat && iDefenderCombatRoll >= iDefenderHitChance) || (iAttackerCombatRoll < iAttackerHitChance)))
		{
			if (pDefender->getCombatFirstStrikes() == 0)
			{
				if (GC.getGame().isModderGameOption(MODDERGAMEOPTION_DEFENDER_WITHDRAW))
				{
					iCloseCombatRoundNum++;
				}
				//TB Combat Mods Begin
				//Attacker attempts withdrawal due to combatlimit
				if ((std::min(pDefender->getMaxHP(), pDefender->getDamage() + iDefenderDamage) > combatLimit(pDefender)) && (PursuitRollResult > pDefender->pursuitVSOpponentProbTotal(this)))
				{
					if (!bBreakdown || getDamage() > combatLimit(this))
					{
						int iWithdrawOdds = 100 - pDefender->pursuitVSOpponentProbTotal(this);
						changeExperience100(getExperiencefromWithdrawal(iWithdrawOdds) * 100, maxXPValue(pDefender), true, pPlot->getOwner() == getOwner(), true);

						int iExperience = defenseXPValue();
						iExperience = ((iExperience * iInitialAttackerStrength) / iInitialDefenderStrength);
						iExperience = range(iExperience, GC.getMIN_EXPERIENCE_PER_COMBAT(), GC.getMAX_EXPERIENCE_PER_COMBAT());
						changeExperience100(iExperience * 10, MAX_INT, true, pPlot->getOwner() == getOwner(), true);
						pDefender->changeExperience100(10, MAX_INT, true, pPlot->getOwner() == pDefender->getOwner(), true);
						bDoDynamic = false;

						if (temporarypursuit == 0)
						{
							m_combatResult.bDeathMessaged = false;
							pDefender->setDamage(combatLimit(pDefender), getOwner());
							if (dealsColdDamage())
							{
								pDefender->setColdDamage(combatLimit(pDefender));
							}
						}
						temporarypursuit = 0;
						break;
					}
					else
					{
						bNoFurtherDamagetoDefender = true;
					}
				}
				else if ((std::min(pDefender->getMaxHP(), pDefender->getDamage() + iDefenderDamage) > combatLimit(pDefender)) && (PursuitRollResult < pDefender->pursuitVSOpponentProbTotal(this)) && pDefender->pursuitVSOpponentProbTotal(this) > 0)
				{
					if (!bBreakdown || getDamage() > combatLimit(this))
					{
						temporarypursuit += 1;
						m_combatResult.bAttackerPursuedSustain = true;
					}
				}
				// Current Code (Defender Attempts Withdrawal):

				if  ((!pPlot->isCity(true, pDefender->getTeam()) || bSamePlot) && GC.getGame().isModderGameOption(MODDERGAMEOPTION_DEFENDER_WITHDRAW) && ((pDefender->getDamage() + iDefenderDamage) >= withdrawalHP(pDefender->getMaxHP(), iDefenderEarlyWithdraw) || bDefenderSkirmish) && !isSuicide() && iCloseCombatRoundNum > 0 && pDefender->withdrawVSOpponentProbTotal(this, pPlot) > 0)	//can not to escape at close combat round 1
				{
					if (DefenderWithdrawalRollResult < AdjustedDefWithdraw)
					{
						bst::optional<CvPlot*> withdrawPlot = selectWithdrawPlot(bSamePlot, pDefender);
						if (withdrawPlot)
						{
							m_combatResult.pPlot = *withdrawPlot;
							m_combatResult.bDefenderWithdrawn = true;
							m_combatResult.bDeathMessaged = false;

							pDefender->changeExperience100(getExperiencefromWithdrawal(AdjustedDefWithdraw) * 10, -1, true, pPlot->getOwner() == pDefender->getOwner(), true);
							changeExperience100(10, -1, true, pPlot->getOwner() == getOwner(), true);
							return;
						}
					}
					else if (DefenderWithdrawalRollResult < iDefenderWithdraw && DefenderWithdrawalRollResult > AdjustedDefWithdraw)
					{
						if ((pDefender->getDamage() + iDefenderDamage) < pDefender->getMaxHP())
						{
							m_combatResult.bDefenderPursuedSustain = true;
						}
						else
						{
							m_combatResult.bDefenderPursued = true;
						}
					}
				}

//TB Combat Mods End

				//TB Combat Mods (Afflict) begin
				if (iDefenderDamage > 0)
				{
					if (!bNoFurtherDamagetoDefender)
					{
						m_combatResult.bDefenderInjured = true;
						pDefender->changeDamage(iDefenderDamage, getOwner());
					}
				}
				//TB Combat Mods (Afflict) end
				//TB Combat Mods Begin
				if (!bBreakdown)
				{
					pDefender->checkForStun(iDefenderDamage, this);
#ifdef OUTBREAKS_AND_AFFLICTIONS
					pDefender->checkForCritical(iDefenderDamage, this);
#endif
					if (dealsColdDamage())
					{
						pDefender->changeColdDamage(iDefenderDamage);
					}
				}
				//TB Combat Mods End

				if (getCombatFirstStrikes() > 0 && isRanged())
				{
					kBattle.addFirstStrikes(BATTLE_UNIT_ATTACKER, 1);
					kBattle.addDamage(BATTLE_UNIT_DEFENDER, BATTLE_TIME_RANGED, iDefenderDamage);
				}

				cdDefenderDetails.iCurrHitPoints=pDefender->getHP();

				if (isHuman() || pDefender->isHuman())
				{
					CyArgsList pyArgs;
					pyArgs.add(gDLL->getPythonIFace()->makePythonObject(&cdAttackerDetails));
					pyArgs.add(gDLL->getPythonIFace()->makePythonObject(&cdDefenderDetails));
					pyArgs.add(0);
					pyArgs.add(iDefenderDamage);
					CvEventReporter::getInstance().genericEvent("combatLogHit", pyArgs.makeFunctionArgs());
				}

				//TB Combat Mods (Knockback and attacker affliction)
				if (!bBreakdown && !pDefender->isDead())
				{
					if (!bSamePlot)
					{
						int KnockbackRollResult = GC.getGame().getSorenRandNum(100, "Knockback");

						if (getCombatKnockbacks() > 0)
						{
							if (KnockbackRollResult < AdjustedKnockback)
							{
								m_combatResult.bDefenderKnockedBack = true;
								m_combatResult.bDeathMessaged = false;
								m_combatResult.pPlot = selectWithdrawPlot(bSamePlot, pDefender).get_value_or(nullptr);
								changeExperience100(getExperiencefromWithdrawal(AdjustedKnockback) * 15, MAX_INT, true, pPlot->getOwner() == getOwner(), true);
								return;
							}
							else if ((KnockbackRollResult < iAttackerKnockback) && (KnockbackRollResult > AdjustedKnockback))
							{
								if ((pDefender->getDamage() + iDefenderDamage) < getMaxHP())
								{
									m_combatResult.bDefenderRefusedtoYieldSustain = true;
								}
								else
								{
									m_combatResult.bDefenderRefusedtoYield = true;
								}
							}
						}
					}
					if (getCombatFirstStrikes() > 0 && isRanged())
					{
						m_combatResult.bAttackerHitDefenderWithDistanceAttack = true;
					}
#ifdef OUTBREAKS_AND_AFFLICTIONS
					if (GC.getGame().isOption(GAMEOPTION_OUTBREAKS_AND_AFFLICTIONS))
					{
						for (int iI = 0; iI < GC.getNumPromotionLineInfos(); iI++)
						{
							if (GC.getPromotionLineInfo((PromotionLineTypes)iI).isAffliction() && !GC.getPromotionLineInfo((PromotionLineTypes)iI).isCritical())
							{
								PromotionLineTypes eAfflictionLine = ((PromotionLineTypes)iI);
								if (hasAfflictOnAttackType(eAfflictionLine) &&
									isAfflictOnAttackTypeImmediate(eAfflictionLine) &&
									isAfflictOnAttackTypeAttempted(eAfflictionLine) == false)
								{
									bool bDistanceQualified = ((getCombatFirstStrikes() > 0 && isAfflictOnAttackTypeDistance(eAfflictionLine) && isRanged()) ||
															((getCombatFirstStrikes() < 1 || !isRanged()) && isAfflictOnAttackTypeMelee(eAfflictionLine) && !(pDefender->getCombatFirstStrikes() > 0 && pDefender->isRanged())));
									if (bDistanceQualified)
									{
										int iAttackersPoisonChance = getAfflictOnAttackTypeProbability(eAfflictionLine) - pDefender->fortitudeTotal() - pDefender->getUnitAfflictionTolerance(eAfflictionLine);

										if (GC.getGame().getSorenRandNum(100, "AttackersPoisonRoll") < iAttackersPoisonChance)
										{
											pDefender->afflict(eAfflictionLine, true, this);
										}
										changeAfflictOnAttackTypeAttemptedCount(eAfflictionLine, 1);
									}
								}
							}
						}
					}
#endif // OUTBREAKS_AND_AFFLICTIONS
				}
			}
		}
		//TB Combat Mods begin
		if (pDefender->getCombatFirstStrikes() == 0 && getCombatPowerShots() > 0)
		{
			if (!bBreakdown)
			{
				changeCombatPowerShots(-1);
			}
		}

		if (getCombatFirstStrikes() == 0 && pDefender->getCombatPowerShots() > 0)
		{
			pDefender->changeCombatPowerShots(-1);
		}

		if ((getCombatKnockbacks() > 0) && (pDefender->getCombatFirstStrikes() == 0))
		{
			if (!bBreakdown && !bSamePlot)
			{
				changeCombatKnockbacks(-1);
			}
		}

		if ((pDefender->getCombatRepels() > 0) && (getCombatFirstStrikes() == 0))
		{
			pDefender->changeCombatRepels(-1);
		}

		if (getCombatStuns() > 0)
		{
			if (!bBreakdown)
			{
				changeCombatStuns(-1);
			}
		}

		if (pDefender->getCombatStuns() > 0)
		{
			pDefender->changeCombatStuns(-1);
		}
		//TB Combat Mods end
		if (pDefender->getCombatStuns() == 0 && getCombatFirstStrikes() > 0)
		{
			changeCombatFirstStrikes(-1);
		}

		if (getCombatStuns() == 0 && pDefender->getCombatFirstStrikes() > 0)
		{
			pDefender->changeCombatFirstStrikes(-1);
		}

		if (isDead() || pDefender->isDead())
		{
			if (isDead())
			{
				int iExperience = pDefender->defenseXPValue();
				iExperience = ((iExperience * iInitialAttackerStrength) / iInitialDefenderStrength);
				iExperience = range(iExperience, GC.getMIN_EXPERIENCE_PER_COMBAT(), GC.getMAX_EXPERIENCE_PER_COMBAT());
				if (!bDynamicXP)
				{
					pDefender->changeExperience(iExperience, pDefender->maxXPValue(this), true, pPlot->getOwner() == pDefender->getOwner(), true);
				}

				//	Koshling - add rolling history of combat results to allow the AI to adapt to what it sees happening
				pPlot->area()->recordCombatDeath(getOwner(), getUnitType(), pDefender->getUnitType());
			}
			else
			{
				flankingStrikeCombat(pPlot, iAttackerStrength, iAttackerFirepower, iAttackerKillOdds, iDefenderDamage, pDefender);//TB Note: Place again in the successful withdrawal segment if its not already there.  This may need debugging as well based on reports.

				int iExperience = attackXPValue();
				iExperience = ((iExperience * iInitialDefenderStrength) / std::max(1,iInitialAttackerStrength));
				iExperience = range(iExperience, GC.getMIN_EXPERIENCE_PER_COMBAT(), GC.getMAX_EXPERIENCE_PER_COMBAT());

				if (!bDynamicXP)
				{
					changeExperience(iExperience, maxXPValue(pDefender), true, pPlot->getOwner() == getOwner(), true);
				}

				//	Koshling - add rolling history of combat results to allow the AI to adapt
				//	to what it sees happening
				pPlot->area()->recordCombatDeath(pDefender->getOwner(), pDefender->getUnitType(), getUnitType());
			}
			break;
		}
	}

	bool bPromotion = false;
	bool bDefPromotion = false;
	int iNonLethalAttackWinChance = std::max(AdjustedAttWithdrawal, AdjustedKnockback);
	iNonLethalAttackWinChance = std::max(0,iNonLethalAttackWinChance);
	int iNonLethalDefenseWinChance = std::max(AdjustedDefWithdraw, AdjustedRepel);
	iNonLethalDefenseWinChance = std::max(0,iNonLethalDefenseWinChance);
	doBattleFieldPromotions(pDefender, cdDefenderDetails, pPlot, bAttackerHasLostNoHP, bAttackerWithdrawn, iAttackerInitialDamage, iWinningOdds, iInitialAttXP, iInitialAttGGXP, iDefenderInitialDamage, iInitialDefXP, iInitialDefGGXP, bPromotion, bDefPromotion, iNonLethalAttackWinChance, iNonLethalDefenseWinChance, iDefenderFirstStrikes, iAttackerFirstStrikes);
	if (bDoDynamic) //TB Note: for both doBattleFieldPromotions and doDynamicXP, the iWinningOdds needs adjusted by YOUR ability to withdraw - if you have withdrawn at least.  Check the instance there.
	{
		doDynamicXP(pDefender, pPlot, iAttackerInitialDamage, iWinningOdds, iDefenderInitialDamage, iInitialAttXP, iInitialDefXP, iInitialAttGGXP, iInitialDefGGXP, bPromotion, bDefPromotion);
	}
}


void CvUnit::updateCombat(bool bQuick, CvUnit* pSelectedDefender, bool bSamePlot, bool bStealth, bool bNoCache)
{
	PROFILE_FUNC();

	/*GC.getGame().logOOSSpecial(6, getID(), getDamage());*/

	if (bStealth)
	{
		bNoCache = true;
	}

	bool bFinish = false;

	if (getCombatTimer() > 0)
	{
		changeCombatTimer(-1);
		if (getCombatTimer() > 0)
		{
			/*GC.getGame().logOOSSpecial(7, getID(), getDamage());*/
			return;
		}
		bFinish = true;
	}

	CvPlot* pPlot = getAttackPlot();

	if (pPlot == NULL)
	{
		/*GC.getGame().logOOSSpecial(8, getID(), getDamage());*/
		return;
	}

	if (getDomainType() == DOMAIN_AIR)
	{
		updateAirStrike(pPlot, bQuick, bFinish);
		/*GC.getGame().logOOSSpecial(9, getID(), getDamage());*/
		return;
	}

	CvUnit* pDefender = NULL;
	if (bFinish)
	{
		pDefender = getCombatUnit();
	}
	else if (pSelectedDefender == NULL)
	{
		pDefender = pPlot->getBestDefender(NO_PLAYER, getOwner(), this, true, false, false, false, bNoCache);
	}
	else
	{
		pDefender = pSelectedDefender;
	}

	if (pDefender == NULL)
	{
		setAttackPlot(NULL, false);
		setCombatUnit(NULL);

		if (!bSamePlot)
		{
			getGroup()->groupMove(pPlot, true, ((canAdvance(pPlot, 0)) ? this : NULL));
		}

		getGroup()->clearMissionQueue();

		/*GC.getGame().logOOSSpecial(10, getID(), getDamage());*/
		return;
	}
	const bool bHuman = isHuman();
	const bool bHumanDefender = pDefender->isHuman();

	//check if quick combat
	const bool bVisible = !bQuick && !bSamePlot && isCombatVisible(pDefender);

	//FAssertMsg((pPlot == pDefender->plot()), "There is not expected to be a defender or the defender's plot is expected to be pPlot (the attack plot)");

	const PlayerTypes eAttacker = getVisualOwner(pDefender->getTeam());
	const PlayerTypes eDefender = pDefender->getVisualOwner(getTeam());

	//if not finished and not fighting yet, set up combat damage and mission
	if (!bFinish)
	{
		if (!isFighting())
		{
			PROFILE("CvUnit::updateCombat.StartFight");

			if (!bStealth && (plot()->isFighting() || pPlot->isFighting()))
			{
				/*GC.getGame().logOOSSpecial(11, getID(), getDamage());*/
				return;
			}
			//TB Combat Mods (Att&DefCounters)
			if (getRoundCount() > 0)
			{
				changeRoundCount(-getRoundCount());
			}
			if (pDefender->getRoundCount() > 0)
			{
				pDefender->changeRoundCount(-pDefender->getRoundCount());
			}
			changeAttackCount(1);
			//TB Combat Mods end
			if (!bSamePlot)
			{
				//rotate to face plot
				DirectionTypes newDirection = estimateDirection(this->plot(), pDefender->plot());
				if (newDirection != NO_DIRECTION)
				{
					setFacingDirection(newDirection);
				}

				//rotate enemy to face us
				newDirection = estimateDirection(pDefender->plot(), this->plot());
				if (newDirection != NO_DIRECTION)
				{
					pDefender->setFacingDirection(newDirection);
				}
			}

			const bool bStealthAttack = isInvisible(GET_PLAYER(pDefender->getOwner()).getTeam(), false, false) || pDefender->plot() == plot();
			if (bStealthAttack)
			{

				if (bHuman)
				{
					AddDLLMessage(
						getOwner(), false, GC.getEVENT_MESSAGE_TIME(),
						gDLL->getText("TXT_KEY_MISC_STEALTH_ATTACK_OWNER", getNameKey(), GET_PLAYER(eDefender).getNameKey(), pDefender->getNameKey()),
						"AS2D_EXPOSED", MESSAGE_TYPE_MINOR_EVENT, getButton(), GC.getCOLOR_UNIT_TEXT(), getX(), getY(), true, true
					);
				}
				if (bHumanDefender)
				{
					AddDLLMessage(
						pDefender->getOwner(), false, GC.getEVENT_MESSAGE_TIME(),
						gDLL->getText("TXT_KEY_MISC_STEALTH_ATTACK", GET_PLAYER(eAttacker).getNameKey(), getNameKey(), pDefender->getNameKey()),
						"AS2D_EXPOSED", MESSAGE_TYPE_MINOR_EVENT, getButton(), GC.getCOLOR_UNIT_TEXT(), getX(), getY(), true, true
					);
				}
			}
			bool bStealthDefense = false;
			if (bStealthAttack || bStealth)
			{
				const bool bLieInWait = !isInvisible(GET_PLAYER(pDefender->getOwner()).getTeam(), false, false) && pDefender->plot() == plot();

				bStealthDefense = bStealth || bLieInWait;
				if (bStealthDefense && bLieInWait)
				{

					if (bHumanDefender)
					{
						AddDLLMessage(
							pDefender->getOwner(), false, GC.getEVENT_MESSAGE_TIME(),
							gDLL->getText("TXT_KEY_MISC_STEALTH_LIE_IN_WAIT_OWNER", pDefender->getNameKey(), GET_PLAYER(getOwner()).getNameKey(), getNameKey()),
							"AS2D_EXPOSED", MESSAGE_TYPE_MINOR_EVENT, getButton(), GC.getCOLOR_UNIT_TEXT(), getX(), getY(), true, true
						);
					}
					if (bHuman)
					{
						AddDLLMessage(
							getOwner(), false, GC.getEVENT_MESSAGE_TIME(),
							gDLL->getText("TXT_KEY_MISC_STEALTH_LIE_IN_WAIT", GET_PLAYER(eAttacker).getNameKey(), getNameKey(), pDefender->getNameKey()),
							"AS2D_EXPOSED", MESSAGE_TYPE_MINOR_EVENT, getButton(), GC.getCOLOR_UNIT_TEXT(), getX(), getY(), true, true
						);
					}
				}
			}
			m_combatResult.bStealthDefense = bStealthDefense && !(pDefender->plot() == plot());//Note this information is transferred to bStealthDefense during bFinish routine to help define whether units should lose movement or not.
			//TBMaybeproblem : I'd like to elminate this from attackers in a stealth defense situation - they shouldn't be counted as having attacked for being ambushed.
			if (!canStampede() && !canOnslaught() && !bStealthDefense)
			{
				setMadeAttack(true);
			}
			setCombatUnit(pDefender, true, bStealthAttack, bStealthDefense);
			pDefender->setCombatUnit(this, false, bStealthAttack, bStealthDefense);
			//TB Combat Mods (Att&DefCounters)
			pDefender->changeDefenseCount(1);
			//TB Combat Mods end

			pDefender->getGroup()->clearMissionQueue();

			bool bFocused = bVisible && isCombatFocus() && gDLL->getInterfaceIFace()->isCombatFocus() && plot()->isInViewport() && pDefender->isInViewport();
			if (bFocused)
			{ // TBMaybeproblem - is it possible that all this should happen to setup the combat on a surprise defense?
				// It is not currently doing so, perhaps because of fear of the revealed unit not being visible yet?
				DirectionTypes directionType = directionXY(plot(), pPlot);
				//								N			NE				E				SE					S				SW					W				NW
				NiPoint2 directions[8] = {NiPoint2(0, 1), NiPoint2(1, 1), NiPoint2(1, 0), NiPoint2(1, -1), NiPoint2(0, -1), NiPoint2(-1, -1), NiPoint2(-1, 0), NiPoint2(-1, 1)};
				NiPoint3 attackDirection = NiPoint3(directions[directionType].x, directions[directionType].y, 0);
				float plotSize = GC.getPLOT_SIZE();
				NiPoint3 lookAtPoint(plot()->getPoint().x + plotSize / 2 * attackDirection.x, plot()->getPoint().y + plotSize / 2 * attackDirection.y, (plot()->getPoint().z + pPlot->getPoint().z) / 2);
				attackDirection.Unitize();
				gDLL->getInterfaceIFace()->lookAt(lookAtPoint, (((getOwner() != GC.getGame().getActivePlayer()) || gDLL->getGraphicOption(GRAPHICOPTION_NO_COMBAT_ZOOM)) ? CAMERALOOKAT_BATTLE : CAMERALOOKAT_BATTLE_ZOOM_IN), attackDirection);
			}
			else if (bHumanDefender)
			{

				if (BARBARIAN_PLAYER != eAttacker)
				{
					AddDLLMessage(
						pDefender->getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
						gDLL->getText("TXT_KEY_MISC_YOU_UNITS_UNDER_ATTACK", GET_PLAYER(getOwner()).getNameKey()),
						"AS2D_COMBAT", MESSAGE_TYPE_DISPLAY_ONLY, getButton(), GC.getCOLOR_RED(), pPlot->getX(), pPlot->getY(), true
					);
				}
				else
				{
					AddDLLMessage(
						pDefender->getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
						gDLL->getText("TXT_KEY_MISC_YOU_UNITS_UNDER_ATTACK_UNKNOWN"),
						"AS2D_COMBAT", MESSAGE_TYPE_DISPLAY_ONLY, getButton(), GC.getCOLOR_RED(), pPlot->getX(), pPlot->getY(), true
					);
				}
			}
			//Damage to Attacking Unit from City Defenses
			if (pPlot->isCity(false) && !bSamePlot)
			{
				std::vector<UnitCombatTypes> damagableUnitCombatTypes;

				CvCity* pCity = pPlot->getPlotCity();
				for (std::map<UnitCombatTypes, UnitCombatKeyedInfo>::iterator it = m_unitCombatKeyedInfo.begin(), end = m_unitCombatKeyedInfo.end(); it != end; ++it)
				{
					if (it->second.m_bHasUnitCombat && pCity->canDamageAttackingUnitCombat(it->first))
					{
						damagableUnitCombatTypes.push_back(it->first);
					}
				}
				if (damagableUnitCombatTypes.size() > 0)
				{
					checkCityAttackDefensesDamage(pCity, damagableUnitCombatTypes);
				}
			}
		}
		FAssertMsg(pDefender != NULL, "Defender is not assigned a valid value");
		FAssertMsg(plot()->isFighting(), "Current unit instance plot is not fighting as expected");
		FAssertMsg(pPlot->isFighting(), "pPlot is not fighting as expected");

		if (!pDefender->canDefend())
		{
			if (bVisible)
			{
				addMission(CvMissionDefinition(MISSION_SURRENDER, pPlot, this, pDefender, getCombatTimer() * gDLL->getSecsPerTurn()));

				// Surrender mission
				setCombatTimer(GC.getMissionInfo(MISSION_SURRENDER).getTime());

				GC.getGame().incrementTurnTimer(getCombatTimer());
			}
			else bFinish = true;

			// Kill them!
			pDefender->setDamage(pDefender->getMaxHP());
		}
		//	Need to check the attacker has not already died in the attempt (on building defenses)
		else if (!isDead())
		{
			PROFILE("CvUnit::updateCombat.CanDefend");

			//USE commanders here (so their command points will be decreased) for attacker and defender:
			this->tryUseCommander();
			pDefender->tryUseCommander();

			CvBattleDefinition kBattle(pPlot, this, pDefender);

			//	Koshling - save pre-combat helath so we can use health loss as
			//	a basis for more granular war weariness
			setupPreCombatDamage();
			pDefender->setupPreCombatDamage();

			resolveCombat(pDefender, pPlot, kBattle, bSamePlot);

			if (!bVisible)
			{
				if (bHuman)
				{
					//	Hack to make quick offensive option not switch away from
					//	the stack.  It appears to be a bug in the main game engine
					//	in that it ALWAYS switches away unles you compleet the combat
					//	in a timer update call rather than directly here, so fake up
					//	a pseudo-combat round to perform delayed completion (but without
					//	animation, so no battle setup) via the unit timer
					setCombatTimer(1);

					GC.getGame().incrementTurnTimer(getCombatTimer());
					//TB: This is a fix for (standard bts) stack attack.  This 'hack' works as described above but if you have stack attack on,
					//it causes a situation where the tile is still considered to be in the middle of a battle after the battle has ended.
					//This will in effect disable stack attack and force each attack to be instructed individually as if the option was off.
					//Therefore, the bQuick definition that the groupAttack sends when the attack is one among a sequence
					//was modified to only send false IF it was the LAST attack in the stack attack sequence while
					//this section was modified to ONLY turn bFinish true on quick attack if it is the last attack in the sequence, when,
					//at that point it is safe to process as the finish of the battle.
					if (bQuick || !GET_PLAYER(getOwner()).isOption(PLAYEROPTION_QUICK_ATTACK))//TBFLAG
					{
						bFinish = true;
					}
				}
				else bFinish = true;
			}
			else
			{
				kBattle.setDamage(BATTLE_UNIT_ATTACKER, BATTLE_TIME_END, getDamage());
				kBattle.setDamage(BATTLE_UNIT_DEFENDER, BATTLE_TIME_END, pDefender->getDamage());
				if (!bSamePlot)
				{
					kBattle.setAdvanceSquare(canAdvance(pPlot, pDefender->isDead() ? 0 : 1));
				}

				if (isRanged() && pDefender->isRanged())
				{
					kBattle.setDamage(BATTLE_UNIT_ATTACKER, BATTLE_TIME_RANGED, kBattle.getDamage(BATTLE_UNIT_ATTACKER, BATTLE_TIME_END));
					kBattle.setDamage(BATTLE_UNIT_DEFENDER, BATTLE_TIME_RANGED, kBattle.getDamage(BATTLE_UNIT_DEFENDER, BATTLE_TIME_END));
				}
				else
				{
					kBattle.addDamage(BATTLE_UNIT_ATTACKER, BATTLE_TIME_RANGED, kBattle.getDamage(BATTLE_UNIT_ATTACKER, BATTLE_TIME_BEGIN));
					kBattle.addDamage(BATTLE_UNIT_DEFENDER, BATTLE_TIME_RANGED, kBattle.getDamage(BATTLE_UNIT_DEFENDER, BATTLE_TIME_BEGIN));
				}

				const int iTurns = planBattle(kBattle);
				kBattle.setMissionTime(iTurns * gDLL->getSecsPerTurn());
				setCombatTimer(iTurns);
				//TB Debug: Without plot set, this routine ended up causing a crash at addMission below.

				GC.getGame().incrementTurnTimer(getCombatTimer());

				if (pPlot->isActiveVisible(false) && !pDefender->isUsingDummyEntities())
				{
					//TB sameplot?
					ExecuteMove(0.5f, true);
					addMission(kBattle);
				}
			}
		}
		else bFinish = true;	//Attacker died before it could even engage
	}

	if (bFinish)
	{
		PROFILE("CvUnit::updateCombat.Finish");

		const bool bStealthDefense = m_combatResult.bStealthDefense;
#ifdef STRENGTH_IN_NUMBERS
		//TB Combat Mod begin
		if (GC.getGame().isOption(GAMEOPTION_STRENGTH_IN_NUMBERS))
		{
			ClearSupports();
		}
#endif // STRENGTH_IN_NUMBERS
		if (bVisible && isCombatFocus() && gDLL->getInterfaceIFace()->isCombatFocus() && getOwner() == GC.getGame().getActivePlayer())
		{
			gDLL->getInterfaceIFace()->releaseLockedCamera();
		}
#ifdef OUTBREAKS_AND_AFFLICTIONS
		//TB Combat Mod (Afflict) begin
		if (GC.getGame().isOption(GAMEOPTION_OUTBREAKS_AND_AFFLICTIONS))
		{
			for (int iI = 0; iI < GC.getNumPromotionLineInfos(); iI++)
			{
				if (m_combatResult.bAttackerInjured
				&&
				(
					pDefender->isDead()
					|| m_combatResult.bDefenderWithdrawn
					|| m_combatResult.bDefenderKnockedBack
					|| m_combatResult.bAttackerRepelled
					|| m_combatResult.bAttackerWithdraws
				)
				&& GC.getPromotionLineInfo((PromotionLineTypes)iI).isAffliction()
				&& !GC.getPromotionLineInfo((PromotionLineTypes)iI).isCritical())
				{
					const PromotionLineTypes eAfflictionLine = (PromotionLineTypes)iI;

					if (pDefender->hasAfflictOnAttackType(eAfflictionLine)
					&& !pDefender->isAfflictOnAttackTypeAttempted(eAfflictionLine)
					// Distance Qualifier
					&&
					(
						m_combatResult.bDefenderHitAttackerWithDistanceAttack
						&& pDefender->isAfflictOnAttackTypeDistance(eAfflictionLine)
						|| pDefender->isAfflictOnAttackTypeMelee(eAfflictionLine)
						&& !m_combatResult.bNeverMelee
					))
					{
						const int iDefendersPoisonChance =
						(
							pDefender->getAfflictOnAttackTypeProbability(eAfflictionLine)
							- fortitudeTotal() - getUnitAfflictionTolerance(eAfflictionLine)
						);
						if (GC.getGame().getSorenRandNum(100, "DefendersPoisonRoll") < iDefendersPoisonChance)
						{
							afflict(eAfflictionLine, true, pDefender);
						}
						pDefender->setAfflictOnAttackTypeAttemptedCount(eAfflictionLine, 1);
					}
					//Battle proximity communicability affliction spread
					if (!m_combatResult.bNeverMelee && pDefender->hasAfflictionLine(eAfflictionLine) && GC.getPromotionLineInfo(eAfflictionLine).getCommunicability() > 0 && !GC.getPromotionLineInfo(eAfflictionLine).isNoSpreadonBattle())
					{
						const int iDefendersChancetoAfflict = getChancetoContract(eAfflictionLine) + pDefender->worsenedProbabilitytoAfflict(eAfflictionLine);

						if (GC.getGame().getSorenRandNum(100, "DefenderCauseContractRoll") < iDefendersChancetoAfflict)
						{
							afflict(eAfflictionLine, false, pDefender);
						}
					}
				}
				if (m_combatResult.bDefenderInjured
				&&
				(
					isDead()
					|| m_combatResult.bDefenderWithdrawn
					|| m_combatResult.bDefenderKnockedBack
					|| m_combatResult.bAttackerRepelled
					|| m_combatResult.bAttackerWithdraws
				)
				&& GC.getPromotionLineInfo((PromotionLineTypes)iI).isAffliction()
				&& !GC.getPromotionLineInfo((PromotionLineTypes)iI).isCritical())
				{
					const PromotionLineTypes eAfflictionLine = (PromotionLineTypes)iI;
					if (hasAfflictOnAttackType(eAfflictionLine)
					&& !isAfflictOnAttackTypeAttempted(eAfflictionLine)
					&&
					(
						m_combatResult.bDefenderHitAttackerWithDistanceAttack
						&& isAfflictOnAttackTypeDistance(eAfflictionLine)
						|| isAfflictOnAttackTypeMelee(eAfflictionLine)
						&& !m_combatResult.bNeverMelee
					))
					{
						const int iAttackersPoisonChance =
						(
							getAfflictOnAttackTypeProbability(eAfflictionLine)
							- pDefender->fortitudeTotal()
							- pDefender->getUnitAfflictionTolerance(eAfflictionLine)
						);
						if (GC.getGame().getSorenRandNum(100, "AttackersPoisonRoll") < iAttackersPoisonChance)
						{
							pDefender->afflict(eAfflictionLine, true, this);
						}
						setAfflictOnAttackTypeAttemptedCount(eAfflictionLine, 1);
					}
					//Communicability exposure
					if (!m_combatResult.bNeverMelee && hasAfflictionLine(eAfflictionLine) && GC.getPromotionLineInfo(eAfflictionLine).getCommunicability() > 0 && !GC.getPromotionLineInfo(eAfflictionLine).isNoSpreadonBattle())
					{
						const int iAttackersChancetoAfflict = pDefender->getChancetoContract(eAfflictionLine) + worsenedProbabilitytoAfflict(eAfflictionLine);

						if (GC.getGame().getSorenRandNum(100, "AttackerCauseContractRoll") < iAttackersChancetoAfflict)
						{
							pDefender->afflict(eAfflictionLine, false, this);
						}
					}
				}
			}
		}
		//TB Combat Mod (Afflict) end
#endif // OUTBREAKS_AND_AFFLICTIONS

		//TB Combat Mod (Stampede/Onslaught)
		if (pDefender->isDead() || m_combatResult.bDefenderWithdrawn || m_combatResult.bDefenderKnockedBack || m_combatResult.bAttackerRepelled || m_combatResult.bAttackerWithdraws)
		{
			if (!bSamePlot && canStampede() && pPlot->getNumVisiblePotentialEnemyDefenders(this) > 1)
			{
				m_combatResult.bAttackerStampedes = true;
			}
			if (!bSamePlot && canOnslaught() && (getDamage() == 0) && pPlot->getNumVisiblePotentialEnemyDefenders(this) > 1)
			{
				m_combatResult.bAttackerOnslaught = true;
			}
		}
		if (isDead() || pDefender->isDead() || m_combatResult.bDefenderWithdrawn || m_combatResult.bDefenderKnockedBack || m_combatResult.bAttackerRepelled || m_combatResult.bAttackerWithdraws)
		{
			//Sustain Reports
			//Pursuit Reports
			if (m_combatResult.bAttackerPursuedSustain)
			{
				if (bHuman)
				{

					if (BARBARIAN_PLAYER != eDefender)
					{
						AddDLLMessage(
							getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
							gDLL->getText("TXT_KEY_MISC_ATTACKER_PURSUED_SUSTAIN_HUMAN", getNameKey(), pDefender->getVisualCivAdjective(pDefender->getTeam()), pDefender->getNameKey()),
							"AS2D_OUR_WITHDRAWL", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_YELLOW(), pPlot->getX(), pPlot->getY()
						);
					}
					else
					{
						AddDLLMessage(
							getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
							gDLL->getText("TXT_KEY_MISC_ATTACKER_PURSUED_SUSTAIN_HUMAN_HIDDEN", getNameKey(), pDefender->getNameKey()),
							"AS2D_OUR_WITHDRAWL", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_YELLOW(), pPlot->getX(), pPlot->getY()
						);
					}
				}
				if (bHumanDefender)
				{

					if (BARBARIAN_PLAYER != eAttacker)
					{
						AddDLLMessage(
							pDefender->getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
							gDLL->getText("TXT_KEY_MISC_ATTACKER_PURSUED_SUSTAIN", getVisualCivAdjective(getTeam()), getNameKey(), pDefender->getNameKey()),
							"AS2D_OUR_WITHDRAWL", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_GREEN(), pPlot->getX(), pPlot->getY()
						);
					}
					else
					{
						AddDLLMessage(
							pDefender->getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
							gDLL->getText("TXT_KEY_MISC_ATTACKER_PURSUED_SUSTAIN_HIDDEN", getNameKey(), pDefender->getNameKey()),
							"AS2D_OUR_WITHDRAWL", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_GREEN(), pPlot->getX(), pPlot->getY()
						);
					}
				}
				m_combatResult.bAttackerPursuedSustain = false;
			}
			if (m_combatResult.bDefenderPursuedSustain)
			{
				if (bHuman)
				{

					if (BARBARIAN_PLAYER != eDefender)
					{
						AddDLLMessage(
							getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
							gDLL->getText(
								"TXT_KEY_MISC_DEFENDER_PURSUED_SUSTAIN_HUMAN",
								getNameKey(), pDefender->getVisualCivAdjective(pDefender->getTeam()), pDefender->getNameKey()
							),
							"AS2D_OUR_WITHDRAWL", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_GREEN(), pPlot->getX(), pPlot->getY()
						);
					}
					else
					{
						AddDLLMessage(
							getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
							gDLL->getText("TXT_KEY_MISC_DEFENDER_PURSUED_SUSTAIN_HUMAN_HIDDEN", getNameKey(), pDefender->getNameKey()),
							"AS2D_OUR_WITHDRAWL", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_GREEN(), pPlot->getX(), pPlot->getY()
						);
					}
				}
				if (bHumanDefender)
				{

					if (BARBARIAN_PLAYER != eAttacker)
					{
						AddDLLMessage(
							pDefender->getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
							gDLL->getText("TXT_KEY_MISC_DEFENDER_PURSUED_SUSTAIN", pDefender->getNameKey(), getVisualCivAdjective(getTeam()), getNameKey()),
							"AS2D_OUR_WITHDRAWL", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_YELLOW(), pPlot->getX(), pPlot->getY()
						);
					}
					else
					{
						AddDLLMessage(
							pDefender->getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
							gDLL->getText("TXT_KEY_MISC_DEFENDER_PURSUED_SUSTAIN_HIDDEN", pDefender->getNameKey(),getNameKey()),
							"AS2D_OUR_WITHDRAWL", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_YELLOW(), pPlot->getX(), pPlot->getY()
						);
					}
				}
				m_combatResult.bDefenderPursuedSustain = false;
			}

			//Unyielding Reports
			if (m_combatResult.bAttackerRefusedtoYieldSustain)
			{
				if (bHuman)
				{

					if (BARBARIAN_PLAYER != eAttacker)
					{
						AddDLLMessage(
							getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
							gDLL->getText(
								"TXT_KEY_MISC_ATTACKER_UNYIELDING_SUSTAIN_HUMAN",
								getNameKey(), getVisualCivAdjective(pDefender->getTeam()), pDefender->getNameKey()
							),
							"AS2D_OUR_WITHDRAWL", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_GREEN(), pPlot->getX(), pPlot->getY()
						);
					}
					else
					{
						AddDLLMessage(
							getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
							gDLL->getText("TXT_KEY_MISC_ATTACKER_UNYIELDING_SUSTAIN_HUMAN_HIDDEN", getNameKey(), pDefender->getNameKey()),
							"AS2D_OUR_WITHDRAWL", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_GREEN(), pPlot->getX(), pPlot->getY()
						);
					}
				}
				if (bHumanDefender)
				{

					if (BARBARIAN_PLAYER != eAttacker)
					{
						AddDLLMessage(
							pDefender->getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
							gDLL->getText("TXT_KEY_MISC_ATTACKER_UNYIELDING_SUSTAIN", getVisualCivAdjective(getTeam()), pDefender->getNameKey(), getNameKey()),
							"AS2D_OUR_WITHDRAWL", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_YELLOW(), pPlot->getX(), pPlot->getY()
						);
					}
					else
					{
						AddDLLMessage(
							pDefender->getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
							gDLL->getText("TXT_KEY_MISC_ATTACKER_UNYIELDING_SUSTAIN_HIDDEN", pDefender->getNameKey(), getNameKey()),
							"AS2D_OUR_WITHDRAWL", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_YELLOW(), pPlot->getX(), pPlot->getY()
						);
					}
				}
				m_combatResult.bAttackerRefusedtoYieldSustain = false;
			}
			if (m_combatResult.bDefenderRefusedtoYieldSustain)
			{
				if (bHuman)
				{

					if (BARBARIAN_PLAYER != eDefender)
					{
						AddDLLMessage(
							getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
							gDLL->getText("TXT_KEY_MISC_DEFENDER_UNYIELDING_SUSTAIN_HUMAN", getNameKey(), getVisualCivAdjective(pDefender->getTeam()), pDefender->getNameKey()),
							"AS2D_OUR_WITHDRAWL", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_YELLOW(), pPlot->getX(), pPlot->getY()
						);
					}
					else
					{
						AddDLLMessage(
							getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
							gDLL->getText("TXT_KEY_MISC_DEFENDER_UNYIELDING_SUSTAIN_HUMAN_HIDDEN", getNameKey(), pDefender->getNameKey()),
							"AS2D_OUR_WITHDRAWL", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_YELLOW(), pPlot->getX(), pPlot->getY()
						);
					}
				}
				if (bHumanDefender)
				{

					if (BARBARIAN_PLAYER != eAttacker)
					{
						AddDLLMessage(
							pDefender->getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
							gDLL->getText("TXT_KEY_MISC_DEFENDER_UNYIELDING_SUSTAIN", pDefender->getNameKey(), getVisualCivAdjective(getTeam()), getNameKey()),
							"AS2D_OUR_WITHDRAWL", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_GREEN(), pPlot->getX(), pPlot->getY()
						);
					}
					else
					{
						AddDLLMessage(
							pDefender->getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
							gDLL->getText("TXT_KEY_MISC_DEFENDER_UNYIELDING_SUSTAIN_HIDDEN", pDefender->getNameKey(), getNameKey()),
							"AS2D_OUR_WITHDRAWL", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_GREEN(), pPlot->getX(), pPlot->getY()
						);
					}
				}
				m_combatResult.bDefenderRefusedtoYieldSustain = false;
			}
		}
		//TB Combat Mods End
		//end the combat mission if this code executes first
		if (!isUsingDummyEntities() && isInViewport())
		{
			gDLL->getEntityIFace()->RemoveUnitFromBattle(this);
		}
		if (!pDefender->isUsingDummyEntities() && pDefender->isInViewport())
		{
			gDLL->getEntityIFace()->RemoveUnitFromBattle(pDefender);
		}
		setAttackPlot(NULL, false);
		setCombatUnit(NULL);
		pDefender->setCombatUnit(NULL);
		NotifyEntity(MISSION_DAMAGE);
		pDefender->NotifyEntity(MISSION_DAMAGE);

		if (isDead())
		{
			if (isNPC())
			{
				GET_PLAYER(pDefender->getOwner()).changeWinsVsBarbs(1);
			}

			if (!isHiddenNationality() && !pDefender->isHiddenNationality())
			{
				const int attackerWarWearinessChangeTimes100 = std::max(1, 100 * GC.getDefineINT("WW_UNIT_KILLED_ATTACKING") * (getMaxHP() - getPreCombatDamage()) / getMaxHP());
				GET_TEAM(getTeam()).changeWarWearinessTimes100(pDefender->getTeam(), *pPlot, attackerWarWearinessChangeTimes100);

				const int defenderWarWearinessChangeTimes100 = 100*GC.getDefineINT("WW_KILLED_UNIT_DEFENDING")*(pDefender->getDamage() - pDefender->getPreCombatDamage())/pDefender->getMaxHP();
				GET_TEAM(pDefender->getTeam()).changeWarWearinessTimes100(getTeam(), *pPlot, defenderWarWearinessChangeTimes100);

				GET_TEAM(pDefender->getTeam()).AI_changeWarSuccess(getTeam(), GC.getDefineINT("WAR_SUCCESS_DEFENDING"));
			}

			const float fInfluenceRatio = GC.isIDW_ENABLED() ? pDefender->doVictoryInfluence(this, false, false) : 0.0f;

			if (bHuman)
			{
				CvWString szBuffer;

				if (m_combatResult.bAttackerPursued)
				{
					szBuffer = gDLL->getText("TXT_KEY_MISC_PURSUIT_VICTIM", getNameKey(), pDefender->getNameKey());
				}
				else if (m_combatResult.bAttackerRefusedtoYield)
				{
					szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_UNYIELDING_UNIT_DIED_ATTACKING", getNameKey(), pDefender->getNameKey());
				}
				else if (m_combatResult.bDefenderRefusedtoYield)
				{
					szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_UNIT_DIED_ATTACKING_UNYIELDING", getNameKey(), pDefender->getNameKey());
				}
				else szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_UNIT_DIED_ATTACKING", getNameKey(), pDefender->getNameKey());

				if (fInfluenceRatio > 0.0f)
				{
					szBuffer = szBuffer + CvString::format(" %s: -%.1f%%", gDLL->getText("TXT_KEY_TILE_INFLUENCE").GetCString(), fInfluenceRatio);
				}
				AddDLLMessage(
					getOwner(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer,
					GC.getEraInfo(GC.getGame().getCurrentEra()).getAudioUnitDefeatScript(),
					MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_RED(), pPlot->getX(), pPlot->getY()
				);
			}
			if (bHumanDefender)
			{
				CvWString szBuffer;

				if (m_combatResult.bAttackerPursued)
				{
					szBuffer = gDLL->getText("TXT_KEY_MISC_PURSUIT_SUCCESS", getNameKey(), pDefender->getNameKey());
				}
				else if (m_combatResult.bAttackerRefusedtoYield)
				{
					szBuffer = gDLL->getText("TXT_KEY_MISC_UNYIELDING_ATTACKER_YOU_KILLED", getNameKey(), pDefender->getNameKey());
				}
				else if (m_combatResult.bDefenderRefusedtoYield)
				{
					szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_KILLED_ATTACKER_WHILEUNYIELDING", getNameKey(), pDefender->getNameKey());
				}
				else if (BARBARIAN_PLAYER != eAttacker)
				{
					szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_KILLED_ENEMY_UNIT", pDefender->getNameKey(), getNameKey(), getVisualCivAdjective(pDefender->getTeam()));
				}
				else szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_KILLED_ENEMY_UNIT_HIDDEN", pDefender->getNameKey(), getNameKey());

				if (fInfluenceRatio > 0.0f)
				{
					szBuffer = szBuffer + CvString::format(" %s: +%.1f%%", gDLL->getText("TXT_KEY_TILE_INFLUENCE").GetCString(), fInfluenceRatio);
				}
				AddDLLMessage(
					pDefender->getOwner(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer,
					GC.getEraInfo(GC.getGame().getCurrentEra()).getAudioUnitVictoryScript(),
					MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_GREEN(), pPlot->getX(), pPlot->getY()
				);
			}

			int iUnitsHealed = 0;
			if (pDefender->getVictoryAdjacentHeal() > 0
			&& GC.getGame().getSorenRandNum(100, "Field Hospital Die Roll") <= pDefender->getVictoryAdjacentHeal())
			{
				foreach_(const CvPlot* pLoopPlot, pPlot->adjacent() | filtered(CvPlot::fn::area() == pPlot->area()))
				{
					foreach_(CvUnit* pLoopUnit, pLoopPlot->units())
					{
						if (pLoopUnit->getTeam() == pDefender->getTeam() && pLoopUnit->isHurt())
						{
							iUnitsHealed++;
							pLoopUnit->doHeal();
						}
					}
				}
			}

			if (pDefender->getVictoryStackHeal() > 0
			&& GC.getGame().getSorenRandNum(100, "Field Surgeon Die Roll") <= pDefender->getVictoryStackHeal())
			{
				foreach_(CvUnit* pLoopUnit, pPlot->units())
				{
					if (pLoopUnit->getTeam() == pDefender->getTeam() && pLoopUnit->isHurt())
					{
						iUnitsHealed++;
						pLoopUnit->doHeal();
					}
				}
			}
			else if (pDefender->getVictoryHeal() > 0 && pDefender->isHurt()
			&& GC.getGame().getSorenRandNum(100, "Field Medic Die Roll") <= pDefender->getVictoryHeal())
			{
				pDefender->doHeal();
			}

			if (iUnitsHealed > 1)
			{
				if (bHuman)
				{
					if (BARBARIAN_PLAYER != eAttacker)
					{
						AddDLLMessage(
							getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
							gDLL->getText("TXT_KEY_MISC_ENEMY_FIELD_MEDIC_DEFENDERS", GET_PLAYER(pDefender->getOwner()).getCivilizationAdjective()),
							"AS2D_COMBAT", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_YELLOW(), pDefender->getX(), pDefender->getY()
						);
					}
					else
					{
						AddDLLMessage(
							getOwner(), true, GC.getEVENT_MESSAGE_TIME(), gDLL->getText("TXT_KEY_MISC_ENEMY_FIELD_MEDIC_DEFENDERS_HIDDEN"),
							"AS2D_COMBAT", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_YELLOW(), pDefender->getX(), pDefender->getY()
						);
					}
				}
				if (bHumanDefender)
				{
					AddDLLMessage(
						pDefender->getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
						gDLL->getText("TXT_KEY_MISC_FIELD_MEDIC_DEFENDERS", pDefender->getNameKey(), iUnitsHealed),
						"AS2D_POSITIVE_DINK", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_GREEN(), pDefender->getX(), pDefender->getY()
					);
				}
			}

			if (pDefender->getDefensiveVictoryMoveCount() > 0)
			{
				pDefender->changeMoves(-GC.getMOVE_DENOMINATOR());
			}

			if (getSurvivorChance() > 0
			&& GC.getGame().getSorenRandNum(100, "Too Badass Check") <= getSurvivorChance())
			{
				setSurvivor(true);
				jumpToNearestValidPlot();
			}
			else if (isOneUp())
			{
				setCanRespawn(true);
			}

			if (pDefender->isPillageOnVictory())
			{
				CvPlot* pDefenderPlot = pDefender->plot();
				int iPillageGold = getLevel() * getExperience();
				if (NO_UNIT != getLeaderUnitType())
				{
					iPillageGold *= getLevel();
				}

				if (iPillageGold > 0)
				{
					iPillageGold += (iPillageGold * pDefender->getPillageChange()) / 100;
					GET_PLAYER(pDefender->getOwner()).changeGold(iPillageGold);

					if (bHuman)
					{
						if (BARBARIAN_PLAYER != eDefender)
						{
							AddDLLMessage(
								getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
								gDLL->getText("TXT_KEY_MISC_GOLD_LOOTED_FROM_DEAD", getNameKey(), pDefender->getVisualCivAdjective(pDefender->getTeam())),
								"AS2D_PILLAGED", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_YELLOW(), pDefenderPlot->getX(), pDefenderPlot->getY()
							);
						}
						else
						{
							AddDLLMessage(
								getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
								gDLL->getText("TXT_KEY_MISC_GOLD_LOOTED_FROM_DEAD_HIDDEN", getNameKey()),
								"AS2D_PILLAGED", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_YELLOW(), pDefenderPlot->getX(), pDefenderPlot->getY()
							);
						}
					}

					for (int iI = 0; iI < NUM_COMMERCE_TYPES; ++iI)
					{
						TechTypes ePillageTech = GET_PLAYER(pDefender->getOwner()).getCurrentResearch();
						CommerceTypes eCommerce = (CommerceTypes)iI;
						switch (eCommerce)
						{
						case COMMERCE_GOLD:
							if (pDefender->isPillageMarauder())
							{
								GET_PLAYER(pDefender->getOwner()).changeGold(iPillageGold);
								if (bHumanDefender)
								{
									AddDLLMessage(
										pDefender->getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
										gDLL->getText("TXT_KEY_MISC_MARAUDERS_PLUNDERED_VICTIMS", iPillageGold, pDefender->getNameKey()),
										"AS2D_PILLAGE", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_GREEN(), pDefenderPlot->getX(), pDefenderPlot->getY()
									);
								}
								if (bHuman)
								{
									if (BARBARIAN_PLAYER != eDefender)
									{
										AddDLLMessage(
											getOwner(), false, GC.getEVENT_MESSAGE_TIME(),
											gDLL->getText("TXT_KEY_MISC_DEFENDED_BY_MARAUDERS", getNameKey(), getVisualCivAdjective(pDefender->getTeam())),
											"AS2D_PILLAGED", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_YELLOW(), pDefenderPlot->getX(), pDefenderPlot->getY(), true, true
										);
									}
									else
									{
										AddDLLMessage(
											getOwner(), false, GC.getEVENT_MESSAGE_TIME(),
											gDLL->getText("TXT_KEY_MISC_DEFENDED_BY_MARAUDERS_HIDDEN", getNameKey()),
											"AS2D_PILLAGED", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_YELLOW(), pDefenderPlot->getX(), pDefenderPlot->getY(), true, true
										);
									}
								}
							}
							break;
						case COMMERCE_RESEARCH:
							if (pDefender->isPillageResearch())
							{
								GET_TEAM(GET_PLAYER(pDefender->getOwner()).getTeam()).changeResearchProgress(ePillageTech, iPillageGold, pDefender->getOwner());
								if (bHumanDefender)
								{
									if (BARBARIAN_PLAYER != eDefender)
									{
										AddDLLMessage(
											pDefender->getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
											gDLL->getText(
												"TXT_KEY_MISC_PLUNDERED_RESEARCH_FROM_VICTIMS",
												iPillageGold, pDefender->getNameKey(), getVisualCivAdjective(getTeam()), ePillageTech
											),
											"AS2D_PILLAGE", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_GREEN(), pDefenderPlot->getX(), pDefenderPlot->getY()
										);
									}
									else
									{
										AddDLLMessage(
											pDefender->getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
											gDLL->getText("TXT_KEY_MISC_PLUNDERED_RESEARCH_FROM_VICTIMS_HIDDEN", iPillageGold, pDefender->getNameKey(), ePillageTech),
											"AS2D_PILLAGE", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_GREEN(), pDefenderPlot->getX(), pDefenderPlot->getY()
										);
									}
								}
							}
							break;
						case COMMERCE_CULTURE:
							break;
						case COMMERCE_ESPIONAGE:
							if (pDefender->isPillageEspionage() && pDefenderPlot->getTeam() != NO_TEAM)
							{
								GET_TEAM(GET_PLAYER(pDefender->getOwner()).getTeam()).changeEspionagePointsAgainstTeam(getTeam(), iPillageGold);
								if (bHumanDefender)
								{
									if (BARBARIAN_PLAYER != eDefender)
									{
										AddDLLMessage(
											pDefender->getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
											gDLL->getText("TXT_KEY_MISC_PLUNDERED_ESPIONAGE_FROM_VICTIMS", iPillageGold, getVisualCivAdjective(getTeam()), pDefender->getNameKey()),
											"AS2D_PILLAGE", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_GREEN(), pDefenderPlot->getX(), pDefenderPlot->getY()
										);
									}
									else
									{
										AddDLLMessage(
											pDefender->getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
											gDLL->getText("TXT_KEY_MISC_PLUNDERED_ESPIONAGE_FROM_VICTIMS_HIDDEN", iPillageGold, pDefender->getNameKey()),
											"AS2D_PILLAGE", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_GREEN(), pDefenderPlot->getX(), pDefenderPlot->getY()
										);
									}
								}
							}
							break;
						}
					}
				}
			}

			// report event to Python, along with some other key state
			CvEventReporter::getInstance().combatResult(pDefender, this);

			CvOutcomeListMerged list;
			list.addOutcomeList(getUnitInfo().getKillOutcomeList());
			//getUnitInfo().getKillOutcomeList()->execute(*pDefender, getOwner(), getUnitType());
			for (int iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
			{
				const UnitCombatTypes eCombat = (UnitCombatTypes)iI;
				if (isHasUnitCombat(eCombat))
				{
					list.addOutcomeList(GC.getUnitCombatInfo(eCombat).getKillOutcomeList());
					//pOutcomeList->execute(*pDefender, getOwner(), getUnitType());
				}
			}
			list.execute(*pDefender, getOwner(), getUnitType());
		}
		else if (pDefender->isDead())
		{
			if (pDefender->isNPC())
			{
				GET_PLAYER(getOwner()).changeWinsVsBarbs(1);
			}

			if (!isHiddenNationality() && !pDefender->isHiddenNationality())
			{
				const int defenderWarWearinessChangeTimes100 =
				(
					std::max(
						1,
						100 * GC.getDefineINT("WW_UNIT_KILLED_DEFENDING")
						* (pDefender->getMaxHP() - pDefender->getPreCombatDamage())
						/
						pDefender->getMaxHP()
					)
				);
				GET_TEAM(pDefender->getTeam()).changeWarWearinessTimes100(getTeam(), *pPlot, defenderWarWearinessChangeTimes100);

				const int attackerWarWearinessChangeTimes100 =
				(
					100 * GC.getDefineINT("WW_KILLED_UNIT_ATTACKING")
					* (getDamage() - getPreCombatDamage())
					/
					getMaxHP()
				);
				GET_TEAM(getTeam()).changeWarWearinessTimes100(pDefender->getTeam(), *pPlot, attackerWarWearinessChangeTimes100);

				GET_TEAM(getTeam()).AI_changeWarSuccess(pDefender->getTeam(), GC.getDefineINT("WAR_SUCCESS_ATTACKING"));
			}

			const float fInfluenceRatio = GC.isIDW_ENABLED() ? doVictoryInfluence(pDefender, true, false) : 0.0f;

			if (bHuman)
			{
				CvWString szBuffer;

				if (m_combatResult.bDefenderPursued)
				{
					szBuffer = gDLL->getText("TXT_KEY_MISC_PURSUIT_ONATTACK_SUCCESS", pDefender->getNameKey(), getNameKey());
				}
				else if (m_combatResult.bAttackerRefusedtoYield)
				{
					szBuffer = gDLL->getText("TXT_KEY_MISC_UNYIELDING_YOU_DESTROYED_ENEMY", pDefender->getNameKey(), getNameKey());
				}
				else if (m_combatResult.bDefenderRefusedtoYield)
				{
					szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_UNIT_DESTROYED_UNYIELDING_ENEMY", pDefender->getNameKey(), getNameKey());
				}
				else if (m_combatResult.bAttackerStampedes)
				{
					szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_UNIT_DESTROYED_ENEMY_STAMPEDE", pDefender->getNameKey(), getNameKey());
				}
				else if (m_combatResult.bAttackerOnslaught)
				{
					szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_UNIT_DESTROYED_ENEMY_ONSLAUGHT", pDefender->getNameKey(), getNameKey());
				}
				else szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_UNIT_DESTROYED_ENEMY", getNameKey(), pDefender->getNameKey());

				if (fInfluenceRatio > 0.0f)
				{
					szBuffer = szBuffer + CvString::format(" %s: +%.1f%%", gDLL->getText("TXT_KEY_TILE_INFLUENCE").GetCString(), fInfluenceRatio);
				}
				AddDLLMessage(
					getOwner(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer,
					GC.getEraInfo(GC.getGame().getCurrentEra()).getAudioUnitVictoryScript(),
					MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_GREEN(), pPlot->getX(), pPlot->getY()
				);
			}
			if (bHumanDefender)
			{
				CvWString szBuffer;

				if (m_combatResult.bDefenderPursued)
				{
					szBuffer = gDLL->getText("TXT_KEY_MISC_PURSUIT_ONATTACK_VICTIM", pDefender->getNameKey(), getNameKey());
				}
				else if (m_combatResult.bAttackerRefusedtoYield)
				{
					if (BARBARIAN_PLAYER != eDefender)
					{
						szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_UNIT_WAS_DESTROYED_BYUNYIELDING_UNKNOWN", pDefender->getNameKey(), getNameKey());
					}
					else szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_UNIT_WAS_DESTROYED_BYUNYIELDING", pDefender->getNameKey(), getVisualCivAdjective(pDefender->getTeam()), getNameKey());
				}
				else if (m_combatResult.bDefenderRefusedtoYield)
				{
					if (BARBARIAN_PLAYER == eDefender)
					{
						szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_UNIT_WAS_DESTROYED_WHILEUNYIELDING_UNKNOWN", pDefender->getNameKey(), getNameKey());
					}
					else szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_UNIT_WAS_DESTROYED_WHILEUNYIELDING", pDefender->getNameKey(), getVisualCivAdjective(pDefender->getTeam()), getNameKey());
				}
				else if (m_combatResult.bAttackerStampedes)
				{
					szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_UNIT_WAS_DESTROYED_ENEMY_STAMPEDE", pDefender->getNameKey(), getNameKey());
				}
				else if (m_combatResult.bAttackerOnslaught)
				{
					szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_UNIT_WAS_DESTROYED_ENEMY_ONSLAUGHT", pDefender->getNameKey(), getNameKey());
				}
				else if (BARBARIAN_PLAYER == eAttacker)
				{
					szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_UNIT_WAS_DESTROYED_UNKNOWN", pDefender->getNameKey(), getNameKey());
				}
				else szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_UNIT_WAS_DESTROYED", pDefender->getNameKey(), getNameKey(), getVisualCivAdjective(pDefender->getTeam()));

				if (fInfluenceRatio > 0.0f)
				{
					szBuffer = szBuffer + CvString::format(" %s: -%.1f%%", gDLL->getText("TXT_KEY_TILE_INFLUENCE").GetCString(), fInfluenceRatio);
				}
				AddDLLMessage(
					pDefender->getOwner(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer,
					GC.getEraInfo(GC.getGame().getCurrentEra()).getAudioUnitDefeatScript(),
					MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_RED(), pPlot->getX(), pPlot->getY()
				);
			}

			// report event to Python, along with some other key state
			int iUnitsHealed = 0;
			if (getVictoryAdjacentHeal() > 0
			&& GC.getGame().getSorenRandNum(100, "Field Hospital Die Roll") <= getVictoryAdjacentHeal())
			{
				foreach_(const CvPlot* pLoopPlot, pPlot->adjacent() | filtered(CvPlot::fn::area() == pPlot->area()))
				{
					foreach_(CvUnit* pLoopUnit, pLoopPlot->units())
					{
						if (pLoopUnit->getTeam() == getTeam() && pLoopUnit->isHurt())
						{
							iUnitsHealed++;
							pLoopUnit->doHeal();
						}
					}
				}
			}

			if (getVictoryStackHeal() > 0
			&& GC.getGame().getSorenRandNum(100, "Field Surgeon Die Roll") <= getVictoryStackHeal())
			{
				foreach_(CvUnit* pLoopUnit, pPlot->units())
				{
					if (pLoopUnit->getTeam() == getTeam() && pLoopUnit->isHurt())
					{
						iUnitsHealed++;
						pLoopUnit->doHeal();
					}
				}
			}
			else if (getVictoryHeal() > 0 && GC.getGame().getSorenRandNum(100, "Field Medic Die Roll") <= getVictoryHeal())
			{
				doHeal();
			}

			if (iUnitsHealed > 1)
			{
				if (bHumanDefender)
				{
					if (BARBARIAN_PLAYER != eAttacker)
					{
						AddDLLMessage(
							pDefender->getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
							gDLL->getText("TXT_KEY_MISC_ENEMY_FIELD_MEDIC_ATTACKERS", GET_PLAYER(getOwner()).getCivilizationAdjective()),
							"AS2D_COMBAT", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_YELLOW(), getX(), getY(), true, true
						);
					}
					else
					{
						AddDLLMessage(
							pDefender->getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
							gDLL->getText("TXT_KEY_MISC_ENEMY_FIELD_MEDIC_ATTACKERS_HIDDEN"),
							"AS2D_COMBAT", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_YELLOW(), getX(), getY(), true, true
						);
					}
				}
				if (bHuman)
				{
					AddDLLMessage(
						getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
						gDLL->getText("TXT_KEY_MISC_FIELD_MEDIC_ATTACKERS", getNameKey(), iUnitsHealed),
						"AS2D_POSITIVE_DINK", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_GREEN(), getX(), getY()
					);
				}
			}

			if (getOffensiveVictoryMoveCount() > 0)
			{
				changeMoves(-GC.getMOVE_DENOMINATOR());
			}

			if (pDefender->getSurvivorChance() > 0
			&& GC.getGame().getSorenRandNum(100, "Too Badass Check") <= pDefender->getSurvivorChance())
			{
				pDefender->setSurvivor(true);
				pDefender->jumpToNearestValidPlot();
			}
			else if (pDefender->isOneUp())
			{
				CvCity* pCapitalCity = GET_PLAYER(pDefender->getOwner()).getCapitalCity();
				if (pCapitalCity != NULL)
				{
					pDefender->setCanRespawn(true);
				}
			}

			if (isPillageOnVictory())
			{
				CvPlot* pDefenderPlot = (pDefender->plot());
				int iPillageGold = (pDefender->getLevel() * pDefender->getExperience());
				if (NO_UNIT != pDefender->getLeaderUnitType())
				{
					iPillageGold *= pDefender->getLevel();
				}
				if (iPillageGold > 0)
	            {
					iPillageGold += iPillageGold * getPillageChange() / 100;
					GET_PLAYER(getOwner()).changeGold(iPillageGold);

					if (bHuman)
					{
						if (BARBARIAN_PLAYER != eAttacker)
						{
							AddDLLMessage(
								getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
								gDLL->getText("TXT_KEY_MISC_GOLD_LOOTED_FROM_DEAD", pDefender->getNameKey(), getVisualCivAdjective(getTeam())),
								"AS2D_PILLAGED", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_YELLOW(), pDefenderPlot->getX(), pDefenderPlot->getY()
							);
						}
						else
						{
							AddDLLMessage(
								getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
								gDLL->getText("TXT_KEY_MISC_GOLD_LOOTED_FROM_DEAD_HIDDEN", pDefender->getNameKey()),
								"AS2D_PILLAGED", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_YELLOW(), pDefenderPlot->getX(), pDefenderPlot->getY()
							);
						}
					}

					for (int iI = 0; iI < NUM_COMMERCE_TYPES; ++iI)
					{
						TechTypes ePillageTech = GET_PLAYER(getOwner()).getCurrentResearch();
						CommerceTypes eCommerce = (CommerceTypes)iI;
						switch (eCommerce)
						{
						case COMMERCE_GOLD:
							if (isPillageMarauder())
							{
								GET_PLAYER(getOwner()).changeGold(iPillageGold);
								if (bHuman)
								{
									AddDLLMessage(
										getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
										gDLL->getText("TXT_KEY_MISC_MARAUDERS_PLUNDERED_VICTIMS", iPillageGold, getNameKey()),
										"AS2D_PILLAGE", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_GREEN(), pDefenderPlot->getX(), pDefenderPlot->getY()
									);
								}
								if (bHumanDefender)
								{
									if (BARBARIAN_PLAYER != eAttacker)
									{
										AddDLLMessage(
											pDefender->getOwner(), false, GC.getEVENT_MESSAGE_TIME(),
											gDLL->getText("TXT_KEY_MISC_ATTACKED_BY_MARAUDERS", pDefender->getNameKey(), getVisualCivAdjective(getTeam())),
											"AS2D_PILLAGED", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_YELLOW(), pDefenderPlot->getX(), pDefenderPlot->getY(), true, true
										);
									}
									else
									{
										AddDLLMessage(
											pDefender->getOwner(), false, GC.getEVENT_MESSAGE_TIME(),
											gDLL->getText("TXT_KEY_MISC_ATTACKED_BY_MARAUDERS_HIDDEN", pDefender->getNameKey()),
											"AS2D_PILLAGED", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_YELLOW(), pDefenderPlot->getX(), pDefenderPlot->getY(), true, true
										);
									}
								}
							}
							break;
						case COMMERCE_RESEARCH:
							if (isPillageResearch())
							{
								GET_TEAM(GET_PLAYER(getOwner()).getTeam()).changeResearchProgress(ePillageTech, iPillageGold, getOwner());
								if (bHuman)
								{
									if (BARBARIAN_PLAYER != eDefender)
									{
										AddDLLMessage(
											getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
											gDLL->getText(
												"TXT_KEY_MISC_PLUNDERED_RESEARCH_FROM_IMP",
												iPillageGold, getNameKey(), getVisualCivAdjective(pDefender->getTeam()), ePillageTech
											),
											"AS2D_PILLAGE", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_GREEN(), pDefenderPlot->getX(), pDefenderPlot->getY()
										);
									}
									else
									{
										AddDLLMessage(
											getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
											gDLL->getText("TXT_KEY_MISC_PLUNDERED_RESEARCH_FROM_IMP_HIDDEN", iPillageGold, getNameKey(), ePillageTech),
											"AS2D_PILLAGE", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_GREEN(), pDefenderPlot->getX(), pDefenderPlot->getY()
										);
									}
								}
							}
							break;
						case COMMERCE_CULTURE:
							break;
						case COMMERCE_ESPIONAGE:
							if (isPillageEspionage() && pDefenderPlot->getTeam() != NO_TEAM)
							{
								GET_TEAM(GET_PLAYER(getOwner()).getTeam()).changeEspionagePointsAgainstTeam(pDefenderPlot->getTeam(), iPillageGold);

								if (bHuman)
								{
									if (BARBARIAN_PLAYER != eDefender)
									{
										AddDLLMessage(
											getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
											gDLL->getText(
												"TXT_KEY_MISC_PLUNDERED_ESPIONAGE_FROM_IMP",
												iPillageGold, getNameKey(), getVisualCivAdjective(pDefender->getTeam()), ePillageTech
											),
											"AS2D_PILLAGE", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_GREEN(), pDefenderPlot->getX(), pDefenderPlot->getY()
										);
									}
									else
									{
										AddDLLMessage(
											getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
											gDLL->getText("TXT_KEY_MISC_PLUNDERED_ESPIONAGE_FROM_IMP_HIDDEN", iPillageGold, getNameKey(), ePillageTech),
											"AS2D_PILLAGE", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_GREEN(), pDefenderPlot->getX(), pDefenderPlot->getY()
										);
									}
								}
							}
							break;
						}
					}
				}
			}

			CvEventReporter::getInstance().combatResult(this, pDefender);
			//CvUnitInfo* pDefenderUnitInfo = &(pDefender->getUnitInfo());
			PlayerTypes eDefenderUnitPlayer = pDefender->getOwner();
			UnitTypes eDefenderUnitType = pDefender->getUnitType();

			// generate the kill outcome list but don't execute it yet
			//std::vector<UnitCombatTypes> aDefenderCombats;
			CvOutcomeListMerged mergedList;
			mergedList.addOutcomeList(pDefender->getUnitInfo().getKillOutcomeList());
			for (std::map<UnitCombatTypes, UnitCombatKeyedInfo>::const_iterator it = m_unitCombatKeyedInfo.begin(), end = m_unitCombatKeyedInfo.end(); it != end; ++it)
			{
				if(it->second.m_bHasUnitCombat)
				{
					mergedList.addOutcomeList(GC.getUnitCombatInfo((UnitCombatTypes)it->first).getKillOutcomeList());
					//aDefenderCombats.push_back((UnitCombatTypes)it->first);
				}
			}

			if (isSuicide())
			{
				kill(true);

				pDefender->kill(false, NO_PLAYER, true);
				pDefender = NULL;
			}
			else
			{
				if (pPlot == plot())
				{
					bSamePlot = true;
				}
				//TB debug attempt: added && pDefender->plot() == pPlot to try to allow units to move in when one defender on the plot withdrew.
				const bool bAdvance = !bSamePlot && canAdvance(pPlot, (pDefender->canDefend() && !pDefender->isDead() && pDefender->plot() == pPlot) ? 1 : 0);

				//TBMaybeproblem - should this come before the generation of the captive which takes place above at the add outcome step?
				if (bAdvance && !isNoCapture())
				{
					pDefender->setCapturingPlayer(getOwner());
					pDefender->setCapturingUnit(this);
				}

				pDefender->killUnconditional(false, NO_PLAYER, true);
				pDefender = NULL;
				//TB Combat Mod (Stampede) begin
				if (!bAdvance && !m_combatResult.bAttackerStampedes && !m_combatResult.bAttackerOnslaught && !bStealthDefense)
				{
					changeMoves(std::max(GC.getMOVE_DENOMINATOR(), pPlot->movementCost(this, plot())));
					checkRemoveSelectionAfterAttack();
				}
				if (m_combatResult.bAttackerStampedes || m_combatResult.bAttackerOnslaught)
				{
					getGroup()->clearMissionQueue();
					bFinish = false;
					attack(pPlot, true);
				}
				if (bAdvance && getGroup() != NULL)
				{
					PROFILE("CvUnit::updateCombat.Advance");
					getGroup()->groupMove(pPlot, true, ((bAdvance) ? this : NULL));
				}
			}
			//TB Combat Mods End

			if (getGroup() != NULL)
			{
				if (getGroup()->canAnyMove()) // testing selective situation here.
				{
					getGroup()->setMissionPaneDirty();
				}
				else getGroup()->clearMissionQueue();
			}
			mergedList.execute(*this, eDefenderUnitPlayer, eDefenderUnitType);
		}
		else if (m_combatResult.bDefenderWithdrawn)
		{
			if (!m_combatResult.bAttackerOnslaught)
			{

				if (!m_combatResult.bAttackerStampedes)
				{
					if (bHuman)
					{
						AddDLLMessage(
							getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
							gDLL->getText("TXT_KEY_MISC_ENEMY_UNIT_WITHDRAW", pDefender->getNameKey(), getNameKey()),
							"AS2D_OUR_WITHDRAWL", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_YELLOW(), pPlot->getX(), pPlot->getY()
						);
					}
					if (bHumanDefender)
					{
						AddDLLMessage(
							pDefender->getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
							gDLL->getText("TXT_KEY_MISC_YOU_UNIT_WITHDRAW", pDefender->getNameKey(), getNameKey()),
							"AS2D_THEIR_WITHDRAWL", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_GREEN(), pPlot->getX(), pPlot->getY()
						);
					}
				}
				else
				{
					if (bHuman)
					{
						AddDLLMessage(
							getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
							gDLL->getText("TXT_KEY_MISC_ENEMY_UNIT_WITHDRAW_STAMPEDE", pDefender->getNameKey(), getNameKey()),
							"AS2D_OUR_WITHDRAWL", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_YELLOW(), pPlot->getX(), pPlot->getY()
						);
					}
					if (bHumanDefender)
					{
						AddDLLMessage(
							pDefender->getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
							gDLL->getText("TXT_KEY_MISC_YOU_UNIT_WITHDRAW_STAMPEDE", pDefender->getNameKey(), getNameKey()),
							"AS2D_THEIR_WITHDRAWL", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_GREEN(), pPlot->getX(), pPlot->getY()
						);
					}
				}
			}
			else
			{
				if (bHuman)
				{
					AddDLLMessage(
						getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
						gDLL->getText("TXT_KEY_MISC_ENEMY_UNIT_WITHDRAW_ONSLAUGHT", pDefender->getNameKey(), getNameKey()),
						"AS2D_OUR_WITHDRAWL", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_YELLOW(), pPlot->getX(), pPlot->getY()
					);
				}
				if (bHumanDefender)
				{
					AddDLLMessage(
						pDefender->getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
						gDLL->getText("TXT_KEY_MISC_YOU_UNIT_WITHDRAW_ONSLAUGHT", pDefender->getNameKey(), getNameKey()),
						"AS2D_THEIR_WITHDRAWL", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_GREEN(), pPlot->getX(), pPlot->getY()
					);
				}
			}

			if (pPlot->isCity())
			{
				m_combatResult.pPlot = NULL;
				//TB Combat Mod (Stampede)
				if (m_combatResult.bAttackerStampedes || m_combatResult.bAttackerOnslaught)
				{
					getGroup()->clearMissionQueue();
					bFinish = false;
					attack(pPlot,true);
				}
				else
				{
					const bool bAdvance = !bSamePlot && canAdvance(pPlot, (pDefender->canDefend() && !pDefender->isDead() && pDefender->plot() == pPlot) ? 1 : 0);
					if (bAdvance)
					{
						if (getGroup() != NULL && pPlot->getNumVisiblePotentialEnemyDefenders(this) == 0)
						{
							PROFILE("CvUnit::updateCombat.Advance");
							getGroup()->groupMove(pPlot, true, bAdvance ? this : NULL);
						}
					}
					else if (!m_combatResult.bAttackerStampedes && !m_combatResult.bAttackerOnslaught)
					{
						changeMoves(std::max(GC.getMOVE_DENOMINATOR(), pPlot->movementCost(this, plot())));
						checkRemoveSelectionAfterAttack();
					}
					if (getGroup() != NULL)
					{
						if (!getGroup()->canAnyMove())//testing selective situation here.
						{
							getGroup()->clearMissionQueue();
						}
						else
						{
							getGroup()->setMissionPaneDirty();
						}
					}
				}
				//TB Combat Mod end
			}

			if (m_combatResult.pPlot != NULL && !bSamePlot)
			{
				FAssertMsg(m_combatResult.pPlot != plot(), "Can't escape back to attacker plot");
				FAssertMsg(m_combatResult.pPlot != pDefender->plot(), "Can't escape back to own plot");

				//defender escapes to a safe plot
				pDefender->move(m_combatResult.pPlot, true);
				const bool bAdvance = canAdvance(pPlot, (pDefender->canDefend() && !pDefender->isDead() && pDefender->plot() == pPlot) ? 1 : 0);

				//TB Combat Mod (Stampede) begin
				if (m_combatResult.bAttackerStampedes || m_combatResult.bAttackerOnslaught)
				{
					getGroup()->clearMissionQueue();
					bFinish = false;
					attack(pPlot,true);
				}
				else
				{
					if (getGroup() != NULL)
					{
						if (bAdvance && getGroup() != NULL && pPlot->getNumVisiblePotentialEnemyDefenders(this) == 0)
						{
							PROFILE("CvUnit::updateCombat.Advance");

							getGroup()->groupMove(pPlot, true, ((bAdvance) ? this : NULL));
						}
						else if (!bStealthDefense && !m_combatResult.bAttackerStampedes && !m_combatResult.bAttackerOnslaught)
						{
							changeMoves(std::max(GC.getMOVE_DENOMINATOR(), pPlot->movementCost(this, plot())));
							checkRemoveSelectionAfterAttack();
						}
					}
					else
					{
						//TB Combat Mod (Stampede) end
						if (!bStealthDefense)
						{
							changeMoves(std::max(GC.getMOVE_DENOMINATOR(), pPlot->movementCost(this, plot())));
						}
						checkRemoveSelectionAfterAttack();
					}
					if (getGroup() != NULL)
					{
						if (getGroup()->canAnyMove())//testing selective situation here.
						{
							getGroup()->setMissionPaneDirty();
						}
						else getGroup()->clearMissionQueue();
					}
				}
			}
			else
			{
				//TB Combat Mod (Stampede) end
				if (!bStealthDefense)
				{
					changeMoves(std::max(GC.getMOVE_DENOMINATOR(), pPlot->movementCost(this, plot())));
				}
				checkRemoveSelectionAfterAttack();
				if (getGroup() != NULL)
				{
					if (getGroup()->canAnyMove())//testing selective situation here.
					{
						getGroup()->setMissionPaneDirty();
					}
					else getGroup()->clearMissionQueue();
				}
			}
		}
		//TB Combat Mods
		//Repel
		else if (m_combatResult.bAttackerRepelled)
		{
			if (!m_combatResult.bAttackerStampedes && !m_combatResult.bAttackerOnslaught)
			{
				if (bHuman)
				{

					if (BARBARIAN_PLAYER != eDefender)
					{
						AddDLLMessage(
							getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
							gDLL->getText(
								"TXT_KEY_MISC_ATTACKER_REPELLED_HUMAN",
								getNameKey(), getVisualCivAdjective(pDefender->getTeam()), pDefender->getNameKey()
							),
							"AS2D_OUR_WITHDRAWL", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_YELLOW(), pPlot->getX(), pPlot->getY()
						);
					}
					else
					{
						AddDLLMessage(
							getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
							gDLL->getText("TXT_KEY_MISC_ATTACKER_REPELLED_HUMAN_HIDDEN", getNameKey(), pDefender->getNameKey()),
							"AS2D_OUR_WITHDRAWL", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_YELLOW(), pPlot->getX(), pPlot->getY()
						);
					}
				}
				if (bHumanDefender)
				{

					if (BARBARIAN_PLAYER != eDefender)
					{
						AddDLLMessage(
							pDefender->getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
							gDLL->getText("TXT_KEY_MISC_ATTACKER_REPELLED", getVisualCivAdjective(getTeam()), getNameKey(), pDefender->getNameKey()),
							"AS2D_THEIR_WITHDRAWL", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_GREEN(), pPlot->getX(), pPlot->getY()
						);
					}
					else
					{
						AddDLLMessage(
							pDefender->getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
							gDLL->getText("TXT_KEY_MISC_ATTACKER_REPELLED_HIDDEN", getNameKey(), pDefender->getNameKey()),
							"AS2D_THEIR_WITHDRAWL", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_GREEN(), pPlot->getX(), pPlot->getY()
						);
					}
				}
			}
			else if (!m_combatResult.bAttackerOnslaught)
			{
				if (bHuman)
				{

					if (BARBARIAN_PLAYER != eDefender)
					{
						AddDLLMessage(
							getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
							gDLL->getText(
								"TXT_KEY_MISC_ATTACKER_REPELLED_HUMAN_STAMPEDE",
								getNameKey(), getVisualCivAdjective(pDefender->getTeam()), pDefender->getNameKey()
							),
							"AS2D_OUR_WITHDRAWL", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_YELLOW(), pPlot->getX(), pPlot->getY()
						);
					}
					else
					{
						AddDLLMessage(
							getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
							gDLL->getText("TXT_KEY_MISC_ATTACKER_REPELLED_HUMAN_STAMPEDE_HIDDEN", getNameKey(), pDefender->getNameKey()),
							"AS2D_OUR_WITHDRAWL", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_YELLOW(), pPlot->getX(), pPlot->getY()
						);
					}
				}
				if (bHumanDefender)
				{

					if (BARBARIAN_PLAYER != eAttacker)
					{
						AddDLLMessage(
							pDefender->getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
							gDLL->getText("TXT_KEY_MISC_ATTACKER_REPELLED_STAMPEDE", getVisualCivAdjective(getTeam()), getNameKey(), pDefender->getNameKey()),
							"AS2D_THEIR_WITHDRAWL", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_GREEN(), pPlot->getX(), pPlot->getY()
						);
					}
					else
					{
						AddDLLMessage(
							pDefender->getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
							gDLL->getText("TXT_KEY_MISC_ATTACKER_REPELLED_STAMPEDE_HIDDEN", getNameKey(), pDefender->getNameKey()),
							"AS2D_THEIR_WITHDRAWL", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_GREEN(), pPlot->getX(), pPlot->getY()
						);
					}
				}
			}
			else
			{
				if (bHuman)
				{
					if (BARBARIAN_PLAYER != eDefender)
					{
						AddDLLMessage(
							getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
							gDLL->getText(
								"TXT_KEY_MISC_ATTACKER_REPELLED_HUMAN_ONSLAUGHT",
								getNameKey(), getVisualCivAdjective(pDefender->getTeam()), pDefender->getNameKey()
							),
							"AS2D_OUR_WITHDRAWL", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_YELLOW(), pPlot->getX(), pPlot->getY()
						);
					}
					else
					{
						AddDLLMessage(
							getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
							gDLL->getText("TXT_KEY_MISC_ATTACKER_REPELLED_HUMAN_ONSLAUGHT_HIDDEN", getNameKey(), pDefender->getNameKey()),
							"AS2D_OUR_WITHDRAWL", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_YELLOW(), pPlot->getX(), pPlot->getY()
						);
					}
				}
				if (bHumanDefender)
				{
					if (BARBARIAN_PLAYER != eAttacker)
					{
						AddDLLMessage(
							pDefender->getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
							gDLL->getText(
								"TXT_KEY_MISC_ATTACKER_REPELLED_ONSLAUGHT",
								getVisualCivAdjective(getTeam()), getNameKey(), pDefender->getNameKey()
							),
							"AS2D_THEIR_WITHDRAWL", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_GREEN(), pPlot->getX(), pPlot->getY()
						);
					}
					else
					{
						AddDLLMessage(
							pDefender->getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
							gDLL->getText("TXT_KEY_MISC_ATTACKER_REPELLED_ONSLAUGHT_HIDDEN", getNameKey(), pDefender->getNameKey()),
							"AS2D_THEIR_WITHDRAWL", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_GREEN(), pPlot->getX(), pPlot->getY()
						);
					}
				}
			}

			m_combatResult.bAttackerRepelled = false;

			if (m_combatResult.bAttackerStampedes || m_combatResult.bAttackerOnslaught)
			{
				//TB Combat Mod (Stampede)
				bFinish = false;
				attack(pPlot, true);
			}
			else
			{
				if (!bStealthDefense)
				{
					changeMoves(std::max(GC.getMOVE_DENOMINATOR(), pPlot->movementCost(this, plot())));
				}
				checkRemoveSelectionAfterAttack();
				if (getGroup() != NULL)
				{
					if (getGroup()->canAnyMove())//testing selective situation here.
					{
						getGroup()->setMissionPaneDirty();
					}
					else getGroup()->clearMissionQueue();
				}
			}
		}
		else if (m_combatResult.bDefenderKnockedBack)
		{
			//Knockback
			if (!m_combatResult.bAttackerStampedes && !m_combatResult.bAttackerOnslaught)
			{
				if (bHuman)
				{
					if (BARBARIAN_PLAYER != eDefender)
					{
						AddDLLMessage(
							getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
							gDLL->getText(
								"TXT_KEY_MISC_DEFENDER_KNOCKEDBACK_HUMAN",
								getNameKey(), getVisualCivAdjective(pDefender->getTeam()), pDefender->getNameKey()
							),
							"AS2D_THEIR_WITHDRAWL", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_GREEN(), pPlot->getX(), pPlot->getY()
						);
					}
					else
					{
						AddDLLMessage(
							getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
							gDLL->getText("TXT_KEY_MISC_DEFENDER_KNOCKEDBACK_HUMAN_HIDDEN", getNameKey(), pDefender->getNameKey()),
							"AS2D_THEIR_WITHDRAWL", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_GREEN(), pPlot->getX(), pPlot->getY()
						);
					}
				}
				if (bHumanDefender)
				{
					if (BARBARIAN_PLAYER != eAttacker)
					{
						AddDLLMessage(
							pDefender->getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
							gDLL->getText(
								"TXT_KEY_MISC_DEFENDER_KNOCKEDBACK",
								getVisualCivAdjective(getTeam()), getNameKey(), pDefender->getNameKey()
							),
							"AS2D_OUR_WITHDRAWL", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_YELLOW(), pPlot->getX(), pPlot->getY()
						);
					}
					else
					{
						AddDLLMessage(
							pDefender->getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
							gDLL->getText("TXT_KEY_MISC_DEFENDER_KNOCKEDBACK_HIDDEN", getNameKey(), pDefender->getNameKey()),
							"AS2D_OUR_WITHDRAWL", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_YELLOW(), pPlot->getX(), pPlot->getY()
						);
					}
				}
			}
			else if (!m_combatResult.bAttackerOnslaught)
			{
				if (bHuman)
				{
					if (BARBARIAN_PLAYER != eDefender)
					{
						AddDLLMessage(
							getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
							gDLL->getText(
								"TXT_KEY_MISC_DEFENDER_KNOCKEDBACK_HUMAN_STAMPEDE",
								getNameKey(), getVisualCivAdjective(pDefender->getTeam()), pDefender->getNameKey()
							),
							"AS2D_THEIR_WITHDRAWL", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_GREEN(), pPlot->getX(), pPlot->getY()
						);
					}
					else
					{
						AddDLLMessage(
							getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
							gDLL->getText(
								"TXT_KEY_MISC_DEFENDER_KNOCKEDBACK_HUMAN_STAMPEDE_HIDDEN",
								getNameKey(), pDefender->getNameKey()
							),
							"AS2D_THEIR_WITHDRAWL", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_GREEN(), pPlot->getX(), pPlot->getY()
						);
					}
				}
				if (bHumanDefender)
				{
					if (BARBARIAN_PLAYER != eAttacker)
					{
						AddDLLMessage(
							pDefender->getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
							gDLL->getText(
								"TXT_KEY_MISC_DEFENDER_KNOCKEDBACK_STAMPEDE",
								getVisualCivAdjective(getTeam()), getNameKey(), pDefender->getNameKey()
							),
							"AS2D_OUR_WITHDRAWL", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_YELLOW(), pPlot->getX(), pPlot->getY()
						);
					}
					else
					{
						AddDLLMessage(
							pDefender->getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
							gDLL->getText(
								"TXT_KEY_MISC_DEFENDER_KNOCKEDBACK_STAMPEDE_HIDDEN",
								getNameKey(), pDefender->getNameKey()
							),
							"AS2D_OUR_WITHDRAWL", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_YELLOW(), pPlot->getX(), pPlot->getY()
						);
					}
				}
			}
			else
			{
				if (bHuman)
				{
					if (BARBARIAN_PLAYER != eDefender)
					{
						AddDLLMessage(
							getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
							gDLL->getText(
								"TXT_KEY_MISC_DEFENDER_KNOCKEDBACK_HUMAN_ONSLAUGHT",
								getNameKey(), getVisualCivAdjective(pDefender->getTeam()), pDefender->getNameKey()
							),
							"AS2D_THEIR_WITHDRAWL", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_GREEN(), pPlot->getX(), pPlot->getY()
						);
					}
					else
					{
						AddDLLMessage(
							getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
							gDLL->getText(
								"TXT_KEY_MISC_DEFENDER_KNOCKEDBACK_HUMAN_ONSLAUGHT_HIDDEN",
								getNameKey(), pDefender->getNameKey()
							),
							"AS2D_THEIR_WITHDRAWL", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_GREEN(), pPlot->getX(), pPlot->getY()
						);
					}
				}
				if (bHumanDefender)
				{
					if (BARBARIAN_PLAYER != eAttacker)
					{
						AddDLLMessage(
							pDefender->getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
							gDLL->getText(
								"TXT_KEY_MISC_DEFENDER_KNOCKEDBACK_ONSLAUGHT",
								getVisualCivAdjective(getTeam()), getNameKey(), pDefender->getNameKey()
							),
							"AS2D_OUR_WITHDRAWL", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_YELLOW(), pPlot->getX(), pPlot->getY()
						);
					}
					else
					{
						AddDLLMessage(
							pDefender->getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
							gDLL->getText(
								"TXT_KEY_MISC_DEFENDER_KNOCKEDBACK_ONSLAUGHT_HIDDEN",
								getNameKey(), pDefender->getNameKey()
							),
							"AS2D_OUR_WITHDRAWL", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_YELLOW(), pPlot->getX(), pPlot->getY()
						);
					}
				}
			}
			m_combatResult.bDefenderKnockedBack = false;

			if (pPlot->isCity())
			{
				m_combatResult.pPlot = NULL;
			}
			pDefender->setFortifyTurns(0);

			if (m_combatResult.pPlot != NULL)
			{
				FAssertMsg(m_combatResult.pPlot != plot(), "Can't get knocked back to attacker plot");
				FAssertMsg(m_combatResult.pPlot != pDefender->plot(), "Can't get knocked back to own plot");

				//defender escapes to a safe plot
				pDefender->move(m_combatResult.pPlot, true);
				pDefender->getGroup()->clearMissionQueue();
			}

			const bool bAdvance = canAdvance(pPlot, (pDefender->canDefend() && !pDefender->isDead() && pDefender->plot() == pPlot) ? 1 : 0);

			if (!bAdvance && !m_combatResult.bAttackerStampedes && !m_combatResult.bAttackerOnslaught)
			{
				if (!isNoCapture())
				{
					pDefender->setCapturingPlayer(getOwner());
					pDefender->setCapturingUnit(this);
				}
				if (!bStealthDefense)
				{
					changeMoves(std::max(GC.getMOVE_DENOMINATOR(), pPlot->movementCost(this, plot())));
				}
			}
			else if (m_combatResult.bAttackerStampedes || m_combatResult.bAttackerOnslaught)
			{
				//TB Combat Mod (Stampede)
				getGroup()->clearMissionQueue();
				bFinish = false;
				attack(pPlot,true);
			}

			if (getGroup() != NULL)
			{
				if (pPlot->getNumVisiblePotentialEnemyDefenders(this) == 0)
				{
					PROFILE("CvUnit::updateCombat.Advance");

					getGroup()->groupMove(pPlot, true, ((bAdvance) ? this : NULL));
				}

				// This is before the plot advancement, the unit will always try to walk back
				// to the square that they came from, before advancing.
			}
			checkRemoveSelectionAfterAttack();
			if (getGroup() != NULL)
			{
				if (getGroup()->canAnyMove())//testing selective situation here.
				{
					getGroup()->setMissionPaneDirty();
				}
				else getGroup()->clearMissionQueue();
			}
		}
		else if (m_combatResult.bAttackerWithdraws)
		{
			if (!m_combatResult.bAttackerStampedes && !m_combatResult.bAttackerOnslaught)
			{
				if (bHuman)
				{
					AddDLLMessage(
						getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
						gDLL->getText("TXT_KEY_MISC_YOU_UNIT_WITHDRAW", getNameKey(), pDefender->getNameKey()),
						"AS2D_OUR_WITHDRAWL", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_GREEN(), pPlot->getX(), pPlot->getY()
					);
				}
				if (bHumanDefender)
				{
					AddDLLMessage(
						pDefender->getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
						gDLL->getText("TXT_KEY_MISC_ENEMY_UNIT_WITHDRAW", getNameKey(), pDefender->getNameKey()),
						"AS2D_THEIR_WITHDRAWL", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_YELLOW(), pPlot->getX(), pPlot->getY()
					);
				}
				changeMoves(std::max(GC.getMOVE_DENOMINATOR(), pPlot->movementCost(this, plot())));
				//GC.getGame().logOOSSpecial(53, getID(), getMoves(), getDamage());
				checkRemoveSelectionAfterAttack();

				if (getGroup() != NULL)
				{
					if (getGroup()->canAnyMove())//testing selective situation here.
					{
						getGroup()->setMissionPaneDirty();
					}
					else getGroup()->clearMissionQueue();
				}
			}
			//TB Combat Mod (Stampede) begin
			else if (m_combatResult.bAttackerStampedes)
			{
				if (bHuman)
				{
					AddDLLMessage(
						getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
						gDLL->getText("TXT_KEY_MISC_YOU_UNIT_ATTACKER_WITHDRAW_STAMPEDE", getNameKey(), pDefender->getNameKey()),
						"AS2D_OUR_WITHDRAWL", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_GREEN(), pPlot->getX(), pPlot->getY()
					);
				}
				if (bHumanDefender)
				{
					AddDLLMessage(
						pDefender->getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
						gDLL->getText("TXT_KEY_MISC_ENEMY_UNIT_ATTACKER_WITHDRAW_STAMPEDE", getNameKey(), pDefender->getNameKey()),
						"AS2D_THEIR_WITHDRAWL", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_YELLOW(), pPlot->getX(), pPlot->getY()
					);
				}
				if (getGroup() != NULL)
				{
					getGroup()->clearMissionQueue();
				}
				bFinish = false;
				attack(pPlot,true);
			}
			else if (m_combatResult.bAttackerOnslaught)
			{
				if (bHuman)
				{
					AddDLLMessage(
						getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
						gDLL->getText("TXT_KEY_MISC_YOU_UNIT_ATTACKER_WITHDRAW_ONSLAUGHT", getNameKey(), pDefender->getNameKey()),
						"AS2D_OUR_WITHDRAWL", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_GREEN(), pPlot->getX(), pPlot->getY()
					);
				}
				if (bHumanDefender)
				{
					AddDLLMessage(
						pDefender->getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
						gDLL->getText("TXT_KEY_MISC_ENEMY_UNIT_ATTACKER_WITHDRAW_ONSLAUGHT", getNameKey(), pDefender->getNameKey()),
						"AS2D_THEIR_WITHDRAWL", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_YELLOW(), pPlot->getX(), pPlot->getY()
					);
				}
				if (getGroup() != NULL)
				{
					getGroup()->clearMissionQueue();
				}
				bFinish = false;
				attack(pPlot,true);
			}
		}
		else
		{
			if (!bStealthDefense)
			{
				changeMoves(std::max(GC.getMOVE_DENOMINATOR(), pPlot->movementCost(this, plot())));
			}
			checkRemoveSelectionAfterAttack();
			if (getGroup() != NULL)
			{
				if (getGroup()->canAnyMove()) // testing selective situation here.
				{
					getGroup()->setMissionPaneDirty();
				}
				else getGroup()->clearMissionQueue();
			}
		}
	}
}

void CvUnit::checkRemoveSelectionAfterAttack()
{
	if (IsSelected() && !canMove() && gDLL->getInterfaceIFace()->getLengthSelectionList() > 1)
	{
		gDLL->getInterfaceIFace()->removeFromSelectionList(this);
	}
}


bool CvUnit::isActionRecommended(int iAction) const
{
	if (getOwner() != GC.getGame().getActivePlayer()
	|| GET_PLAYER(getOwner()).isOption(PLAYEROPTION_NO_UNIT_RECOMMENDATIONS))
	{
		return false;
	}

	CvPlot* pPlot = gDLL->getInterfaceIFace()->getGotoPlot();

	if (pPlot == NULL && gDLL->shiftKey())
	{
		pPlot = getGroup()->lastMissionPlot();
	}
	if (pPlot == NULL)
	{
		pPlot = plot();
	}

	if (GC.getActionInfo(iAction).getMissionType() == MISSION_FORTIFY)
	{
		if (pPlot->isCity(true, getTeam()) && canDefend(pPlot) && pPlot->getNumDefenders(getOwner()) < (atPlot(pPlot) ? 2 : 1))
		{
			return true;
		}
	}
#ifdef _MOD_SENTRY
	else if (GC.getActionInfo(iAction).getMissionType() == MISSION_HEAL || GC.getActionInfo(iAction).getMissionType() == MISSION_SENTRY_WHILE_HEAL)
#else
	else if(GC.getActionInfo(iAction).getMissionType() == MISSION_HEAL || GC.getActionInfo(iAction).getMissionType() == MISSION_HEAL_BUILDUP)
#endif
	{
		if (isHurt() && !hasMoved() && (pPlot->getTeam() == getTeam() || healTurns(pPlot) > 0))
		{
			return true;
		}
	}
	else if (GC.getActionInfo(iAction).getCommandType() == COMMAND_PROMOTION)
	{
		return true;
	}
	else if (GC.getActionInfo(iAction).getMissionType() == MISSION_BUILD)
	{
		if (pPlot->getOwner() == getOwner())
		{
			const BuildTypes eBuild = (BuildTypes) GC.getActionInfo(iAction).getMissionData();

			FASSERT_BOUNDS(0, GC.getNumBuildInfos(), eBuild);

			if (canBuild(pPlot, eBuild))
			{
				const ImprovementTypes eImprovement = pPlot->getImprovementType();

				// Recommend build
				if (eImprovement == NO_IMPROVEMENT)
				{
					// If City AI wants it
					const CvCity* pWorkingCity = pPlot->getWorkingCity();

					if (pWorkingCity != NULL)
					{
						const int iIndex = pWorkingCity->getCityPlotIndex(pPlot);
						if (iIndex != -1 && pWorkingCity->AI_getBestBuild(iIndex) == eBuild)
						{
							return true;
						}
					}
					// Recommend improvement
					const ImprovementTypes eImprovementNew = GC.getBuildInfo(eBuild).getImprovement();

					if (eImprovementNew != NO_IMPROVEMENT)
					{
						const CvImprovementInfo& improvement = GC.getImprovementInfo(eImprovementNew);

						const BonusTypes eBonus = pPlot->getBonusType(getTeam());

						// If it provides bonus
						if (eBonus != NO_BONUS && improvement.isImprovementBonusTrade(eBonus))
						{
							return true;
						}
						// If it irrigates
						if (improvement.isCarriesIrrigation() && !pPlot->isIrrigated() && pPlot->isIrrigationAvailable(true))
						{
							return true;
						}
						// If it gives yields
						if (pWorkingCity != NULL)
						{
							if (improvement.getYieldChange(YIELD_COMMERCE) > 0)
							{
								return true;
							}
							// Food is only interesting on flatland/water
							if (improvement.getYieldChange(YIELD_FOOD) > 0 && !pPlot->isHills() && !pPlot->isAsPeak())
							{
								return true;
							}
							if (improvement.getYieldChange(YIELD_PRODUCTION) > 0)
							{
								return true;
							}
						}
					}
				}
				// Recommend route
				const RouteTypes eRouteNew = (RouteTypes) GC.getBuildInfo(eBuild).getRoute();

				if (eRouteNew != NO_ROUTE)
				{
					// If bonus with no route
					if (!pPlot->isRoute() && pPlot->getBonusType(getTeam()) != NO_BONUS)
					{
						return true;
					}
					// If route improves yields from improvement
					if (eImprovement != NO_IMPROVEMENT
					&& (
						GC.getImprovementInfo(eImprovement).getRouteYieldChanges(eRouteNew, YIELD_FOOD) > 0
					||	GC.getImprovementInfo(eImprovement).getRouteYieldChanges(eRouteNew, YIELD_PRODUCTION) > 0
					||	GC.getImprovementInfo(eImprovement).getRouteYieldChanges(eRouteNew, YIELD_COMMERCE) > 0))
					{
						return true;
					}
				}
			}
		}
	}
	else if (GC.getActionInfo(iAction).getMissionType() == MISSION_FOUND)
	{
		if (canFound(pPlot) && pPlot->isBestAdjacentFound(getOwner()))
		{
			return true;
		}
	}
	return false;
}

int CvUnit::defenderValue(const CvUnit* pAttacker) const
{
	if (!canDefend())
	{
		return 1;
	}

	int iValue = 0;
	bool bTargetOverride = false;

	TeamTypes eAttackerTeam = NO_TEAM;
	if (NULL != pAttacker)
	{
		eAttackerTeam = pAttacker->getTeam();

		CvPlot* pPlot = plot();
		if (pPlot != NULL)
		{
			if (canCoexistWithAttacker(*pAttacker))
			{
				return 0;
			}
		}
		else if (canCoexistWithTeam(eAttackerTeam))
		{
			return 0;
		}

		if (!pAttacker->canAttack(*this))
		{
			return 2;
		}

		if (isTargetOf(*pAttacker))
		{
			bTargetOverride = true;
		}
	}

	iValue += currCombatStr(plot(), pAttacker);
	if (::isWorldUnit(getUnitType()))
	{
		iValue /= 2;
	}

	if (NULL == pAttacker)
	{
		if (collateralDamage() > 0)
		{
			iValue *= 100;
			iValue /= 100 + collateralDamage();
		}

		if (currInterceptionProbability() > 0)
		{
			iValue *= 100;
			iValue /= 100 + currInterceptionProbability();
		}
	}
	else
	{
		if (!pAttacker->immuneToFirstStrikes())
		{
			iValue *= 100 + (firstStrikes() * 2 + chanceFirstStrikes()) * (GC.getCOMBAT_DAMAGE() * 2 / 5);
			iValue /= 100;
		}
		if (immuneToFirstStrikes())
		{
			iValue *= 100 + (pAttacker->firstStrikes() * 2 + pAttacker->chanceFirstStrikes()) * (GC.getCOMBAT_DAMAGE() * 2 / 5);
			iValue /= 100;
		}
	}

	const int iAssetValue = std::max(1, assetValueTotal()/100);
	int iCargoAssetValue = 0;
	std::vector<CvUnit*> aCargoUnits;
	getCargoUnits(aCargoUnits);
	foreach_(const CvUnit* pCargo, aCargoUnits)
	{
		iCargoAssetValue += std::max(1, pCargo->assetValueTotal()/100);
	}
	iValue = iValue * iAssetValue / std::max(1, iAssetValue + iCargoAssetValue);

	if (NO_UNIT == getLeaderUnitType())
	{
		++iValue;
	}

	iValue += tauntTotal() * iValue / 100;
	// It should be greater than 0 as this target is at least valid as per the checks above
	iValue = std::max(1, iValue);

	if (bTargetOverride)
	{
		iValue += 1000000;
	}

	return iValue + 3;
}

bool CvUnit::isBetterDefenderThan(const CvUnit* pDefender, const CvUnit* pAttacker) const
{
	int iOurDefense;
	int iTheirDefense;

	if (pDefender == NULL)
	{
		return true;
	}

	const TeamTypes eAttackerTeam = pAttacker ? pAttacker->getTeam() : NO_TEAM;

	if (canCoexistWithTeam(eAttackerTeam))
	{
		return false;
	}

	if (!canDefend())
	{
		return false;
	}

	if (canDefend() && !(pDefender->canDefend()))
	{
		return true;
	}

	if (pAttacker)
	{
		if (isTargetOf(*pAttacker) && !pDefender->isTargetOf(*pAttacker))
		{
			return true;
		}

		if (!isTargetOf(*pAttacker) && pDefender->isTargetOf(*pAttacker))
		{
			return false;
		}

		if (pAttacker->canAttack(*pDefender) && !pAttacker->canAttack(*this))
		{
			return false;
		}

		if (pAttacker->canAttack(*this) && !pAttacker->canAttack(*pDefender))
		{
			return true;
		}
	}

	iOurDefense = currCombatStr(plot(), pAttacker);
	if (::isWorldUnit(getUnitType()))
	{
		iOurDefense /= 2;
	}

	if (NULL == pAttacker)
	{
		if (pDefender->collateralDamage() > 0)
		{
			iOurDefense *= (100 + pDefender->collateralDamage());
			iOurDefense /= 100;
		}

		if (pDefender->currInterceptionProbability() > 0)
		{
			iOurDefense *= (100 + pDefender->currInterceptionProbability());
			iOurDefense /= 100;
		}
	}
	else
	{
		if (!(pAttacker->immuneToFirstStrikes()))
		{
			iOurDefense *= ((((firstStrikes() * 2) + chanceFirstStrikes()) * ((GC.getCOMBAT_DAMAGE() * 2) / 5)) + 100);
			iOurDefense /= 100;
		}

		if (immuneToFirstStrikes())
		{
			iOurDefense *= ((((pAttacker->firstStrikes() * 2) + pAttacker->chanceFirstStrikes()) * ((GC.getCOMBAT_DAMAGE() * 2) / 5)) + 100);
			iOurDefense /= 100;
		}
	}

	int iAssetValue = assetValueTotal()/100;
	int iCargoAssetValue = 0;
	std::vector<CvUnit*> aCargoUnits;
	getCargoUnits(aCargoUnits);
	foreach_(const CvUnit* pCargoUnit, aCargoUnits)
	{
		iCargoAssetValue += pCargoUnit->assetValueTotal()/100;
	}
	iOurDefense = iOurDefense * iAssetValue / std::max(1, iAssetValue + iCargoAssetValue);

	iTheirDefense = pDefender->currCombatStr(plot(), pAttacker);
	if (::isWorldUnit(pDefender->getUnitType()))
	{
		iTheirDefense /= 2;
	}

	if (NULL == pAttacker)
	{
		if (collateralDamage() > 0)
		{
			iTheirDefense *= (100 + collateralDamage());
			iTheirDefense /= 100;
		}

		if (currInterceptionProbability() > 0)
		{
			iTheirDefense *= (100 + currInterceptionProbability());
			iTheirDefense /= 100;
		}
	}
	else
	{
		if (!(pAttacker->immuneToFirstStrikes()))
		{
			iTheirDefense *= ((((pDefender->firstStrikes() * 2) + pDefender->chanceFirstStrikes()) * ((GC.getCOMBAT_DAMAGE() * 2) / 5)) + 100);
			iTheirDefense /= 100;
		}

		if (pDefender->immuneToFirstStrikes())
		{
			iTheirDefense *= ((((pAttacker->firstStrikes() * 2) + pAttacker->chanceFirstStrikes()) * ((GC.getCOMBAT_DAMAGE() * 2) / 5)) + 100);
			iTheirDefense /= 100;
		}
	}

	iAssetValue = pDefender->assetValueTotal()/100;
	iCargoAssetValue = 0;
	pDefender->getCargoUnits(aCargoUnits);
	foreach_(const CvUnit* pCargoUnit, aCargoUnits)
	{
		iCargoAssetValue += pCargoUnit->assetValueTotal()/100;
	}
	iTheirDefense = iTheirDefense * iAssetValue / std::max(1, iAssetValue + iCargoAssetValue);

	if (iOurDefense == iTheirDefense)
	{
		if (NO_UNIT == getLeaderUnitType() && NO_UNIT != pDefender->getLeaderUnitType())
		{
			++iOurDefense;
		}
		else if (NO_UNIT != getLeaderUnitType() && NO_UNIT == pDefender->getLeaderUnitType())
		{
			++iTheirDefense;
		}
		else if (isBeforeUnitCycle(this, pDefender))
		{
			++iOurDefense;
		}
	}

	iOurDefense += (tauntTotal() * iOurDefense) / 100;
	iTheirDefense += (pDefender->tauntTotal() * iTheirDefense) / 100;

	return (iOurDefense > iTheirDefense);
}


bool CvUnit::canDoCommand(CommandTypes eCommand, int iData1, int iData2, bool bTestVisible, bool bTestBusy) const
{
	CvUnit* pUnit;

	if (bTestBusy && getGroup()->isBusy())
	{
		return false;
	}

	switch (eCommand)
	{
	case COMMAND_PROMOTION:
		if (canPromote((PromotionTypes)iData1, iData2))
		{
			return true;
		}
		break;

	case COMMAND_UPGRADE:
		if (canUpgrade(((UnitTypes)iData1), bTestVisible))
		{
			return true;
		}
		break;

	case COMMAND_AUTOMATE:
		if (canAutomate((AutomateTypes)iData1))
		{
			return true;
		}
		break;

	case COMMAND_WAKE:
		if (!isAutomated() && isWaiting())
		{
			return true;
		}
		break;

	case COMMAND_CANCEL:
	case COMMAND_CANCEL_ALL:
		if (!isAutomated() && getGroup()->getLengthMissionQueue() > 0)
		{
			return true;
		}
		break;

	case COMMAND_STOP_AUTOMATION:
		if (isAutomated())
		{
			return true;
		}
		break;

	case COMMAND_DELETE:
		if (canScrap())
		{
			return true;
		}
		break;

	case COMMAND_GIFT:
		if (canGift(bTestVisible))
		{
			return true;
		}
		break;

	case COMMAND_LOAD:
		if (canLoad(plot()))
		{
			return true;
		}
		break;

	case COMMAND_LOAD_UNIT:
		pUnit = ::getUnit(IDInfo(((PlayerTypes)iData1), iData2));
		if (pUnit != NULL)
		{
			if (canLoadOntoUnit(pUnit, plot()))
			{
				return true;
			}
		}
		break;

	case COMMAND_UNLOAD:
		if (canUnload())
		{
			return true;
		}
		break;

	case COMMAND_UNLOAD_ALL:
		if (canUnloadAll())
		{
			return true;
		}
		break;

	case COMMAND_HOTKEY:
		if (isGroupHead())
		{
			return true;
		}
		break;

	case COMMAND_REEQUIP:

		if (plot()->isCity(true, getTeam()))
		{
			if (canSwitchEquipment((PromotionTypes)iData1))
			{
				return true;
			}
		}
		break;
//TBSIZE
	case COMMAND_MERGE:

		if (GC.getGame().isOption(GAMEOPTION_SIZE_MATTERS))
		{
			if (canMerge())
			{
				return true;
			}
		}
		break;

	case COMMAND_SPLIT:

		if (GC.getGame().isOption(GAMEOPTION_SIZE_MATTERS))
		{
			if (canSplit())
			{
				return true;
			}
		}
		break;

	case COMMAND_STATUS:

		if ((PromotionTypes)iData1 != NO_PROMOTION)
		{//TBHERE
			bool bIsQuick = GC.getPromotionInfo((PromotionTypes)iData1).isQuick();
			if ((!hasMoved() || (canMove() && bIsQuick)) && canAcquirePromotion((PromotionTypes)iData1, PromotionRequirements::ForStatus))
			{
				return true;
			}
		}
		break;

	case COMMAND_ARREST:
		if (canArrest())
		{
			return true;
		}
		break;

	case COMMAND_AMBUSH:
		return false;
		break;

	default:
		FErrorMsg("error");
		break;
	}

	return false;
}


void CvUnit::doCommand(CommandTypes eCommand, int iData1, int iData2)
{
	CvUnit* pUnit;

	bool bCycle = false;

	FAssert(getOwner() != NO_PLAYER);

	if (canDoCommand(eCommand, iData1, iData2))
	{
		switch (eCommand)
		{
		case COMMAND_PROMOTION:
			promote((PromotionTypes)iData1, iData2);
			break;

		case COMMAND_UPGRADE:
			upgrade((UnitTypes)iData1);
			bCycle = true;
			break;

		case COMMAND_AUTOMATE:
			automate((AutomateTypes)iData1);
			bCycle = true;
			break;

		case COMMAND_WAKE:
			getGroup()->setActivityType(ACTIVITY_AWAKE);
			break;

		case COMMAND_CANCEL:
			getGroup()->popMission();
			break;

		case COMMAND_CANCEL_ALL:
			getGroup()->clearMissionQueue();
			break;

		case COMMAND_STOP_AUTOMATION:
			getGroup()->setAutomateType(NO_AUTOMATE);
			break;

		case COMMAND_DELETE:
			scrap();
			bCycle = true;
			break;

		case COMMAND_GIFT:
			gift();
			bCycle = true;
			break;

		case COMMAND_LOAD:
			load();
			bCycle = true;
			break;

		case COMMAND_LOAD_UNIT:
			pUnit = ::getUnit(IDInfo(((PlayerTypes)iData1), iData2));
			if (pUnit != NULL)
			{
				loadOntoUnit(pUnit);
				bCycle = true;
			}
			break;

		case COMMAND_UNLOAD:
			unload();
			bCycle = true;
			break;

		case COMMAND_UNLOAD_ALL:
			unloadAll();
			bCycle = true;
			break;

		case COMMAND_HOTKEY:
			setHotKeyNumber(iData1);
			break;

		case COMMAND_REEQUIP:
			reEquip((PromotionTypes)iData1);
			finishMoves();
			break;

		case COMMAND_MERGE:
			if (!GET_PLAYER(getOwner()).isBarbarian())
			{
				doMerge();
			}
			break;

		case COMMAND_SPLIT:
			if (!GET_PLAYER(getOwner()).isBarbarian())
			{
				doSplit();
			}
			break;

		case COMMAND_STATUS:
			statusUpdate((PromotionTypes)iData1);
			if (!GC.getPromotionInfo((PromotionTypes)iData1).isQuick())
			{
				finishMoves();
			}
			break;

		case COMMAND_ARREST:
			doArrest();
			break;

		case COMMAND_AMBUSH:
			break;

		default:
			FErrorMsg("error");
			break;
		}
	}

	if (bCycle)
	{
		if (IsSelected())
		{
			gDLL->getInterfaceIFace()->setCycleSelectionCounter(1);
		}
	}

	getGroup()->doDelayedDeath();
}


#ifdef USE_OLD_PATH_GENERATOR
FAStarNode* CvUnit::getPathLastNode() const
{
	return getGroup()->getPathLastNode();
}
#else
int CvUnit::getPathMovementRemaining() const
{
	return getGroup()->getPath().movementRemaining();
}
#endif


CvPlot* CvUnit::getPathEndTurnPlot() const
{
	return getGroup()->getPathEndTurnPlot();
}


bool CvUnit::generatePath(const CvPlot* pToPlot, int iFlags, bool bReuse, int* piPathTurns, int iMaxTurns, int iOptimizationLimit) const
{
	//TB OOS fix: This is just to assist me with my tracking
	//GC.getGame().logOOSSpecial(29, getGroup()->getID(), iMaxTurns);
	return getGroup()->generatePath(plot(), pToPlot, iFlags, bReuse, piPathTurns, iMaxTurns, iOptimizationLimit);
}


bool CvUnit::canEnterTerritory(TeamTypes eTeam, bool bIgnoreRightOfPassage) const
{
	if (eTeam == NO_TEAM)
	{
		return true;
	}

	if (GET_TEAM(getTeam()).isFriendlyTerritory(eTeam))
	{
		return true;
	}

	if (isEnemy(eTeam))
	{
		return true;
	}

	if (isRivalTerritory())
	{
		return true;
	}

	if (alwaysInvisible())
	{
		return true;
	}

	if (isHiddenNationality())
	{
		return true;
	}

	if (!bIgnoreRightOfPassage)
	{
		if (GET_TEAM(getTeam()).isOpenBorders(eTeam))
		{
			return true;
		}

		if (GET_TEAM(getTeam()).isLimitedBorders(eTeam) && (isOnlyDefensive() || !canFight() || isPassage()))
		{
			return true;
		}
	}
	if (!GET_TEAM(eTeam).isAlive())
	{
		return true;
	}

	return false;
}


bool CvUnit::canEnterArea(TeamTypes eTeam, const CvArea* pArea, bool bIgnoreRightOfPassage) const
{
	if (!canEnterTerritory(eTeam, bIgnoreRightOfPassage))
	{
		return false;
	}
	/*
	if (isBarbarian() && DOMAIN_LAND == getDomainType() && eTeam != NO_TEAM && eTeam != getTeam()
	&& pArea && pArea->isBorderObstacle(eTeam) && pArea->getID() != getArea())
	{
		return false;
	}
	*/
	return true;
}


// Returns the ID of the team to declare war against
TeamTypes CvUnit::getDeclareWarMove(const CvPlot* pPlot) const
{
	FAssert(isHuman());

	if (getDomainType() != DOMAIN_AIR)
	{
		const TeamTypes eRevealedTeam = pPlot->getRevealedTeam(getTeam(), false);

		if (eRevealedTeam != NO_TEAM)
		{
			if ((!canEnterArea(eRevealedTeam, pPlot->area()) || getDomainType() == DOMAIN_SEA && !canCargoEnterArea(eRevealedTeam, pPlot->area(), false) && getGroup()->isAmphibPlot(pPlot))
			&& GET_TEAM(getTeam()).canDeclareWar(pPlot->getTeam()))
			{
				return eRevealedTeam;
			}
		}
		else if (pPlot->isActiveVisible(false) && canMoveInto(pPlot, MoveCheck::Attack | MoveCheck::DeclareWar | MoveCheck::IgnoreLoad))
		{
			const CvUnit* pUnit = pPlot->plotCheck(PUF_canDeclareWar, getOwner(), isAlwaysHostile(pPlot), NULL, NO_PLAYER, NO_TEAM, PUF_isVisible, getOwner());

			if (pUnit != NULL)
			{
				return pUnit->getTeam();
			}
		}
	}
	return NO_TEAM;
}

bool CvUnit::willRevealByMove(const CvPlot* pPlot) const
{
	const int iRange = visibilityRange(pPlot) + 1;
	foreach_(const CvPlot* pLoopPlot, pPlot->rect(iRange, iRange))
	{
		if (!pLoopPlot->isRevealed(getTeam(), false)
		&& pPlot->canSeePlot(pLoopPlot, getTeam(), visibilityRange(), NO_DIRECTION))
		{
			return true;
		}
	}
	return false;
}

bool CvUnit::canMoveInto(const CvPlot* pPlot, MoveCheck::flags flags /*= MoveCheck::None*/, CvUnit** ppDefender /*= NULL*/) const
{
	FAssertMsg(pPlot != NULL, "Plot is not assigned a valid value");
	if (pPlot == NULL)
	{
		return false;
	}
	const bool bAttack = flags & MoveCheck::Attack;
	const bool bDeclareWar = flags & MoveCheck::DeclareWar;
	const bool bIgnoreLoad = flags & MoveCheck::IgnoreLoad;
	const bool bIgnoreTileLimit = flags & MoveCheck::IgnoreTileLimit;
	const bool bIgnoreLocation = flags & MoveCheck::IgnoreLocation;
	const bool bIgnoreAttack = flags & MoveCheck::IgnoreAttack;
	const bool bCheckForBest = flags & MoveCheck::CheckForBest;
	FAssertMsg((!bCheckForBest && ppDefender == nullptr) || (bCheckForBest && ppDefender), "MoveCheck::CheckForBest implies ppDefender is valid and vice-versa");

	const bool bAssassinate = flags & MoveCheck::Assassinate;
	const bool bSuprise = flags & MoveCheck::Suprise;

	bool bFailWithAttack = false;
	bool bFailWithoutAttack = false;

	PROFILE_FUNC();

	bool bIsVisibleEnemyDefender = (pPlot->isVisiblePotentialEnemyDefender(this) || pPlot->isVisiblePotentialEnemyDefenderless(this));

	const bool bCanCoexist = canCoexistAlwaysOnPlot(*pPlot);
	if (bCanCoexist && bIsVisibleEnemyDefender)
	{
		bIsVisibleEnemyDefender = false;
	}

	if (!bIgnoreLocation && atPlot(pPlot))
	{
		return false;
	}
	// Can Explore?
	if (m_pUnitInfo->isNoRevealMap() && willRevealByMove(pPlot))
	{
		return false;
	}
	// Exiled?
	if (isExcile() && (pPlot->getOwner() == getOwner() || pPlot->getOwner() == getOriginalOwner()))
	{
		return false;
	}

	if (!isMapCategory(*pPlot, *m_pUnitInfo))
	{
		return false;
	}

	if (GC.getUSE_SPIES_NO_ENTER_BORDERS() && isSpy() && NO_PLAYER != pPlot->getOwner()
	&& !GET_PLAYER(getOwner()).canSpiesEnterBorders(pPlot->getOwner()))
	{
		return false;
	}

	const CvArea* pPlotArea = pPlot->area();
	TeamTypes ePlotTeam = pPlot->getTeam();
	bool bCanEnterArea = canEnterArea(ePlotTeam, pPlotArea);
	if (bCanEnterArea)
	{
		if (pPlot->getFeatureType() != NO_FEATURE)
		{
			if (algo::any_of_equal(m_pUnitInfo->getImpassableFeatures(), pPlot->getFeatureType()))
			{
				const TechTypes eTech = (TechTypes)m_pUnitInfo->getFeaturePassableTech(pPlot->getFeatureType());
				if (NO_TECH == eTech || !GET_TEAM(getTeam()).isHasTech(eTech))
				{
					if (DOMAIN_SEA != getDomainType() || pPlot->getTeam() != getTeam())  // sea units can enter impassable in own cultural borders
					{
						return false;
					}
				}
			}
		}

		if (pPlot->isAsPeak() && m_pUnitInfo->isTerrainImpassableType(GC.getTERRAIN_PEAK())
		|| pPlot->isHills() && m_pUnitInfo->isTerrainImpassableType(GC.getTERRAIN_HILL()))
		{
			const TechTypes eTech = (TechTypes)m_pUnitInfo->getTerrainPassableTech(pPlot->getTerrainType());
			if (NO_TECH == eTech || !GET_TEAM(getTeam()).isHasTech(eTech))
			{
				if (DOMAIN_SEA != getDomainType() || pPlot->getTeam() != getTeam())  // sea units can enter impassable in own cultural borders
				{
					if (bIgnoreLoad || !canLoad(pPlot))
					{
						return false;
					}
				}
			}
		}
		if (algo::any_of_equal(m_pUnitInfo->getImpassableTerrains(), pPlot->getTerrainType()))
		{
			const TechTypes eTech = (TechTypes)m_pUnitInfo->getTerrainPassableTech(pPlot->getTerrainType());
			if (NO_TECH == eTech || !GET_TEAM(getTeam()).isHasTech(eTech))
			{
				if (DOMAIN_SEA != getDomainType() || pPlot->getTeam() != getTeam())  // sea units can enter impassable in own cultural borders
				{
					if (bIgnoreLoad || !canLoad(pPlot))
					{
						return false;
					}
				}
			}
		}
	}

	switch (getDomainType())
	{
	case DOMAIN_SEA:
		if (!pPlot->isWater() && !canMoveAllTerrain() && !pPlot->isCanMoveSeaUnits())
		{
			if (!pPlot->isFriendlyCity(*this, true) || !pPlot->isCoastalLand())
			{
				return false;
			}
		}
		break;

	case DOMAIN_AIR:
		if (!bAttack)
		{
			bool bValid = false;

			if (pPlot->isFriendlyCity(*this, true))
			{
				bValid = true;

				if (m_pUnitInfo->getAirUnitCap() > 0)
				{
					if (GC.getGame().isOption(GAMEOPTION_SIZE_MATTERS))
					{
						if (pPlot->airUnitSpaceAvailable(getTeam()) < GC.getGame().getBaseAirUnitIncrementsbyCargoVolume())
						{
							bValid = false;
						}
					}
					else if (pPlot->airUnitSpaceAvailable(getTeam()) <= 0)
					{
						bValid = false;
					}
				}
			}

			if (!bValid && (bIgnoreLoad || !canLoad(pPlot)))
			{
				if (!bIgnoreAttack)
				{
					return false;
				}
				bFailWithoutAttack = true;
			}

			// Afforess - 03/7/10 - Rebase Limit
			if (!bFailWithoutAttack && !GET_TEAM(getTeam()).isRebaseAnywhere() && GC.getGame().isModderGameOption(MODDERGAMEOPTION_AIRLIFT_RANGE)
			&& plotDistance(pPlot->getX(), pPlot->getY(), getX(), getY()) > GC.getGame().getModderGameOption(MODDERGAMEOPTION_AIRLIFT_RANGE))
			{
				if (!bIgnoreAttack)
				{
					return false;
				}
				bFailWithoutAttack = true;
			}
		}
		break;

	case DOMAIN_LAND:

		if (pPlot->isWater() && !canMoveAllTerrain() && !pPlot->isCanMoveLandUnits())
		{
			if (!pPlot->isCity() || (pPlot->isCity() && 0 == GC.getLAND_UNITS_CAN_ATTACK_WATER_CITIES()))
			{
				if (bIgnoreLoad || !isHuman() || plot()->isWater() || !canLoad(pPlot))
				{
					return false;
				}
			}
		}
		if (isHominid())
		{
			if (pPlotArea->isBorderObstacle(pPlot->getTeam()))
			{
				if (plot()->getTeam() != pPlot->getTeam())
				{
					return false;
				}
			}
		}
		break;

	case DOMAIN_IMMOBILE:
		return false;
		break;

	default:
		FErrorMsg("error");
		break;
	}

	if (m_pUnitInfo->getPassableRouteNeeded(0) || m_pUnitInfo->getPassableRouteNeeded(1))
	{
		if (!(m_pUnitInfo->getPassableRouteNeeded(pPlot->getRouteType()) && pPlot->isRoute()))
		{
			return false;
		}
	}

	//ls612: For units that can't enter non-Owned Cities
	if (m_pUnitInfo->isNoNonOwnedEntry() && pPlot->isCity() && (pPlot->getOwner() != getOwner()))
	{
		return false;
	}

	if (isAnimal())
	{
		if (pPlot->isOwned() && !canAnimalIgnoresBorders())
		{
			return false;
		}

		if (pPlot->isOwned() && pPlot->getImprovementType() != NO_IMPROVEMENT && !canAnimalIgnoresImprovements())
		{
			return false;
		}

		if (pPlot->isCity(true) && !canAnimalIgnoresCities())
		{
			return false;
		}

		if (!bAttack && !bFailWithoutAttack)
		{
			if (pPlot->getBonusType() != NO_BONUS)
			{
				if ( !bIgnoreAttack )
				{
					return false;
				}
				else
				{
					bFailWithoutAttack = true;
				}
			}

			if (pPlot->getImprovementType() != NO_IMPROVEMENT)
			{
				if ( !bIgnoreAttack )
				{
					return false;
				}
				else
				{
					bFailWithoutAttack = true;
				}
			}

			if (pPlot->getNumUnits() > 0)
			{
				if ( !bIgnoreAttack )
				{
					return false;
				}
				else
				{
					bFailWithoutAttack = true;
				}
			}
		}
	}

	if (!bAttack && !bFailWithoutAttack)
	{
		if (isNoCapture() && !isBlendIntoCity() && !isSpy())
		{
			if (pPlot->isEnemyCity(*this))
			{
				if ( !bIgnoreAttack )
				{
					return false;
				}
				else
				{
					bFailWithoutAttack = true;
				}
			}
		}
	}
	// The following change makes it possible to capture defenseless units after having
	// made a previous attack or paradrop
	if (bAttack && isMadeAttack() && !isBlitz() && !bSuprise && bIsVisibleEnemyDefender)
	{
		if (!bIgnoreAttack || bFailWithoutAttack)
		{
			return false;
		}
		else
		{
			bFailWithAttack = true;
		}
	}

	bool bHasCheckedCityEntry = false;
	if (getDomainType() == DOMAIN_AIR)
	{
		if (bAttack && !bFailWithAttack && !canAirStrike(pPlot))
		{
			if (!bIgnoreAttack || bFailWithoutAttack)
			{
				return false;
			}
			else
			{
				bFailWithAttack = true;
			}
		}
	}
	else
	{
		if (canAttack())
		{
			if (!isHuman() || (pPlot->isVisible(getTeam(), false)))
			{
				if (bIgnoreAttack)
				{
					if (!bFailWithoutAttack && !bCanCoexist && bIsVisibleEnemyDefender
					&& (!bDeclareWar || (pPlot->isVisibleOtherUnit(getOwner()))))
					{
						if (bFailWithAttack)
						{
							return false;
						}
						bFailWithoutAttack = true;
					}
					if (!bFailWithAttack && !bIsVisibleEnemyDefender
					&& (!bDeclareWar || !pPlot->isVisibleOtherUnit(getOwner()) && !(pPlot->getPlotCity() && !isNoCapture() && !isBlendIntoCity())))
					{
						if (bFailWithoutAttack)
						{
							return false;
						}
						bFailWithAttack = true;
					}
				}
				//This part is to keep units that cannot capture a city from doing so. - one objective at least.
				else if ((bAttack || bIsVisibleEnemyDefender)
				&& bIsVisibleEnemyDefender != bAttack
				&& (!bDeclareWar || bIsVisibleEnemyDefender != bAttack && !(bAttack && pPlot->getPlotCity() && !isNoCapture())))
				{
					return false;//Searchforthis
				}
			}

			if (bAttack && !bFailWithAttack)
			{
				//City Minimum Defense Level
				if (!bIgnoreLocation && pPlot->getPlotCity() != NULL && !isSpy() && !isBlendIntoCity() && !(isBarbCoExist() && pPlot->isHominid())
				&& GET_TEAM(GET_PLAYER(getCombatOwner(pPlot->getTeam(),pPlot)).getTeam()).isAtWar(pPlot->getTeam()))
				{
					if (!pPlot->getPlotCity()->isDirectAttackable() && !canIgnoreNoEntryLevel())
					{
						return false;
					}
					bHasCheckedCityEntry = true;
				}
				CvUnit* pDefender = pPlot->getFirstDefender(NO_PLAYER, getOwner(), this, true);
				if (NULL != pDefender)
				{
					if (!canAttack(*pDefender))
					{
						if (!bIgnoreAttack || bFailWithoutAttack)
						{
							return false;
						}
						bFailWithAttack = true;
					}
					if (bCheckForBest)
					{
						*ppDefender = pPlot->getBestDefender(NO_PLAYER, getOwner(), this, true, false, false, bAssassinate);
					}
				}
			}
		}
		else
		{
			if (bAttack && !bFailWithAttack)
			{
				if (!bIgnoreAttack || bFailWithoutAttack)
				{
					return false;
				}
				bFailWithAttack = true;
			}

			if (!bCanCoexist && bIsVisibleEnemyDefender && (!isHuman() || pPlot->isVisible(getTeam(), false)))
			{
				return false;
			}
		}

		if (isHuman())
		{
			ePlotTeam = pPlot->getRevealedTeam(getTeam(), false);
			bCanEnterArea = canEnterArea(ePlotTeam, pPlotArea);
		}

		if (!bCanEnterArea)
		{
			FAssert(ePlotTeam != NO_TEAM);

			if (!GET_TEAM(getTeam()).canDeclareWar(ePlotTeam))
			{
				return false;
			}

			if (isHuman())
			{
				if (!bDeclareWar)
				{
					return false;
				}
			}
			else if (!GET_TEAM(getTeam()).AI_isSneakAttackReady(ePlotTeam) || !getGroup()->AI_isDeclareWar(pPlot))
			{
				return false;
			}
		}
	}

	bool bValid = false;
	if (pPlot->isImpassable(getTeam()))
	{
		//Check our current tile
		if (plot()->isAsPeak())
		{
			//	Can this unit move through peaks regardless?
			if (isCanMovePeaks())
			{
				bValid = true;
			}
			else
			{
				//	If not we need a peak leader to be present
				bValid = plot()->getHasMountainLeader(getTeam());
			}
		}
		//Check the impassible tile
		if (!bValid)
		{
			if (pPlot->isAsPeak())
			{
				// Can this unit move through peaks regardless?
				if (isCanMovePeaks())
				{
					bValid = true;
				}
				else
				{
					// If not we need a peak leader to be present
					bValid = pPlot->getHasMountainLeader(getTeam());
				}
			}
			if (!bValid && !canMoveImpassable())
			{
				return false;
			}
		}
	}

	if (GC.getGame().getModderGameOption(MODDERGAMEOPTION_MAX_UNITS_PER_TILES) > 0)
	{
		if (!bIgnoreTileLimit)
		{
			if (!getUnitInfo().isOnlyDefensive() && baseCombatStr() > 0)
			{
				if (getDomainType() == DOMAIN_LAND && !pPlot->isWater() || getDomainType() == DOMAIN_SEA && pPlot->isWater() || getDomainType() == DOMAIN_AIR)
				{
					int iCount = 0;

					//Check our current tile
					foreach_(const CvUnit* pLoopUnit, pPlot->units())
					{
						if (pLoopUnit->getTeam() == getTeam())
						{
							//Ignore workers, Missionaries, etc...
							if (!pLoopUnit->getUnitInfo().isOnlyDefensive() && pLoopUnit->baseCombatStr() > 0)
							{
								//No counting cargo for ships, or harbors
								if (pLoopUnit->getDomainType() == getDomainType())
								{
									iCount++;
								}
							}
						}
					}//Unit is already on the tile, ignore it in the count
					if (bIgnoreLocation)
					{
						iCount--;
					}
					if (GC.getGame().getModderGameOption(MODDERGAMEOPTION_MAX_UNITS_PER_TILES) <= iCount)
					{
						return false;
					}
				}
			}
		}
	}

	if (!bIgnoreLocation && GC.getGame().isOption(GAMEOPTION_ZONE_OF_CONTROL))
	{
		//	ZoC don't apply into cities of the unit owner
		if (pPlot->getPlotCity() == NULL || pPlot->getPlotCity()->getTeam() != getTeam())
		{
			// Fort ZoC
			const PlayerTypes eDefender = plot()->controlsAdjacentZOCSource(getTeam());
			if (eDefender != NO_PLAYER)
			{
				const CvPlot* pZoneOfControl = plot()->isInFortControl(true, eDefender, getOwner());
				const CvPlot* pForwardZoneOfControl = pPlot->isInFortControl(true, eDefender, getOwner());
				if (pZoneOfControl != NULL && pForwardZoneOfControl != NULL && !canIgnoreZoneofControl()
				&& pZoneOfControl == pPlot->isInFortControl(true, eDefender, getOwner(), pZoneOfControl))
				{
					return false;
				}
			}
			// City ZoC
			if (plot()->isInCityZoneOfControl(getOwner()) && pPlot->isInCityZoneOfControl(getOwner()) && !canIgnoreZoneofControl())
			{
				return false;
			}
		}
		// Promotion ZoC
		if (GC.getGame().isAnyoneHasUnitZoneOfControl() && !canIgnoreZoneofControl()
		&& plot()->isInUnitZoneOfControl(getOwner()) && pPlot->isInUnitZoneOfControl(getOwner()))
		{
			return false;
		}
	}
	//City Minimum Defense Level
	if (!bHasCheckedCityEntry && !bIgnoreLocation && pPlot->getPlotCity() != NULL && !isSpy()
	&& !isBlendIntoCity() && (!isBarbCoExist() || !pPlot->isHominid())
	&& GET_TEAM(GET_PLAYER(getCombatOwner(pPlot->getTeam(), pPlot)).getTeam()).isAtWar(pPlot->getTeam())
	&& !pPlot->getPlotCity()->isDirectAttackable() && !canIgnoreNoEntryLevel())
	{
		return false;
	}
	return true;
}

bool CvUnit::canMoveOrAttackInto(const CvPlot* pPlot, bool bDeclareWar) const
{
	const bool ignoreLocation = stepDistance(pPlot->getX(), pPlot->getY(), getX(), getY()) != 1;
	return canMoveInto(pPlot,
		(bDeclareWar ? MoveCheck::DeclareWar : MoveCheck::None) |
		(ignoreLocation ? MoveCheck::IgnoreLocation : MoveCheck::None) |
		MoveCheck::IgnoreAttack
	);
}

bool CvUnit::canMoveThrough(const CvPlot* pPlot, bool bDeclareWar) const
{
	return canMoveInto(pPlot, (bDeclareWar ? MoveCheck::DeclareWar : MoveCheck::None) | MoveCheck::IgnoreLoad);
}

void CvUnit::attack(CvPlot* pPlot, bool bQuick, bool bStealth, bool bNoCache)
{
	PROFILE_FUNC();
	FAssert(plot() == pPlot || bStealth || bNoCache || canMoveInto(pPlot, MoveCheck::Attack));
	FAssert(getCombatTimer() == 0);

	m_combatResult.iTurnCount = 0;

	//TB Combat Mods begin
	pPlot->doPreAttackTraps(this);

	if (!isDead() && !isDelayedDeath())
	{
		if (!pPlot->hasDefender(false, NO_PLAYER, getOwner(), this, true, false, false, true) && pPlot->hasStealthDefender(this))
		{
			pPlot->revealBestStealthDefender(this);
			attack(pPlot, true, true);
		}
#ifdef STRENGTH_IN_NUMBERS
		CvPlot* aPlot = plot();
		if (GC.getGame().isOption(GAMEOPTION_STRENGTH_IN_NUMBERS))
		{
			setAttackFromPlot(aPlot);
		}
#endif // STRENGTH_IN_NUMBERS
		//TB Combat Mods end
		setAttackPlot(pPlot, false);

		FAssertMsg(pPlot != plot(), "We are passing in false for bSamePlot so why are we on the same plot? (This is here to confirm if the bSamePlot parameter actually means what it says or not, we might remove the parameter or rename it if the assert is hit)");
		updateCombat(bQuick, 0, false, bStealth, bNoCache);
	}
}

void CvUnit::fightInterceptor(const CvPlot* pPlot, bool bQuick)
{
	FAssert(getCombatTimer() == 0);

	setAttackPlot(pPlot, true);

	updateAirCombat(bQuick);
}

void CvUnit::attackForDamage(CvUnit *pDefender, int attackerDamageChange, int defenderDamageChange)
{
	FAssert(getCombatTimer() == 0);
	FAssert(!isFighting());

	if(pDefender == NULL)
	{
		FErrorMsg("Defender cannot be NULL");
		return;
	}

	setAttackPlot(pDefender->plot(), false);

	CvPlot* pPlot = getAttackPlot();
	if (pPlot == NULL)
	{
		FErrorMsg("Plot was NULL");
		return;
	}

	//rotate to face plot
	DirectionTypes newDirection = estimateDirection(this->plot(), pDefender->plot());
	if(newDirection != NO_DIRECTION)
	{
		setFacingDirection(newDirection);
	}

	//rotate enemy to face us
	newDirection = estimateDirection(pDefender->plot(), this->plot());
	if(newDirection != NO_DIRECTION)
	{
		pDefender->setFacingDirection(newDirection);
	}

	//check if quick combat
	bool bVisible = isCombatVisible(pDefender);

	//if not finished and not fighting yet, set up combat damage and mission
	if (!isFighting())
	{
		if (plot()->isFighting() || pPlot->isFighting())
		{
			return;
		}


		bool bStealthAttack = false;
		if (isInvisible(GET_PLAYER(pDefender->getOwner()).getTeam(), false, false) || pDefender->plot() == plot())
		{
			bStealthAttack = true;
		}
		bool bStealthDefense = false;
		if (bStealthAttack)
		{
			if (!isInvisible(GET_PLAYER(pDefender->getOwner()).getTeam(), false, false) && pDefender->plot() == plot())
			{
				bStealthDefense = true;
			}
		}
		setCombatUnit(pDefender, true, bStealthAttack, bStealthDefense);
		pDefender->setCombatUnit(this, false, bStealthAttack, bStealthDefense);

		pDefender->getGroup()->clearMissionQueue();

		bool bFocused = (bVisible && isCombatFocus() && gDLL->getInterfaceIFace()->isCombatFocus() && plot()->isInViewport() && pDefender->isInViewport());

		if (bFocused)
		{
			DirectionTypes directionType = directionXY(plot(), pPlot);
			//								N			NE				E				SE					S				SW					W				NW
			NiPoint2 directions[8] = {NiPoint2(0, 1), NiPoint2(1, 1), NiPoint2(1, 0), NiPoint2(1, -1), NiPoint2(0, -1), NiPoint2(-1, -1), NiPoint2(-1, 0), NiPoint2(-1, 1)};
			NiPoint3 attackDirection = NiPoint3(directions[directionType].x, directions[directionType].y, 0);
			float plotSize = GC.getPLOT_SIZE();
			NiPoint3 lookAtPoint(plot()->getPoint().x + plotSize / 2 * attackDirection.x, plot()->getPoint().y + plotSize / 2 * attackDirection.y, (plot()->getPoint().z + pPlot->getPoint().z) / 2);
			attackDirection.Unitize();
			gDLL->getInterfaceIFace()->lookAt(lookAtPoint, (((getOwner() != GC.getGame().getActivePlayer()) || gDLL->getGraphicOption(GRAPHICOPTION_NO_COMBAT_ZOOM)) ? CAMERALOOKAT_BATTLE : CAMERALOOKAT_BATTLE_ZOOM_IN), attackDirection);
		}
		else
		{

			PlayerTypes eAttacker = getVisualOwner(pDefender->getTeam());
			CvWString szMessage;
			if (BARBARIAN_PLAYER != eAttacker)
			{
				szMessage = gDLL->getText("TXT_KEY_MISC_YOU_UNITS_UNDER_ATTACK", GET_PLAYER(getOwner()).getNameKey());
			}
			else
			{
				szMessage = gDLL->getText("TXT_KEY_MISC_YOU_UNITS_UNDER_ATTACK_UNKNOWN");
			}

			AddDLLMessage(pDefender->getOwner(), true, GC.getEVENT_MESSAGE_TIME(), szMessage, "AS2D_COMBAT", MESSAGE_TYPE_DISPLAY_ONLY, getButton(), GC.getCOLOR_RED(), pPlot->getX(), pPlot->getY(), true);
		}
	}
	FAssertMsg(plot()->isFighting(), "Current unit instance plot is not fighting as expected");
	FAssertMsg(pPlot->isFighting(), "pPlot is not fighting as expected");

	//setup battle object
	CvBattleDefinition kBattle(pPlot, this, pDefender);

	changeDamage(attackerDamageChange, pDefender->getOwner());
	//TB Combat Mod begin
	if (pDefender->dealsColdDamage())
	{
		changeColdDamage(attackerDamageChange);
	}
	//TB Combat Mod end
	pDefender->changeDamage(defenderDamageChange, getOwner());
	//TB Combat Mod begin
	if (dealsColdDamage())
	{
		pDefender->changeColdDamage(defenderDamageChange);
	}
	//TB Combat Mod end

	if (bVisible)
	{
		kBattle.setDamage(BATTLE_UNIT_ATTACKER, BATTLE_TIME_END, getDamage());
		kBattle.setDamage(BATTLE_UNIT_DEFENDER, BATTLE_TIME_END, pDefender->getDamage());
		kBattle.setAdvanceSquare(canAdvance(pPlot, pDefender->isDead() ? 0 : 1));

		kBattle.addDamage(BATTLE_UNIT_ATTACKER, BATTLE_TIME_RANGED, kBattle.getDamage(BATTLE_UNIT_ATTACKER, BATTLE_TIME_BEGIN));
		kBattle.addDamage(BATTLE_UNIT_DEFENDER, BATTLE_TIME_RANGED, kBattle.getDamage(BATTLE_UNIT_DEFENDER, BATTLE_TIME_BEGIN));

		int iTurns = planBattle( kBattle);
		kBattle.setMissionTime(iTurns * gDLL->getSecsPerTurn());
		setCombatTimer(iTurns);

		GC.getGame().incrementTurnTimer(getCombatTimer());

		if (pPlot->isActiveVisible(false) && !pDefender->isUsingDummyEntities())
		{
			ExecuteMove(0.5f, true);
			addMission(kBattle);
		}
	}
	else
	{
		setCombatTimer(1);
	}
}


void CvUnit::move(CvPlot* pPlot, bool bShow)
{
	PROFILE_FUNC();

	FAssert(canMoveOrAttackInto(pPlot) || isMadeAttack());

	CvPlot* pOldPlot = plot();

	changeMoves(pPlot->movementCost(this, pOldPlot));

	//GC.getGame().logOOSSpecial(16, getID(), pPlot->getX(), pPlot->getY());
	setXY(pPlot->getX(), pPlot->getY(), true, true, bShow && pPlot->isVisibleToWatchingHuman(), bShow);
	if (isDead())
	{
		return;
	}
	//TBFIXHERE it's very possible for the unit to be dead from this point and there are further move aspects taking place such as the python reporting which may include more than python
	//change feature
	const FeatureTypes featureType = pPlot->getFeatureType();
	if(featureType != NO_FEATURE)
	{
		const CvString featureString(GC.getFeatureInfo(featureType).getOnUnitChangeTo());
		if(!featureString.IsEmpty())
		{
			FeatureTypes newFeatureType = (FeatureTypes) GC.getInfoTypeForString(featureString);
			pPlot->setFeatureType(newFeatureType);
		}
	}

	if (getOwner() == GC.getGame().getActivePlayer())
	{
		if (!(pPlot->isOwned()))
		{
			//spawn birds if trees present - JW
			if (featureType != NO_FEATURE)
			{
				if (GC.getASyncRand().get(100) < GC.getFeatureInfo(featureType).getEffectProbability())
				{
					EffectTypes eEffect = (EffectTypes)GC.getInfoTypeForString(GC.getFeatureInfo(featureType).getEffectType());
					gDLL->getEngineIFace()->TriggerEffect(eEffect, pPlot->getPoint(), (float)(GC.getASyncRand().get(360)));
					gDLL->getInterfaceIFace()->playGeneralSound("AS3D_UN_BIRDS_SCATTER", pPlot->getPoint());
				}
			}
		}
	}

	CvEventReporter::getInstance().unitMove(pPlot, this, pOldPlot);
}

// false if unit is killed
bool CvUnit::jumpToNearestValidPlot(bool bKill)
{
	FAssertMsg(!isAttacking(), "isAttacking did not return false as expected");
	FAssertMsg(!isFighting(), "isFighting did not return false as expected");

	//	If the jump is due to being in an incorrect doamin it implies there WILL be an area change, so the relevant nearest
	//	city cannot possibly be in the same area, hence we need to search all
	CvCity* pNearestCity = GC.getMap().findCity(getX(), getY(), getOwner(), NO_TEAM, plot()->isValidDomainForAction(*this));

	int iBestValue = MAX_INT;
	CvPlot* pBestPlot = NULL;

	for (int iI = 0; iI < GC.getMap().numPlots(); iI++)
	{
		CvPlot* pLoopPlot = GC.getMap().plotByIndex(iI);

		if (pLoopPlot->isValidDomainForLocation(*this))
		{
			if (canMoveInto(pLoopPlot))
			{
				if (canEnterArea(pLoopPlot->getTeam(), pLoopPlot->area()) && !isEnemy(pLoopPlot->getTeam(), pLoopPlot))
				{
					FAssertMsg(!atPlot(pLoopPlot), "atPlot(pLoopPlot) did not return false as expected");

					if ((getDomainType() != DOMAIN_AIR) || pLoopPlot->isFriendlyCity(*this, true))
					{
						if (pLoopPlot->isRevealed(getTeam(), false))
						{
							int iValue = (plotDistance(getX(), getY(), pLoopPlot->getX(), pLoopPlot->getY()) * 2);

							if (pNearestCity != NULL)
							{
								iValue += plotDistance(pLoopPlot->getX(), pLoopPlot->getY(), pNearestCity->getX(), pNearestCity->getY());

								//	Try to at least favour the same landmass as the nearest city
								if (pLoopPlot->area() != pNearestCity->area())
								{
									iValue *= 3;
								}
							}

							if (getDomainType() == DOMAIN_SEA && !plot()->isWater())
							{
								if (!pLoopPlot->isWater() || !pLoopPlot->isAdjacentToArea(area()))
								{
									iValue *= 3;
								}
							}
							else
							{
								if (pLoopPlot->area() != area())
								{
									iValue *= 3;
								}
							}
							iValue *= std::max(1, ((pLoopPlot->getTotalTurnDamage(this)) / 2));

							if (iValue < iBestValue)
							{
								iBestValue = iValue;
								pBestPlot = pLoopPlot;
							}
						}
					}
				}
			}
		}
	}

	if (pBestPlot != NULL)
	{
		//GC.getGame().logOOSSpecial(17, getID(), pBestPlot->getX(), pBestPlot->getY());
		setXY(pBestPlot->getX(), pBestPlot->getY());
		return true;
	}

	if (bKill)
	{
		kill(false);
	}
	return false;
}


bool CvUnit::canAutomate(AutomateTypes eAutomate) const
{
	if (eAutomate == NO_AUTOMATE)
	{
		return false;
	}

	if (!isGroupHead())
	{
		return false;
	}
	/************************************************************************************************/
	/* Afforess	                  Start		 02/14/10                                               */
	/*                                                                                              */
	/*  Clicking on the Automate button with an Inquisitor causes a CTD                             */
	/************************************************************************************************/
	if (m_pUnitInfo->isInquisitor())
	{
		return false;
	}
	/************************************************************************************************/
	/* Afforess	                     END                                                            */
	/************************************************************************************************/

	switch (eAutomate)
	{
	case AUTOMATE_BUILD:
		if ((AI_getUnitAIType() != UNITAI_WORKER) && (AI_getUnitAIType() != UNITAI_WORKER_SEA))
		{
			return false;
		}
		break;

	case AUTOMATE_NETWORK:
		if ((AI_getUnitAIType() != UNITAI_WORKER) || !canBuildRoute())
		{
			return false;
		}
		break;

	case AUTOMATE_CITY:
		if (AI_getUnitAIType() != UNITAI_WORKER)
		{
			return false;
		}
		break;

	case AUTOMATE_EXPLORE:
		/************************************************************************************************/
		/* BETTER_BTS_AI_MOD                      04/25/10                                jdog5000      */
		/*                                                                                              */
		/* Player Interface                                                                             */
		/************************************************************************************************/
		if (!canFight())
		{
			// Enable exploration for air units
			if (getDomainType() != DOMAIN_SEA && getDomainType() != DOMAIN_AIR)
			{
				if (!alwaysInvisible() || !isSpy())
				{
					return false;
				}
			}
		}

		if (getDomainType() == DOMAIN_IMMOBILE)
		{
			return false;
		}

		if (getDomainType() == DOMAIN_AIR && !canRecon())
		{
			return false;
		}

		if (GET_PLAYER(getOwner()).isModderOption(MODDEROPTION_HIDE_AUTO_EXPLORE))
		{
			return false;
		}
		/************************************************************************************************/
		/* BETTER_BTS_AI_MOD                       END                                                  */
		/************************************************************************************************/

		break;

	case AUTOMATE_RELIGION:
		if (AI_getUnitAIType() != UNITAI_MISSIONARY)
		{
			return false;
		}
		/************************************************************************************************/
		/* Afforess	                  Start		 09/16/10                                               */
		/*                                                                                              */
		/* Advanced Automations                                                                         */
		/************************************************************************************************/
		if (GET_PLAYER(getOwner()).isModderOption(MODDEROPTION_HIDE_AUTO_SPREAD))
		{
			return false;
		}
		break;

	case AUTOMATE_PILLAGE:
		if (!getUnitInfo().isPillage())
		{
			return false;
		}
		if (GET_PLAYER(getOwner()).isModderOption(MODDEROPTION_HIDE_AUTO_PILLAGE))
		{
			return false;
		}
		break;
	case AUTOMATE_HUNT:
		if (GET_PLAYER(getOwner()).isModderOption(MODDEROPTION_HIDE_AUTO_HUNT))
		{
			return false;
		}
		if (!canAttack())
		{
			return false;
		}
		break;
	case AUTOMATE_CITY_DEFENSE:
		if (GET_PLAYER(getOwner()).isModderOption(MODDEROPTION_HIDE_AUTO_DEFENSE))
		{
			return false;
		}
		if (!canAttack())
		{
			return false;
		}
		break;
	case AUTOMATE_BORDER_PATROL:
		if (GET_PLAYER(getOwner()).isModderOption(MODDEROPTION_HIDE_AUTO_PATROL))
		{
			return false;
		}
		if (!canAttack())
		{
			return false;
		}
		break;
	case AUTOMATE_PIRATE:
		if (GET_PLAYER(getOwner()).isModderOption(MODDEROPTION_HIDE_AUTO_PIRATE))
		{
			return false;
		}
		if (getDomainType() != DOMAIN_SEA)
		{
			return false;
		}
		if (!canAttack())
		{
			return false;
		}
		if (!isHiddenNationality() || !m_pUnitInfo->isAlwaysHostile())
		{
			return false;
		}
		break;
	case AUTOMATE_HURRY:
		if (GET_PLAYER(getOwner()).isModderOption(MODDEROPTION_HIDE_AUTO_CARAVAN))
		{
			return false;
		}
		if (m_pUnitInfo->getBaseHurry() <= 0)
		{
			return false;
		}
		//Do not give ability to great people
		if (m_pUnitInfo->getProductionCost() < 0)
		{
			return false;
		}
		break;
	case AUTOMATE_AIRSTRIKE:
		if (GET_PLAYER(getOwner()).isModderOption(MODDEROPTION_HIDE_AUTO_AIR))
		{
			return false;
		}
		if (getDomainType() != DOMAIN_AIR)
		{
			return false;
		}
		if (!canAirAttack())
		{
			return false;
		}
		//Jets and Fighters can intercept, modders, if you have fighters with 0 interception, feel free to get rid of this check
		if (m_pUnitInfo->getInterceptionProbability() <= 0)
		{
			return false;
		}
		break;
	case AUTOMATE_AIRBOMB:
		if (GET_PLAYER(getOwner()).isModderOption(MODDEROPTION_HIDE_AUTO_AIR))
		{
			return false;
		}
		if (getDomainType() != DOMAIN_AIR)
		{
			return false;
		}

		if (getAirBombBaseRate() == 0)
		{
			return false;
		}

		if (canAutomate(AUTOMATE_AIRSTRIKE))
		{
			return false;
		}
	case AUTOMATE_AIR_RECON:
		if (!canRecon())
		{
			return false;
		}
		break;
	case AUTOMATE_UPGRADING:
		if (m_pUnitInfo->getNumUnitUpgrades() == 0)
		{
			return false;
		}
		if (isAutoUpgrading())
		{
			return false;
		}
		if (GET_PLAYER(getOwner()).isModderOption(MODDEROPTION_HIDE_AUTO_UPGRADE))
		{
			return false;
		}
		break;
	case AUTOMATE_CANCEL_UPGRADING:
		if (m_pUnitInfo->getNumUnitUpgrades() == 0)
		{
			return false;
		}
		if (!isAutoUpgrading())
		{
			return false;
		}
		break;
	case AUTOMATE_PROMOTIONS:
		if (GET_PLAYER(getOwner()).isModderOption(MODDEROPTION_HIDE_AUTO_PROMOTE))
		{
			return false;
		}
		if (!canAcquirePromotionAny())
		{
			return false;
		}
		if (isAutoPromoting())
		{
			return false;
		}
		break;
	case AUTOMATE_CANCEL_PROMOTIONS:
		if (!canAcquirePromotionAny())
		{
			return false;
		}
		if (!isAutoPromoting())
		{
			return false;
		}
		break;
	case AUTOMATE_SHADOW:
		if (!canShadow())
		{
			return false;
		}
		if (GET_PLAYER(getOwner()).isModderOption(MODDEROPTION_HIDE_AUTO_PROTECT))
		{
			return false;
		}
		break;
/************************************************************************************************/
/* Afforess	                     END                                                            */
/************************************************************************************************/
	default:
		FErrorMsg("error");
		break;
	}

	return true;
}


void CvUnit::automate(AutomateTypes eAutomate)
{
	if (!canAutomate(eAutomate))
	{
		return;
	}
/************************************************************************************************/
/* Afforess	                  Start		 08/20/10                                               */
/*                                                                                              */
/* Advanced Automations                                                                         */
/************************************************************************************************/
	if (eAutomate == AUTOMATE_UPGRADING || eAutomate == AUTOMATE_CANCEL_UPGRADING)
	{
		foreach_(CvUnit* pLoopUnit, getGroup()->units())
		{
			pLoopUnit->setAutoUpgrading((eAutomate == AUTOMATE_UPGRADING));
		}
		if (IsSelected())
		{
			gDLL->getInterfaceIFace()->setDirty(SelectionButtons_DIRTY_BIT, true);
		}
		return;
	}
	if (eAutomate == AUTOMATE_PROMOTIONS || eAutomate == AUTOMATE_CANCEL_PROMOTIONS)
	{
		foreach_(CvUnit* pLoopUnit, getGroup()->units())
		{
			pLoopUnit->setAutoPromoting((eAutomate == AUTOMATE_PROMOTIONS));
		}
		if (IsSelected())
		{
			gDLL->getInterfaceIFace()->setDirty(SelectionButtons_DIRTY_BIT, true);
		}
		return;
	}
/************************************************************************************************/
/* Afforess	                     END                                                            */
/************************************************************************************************/
	getGroup()->setAutomateType(eAutomate);
}


bool CvUnit::canScrap() const
{
	if (plot()->isFighting())
	{
		return false;
	}

	return true;
}


// No need to let return value exceed MAX_INT, shouldn't really happen unless one of the most expensive units is merged many times.
int CvUnit::calculateScrapValue() const
{
	int64_t iCost = getUnitInfo().getProductionCost() * GC.getGameSpeedInfo(GC.getGame().getGameSpeedType()).getHammerCostPercent();

	if (GC.getGame().isOption(GAMEOPTION_SIZE_MATTERS))
	{
		const int iGroupDiff = groupRank() - m_pUnitInfo->getBaseGroupRank();
		if (iGroupDiff != 0)
		{
			if (iGroupDiff > 0)
			{
				iCost *= intPow64(3, iGroupDiff);
			}
			else iCost /= intPow64(3, -iGroupDiff);
		}
	}
	iCost /= 100*GC.getUNIT_GOLD_DISBAND_DIVISOR();

	if (iCost > MAX_INT) return MAX_INT;
	// A minimum return of 1 will cause oddities in early game where a unit that can split only gives 1 gold,
	//	giving the player a reason to split before disbanding to earn a couple extra gold coins.
	if (iCost < 1) return 0;

	return static_cast<int>(iCost);
}

void CvUnit::scrap()
{
	if (!canScrap())
	{
		return;
	}

	if (gUnitLogLevel > 2)
	{
		CvWString szString;
		getUnitAIString(szString, AI_getUnitAIType());
		logBBAI("    %S scraps %S (%d) with %S", GET_PLAYER(getOwner()).getCivilizationDescription(0), getName(0).GetCString(), getID(), szString.GetCString());
	}

	if (GC.getGame().isOption(GAMEOPTION_DOWNSIZING_IS_PROFITABLE) && plot()->getOwner() == getOwner())
	{
		GET_PLAYER(getOwner()).changeGold(calculateScrapValue());
	}

	getGroup()->AI_setMissionAI(MISSIONAI_DELIBERATE_KILL, NULL, NULL);
	kill(true, NO_PLAYER, true);
}


bool CvUnit::canGift(bool bTestVisible, bool bTestTransport) const
{
	const CvPlot* pPlot = plot();

	if (!(pPlot->isOwned()))
	{
		return false;
	}

	if (pPlot->getOwner() == getOwner())
	{
		return false;
	}

	if (pPlot->isVisibleEnemyUnit(this))
	{
		return false;
	}

	if (pPlot->isVisibleEnemyUnit(pPlot->getOwner()))
	{
		return false;
	}
	const CvUnit* pTransport = getTransportUnit();

	if (!pPlot->isValidDomainForLocation(*this) && NULL == pTransport)
	{
		return false;
	}

	for (int iCorp = 0; iCorp < GC.getNumCorporationInfos(); ++iCorp)
	{
		if (m_pUnitInfo->getCorporationSpreads(iCorp) > 0)
		{
			return false;
		}
	}

	if (bTestTransport)
	{
		if (pTransport && pTransport->getTeam() != pPlot->getTeam())
		{
			return false;
		}
	}

	if (!bTestVisible)
	{
		if (GET_TEAM(pPlot->getTeam()).isUnitMaxedOut(getUnitType(), GET_TEAM(pPlot->getTeam()).getUnitMaking(getUnitType()))
		|| GET_PLAYER(pPlot->getOwner()).isUnitMaxedOut(getUnitType(), GET_PLAYER(pPlot->getOwner()).getUnitMaking(getUnitType())))
		{
			return false;
		}
		if (!(GET_PLAYER(pPlot->getOwner()).AI_acceptUnit(this)))
		{
			return false;
		}
	}
	return !atWar(pPlot->getTeam(), getTeam());
}


void CvUnit::gift(bool bTestTransport)
{
	if (!canGift(false, bTestTransport))
	{
		return;
	}
	std::vector<CvUnit*> aCargoUnits;
	getCargoUnits(aCargoUnits);
	if (!aCargoUnits.empty())
	{
		validateCargoUnits();
	}
	algo::for_each(aCargoUnits, bind(CvUnit::gift, _1, false));

	const PlayerTypes eNewOwner = plot()->getOwner();

	FAssertMsg(eNewOwner != NO_PLAYER, "plot()->getOwner() is not expected to be equal with NO_PLAYER");

	CvUnit* pGiftUnit = GET_PLAYER(eNewOwner).initUnit(getUnitType(), getX(), getY(), AI_getUnitAIType(), NO_DIRECTION, GC.getGame().getSorenRandNum(10000, "AI Unit Birthmark"));
	if (pGiftUnit == NULL)
	{
		FErrorMsg("GiftUnit is not assigned a valid value");
		return;
	}
	const PlayerTypes eOldOwner = getOwner();

	pGiftUnit->convert(this);

	if (pGiftUnit->isCombat())
	{
		GET_PLAYER(eNewOwner).AI_changePeacetimeGrantValue(eOldOwner, (pGiftUnit->getUnitInfo().getProductionCost() * 3 * GC.getGame().AI_combatValue(pGiftUnit->getUnitType()))/100);
	}
	else GET_PLAYER(eNewOwner).AI_changePeacetimeGrantValue(eOldOwner, (pGiftUnit->getUnitInfo().getProductionCost()));

	if (pGiftUnit->isHuman())
	{
		AddDLLMessage(
			eNewOwner, false, GC.getEVENT_MESSAGE_TIME(),
			gDLL->getText("TXT_KEY_MISC_GIFTED_UNIT_TO_YOU", GET_PLAYER(eOldOwner).getNameKey(), pGiftUnit->getNameKey()),
			"AS2D_UNITGIFTED", MESSAGE_TYPE_INFO, pGiftUnit->getButton(), GC.getCOLOR_WHITE(), pGiftUnit->getX(), pGiftUnit->getY(), true, true
		);
	}
	// Python Event
	CvEventReporter::getInstance().unitGifted(pGiftUnit, eOldOwner, plot());
}


bool CvUnit::canLoadOntoUnit(const CvUnit* pUnit, const CvPlot* pPlot) const
{
	FAssert(pUnit != NULL);
	FAssert(pPlot != NULL);

	if (pUnit == this)
	{
		return false;
	}

	if (!pUnit->isCarrier())
	{
		return false;
	}

	if (isArmedTrap())
	{
		return false;
	}

	if (pUnit->getUnitType() == getUnitType())
	{
		return false;
	}
/*	if (GC.getGame().isOption(GAMEOPTION_SIZE_MATTERS))
	{
		if (pUnit->getTeam() == getTeam())
		{
			if (!pUnit->isHuman() || !isHuman())
			{
				return false;
			}
		}
		else
		{
			return false;
		}
	}
	else */if (pUnit->getTeam() != getTeam())
	{
		return false;
	}

/************************************************************************************************/
/* UNOFFICIAL_PATCH                       06/23/10                     Mongoose & jdog5000      */
/*                                                                                              */
/* Bugfix                                                                                       */
/************************************************************************************************/
	// From Mongoose SDK
	if (getTransportUnit() == pUnit || pUnit->getTransportUnit() == this)
	{
		return false;
	}
/************************************************************************************************/
/* UNOFFICIAL_PATCH                        END                                                  */
/************************************************************************************************/
	if (GC.getGame().isOption(GAMEOPTION_SIZE_MATTERS))
	{
		if (pUnit->SMcargoSpaceAvailable(getSpecialUnitType(), getDomainType()) < SMCargoVolume()
			|| pUnit->SMcargoSpaceAvailable(getSpecialUnitType(), getDomainType()) <= 0)
		{
			return false;
		}
	}
	else
	{
		if (pUnit->cargoSpaceAvailable(getSpecialUnitType(), getDomainType()) <= 0)
		{
			return false;
		}
	}

	//Not a good rule for C2C - would keep units carrying from being able to load
	//if (pUnit->isCargo())
	//{
	//	return false;
	//}

	if (!(pUnit->atPlot(pPlot)))
	{
		return false;
	}

	//Not a helpful rule for C2C
	//if (!m_pUnitInfo->isHiddenNationality() && pUnit->getUnitInfo().isHiddenNationality())
	//{
	//	return false;
	//}

	if (NO_SPECIALUNIT != getSpecialUnitType())
	{
		if (GC.getSpecialUnitInfo(getSpecialUnitType()).isCityLoad())
		{
			if (!pPlot->isCity(true, getTeam()))
			{
				return false;
			}
		}
	}

	return true;
}


void CvUnit::loadOntoUnit(CvUnit* pUnit)
{
	if (!canLoadOntoUnit(pUnit, plot()))
	{
		return;
	}

	setTransportUnit(pUnit);
}

bool CvUnit::shouldLoadOnMove(const CvPlot* pPlot) const
{
	if (isCargo())
	{
		return false;
	}

	switch (getDomainType())
	{
	case DOMAIN_LAND:
/************************************************************************************************/
/* UNOFFICIAL_PATCH                       10/30/09                     Mongoose & jdog5000      */
/*                                                                                              */
/* Bugfix                                                                                       */
/************************************************************************************************/
/* original bts code
		if (pPlot->isWater())
*/
		// From Mongoose SDK
/************************************************************************************************/
/* Afforess	                  Start		 08/18/10                                               */
/*                                                                                              */
/*                                                                                              */
/************************************************************************************************/
/*
		if (pPlot->isWater() && !canMoveAllTerrain())
*/
		if ((pPlot->isWater() && !canMoveAllTerrain()) && !pPlot->isCanMoveLandUnits())
/************************************************************************************************/
/* Afforess	                     END                                                            */
/************************************************************************************************/
		{
			return true;
		}
/************************************************************************************************/
/* UNOFFICIAL_PATCH                        END                                                  */
/************************************************************************************************/
		break;
	case DOMAIN_AIR:
		if (!pPlot->isFriendlyCity(*this, true))
		{
			return true;
		}

		if (m_pUnitInfo->getAirUnitCap() > 0)
		{
			if (GC.getGame().isOption(GAMEOPTION_SIZE_MATTERS))
			{
				if (pPlot->airUnitSpaceAvailable(getTeam()) < getCargoVolume())
				{
					return true;
				}
			}
			else if (pPlot->airUnitSpaceAvailable(getTeam()) <= 0)
			{
				return true;
			}
		}
		break;
	default:
		break;
	}

	if (algo::any_of_equal(m_pUnitInfo->getImpassableTerrains(), pPlot->getTerrainType()))
	{
		const TechTypes eTech = (TechTypes)m_pUnitInfo->getTerrainPassableTech(pPlot->getTerrainType());
		if (NO_TECH == eTech || !GET_TEAM(getTeam()).isHasTech(eTech))
		{
			return true;
		}
	}

	return false;
}


bool CvUnit::canLoad(const CvPlot* pPlot) const
{
	PROFILE_FUNC();

	FAssert(pPlot != NULL);

	foreach_(const CvUnit* pLoopUnit, pPlot->units())
	{
		if (canLoadOntoUnit(pLoopUnit, pPlot))
		{
			return true;
		}
	}

	return false;
}


void CvUnit::load()
{
	if (!canLoad(plot()))
	{
		return;
	}

	const CvPlot* pPlot = plot();

	for (int iPass = 0; iPass < 2; iPass++)
	{
		foreach_(CvUnit* pLoopUnit, pPlot->units())
		{
			if (canLoadOntoUnit(pLoopUnit, pPlot))
			{
				if ((iPass == 0) ? (pLoopUnit->getOwner() == getOwner()) : (pLoopUnit->getTeam() == getTeam()))
				{
					setTransportUnit(pLoopUnit);
					break;
				}
			}
		}

		if (isCargo())
		{
			break;
		}
	}
}


bool CvUnit::canUnload() const
{
	if (getTransportUnit() == NULL)
	{
		return false;
	}

	const CvPlot& kPlot = *(plot());
	if (!kPlot.isValidDomainForLocation(*this))
	{
		return false;
	}

	if (isTrap())
	{
		const TerrainTypes eTerrain = kPlot.getTerrainType();
		if (eTerrain != NO_TERRAIN)
		{
			return false;
		}
		const FeatureTypes eFeature = kPlot.getFeatureType();
		if (eFeature != NO_FEATURE)
		{
			return false;
		}
	}

	if (!isMapCategory(kPlot, *m_pUnitInfo))
	{
		return false;
	}

	if (getDomainType() == DOMAIN_AIR)
	{
		if (kPlot.isFriendlyCity(*this, true))
		{
			const int iNumAirUnits = kPlot.countNumAirUnits(getTeam());
			const CvCity* pCity = kPlot.getPlotCity();
			if (NULL != pCity)
			{
				if (GC.getGame().isOption(GAMEOPTION_SIZE_MATTERS))
				{
					const int iNumAirUnitCargoVolume = kPlot.countNumAirUnitCargoVolume(getTeam());
					if (iNumAirUnitCargoVolume >= pCity->getSMAirUnitCapacity(getTeam()))
					{
						return false;
					}
				}
				else if (iNumAirUnits >= pCity->getAirUnitCapacity(getTeam()))
				{
					return false;
				}
			}
			else
			{
				if (iNumAirUnits >= GC.getDefineINT("CITY_AIR_UNIT_CAPACITY"))
				{
					return false;
				}
			}
		}
	}

	return true;
}


void CvUnit::unload()
{
	if (!canUnload())
	{
		return;
	}

	CvUnit* pUnit = getTransportUnit();
	setTransportUnit(NULL);

	if (isTrap())
	{
		if (plot()->isFriendlyCity(*this, false))
		{
			setTrap(pUnit);
		}
	}
}


bool CvUnit::canUnloadAll() const
{
	if (!hasCargo())
	{
		return false;
	}
	return true;
}


void CvUnit::unloadAll()
{
	if (!canUnloadAll())
	{
		return;
	}

	std::vector<CvUnit*> aCargoUnits;
	getCargoUnits(aCargoUnits);
	if (!aCargoUnits.empty())
	{
		validateCargoUnits();
	}
	foreach_(CvUnit* pCargo, aCargoUnits)
	{
		if (pCargo->canUnload())
		{
			pCargo->setTransportUnit(NULL);
		}
		else
		{
			FAssert(isHuman() || pCargo->getDomainType() == DOMAIN_AIR);
			pCargo->getGroup()->setActivityType(ACTIVITY_AWAKE);
		}
	}
}


bool CvUnit::canHold() const
{
	return true;
}


bool CvUnit::canSleep() const
{
	if (isFortifyable() || isWaiting())
	{
		return false;
	}
	return true;
}


bool CvUnit::canFortify() const
{
	if (!isFortifyable() || isWaiting())
	{
		return false;
	}
	return true;
}

bool CvUnit::canBuildUp() const
{
	if (!isBuildUpable() || isWaiting())
	{
		return false;
	}
	return true;
}

bool CvUnit::canAirPatrol(const CvPlot* pPlot) const
{
	if (getDomainType() != DOMAIN_AIR || !canAirDefend(pPlot) || isWaiting())
	{
		return false;
	}
	return true;
}


bool CvUnit::canSeaPatrol(const CvPlot* pPlot) const
{
	if (!pPlot->isWater())
	{
		return false;
	}

	if (getDomainType() != DOMAIN_SEA)
	{
		return false;
	}

	if (!canFight() || isOnlyDefensive())
	{
		return false;
	}

	if (isWaiting())
	{
		return false;
	}

	return true;
}


void CvUnit::airCircle(bool bStart)
{
	if (!GC.IsGraphicsInitialized())
	{
		return;
	}

	if (!isInViewport())
	{
		return;
	}

	if (getDomainType() != DOMAIN_AIR || maxInterceptionProbability() == 0)
	{
		return;
	}

	//cancel previos missions
	if ( !isUsingDummyEntities() && isInViewport() )
	{
		gDLL->getEntityIFace()->RemoveUnitFromBattle( this );

		if (bStart)
		{
			// patrol is indefinite - time is ignored
			addMission(CvAirMissionDefinition(MISSION_AIRPATROL, plot(), this, NULL, 1.f));
		}
	}
}


bool CvUnit::canHeal(const CvPlot* pPlot) const
{
	if (!isHurt() || isWaiting() || healTurns(pPlot) == 0)
	{
		return false;
	}
	return true;
}


bool CvUnit::canSentry(const CvPlot* pPlot) const
{
	if (!canDefend(pPlot) || isWaiting())
	{
		return false;
	}
	return true;
}


int CvUnit::healRate(const CvPlot* pPlot, bool bHealCheck) const
{
	PROFILE_FUNC();

	CvCity* pCity;
	CvUnit* pHealUnit = NULL;
	int iTotalHeal;
	int iHeal;
	int iBestHeal;
	int iI;
	int iHealAs = MAX_INT;

	int iNumHealAs = m_pUnitInfo->getNumHealAsTypes();
	bool bHasHealAs = (iNumHealAs > 0);

	if (pPlot->getTotalTurnDamage(this) > 0)
	{
		return 0;
	}

	//Find what will take the longest to heal and use that rate
	int iNumTurns = MAX_INT;
	int iBestNumTurns = MAX_INT;
	bool bNeedsHealing = false;
	if (bHasHealAs)
	{
		iBestHeal = MAX_INT;
		for (iI = 0; iI < iNumHealAs; iI++)
		{
			UnitCombatTypes eHealAsType = (UnitCombatTypes)m_pUnitInfo->getHealAsType(iI);
			if (getHealAsDamage(eHealAsType) > 0)
			{
				bNeedsHealing = true;
				iHealAs = getHealRateAsType(pPlot, bHealCheck, eHealAsType);
				if (iHealAs > 0)
				{
					iNumTurns = (getHealAsDamage(eHealAsType)/ iHealAs);
				}
				else
				{
					iNumTurns = MAX_INT;
				}
				//Note we're actually looking for the slowest to heal here to use that for the # of rounds to heal total
				if (iNumTurns > iBestNumTurns)
				{
					iBestHeal = iHealAs;
				}
			}
		}
		if (bNeedsHealing)
		{
			if (iBestHeal > getDamage())
			{
				iBestHeal = getDamage();
			}

			iTotalHeal = iBestHeal;

			if (!hasNoSelfHeal())
			{
				iTotalHeal = std::max(1, iTotalHeal);
			}
			else
			{
				iTotalHeal = std::max(0, iTotalHeal);
			}
			return iTotalHeal;
		}
	}


	pCity = pPlot->getPlotCity();

	iTotalHeal = 0;

	if (!hasNoSelfHeal() || (getSelfHealModifierTotal() < 0))
	{
		iTotalHeal += getSelfHealModifierTotal();
	}

	if (pPlot->isCity(true, getTeam()))
	{
		iTotalHeal += GC.getCITY_HEAL_RATE() + (GET_TEAM(getTeam()).isFriendlyTerritory(pPlot->getTeam()) ? getExtraFriendlyHeal() : getExtraNeutralHeal());
		if (pCity && !pCity->isOccupation())
		{
			iTotalHeal += pCity->getHealRate();
		}
	}
	else if (!hasNoSelfHeal())
	{
		if (!GET_TEAM(getTeam()).isFriendlyTerritory(pPlot->getTeam()))
		{
			if (isEnemy(pPlot->getTeam(), pPlot))
			{
				iTotalHeal += (GC.getENEMY_HEAL_RATE() + getExtraEnemyHeal());
			}
			else
			{
				iTotalHeal += (GC.getNEUTRAL_HEAL_RATE() + getExtraNeutralHeal());
			}
		}
		else
		{
			iTotalHeal += (GC.getFRIENDLY_HEAL_RATE() + getExtraFriendlyHeal());
		}
	}

	// XXX optimize this (save it?)
	iBestHeal = 0;

	foreach_(CvUnit* pLoopUnit, pPlot->units())
	{
		if (pLoopUnit->getTeam() == getTeam() && pLoopUnit->hasHealSupportRemaining()) // XXX what about alliances?
		{
			iHeal = pLoopUnit->getSameTileHeal();
			//if (pLoopUnit->getSameTileHeal() > 0)
			//{
			//	iHeal += pLoopUnit->establishModifier();
			//}

			if (iHeal > iBestHeal)
			{
				iBestHeal = iHeal;
				pHealUnit = pLoopUnit;
			}
		}
	}

	foreach_(const CvPlot* pLoopPlot, pPlot->adjacent() | filtered(CvPlot::fn::area() == pPlot->area()))
	{
		foreach_(CvUnit* pLoopUnit, pLoopPlot->units())
		{
			if (pLoopUnit->getTeam() == getTeam() && pLoopUnit->hasHealSupportRemaining()) // XXX what about alliances?
			{
				iHeal = pLoopUnit->getAdjacentTileHeal();
				//if (pLoopUnit->getAdjacentTileHeal() > 0)
				//{
				//	iHeal += pLoopUnit->establishModifier();
				//}

				if (iHeal > iBestHeal)
				{
					iBestHeal = iHeal;
					pHealUnit = pLoopUnit;
				}
			}
		}
	}

	if (pHealUnit != NULL && bHealCheck)
	{
		pHealUnit->changeHealSupportUsed(1);
		pHealUnit->changeExperience100((10));
	}

	iTotalHeal += iBestHeal;
	// XXX
	if (!hasNoSelfHeal())
	{
		iTotalHeal = std::max(1, iTotalHeal);
	}
	else
	{
		iTotalHeal = std::max(0, iTotalHeal);
	}

	return iTotalHeal;
}

int CvUnit::getHealRateAsType(const CvPlot* pPlot, bool bHealCheck, UnitCombatTypes eHealAsType) const
{
	PROFILE_FUNC();

	CvCity* pCity;
	CvUnit* pHealUnit = NULL;
	int iTotalHeal;
	int iHeal;
	int iBestHeal;
	int iI;
	bool bIsValid = false;

	for (iI = 0; iI < m_pUnitInfo->getNumHealAsTypes(); iI++)
	{
		if (m_pUnitInfo->getHealAsType(iI) == eHealAsType)
		{
			bIsValid = true;
			break;
		}
	}

	if (!bIsValid)
	{
		return MAX_INT;
	}

	pCity = pPlot->getPlotCity();

	iTotalHeal = 0;

	if (pPlot->getTotalTurnDamage(this) > 0)
	{
		return 0;
	}

	if (!hasNoSelfHeal() || (getSelfHealModifierTotal() < 0))
	{
		iTotalHeal += getSelfHealModifierTotal();
	}

	if (pPlot->isCity(true, getTeam()))
	{
		iTotalHeal += GC.getCITY_HEAL_RATE() + (GET_TEAM(getTeam()).isFriendlyTerritory(pPlot->getTeam()) ? getExtraFriendlyHeal() : getExtraNeutralHeal());
		if (pCity && !pCity->isOccupation())
		{
			iTotalHeal += pCity->getHealRate();
			iTotalHeal += pCity->getHealUnitCombatTypeTotal(eHealAsType);
		}
	}
	else if (!hasNoSelfHeal())
	{
		if (!GET_TEAM(getTeam()).isFriendlyTerritory(pPlot->getTeam()))
		{
			if (isEnemy(pPlot->getTeam(), pPlot))
			{
				iTotalHeal += (GC.getENEMY_HEAL_RATE() + getExtraEnemyHeal());
			}
			else
			{
				iTotalHeal += (GC.getNEUTRAL_HEAL_RATE() + getExtraNeutralHeal());
			}
		}
		else
		{
			iTotalHeal += (GC.getFRIENDLY_HEAL_RATE() + getExtraFriendlyHeal());
		}
	}

	// XXX optimize this (save it?)
	iBestHeal = 0;

	foreach_(CvUnit* pLoopUnit, pPlot->units())
	{
		if (pLoopUnit->getTeam() == getTeam() && pLoopUnit->hasHealSupportRemaining()) // XXX what about alliances?
		{
			iHeal = pLoopUnit->getSameTileHeal();
			iHeal += pLoopUnit->getHealUnitCombatTypeTotal(eHealAsType);
			//if (pLoopUnit->getSameTileHeal() > 0 || pLoopUnit->getHealUnitCombatTypeTotal(eHealAsType) > 0)
			//{
			//	iHeal += pLoopUnit->establishModifier();
			//}

			if (iHeal > iBestHeal)
			{
				iBestHeal = iHeal;
				pHealUnit = pLoopUnit;
			}
		}
	}

	foreach_(const CvPlot* pLoopPlot, pPlot->adjacent() | filtered(CvPlot::fn::area() == pPlot->area()))
	{
		foreach_(CvUnit* pLoopUnit, pLoopPlot->units())
		{
			if (pLoopUnit->getTeam() == getTeam() && pLoopUnit->hasHealSupportRemaining()) // XXX what about alliances?
			{
				iHeal = pLoopUnit->getAdjacentTileHeal();
				iHeal += pLoopUnit->getHealUnitCombatTypeAdjacentTotal(eHealAsType);
				//if (pLoopUnit->getAdjacentTileHeal() > 0 || pLoopUnit->getHealUnitCombatTypeAdjacentTotal(eHealAsType) > 0)
				//{
				//	iHeal += pLoopUnit->establishModifier();
				//}

				if (iHeal > iBestHeal)
				{
					iBestHeal = iHeal;
					pHealUnit = pLoopUnit;
				}
			}
		}
	}

	int iExp = 0;
	if (pHealUnit != NULL && bHealCheck)
	{
		pHealUnit->changeHealSupportUsed(1);
		iExp = (10/m_pUnitInfo->getNumHealAsTypes());
		pHealUnit->changeExperience100(iExp);
	}

	iTotalHeal += iBestHeal;
	// XXX
	if (!hasNoSelfHeal())
	{
		iTotalHeal = std::max(1, iTotalHeal);
	}
	else
	{
		iTotalHeal = std::max(0, iTotalHeal);
	}

	return iTotalHeal;
}


int CvUnit::healTurns(const CvPlot* pPlot) const
{
	int iHeal;
	int iTurns = 0;
	int iI;

	if (!isHurt())
	{
		return 0;
	}

	if (pPlot->getTotalTurnDamage(this) > 0)
	{
		return 0;
	}

	int iNumHealAs = m_pUnitInfo->getNumHealAsTypes();
	bool bHasHealAs = (iNumHealAs > 0);

	//Find what will take the longest to heal and use that rate
	int iNumTurns = 0;
	int iBestNumTurns = 0;
	bool bNeedsHealing = false;
	int iHealRate = 0;
	int iHealDamage = 0;
	if (bHasHealAs)
	{
		for (iI = 0; iI < iNumHealAs; iI++)
		{
			UnitCombatTypes eHealAsType = (UnitCombatTypes)m_pUnitInfo->getHealAsType(iI);
			iHealDamage = getHealAsDamage(eHealAsType);
			if (iHealDamage > 0)
			{
				bNeedsHealing = true;
				iHealRate = getHealRateAsType(pPlot, false, eHealAsType);
				if (iHealRate > 0  && iHealRate < MAX_INT)
				{
					iNumTurns = (iHealDamage/ iHealRate);
					if ((getHealAsDamage(eHealAsType) % iHealRate) != 0)
					{
						iNumTurns++;
					}
				}
				else
				{
					iNumTurns = 0;
				}
				//Note we're actually looking for the slowest to heal here to use that for the # of rounds to heal total
				if (iNumTurns > iBestNumTurns)
				{
					iBestNumTurns = iNumTurns;
				}
			}
		}
		if (bNeedsHealing)
		{
			return iBestNumTurns;
		}
	}

	iHeal = healRate(pPlot);

	if (iHeal > 0)
	{
		iTurns = (getDamage() / iHeal);

		if ((getDamage() % iHeal) != 0)
		{
			iTurns++;
		}

		return iTurns;
	}
	else
	{
		return MAX_INT;
	}
}

int CvUnit::healTurnsAsType(const CvPlot* pPlot, UnitCombatTypes eHealAsType) const
{
	int iNumTurns = MAX_INT;
	int iHealAs = 0;

	if (getHealAsDamage(eHealAsType) > 0)
	{
		iHealAs = getHealRateAsType(pPlot, false, eHealAsType);
		if (iHealAs > 0)
		{
			iNumTurns = (getHealAsDamage(eHealAsType)/ iHealAs);
			if ((getHealAsDamage(eHealAsType) % iHealAs) != 0)
			{
				iNumTurns++;
			}
		}
		else
		{
			iNumTurns = MAX_INT;
		}
	}
	return iNumTurns;
}

void CvUnit::doHeal()
{
	UnitCombatTypes eHealAsType = NO_UNITCOMBAT;

	if (m_pUnitInfo->getNumHealAsTypes() > 0)
	{
		for (int iI = 0; iI < m_pUnitInfo->getNumHealAsTypes(); iI++)
		{
			eHealAsType = (UnitCombatTypes)m_pUnitInfo->getHealAsType(iI);
			if (!isHasUnitCombat(eHealAsType))
			{
				setHasUnitCombat(eHealAsType, true);
				setHealAsDamage(eHealAsType, getDamage());
			}
			if (getHealAsDamage(eHealAsType) > 0)
			{
				changeHealAsDamage(eHealAsType,-(getHealRateAsType(plot(), true, eHealAsType)));
			}
		}
	}
	else
	{
		changeDamage(-(healRate(plot(), true)));
	}
	//TB Combat Mod begin
	//Note: to be re-evaluated!!!
	if (getColdDamage() > 0)
	{
		changeColdDamage(-(healRate(plot())));
	}
	//TB Combat Mod end
}

#ifdef OUTBREAKS_AND_AFFLICTIONS
void CvUnit::doAffliction(const bool bHeal)
{
	for (int iI = GC.getNumPromotionLineInfos() - 1; iI > -1; iI--)
	{
		const PromotionLineTypes ePromoLine = static_cast<PromotionLineTypes>(iI);
		const CvPromotionLineInfo& promoLine = GC.getPromotionLineInfo(ePromoLine);

		if (promoLine.isAffliction())
		{
			const bool bHasAffliction = hasAfflictionLine(ePromoLine);

			if (bHasAffliction)
			{
				changeAfflictionTurnCount(ePromoLine, 1);

				for (int iJ = 0; iJ < promoLine.getNumPromotions(); iJ++)
				{
					//Update Afflictions
					const PromotionTypes ePromotion = (PromotionTypes)promoLine.getPromotion(iJ);

					if (isHasPromotion(ePromotion))
					{
						changeAfflictionHitCount(ePromotion, 1);
						updateAfflictionHits(ePromotion);

						if (GC.getPromotionInfo(ePromotion).isParalyze())
						{
							changeImmobileTimer(1);
						}
					}
				}
			}
			//Update Afflictions
			const int iToleranceDecay = promoLine.getToleranceDecay();

			if (!bHasAffliction && getUnitAfflictionTolerance(ePromoLine) > 0 && iToleranceDecay != 0)
			{
				changeUnitAfflictionTolerance(ePromoLine, -iToleranceDecay);
			}

			int iCommunicableExposure = getTotalCommunicableExposure(ePromoLine);
			if (iCommunicableExposure > 0)//sure we have access to communicable source?  Maybe included in checkcontract huh?
			{
				if (checkContractDisease(ePromoLine, iCommunicableExposure))
				{
					afflict(ePromoLine);
				}
			}
			if (bHeal && bHasAffliction)
			{
				doOvercomeAttempt(ePromoLine);
			}
		}
	}
}
#endif

bool CvUnit::canAirlift(const CvPlot* pPlot) const
{
	CvCity* pCity;

	if (getDomainType() != DOMAIN_LAND)
	{
		return false;
	}

	if (hasMoved())
	{
		return false;
	}

	pCity = pPlot->getPlotCity();

	if (pCity == NULL)
	{
		return false;
	}

	if (pCity->getCurrAirlift() >= pCity->getMaxAirlift())
	{
		return false;
	}

	if (pCity->getTeam() != getTeam())
	{
		return false;
	}

	return true;
}


bool CvUnit::canAirliftAt(const CvPlot* pPlot, int iX, int iY) const
{
	CvPlot* pTargetPlot;
	CvCity* pTargetCity;

	if (!canAirlift(pPlot))
	{
		return false;
	}

	pTargetPlot = GC.getMap().plot(iX, iY);

	if (!canMoveInto(pTargetPlot))
	{
		return false;
	}

	// Super Forts begin *airlift*
	if (pTargetPlot->getTeam() != NO_TEAM)
	{
		if (pTargetPlot->getTeam() == getTeam() || GET_TEAM(pTargetPlot->getTeam()).isVassal(getTeam()))
		{
			if (pTargetPlot->getImprovementType() != NO_IMPROVEMENT)
			{
				if (GC.getImprovementInfo(pTargetPlot->getImprovementType()).isActsAsCity())
				{
					return true;
				}
			}
		}
	}
	// Super Forts end

	pTargetCity = pTargetPlot->getPlotCity();

	if (pTargetCity == NULL)
	{
		return false;
	}

	if (pTargetCity->isAirliftTargeted())
	{
		return false;
	}

	if (pTargetCity->getTeam() != getTeam() && !GET_TEAM(pTargetCity->getTeam()).isVassal(getTeam()))
	{
		return false;
	}
/************************************************************************************************/
/* Afforess	                  Start		 03/7/10                                                */
/*                                                                                              */
/*  Airlift Range                                                                               */
/************************************************************************************************/
	if (!GET_TEAM(getTeam()).isRebaseAnywhere())
	{
		if (GC.getGame().isModderGameOption(MODDERGAMEOPTION_AIRLIFT_RANGE))
		{
			if (plotDistance(pPlot->getX(), pPlot->getY(), iX, iY) > (GC.getGame().getModderGameOption(MODDERGAMEOPTION_AIRLIFT_RANGE)))
			{
				return false;
			}
		}
	}
/************************************************************************************************/
/* Afforess	                     END                                                            */
/************************************************************************************************/
	return true;
}


bool CvUnit::airlift(int iX, int iY)
{
	CvCity* pCity;
	CvCity* pTargetCity;
	CvPlot* pTargetPlot;

	if (!canAirliftAt(plot(), iX, iY))
	{
		return false;
	}

	pCity = plot()->getPlotCity();
	FAssert(pCity != NULL);
	pTargetPlot = GC.getMap().plot(iX, iY);
	FAssert(pTargetPlot != NULL);
	pTargetCity = pTargetPlot->getPlotCity();
	FAssert(pTargetCity != NULL);
	FAssert(pCity != pTargetCity);

	// Super Forts begin *airlift* - added if statement to allow airlifts to plots that aren't cities
	if (pTargetPlot->isCity())
	{
		pTargetCity = pTargetPlot->getPlotCity();
		FAssert(pTargetCity != NULL);
		FAssert(pCity != pTargetCity);

		if (pTargetCity->getMaxAirlift() == 0)
		{
			pTargetCity->setAirliftTargeted(true);
		}
	}
	pCity->changeCurrAirlift(1);
	// Super Forts end

	finishMoves();

	//GC.getGame().logOOSSpecial(18, getID(), pTargetPlot->getX(), pTargetPlot->getY());
	setXY(pTargetPlot->getX(), pTargetPlot->getY());

	return true;
}


bool CvUnit::isNukeVictim(const CvPlot* pPlot, TeamTypes eTeam) const
{
	if (!GET_TEAM(eTeam).isAlive() || eTeam == getTeam())
	{
		return false;
	}

	foreach_(const CvPlot* pLoopPlot, pPlot->rect(nukeRange(), nukeRange()))
	{
		if (pLoopPlot->getTeam() == eTeam)
		{
			return true;
		}
		if (pLoopPlot->plotCheck(PUF_isCombatTeam, eTeam, getTeam()) != NULL)
		{
			return true;
		}
	}
	return false;
}


bool CvUnit::canNuke(const CvPlot* pPlot) const
{
	if (nukeRange() == -1)
	{
		return false;
	}

	return true;
}


bool CvUnit::canNukeAt(const CvPlot* pPlot, int iX, int iY) const
{
	if (!canNuke(pPlot))
	{
		return false;
	}
	const int iDistance = plotDistance(pPlot->getX(), pPlot->getY(), iX, iY);

	if (iDistance <= nukeRange() || airRange() > 0 && iDistance > airRange())
	{
		return false;
	}
	CvPlot* pTargetPlot = GC.getMap().plot(iX, iY);

	for (int iI = 0; iI < MAX_TEAMS; iI++)
	{
		if (iI != getTeam() && isNukeVictim(pTargetPlot, (TeamTypes)iI) && !isEnemy((TeamTypes)iI))
		{
			return false;
		}
	}
	return true;
}

bool CvUnit::nuke(int iX, int iY, bool bTrap)
{
	if (!canNukeAt(plot(), iX, iY))
	{
		return false;
	}
	CvPlot* pPlot = GC.getMap().plot(iX, iY);

	bool abTeamsAffected[MAX_TEAMS];

	for (int iI = 0; iI < MAX_TEAMS; iI++)
	{
		abTeamsAffected[iI] = isNukeVictim(pPlot, ((TeamTypes)iI));
	}

	for (int iI = 0; iI < MAX_PC_TEAMS; iI++)
	{
		if (abTeamsAffected[iI] && iI != getTeam() && !isEnemy((TeamTypes)iI))
		{
			GET_TEAM(getTeam()).declareWar(((TeamTypes)iI), false, WARPLAN_TOTAL);
		}
	}

	if (!bTrap && airBaseCombatStr() != 0 && interceptTest(pPlot))
	{
		return true;
	}
	int iBestInterception = 0;
	TeamTypes eBestTeam = NO_TEAM;

	if (!bTrap)
	{
		for (int iI = 0; iI < MAX_TEAMS; iI++)
		{
			if (abTeamsAffected[iI] && GET_TEAM((TeamTypes)iI).getNukeInterception() > iBestInterception)
			{
				iBestInterception = GET_TEAM((TeamTypes)iI).getNukeInterception();
				eBestTeam = ((TeamTypes)iI);
			}
		}

		iBestInterception *= (100 - m_pUnitInfo->getEvasionProbability());
		iBestInterception /= 100;

		setReconPlot(pPlot);

		if (GC.getGame().getSorenRandNum(100, "Nuke") < iBestInterception)
		{
			for (int iI = 0; iI < MAX_PC_PLAYERS; iI++)
			{
				if (GET_PLAYER((PlayerTypes)iI).isAlive() && GET_PLAYER((PlayerTypes)iI).isHuman())
				{
					AddDLLMessage(
						(PlayerTypes)iI, iI == getOwner(), GC.getEVENT_MESSAGE_TIME(),
						gDLL->getText(
							"TXT_KEY_MISC_NUKE_INTERCEPTED",
							GET_PLAYER(getOwner()).getNameKey(), getNameKey(),
							GET_TEAM(eBestTeam).getName().GetCString()
						),
						"AS2D_NUKE_INTERCEPTED", MESSAGE_TYPE_MAJOR_EVENT, getButton(),
						GC.getCOLOR_RED(), pPlot->getX(), pPlot->getY(), true, true
					);
				}
			}
			// Nuke entity mission
			// Add the intercepted mission (defender is not NULL)
			addMission(CvMissionDefinition(MISSION_NUKE, pPlot, this, this));

			kill(true, NO_PLAYER, true);

			return true; // Intercepted!!! (XXX need special event for this...)
		}
	}

	if (pPlot->isActiveVisible(false) && !isUsingDummyEntities() && isInViewport())
	{
		if (airBaseCombatStr() != 0)
		{
			addMission(CvAirMissionDefinition(MISSION_AIRSTRIKE, pPlot, this));
		}
		else // Nuke entity mission
		{
			// Add the non-intercepted mission (defender is NULL)
			addMission(CvMissionDefinition(MISSION_NUKE, pPlot, this));
			CvMissionDefinition kDefiniton;
		}
	}

	setMadeAttack(true);
	setAttackPlot(pPlot, false);

	for (int iI = 0; iI < MAX_PC_TEAMS; iI++)
	{
		if (abTeamsAffected[iI])
		{
			GET_TEAM((TeamTypes)iI).changeWarWeariness(getTeam(), 100 * GC.getDefineINT("WW_HIT_BY_NUKE"));
			GET_TEAM(getTeam()).changeWarWeariness(((TeamTypes)iI), 100 * GC.getDefineINT("WW_ATTACKED_WITH_NUKE"));
			GET_TEAM(getTeam()).AI_changeWarSuccess(((TeamTypes)iI), GC.getDefineINT("WAR_SUCCESS_NUKE"));
		}
	}

	for (int iI = 0; iI < MAX_PC_TEAMS; iI++)
	{
		if (GET_TEAM((TeamTypes)iI).isAlive() && iI != getTeam())
		{
			if (abTeamsAffected[iI])
			{
				for (int iJ = 0; iJ < MAX_PC_PLAYERS; iJ++)
				{
					if (GET_PLAYER((PlayerTypes)iJ).isAliveAndTeam((TeamTypes)iI))
					{
						GET_PLAYER((PlayerTypes)iJ).AI_changeMemoryCount(getOwner(), MEMORY_NUKED_US, 1);
					}
				}
			}
			else
			{
				for (int iJ = 0; iJ < MAX_PC_TEAMS; iJ++)
				{
					if (abTeamsAffected[iJ] && GET_TEAM((TeamTypes)iJ).isAlive()
					&& GET_TEAM((TeamTypes)iI).isHasMet((TeamTypes)iJ)
					&& GET_TEAM((TeamTypes)iI).AI_getAttitude((TeamTypes)iJ) >= ATTITUDE_CAUTIOUS)
					{
						for (int iK = 0; iK < MAX_PC_PLAYERS; iK++)
						{
							if (GET_PLAYER((PlayerTypes)iK).isAliveAndTeam((TeamTypes)iI))
							{
								GET_PLAYER((PlayerTypes)iK).AI_changeMemoryCount(getOwner(), MEMORY_NUKED_FRIEND, 1);
							}
						}
						break;
					}
				}
			}
		}
	}
	// XXX some AI should declare war here...

	const CvWString szBuffer =
	(
		bTrap
		?
		gDLL->getText("TXT_KEY_MISC_NUKE_TRAP", getNameKey(), GET_PLAYER(getOwner()).getNameKey())
		:
		gDLL->getText("TXT_KEY_MISC_NUKE_LAUNCHED", GET_PLAYER(getOwner()).getNameKey(), getNameKey())
	);

	for (int iI = 0; iI < MAX_PC_PLAYERS; iI++)
	{
		if (GET_PLAYER((PlayerTypes)iI).isAlive() && GET_PLAYER((PlayerTypes)iI).isHuman())
		{
			AddDLLMessage(
				(PlayerTypes)iI, iI == getOwner(), GC.getEVENT_MESSAGE_TIME(),
				szBuffer, "AS2D_NUKE_EXPLODES", MESSAGE_TYPE_MAJOR_EVENT,
				getButton(), GC.getCOLOR_RED(), pPlot->getX(), pPlot->getY(), true, true
			);
		}
	}

	if (isSuicide())
	{
		kill(true);
	}
	GC.getGame().setLastNukeStrikePlot(pPlot);

	return true;
}


bool CvUnit::canRecon() const
{
	if (getDomainType() != DOMAIN_AIR)
	{
		return false;
	}

	if (airRange() == 0)
	{
		return false;
	}

	if (m_pUnitInfo->isSuicide())
	{
		return false;
	}

	return true;
}



bool CvUnit::canReconAt(const CvPlot* pPlot, int iX, int iY) const
{
	if (!canRecon())
	{
		return false;
	}

	int iDistance = plotDistance(pPlot->getX(), pPlot->getY(), iX, iY);
	if (iDistance > airRange() || 0 == iDistance)
	{
		return false;
	}

	return true;
}


bool CvUnit::recon(int iX, int iY)
{
	CvPlot* pPlot;

	if (!canReconAt(plot(), iX, iY))
	{
		return false;
	}

	pPlot = GC.getMap().plot(iX, iY);

	setReconPlot(pPlot);

	finishMoves();
/************************************************************************************************/
/* Afforess	                  Start		 09/13/10                                               */
/*                                                                                              */
/*                                                                                              */
/************************************************************************************************/
	if (GC.getGame().isModderGameOption(MODDERGAMEOPTION_IMPROVED_XP))
	{
		 setExperience100(getExperience100() + 5, -1);
	}
/************************************************************************************************/
/* Afforess	                     END                                                            */
/************************************************************************************************/

	addMission(CvAirMissionDefinition(MISSION_RECON, pPlot, this, NULL));

	return true;
}


bool CvUnit::canParadrop(const CvPlot* pPlot) const
{
	if (getDropRange() <= 0 || hasMoved() || !pPlot->isFriendlyCity(*this, true))
	{
		return false;
	}
	return true;
}


bool CvUnit::canParadropAt(const CvPlot* fromPlot, int toX, int toY) const
{
	if (!canParadrop(fromPlot))
	{
		return false;
	}

	CvPlot* pTargetPlot = GC.getMap().plot(toX, toY);
	if (NULL == pTargetPlot || pTargetPlot == fromPlot)
	{
		return false;
	}

	if (!pTargetPlot->isVisible(getTeam(), false))
	{
		return false;
	}

	if (!canMoveInto(pTargetPlot, MoveCheck::IgnoreLoad))
	{
		return false;
	}

	if (plotDistance(fromPlot->getX(), fromPlot->getY(), toX, toY) > getDropRange())
	{
		return false;
	}

	if (!canCoexistAlwaysOnPlot(*pTargetPlot) && pTargetPlot->isEnemyCity(*this))
	{
		return false;
	}

	if (pTargetPlot->isWater() && getDomainType() == DOMAIN_LAND)
	{
		return false;
	}

	return true;
}


bool CvUnit::paradrop(int iX, int iY)
{
	if (!canParadropAt(plot(), iX, iY))
	{
		return false;
	}

	CvPlot* pPlot = GC.getMap().plot(iX, iY);

	changeMoves(GC.getMOVE_DENOMINATOR() / 2);
	setMadeAttack(true);

	if (isFreeDrop() == true)
	{
		changeMoves(-(GC.getMOVE_DENOMINATOR() / 2));
		setMadeAttack(false);
	}

	//GC.getGame().logOOSSpecial(19, getID(), pPlot->getX(), pPlot->getY());
	setXY(pPlot->getX(), pPlot->getY());

	//check if intercepted
	if(interceptTest(pPlot))
	{
		return true;
	}

	if (GC.getGame().isModderGameOption(MODDERGAMEOPTION_IMPROVED_XP))
	{
		 setExperience100(getExperience100() + 5, -1);
	}

	//play paradrop animation by itself
	addMission(CvAirMissionDefinition(MISSION_PARADROP, pPlot, this));

	return true;
}


bool CvUnit::canAirBomb() const
{
	if (GC.isDCM_AIR_BOMBING() && isHuman())
	{
		return false;
	}

	if (getDomainType() != DOMAIN_AIR)
	{
		return false;
	}

	if (getAirBombBaseRate() == 0)
	{
		return false;
	}

	if (isMadeAttack())
	{
		return false;
	}
	return true;
}


bool CvUnit::canAirBombAt(const CvPlot* pPlot, int iX, int iY) const
{
	if (!canAirBomb())
	{
		return false;
	}

	CvPlot* pTargetPlot = GC.getMap().plot(iX, iY);

	if (plotDistance(pPlot->getX(), pPlot->getY(), pTargetPlot->getX(), pTargetPlot->getY()) > airRange())
	{
		return false;
	}

	if (pTargetPlot->isOwned() && !potentialWarAction(pTargetPlot))
	{
		return false;
	}

	CvCity* pCity = pTargetPlot->getPlotCity();

	if (pTargetPlot->getImprovementType() != NO_IMPROVEMENT)
	{
		if (GC.getImprovementInfo(pTargetPlot->getImprovementType()).isActsAsCity() && pCity == NULL)
		{
			if (m_pUnitInfo->getDCMAirBomb4())
			{
				int iCount = 0;
				foreach_(const CvUnit* pLoopUnit, pPlot->units())
				{
					if (pLoopUnit->getDomainType() == DOMAIN_SEA && atWar(pLoopUnit->getTeam(), getTeam()))
					{
						iCount++;
					}
				}
				if (iCount > 0)
				{
					return true;
				}
			}
		}
	}
	else if (pCity != NULL)
	{
		if (GC.isDCM_AIR_BOMBING())
		{
			for (int iI = 0; iI < MAX_PLAYERS; ++iI)
			{
				if (atWar(GET_PLAYER((PlayerTypes)iI).getTeam(), getTeam()))
				{
					if (algo::any_of(GET_PLAYER((PlayerTypes)iI).units(),
						CvUnit::fn::plot() == pTargetPlot && CvUnit::fn::getDomainType() == DOMAIN_SEA))
					{
						return true;
					}
				}
			}
			if (pCity->isBombardable(this))
			{
				return true;
			}
			return false;
		}
		else if (!(pCity->isBombardable(this)))
		{
			return false;
		}
	}
	// Toffer - Something is wrong here, this else if can never be true as we already established that there's no improvement here if first if fails.
	else if (!pTargetPlot->isImprovementDestructible())
	{
		return false;
	}
	return true;
}


bool CvUnit::airBomb(int iX, int iY)
{
	if (!canAirBombAt(plot(), iX, iY))
	{
		return false;
	}
	CvPlot* pPlot = GC.getMap().plot(iX, iY);

	if (!isEnemy(pPlot->getTeam()))
	{
		getGroup()->groupDeclareWar(pPlot, true);
	}

	if (!isEnemy(pPlot->getTeam()))
	{
		return false;
	}

	if (interceptTest(pPlot))
	{
		return true;
	}

	CvCity* pCity = pPlot->getPlotCity();

	if (pPlot->getImprovementType() != NO_IMPROVEMENT)
	{
		if (!GC.isDCM_AIR_BOMBING())
		{
			if (GC.getGame().getSorenRandNum(getAirBombCurrRate(), "Air Bomb - Offense")
				>=
				GC.getGame().getSorenRandNum(GC.getImprovementInfo(pPlot->getImprovementType()).getAirBombDefense(), "Air Bomb - Defense"))
			{
				AddDLLMessage(
					getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
					gDLL->getText(
						"TXT_KEY_MISC_YOU_UNIT_DESTROYED_IMP",
						getNameKey(), GC.getImprovementInfo(pPlot->getImprovementType()).getTextKeyWide()
					),
					"AS2D_PILLAGE", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_GREEN(), pPlot->getX(), pPlot->getY()
				);
				if (pPlot->isOwned())
				{
					if (BARBARIAN_PLAYER != getVisualOwner(getTeam()))
					{
						AddDLLMessage(
							pPlot->getOwner(), false, GC.getEVENT_MESSAGE_TIME(),
							gDLL->getText(
								"TXT_KEY_MISC_YOU_IMP_WAS_DESTROYED",
								GC.getImprovementInfo(pPlot->getImprovementType()).getTextKeyWide(),
								getNameKey(), getVisualCivAdjective(pPlot->getTeam())
							),
							"AS2D_PILLAGED", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_RED(), pPlot->getX(), pPlot->getY(), true, true
						);
					}
					else
					{
						AddDLLMessage(
							pPlot->getOwner(), false, GC.getEVENT_MESSAGE_TIME(),
							gDLL->getText(
								"TXT_KEY_MISC_YOU_IMP_WAS_DESTROYED_HIDDEN",
								GC.getImprovementInfo(pPlot->getImprovementType()).getTextKeyWide(), getNameKey()
							),
							"AS2D_PILLAGED", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_RED(), pPlot->getX(), pPlot->getY(), true, true
						);
					}
				}
				pPlot->setImprovementType(GC.getImprovementInfo(pPlot->getImprovementType()).getImprovementPillage());
			}
			else
			{
				AddDLLMessage(
					getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
					gDLL->getText(
						"TXT_KEY_MISC_YOU_UNIT_FAIL_DESTROY_IMP",
						getNameKey(), GC.getImprovementInfo(pPlot->getImprovementType()).getTextKeyWide()
					),
					"AS2D_BOMB_FAILS", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_RED(), pPlot->getX(), pPlot->getY()
				);
			}
		}
		else if (GC.getImprovementInfo(pPlot->getImprovementType()).isActsAsCity() && pCity == NULL && m_pUnitInfo->getDCMAirBomb4()

		&& algo::any_of(pPlot->units(), CvUnit::fn::getDomainType() == DOMAIN_SEA))
		{
			airBomb4(iX, iY);
		}
	}
	else if (pCity != NULL)
	{
		if (!GC.isDCM_AIR_BOMBING())
		{
			pCity->changeDefenseModifier(-getAirBombCurrRate());

			AddDLLMessage(
				pCity->getOwner(), false, GC.getEVENT_MESSAGE_TIME(),
				gDLL->getText(
					"TXT_KEY_MISC_YOU_DEFENSES_REDUCED_TO",
					pCity->getNameKey(), pCity->getDefenseModifier(false), getNameKey()
				),
				"AS2D_BOMBARDED", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_RED(), pCity->getX(), pCity->getY(), true, true
			);
			AddDLLMessage(
				getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
				gDLL->getText(
					"TXT_KEY_MISC_ENEMY_DEFENSES_REDUCED_TO",
					getNameKey(), pCity->getNameKey(), pCity->getDefenseModifier(false)
				),
				"AS2D_BOMBARD", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_GREEN(), pCity->getX(), pCity->getY()
			);
		}
		else
		{
			int iMis1, iMis2, iMis3;
			iMis1 = iMis2 = iMis3 = 0;
			if (m_pUnitInfo->getDCMAirBomb1())
			{
				iMis1 = 10;
				int iCount = 0;
				foreach_(const CvPlot* pLoopPlot, plot()->rect(2, 2))
				{
					iCount += algo::count_if(pLoopPlot->units(), CvUnit::fn::getOwner() == getOwner());
				}
				iMis1 *= iCount * 2;
			}
			if (m_pUnitInfo->getDCMAirBomb2())
			{
				iMis2 = 10;
				int iCount = 0;
				for (int iI = 0; iI < GC.getNumBuildingInfos(); iI++)
				{
					if (GC.getBuildingInfo((BuildingTypes)iI).getDCMAirbombMission() == 2 && pCity->getNumActiveBuilding((BuildingTypes)iI))
					{
						iCount++;
					}
				}
				iMis2 *= iCount;
			}
			if (m_pUnitInfo->getDCMAirBomb3())
			{
				iMis3 = 10;
				int iCount = 0;
				for (int iI = 0; iI < GC.getNumBuildingInfos(); iI++)
				{
					if (GC.getBuildingInfo((BuildingTypes)iI).getDCMAirbombMission() == 3 && pCity->getNumActiveBuilding((BuildingTypes)iI) > 0)
					{
						iCount++;
					}
				}
				iMis3 *= (iCount * 2);
			}
			const int iMis4 = m_pUnitInfo->getDCMAirBomb4() ? 40 * algo::count_if(pPlot->units(), CvUnit::fn::getDomainType() == DOMAIN_SEA) : 0;

			const int iMis5 = m_pUnitInfo->getDCMAirBomb5() ? 10 * GC.getGame().getSorenRandNum(20, "Strat Bombing") : 0;

			int iMis0 = 1;
			if (iMis2 > iMis1)
			{
				iMis1 = iMis2;
				iMis0++;
			}
			if (iMis3 > iMis1)
			{
				iMis1 = iMis3;
				iMis0++;
			}
			if (iMis4 > iMis1)
			{
				iMis1 = iMis4;
				iMis0++;
			}
			if (iMis5 > iMis1)
			{
				iMis0++;
			}
			bool bNoTarget = true;
			switch(iMis0)
			{
				case 1:
				{
					if (airBomb1(iX, iY))
					{
						bNoTarget = false;
					}
					break;
				}
				case 2:
				{
					if (airBomb2(iX, iY))
					{
						bNoTarget = false;
					}
					break;
				}
				case 3:
				{
					if (airBomb3(iX, iY))
					{
						bNoTarget = false;
					}
					break;
				}
				case 4:
				{
					if (airBomb4(iX, iY))
					{
						bNoTarget = false;
					}
					break;
				}
				case 5:
				{
					if (airBomb5(iX, iY))
					{
						bNoTarget = false;
					}
					break;
				}
			}
			if (bNoTarget && pCity->getPopulation() > 1 && GC.getGame().getSorenRandNum(5, "Airbomb population") < 2)
			{
				pCity->changePopulation(-1);

				AddDLLMessage(
					getOwner(), true, GC.getEVENT_MESSAGE_TIME(), gDLL->getText("TXT_KEY_MISC_YOU_AIRBOMB_POP"),
					"AS2D_BOMBARD", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_GREEN(), pCity->getX(), pCity->getY(), true, true
				);
				AddDLLMessage(
					pCity->getOwner(), false, GC.getEVENT_MESSAGE_TIME(), gDLL->getText("TXT_KEY_MISC_ENEMY_AIRBOMB_POP"),
					"AS2D_BOMBARDED", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_RED(), pCity->getX(), pCity->getY(), true, true
				);
			}
		}
	}
	setReconPlot(pPlot);
	setMadeAttack(true);
	changeMoves(GC.getMOVE_DENOMINATOR());
	addMission(CvAirMissionDefinition(MISSION_AIRBOMB, pPlot, this));

	if (isSuicide())
	{
		kill(true);
	}
	else if (GC.getGame().isModderGameOption(MODDERGAMEOPTION_IMPROVED_XP))
	{
		setExperience100(getExperience100() + getRandomMinExperienceTimes100(), -1);
	}
	return true;
}


CvCity* CvUnit::bombardTarget(const CvPlot* pPlot) const
{
	int iBestValue = MAX_INT;
	CvCity* pBestCity = NULL;

	foreach_(const CvPlot* pLoopPlot, pPlot->adjacent())
	{
		CvCity* pLoopCity = pLoopPlot->getPlotCity();

		if (pLoopCity != NULL && pLoopCity->isBombardable(this))
		{
			int iValue = pLoopCity->getDefenseDamage();

			// always prefer cities we are at war with
			if (isEnemy(pLoopCity->getTeam(), pPlot))
			{
				iValue *= 128;
			}

			if (iValue < iBestValue)
			{
				iBestValue = iValue;
				pBestCity = pLoopCity;
			}
		}
	}

	return pBestCity;
}


// Super Forts begin *bombard*
CvPlot* CvUnit::bombardImprovementTarget(const CvPlot* pPlot) const
{
	int iBestValue = MAX_INT;
	CvPlot* pBestPlot = NULL;

	foreach_(CvPlot* pLoopPlot, pPlot->adjacent() | filtered(CvPlot::fn::isBombardable(this)))
	{
		int iValue = pLoopPlot->getDefenseDamage();

		// always prefer cities we are at war with
		if (isEnemy(pLoopPlot->getTeam(), pPlot))
		{
			iValue *= 128;
		}

		if (iValue < iBestValue)
		{
			iBestValue = iValue;
			pBestPlot = pLoopPlot;
		}
	}

	return pBestPlot;
}
// Super Forts end

bool CvUnit::canBombard(const CvPlot* pPlot, bool bIgnoreHasAttacked) const
{
	if (getBombardRate() <= 0)
	{
		return false;
	}

	if (!bIgnoreHasAttacked && isMadeAttack())
	{
		return false;
	}

	if (isCargo())
	{
		return false;
	}

	// Super Forts begin *bombard*
	if (bombardTarget(pPlot) == NULL && bombardImprovementTarget(pPlot) == NULL)
	//if (bombardTarget(pPlot) == NULL) - Original Code
	// Super Forts end
	{
		return false;
	}

	return true;
}


bool CvUnit::bombard()
{
	CvPlot* pPlot = plot();
	if (!canBombard(pPlot))
	{
		return false;
	}

	CvCity* pBombardCity = bombardTarget(pPlot);
	// Super Forts begin *bombard*
	//FAssertMsg(pBombardCity != NULL, "BombardCity is not assigned a valid value"); - Removed for Super Forts

	CvPlot* pTargetPlot;
	//CvPlot* pTargetPlot = pBombardCity->plot(); - Original Code
	if(pBombardCity != NULL)
	{
		pTargetPlot = pBombardCity->plot();
	}
	else
	{
		pTargetPlot = bombardImprovementTarget(pPlot);
	}
	// Super Forts end

	// Dale - RB: Bug Fix (RevolutionDCM - just checks for a null value)
	if (pTargetPlot != NULL)
	{
		if (!isEnemy(pTargetPlot->getTeam()))
		{
			getGroup()->groupDeclareWar(pTargetPlot, true);
		}

		if (!isEnemy(pTargetPlot->getTeam()))
		{
			return false;
		}

		int iBombardModifier = 0;
		// Super Forts begin *bombard* *text*
		if(pBombardCity != NULL)
		{

			if (!ignoreBuildingDefense())
			{
				iBombardModifier -= pBombardCity->getBuildingBombardDefense();
			}

			pBombardCity->changeDefenseModifier(-(getBombardRate() * std::max(0, 100 + iBombardModifier)) / 100);

			CvWString szBuffer = gDLL->getText("TXT_KEY_MISC_DEFENSES_IN_CITY_REDUCED_TO", pBombardCity->getNameKey(), pBombardCity->getDefenseModifier(false), GET_PLAYER(getOwner()).getNameKey());
			AddDLLMessage(pBombardCity->getOwner(), false, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_BOMBARDED", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_RED(), pBombardCity->getX(), pBombardCity->getY(), true, true);

			szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_REDUCE_CITY_DEFENSES", getNameKey(), pBombardCity->getNameKey(), pBombardCity->getDefenseModifier(false));
			AddDLLMessage(getOwner(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_BOMBARD", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_GREEN(), pBombardCity->getX(), pBombardCity->getY());
		}
		else
		{

			pTargetPlot->changeDefenseDamage(getBombardRate());

			CvWString szBuffer = gDLL->getText("TXT_KEY_MISC_DEFENSES_IN_CITY_REDUCED_TO", GC.getImprovementInfo(pTargetPlot->getImprovementType()).getText(),
				(GC.getImprovementInfo(pTargetPlot->getImprovementType()).getDefenseModifier()-pTargetPlot->getDefenseDamage()), GET_PLAYER(getOwner()).getNameKey());
			AddDLLMessage(pTargetPlot->getOwner(), false, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_BOMBARDED", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_RED(), pTargetPlot->getX(), pTargetPlot->getY(), true, true);

			szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_REDUCE_CITY_DEFENSES", getNameKey(), GC.getImprovementInfo(pTargetPlot->getImprovementType()).getText(),
				(GC.getImprovementInfo(pTargetPlot->getImprovementType()).getDefenseModifier()-pTargetPlot->getDefenseDamage()));
			AddDLLMessage(getOwner(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_BOMBARD", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_GREEN(), pTargetPlot->getX(), pTargetPlot->getY());
		}
		// Super Forts end

		changeExperience100(100, -1, true);
		setMadeAttack(true);
		changeMoves(GC.getMOVE_DENOMINATOR());
/************************************************************************************************/
/* Afforess	                  Start		 07/22/10                                               */
/*                                                                                              */
/*                                                                                              */
/************************************************************************************************/
		if (GC.getGame().isModderGameOption(MODDERGAMEOPTION_IMPROVED_XP))
		{
			 setExperience100(getExperience100() + getRandomMinExperienceTimes100(), -1);
		}
/************************************************************************************************/
/* Afforess	                     END                                                            */
/************************************************************************************************/

		if (pPlot->isActiveVisible(false))
		{
			// Super Forts begin *bombard*
			CvUnit *pDefender = pTargetPlot->getBestDefender(NO_PLAYER, getOwner(), this, true);
			//CvUnit *pDefender = pBombardCity->plot()->getBestDefender(NO_PLAYER, getOwner(), this, true); - Original Code
			// Super Forts end

			// Bombard entity mission
			addMission(CvMissionDefinition(MISSION_BOMBARD, pTargetPlot, this, pDefender));
		}
	}
	return true;
}

bool CvUnit::canPillage(const CvPlot* pPlot) const
{
	if (pPlot == NULL || !m_pUnitInfo->isPillage())
	{
		return false;
	}

	if (isOnlyDefensive() && !isAnimal())
	{
		// Toffer - This is an odd one, probably specific to the locust swarm unit.
		return false;
	}

	if (GET_PLAYER(getOwner()).isModderOption(MODDEROPTION_NO_FRIENDLY_PILLAGING) && pPlot->getTeam() == getTeam())
	{
		return false;
	}

	if (isCargo())
	{
		return false;
	}

	if (pPlot->isCity())
	{
		return false;
	}

	if (pPlot->getImprovementType() == NO_IMPROVEMENT)
	{
		if (!pPlot->isRoute())
		{
			return false;
		}
	}
	else if (GC.getImprovementInfo(pPlot->getImprovementType()).isPermanent())
	{
		return false;
	}

	if (pPlot->isOwned() && !potentialWarAction(pPlot)
	&& (pPlot->getImprovementType() == NO_IMPROVEMENT || pPlot->getOwner() != getOwner()))
	{
		return false;
	}

	if (!pPlot->isValidDomainForAction(*this))
	{
		return false;
	}

	return true;
}


bool CvUnit::pillage()
{
	CvPlot* pPlot = plot();

	if (!canPillage(pPlot))
	{
		return false;
	}

	const PlayerTypes ePlayerPillaged = pPlot->getOwner();
	if (ePlayerPillaged != NO_PLAYER
	// We should not be calling this without declaring war first, so do not declare war here
	&& !isEnemy(pPlot->getTeam(), pPlot)
	&& (pPlot->getImprovementType() == NO_IMPROVEMENT || ePlayerPillaged != getOwner()))
	{
		return false;
	}

	if (pPlot->isWater())
	{
		CvUnit* pInterceptor = bestSeaPillageInterceptor(this, GC.getCOMBAT_DIE_SIDES() / 2);

		if (NULL != pInterceptor)
		{
			setMadeAttack(false);

			int iWithdrawal = withdrawalProbability();
			changeExtraWithdrawal(-iWithdrawal); // no withdrawal since we are really the defender
			attack(pInterceptor->plot(), false);
			changeExtraWithdrawal(iWithdrawal);

			return false;
		}
	}
	CvPlayer& player = GET_PLAYER(getOwner());
	int iPillageGold = 0;
	ImprovementTypes eTempImprovement = NO_IMPROVEMENT;
	RouteTypes eTempRoute = NO_ROUTE;

	if (pPlot->getImprovementType() != NO_IMPROVEMENT)
	{
		eTempImprovement = pPlot->getImprovementType();

		if (ePlayerPillaged != NO_PLAYER && pPlot->getTeam() != getTeam())
		{
			// Use python to determine pillage amounts...
			iPillageGold = Cy::call<int>(PYGameModule, "doPillageGold", Cy::Args() << pPlot << this);

			if (iPillageGold > 0)
			{
				const float fInfluenceRatio =
				(
					GC.isIDW_ENABLED() && GC.isIDW_PILLAGE_INFLUENCE_ENABLED() && atWar(pPlot->getTeam(), getTeam())
					?
					doPillageInfluence()
					:
					0.0f
				);
				iPillageGold += iPillageGold * getPillageChange() / 100;
				player.changeGold(iPillageGold);

				if (isHuman())
				{
					AddDLLMessage(
						getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
						gDLL->getText(
							"TXT_KEY_MISC_PLUNDERED_GOLD_FROM_IMP",
							iPillageGold, GC.getImprovementInfo(pPlot->getImprovementType()).getTextKeyWide()
						)
						, "AS2D_PILLAGE", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_GREEN(),
						pPlot->getX(), pPlot->getY()
					);
				}
				for (int iI = 0; iI < NUM_COMMERCE_TYPES; ++iI)
				{
					CommerceTypes eCommerce = (CommerceTypes)iI;
					switch (eCommerce)
					{
						case COMMERCE_GOLD:
						{
							if (isPillageMarauder())
							{
								player.changeGold(iPillageGold);
								pPlot->setImprovementType(GC.getImprovementInfo(pPlot->getImprovementType()).getImprovementPillage());
								if (isHuman())
								{
									AddDLLMessage(
										getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
										gDLL->getText(
											"TXT_KEY_MISC_MARAUDERS_PLUNDERED_IMP",
											iPillageGold, GC.getImprovementInfo(pPlot->getImprovementType()).getTextKeyWide()
										),
										"AS2D_PILLAGE", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_GREEN(),
										pPlot->getX(), pPlot->getY()
									);
								}
								if (GET_PLAYER(ePlayerPillaged).isHuman())
								{
									AddDLLMessage(
										ePlayerPillaged, false, GC.getEVENT_MESSAGE_TIME(),
										gDLL->getText(
											"TXT_KEY_MISC_IMP_DESTROYED_BY_MARAUDERS",
											GC.getImprovementInfo(pPlot->getImprovementType()).getTextKeyWide(),
											getNameKey(), getVisualCivAdjective(pPlot->getTeam())
										),
										"AS2D_PILLAGED", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_RED(),
										pPlot->getX(), pPlot->getY(), true, true
									);
								}
							}
							break;
						}
						case COMMERCE_RESEARCH:
						{
							if (isPillageResearch())
							{
								GET_TEAM(player.getTeam()).changeResearchProgress(player.getCurrentResearch(), iPillageGold, getOwner());
								if (isHuman())
								{
									AddDLLMessage(
										getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
										gDLL->getText(
											"TXT_KEY_MISC_PLUNDERED_RESEARCH_FROM_IMP",
											iPillageGold, GC.getImprovementInfo(pPlot->getImprovementType()).getTextKeyWide()
										),
										"AS2D_PILLAGE", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_GREEN(),
										pPlot->getX(), pPlot->getY()
									);
								}
							}
							break;
						}
						case COMMERCE_CULTURE:
						{
							break;
						}
						case COMMERCE_ESPIONAGE:
						{
							if (isPillageEspionage() && pPlot->getTeam() != NO_TEAM)
							{
								GET_TEAM(player.getTeam()).changeEspionagePointsAgainstTeam(pPlot->getTeam(), iPillageGold);
								if (isHuman())
								{
									AddDLLMessage(
										getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
										gDLL->getText(
											"TXT_KEY_MISC_PLUNDERED_ESPIONAGE_FROM_IMP",
											iPillageGold, GC.getImprovementInfo(pPlot->getImprovementType()).getTextKeyWide()
										),
										"AS2D_PILLAGE", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_GREEN(),
										pPlot->getX(), pPlot->getY()
									);
								}
							}
							break;
						}
					}
				}
				if (GET_PLAYER(ePlayerPillaged).isHuman())
				{
					CvWString szBuffer = gDLL->getText("TXT_KEY_MISC_IMP_DESTROYED", GC.getImprovementInfo(pPlot->getImprovementType()).getTextKeyWide(), getNameKey(), getVisualCivAdjective(pPlot->getTeam()));

					if (fInfluenceRatio > 0.0f)
					{
						szBuffer = szBuffer + CvString::format(" %s: -%.1f%%", gDLL->getText("TXT_KEY_TILE_INFLUENCE").GetCString(), fInfluenceRatio);
					}
					AddDLLMessage(
						ePlayerPillaged, false, GC.getEVENT_MESSAGE_TIME(), szBuffer,
						"AS2D_PILLAGED", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_RED(), pPlot->getX(), pPlot->getY(), true, true
					);
				}
				//	A pillage implies a source of danger even if we can't see it
				GET_PLAYER(ePlayerPillaged).addPlotDangerSource(pPlot, 100);
			}
		}
		pPlot->setImprovementType(GC.getImprovementInfo(pPlot->getImprovementType()).getImprovementPillage());
	}
	else if (pPlot->isRoute())
	{
		eTempRoute = pPlot->getRouteType();
		pPlot->setRouteType(NO_ROUTE, true); // XXX downgrade rail???

		// Afforess - Alert Player of Pillaged Routes
		if (ePlayerPillaged != NO_PLAYER)
		{
			// A pillage implies a source of danger even if we can't see it
			GET_PLAYER(ePlayerPillaged).addPlotDangerSource(pPlot, 100);

			if (GET_PLAYER(ePlayerPillaged).isHuman())
			{
				AddDLLMessage(
					pPlot->getOwner(), false, GC.getEVENT_MESSAGE_TIME(),
					gDLL->getText(
						"TXT_KEY_MISC_IMP_DESTROYED",
						GC.getRouteInfo(eTempRoute).getTextKeyWide(), getNameKey(),
						getVisualCivAdjective(pPlot->getTeam())
					)
					, "AS2D_PILLAGED", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_RED(),
					pPlot->getX(), pPlot->getY(), true, true
				);
			}
		}
	}
	changeMoves(GC.getMOVE_DENOMINATOR());

	if (GC.getGame().isModderGameOption(MODDERGAMEOPTION_IMPROVED_XP) && !pPlot->isRoute())
	{
		setExperience100(getExperience100() + getRandomMinExperienceTimes100(), -1);
	}
	else if (iPillageGold > 0 && pPlot->getOwner() != getOwner())
	{
		changeExperience100(iPillageGold);
	}
	addMission(CvMissionDefinition(MISSION_PILLAGE, pPlot, this));

	if (eTempImprovement != NO_IMPROVEMENT || eTempRoute != NO_ROUTE)
	{
		CvEventReporter::getInstance().unitPillage(this, eTempImprovement, eTempRoute, getOwner());
	}

	return true;
}


bool CvUnit::canPlunder(const CvPlot* pPlot, bool bTestVisible) const
{
	if (getDomainType() != DOMAIN_SEA)
	{
		return false;
	}

	if (!m_pUnitInfo->isPillage())
	{
		return false;
	}

	if (!pPlot->isWater() || pPlot->isFreshWater())
	{
		return false;
	}

	if (!pPlot->isValidDomainForAction(*this))
	{
		return false;
	}

	if (!bTestVisible && pPlot->getTeam() == getTeam())
	{
		return false;
	}

	return true;
}


bool CvUnit::plunder()
{
	if (!canPlunder(plot()))
	{
		return false;
	}
	setBlockading(true);
	finishMoves();

	return true;
}


void CvUnit::updatePlunder(int iChange, bool bUpdatePlotGroups)
{
	PROFILE_FUNC();

	const int iBlockadeRange = GC.getDefineINT("SHIP_BLOCKADE_RANGE");
	bool bChanged = false;

	if (bUpdatePlotGroups)
	{
		CvPlot::setDeferredPlotGroupRecalculationMode(true);
	}

	foreach_(CvPlot* pLoopPlot, plot()->rect(iBlockadeRange, iBlockadeRange))
	{
		if (!pLoopPlot->isWater() || pLoopPlot->area() != area())
		{
			continue;
		}
		const int iPathDist = GC.getMap().calculatePathDistance(plot(),pLoopPlot);

		/* BBAI NOTES:
		// There are rare issues where the path finder will return incorrect results for unknown reasons.
		// Seems to find a suboptimal path sometimes in partially repeatable circumstances.
		// The fix below is a hack to address the permanent one or two tile blockades which
		// would appear randomly, it should cause extra blockade clearing only very rarely.
		if (iPathDist > iBlockadeRange)
		{
			continue; // No blockading on other side of an isthmus
		}
		*/
		if (iPathDist < 0 || iPathDist > iBlockadeRange + 2)
		{
			continue;
		}
		for (int iTeam = 0; iTeam < MAX_TEAMS; ++iTeam)
		{
			if (isEnemy((TeamTypes)iTeam)
			&& (iPathDist <= iBlockadeRange || iChange == -1 && pLoopPlot->getBlockadedCount((TeamTypes)iTeam) > 0))
			{
				const bool bOldTradeNet = pLoopPlot->isTradeNetwork((TeamTypes)iTeam);

				pLoopPlot->changeBlockadedCount((TeamTypes)iTeam, iChange);

				if (bOldTradeNet != pLoopPlot->isTradeNetwork((TeamTypes)iTeam))
				{
					bChanged = true;
					if (bUpdatePlotGroups)
					{
						pLoopPlot->updatePlotGroup();
					}
				}
			}
		}
	}

	if (bChanged)
	{
		gDLL->getInterfaceIFace()->setDirty(BlockadedPlots_DIRTY_BIT, true);

		if (bUpdatePlotGroups)
		{
			CvPlot::setDeferredPlotGroupRecalculationMode(false);
		}
	}
}


int CvUnit::sabotageProb(const CvPlot* pPlot, ProbabilityTypes eProbStyle) const
{
	if (!pPlot->isOwned())
	{
		return 40 + 50 * (eProbStyle != PROBABILITY_LOW);
	}
	const int iProb = 40 / (pPlot->plotCount(PUF_canDefend, -1, -1, NULL, NO_PLAYER, pPlot->getTeam()) + 1);

	if (eProbStyle == PROBABILITY_LOW)
	{
		return iProb;
	}
	if (eProbStyle == PROBABILITY_HIGH)
	{
		return iProb + 50;
	}
	int iCounterSpyCount = pPlot->plotCount(PUF_isCounterSpy, -1, -1, NULL, NO_PLAYER, pPlot->getTeam());

	foreach_(const CvPlot* pLoopPlot, pPlot->adjacent())
	{
		iCounterSpyCount += pLoopPlot->plotCount(PUF_isCounterSpy, -1, -1, NULL, NO_PLAYER, pPlot->getTeam());
	}
	return iProb + 50 / (iCounterSpyCount + 1);
}


bool CvUnit::canSabotage(const CvPlot* pPlot, bool bTestVisible) const
{
	if (!m_pUnitInfo->isSabotage())
	{
		return false;
	}

	if (pPlot->getTeam() == getTeam() || pPlot->isCity())
	{
		return false;
	}

	if (pPlot->getImprovementType() == NO_IMPROVEMENT)
	{
		return false;
	}

	if (!bTestVisible && GET_PLAYER(getOwner()).getGold() < GC.getBASE_SPY_SABOTAGE_COST())
	{
		return false;
	}

	return true;
}


bool CvUnit::sabotage()
{
	if (!canSabotage(plot()))
	{
		return false;
	}

	CvPlot* pPlot = plot();

	GET_PLAYER(getOwner()).changeGold(-GC.getBASE_SPY_SABOTAGE_COST());

	if (GC.getGame().getSorenRandNum(100, "Spy: Sabotage") <= sabotageProb(pPlot))
	{
		pPlot->setImprovementType(GC.getImprovementInfo(pPlot->getImprovementType()).getImprovementPillage());

		finishMoves();

		const CvCity* pNearestCity = GC.getMap().findCity(pPlot->getX(), pPlot->getY(), pPlot->getOwner(), NO_TEAM, false);

		if (pNearestCity != NULL)
		{
			AddDLLMessage(
				getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
				gDLL->getText("TXT_KEY_MISC_SPY_SABOTAGED", getNameKey(), pNearestCity->getNameKey()),
				"AS2D_SABOTAGE", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_GREEN(), pPlot->getX(), pPlot->getY()
			);
			if (pPlot->isOwned())
			{
				AddDLLMessage(
					pPlot->getOwner(), false, GC.getEVENT_MESSAGE_TIME(),
					gDLL->getText("TXT_KEY_MISC_SABOTAGE_NEAR", pNearestCity->getNameKey()),
					"AS2D_SABOTAGE", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_RED(),
					pPlot->getX(), pPlot->getY(), true, true
				);
			}
		}

		if (pPlot->isActiveVisible(false))
		{
			NotifyEntity(MISSION_SABOTAGE);
		}
	}
	else // Caught red handed
	{
		if (plot()->isActiveVisible(false))
		{
			NotifyEntity(MISSION_SURRENDER);
		}

		if (pPlot->isOwned())
		{
			if (!isEnemy(pPlot->getTeam(), pPlot))
			{
				GET_PLAYER(pPlot->getOwner()).AI_changeMemoryCount(getOwner(), MEMORY_SPY_CAUGHT, 1);
			}
			AddDLLMessage(
				pPlot->getOwner(), false, GC.getEVENT_MESSAGE_TIME(),
				gDLL->getText(
					"TXT_KEY_MISC_SPY_CAUGHT_AND_KILLED",
					GET_PLAYER(getOwner()).getCivilizationAdjective(), getNameKey()
				),
				"AS2D_EXPOSE", MESSAGE_TYPE_INFO
			);
		}
		{
			AddDLLMessage(
				getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
				gDLL->getText("TXT_KEY_MISC_YOUR_SPY_CAUGHT", getNameKey()),
				"AS2D_EXPOSED", MESSAGE_TYPE_INFO
			);
		}

		kill(true, pPlot->getOwner(), true);
	}

	return true;
}


int CvUnit::destroyCost(const CvPlot* pPlot) const
{
	const CvCity* pCity = pPlot->getPlotCity();

	if (pCity == NULL)
	{
		return 0;
	}
	bool bLimited = false;

	if (pCity->isProductionUnit())
	{
		bLimited = isLimitedUnit(pCity->getProductionUnit());
	}
	else if (pCity->isProductionBuilding())
	{
		bLimited = isLimitedWonder(pCity->getProductionBuilding());
	}
	else if (pCity->isProductionProject())
	{
		bLimited = isLimitedProject(pCity->getProductionProject());
	}
	return
	(
		GC.getDefineINT("BASE_SPY_DESTROY_COST")
		+
		pCity->getProduction()
		*
		(
			bLimited
			?
			GC.getDefineINT("SPY_DESTROY_COST_MULTIPLIER_LIMITED")
			:
			GC.getDefineINT("SPY_DESTROY_COST_MULTIPLIER")
		)
	);
}


int CvUnit::destroyProb(const CvPlot* pPlot, ProbabilityTypes eProbStyle) const
{
	const CvCity* pCity = pPlot->getPlotCity();

	if (pCity == NULL)
	{
		return 0;
	}
	int iProb = 25 / (pPlot->plotCount(PUF_canDefend, -1, -1, NULL, NO_PLAYER, pPlot->getTeam()) + 1);

	if (eProbStyle != PROBABILITY_LOW)
	{
		if (eProbStyle != PROBABILITY_HIGH)
		{
			int iCounterSpyCount = pPlot->plotCount(PUF_isCounterSpy, -1, -1, NULL, NO_PLAYER, pPlot->getTeam());

			foreach_(const CvPlot* pLoopPlot, pPlot->adjacent())
			{
				iCounterSpyCount += pLoopPlot->plotCount(PUF_isCounterSpy, -1, -1, NULL, NO_PLAYER, pPlot->getTeam());
			}
			iProb += 50 / (iCounterSpyCount + 1);
		}
		else iProb += 50;
	}
	return iProb + std::min(25, pCity->getProductionTurnsLeft());
}


bool CvUnit::canDestroy(const CvPlot* pPlot, bool bTestVisible) const
{
	if (!m_pUnitInfo->isDestroy())
	{
		return false;
	}

	if (pPlot->getTeam() == getTeam())
	{
		return false;
	}

	const CvCity* pCity = pPlot->getPlotCity();

	if (pCity == NULL || pCity->getProduction() == 0)
	{
		return false;
	}

	if (!bTestVisible && GET_PLAYER(getOwner()).getGold() < destroyCost(pPlot))
	{
		return false;
	}

	return true;
}


bool CvUnit::destroy()
{
	CvCity* pCity;
	CvWString szBuffer;
	bool bCaught;

	if (!canDestroy(plot()))
	{
		return false;
	}

	bCaught = (GC.getGame().getSorenRandNum(100, "Spy: Destroy") > destroyProb(plot()));

	pCity = plot()->getPlotCity();
	FAssertMsg(pCity != NULL, "City is not assigned a valid value");

	GET_PLAYER(getOwner()).changeGold(-(destroyCost(plot())));

	if (!bCaught)
	{
		pCity->setProduction(pCity->getProduction() / 2);

		finishMoves();

		{

			szBuffer = gDLL->getText("TXT_KEY_MISC_SPY_DESTROYED_PRODUCTION", getNameKey(), pCity->getProductionNameKey(), pCity->getNameKey());
			AddDLLMessage(getOwner(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_DESTROY", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_GREEN(), pCity->getX(), pCity->getY());

			szBuffer = gDLL->getText("TXT_KEY_MISC_CITY_PRODUCTION_DESTROYED", pCity->getProductionNameKey(), pCity->getNameKey());
			AddDLLMessage(pCity->getOwner(), false, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_DESTROY", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_RED(), pCity->getX(), pCity->getY(), true, true);
		}

		if (plot()->isActiveVisible(false))
		{
			NotifyEntity(MISSION_DESTROY);
		}
		if (!isSpy())
		{
			changeExperience100(100);
		}
	}
	else
	{
		if (isSpy())
		{

			szBuffer = gDLL->getText("TXT_KEY_MISC_SPY_CAUGHT_AND_KILLED", GET_PLAYER(getOwner()).getCivilizationAdjective(), getNameKey());
			AddDLLMessage(pCity->getOwner(), false, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_EXPOSE", MESSAGE_TYPE_INFO);

			szBuffer = gDLL->getText("TXT_KEY_MISC_YOUR_SPY_CAUGHT", getNameKey());
			AddDLLMessage(getOwner(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_EXPOSED", MESSAGE_TYPE_INFO);

			if (plot()->isActiveVisible(false))
			{
				NotifyEntity(MISSION_SURRENDER);
			}

			kill(true, pCity->getOwner(), true);
		}
		else
		{

			szBuffer = gDLL->getText("TXT_KEY_MISC_CRIMINAL_CAUGHT", GET_PLAYER(getOwner()).getCivilizationAdjective(), getNameKey());
			AddDLLMessage(pCity->getOwner(), false, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_EXPOSE", MESSAGE_TYPE_INFO);

			szBuffer = gDLL->getText("TXT_KEY_MISC_YOUR_CRIMINAL_CAUGHT", getNameKey());
			AddDLLMessage(getOwner(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_EXPOSED", MESSAGE_TYPE_INFO);

			makeWanted(pCity);
		}


		if (!isEnemy(pCity->getTeam()))
		{
			GET_PLAYER(pCity->getOwner()).AI_changeMemoryCount(getOwner(), MEMORY_SPY_CAUGHT, 1);
		}
	}

	return true;
}


int CvUnit::stealPlansCost(const CvPlot* pPlot) const
{
	const CvCity* pCity = pPlot->getPlotCity();

	if (pCity == NULL)
	{
		return 0;
	}

	return (GC.getDefineINT("BASE_SPY_STEAL_PLANS_COST") + ((GET_TEAM(pCity->getTeam()).getTotalLand() + GET_TEAM(pCity->getTeam()).getTotalPopulation()) * GC.getDefineINT("SPY_STEAL_PLANS_COST_MULTIPLIER")));
}


// XXX compare with destroy prob...
int CvUnit::stealPlansProb(const CvPlot* pPlot, ProbabilityTypes eProbStyle) const
{
	const CvCity* pCity = pPlot->getPlotCity();
	if (pCity == NULL)
	{
		return 0;
	}

	int iProb = ((pCity->isGovernmentCenter()) ? 20 : 0); // XXX

	const int iDefenseCount = pPlot->plotCount(PUF_canDefend, -1, -1, NULL, NO_PLAYER, pPlot->getTeam());

	int iCounterSpyCount = pPlot->plotCount(PUF_isCounterSpy, -1, -1, NULL, NO_PLAYER, pPlot->getTeam());

	foreach_(const CvPlot* pLoopPlot, pPlot->adjacent())
	{
		iCounterSpyCount += pLoopPlot->plotCount(PUF_isCounterSpy, -1, -1, NULL, NO_PLAYER, pPlot->getTeam());
	}

	if (eProbStyle == PROBABILITY_HIGH)
	{
		iCounterSpyCount = 0;
	}

	iProb += (20 / (iDefenseCount + 1)); // XXX

	if (eProbStyle != PROBABILITY_LOW)
	{
		iProb += (50 / (iCounterSpyCount + 1)); // XXX
	}

	return iProb;
}


bool CvUnit::canStealPlans(const CvPlot* pPlot, bool bTestVisible) const
{
	if (!(m_pUnitInfo->isStealPlans()))
	{
		return false;
	}

	if (pPlot->getTeam() == getTeam())
	{
		return false;
	}

	if (isNPC())
	{
		return false;
	}

	if (pPlot->getPlotCity() == NULL)
	{
		return false;
	}

	if (!bTestVisible && GET_PLAYER(getOwner()).getGold() < stealPlansCost(pPlot))
	{
		return false;
	}

	return true;
}


bool CvUnit::stealPlans()
{
	CvCity* pCity;
	CvWString szBuffer;
	bool bCaught;

	if (!canStealPlans(plot()))
	{
		return false;
	}

	bCaught = (GC.getGame().getSorenRandNum(100, "Spy: Steal Plans") > stealPlansProb(plot()));

	pCity = plot()->getPlotCity();
	FAssertMsg(pCity != NULL, "City is not assigned a valid value");

	GET_PLAYER(getOwner()).changeGold(-(stealPlansCost(plot())));

	if (!bCaught)
	{
		GET_TEAM(getTeam()).changeStolenVisibilityTimer(pCity->getTeam(), 2);

		finishMoves();

		{

			szBuffer = gDLL->getText("TXT_KEY_MISC_SPY_STOLE_PLANS", getNameKey(), pCity->getNameKey());
			AddDLLMessage(getOwner(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_STEALPLANS", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_GREEN(), pCity->getX(), pCity->getY());

			szBuffer = gDLL->getText("TXT_KEY_MISC_PLANS_STOLEN", pCity->getNameKey());
			AddDLLMessage(pCity->getOwner(), false, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_STEALPLANS", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_RED(), pCity->getX(), pCity->getY(), true, true);
		}

		if (plot()->isActiveVisible(false))
		{
			NotifyEntity(MISSION_STEAL_PLANS);
		}
		if (!isSpy())
		{
			changeExperience100(100);
		}

	}
	else
	{
		if (isSpy())
		{

			szBuffer = gDLL->getText("TXT_KEY_MISC_SPY_CAUGHT_AND_KILLED", GET_PLAYER(getOwner()).getCivilizationAdjective(), getNameKey());
			AddDLLMessage(pCity->getOwner(), false, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_EXPOSE", MESSAGE_TYPE_INFO);

			szBuffer = gDLL->getText("TXT_KEY_MISC_YOUR_SPY_CAUGHT", getNameKey());
			AddDLLMessage(getOwner(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_EXPOSED", MESSAGE_TYPE_INFO);

			if (plot()->isActiveVisible(false))
			{
				NotifyEntity(MISSION_SURRENDER);
			}

			kill(true, pCity->getOwner(), true);
		}
		else
		{

			szBuffer = gDLL->getText("TXT_KEY_MISC_CRIMINAL_CAUGHT", GET_PLAYER(getOwner()).getCivilizationAdjective(), getNameKey());
			AddDLLMessage(pCity->getOwner(), false, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_EXPOSE", MESSAGE_TYPE_INFO);

			szBuffer = gDLL->getText("TXT_KEY_MISC_YOUR_CRIMINAL_CAUGHT", getNameKey());
			AddDLLMessage(getOwner(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_EXPOSED", MESSAGE_TYPE_INFO);

			makeWanted(pCity);
		}

		if (!isEnemy(pCity->getTeam()))
		{
			GET_PLAYER(pCity->getOwner()).AI_changeMemoryCount(getOwner(), MEMORY_SPY_CAUGHT, 1);
		}
	}

	return true;
}


bool CvUnit::canFound(const CvPlot* pPlot, bool bTestVisible) const
{
	if (!isFound())
	{
		return false;
	}

	if (!(GET_PLAYER(getOwner()).canFound(pPlot->getX(), pPlot->getY(), bTestVisible)))
	{
		return false;
	}

	return true;
}


bool CvUnit::found()
{
	CvPlot* pPlot = plot();

	if (pPlot == NULL)
	{
		return false;
	}

	if (!canFound(pPlot))
	{
		return false;
	}

	if (GC.getGame().getActivePlayer() == getOwner())
	{
		GC.getCurrentViewport()->bringIntoView(getX(), getY());
		//gDLL->getInterfaceIFace()->lookAt(plot()->getPoint(), CAMERALOOKAT_NORMAL);
	}

	GET_PLAYER(getOwner()).found(getX(), getY(), this);

	if (pPlot->isActiveVisible(false))
	{
		NotifyEntity(MISSION_FOUND);
	}

	//	For the AI we need to run the turn for the new city to get production set
	if ( !GET_PLAYER(getOwner()).isHuman() )
	{
		CvCity* pCity = pPlot->getPlotCity();

		FAssert(pCity!=NULL);
		if (pCity != NULL)//TB Debug note: unknown as to why, after the found statement above, this does not work in some cases to find the new city.
		{
			pCity->doTurn();
		}
	}

	kill(true, NO_PLAYER, true);

	return true;
}


bool CvUnit::canSpread(const CvPlot* pPlot, ReligionTypes eReligion, bool bTestVisible) const
{
	PROFILE_FUNC();

	if (eReligion == NO_RELIGION || m_pUnitInfo->getReligionSpreads(eReligion) <= 0)
	{
		return false;
	}

	CvCity* pCity = pPlot->getPlotCity();

	if (pCity == NULL || pCity->isHasReligion(eReligion))
	{
		return false;
	}

	if (!canEnterArea(pPlot->getTeam(), pPlot->area()))
	{
		return false;
	}

	if (!bTestVisible && pCity->getTeam() != getTeam()
	&& GET_PLAYER(pCity->getOwner()).isNoNonStateReligionSpread()
	&& eReligion != GET_PLAYER(pCity->getOwner()).getStateReligion())
	{
		return false;
	}

	// TB Prophet Mod
	if (AI_getUnitAIType() != UNITAI_MISSIONARY)
	{
		if (!GC.getGame().isOption(GAMEOPTION_DIVINE_PROPHETS)
		|| GC.getGame().isOption(GAMEOPTION_LIMITED_RELIGIONS) && GET_PLAYER(getOwner()).hasHolyCity())
		{
			return false;
		}

		if (!GC.getGame().isOption(GAMEOPTION_PICK_RELIGION))
		{
			const TechTypes ePreqTech = GC.getReligionInfo(eReligion).getTechPrereq();

			if (!GC.getGame().isTechDiscovered(ePreqTech)
			|| !GET_TEAM(getTeam()).isHasTech(ePreqTech)
			&& GC.getGame().getGameTurn() <= GC.getGame().getTechGameTurnDiscovered(ePreqTech) + 1)
			{
				return false;
			}
		}
	}
	// ! TB Prophet Mod

	return true;
}


bool CvUnit::spread(ReligionTypes eReligion)
{
	if (!canSpread(plot(), eReligion))
	{
		return false;
	}
	CvCity* pCity = plot()->getPlotCity();

	if (pCity != NULL)
	{
		if (GC.getGame().isReligionFounded(eReligion))
		{
			int iSpreadProb = m_pUnitInfo->getReligionSpreads(eReligion);

			if ((ReligionTypes)GET_PLAYER(getOwner()).getStateReligion() == eReligion)
			{
				iSpreadProb += GET_PLAYER(getOwner()).getExtraStateReligionSpreadModifier();
			}
			else iSpreadProb += GET_PLAYER(getOwner()).getExtraNonStateReligionSpreadModifier();

			if (pCity->getTeam() != getTeam())
			{
				iSpreadProb /= 2;
			}

			iSpreadProb += (GC.getNumReligionInfos() - pCity->getReligionCount()) * (100 - iSpreadProb) / GC.getNumReligionInfos();
			const bool bSuccess = GC.getGame().getSorenRandNum(100, "Unit Spread Religion") < iSpreadProb;

			// Python Event
			CvEventReporter::getInstance().unitSpreadReligionAttempt(this, eReligion, bSuccess);

			if (!bSuccess)
			{
				// Python event above may have spread the religion, it's fine if it did.
				if (!pCity->isHasReligion(eReligion))
				{
					AddDLLMessage(
						getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
						gDLL->getText(
							"TXT_KEY_MISC_RELIGION_FAILED_TO_SPREAD",
							getNameKey(),
							GC.getReligionInfo(eReligion).getChar(),
							pCity->getNameKey()
						),
						"AS2D_NOSPREAD", MESSAGE_TYPE_INFO, getButton(),
						GC.getCOLOR_RED(), pCity->getX(), pCity->getY()
					);
				}
			}
			else pCity->setHasReligion(eReligion, true, true, false);
		}
		else // Divine Prophet is founding religion here; always 100% chance.
		{
			GC.getGame().setHolyCity(eReligion, pCity, true);
			GC.getGame().setReligionSlotTaken(eReligion, true);
			pCity->setHasReligion(eReligion, true, true, false);
		}
	}

	if (plot()->isActiveVisible(false))
	{
		NotifyEntity(MISSION_SPREAD);
	}

	kill(true, NO_PLAYER, true);

	return true;
}


bool CvUnit::canSpreadCorporation(const CvPlot* pPlot, CorporationTypes eCorporation, bool bTestVisible) const
{
	if (NO_CORPORATION == eCorporation)
	{
		return false;
	}

	if (!GET_PLAYER(getOwner()).isActiveCorporation(eCorporation))
	{
		return false;
	}

	if (m_pUnitInfo->getCorporationSpreads(eCorporation) <= 0)
	{
		return false;
	}

	const CvCity* pCity = pPlot->getPlotCity();

	if (NULL == pCity)
	{
		return false;
	}

	if (pCity->isHasCorporation(eCorporation))
	{
		return false;
	}
/************************************************************************************************/
/* Afforess	                  Start		 01/17/10                                               */
/*                                                                                              */
/*   Blocks obsolete Corps from spreading                                                       */
/************************************************************************************************/
	if (GC.getCorporationInfo(eCorporation).getObsoleteTech() != NO_TECH)
	{
		if (GET_TEAM(GET_PLAYER(pCity->getOwner()).getTeam()).isHasTech(GC.getCorporationInfo(eCorporation).getObsoleteTech()))
		{
			return false;
		}
	}
	if (GC.getGame().isOption(GAMEOPTION_REALISTIC_CORPORATIONS))
	{
		if (!GC.getGame().isModderGameOption(MODDERGAMEOPTION_NO_AUTO_CORPORATION_FOUNDING))
		{
			return false;
		}
	}
	if (!GC.getGame().canEverSpread(eCorporation))
	{
		return false;
	}
	if (!bTestVisible)
	{
		for (int iI = 0; iI < GC.getNumBuildingInfos(); iI++)
		{
			if (GC.getCorporationInfo(eCorporation).getPrereqBuilding(iI) > 0)
			{
				if (GET_PLAYER(pCity->getOwner()).getBuildingCount((BuildingTypes)iI) < GC.getCorporationInfo(eCorporation).getPrereqBuilding(iI))
				{
					return false;
				}
			}
		}
	}
/************************************************************************************************/
/* Afforess	                     END                                                            */
/************************************************************************************************/

	if (!canEnterArea(pPlot->getTeam(), pPlot->area()))
	{
		return false;
	}

	if (!bTestVisible)
	{
		if (!GET_PLAYER(pCity->getOwner()).isActiveCorporation(eCorporation))
		{
			return false;
		}

		for (int iCorporation = 0; iCorporation < GC.getNumCorporationInfos(); ++iCorporation)
		{
			if (pCity->isHeadquarters((CorporationTypes)iCorporation))
			{
				if (GC.getGame().isCompetingCorporation((CorporationTypes)iCorporation, eCorporation))
				{
					return false;
				}
			}
		}
		// Afforess: Some corporations don't require any resources...
		bool bValid = false;
		bool bRequiresBonus = false;
		foreach_(const BonusTypes eBonus, GC.getCorporationInfo(eCorporation).getPrereqBonuses())
		{
			bRequiresBonus = true;
			if (pCity->hasBonus(eBonus))
			{
				bValid = true;
				break;
			}
		}
		if (!bValid && bRequiresBonus)
		{
			return false;
		}

		if (GET_PLAYER(getOwner()).getGold() < spreadCorporationCost(eCorporation, pCity))
		{
			return false;
		}
	}

	return true;
}

int CvUnit::spreadCorporationCost(CorporationTypes eCorporation, const CvCity* pCity) const
{
	int iCost = std::max(0, GC.getCorporationInfo(eCorporation).getSpreadCost() * (100 + GET_PLAYER(getOwner()).calculateInflationRate()));
	iCost /= 100;

	if (NULL != pCity)
	{
		if (getTeam() != pCity->getTeam() && !GET_TEAM(pCity->getTeam()).isVassal(getTeam()))
		{
			iCost *= GC.getDefineINT("CORPORATION_FOREIGN_SPREAD_COST_PERCENT");
			iCost /= 100;
		}

		for (int iCorp = 0; iCorp < GC.getNumCorporationInfos(); ++iCorp)
		{
			if (iCorp != eCorporation && pCity->isActiveCorporation((CorporationTypes)iCorp)
			&& GC.getGame().isCompetingCorporation(eCorporation, (CorporationTypes)iCorp))
			{
				iCost *= 100 + GC.getCorporationInfo((CorporationTypes)iCorp).getSpreadFactor();
				iCost /= 100;
			}
		}
	}
	return iCost;
}

bool CvUnit::spreadCorporation(CorporationTypes eCorporation)
{
	int iSpreadProb;

	if (!canSpreadCorporation(plot(), eCorporation))
	{
		return false;
	}

	CvCity* pCity = plot()->getPlotCity();

	if (NULL != pCity)
	{
		GET_PLAYER(getOwner()).changeGold(-spreadCorporationCost(eCorporation, pCity));

		iSpreadProb = m_pUnitInfo->getCorporationSpreads(eCorporation);

		if (pCity->getTeam() != getTeam())
		{
			iSpreadProb /= 2;
		}

		iSpreadProb += (((GC.getNumCorporationInfos() - pCity->getCorporationCount()) * (100 - iSpreadProb)) / GC.getNumCorporationInfos());

		if (GC.getGame().getSorenRandNum(100, "Unit Spread Corporation") < iSpreadProb)
		{
			pCity->setHasCorporation(eCorporation, true, true, false);
		}
		else
		{

			const CvWString szBuffer = gDLL->getText("TXT_KEY_MISC_CORPORATION_FAILED_TO_SPREAD", getNameKey(), GC.getCorporationInfo(eCorporation).getChar(), pCity->getNameKey());
			AddDLLMessage(getOwner(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_NOSPREAD", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_RED(), pCity->getX(), pCity->getY());
		}
	}

	if (plot()->isActiveVisible(false))
	{
		NotifyEntity(MISSION_SPREAD_CORPORATION);
	}

	kill(true, NO_PLAYER, true);

	return true;
}


bool CvUnit::canJoin(const CvPlot* pPlot, SpecialistTypes eSpecialist) const
{
	if (eSpecialist == NO_SPECIALIST)
	{
		return false;
	}

	if (isCommander() || isDelayedDeath())
	{
		return false;
	}

	if (!m_pUnitInfo->getGreatPeoples(eSpecialist))
	{
		return false;
	}

	const CvCity* pCity = pPlot->getPlotCity();

	if (pCity == NULL || pCity->getTeam() != getTeam())
	{
		return false;
	}

	return true;
}


bool CvUnit::join(SpecialistTypes eSpecialist)
{
	CvCity* pCity;

	if (!canJoin(plot(), eSpecialist))
	{
		return false;
	}

	pCity = plot()->getPlotCity();

	if (pCity != NULL)
	{
		pCity->changeFreeSpecialistCount(eSpecialist, 1, true);
	}

	if (plot()->isActiveVisible(false))
	{
		NotifyEntity(MISSION_JOIN);
	}

	getGroup()->AI_setMissionAI(MISSIONAI_DELIBERATE_KILL, NULL, NULL);
	kill(true, NO_PLAYER, true);

	return true;
}


bool CvUnit::canConstruct(const CvPlot* pPlot, BuildingTypes eBuilding, bool bTestVisible) const
{
	if (eBuilding == NO_BUILDING || !m_pUnitInfo->getHasBuilding(eBuilding))
	{
		return false;
	}

	if (isDelayedDeath() || isCommander())
	{
		return false;
	}

	if (!canPerformActionSM())
	{
		return false;
	}

	if (GC.getBuildingInfo(eBuilding).getGlobalReligionCommerce() > NO_RELIGION
	&& GC.getBuildingInfo(eBuilding).getProductionCost() == -1
	&& GC.getGame().getBuildingCreatedCount(eBuilding) > 0)
	{
		return false;
	}

	CvCity* pCity = pPlot->getPlotCity();

	if (pCity == NULL || getTeam() != pCity->getTeam())
	{
		return false;
	}

	if (pCity->getNumRealBuilding(eBuilding) > 0)
	{
		return false;
	}

	if (!pCity->canConstruct(eBuilding, false, bTestVisible, true))
	{
		return false;
	}

	return true;
}


bool CvUnit::construct(BuildingTypes eBuilding)
{
	CvCity* pCity;

	if (!canConstruct(plot(), eBuilding))
	{
		return false;
	}

	pCity = plot()->getPlotCity();

	if (pCity != NULL)
	{
		pCity->setNumRealBuilding(eBuilding, 1);

		CvEventReporter::getInstance().buildingBuilt(pCity, eBuilding);
	}

	if (plot()->isActiveVisible(false))
	{
		NotifyEntity(MISSION_CONSTRUCT);
	}

	GET_PLAYER(getOwner()).NoteUnitConstructed(eBuilding);

	getGroup()->AI_setMissionAI(MISSIONAI_DELIBERATE_KILL, NULL, NULL);
	kill(true, NO_PLAYER, true);

	return true;
}


TechTypes CvUnit::getDiscoveryTech() const
{
	return ::getDiscoveryTech(getUnitType(), getOwner());
}


int CvUnit::getDiscoverResearch(TechTypes eTech) const
{
	int iResearch = m_pUnitInfo->getBaseDiscover() + m_pUnitInfo->getDiscoverMultiplier() * GET_TEAM(getTeam()).getTotalPopulation();

	iResearch *= GC.getGameSpeedInfo(GC.getGame().getGameSpeedType()).getSpeedPercent();
	iResearch /= 100;

    if (eTech != NO_TECH)
    {
        iResearch = std::min(GET_TEAM(getTeam()).getResearchLeft(eTech), iResearch);
    }
	return std::max(0, iResearch);
}


bool CvUnit::canDiscover() const
{
	const TechTypes eTech = getDiscoveryTech();

	if (eTech == NO_TECH)
	{
		return false;
	}

	if (getDiscoverResearch(eTech) == 0)
	{
		return false;
	}

	if (isDelayedDeath())
	{
		return false;
	}

	return true;
}


bool CvUnit::discover()
{
	if (!canDiscover())
	{
		return false;
	}

	const TechTypes eDiscoveryTech = getDiscoveryTech();
	FAssertMsg(eDiscoveryTech != NO_TECH, "DiscoveryTech is not assigned a valid value");

	GET_TEAM(getTeam()).changeResearchProgress(eDiscoveryTech, getDiscoverResearch(eDiscoveryTech), getOwner());

	if (plot()->isActiveVisible(false))
	{
		NotifyEntity(MISSION_DISCOVER);
	}

	kill(true, NO_PLAYER, true);

	return true;
}


int CvUnit::getMaxHurryProduction(const CvCity* pCity) const
{
	int iProduction = (m_pUnitInfo->getBaseHurry() + (m_pUnitInfo->getHurryMultiplier() * pCity->getPopulation()));

	iProduction *= GC.getGameSpeedInfo(GC.getGame().getGameSpeedType()).getHammerCostPercent();
	iProduction /= 100;

	return std::max(0, iProduction);
}


int CvUnit::getHurryProduction(const CvPlot* pPlot) const
{
	const CvCity* pCity = pPlot->getPlotCity();

	if (pCity == NULL)
	{
		return 0;
	}

	int iProduction = std::min(pCity->productionLeft(), getMaxHurryProduction(pCity));

	return std::max(0, iProduction);
}


bool CvUnit::canHurry(const CvPlot* pPlot, bool bTestVisible) const
{
	if (isDelayedDeath() || getHurryProduction(pPlot) == 0)
	{
		return false;
	}

	const CvCity* pCity = pPlot->getPlotCity();

	if (pCity == NULL || getTeam() != pCity->getTeam())
	{
		return false;
	}

	if (!bTestVisible)
	{
		if (!(pCity->isProductionBuilding()))
		{
			return false;
		}
	}

	return true;
}


bool CvUnit::hurry()
{
	if (!canHurry(plot()))
	{
		return false;
	}

	CvCity* pCity = plot()->getPlotCity();

	if (pCity != NULL)
	{
		pCity->changeProduction(getHurryProduction(plot()));
	}

	if (plot()->isActiveVisible(false))
	{
		NotifyEntity(MISSION_HURRY);
	}

	kill(true, NO_PLAYER, true);

	return true;
}


int CvUnit::getTradeGold(const CvPlot* pPlot) const
{
	CvCity* pCity = pPlot->getPlotCity();

	if (pCity == NULL || pCity == getCityOfOrigin())
	{
		return 0;
	}
	CvCity* pCapitalCity = GET_PLAYER(pPlot->getOwner()).getCapitalCity();

	int iMult = m_pUnitInfo->getTradeMultiplier();

	int iGold = m_pUnitInfo->getBaseTrade() + iMult * ((pCapitalCity != NULL) ? pCity->calculateTradeProfit(pCapitalCity) : 0);

	iGold *= (pPlot->getOwner() != getOwner() ? iMult : 1);

	iGold *= pCity->getPopulation();
	iGold /= 10;

	CvPlot* cPlot = GC.getMap().plot(m_iXOrigin, m_iYOrigin);
	int iMaxDistance = GC.getMap().maxPlotDistance();
	if (cPlot != NULL)
	{
		iGold *= iMaxDistance + plotDistance(m_iXOrigin, m_iYOrigin, pPlot->getX(), pPlot->getY());
		iGold /= iMaxDistance;
	}

	iGold = getModifiedIntValue(iGold, GC.getTRADE_MISSION_END_TOTAL_PERCENT_ADJUSTMENT() + GET_TEAM(getTeam()).getTradeMissionModifier());

	iGold *= GC.getGameSpeedInfo(GC.getGame().getGameSpeedType()).getSpeedPercent();
	iGold /= 100;

	return std::max(0, iGold);
}


bool CvUnit::canTrade(const CvPlot* pPlot, bool bTestVisible) const
{
	if (isDelayedDeath())
	{
		return false;
	}

	if (!canPerformActionSM())
	{
		return false;
	}

	const CvCity* pCity = pPlot->getPlotCity();

	if (pCity == NULL)
	{
		return false;
	}

	if (getTradeGold(pPlot) == 0)
	{
		return false;
	}

	if (!canEnterArea(pPlot->getTeam(), pPlot->area()))
	{
		return false;
	}

	if (!bTestVisible)
	{
		if (pCity->getTeam() == getTeam())
		{
			return false;
		}
	}

	return true;
}


bool CvUnit::trade()
{
	if (!canTrade(plot()))
	{
		return false;
	}


	if (plot()->isActiveVisible(false))
	{
		NotifyEntity(MISSION_TRADE);
	}

	//if is criminal then must pass an investigation check or fail and become wanted.  If passes the check, then send back to capital.
	CvCity* pCapital = getCityOfOrigin();

	if (isCriminal())
	{
		if (!criminalSuccessCheck())
		{
			finishMoves();
			return true;
		}
		changeExperience100(10);
		GET_PLAYER(getOwner()).changeGold(getTradeGold(plot()));
		finishMoves();
		if (pCapital != NULL)
		{
			setXY(pCapital->getX(), pCapital->getY(), false, true, true, false, false);
		}
		return true;
	}

	GET_PLAYER(getOwner()).changeGold(getTradeGold(plot()));
	//if is Great Person then kill

	//otherwise send back to capital
	if (!isGoldenAge() && pCapital != NULL)
	{
		changeExperience100(10);
		setXY(pCapital->getX(), pCapital->getY(), false, true, true, false, false);
	}
	else
	{
		kill(true, NO_PLAYER, true);
	}

	return true;
}


int CvUnit::getGreatWorkCulture() const
{
	int iCulture = m_pUnitInfo->getGreatWorkCulture();

	iCulture *= GC.getGameSpeedInfo(GC.getGame().getGameSpeedType()).getSpeedPercent();
	iCulture /= 100;

	return std::max(0, iCulture);
}


bool CvUnit::canGreatWork(const CvPlot* pPlot) const
{
	if (isDelayedDeath())
	{
		return false;
	}

	const CvCity* pCity = pPlot->getPlotCity();

	if (pCity == NULL)
	{
		return false;
	}

	if (pCity->getOwner() != getOwner())
	{
		return false;
	}

	if (getGreatWorkCulture() == 0)
	{
		return false;
	}

	return true;
}


bool CvUnit::greatWork()
{
	if (!canGreatWork(plot()))
	{
		return false;
	}

	CvCity* pCity = plot()->getPlotCity();

	if (pCity != NULL)
	{
		pCity->setCultureUpdateTimer(0);
		pCity->setOccupationTimer(0);

		const int iCultureToAdd = 100 * getGreatWorkCulture();
		const int iNumTurnsApplied = GC.getDefineINT("GREAT_WORKS_CULTURE_TURNS") * GC.getGameSpeedInfo(GC.getGame().getGameSpeedType()).getSpeedPercent() / 100;

		for (int i = 0; i < iNumTurnsApplied; ++i)
		{
			pCity->changeCultureTimes100(getOwner(), iCultureToAdd / iNumTurnsApplied, true, true);
		}

		if (iNumTurnsApplied > 0)
		{
			pCity->changeCultureTimes100(getOwner(), iCultureToAdd % iNumTurnsApplied, false, true);
		}
	}

	if (plot()->isActiveVisible(false))
	{
		NotifyEntity(MISSION_GREAT_WORK);
	}

	kill(true, NO_PLAYER, true);

	return true;
}

bool CvUnit::doOutcomeMission(MissionTypes eMission)
{
	CvOutcomeMission* pOutcomeMission = getUnitInfo().getOutcomeMissionByMission(eMission);

	if (!pOutcomeMission)
	{
		// Outcome missions on unit combats
		for (int iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
		{
			if (isHasUnitCombat((UnitCombatTypes)iI))
			{
				pOutcomeMission = GC.getUnitCombatInfo((UnitCombatTypes)iI).getOutcomeMissionByMission(eMission);
				if (pOutcomeMission)
				{
					break;
				}
			}
		}
	}

	if (!pOutcomeMission)
	{
		return false;
	}

	if (!pOutcomeMission->isPossible(this))
	{
		return false;
	}

	pOutcomeMission->execute(this);

	if (plot()->isActiveVisible(false))
	{
		NotifyEntity(eMission);
	}

	if (pOutcomeMission->isKill())
	{
		getGroup()->AI_setMissionAI(MISSIONAI_DELIBERATE_KILL, NULL, NULL);
		kill(true);
	}

	return true;
}


int CvUnit::getEspionagePoints() const
{
	int iEspionagePoints = m_pUnitInfo->getEspionagePoints();

	iEspionagePoints *= GC.getGameSpeedInfo(GC.getGame().getGameSpeedType()).getSpeedPercent();
	iEspionagePoints /= 100;

	return std::max(0, iEspionagePoints);
}

bool CvUnit::canInfiltrate() const
{
	if (isDelayedDeath() || isNPC() || getEspionagePoints() == 0)
	{
		return false;
	}
	return true;
}

bool CvUnit::canInfiltrate(const CvPlot* pPlot, bool bTestVisible) const
{
	if (!canInfiltrate())
	{
		return false;
	}
	const CvCity* pCity = pPlot->getPlotCity();

	if (pCity == NULL || pCity->isNPC())
	{
		return false;
	}
	if (!bTestVisible && pCity->getTeam() == getTeam())
	{
		return false;
	}
	if (!isInvisible(pCity->getTeam(), false, true))
	{
		return false;
	}
	return true;
}


bool CvUnit::infiltrate()
{
	if (!canInfiltrate(plot()))
	{
		return false;
	}

	int iPoints = getEspionagePoints();

	int iPointsAdj = (GC.getINFILTRATE_MISSION_END_TOTAL_PERCENT_ADJUSTMENT() * iPoints) / 100;

	iPoints += iPointsAdj;

	if (plot()->isActiveVisible(false))
	{
		NotifyEntity(MISSION_INFILTRATE);
	}

	if (!isSpy())
	{
		if (criminalSuccessCheck())
		{
			changeExperience100(100);
			GET_TEAM(getTeam()).changeEspionagePointsAgainstTeam(GET_PLAYER(plot()->getOwner()).getTeam(), iPoints);
			GET_TEAM(getTeam()).changeEspionagePointsEver(iPoints);

			const CvCity* pCapital = GET_PLAYER(getOwner()).getCapitalCity();
			if (pCapital != NULL)
			{
				finishMoves();
				setXY(pCapital->getX(), pCapital->getY(), false, true, true, false, false);
			}
			else
			{
				kill(true, NO_PLAYER, true);
			}
		}
		else
		{
			finishMoves();
		}
	}
	else
	{
		GET_TEAM(getTeam()).changeEspionagePointsAgainstTeam(GET_PLAYER(plot()->getOwner()).getTeam(), iPoints);
		GET_TEAM(getTeam()).changeEspionagePointsEver(iPoints);
		kill(true, NO_PLAYER, true);
	}

	return true;
}


bool CvUnit::canEspionage(const CvPlot* pPlot, bool bTestVisible) const
{
	if (isDelayedDeath() || !isSpy())
	{
		return false;
	}

	const PlayerTypes ePlotOwner = pPlot->getOwner();
	if (NO_PLAYER == ePlotOwner)
	{
		return false;
	}

	const CvPlayer& kTarget = GET_PLAYER(ePlotOwner);

	if (kTarget.isNPC())
	{
		return false;
	}

	if (kTarget.getTeam() == getTeam())
	{
		return false;
	}

	if (GET_TEAM(getTeam()).isVassal(kTarget.getTeam()))
	{
		return false;
	}

	if (!bTestVisible)
	{
		if (isMadeAttack())
		{
			return false;
		}

		if (hasMoved())
		{
			return false;
		}

		if (kTarget.getTeam() != getTeam() && !isInvisible(kTarget.getTeam(), false))
		{
			return false;
		}
	}

	return true;
}

//TSHEEP start
bool CvUnit::awardSpyExperience(TeamTypes eTargetTeam, int iModifier)
{
	if (GC.isSS_ENABLED())
	{
		const int iDifficulty = getSpyInterceptPercent(eTargetTeam) * (100 + iModifier) / 100;
		if (iDifficulty < 1)
			changeExperience(1);
		else if (iDifficulty < 10)
			changeExperience(2);
		else if (iDifficulty < 25)
			changeExperience(3);
		else if (iDifficulty < 50)
			changeExperience(4);
		else if (iDifficulty < 75)
			changeExperience(5);
		else
			changeExperience(6);
		return true;
	}
	return false;
}
//TSHEEP End


bool CvUnit::canAssassin(const CvPlot* pPlot, bool bTestVisible) const
{
	if (isDelayedDeath())
	{
		return false;
	}

	if (!isSpy())
	{
		return false;
	}

	const CvCity* pCity = pPlot->getPlotCity();
	if (NULL == pCity)
	{
		return false;
	}

	const int numGreatPeople = pCity->getNumGreatPeople();
	if (numGreatPeople <= 0)
	{
		return false;
	}

	const CvPlayer& kTarget = GET_PLAYER(pCity->getOwner());

	if (kTarget.getTeam() == getTeam())
	{
		return false;
	}

	if (kTarget.isNPC())
	{
		return false;
	}

	if (GET_TEAM(getTeam()).isVassal(kTarget.getTeam()))
	{
		return false;
	}

	if (!bTestVisible)
	{
		if (isMadeAttack())
		{
			return false;
		}

		if (hasMoved())
		{
			return false;
		}

		if (kTarget.getTeam() != getTeam() && !isInvisible(kTarget.getTeam(), false))
		{
			return false;
		}
	}

	return true;
}

bool CvUnit::canBribe(const CvPlot* pPlot, bool bTestVisible) const
{
	if (isDelayedDeath())
	{
		return false;
	}

	if (!isSpy())
	{
		return false;
	}

	if(pPlot->plotCount(PUF_isOtherTeam, getOwner(), -1, NULL, NO_PLAYER, NO_TEAM, PUF_isVisible, getOwner()) < 1)
	{
		return false;
	}

	if (pPlot->plotCount(PUF_isUnitAIType, UNITAI_WORKER, -1) < 1)
	{
		return false;
	}

	const CvUnit* pTargetUnit = pPlot->plotCheck(PUF_isOtherTeam, getOwner(), -1, NULL, NO_PLAYER, NO_TEAM, PUF_isVisible, getOwner());
	const CvPlayer& kTarget = GET_PLAYER(pTargetUnit->getOwner());

	if (kTarget.getTeam() == getTeam())
	{
		return false;
	}

	if (kTarget.isNPC())
	{
		return false;
	}

	if (GET_TEAM(getTeam()).isVassal(kTarget.getTeam()))
	{
		return false;
	}

	if (!bTestVisible)
	{
		if (isMadeAttack())
		{
			return false;
		}

		if (hasMoved())
		{
			return false;
		}

		if (kTarget.getTeam() != getTeam() && !isInvisible(kTarget.getTeam(), false))
		{
			return false;
		}
	}

	return true;
}


bool CvUnit::espionage(EspionageMissionTypes eMission, int iData)
{
	if (!canEspionage(plot()))
	{
		return false;
	}

	PlayerTypes eTargetPlayer = plot()->getOwner();

	if (NO_ESPIONAGEMISSION == eMission)
	{
		FAssert(GET_PLAYER(getOwner()).isHuman());
		CvPopupInfo* pInfo = new CvPopupInfo(BUTTONPOPUP_DOESPIONAGE);
		if (NULL != pInfo)
		{
			gDLL->getInterfaceIFace()->addPopup(pInfo, getOwner(), true);
		}
	}
	else if (GC.getEspionageMissionInfo(eMission).isTwoPhases() && -1 == iData)
	{
		FAssert(GET_PLAYER(getOwner()).isHuman());
		CvPopupInfo* pInfo = new CvPopupInfo(BUTTONPOPUP_DOESPIONAGE_TARGET);
		if (NULL != pInfo)
		{
			pInfo->setData1(eMission);
			gDLL->getInterfaceIFace()->addPopup(pInfo, getOwner(), true);
		}
	}
	else
	{
		if (testSpyIntercepted(eTargetPlayer, GC.getEspionageMissionInfo(eMission).getDifficultyMod()))
		{
			return false;
		}

		const bool bCaught = testSpyIntercepted(eTargetPlayer, GC.getDefineINT("ESPIONAGE_SPY_MISSION_ESCAPE_MOD"));

		if (GET_PLAYER(getOwner()).doEspionageMission(eMission, eTargetPlayer, plot(), iData, this, (bCaught && !isAlwaysHeal())))
		{
			// If it died in the mission (e.g. - nuke and blew itself up) then nothing else needs doing
			if (!isDelayedDeath())
			{
				if (plot()->isActiveVisible(false))
				{
					NotifyEntity(MISSION_ESPIONAGE);
				}

				if (!bCaught)
				{
					setFortifyTurns(0);
					setMadeAttack(true);
					finishMoves();

					// Afforess 07/12/10
					// Spy actions that aren't in a city don't cause the spy to be sent back
					if (plot()->isCity())
					{
						const CvCity* pCapital = GET_PLAYER(getOwner()).getCapitalCity();

						if (NULL != pCapital)
						{
							if (!pCapital->isInViewport())
							{
								GC.getCurrentViewport()->bringIntoView(pCapital->getX(), pCapital->getY(), NULL, true);
							}
							//GC.getGame().logOOSSpecial(20, getID(), pCapital->getX(), pCapital->getY());
							setXY(pCapital->getX(), pCapital->getY(), false, false, false);


							const CvWString szBuffer = gDLL->getText("TXT_KEY_ESPIONAGE_SPY_SUCCESS", getNameKey(), pCapital->getNameKey());
							AddDLLMessage(getOwner(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_POSITIVE_DINK", MESSAGE_TYPE_INFO,
								getButton(), GC.getCOLOR_WHITE(), pCapital->getX(), pCapital->getY(), true, true);
						}
					}
					//TSHEEP Give spies xp for successful missions
					awardSpyExperience(GET_PLAYER(eTargetPlayer).getTeam(),GC.getEspionageMissionInfo(eMission).getDifficultyMod());
				}
			}
			return true;
		}
	}
	return false;
}

bool CvUnit::testSpyIntercepted(PlayerTypes eTargetPlayer, int iModifier)
{
	CvPlayer& kTargetPlayer = GET_PLAYER(eTargetPlayer);

	if (kTargetPlayer.isNPC())
	{
		return false;
	}

	if (GC.getGame().getSorenRandNum(10000, "Spy Interception") >= getSpyInterceptPercent(kTargetPlayer.getTeam()) * (100 + iModifier))
	{
		return false;
	}

	CvString szFormatNoReveal;
	CvString szFormatReveal;

	if (GET_TEAM(kTargetPlayer.getTeam()).getCounterespionageModAgainstTeam(getTeam()) > 0)
	{
		szFormatNoReveal = "TXT_KEY_SPY_INTERCEPTED_MISSION";
		szFormatReveal = "TXT_KEY_SPY_INTERCEPTED_MISSION_REVEAL";
	}
	else if (plot()->isEspionageCounterSpy(kTargetPlayer.getTeam()))
	{
		szFormatNoReveal = "TXT_KEY_SPY_INTERCEPTED_SPY";
		szFormatReveal = "TXT_KEY_SPY_INTERCEPTED_SPY_REVEAL";
	}
	else
	{
		szFormatNoReveal = "TXT_KEY_SPY_INTERCEPTED";
		szFormatReveal = "TXT_KEY_SPY_INTERCEPTED_REVEAL";
	}

	CvWString szCityName = kTargetPlayer.getCivilizationShortDescription();
	CvCity* pClosestCity = GC.getMap().findCity(getX(), getY(), eTargetPlayer, kTargetPlayer.getTeam(), true, false);
	if (pClosestCity != NULL)
	{
		szCityName = pClosestCity->getName();
	}

	CvWString szBuffer = gDLL->getText(szFormatReveal.GetCString(), GET_PLAYER(getOwner()).getCivilizationAdjectiveKey(), getNameKey(), kTargetPlayer.getCivilizationAdjectiveKey(), szCityName.GetCString());
	AddDLLMessage(getOwner(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_EXPOSED", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_RED(), getX(), getY(), true, true);

	//TSHEEP Enable Loyalty Promotion
	//if (GC.getGame().getSorenRandNum(100, "Spy Reveal identity") < GC.getDefineINT("ESPIONAGE_SPY_REVEAL_IDENTITY_PERCENT"))
	if (GC.getGame().getSorenRandNum(100, "Spy Reveal identity") < GC.getDefineINT("ESPIONAGE_SPY_REVEAL_IDENTITY_PERCENT") && !isAlwaysHeal())//TSHEEP End
	{
		if (!isEnemy(kTargetPlayer.getTeam()))
		{
			kTargetPlayer.AI_changeMemoryCount(getOwner(), MEMORY_SPY_CAUGHT, 1);
		}
		AddDLLMessage(eTargetPlayer, true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_EXPOSE", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_GREEN(), getX(), getY(), true, true);
	}
	else
	{
		AddDLLMessage(
			eTargetPlayer, true, GC.getEVENT_MESSAGE_TIME(),
			gDLL->getText(
				szFormatNoReveal.GetCString(), getNameKey(), kTargetPlayer.getCivilizationAdjectiveKey(), szCityName.GetCString()
			),
			"AS2D_EXPOSE", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_GREEN(), getX(), getY(), true, true
		);
	}

	if (plot()->isActiveVisible(false))
	{
		NotifyEntity(MISSION_SURRENDER);
	}

	//TSHEEP - Give xp to spy who catches spy
	{
		CvUnit* pCounterUnit = plot()->plotCheck(PUF_isCounterSpy, -1, -1, NULL, NO_PLAYER, kTargetPlayer.getTeam());

		if (NULL != pCounterUnit)
		{
			pCounterUnit->changeExperience(1);
		}
	}

	//TSHEEP Implement Escape Promotion
	if (GC.getGame().getSorenRandNum(100, "Spy Reveal identity") < withdrawalProbability())
	{
		setFortifyTurns(0);
		setMadeAttack(true);
		finishMoves();

		CvCity* pCapital = GET_PLAYER(getOwner()).getCapitalCity();

		if (NULL != pCapital)
		{
			//GC.getGame().logOOSSpecial(21, getID(), pCapital->getX(), pCapital->getY());
			setXY(pCapital->getX(), pCapital->getY(), false, false, false);
		}
		{

			szFormatReveal = "TXT_KEY_SPY_ESCAPED_REVEAL";
			szFormatNoReveal = "TXT_KEY_SPY_ESCAPED";
			AddDLLMessage(
				getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
				gDLL->getText(
					szFormatReveal.GetCString(), GET_PLAYER(getOwner()).getCivilizationAdjectiveKey(),
					getNameKey(), kTargetPlayer.getCivilizationAdjectiveKey(), szCityName.GetCString()
				),
				"AS2D_EXPOSED", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_GREEN(), getX(), getY(), true, true
			);
			AddDLLMessage(
				eTargetPlayer, true, GC.getEVENT_MESSAGE_TIME(),
				gDLL->getText(
					szFormatNoReveal.GetCString(),
					getNameKey(), kTargetPlayer.getCivilizationAdjectiveKey(), szCityName.GetCString()
				),
				"AS2D_EXPOSE", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_RED(), getX(), getY(), true, true
			);
		}
		changeExperience(1);

		return true;
	}
	//TSHEEP End

	kill(true, NO_PLAYER, true);

	return true;
}

int CvUnit::getSpyInterceptPercent(TeamTypes eTargetTeam) const
{
	FAssert(isSpy());
	FAssert(getTeam() != eTargetTeam);

	int iSuccess = 0;

	int iTargetPoints = GET_TEAM(eTargetTeam).getEspionagePointsEver();
	int iOurPoints = GET_TEAM(getTeam()).getEspionagePointsEver();
	iSuccess += (GC.getDefineINT("ESPIONAGE_INTERCEPT_SPENDING_MAX") * iTargetPoints) / std::max(1, iTargetPoints + iOurPoints);

	//TSHEEP - add evasion attribute to spy chances
	if(getExtraEvasion())
	{
		iSuccess -= getExtraEvasion();
	}
	//TSHEEP end

	if (plot()->isEspionageCounterSpy(eTargetTeam))
	{
		iSuccess += GC.getDefineINT("ESPIONAGE_INTERCEPT_COUNTERSPY");
		//TSHEEP - Add intercept attribute of any enemy spies present to chances
		if(plot()->plotCheck(PUF_isCounterSpy, -1, -1, NULL, NO_PLAYER, eTargetTeam))
		{
			CvUnit* pCounterUnit = plot()->plotCheck(PUF_isCounterSpy, -1, -1, NULL, NO_PLAYER, eTargetTeam);
			if(pCounterUnit != NULL && pCounterUnit->getExtraIntercept())
				iSuccess += pCounterUnit->getExtraIntercept();
		}
		//TSHEEP end
	}

	if (GET_TEAM(eTargetTeam).getCounterespionageModAgainstTeam(getTeam()) > 0)
	{
		iSuccess += GC.getDefineINT("ESPIONAGE_INTERCEPT_COUNTERESPIONAGE_MISSION");
	}

	//TSHEEP - This check was always returning true since there is always at least one friendly spy in the tile
	//if (0 == getFortifyTurns() || plot()->plotCount(PUF_isSpy, -1, -1, NO_PLAYER, getTeam()) > 0)
	if (0 == getFortifyTurns() || plot()->plotCount(PUF_isSpy, -1, -1, NULL, NO_PLAYER, getTeam()) > 1)//TSHEEP - End
	{
		iSuccess += GC.getDefineINT("ESPIONAGE_INTERCEPT_RECENT_MISSION");
	}

	return std::min(100, std::max(0, iSuccess));
}

bool CvUnit::isIntruding() const
{
	TeamTypes eLocalTeam = plot()->getTeam();

	if (NO_TEAM == eLocalTeam || eLocalTeam == getTeam())
	{
		return false;
	}

	// UNOFFICIAL_PATCH Start
	// * Vassal's spies no longer caught in master's territory
	//if (GET_TEAM(eLocalTeam).isVassal(getTeam()))
	if (GET_TEAM(eLocalTeam).isVassal(getTeam()) || GET_TEAM(getTeam()).isVassal(eLocalTeam))
	// UNOFFICIAL_PATCH End
	{
		return false;
	}

	return true;
}

bool CvUnit::canGoldenAge(bool bTestVisible) const
{
	if (!isGoldenAge())
	{
		return false;
	}

	if (!bTestVisible)
	{
		if (GET_PLAYER(getOwner()).unitsRequiredForGoldenAge() > GET_PLAYER(getOwner()).unitsGoldenAgeReady())
		{
			return false;
		}
	}

	return true;
}


bool CvUnit::goldenAge()
{
	if (!canGoldenAge())
	{
		return false;
	}

	GET_PLAYER(getOwner()).killGoldenAgeUnits(this);

	GET_PLAYER(getOwner()).changeGoldenAgeTurns(GET_PLAYER(getOwner()).getGoldenAgeLength());
	GET_PLAYER(getOwner()).changeNumUnitGoldenAges(1);

	if (plot()->isActiveVisible(false))
	{
		NotifyEntity(MISSION_GOLDEN_AGE);
	}

	kill(true, NO_PLAYER, true);

	return true;
}


bool CvUnit::canBuild(const CvPlot* pPlot, BuildTypes eBuild, bool bTestVisible) const
{
	if (!hasBuild(eBuild))
	{
		return false;
	}

	if (getGroup()->isAutomated())
	{
		if (!GET_PLAYER(getOwner()).isAutomatedCanBuild(eBuild))
		{
			return false;
		}
		if (plot()->getWorkingCity() != NULL && !plot()->getWorkingCity()->isAutomatedCanBuild(eBuild))
		{
			return false;
		}
	}

	if (!(GET_PLAYER(getOwner()).canBuild(pPlot, eBuild, false, bTestVisible)))
	{
		return false;
	}

	if (!pPlot->isValidDomainForAction(*this))
	{
		return false;
	}

	return true;
}

// Returns true if build finished...
bool CvUnit::build(BuildTypes eBuild)
{
	if (!canBuild(plot(), eBuild))
	{
		return false;
	}

	//TBNOTE: There were still some crashes in this so workers cannot merge or split anymore.
	//if (GC.getBuildInfo(eBuild).isKill())
	//{
	//	if (!canPerformActionSM())
	//	{
	//		getGroup()->clearMissionQueue();
	//		if (isHuman())
	//		{

	//			CvWString szBuffer = gDLL->getText("TXT_KEY_MISC_UNIT_CANT_FINISH_BUILD", getNameKey(), GC.getBuildInfo(eBuild).getTextKeyWide());
	//			AddDLLMessage(getOwner(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_PILLAGE", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_YELLOW(), getX(), getY());
	//		}
	//		return false;
	//	}
	//}

	// Note: notify entity must come before changeBuildProgress - because once the unit is done building,
	// that function will notify the entity to stop building.
	NotifyEntity((MissionTypes)GC.getBuildInfo(eBuild).getMissionType());

	GET_PLAYER(getOwner()).changeGold(-(GET_PLAYER(getOwner()).getBuildCost(plot(), eBuild)));

	bool bFinished = plot()->changeBuildProgress(eBuild, workRate(false), getOwner());

	finishMoves(); // needs to be at bottom because movesLeft() can affect workRate()...

	if (bFinished)
	{
		const CvBuildInfo& kBuild = GC.getBuildInfo(eBuild);
		// Super Forts begin *culture*
		if (kBuild.getImprovement() != NO_IMPROVEMENT
		&& GC.getImprovementInfo(kBuild.getImprovement()).getCulture() > 0)
		{
			if (plot()->getOwner() == NO_PLAYER)
			{
				plot()->setOwner(getOwner(),true,true);
			}

			// Special case for plot-grabbing improvements - to get the AI to behave sensibly
			// we nee to split the group here or else an escorted worker will now move away, taking its
			// escort with it, leaving the fort undefended until some other defensive unit can get there.
			// By splitting the group we let the escort occupy the fort at higher priority than
			// re-grouping with the worker, which then has to wait for another escort if it needs one
			if (!isHuman())
			{
				getGroup()->AI_makeForceSeparate();
			}
		}
		// Super Forts end

		if (kBuild.isKill())
		{
			if (plot()->getWorkingCity() != NULL)
			{
				OutputDebugString(CvString::format("Worker at (%d,%d) consumed by build for city %S\n", getX(), getY(), plot()->getWorkingCity()->getName().GetCString()).c_str());
			}
			kill(true, NO_PLAYER, true);
		}
		else if (kBuild.getTime() > 0)
		{
			//ls612: Workers now get XP on finishing a build
			changeExperience100(kBuild.getTime() / std::max(1, workRate(true) / 50));
		}
	}

	// Python Event
	CvEventReporter::getInstance().unitBuildImprovement(this, eBuild, bFinished);

	return bFinished;
}


bool CvUnit::canPromote(PromotionTypes ePromotion, int iLeaderUnitId) const
{
	if (iLeaderUnitId >= 0)
	{
		if (iLeaderUnitId == getID())
		{
			return false;
		}

		// The command is always possible if it's coming from a Warlord unit that gives just experience points
		CvUnit* pWarlord = GET_PLAYER(getOwner()).getUnit(iLeaderUnitId);
		if (pWarlord &&
			NO_UNIT != pWarlord->getUnitType() &&
			pWarlord->getUnitInfo().getLeaderExperience() > 0 &&
			NO_PROMOTION == pWarlord->getUnitInfo().getLeaderPromotion() &&
			canAcquirePromotionAny())
		{
			return true;
		}
	}

	if (ePromotion == NO_PROMOTION)
	{
		return false;
	}

	//TB Debug Note: Apparently the promotions that indicate the unit will become a Leader type that are given to the unit during a Leader attaching
	//to the unit were passing through canAcquirePromotion with a true result though these should've been eliminated here as testPromotionReady would
	//thus find there was an existing promotion possible by only checking against canAcquirePromotion and not including the rest of these checks.
	//By making bForLeader a default false, this will only make it possible to pass true on that check on a leader promotion in canAcquirePromotion if the
	//check is specfically to see if the unit can in all other ways qualify for the leader promo.
	PromotionRequirements::flags promoFlags = PromotionRequirements::Promote;

	if (iLeaderUnitId >= 0)
	{
		promoFlags |= PromotionRequirements::ForLeader;
	}

	if (!canAcquirePromotion(ePromotion, promoFlags))
	{
		return false;
	}

	if (GC.getPromotionInfo(ePromotion).isLeader())
	{
		if (iLeaderUnitId >= 0)
		{
			const CvUnit* pWarlord = GET_PLAYER(getOwner()).getUnit(iLeaderUnitId);

			if (pWarlord && NO_UNIT != pWarlord->getUnitType())
			{
				return (pWarlord->getUnitInfo().getLeaderPromotion() == ePromotion);
			}
		}
		return false;
	}

	if (!isPromotionReady())
	{
		return false;
	}

	return true;
}

bool CvUnit::promote(PromotionTypes ePromotion, int iLeaderUnitId)
{
	if (!canPromote(ePromotion, iLeaderUnitId))
	{
		return false;
	}

	if (iLeaderUnitId >= 0)
	{
		CvUnit* pWarlord = GET_PLAYER(getOwner()).getUnit(iLeaderUnitId);
		if (pWarlord)
		{
			pWarlord->giveExperience();
			if (!pWarlord->getNameNoDesc().empty())
			{
				setName(pWarlord->getNameKey());
			}

			//update graphics models
			m_eLeaderUnitType = pWarlord->getUnitType();
			reloadEntity();
		}
	}

	if (!GC.getPromotionInfo(ePromotion).isLeader())
	{
		if (getRetrainsAvailable() > 0)
		{
			changeRetrainsAvailable(-1);
		}
		else
		{
			changeLevel(1);
			changeDamage(-(getDamage() / 2));
			int iDmgChange = (-(getDamage() / 2));
			if (getColdDamage() > 0)
			{
				if (iDmgChange > getColdDamage())
				{
					setColdDamage(0);
				}
				else
				{
					changeColdDamage(iDmgChange);
				}
			}
		}
	}

	setHasPromotion(ePromotion, true, false, false, true);

	testPromotionReady();

	if (IsSelected())
	{
		gDLL->getInterfaceIFace()->playGeneralSound(GC.getPromotionInfo(ePromotion).getSound());

		gDLL->getInterfaceIFace()->setDirty(UnitInfo_DIRTY_BIT, true);

// BUG - Update Plot List - start
		gDLL->getInterfaceIFace()->setDirty(PlotListButtons_DIRTY_BIT, true);
// BUG - Update Plot List - end
	}
	else
	{
		setInfoBarDirty(true);
	}

	CvEventReporter::getInstance().unitPromoted(this, ePromotion);

	return true;
}

bool CvUnit::lead(int iUnitId)
{
	if (!canLead(plot(), iUnitId))
	{
		return false;
	}

	PromotionTypes eLeaderPromotion = (PromotionTypes)m_pUnitInfo->getLeaderPromotion();

	if (-1 == iUnitId)
	{
		CvPopupInfo* pInfo = new CvPopupInfo(BUTTONPOPUP_LEADUNIT, eLeaderPromotion, getID());
		if (pInfo)
		{
			gDLL->getInterfaceIFace()->addPopup(pInfo, getOwner(), true);
		}
		return false;
	}
	else
	{
		CvUnit* pUnit = GET_PLAYER(getOwner()).getUnit(iUnitId);

		if (!pUnit || !pUnit->canPromote(eLeaderPromotion, getID()))
		{
			return false;
		}

		pUnit->joinGroup(NULL, true, true);

		pUnit->promote(eLeaderPromotion, getID());

		if (plot()->isActiveVisible(false))
		{
			NotifyEntity(MISSION_LEAD);
		}

		kill(true, NO_PLAYER, true);

		return true;
	}
}


int CvUnit::canLead(const CvPlot* pPlot, int iUnitId) const
{
	PROFILE_FUNC();

	if (isDelayedDeath())
	{
		return 0;
	}

	if (NO_UNIT == getUnitType())
	{
		return 0;
	}

	if (isCommander())
	{
		return 0;
	}

	if (isTrap())
	{
		return 0;
	}

	int iNumUnits = 0;
	const CvUnitInfo& kUnitInfo = getUnitInfo();

	if (-1 == iUnitId)
	{
		foreach_(const CvUnit* pUnit, pPlot->units())
		{
			if (pUnit != this &&
				pUnit->getOwner() == getOwner() &&
				!pUnit->isTrap() &&
				!pUnit->isCommander() &&
				pUnit->canPromote((PromotionTypes)kUnitInfo.getLeaderPromotion(), getID()))
			{
				++iNumUnits;
			}
		}
	}
	else
	{
		const CvUnit* pUnit = GET_PLAYER(getOwner()).getUnit(iUnitId);
		if (pUnit && pUnit != this &&
			!pUnit->isTrap() &&
			pUnit->canPromote((PromotionTypes)kUnitInfo.getLeaderPromotion(), getID()))
		{
			iNumUnits = 1;
		}
	}
	return iNumUnits;
}


int CvUnit::canGiveExperience(const CvPlot* pPlot) const
{
	int iNumUnits = 0;

	if (NO_UNIT != getUnitType() && m_pUnitInfo->getLeaderExperience() > 0)
	{
		foreach_(const CvUnit* pUnit, pPlot->units())
		{
			if (pUnit != this && pUnit->getOwner() == getOwner() && pUnit->canAcquirePromotionAny())
			{
/************************************************************************************************/
/* Afforess	                  Start		 03/30/10                                               */
/*                                                                                              */
/* Great Commanders: Do Not give commanders free XP                                             */
/************************************************************************************************/
				if (pUnit->getUnitInfo().isGreatGeneral() || pUnit->isTrap())
				{
					continue;
				}
/************************************************************************************************/
/* Afforess	                     END                                                            */
/************************************************************************************************/
				++iNumUnits;
			}
		}
	}

	return iNumUnits;
}

bool CvUnit::giveExperience()
{
	const CvPlot* pPlot = plot();

	if (pPlot)
	{
		const int iNumUnits = canGiveExperience(pPlot);
		if (iNumUnits > 0)
		{
			const int iTotalExperience = getStackExperienceToGive(iNumUnits);
			const int iMinExperiencePerUnit = iTotalExperience / iNumUnits;

			int i = 0;
			foreach_(CvUnit* pUnit, pPlot->units())
			{
				if (pUnit != this && pUnit->getOwner() == getOwner() && !pUnit->isTrap()
				&& !pUnit->isCommander() && pUnit->canAcquirePromotionAny())
				{
					pUnit->changeExperience(i < (iTotalExperience % iNumUnits) ? iMinExperiencePerUnit + 1 : iMinExperiencePerUnit);
				}
				i++;
			}
			return true;
		}
	}
	return false;
}

int CvUnit::getStackExperienceToGive(int iNumUnits) const
{
	return (m_pUnitInfo->getLeaderExperience() * (100 + std::min(50, (iNumUnits - 1) * GC.getDefineINT("WARLORD_EXTRA_EXPERIENCE_PER_UNIT_PERCENT")))) / 100;
}

int CvUnit::upgradePrice(UnitTypes eUnit) const
{
	if (isNPC())
	{
		return 0;
	}
	int64_t iPrice = (
		GC.getUNIT_UPGRADE_COST_PER_PRODUCTION()
		* (
			GET_PLAYER(getOwner()).getProductionNeeded(eUnit)
			-
			GET_PLAYER(getOwner()).getBaseUnitCost100(getUnitType()) / 100
		)
	);
	if (iPrice < 1)
	{
		return 1;
	}
	{
		int iMod = GET_PLAYER(getOwner()).getUnitUpgradePriceModifier();
		if (!isHuman())
		{
			iMod += (
				GC.getHandicapInfo(GC.getGame().getHandicapType()).getAIUnitUpgradePercent() - 100
				+
				GC.getHandicapInfo(GC.getGame().getHandicapType()).getAIPerEraModifier() * GET_PLAYER(getOwner()).getCurrentEra()
			);
		}
		iPrice = getModifiedIntValue64(iPrice, iMod);
	}
	iPrice -= iPrice * std::min(100, getUpgradeDiscount()) / 100;

	if (GC.getGame().isOption(GAMEOPTION_SIZE_MATTERS))
	{
		iPrice = applySMRank64(iPrice, getSizeMattersOffsetValue(), GC.getSIZE_MATTERS_MOST_MULTIPLIER(), false);
	}
	iPrice /= 100;

	if (iPrice >= MAX_INT)
	{
		return MAX_INT;
	}
	return std::max(1, static_cast<int>(iPrice));
}


bool CvUnit::upgradeAvailable(UnitTypes eFromUnit, UnitTypes eToUnit) const
{
	return GET_PLAYER(getOwner()).upgradeAvailable(eFromUnit, eToUnit);
}


bool CvUnit::canUpgrade(UnitTypes eUnit, bool bTestVisible) const
{
	if (eUnit == NO_UNIT)
	{
		return false;
	}

	if (!isReadyForUpgrade())
	{
		return false;
	}

	if (!bTestVisible && GET_PLAYER(getOwner()).getGold() < upgradePrice(eUnit))
	{
		return false;
	}

	if (GET_PLAYER(getOwner()).getUpgradeRoundCount() == GC.getUPGRADE_ROUND_LIMIT())
	{
		return false;
	}

	if (isCargo())//Being able to upgrade a loaded unit can be problematic
	{
		return false;
	}

	//units in cities cannot upgrade unless the city is one of the owner's team.
	//easiest way to keep upgrades from capturing.  Enforces Rogues must move out of opponent cities to upgrade, which is a little risky which is something to keep things interesting for them.
	if (plot() != NULL && plot()->getPlotCity() != NULL && getTeam() != plot()->getTeam())
	{
		return false;
	}

	if (hasUpgrade(eUnit))
	{
		return true;
	}

	return false;
}

bool CvUnit::isReadyForUpgrade() const
{
	if (!canMove())
	{
		return false;
	}
	if (plot()->getTeam() != getTeam() && !isUpgradeAnywhere() && !GET_PLAYER(getOwner()).isUpgradeAnywhere())
	{
		return false;
	}
	return true;
}

// has upgrade is used to determine if an upgrade is possible,
// it specifically does not check whether the unit can move, whether the current plot is owned, enough gold
// those are checked in canUpgrade()
// does not search all cities, only checks the closest one
bool CvUnit::hasUpgrade(bool bSearch) const
{
	return getUpgradeCity(bSearch) != NULL;
}

// has upgrade is used to determine if an upgrade is possible,
// it specifically does not check whether the unit can move, whether the current plot is owned, enough gold
// those are checked in canUpgrade()
// does not search all cities, only checks the closest one
bool CvUnit::hasUpgrade(UnitTypes eUnit, bool bSearch) const
{
	return getUpgradeCity(eUnit, bSearch) != NULL;
}

// finds the 'best' city which has a valid upgrade for the unit,
// it specifically does not check whether the unit can move, or if the player has enough gold to upgrade
// those are checked in canUpgrade()
// if bSearch is true, it will check every city, if not, it will only check the closest valid city
// NULL result means the upgrade is not possible
CvCity* CvUnit::getUpgradeCity(bool bSearch) const
{
	PROFILE_FUNC();

	CvPlayerAI& kPlayer = GET_PLAYER(getOwner());
	UnitAITypes eUnitAI = AI_getUnitAIType();
	CvArea* pArea = area();

	const int iCurrentValue = kPlayer.AI_unitValue(getUnitType(), eUnitAI, pArea);

	int iBestSearchValue = MAX_INT;
	CvCity* pBestUpgradeCity = NULL;

	for (int iI = 0; iI < GC.getNumUnitInfos(); iI++)
	{
		const UnitTypes eUnitX = static_cast<UnitTypes>(iI);
		if (upgradeAvailable(m_eUnitType, eUnitX) && kPlayer.canTrain(eUnitX))
		{
			int iNewValue = kPlayer.AI_unitValue(eUnitX, eUnitAI, pArea);
			if (iNewValue > iCurrentValue)
			{
				int iSearchValue;
				CvCity* pUpgradeCity = getUpgradeCity(eUnitX, bSearch, &iSearchValue);
				if (pUpgradeCity != NULL)
				{
					// if not searching or close enough, then this match will do
					if (!bSearch || iSearchValue < 16)
					{
						return pUpgradeCity;
					}

					if (iSearchValue < iBestSearchValue)
					{
						iBestSearchValue = iSearchValue;
						pBestUpgradeCity = pUpgradeCity;
					}
				}
			}
		}
	}

	return pBestUpgradeCity;
}

// finds the 'best' city which has a valid upgrade for the unit, to eUnit type
// it specifically does not check whether the unit can move, or if the player has enough gold to upgrade
// those are checked in canUpgrade()
// if bSearch is true, it will check every city, if not, it will only check the closest valid city
// if iSearchValue non NULL, then on return it will be the city's proximity value, lower is better
// NULL result means the upgrade is not possible
CvCity* CvUnit::getUpgradeCity(UnitTypes eUnit, bool bSearch, int* iSearchValue) const
{
	PROFILE_FUNC();

	if (eUnit == NO_UNIT || !upgradeAvailable(m_eUnitType, eUnit) || !GET_PLAYER(getOwner()).canTrain(eUnit, false, false, true))
	{
		return NULL;
	}
	const CvUnitInfo& kUnitInfo = GC.getUnitInfo(eUnit);

	//The following checks to make sure that the upgrade won't make it impossible for a ship to hold
	//the cargo it already does.
	if (GC.getGame().isOption(GAMEOPTION_SIZE_MATTERS))
	{
		if (kUnitInfo.getSMCargoSpace() < SMgetCargo())
		{
			return NULL;
		}
	}
	else if (kUnitInfo.getCargoSpace() < getCargo())
	{
		return NULL;
	}

	foreach_(const CvUnit* pLoopUnit, plot()->units())
	{
		if (pLoopUnit->getTransportUnit() == this)
		{
			if (isHuman() && GC.getGame().isOption(GAMEOPTION_SIZE_MATTERS))
			{
				if (kUnitInfo.getSMSpecialCargo() != NO_SPECIALUNIT)
				{
					return NULL;
				}
			}
			else if (kUnitInfo.getSpecialCargo() != NO_SPECIALUNIT)
			{
				return NULL;
			}

			if (kUnitInfo.getDomainCargo() != NO_DOMAIN && kUnitInfo.getDomainCargo() != pLoopUnit->getDomainType())
			{
				return NULL;
			}
		}
	}

	// sea units must be built on the coast
	const bool bCoastalOnly = getDomainType() == DOMAIN_SEA;

	// results
	int iBestValue = MAX_INT;
	CvCity* pBestCity = NULL;

	// if search is true, check every city for our team
	if (bSearch)
	{
		// air units can travel any distance
		const bool bIgnoreDistance = getDomainType() == DOMAIN_AIR;
		const CvArea* pMyArea = (bCoastalOnly && !plot()->isWater()) ? plot()->waterArea() : area();

		const TeamTypes eTeam = getTeam();
		const int iX = getX();
		const int iY = getY();

		// check every player on our team's cities
		for (int iI = 0; iI < MAX_PLAYERS; iI++)
		{
			// is this player on our team?
			if (GET_PLAYER((PlayerTypes)iI).isAliveAndTeam(eTeam))
			{
				foreach_(CvCity* pLoopCity, GET_PLAYER((PlayerTypes)iI).cities())
				{
					// if coastal only, then make sure we are coast
					CvArea* pCityArea = bCoastalOnly ? pLoopCity->waterArea() : pLoopCity->area();

					// Toffer, units should not be compelled to travel between areas just to get an upgrade.
					if ((bIgnoreDistance || pMyArea == pCityArea) && pLoopCity->canTrain(eUnit, false, false, true))
					{
						// if we do not care about distance, then the first match will do
						if (bIgnoreDistance)
						{
							// if we do not care about distance, then return 1 for value
							if (iSearchValue != NULL)
							{
								*iSearchValue = 1;
							}
							return pLoopCity;
						}
						int iValue = plotDistance(iX, iY, pLoopCity->getX(), pLoopCity->getY());

						// if we cannot path there, not as good (lower numbers are better)
						if (!generatePath(pLoopCity->plot(), 0, true))
						{
							iValue *= 16;
						}
						if (iValue < iBestValue)
						{
							iBestValue = iValue;
							pBestCity = pLoopCity;
						}
					}
				}
			}
		}
	}
	else
	{
		// Find the closest city
		CvCity* pClosestCity = GC.getMap().findCity(getX(), getY(), NO_PLAYER, getTeam(), true, bCoastalOnly);

		// If we can train, then return this city (otherwise it will return NULL)
		if (pClosestCity != NULL && pClosestCity->canTrain(eUnit, false, false, true))
		{
			// did not search, always return 1 for search value
			iBestValue = 1;
			pBestCity = pClosestCity;
		}
	}

	// return the best value, if non-NULL
	if (iSearchValue != NULL)
	{
		*iSearchValue = iBestValue;
	}
	return pBestCity;
}

bool CvUnit::upgrade(UnitTypes eUnit)
{
	if (!canUpgrade(eUnit))
	{
		return false;
	}

// BUG - Upgrade Unit Event - start
	const int iPrice = upgradePrice(eUnit);
	GET_PLAYER(getOwner()).changeGold(-iPrice);
	GET_PLAYER(getOwner()).changeUpgradeRoundCount(1);
// BUG - Upgrade Unit Event - end

	//	Preserve the AI type if that is possible
	UnitAITypes eUnitAI = AI_getUnitAIType();

	if ( !GC.getUnitInfo(eUnit).getUnitAIType(eUnitAI) )
	{
		eUnitAI = NO_UNITAI;	//	Will cause it to initialize with its default
	}

	//Set Group to rejoin
	GET_PLAYER(getOwner()).setSelectionRegroup(getGroupID());
	//Set Unit to reload onto
	CvUnit* pTransportUnit = getTransportUnit();

	CvUnit* pUpgradeUnit = GET_PLAYER(getOwner()).initUnit(eUnit, getX(), getY(), eUnitAI, NO_DIRECTION, GC.getGame().getSorenRandNum(10000, "AI Unit Birthmark"));
	if (pUpgradeUnit == NULL)
	{
		FErrorMsg("UpgradeUnit is not assigned a valid value");
		return false;
	}
	pUpgradeUnit->joinGroup(getGroup());
	if (pTransportUnit)
	{
		pUpgradeUnit->setTransportUnit(pTransportUnit);
	}
	//Clear Group to rejoin
	GET_PLAYER(getOwner()).setSelectionRegroup(NULL);

	pUpgradeUnit->convert(this);

	pUpgradeUnit->finishMoves();

	if (pUpgradeUnit->getLeaderUnitType() == NO_UNIT && !GC.getGame().isOption(GAMEOPTION_INFINITE_XP))
	{
		pUpgradeUnit->setExperience(pUpgradeUnit->getExperience() * 3 / 5);
	}

	CvEventReporter::getInstance().unitUpgraded(this, pUpgradeUnit, iPrice);

	if (gUnitLogLevel > 2)
	{
		CvWString szString;
		getUnitAIString(szString, pUpgradeUnit->AI_getUnitAIType());
		logBBAI("    %S spends %d to upgrade %S to %S, unit AI %S", GET_PLAYER(getOwner()).getCivilizationDescription(0), upgradePrice(eUnit), getName(0).GetCString(), pUpgradeUnit->getName(0).GetCString(), szString.GetCString());
	}

	return true;
}


HandicapTypes CvUnit::getHandicapType() const
{
	return GET_PLAYER(getOwner()).getHandicapType();
}


CivilizationTypes CvUnit::getCivilizationType() const
{
	return GET_PLAYER(getOwner()).getCivilizationType();
}

const wchar_t* CvUnit::getVisualCivAdjective(TeamTypes eForTeam) const
{
	if (getVisualOwner(eForTeam) == getOwner())
	{
		return GC.getCivilizationInfo(getCivilizationType()).getAdjectiveKey();
	}

	return L"";
}

SpecialUnitTypes CvUnit::getSpecialUnitType() const
{
	if (m_eSpecialUnit != NO_SPECIALUNIT)
	{
		return m_eSpecialUnit;
	}
	return ((SpecialUnitTypes)(m_pUnitInfo->getSpecialUnitType()));
}


UnitTypes CvUnit::getCaptureUnitType() const
{
	return (UnitTypes) m_pUnitInfo->getUnitCaptureType();
}


UnitCombatTypes CvUnit::getUnitCombatType() const
{
	return (UnitCombatTypes) m_pUnitInfo->getUnitCombatType();
}


DomainTypes CvUnit::getDomainType() const
{
	return m_pUnitInfo->getDomainType();
}


InvisibleTypes CvUnit::getInvisibleType() const
{
	const InvisibleTypes eInvisible = (InvisibleTypes)m_pUnitInfo->getInvisibleType();
	if (eInvisible != NO_INVISIBLE && isNegatesInvisible(eInvisible))
	{
		return NO_INVISIBLE;
	}
	return (eInvisible);
}

int CvUnit::getNumSeeInvisibleTypes() const
{
	return m_pUnitInfo->getNumSeeInvisibleTypes();
}

InvisibleTypes CvUnit::getSeeInvisibleType(int i) const
{
	return (InvisibleTypes)(m_pUnitInfo->getSeeInvisibleType(i));
}


int CvUnit::flavorValue(FlavorTypes eFlavor) const
{
	return m_pUnitInfo->getFlavorValue(eFlavor);
}


bool CvUnit::isBarbarian() const
{
	return GET_PLAYER(getOwner()).isBarbarian();
}


bool CvUnit::isNPC() const
{
	return GET_PLAYER(getOwner()).isNPC();
}


bool CvUnit::isHominid() const
{
	return GET_PLAYER(getOwner()).isHominid();
}


bool CvUnit::isHuman() const
{
	return GET_PLAYER(getOwner()).isHuman();
}


int CvUnit::visibilityRange(const CvPlot* pPlot) const
{
	if (pPlot == NULL)
	{
		pPlot = plot();
	}

	int iImprovementVisibilityChange = 0;
	if (pPlot->getImprovementType() != NO_IMPROVEMENT)
	{
		iImprovementVisibilityChange = GC.getImprovementInfo(pPlot->getImprovementType()).getVisibilityChange();
	}
	return std::min(GC.getMAX_UNIT_VISIBILITY_RANGE(), GC.getUNIT_VISIBILITY_RANGE() + getExtraVisibilityRange() + iImprovementVisibilityChange);
}


int CvUnit::baseMoves() const
{
	return (m_pUnitInfo->getMoves() + getExtraMoves() + (getDomainType() != DOMAIN_AIR ? GET_TEAM(getTeam()).getExtraMoves(getDomainType()) : 0));
}

int CvUnit::maxMoves() const
{
	PROFILE_FUNC();

	if ( m_iMaxMoveCacheTurn != GC.getGame().getGameTurn() )
	{
		m_maxMoveCache = (baseMoves() * GC.getMOVE_DENOMINATOR());
		m_iMaxMoveCacheTurn = GC.getGame().getGameTurn();
	}

	return m_maxMoveCache;
}


int CvUnit::movesLeft() const
{
	return std::max(0, (maxMoves() - getMoves()));
}


bool CvUnit::canMove() const
{
	if (isDead())
	{
		return false;
	}

	if (getMoves() >= maxMoves())
	{
		return false;
	}

	if (getImmobileTimer() > 0)
	{
		return false;
	}

	return true;
}


bool CvUnit::hasMoved()	const
{
	return getMoves() > 0;
}


int CvUnit::airRange() const
{
	const SpecialUnitTypes eMissile = GC.getSPECIALUNIT_MISSILE();
	if (getDomainType() == DOMAIN_AIR && nukeRange() == -1 && getSpecialUnitType() != eMissile)
	{
		return (m_pUnitInfo->getAirRange() + getExtraAirRange() + GET_TEAM(getTeam()).getExtraMoves(DOMAIN_AIR) + GET_PLAYER(getOwner()).getNationalFlightOperationRangeChange());
	}
	if (getDomainType() == DOMAIN_AIR && getSpecialUnitType() == eMissile)
	{
		return (m_pUnitInfo->getAirRange() + getExtraAirRange() + GET_TEAM(getTeam()).getExtraMoves(DOMAIN_AIR) + GET_PLAYER(getOwner()).getNationalMissileRangeChange());
	}
	return (m_pUnitInfo->getAirRange() + getExtraAirRange());
}


int CvUnit::nukeRange() const
{
	return m_pUnitInfo->getNukeRange();
}

namespace CvUnitInternal
{
	bool canBuildRoute(const std::vector<BuildTypes>& aBuilds, const CvTeam& team)
	{
		foreach_(const BuildTypes eBuild, aBuilds)
		{
			const CvBuildInfo& info = GC.getBuildInfo(eBuild);
			if (info.getRoute() > NO_ROUTE && team.isHasTech(info.getTechPrereq()))
			{
				const TechTypes obsoleteTech = info.getObsoleteTech();
				if (obsoleteTech == NO_TECH || !team.isHasTech(obsoleteTech))
					return true;
			}
		}
		return false;
	}
}

bool CvUnit::canBuildRoute() const
{
	if (!isWorker()) return false;

	const CvTeam& team = GET_TEAM(getTeam());
	return CvUnitInternal::canBuildRoute(m_worker->getExtraBuilds(), team)
		|| CvUnitInternal::canBuildRoute(m_pUnitInfo->getBuilds(), team);
}

BuildTypes CvUnit::getBuildType() const
{
	BuildTypes eBuild;

	if (getGroup()->headMissionQueueNode() != NULL)
	{
		switch (getGroup()->headMissionQueueNode()->m_data.eMissionType)
		{
		case MISSION_MOVE_TO:
// BUG - Sentry Actions - start
#ifdef _MOD_SENTRY
		case MISSION_MOVE_TO_SENTRY:
#endif
// BUG - Sentry Actions - end
			break;

		case MISSION_ROUTE_TO:
			if (getGroup()->getBestBuildRoute(plot(), &eBuild) != NO_ROUTE)
			{
				return eBuild;
			}
			break;

		case MISSION_MOVE_TO_UNIT:
		case MISSION_SKIP:
		case MISSION_SLEEP:
		case MISSION_FORTIFY:
		case MISSION_BUILDUP:
		case MISSION_AUTO_BUILDUP:
		case MISSION_HEAL_BUILDUP:
		case MISSION_PLUNDER:
		case MISSION_AIRPATROL:
		case MISSION_SEAPATROL:
		case MISSION_HEAL:
		case MISSION_SENTRY:
// BUG - Sentry Actions - start
#ifdef _MOD_SENTRY
		case MISSION_SENTRY_WHILE_HEAL:
		case MISSION_SENTRY_NAVAL_UNITS:
		case MISSION_SENTRY_LAND_UNITS:
#endif
// BUG - Sentry Actions - end
		case MISSION_AIRLIFT:
		case MISSION_NUKE:

		case MISSION_RECON:
		case MISSION_PARADROP:
		case MISSION_AIRBOMB:
		case MISSION_BOMBARD:
		case MISSION_RANGE_ATTACK:
		case MISSION_PILLAGE:
		case MISSION_SABOTAGE:
		case MISSION_DESTROY:
		case MISSION_STEAL_PLANS:
		case MISSION_FOUND:
		case MISSION_SPREAD:
		case MISSION_SPREAD_CORPORATION:
		case MISSION_JOIN:
		case MISSION_CONSTRUCT:
		case MISSION_DISCOVER:
		case MISSION_HURRY:
		case MISSION_TRADE:
		case MISSION_GREAT_WORK:
		case MISSION_INFILTRATE:
		case MISSION_GOLDEN_AGE:
		case MISSION_LEAD:
		case MISSION_ESPIONAGE:
		case MISSION_DIE_ANIMATION:
		// Dale - AB: Bombing
		case MISSION_AIRBOMB1:
		case MISSION_AIRBOMB2:
		case MISSION_AIRBOMB3:
		case MISSION_AIRBOMB4:
		case MISSION_AIRBOMB5:
		// Dale - RB: Field Bombard
		case MISSION_RBOMBARD:
		// Dale - FE: Fighters
		case MISSION_FENGAGE:
		// ! Dale
		case MISSION_HURRY_FOOD:
		case MISSION_INQUISITION:
		case MISSION_CLAIM_TERRITORY:
		case MISSION_ESPIONAGE_SLEEP:
		case MISSION_GREAT_COMMANDER:
		case MISSION_SHADOW:
		case MISSION_AMBUSH:
		case MISSION_ASSASSINATE:
			break;

		case MISSION_BUILD:
			return (BuildTypes)getGroup()->headMissionQueueNode()->m_data.iData1;
			break;

		default:
			// AIAndy: Assumed to be an outcome mission
			// FErrorMsg("error");
			break;
		}
	}

	return NO_BUILD;
}

ImprovementTypes CvUnit::getBuildTypeImprovement() const
{
	const BuildTypes buildType = getBuildType();
	if (buildType == NO_BUILD) return NO_IMPROVEMENT;
	return GC.getBuildInfo(buildType).getImprovement();
}

bool CvUnit::isAnimal() const
{
	return GET_PLAYER(getOwner()).isAnimal();
}


bool CvUnit::isNoBadGoodies() const
{
	return m_pUnitInfo->isNoBadGoodies();
}


bool CvUnit::isOnlyDefensive() const
{
	int iCount = m_iOnlyDefensiveCount;
	if (m_pUnitInfo->isOnlyDefensive())
	{
		iCount++;
	}
	return iCount;
}


bool CvUnit::hasRBombardForceAbility() const
{
	bool bForce = (m_pUnitInfo->isRBombardForceAbility() || (getRBombardForceAbilityCount() > 0));
	return bForce;
}

int CvUnit::getRBombardForceAbilityCount() const
{
	return m_iRBombardForceAbilityCount;
}

void CvUnit::changeRBombardForceAbilityCount(int iChange)
{
	m_iRBombardForceAbilityCount += iChange;
}

bool CvUnit::isNoCapture() const
{
	int iCount = getNoCaptureCount();
	if (!canAttack())
	{
		iCount++;
	}
	if (m_pUnitInfo->isNoCapture())
	{
		iCount++;
	}
	return (iCount > 0);
}


bool CvUnit::isRivalTerritory() const
{
	return m_pUnitInfo->isRivalTerritory();
}


bool CvUnit::isMilitaryHappiness() const
{
	return m_pUnitInfo->isMilitaryHappiness();
}

bool CvUnit::isMilitaryBranch() const
{
	return m_pUnitInfo->isMilitarySupport();
}


bool CvUnit::isInvestigate() const
{
	return m_pUnitInfo->isInvestigate();
}


bool CvUnit::isCounterSpy() const
{
	return m_pUnitInfo->isCounterSpy();
}


bool CvUnit::isSpy() const
{
	return m_pUnitInfo->isSpy();
}


bool CvUnit::isFound() const
{
	return m_pUnitInfo->isFound();
}

bool CvUnit::isGoldenAge() const
{
	if (isDelayedDeath())
	{
		return false;
	}
	return m_pUnitInfo->isGoldenAge();
}

bool CvUnit::canCoexistAlways() const
{
	return alwaysInvisible();
}

bool CvUnit::canCoexistAlwaysOnPlot(const CvPlot& onPlot) const
{
	return canCoexistAlways()
		// City or fort allows blend in
		|| onPlot.isCity(true) && isBlendIntoCity()
	;
}

bool CvUnit::canCoexistWithTeam(const TeamTypes withTeam) const
{
	return canCoexistAlways() || getTeam() == withTeam;
}

bool CvUnit::canCoexistWithTeamOnPlot(const TeamTypes withTeam, const CvPlot& onPlot) const
{
	return getTeam() == withTeam || canCoexistAlwaysOnPlot(onPlot)
		// Invisible to team and on the same plot
		|| isInvisible(withTeam) && *plot() == onPlot
	;
}

namespace {
	// Will an attacker be always hostile to a defender on the defenders plot?
	bool alwaysHostile(const CvUnit& defender, const CvUnit& attacker)
	{
		return
			(defender.isAlwaysHostile(defender.plot()) || attacker.isAlwaysHostile(defender.plot()))
			&&
			!(GC.getGame().isOption(GAMEOPTION_PEACE_AMONG_NPCS) && defender.isNPC() && attacker.isNPC());
	}
}
bool CvUnit::canCoexistWithAttacker(const CvUnit& attacker, bool bAssassinate) const
{
	const TeamTypes attackerTeam = GET_PLAYER(attacker.getOwner()).getTeam();

	return
		// Always coexists
		canCoexistAlways() || attacker.canCoexistAlways()
		// Coexists due to barb coexist flag
		|| attacker.isBarbCoExist() && isHominid() || attacker.isHominid() && isBarbCoExist()
		// Coexists due to blending into a city (nullified by assassination)
		|| !bAssassinate && plot()->isCity(true) && (isBlendIntoCity() || attacker.isBlendIntoCity())
		// Invisibility to the attacking team, or being on the attacking team
		|| isInvisible(attackerTeam, false) || getTeam() == attackerTeam
		// War enemy, or just always hostile
		|| !isEnemy(attackerTeam) && !alwaysHostile(*this, attacker)
		// Checks for differing domains, transport status, amnesty game setting
		|| canUnitCoexistWithArrivingUnit(attacker)
		;
}

bool CvUnit::canUnitCoexistWithArrivingUnit(const CvUnit& enemyUnit) const
{
	if (enemyUnit.isDead())
	{
		return true;
	}

	if (plot()->isWater())
	{
		if (enemyUnit.canLoad(plot()))
		{
			return true;
		}

		if (plot()->isCanMoveLandUnits())
		{
			const bool bIsAboveWater =
				getDomainType() != DOMAIN_LAND
				||
				canMoveAllTerrain();
			const bool bOtherIsAboveWater =
				enemyUnit.getDomainType() != DOMAIN_LAND
				||
				enemyUnit.canMoveAllTerrain();

			if (bIsAboveWater && !bOtherIsAboveWater)
			{
				return true;
			}
			if (!bIsAboveWater && bOtherIsAboveWater)
			{
				return true;
			}
		}
	}

	if (!isArmedTrap() && !enemyUnit.isArmedTrap())
	{
		if (!canAttack() && !enemyUnit.canAttack())
		{
			return true;
		}
		if ((enemyUnit.isBarbCoExist() && isHominid()) || (enemyUnit.isHominid() && isBarbCoExist()))
		{
			return true;
		}

		if ((enemyUnit.isInvisible(getTeam(), false, false) && enemyUnit.isOnlyDefensive()) || (isInvisible(enemyUnit.getTeam(), false, false) && isOnlyDefensive()))
		{
			return true;
		}

		if (GC.getGame().isOption(GAMEOPTION_AMNESTY))
		{
			const bool bBorderValid =
				GET_TEAM(getTeam()).isOpenBorders(enemyUnit.getTeam())
				||
				GET_TEAM(getTeam()).isLimitedBorders(enemyUnit.getTeam());

			if (bBorderValid)
			{
				if (plot()->getOwner() == getOwner() && isHiddenNationality())
				{
					if (!enemyUnit.canAttack() || enemyUnit.isPassage())
					{
						return true;
					}
				}
				else if (plot()->getOwner() == enemyUnit.getOwner() && enemyUnit.isHiddenNationality())
				{
					if (!canAttack() || isPassage())
					{
						return true;
					}
				}
			}
		}

		if (plot()->isCity(true))
		{
			if (isBlendIntoCity() || enemyUnit.isBlendIntoCity())
			{
				if ((isAssassin() && enemyUnit.isTargetOf(*this)) || (enemyUnit.isAssassin() && isTargetOf(enemyUnit)))
				{
					return false;
				}
			}
		}
	}

	// if is loaded and is not attacking
	if ((isCargo() && !getGroup()->IsSelected() && plot()->isWater() == enemyUnit.plot()->isWater())
		||
		(enemyUnit.isCargo() && !enemyUnit.getGroup()->IsSelected() && plot()->isWater() == enemyUnit.plot()->isWater())
		)
	{
		//may be oversimplified still - if I move a transport and drop off units on land, the units aren't selected when they are checked to see if they can make this move without an attack.  So this makes for a free overlapping beachhead maneuver.
		//somehow, if disembarking, it must still consider the unit incapable of automatically being able to share the space being moved to with enemies
		//check the autodisembarking code for the right filter checks perhaps...
		return true;
	}
	//if (isCargo())
	//{
	//	return (getTransportUnit()->canUnitCoexistWithEnemyUnit(pUnit, pPlot, bTrapCheck));
	//}
	//if (pUnit->isCargo())
	//{
	//	return (pUnit->getTransportUnit()->canUnitCoexistWithEnemyUnit(this, pPlot, bTrapCheck));
	//}
	return false;
}

bool CvUnit::isFighting() const
{
	return (getCombatUnit() != NULL);
}


bool CvUnit::isAttacking() const
{
	return (getAttackPlot() != NULL && !isDelayedDeath());
}


bool CvUnit::isDefending() const
{
	return isFighting() && !isAttacking();
}


bool CvUnit::isCombat() const
{
	return isFighting() || isAttacking();
}

int CvUnit::withdrawalHP(int iMaxHitPoints, int iAttackerEarly) const
{
	return iMaxHitPoints * (100-iAttackerEarly) / 100;
}

// Toffer - Only called by exe
int CvUnit::maxHitPoints() const
{
	OutputDebugString("exe enquiring about unit max HP\n");
	return getMaxHP();
}
// ! Toffer


int CvUnit::getHP()	const
{
	return (AI_getPredictedHitPoints() == -1 ? getMaxHP() - getDamage() : AI_getPredictedHitPoints());
}


bool CvUnit::isHurt() const
{
	return (getDamage() > 0);
}


bool CvUnit::isDead() const
{
	return (getDamage() >= getMaxHP());
}


void CvUnit::setBaseCombatStr(int iCombat)
{
	m_iBaseCombat = iCombat;
}

int CvUnit::baseCombatStr() const
{
	return GC.getGame().isOption(GAMEOPTION_SIZE_MATTERS) ? getSMStrength() : baseCombatStrPreCheck();
}

int CvUnit::baseCombatStrNonGranular() const
{
	int iStr = baseCombatStr();
	if (!GC.getGame().isOption(GAMEOPTION_SIZE_MATTERS))
	{
		return iStr;
	}
	else
	{
		iStr /= 100;
	}
	return iStr;
}

int CvUnit::airBaseCombatStr() const
{
	int iStr = 0;
	if (!GC.getGame().isOption(GAMEOPTION_SIZE_MATTERS))
	{
		iStr = baseAirCombatStrPreCheck();
	}
	else
	{
		iStr = getSMStrength();
	}
	return iStr;
}

int CvUnit::baseCombatStrPreCheck() const
{
	int iStr = m_iBaseCombat + getExtraStrength();

	if (iStr < 0)
	{
		return 0;
	}
	if (GC.getGame().isOption(GAMEOPTION_SIZE_MATTERS))
	{
		iStr *= 100;
	}
	if (getExtraStrengthModifier() != 0)
	{
		iStr *= 100 + getExtraStrengthModifier();
		iStr /= 100;
	}
	return iStr;
}

int CvUnit::baseAirCombatStrPreCheck() const
{
	int iStr = m_pUnitInfo->getAirCombat() + getExtraStrength();

	if (iStr < 0)
	{
		return 0;
	}
	if (GC.getGame().isOption(GAMEOPTION_SIZE_MATTERS))
	{
		iStr *= 100;
	}
	if (getExtraStrengthModifier() != 0)
	{
		iStr *= 100 + getExtraStrengthModifier();
		iStr /= 100;
	}
	return iStr;
}

int CvUnit::getExtraStrength() const
{
	return m_iExtraStrength;
}

void CvUnit::changeExtraStrength(int iChange)
{
	m_iExtraStrength += iChange;
	FASSERT_NOT_NEGATIVE(m_iExtraStrength);
}

int CvUnit::getSMStrength() const
{
	return m_iSMStrength;
}

void CvUnit::setSMStrength()
{
	const int iStrength = getDomainType() == DOMAIN_AIR? baseAirCombatStrPreCheck() : baseCombatStrPreCheck();
	m_iSMStrength = applySMRank(iStrength, getSizeMattersOffsetValue(), GC.getSIZE_MATTERS_MOST_MULTIPLIER());
	FASSERT_NOT_NEGATIVE(m_iSMStrength);
}

float CvUnit::fbaseCombatStr() const
{
	return (float)baseCombatStr()/100;
}

float CvUnit::fairBaseCombatStr() const
{
	return (float)airBaseCombatStr()/100;
}

struct CombatStrCacheEntry
{
	int	iLRUIndex;
	int iResult;
	const CvPlot* pPlot;
	const CvPlot* pAttackedPlot;
	const CvUnit* pAttacker;
	const CvUnit* pForUnit;
};

#define	COMBATSTR_CACHE_SIZE	100
static CombatStrCacheEntry CombatStrCache[COMBATSTR_CACHE_SIZE];
static int CombatStrCacheInitializedTurn = -1;
static int iNextCombatCacheLRU = 1;

static void FlushCombatStrCache(CvUnit* pMovingUnit)
{
	if ( pMovingUnit == NULL || pMovingUnit->isCommander() )
	{
		memset(CombatStrCache, 0, sizeof(CombatStrCache));

		CombatStrCacheInitializedTurn = GC.getGame().getGameTurn();
	}
	else
	{
		for(int iI = 0; iI < COMBATSTR_CACHE_SIZE; iI++)
		{
			CombatStrCacheEntry* pEntry = &CombatStrCache[iI];

			if ( pEntry->pAttacker == pMovingUnit ||
				 pEntry->pForUnit == pMovingUnit )
			{
				pEntry->pForUnit = NULL;
				pEntry->iLRUIndex = 1;
			}
		}
	}
}

// maxCombatStr can be called in four different configurations
//		pPlot == NULL, pAttacker == NULL for combat when this is the attacker
//		pPlot valid, pAttacker valid for combat when this is the defender
/*** Dexy - Surround and Destroy START ****/
//		pPlot == NULL, pAttacker valid for combat when this is the defender, attacker is just surrounding us (then defender gets no plot defensive bonuses)
/*** Dexy - Surround and Destroy  END  ****/
//		pPlot valid, pAttacker == NULL (new case), when this is the defender, attacker unknown
//		pPlot valid, pAttacker == this (new case), when the defender is unknown, but we want to calc approx str
//			note, in this last case, it is expected pCombatDetails == NULL, it does not have to be, but some
//			values may be unexpectedly reversed in this case (iModifierTotal will be the negative sum)
/*** Dexy - Surround and Destroy START ****/
int CvUnit::maxCombatStr(const CvPlot* pPlot, const CvUnit* pAttacker, CombatDetails* pCombatDetails, bool bSurroundedModifier) const
// OLD CODE
// int CvUnit::maxCombatStr(const CvPlot* pPlot, const CvUnit* pAttacker, CombatDetails* pCombatDetails) const
/*** Dexy - Surround and Destroy  END  ****/
{
	PROFILE_FUNC();

	int iCombat;
	//TB SubCombat Mod Begin
	int iI;
	//TB SubCombat Mod End
	bool bInvolvesHuman = false;
	if (pAttacker != NULL)
	{
		bInvolvesHuman = (GET_PLAYER(getOwner()).isHuman() || GET_PLAYER(pAttacker->getOwner()).isHuman());
	}
	else
	{
		bInvolvesHuman = GET_PLAYER(getOwner()).isHuman();
	}

	FAssertMsg((pPlot == NULL) || (pPlot->getTerrainType() != NO_TERRAIN), "(pPlot == NULL) || (pPlot->getTerrainType() is not expected to be equal with NO_TERRAIN)");

	// handle our new special case
	const	CvPlot*	pAttackedPlot = NULL;
	bool	bAttackingUnknownDefender = false;
	if (pAttacker == this)
	{
		bAttackingUnknownDefender = true;
		pAttackedPlot = pPlot;

		// reset these values, we will fiddle with them below
		pPlot = NULL;
		pAttacker = NULL;
	}
	// otherwise, attack plot is the plot of us (the defender)
	else if (pAttacker != NULL)
	{
		pAttackedPlot = plot();
	}

	CombatStrCacheEntry* pCacheEntry = NULL;
	const CvUnit* pOriginalAttacker = pAttacker;

	if (pCombatDetails != NULL)
	{
		pCombatDetails->iExtraCombatPercent = 0;
		pCombatDetails->iAnimalCombatModifierTA = 0;
		pCombatDetails->iAIAnimalCombatModifierTA = 0;
		pCombatDetails->iAnimalCombatModifierAA = 0;
		pCombatDetails->iAIAnimalCombatModifierAA = 0;
		pCombatDetails->iBarbarianCombatModifierTB = 0;
		pCombatDetails->iAIBarbarianCombatModifierTB = 0;
		pCombatDetails->iBarbarianCombatModifierAB = 0;
		pCombatDetails->iAIBarbarianCombatModifierAB = 0;
		pCombatDetails->iPlotDefenseModifier = 0;
		pCombatDetails->iFortifyModifier = 0;
		pCombatDetails->iCityDefenseModifier = 0;
		pCombatDetails->iHillsAttackModifier = 0;
		pCombatDetails->iHillsDefenseModifier = 0;
		pCombatDetails->iFeatureAttackModifier = 0;
		pCombatDetails->iFeatureDefenseModifier = 0;
		pCombatDetails->iTerrainAttackModifier = 0;
		pCombatDetails->iTerrainDefenseModifier = 0;
		pCombatDetails->iCityAttackModifier = 0;
		pCombatDetails->iDomainDefenseModifier = 0;
		pCombatDetails->iCityBarbarianDefenseModifier = 0;
		pCombatDetails->iDefenseModifier = 0;
		pCombatDetails->iAttackModifier = 0;
		pCombatDetails->iCombatModifierA = 0;
		pCombatDetails->iCombatModifierT = 0;
		pCombatDetails->iDomainModifierA = 0;
		pCombatDetails->iDomainModifierT = 0;
		pCombatDetails->iAnimalCombatModifierA = 0;
		pCombatDetails->iAnimalCombatModifierT = 0;
		pCombatDetails->iRiverAttackModifier = 0;
		pCombatDetails->iAmphibAttackModifier = 0;
		pCombatDetails->iKamikazeModifier = 0;
		pCombatDetails->iModifierTotal = 0;
		pCombatDetails->iBaseCombatStr = 0;
		pCombatDetails->iCombat = 0;
		pCombatDetails->iMaxCombatStr = 0;
		pCombatDetails->iCurrHitPoints = 0;
		pCombatDetails->iMaxHitPoints = 0;
		pCombatDetails->iCurrCombatStr = 0;
		pCombatDetails->eOwner = getOwner();
		pCombatDetails->eVisualOwner = getVisualOwner();
		pCombatDetails->sUnitName = getName().GetCString();
	}
	else if (baseCombatStr() == 0)
	{
		return 0;
	}
	else if ( bSurroundedModifier  && !bInvolvesHuman)
	{
		PROFILE("maxCombatStr.Cachable");

		if ( CombatStrCacheInitializedTurn != GC.getGame().getGameTurn())
		{
			FlushCombatStrCache(NULL);
		}

		int	iBestLRU = MAX_INT;

		for(iI = 0; iI < COMBATSTR_CACHE_SIZE; iI++)
		{
			CombatStrCacheEntry* pEntry = &CombatStrCache[iI];

			if ( pEntry->iLRUIndex == 0 )
			{
				pCacheEntry = pEntry;
				break;
			}
			else if ( pEntry->pPlot == pPlot && pEntry->pAttackedPlot == pAttackedPlot && pEntry->pAttacker == pOriginalAttacker && pEntry->pForUnit == this )
			{
				//OutputDebugString("maxCombatStr.CachHit\n");
				PROFILE("maxCombatStr.CachHit");
				pEntry->iLRUIndex = iNextCombatCacheLRU++;
				//TB overflow fix
				int iTotalResult = pEntry->iResult;
				if (GC.getGame().isOption(GAMEOPTION_SIZE_MATTERS))
				{
					iTotalResult /= 100;
				}
				return iTotalResult;
				/*return pEntry->iResult;*/
			}
			else if ( pEntry->iLRUIndex < iBestLRU )
			{
				iBestLRU = pEntry->iLRUIndex;
				pCacheEntry = pEntry;
			}
		}

		//char buffer[300];

		//sprintf(buffer,"maxCombatStr cache miss for unit %d, attacker %d @(%d,%d)\n", getID(), pOriginalAttacker == NULL ? -1 : pOriginalAttacker->getID(), pPlot == NULL ? -1 : pPlot->getX(), pPlot == NULL ? -1 : pPlot->getY());
		//OutputDebugString(buffer);
	}

	int iModifier = 0;
	int iExtraModifier;
	//TB Combat Mods Begin
	int iExtraModifier2;
	//TB Combat Mods End

	iExtraModifier = getExtraCombatPercent();
	iModifier += iExtraModifier;
	if (pCombatDetails != NULL)
	{
		pCombatDetails->iExtraCombatPercent = iExtraModifier;
	}

	// do modifiers for animals and barbarians (leaving these out for bAttackingUnknownDefender case)
	if (pAttacker != NULL)
	{
		if (isAnimal())
		{
			if (pAttacker->isHuman())
			{
				iExtraModifier = GC.getHandicapInfo(GC.getGame().getHandicapType()).getAnimalCombatModifier();
				iModifier += iExtraModifier;
				if (pCombatDetails != NULL)
				{
					pCombatDetails->iAnimalCombatModifierTA = iExtraModifier;
				}
			}
			else
			{
				iExtraModifier = GC.getHandicapInfo(GC.getGame().getHandicapType()).getAIAnimalCombatModifier();
				iModifier += iExtraModifier;
				if (pCombatDetails != NULL)
				{
					pCombatDetails->iAIAnimalCombatModifierTA = iExtraModifier;
				}
			}
		}

		if (pAttacker->isAnimal())
		{
			if (isHuman())
			{
				iExtraModifier = -GC.getHandicapInfo(GC.getGame().getHandicapType()).getAnimalCombatModifier();
				iModifier += iExtraModifier;
				if (pCombatDetails != NULL)
				{
					pCombatDetails->iAnimalCombatModifierAA = iExtraModifier;
				}
			}
			else
			{
				iExtraModifier = -GC.getHandicapInfo(GC.getGame().getHandicapType()).getAIAnimalCombatModifier();
				iModifier += iExtraModifier;
				if (pCombatDetails != NULL)
				{
					pCombatDetails->iAIAnimalCombatModifierAA = iExtraModifier;
				}
			}
		}

		if (isHominid())
		{
			//TB Combat Mods Begin
			iExtraModifier2 = -pAttacker->vsBarbsModifier();

			//TB Combat Mods End (The lines that follow also include adjustments with iExtraModifier2)

			if (pAttacker->isHuman())
			{
				iExtraModifier = GC.getHandicapInfo(GC.getGame().getHandicapType()).getBarbarianCombatModifier();
				iModifier += (iExtraModifier + iExtraModifier2);
				if (pCombatDetails != NULL)
				{
					pCombatDetails->iBarbarianCombatModifierTB = (iExtraModifier + iExtraModifier2);
				}
			}
			else
			{
				iExtraModifier = GC.getHandicapInfo(GC.getGame().getHandicapType()).getAIBarbarianCombatModifier();
				iModifier += (iExtraModifier + iExtraModifier2);
				if (pCombatDetails != NULL)
				{
					pCombatDetails->iAIBarbarianCombatModifierTB = (iExtraModifier + iExtraModifier2);
				}
			}
		}

		if (pAttacker->isHominid())
		{
			iExtraModifier2 = vsBarbsModifier();
			//TB Combat Mods End (The following lines include references to iExtraModifier2 which is also a portion of this mod)

			if (isHuman())
			{
				iExtraModifier = -GC.getHandicapInfo(GC.getGame().getHandicapType()).getBarbarianCombatModifier();
				iModifier += (iExtraModifier + iExtraModifier2);
				if (pCombatDetails != NULL)
				{
					pCombatDetails->iBarbarianCombatModifierAB = (iExtraModifier + iExtraModifier2);
				}
			}
			else
			{
				iExtraModifier = -GC.getHandicapInfo(GC.getGame().getHandicapType()).getAIBarbarianCombatModifier();
				iModifier += (iExtraModifier + iExtraModifier2);
				if (pCombatDetails != NULL)
				{
					pCombatDetails->iAIBarbarianCombatModifierTB = (iExtraModifier + iExtraModifier2);
				}
			}
		}
	}

	// add defensive bonuses (leaving these out for bAttackingUnknownDefender case)
	if (pPlot != NULL)
	{
		if (!noDefensiveBonus())
		{
			// When pAttacker is NULL but pPlot is not, this is a computation for this units defensive value
			// against an unknown attacker.  Always ignoring building defense in this case is a conservative estimate,
			// but causes AI to suicide against castle walls of low culture cities in early game.  Using this units
			// ignoreBuildingDefense does a little better ... in early game it corrects undervalue of castles.  One
			// downside is when medieval unit is defending a walled city against gunpowder.  Here, the over value
			// makes attacker a little more cautious, but with their tech lead it shouldn't matter too much.  Also
			// makes vulnerable units (ships, etc) feel safer in this case and potentially not leave, but ships
			// leave when ratio is pretty low anyway.
			iExtraModifier = pPlot->defenseModifier(getTeam(), (pAttacker != NULL) ? pAttacker->ignoreBuildingDefense() : ignoreBuildingDefense());

			iModifier += iExtraModifier;
			if (pCombatDetails != NULL)
			{
				pCombatDetails->iPlotDefenseModifier = iExtraModifier;
			}
		}
		//TB Combat Mods (fortification)
		int iFort = fortifyModifier();
		int iOverrun = ((pAttacker != NULL) ? pAttacker->overrunTotal() : 0);
		int iOverrunzero = ((iOverrun < 0) ? 0 : iOverrun);
		int iOverruntotal = ((iOverrunzero > 100) ? 100 : iOverrunzero);
		int iFortModTotal = ((iFort * (100 - iOverruntotal))/100);

		iExtraModifier = iFortModTotal;
		iModifier += iExtraModifier;
		if (pCombatDetails != NULL)
		{
			pCombatDetails->iFortifyModifier = iExtraModifier;
		}

		if (pPlot->isCity(true, getTeam()))
		{
			if (pAttacker != NULL && pAttacker->plot() != pPlot)
			{
				iExtraModifier = cityDefenseModifier();
				iExtraModifier += cityDefenseVSOpponent(pAttacker);

				if (pPlot->isCity(false))
				{
					//TB SubCombat Mod Begin
					for (std::map<UnitCombatTypes, UnitCombatKeyedInfo>::const_iterator it = m_unitCombatKeyedInfo.begin(), end = m_unitCombatKeyedInfo.end(); it != end; ++it)
					{
						if (it->second.m_bHasUnitCombat)
						{
							iExtraModifier += pPlot->getPlotCity()->getUnitCombatExtraStrength(it->first);
						}
					}
					//TB SubCombat Mod End
				}
			}

			iModifier += iExtraModifier;
			if (pCombatDetails != NULL)
			{
				pCombatDetails->iCityDefenseModifier = iExtraModifier;
			}

		}

		if (pPlot->isHills())
		{
			iExtraModifier = hillsDefenseModifier();
			iModifier += iExtraModifier;
			if (pCombatDetails != NULL)
			{
				pCombatDetails->iHillsDefenseModifier = iExtraModifier;
			}
		}

		if (pPlot->getFeatureType() != NO_FEATURE)
		{
			iExtraModifier = featureDefenseModifier(pPlot->getFeatureType());
			iModifier += iExtraModifier;
			if (pCombatDetails != NULL)
			{
				pCombatDetails->iFeatureDefenseModifier = iExtraModifier;
			}
		}

		iExtraModifier = terrainDefenseModifier(pPlot->getTerrainType());
		iModifier += iExtraModifier;
		if (pCombatDetails != NULL)
		{
			pCombatDetails->iTerrainDefenseModifier = iExtraModifier;
		}
	}

	// if we are attacking to an plot with an unknown defender, the calc the modifier in reverse
	if (bAttackingUnknownDefender)
	{
		pAttacker = this;
	}

	// calc attacker bonueses
/************************************************************************************************/
/* UNOFFICIAL_PATCH                       09/20/09                                jdog5000      */
/*                                                                                              */
/* Bugfix                                                                                       */
/************************************************************************************************/
/* original code
	if (pAttacker != NULL)
*/
	if (pAttacker != NULL && pAttackedPlot != NULL)
/************************************************************************************************/
/* UNOFFICIAL_PATCH                        END                                                  */
/************************************************************************************************/
	{
		int iTempModifier = 0;

		if (pAttacker->plot() == pAttackedPlot || pAttacker->isInvisible(getTeam(), false, false) || (isRevealed() && getDefenseCount() <= 1))
		{
			iExtraModifier = -pAttacker->stealthCombatModifierTotal();
			iTempModifier += iExtraModifier;
			if (pCombatDetails != NULL)
			{
				pCombatDetails->iExtraCombatPercent += iExtraModifier;
			}

			if (!pAttacker->isInvisible(getTeam(), false, false))
			{
				iExtraModifier = stealthCombatModifierTotal();
				iTempModifier += iExtraModifier;
				{
					if (pCombatDetails != NULL)
					{
						pCombatDetails->iExtraCombatPercent += iExtraModifier;
					}
				}
			}
		}

		if (pAttackedPlot->isCity(true, getTeam()) && pAttacker->plot() != pPlot)
		{
			iExtraModifier = -pAttacker->cityAttackModifier();
			iTempModifier += iExtraModifier;
			if (pCombatDetails != NULL)
			{
				pCombatDetails->iCityAttackModifier = iExtraModifier;
			}

			if (pAttacker->isHominid())
			{
				iExtraModifier = GC.getCITY_BARBARIAN_DEFENSE_MODIFIER();
				iTempModifier += iExtraModifier;
				if (pCombatDetails != NULL)
				{
					pCombatDetails->iCityBarbarianDefenseModifier = iExtraModifier;
				}
			}
		}

		if (pAttackedPlot->isHills())
		{
			iExtraModifier = -pAttacker->hillsAttackModifier();
			iTempModifier += iExtraModifier;
			if (pCombatDetails != NULL)
			{
				pCombatDetails->iHillsAttackModifier = iExtraModifier;
			}
		}

		if (pAttackedPlot->getFeatureType() != NO_FEATURE)
		{
			iExtraModifier = -pAttacker->featureAttackModifier(pAttackedPlot->getFeatureType());
			iTempModifier += iExtraModifier;
			if (pCombatDetails != NULL)
			{
				pCombatDetails->iFeatureAttackModifier = iExtraModifier;
			}
		}
		else
		{
			iExtraModifier = -pAttacker->terrainAttackModifier(pAttackedPlot->getTerrainType());
			/*** Dexy - Others' bug fixes START ****/
			iTempModifier += iExtraModifier;
			// OLD CODE
			// iModifier += iExtraModifier;
			/*** Dexy - Others' bug fixes  END  ****/
			if (pCombatDetails != NULL)
			{
				pCombatDetails->iTerrainAttackModifier = iExtraModifier;
			}
		}

		// only compute comparisons if we are the defender with a known attacker
		if (!bAttackingUnknownDefender)
		{
			FAssertMsg(pAttacker != this, "pAttacker is not expected to be equal with this");

			iExtraModifier = unitDefenseModifier(pAttacker->getUnitType());
			iTempModifier += iExtraModifier;
			if (pCombatDetails != NULL)
			{
				pCombatDetails->iDefenseModifier = iExtraModifier;
			}

			iExtraModifier = -pAttacker->unitAttackModifier(getUnitType());
			iTempModifier += iExtraModifier;
			if (pCombatDetails != NULL)
			{
				pCombatDetails->iAttackModifier = iExtraModifier;
			}

			iExtraModifier = religiousCombatModifierTotal(pAttacker->getReligion());
			iTempModifier += iExtraModifier;
			if (pCombatDetails != NULL)
			{
				pCombatDetails->iExtraCombatPercent += iExtraModifier;
			}

			iExtraModifier = -pAttacker->religiousCombatModifierTotal(getReligion());
			iTempModifier += iExtraModifier;
			if (pCombatDetails != NULL)
			{
				pCombatDetails->iExtraCombatPercent += iExtraModifier;
			}

			iExtraModifier = 0;
			//TB SubCombat Mod Begin
			for (std::map<UnitCombatTypes, UnitCombatKeyedInfo>::const_iterator it = pAttacker->m_unitCombatKeyedInfo.begin(), end = pAttacker->m_unitCombatKeyedInfo.end(); it != end; ++it)
			{
				if(it->second.m_bHasUnitCombat)
				{
					iExtraModifier += unitCombatModifier(it->first);
				}
			}

			iTempModifier += iExtraModifier;
			if (pCombatDetails != NULL)
			{
				pCombatDetails->iCombatModifierA = iExtraModifier;
			}

			iExtraModifier = 0;
			//TB SubCombat Mod Begin
			for (std::map<UnitCombatTypes, UnitCombatKeyedInfo>::const_iterator it = m_unitCombatKeyedInfo.begin(), end = m_unitCombatKeyedInfo.end(); it != end; ++it)
			{
				if(it->second.m_bHasUnitCombat)
				{
					iExtraModifier -= pAttacker->unitCombatModifier(it->first);
				}
			}
			//TB SubCombat Mod End
			iTempModifier += iExtraModifier;
			if (pCombatDetails != NULL)
			{
				pCombatDetails->iCombatModifierT = iExtraModifier;
			}

			iExtraModifier = domainModifier(pAttacker->getDomainType());
			iTempModifier += iExtraModifier;
			if (pCombatDetails != NULL)
			{
				pCombatDetails->iDomainModifierA = iExtraModifier;
			}

			iExtraModifier = -pAttacker->domainModifier(getDomainType());
			iTempModifier += iExtraModifier;
			if (pCombatDetails != NULL)
			{
				pCombatDetails->iDomainModifierT = iExtraModifier;
			}

			if (pAttacker->isAnimal())
			{
				iExtraModifier = animalCombatModifier();
				iTempModifier += iExtraModifier;
				if (pCombatDetails != NULL)
				{
					pCombatDetails->iAnimalCombatModifierA = iExtraModifier;
				}
			}

			if (isAnimal())
			{
				iExtraModifier = -pAttacker->animalCombatModifier();
				iTempModifier += iExtraModifier;
				if (pCombatDetails != NULL)
				{
					pCombatDetails->iAnimalCombatModifierT = iExtraModifier;
				}
			}
		}

		if (!(pAttacker->isRiver()))
		{
			if (pAttacker->plot()->isRiverCrossing(directionXY(pAttacker->plot(), pAttackedPlot)))
			{
				CvCity* pCity = pAttackedPlot->getPlotCity();

				if (pCity != NULL && pAttackedPlot->isCity(true, getTeam()))
				{
					iExtraModifier = std::min(0,(pCity->getExtraRiverDefensePenalty() - GC.getRIVER_ATTACK_MODIFIER()));
				}
				else
				{
					iExtraModifier = -GC.getRIVER_ATTACK_MODIFIER();
				}
				iTempModifier += iExtraModifier;
				if (pCombatDetails != NULL)
				{
					pCombatDetails->iRiverAttackModifier = iExtraModifier;
				}
			}
		}

		if (!(pAttacker->isAmphib()))
		{
			if (!(pAttackedPlot->isWater()) && pAttacker->plot()->isWater())
			{
				iExtraModifier = -GC.getAMPHIB_ATTACK_MODIFIER();
				iTempModifier += iExtraModifier;
				if (pCombatDetails != NULL)
				{
					pCombatDetails->iAmphibAttackModifier = iExtraModifier;
				}
			}
		}

		if (pAttacker->getKamikazePercent() != 0)
		{
/************************************************************************************************/
/* Afforess	                  Start		 02/05/10                                    Dexy       */
/*                                                                                              */
/*       Unofficial Patch                                                                       */
/************************************************************************************************/
			iExtraModifier = -pAttacker->getKamikazePercent();
/************************************************************************************************/
/* Afforess	                     END                                                            */
/************************************************************************************************/
			iTempModifier += iExtraModifier;
			if (pCombatDetails != NULL)
			{
				pCombatDetails->iKamikazeModifier = iExtraModifier;
			}
		}

/************************************************************************************************/
/* Afforess	                  Start		 02/05/10                                               */
/*                                                                                              */
/*                                                                                              */
/************************************************************************************************/
		if (bSurroundedModifier)
		{
			// the stronger the surroundings -> decrease the iModifier more
			//TB Combat Mods (S&D promos) begin
			int iSurround = pAttacker->surroundedDefenseModifier(pAttackedPlot, bAttackingUnknownDefender ? NULL : this);
			int iDynamicDefense = dynamicDefenseTotal();
			int iDynamicDefenseModifier = ((iSurround * iDynamicDefense) / 100);
			int iSurroundTotalstepone = iSurround - iDynamicDefenseModifier;
			int iSurroundTotal = (iSurroundTotalstepone < 0 ? 0 : iSurroundTotalstepone);
			iExtraModifier = -iSurroundTotal;
			iTempModifier += iExtraModifier;
			//TB Combat Mods (S&D promos) end
		}
/************************************************************************************************/
/* Afforess	                     END                                                            */
/************************************************************************************************/

		//TB Combat Mods (StrAdjperAtt) begin
		if (pAttacker->currentStrAdjperAttTotal() != 0)
		{
			iExtraModifier = -(pAttacker->currentStrAdjperAttTotal());
			iTempModifier += iExtraModifier;
		}

		if (currentStrAdjperDefTotal() != 0)
		{
			iExtraModifier = currentStrAdjperDefTotal();
			iTempModifier += iExtraModifier;
		}

		if (pAttacker->attackCombatModifierTotal() != 0)
		{
			iExtraModifier = -pAttacker->attackCombatModifierTotal();
			iTempModifier += iExtraModifier;
			if (pCombatDetails != NULL)
			{
				pCombatDetails->iExtraCombatPercent += iExtraModifier;
			}
		}

		if (defenseCombatModifierTotal() != 0)
		{
			iExtraModifier = defenseCombatModifierTotal();
			iTempModifier += iExtraModifier;
			if (pCombatDetails != NULL)
			{
				pCombatDetails->iExtraCombatPercent += iExtraModifier;
			}
		}

		//Defender's bonus from size diff (more)
		int iOffset = 0;
		int iPerTotal = 0;
		iOffset = pAttacker->sizeRank() - sizeRank();
		if (combatModifierPerSizeMoreTotal() != 0 && iOffset > 0)
		{
			iPerTotal = combatModifierPerSizeMoreTotal() * iOffset;
			iExtraModifier = iPerTotal;
			iTempModifier += iExtraModifier;
			if (pCombatDetails != NULL)
			{
				pCombatDetails->iExtraCombatPercent += iExtraModifier;
			}
		}
		//Attacker's bonus from size diff (more)
		iOffset = 0;
		iPerTotal = 0;
		iOffset = sizeRank() - pAttacker->sizeRank();
		if (pAttacker->combatModifierPerSizeMoreTotal() != 0 && iOffset > 0)
		{
			iPerTotal = pAttacker->combatModifierPerSizeMoreTotal() * iOffset;
			iExtraModifier = -iPerTotal;
			iTempModifier += iExtraModifier;
			if (pCombatDetails != NULL)
			{
				pCombatDetails->iExtraCombatPercent += iExtraModifier;
			}
		}

		//Defender's bonus from volume diff (more)
		iOffset = 0;
		iPerTotal = 0;
		iOffset = pAttacker->groupRank() - groupRank();
		if (combatModifierPerVolumeMoreTotal() != 0 && iOffset > 0)
		{
			iPerTotal = combatModifierPerVolumeMoreTotal() * iOffset;
			iExtraModifier = iPerTotal;
			iTempModifier += iExtraModifier;
			if (pCombatDetails != NULL)
			{
				pCombatDetails->iExtraCombatPercent += iExtraModifier;
			}
		}
		//Attacker's bonus from volume diff (more)
		iOffset = 0;
		iPerTotal = 0;
		iOffset = groupRank() - pAttacker->groupRank();
		if (pAttacker->combatModifierPerVolumeMoreTotal() != 0 && iOffset > 0)
		{
			iPerTotal = pAttacker->combatModifierPerVolumeMoreTotal() * iOffset;
			iExtraModifier = -iPerTotal;
			iTempModifier += iExtraModifier;
			if (pCombatDetails != NULL)
			{
				pCombatDetails->iExtraCombatPercent += iExtraModifier;
			}
		}

		//Defender's bonus from size diff (Less)
		iOffset = 0;
		iPerTotal = 0;
		iOffset = pAttacker->sizeRank() - sizeRank();
		if (combatModifierPerSizeLessTotal() != 0 && iOffset < 0)
		{
			iPerTotal = combatModifierPerSizeLessTotal() * -iOffset;
			iExtraModifier = iPerTotal;
			iTempModifier += iExtraModifier;
			if (pCombatDetails != NULL)
			{
				pCombatDetails->iExtraCombatPercent += iExtraModifier;
			}
		}
		//Attacker's bonus from size diff (Less)
		iOffset = 0;
		iPerTotal = 0;
		iOffset = sizeRank() - pAttacker->sizeRank();
		if (pAttacker->combatModifierPerSizeLessTotal() != 0 && iOffset < 0)
		{
			iPerTotal = pAttacker->combatModifierPerSizeLessTotal() * -iOffset;
			iExtraModifier = -iPerTotal;
			iTempModifier += iExtraModifier;
			if (pCombatDetails != NULL)
			{
				pCombatDetails->iExtraCombatPercent += iExtraModifier;
			}
		}

		//Defender's bonus from volume diff (Less)
		iOffset = 0;
		iPerTotal = 0;
		iOffset = pAttacker->groupRank() - groupRank();
		if (combatModifierPerVolumeLessTotal() != 0 && iOffset < 0)
		{
			iPerTotal = combatModifierPerVolumeLessTotal() * -iOffset;
			iExtraModifier = iPerTotal;
			iTempModifier += iExtraModifier;
			if (pCombatDetails != NULL)
			{
				pCombatDetails->iExtraCombatPercent += iExtraModifier;
			}
		}
		//Attacker's bonus from volume diff (Less)
		iOffset = 0;
		iPerTotal = 0;
		iOffset = groupRank() - pAttacker->groupRank();
		if (pAttacker->combatModifierPerVolumeLessTotal() != 0 && iOffset < 0)
		{
			iPerTotal = pAttacker->combatModifierPerVolumeLessTotal() * -iOffset;
			iExtraModifier = -iPerTotal;
			iTempModifier += iExtraModifier;
			if (pCombatDetails != NULL)
			{
				pCombatDetails->iExtraCombatPercent += iExtraModifier;
			}
		}
		//TB Combat Mods (StrAdjperAtt) end
		// if we are attacking an unknown defender, then use the reverse of the modifier
		if (bAttackingUnknownDefender)
		{
			iModifier -= iTempModifier;
		}
		else
		{
			iModifier += iTempModifier;
		}
	}

	if (pCombatDetails != NULL)
	{
		pCombatDetails->iModifierTotal = iModifier;
		pCombatDetails->iBaseCombatStr = baseCombatStr();
	}

	int iBaseCombatStr = baseCombatStr();

	if (iModifier > 0)
	{
		iCombat = (iBaseCombatStr * (iModifier + 100));
	}
	else
	{
		iCombat = ((iBaseCombatStr * 10000) / (100 - iModifier));
	}

	if (pCombatDetails != NULL)
	{
		pCombatDetails->iCombat = iCombat;
		pCombatDetails->iMaxCombatStr = std::max(1, iCombat);
		pCombatDetails->iCurrHitPoints = getHP();
		pCombatDetails->iMaxHitPoints = getMaxHP();
		pCombatDetails->iCurrCombatStr = ((pCombatDetails->iMaxCombatStr * pCombatDetails->iCurrHitPoints) / pCombatDetails->iMaxHitPoints);
	}

	if ( pCacheEntry != NULL )
	{
		pCacheEntry->iLRUIndex = iNextCombatCacheLRU++;
		pCacheEntry->iResult = std::max(1, iCombat);
		pCacheEntry->pPlot = pPlot;
		pCacheEntry->pAttackedPlot = pAttackedPlot;
		pCacheEntry->pAttacker = pOriginalAttacker;
		pCacheEntry->pForUnit = this;

		//char buffer[300];

		//sprintf(buffer,"maxCombatStr cache result (%d) for unit %d, attacker %d @(%d,%d)\n", pCacheEntry->iResult, getID(), pOriginalAttacker == NULL ? -1 : pOriginalAttacker->getID(), pPlot == NULL ? -1 : pPlot->getX(), pPlot == NULL ? -1 : pPlot->getY());
		//OutputDebugString(buffer);
	}

	if (GC.getGame().isOption(GAMEOPTION_SIZE_MATTERS))
	{
		iCombat /= 100;
	}

	return std::max(1, iCombat);
}


/*** Dexy - Surround and Destroy START ****/
int CvUnit::currCombatStr(const CvPlot* pPlot, const CvUnit* pAttacker, CombatDetails* pCombatDetails, bool bSurroundedModifier) const
{
	//TB Combat Mods (StrAdjperRnd) begin
	int iStrengthAdj = currentStrAdjperRndTotal();
	int iMaxStr = maxCombatStr(pPlot, pAttacker, pCombatDetails, bSurroundedModifier);

	return ((iMaxStr * getHP()) / getMaxHP())+((((iMaxStr * getHP()) / getMaxHP()) * iStrengthAdj) / 100);
	//TB Combat Mods (StrAdjperRnd) end
}
// OLD CODE
// int CvUnit::currCombatStr(const CvPlot* pPlot, const CvUnit* pAttacker, CombatDetails* pCombatDetails) const
// {
// 	   return ((maxCombatStr(pPlot, pAttacker, pCombatDetails) * getHP()) / getMaxHP());
// }
/*** Dexy - Surround and Destroy  END  ****/


int CvUnit::currFirepower(const CvPlot* pPlot, const CvUnit* pAttacker) const
{
	return ((maxCombatStr(pPlot, pAttacker) + currCombatStr(pPlot, pAttacker) + 1) / 2);
}

// this normalizes str by firepower, useful for quick odds calcs
// the effect is that a damaged unit will have an effective str lowered by firepower/maxFirepower
// doing the algebra, this means we mulitply by 1/2(1 + currHP)/maxHP = (maxHP + currHP) / (2 * maxHP)
int CvUnit::currEffectiveStr(const CvPlot* pPlot, const CvUnit* pAttacker, CombatDetails* pCombatDetails) const
{
	int currStr = currCombatStr(pPlot, pAttacker, pCombatDetails);

	currStr *= getMaxHP() + getHP();
	currStr /= 2 * getMaxHP();

	return currStr;
}

float CvUnit::maxCombatStrFloat(const CvPlot* pPlot, const CvUnit* pAttacker) const
{
	return (((float)(maxCombatStr(pPlot, pAttacker))) / 100.0f);
}


float CvUnit::currCombatStrFloat(const CvPlot* pPlot, const CvUnit* pAttacker) const
{
	return (((float)(currCombatStr(pPlot, pAttacker))) / 100.0f);
}


bool CvUnit::canFight() const
{
	//	Don't bother calculating modifiers for this call
	return (m_iBaseCombat > 0);
}


bool CvUnit::canAttack() const
{
	if (!canFight())
	{
		return false;
	}

	if (isOnlyDefensive())
	{
		return false;
	}

	return true;
}
bool CvUnit::canAttack(const CvUnit& defender) const
{
	if (!canAttack())
	{
		return false;
	}

	if (getOwner() == defender.getOwner())
	{
		return false;
	}
	int iLimit = combatLimit();
	iLimit *= defender.getMaxHP();
	iLimit /= 100;
	if (defender.getDamage() >= iLimit && breakdownChanceTotal() <= 0)//Breakdown combat can proceed even at combat limit.
	{
		return false;
	}

	// Artillery can't amphibious attack
	if (plot()->isWater() && !defender.plot()->isWater())
	{
		if (combatLimit() < 100)
		{
			return false;
		}
	}

	if (canAttackOnlyCities() && !defender.plot()->isCity())
	{
		return false;
	}

	//tunnel fixes
	if (defender.plot()->isWater() && defender.plot()->isCanMoveLandUnits())
	{
		//Sea units and air units and hovering units can't be attacked by land units in tunnels (Unless the land unit is hovering)
		if ((defender.getDomainType() != DOMAIN_LAND || defender.canMoveAllTerrain()) && getDomainType() == DOMAIN_LAND && !canMoveAllTerrain())
		{
			return false;
		}

		//Non-Hovering Land units can't be attacked by sea or air units or transported units or hovering units in tunnels.
		if ((defender.getDomainType() == DOMAIN_LAND && !defender.canMoveAllTerrain()) && (getDomainType() != DOMAIN_LAND || isCargo() || canMoveAllTerrain()))
		{
			return false;
		}
	}

	if (defender.plot()->isCity(true))
	{
		if (isBlendIntoCity())
		{
			if (isAssassin())
			{
				if (defender.plot() != plot())
				{
					return false;
				}
			}
			else
			{
				return false;
			}
		}
	}

	if (GC.getGame().isOption(GAMEOPTION_AMNESTY) && defender.plot()->getOwner() == getOwner() && isHiddenNationality())
	{
		bool bBorderValid = (GET_TEAM(getTeam()).isOpenBorders(defender.getTeam()) || GET_TEAM(getTeam()).isLimitedBorders(defender.getTeam()));
		if (bBorderValid)
		{
			if (!defender.canAttack() || defender.isPassage())
			{
				return false;
			}
		}
	}

	return true;
}

bool CvUnit::canDefend(const CvPlot* pPlot) const
{
	if (pPlot == NULL)
	{
		pPlot = plot();
	}

	if (!canFight())
	{
		return false;
	}

	if (isTrap())
	{
		return false;
	}

	if (!pPlot->isValidDomainForAction(*this))
	{
		if (GC.getLAND_UNITS_CAN_ATTACK_WATER_CITIES() == 0)
		{
			return false;
		}
	}

	if (isCargo())
	{
		return false;
	}

	return true;
}


bool CvUnit::canSiege(TeamTypes eTeam) const
{
	if (!canDefend())
	{
		return false;
	}

	if (!isEnemy(eTeam))
	{
		return false;
	}

	if (isInvisible(eTeam, false))
	{
		return false;
	}

	if (getOwner() == PREY_PLAYER)
	{
		return false;
	}

	if (isCargo())
	{
		return false;
	}

	return true;
}


int CvUnit::airMaxCombatStr(const CvUnit* pOther) const
{
	if (airBaseCombatStr() == 0)
	{
		return 0;
	}
	int iModifier = getExtraCombatPercent() + getKamikazePercent();

	if (NULL != pOther)
	{
		for (std::map<UnitCombatTypes, UnitCombatKeyedInfo>::const_iterator it = pOther->m_unitCombatKeyedInfo.begin(), end = pOther->m_unitCombatKeyedInfo.end(); it != end; ++it)
		{
			if (it->second.m_bHasUnitCombat)
			{
				iModifier += unitCombatModifier(it->first);
			}
		}

		iModifier += domainModifier(pOther->getDomainType());

		if (pOther->isAnimal())
		{
			iModifier += animalCombatModifier();
		}

		if (pOther->isHominid())
		{
			iModifier += vsBarbsModifier();
		}
	}

	return std::max(1, getModifiedIntValue(100 * airBaseCombatStr(), iModifier));
}


int CvUnit::airCurrCombatStr(const CvUnit* pOther) const
{
	return airMaxCombatStr(pOther) * getHP() / getMaxHP();
}


float CvUnit::airMaxCombatStrFloat(const CvUnit* pOther) const
{
	return (((float)(airMaxCombatStr(pOther))) / 100.0f);
}


float CvUnit::airCurrCombatStrFloat(const CvUnit* pOther) const
{
	return (((float)(airCurrCombatStr(pOther))) / 100.0f);
}


int CvUnit::combatLimit(const CvUnit* pOpponent) const
{
/*****************************************************************************************************/
/**  Author: TheLadiesOgre                                                                          **/
/**  Date: 18.09.2009                                                                               **/
/**  ModComp: TLOTags                                                                               **/
/**  Reason Added: Implement iAirCombatLimitChange                                                  **/
/**  Notes:                                                                                         **/
/*****************************************************************************************************
	return m_pUnitInfo->getCombatLimit();*/
	//return (m_pUnitInfo->getCombatLimit() + getCombatLimitChange());
/*****************************************************************************************************/
/**  TheLadiesOgre; 18.09.2009; TLOTags                                                             **/
/*****************************************************************************************************/

	int iTotal = (m_pUnitInfo->getCombatLimit() + getCombatLimitChange());
	if (pOpponent != NULL)
	{
		iTotal *= pOpponent->getMaxHP();
		iTotal /= 100;
	}
	return iTotal;
}


int CvUnit::airCombatLimit(const CvUnit* pOpponent) const
{
/*****************************************************************************************************/
/**  Author: TheLadiesOgre                                                                          **/
/**  Date: 18.09.2009                                                                               **/
/**  ModComp: TLOTags                                                                               **/
/**  Reason Added: Implement iAirCombatLimitChange                                                  **/
/**  Notes:                                                                                         **/
/*****************************************************************************************************
	return m_pUnitInfo->getAirCombatLimit();*/
	//return (m_pUnitInfo->getAirCombatLimit() + getAirCombatLimitChange());
/*****************************************************************************************************/
/**  TheLadiesOgre; 18.09.2009; TLOTags                                                             **/
/*****************************************************************************************************/

	int iTotal = (m_pUnitInfo->getAirCombatLimit() + getAirCombatLimitChange());
	if (pOpponent != NULL)
	{
		iTotal *= pOpponent->getMaxHP();
		iTotal /= 100;
	}
	return iTotal;
}


bool CvUnit::canAirAttack() const
{
	if (isMadeAttack())
	{
		return false;
	}

	if (hasMoved())
	{
		return false;
	}

	return (airBaseCombatStr() > 0);
}


bool CvUnit::canAirDefend(const CvPlot* pPlot) const
{
	if (pPlot == NULL)
	{
		pPlot = plot();
	}

	//TSHEEP - prevent spies from being used as SAMs
	if(isSpy())
	{
		return false;
	}
	//TSHEEP end

	if (maxInterceptionProbability() == 0)
	{
		return false;
	}

	if (getDomainType() != DOMAIN_AIR)
	{
/************************************************************************************************/
/* UNOFFICIAL_PATCH                       10/30/09                     Mongoose & jdog5000      */
/*                                                                                              */
/* Bugfix                                                                                       */
/************************************************************************************************/
/* original bts code
		if (!pPlot->isValidDomainForLocation(*this))
*/
		// From Mongoose SDK
		// Land units which are cargo cannot intercept
		if (!pPlot->isValidDomainForLocation(*this) || isCargo())
/************************************************************************************************/
/* UNOFFICIAL_PATCH                        END                                                  */
/************************************************************************************************/
		{
			return false;
		}
	}

	return true;
}


int CvUnit::airCombatDamage(const CvUnit* pDefender) const
{
	const CvPlot* pPlot = pDefender->plot();

	const int iOurStrength = airCurrCombatStr(pDefender);
	FAssertMsg(iOurStrength > 0, "Air combat strength is expected to be greater than zero");
	const int iTheirStrength = pDefender->maxCombatStr(pPlot, this);

	const int iStrengthFactor = ((iOurStrength + iTheirStrength + 1) / 2);

	int iDamage = std::max(1, ((GC.getDefineINT("AIR_COMBAT_DAMAGE") * (iOurStrength + iStrengthFactor)) / (iTheirStrength + iStrengthFactor)));

	const CvCity* pCity = pPlot->getPlotCity();

	if (pCity != NULL)
	{
		iDamage *= std::max(0, (pCity->getAirModifier() + 100));
		iDamage /= 100;
	}

	return iDamage;
}


int CvUnit::rangeCombatDamage(const CvUnit* pDefender) const
{
	const CvPlot* pPlot = pDefender->plot();

	const int iOurStrength = airCurrCombatStr(pDefender);
	FAssertMsg(iOurStrength > 0, "Combat strength is expected to be greater than zero");
	const int iTheirStrength = pDefender->maxCombatStr(pPlot, this);

	const int iStrengthFactor = ((iOurStrength + iTheirStrength + 1) / 2);

	return std::max(1, ((GC.getDefineINT("RANGE_COMBAT_DAMAGE") * (iOurStrength + iStrengthFactor)) / (iTheirStrength + iStrengthFactor)));
}


CvUnit* CvUnit::bestInterceptor(const CvPlot* pPlot) const
{
	int iBestValue = 0;
	CvUnit* pBestUnit = NULL;

	for (int iI = 0; iI < MAX_PLAYERS; iI++)
	{
		if (GET_PLAYER((PlayerTypes)iI).isAlive())
		{
			if (!isInvisible(GET_PLAYER((PlayerTypes)iI).getTeam(), false, false))
			{
				foreach_(CvUnit* pLoopUnit, GET_PLAYER((PlayerTypes)iI).units())
				{
					if (pLoopUnit->canAirDefend())
					{
						if (!pLoopUnit->isMadeInterception())
						{
							if (isEnemy(GET_PLAYER((PlayerTypes)iI).getTeam(), NULL, pLoopUnit))
							{
								if ((pLoopUnit->getDomainType() != DOMAIN_AIR) || !(pLoopUnit->hasMoved()))
								{
									if ((pLoopUnit->getDomainType() != DOMAIN_AIR) || (pLoopUnit->getGroup()->getActivityType() == ACTIVITY_INTERCEPT))
									{
										if (plotDistance(pLoopUnit->getX(), pLoopUnit->getY(), pPlot->getX(), pPlot->getY()) <= pLoopUnit->airRange())
										{
											const int iValue = pLoopUnit->currInterceptionProbability();

											if (iValue > iBestValue)
											{
												iBestValue = iValue;
												pBestUnit = pLoopUnit;
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}

	return pBestUnit;
}


CvUnit* CvUnit::bestSeaPillageInterceptor(const CvUnit* pPillager, int iMinOdds) const
{
	CvUnit* pBestUnit = NULL;

	foreach_(const CvPlot* pLoopPlot, pPillager->plot()->rect(1, 1))
	{
		foreach_(CvUnit* pLoopUnit, pLoopPlot->units())
		{
			if (pLoopUnit->area() == pPillager->plot()->area()
			&& !pLoopUnit->isInvisible(getTeam(), false)
			&& isEnemy(pLoopUnit->getTeam())
			&& DOMAIN_SEA == pLoopUnit->getDomainType()
			&& ACTIVITY_PATROL == pLoopUnit->getGroup()->getActivityType()
			&& (NULL == pBestUnit || pLoopUnit->isBetterDefenderThan(pBestUnit, this))
			&& getCombatOdds(pPillager, pLoopUnit) < iMinOdds)
			{
				pBestUnit = pLoopUnit;
			}
		}
	}
	return pBestUnit;
}


bool CvUnit::isAutomated() const
{
	return getGroup()->isAutomated();
}


bool CvUnit::isWaiting() const
{
	return getGroup()->isWaiting();
}


bool CvUnit::isFortifyable() const
{
	if (!canFight() || noDefensiveBonus() || ((getDomainType() != DOMAIN_LAND) && (getDomainType() != DOMAIN_IMMOBILE)))
	{
		return false;
	}

	return true;
}

bool CvUnit::isBuildUpable() const
{
	if (isDelayedDeath() || isDead())
	{
		return false;
	}
	return m_bHasBuildUp;
}


int CvUnit::fortifyModifier() const
{
	if (!isFortifyable())
	{
		return 0;
	}
	return range(getFortifyTurns(), 0, GC.getDefineINT("MAX_FORTIFY_TURNS")) * GC.getFORTIFY_MODIFIER_PER_TURN();
}


int CvUnit::fortifyRepelModifier() const
{
	if (!isFortifyable() || noDefensiveBonus())
	{
		return 0;
	}
	return getFortifyTurns() * fortRepelTotal();
}
//TB Combat Mods end

int CvUnit::experienceNeeded(int iLvlOffset) const
{
	int iExperienceNeeded = calcBaseExpNeeded(getLevel() + iLvlOffset, getOwner());

	if (isCommander())
	{
		iExperienceNeeded *= 3;
		iExperienceNeeded /= 2;
	}
	return iExperienceNeeded;
}


int CvUnit::attackXPValue() const
{
	return m_pUnitInfo->getXPValueAttack();
}


int CvUnit::defenseXPValue() const
{
	return m_pUnitInfo->getXPValueDefense();
}


int CvUnit::maxXPValue(const CvUnit* pVictim, bool bBarb) const
{
	if (GC.getGame().isOption(GAMEOPTION_INFINITE_XP) || isNPC())
	{
		return -1;
	}
	int iMaxValue = -1;

	if (pVictim != NULL && pVictim->isAnimal())
	{
		if (!isHasUnitCombat(GC.getUNITCOMBAT_EXPLORER())
		&& !isHasPromotion(GC.getPROMOTION_ANIMAL_HUNTER()))
		{
			iMaxValue = GC.getANIMAL_MAX_XP_VALUE();
		}
	}
	else if (pVictim != NULL && pVictim->isHominid() || bBarb)
	{
		if (!isHasUnitCombat(GC.getUNITCOMBAT_RECON())
		&& !isHasPromotion(GC.getPROMOTION_BARBARIAN_HUNTER()))
		{
			iMaxValue = GC.getBARBARIAN_MAX_XP_VALUE();
		}
	}
	else if (pVictim != NULL && getUnitCombatType() == GC.getUNITCOMBAT_HUNTER())
	{
		if (!isHasPromotion(GC.getPROMOTION_BARBARIAN_HUNTER())
		&& pVictim->getUnitCombatType() != GC.getUNITCOMBAT_ANIMAL())
		{
			iMaxValue = GC.getBARBARIAN_MAX_XP_VALUE();
		}
	}
	if (iMaxValue > 0 && GC.getGame().isOption(GAMEOPTION_MORE_XP_TO_LEVEL))
	{
		iMaxValue *= GC.getMORE_XP_TO_LEVEL_MODIFIER();
		iMaxValue /= 100;
	}
	return iMaxValue;
}


int CvUnit::firstStrikes() const
{
	return std::max(0, (m_pUnitInfo->getFirstStrikes() + getExtraFirstStrikes()));
}


int CvUnit::chanceFirstStrikes() const
{
	return std::max(0, (m_pUnitInfo->getChanceFirstStrikes() + getExtraChanceFirstStrikes()));
}


int CvUnit::maxFirstStrikes() const
{
	return (firstStrikes() + chanceFirstStrikes());
}


bool CvUnit::isRanged() const
{
	const int groupDefinitions = getUnitInfo().getGroupDefinitions();
	for (int  i = 0; i < groupDefinitions; i++)
	{
		if ( !getArtInfo(i, GET_PLAYER(getOwner()).getCurrentEra())->getActAsRanged() )
		{
			return false;
		}
	}
	return true;
}


bool CvUnit::alwaysInvisible() const
{
	return m_pUnitInfo->isInvisible() || getAlwaysInvisibleCount() > 0;
}


bool CvUnit::immuneToFirstStrikes() const
{
	return (m_pUnitInfo->isFirstStrikeImmune() || (getImmuneToFirstStrikesCount() > 0));
}


bool CvUnit::noDefensiveBonus() const
{
	int iCount = m_pUnitInfo->isNoDefensiveBonus();
	iCount += getExtraNoDefensiveBonusCount();
	return (iCount > 0);
}

int CvUnit::getExtraNoDefensiveBonusCount() const
{
	return m_iExtraNoDefensiveBonusCount;
}

void CvUnit::changeExtraNoDefensiveBonusCount(int iChange)
{
	m_iExtraNoDefensiveBonusCount += iChange;
}

bool CvUnit::ignoreBuildingDefense() const
{
	return m_pUnitInfo->isIgnoreBuildingDefense();
}


bool CvUnit::canMoveImpassable() const
{
	return (m_pUnitInfo->isCanMoveImpassable() || canFliesToMove());
}

bool CvUnit::canMoveAllTerrain() const
{
	return (m_pUnitInfo->isCanMoveAllTerrain() || canFliesToMove());
}

bool CvUnit::flatMovementCost() const
{
	//soon as the pathing engine can handle it this should be uncommented.
	return (/*canFliesToMove() ||*/ m_pUnitInfo->isFlatMovementCost());
}

bool CvUnit::ignoreTerrainCost() const
{
	return (m_pUnitInfo->isIgnoreTerrainCost() || canFliesToMove());
}

bool CvUnit::isNeverInvisible() const
{
	return !alwaysInvisible() && getInvisibleType() == NO_INVISIBLE && !hasAnyInvisibilityType();
}

int CvUnit::getNoInvisibilityCount() const
{
	return GC.getGame().isOption(GAMEOPTION_HIDE_AND_SEEK) * m_iNoInvisibilityCount;
}

void CvUnit::changeNoInvisibilityCount(int iChange)
{
	m_iNoInvisibilityCount += iChange;
	setHasAnyInvisibility();
}


bool CvUnit::isInvisible(TeamTypes eTeam, bool bDebug, bool bCheckCargo) const
{
	if (bDebug && GC.getGame().isDebugMode())
	{
		return false;
	}

	if (getTeam() == eTeam)
	{
		return false;
	}

	if (alwaysInvisible())
	{
		return true;
	}

	if (bCheckCargo && isCargo())
	{
		return true;
	}

	if (isNeverInvisible())
	{
		return false;
	}

	if (isRevealed())
	{
		return false;
	}

	if (!GC.getGame().isOption(GAMEOPTION_HIDE_AND_SEEK))
	{
		return getInvisibleType() != NO_INVISIBLE && !plot()->isSpotterInSight(eTeam, getInvisibleType());
	}

	if (hasAnyInvisibilityType())
	{
		for (int iI = GC.getNumInvisibleInfos() - 1; iI > -1; iI--)
		{
			const InvisibleTypes eInvisible = static_cast<InvisibleTypes>(iI);

			if (hasInvisibilityType(eInvisible))
			{
				if (!plot()->isSpotterInSight(eTeam, eInvisible))
				{
					return true;
				}
				const int iIntensity = invisibilityIntensityTotal(eInvisible);

				if ((iIntensity > 0 || GC.getInvisibleInfo(eInvisible).isIntrinsic())
				&& plot()->getHighestPlotTeamVisibilityIntensity(eInvisible, eTeam) < iIntensity)
				{
					return true;
				}
			}
		}
	}
	return false;
}


bool CvUnit::isNukeImmune() const
{
	return m_pUnitInfo->isNukeImmune();
}


bool CvUnit::isInquisitor() const
{
	return m_pUnitInfo->isInquisitor();
}


int CvUnit::maxInterceptionProbability(bool bIgnoreCommanders) const
{
	return std::min(GC.getDefineINT("MAX_INTERCEPTION_PROBABILITY"),std::max(0, m_pUnitInfo->getInterceptionProbability() + getExtraIntercept(bIgnoreCommanders)));
}


int CvUnit::currInterceptionProbability() const
{
	if (getDomainType() != DOMAIN_AIR && !GC.getGame().isModderGameOption(MODDERGAMEOPTION_BETTER_INTERCETION))
	{
		return maxInterceptionProbability();
	}
	return maxInterceptionProbability() * getHP() / getMaxHP();
}


int CvUnit::evasionProbability(bool bIgnoreCommanders) const
{
	return std::min(GC.getDefineINT("MAX_EVASION_PROBABILITY"),std::max(0, m_pUnitInfo->getEvasionProbability() + getExtraEvasion(bIgnoreCommanders)));
}


int CvUnit::withdrawalProbability() const
{
	const int iProbability = m_pUnitInfo->getWithdrawalProbability() + getExtraWithdrawal() /*+ escapeModifier()*/;

	if (shouldUseWithdrawalOddsCap())
	{
		return std::min(GC.getDefineINT("MAX_WITHDRAWAL_PROBABILITY"), std::max(0, iProbability));
	}
	return std::max(0, iProbability);
}
//TB Combat Mods Begin
int CvUnit::attackCombatModifierTotal() const
{
	return (m_pUnitInfo->getAttackCombatModifier() + getExtraAttackCombatModifier());
}

int CvUnit::defenseCombatModifierTotal() const
{
	if (noDefensiveBonus())
	{
		return 0;
	}

	return (m_pUnitInfo->getDefenseCombatModifier() + getExtraDefenseCombatModifier());
}

int CvUnit::pursuitProbability() const
{
	if (!GC.getGame().isOption(GAMEOPTION_FIGHT_OR_FLIGHT))
	{
		return 0;
	}
	if (getDomainType() == DOMAIN_LAND && plot()->isWater())
	{
		return 0;
	}
	return std::max(0, (m_pUnitInfo->getPursuit() + getExtraPursuit() + currentWithdrawAdjperAttTotal()));
}

int CvUnit::earlyWithdrawTotal() const
{
	if (!GC.getGame().isOption(GAMEOPTION_FIGHT_OR_FLIGHT))
	{
		return 0;
	}
	if (getDomainType() == DOMAIN_LAND && plot()->isWater())
	{
		return 0;
	}
	return std::max(0, (m_pUnitInfo->getEarlyWithdraw() + getExtraEarlyWithdraw()));
}

int CvUnit::vsBarbsModifier() const
{
	return (m_pUnitInfo->getVSBarbs() + getExtraVSBarbs());
}

int CvUnit::religiousCombatModifierTotal(ReligionTypes eReligion, bool bDisplay) const
{
	if (bDisplay || (getReligion() != NO_RELIGION))
	{
		if (bDisplay || getReligion() != eReligion)
		{
			return (m_pUnitInfo->getReligiousCombatModifier() + getExtraReligiousCombatModifier());
		}
		else if (getReligion() == eReligion)
		{
			return -(m_pUnitInfo->getReligiousCombatModifier() + getExtraReligiousCombatModifier());
		}
	}
	return 0;
}

int CvUnit::armorTotal() const
{
	return std::max(0, (m_pUnitInfo->getArmor() + getExtraArmor()));
}

int CvUnit::punctureTotal() const
{
	return std::max(0, (m_pUnitInfo->getPuncture() + getExtraPuncture()));
}

int CvUnit::damageModifierTotal() const
{
	return std::max(-95, (m_pUnitInfo->getDamageModifier() + getExtraDamageModifier()));
}

int CvUnit::costModifierTotal() const
{
	return 0;
}

int CvUnit::overrunTotal() const
{
	if (getDomainType() == DOMAIN_LAND && plot()->isWater())
	{
		return 0;
	}
	return std::max(0, (m_pUnitInfo->getOverrun() + getExtraOverrun()));
}

int CvUnit::repelTotal() const
{
	if (noDefensiveBonus() || (getDomainType() == DOMAIN_LAND && plot()->isWater()))
	{
		return 0;
	}
	return std::max(0, (m_pUnitInfo->getRepel() + getExtraRepel() + getCityRepel()));
}

int CvUnit::fortRepelTotal() const
{
	if (noDefensiveBonus() || (getDomainType() == DOMAIN_LAND && plot()->isWater()))
	{
		return 0;
	}
	return std::max(0, (m_pUnitInfo->getFortRepel() + getExtraFortRepel()));
}

int CvUnit::repelRetriesTotal() const
{
	if (noDefensiveBonus() ||  (getDomainType() == DOMAIN_LAND && plot()->isWater()))
	{
		return 0;
	}
	return std::max(0, (m_pUnitInfo->getRepelRetries() + getExtraRepelRetries()));
}

int CvUnit::unyieldingTotal() const
{
	if (getDomainType() == DOMAIN_LAND && plot()->isWater())
	{
		return 0;
	}
	return std::max(0, (m_pUnitInfo->getUnyielding() + getExtraUnyielding()));
}

int CvUnit::knockbackTotal() const
{
	if (getDomainType() == DOMAIN_LAND && plot()->isWater())
	{
		return 0;
	}
	return std::max(0, (m_pUnitInfo->getKnockback() + getExtraKnockback()));
}

int CvUnit::knockbackRetriesTotal() const
{
	if (getDomainType() == DOMAIN_LAND && plot()->isWater())
	{
		return 0;
	}
	return std::max(0, (m_pUnitInfo->getKnockbackRetries() + getExtraKnockbackRetries()));
}

bool CvUnit::canStampede() const
{
	return (m_pUnitInfo->isStampede() || mayStampede()) && !cannotStampede();
}

bool CvUnit::canAttackOnlyCities() const
{
	int iTrueCount = 0;

	if (m_pUnitInfo->isAttackOnlyCities())
	{
		iTrueCount++;
	}
	iTrueCount += getAttackOnlyCitiesCount();

	return iTrueCount > 0;
}

bool CvUnit::canIgnoreNoEntryLevel() const
{
	int iTrueCount = 0;

	if (m_pUnitInfo->isIgnoreNoEntryLevel())
	{
		iTrueCount++;
	}
	iTrueCount += getIgnoreNoEntryLevelCount();

	return iTrueCount > 0;
}

bool CvUnit::canIgnoreZoneofControl() const
{
	int iTrueCount = 0;

	if (m_pUnitInfo->isIgnoreZoneofControl())
	{
		iTrueCount++;
	}
	iTrueCount += getIgnoreZoneofControlCount();

	return iTrueCount > 0;
}

bool CvUnit::canFliesToMove() const
{
	int iTrueCount = 0;

	if (m_pUnitInfo->isFliesToMove())
	{
		iTrueCount++;
	}
	iTrueCount += getFliesToMoveCount();

	return iTrueCount > 0;
}

int CvUnit::strAdjperRndTotal() const
{
	int iStrAdjperRnd = getExtraStrAdjperRnd();
#ifdef BATTLEWORN
	iStrAdjperRnd += m_pUnitInfo->getStrAdjperRnd();
#endif
	if (iStrAdjperRnd < 0)
	{
		iStrAdjperRnd = std::max(0, (iStrAdjperRnd + enduranceTotal()));
	}
	return iStrAdjperRnd;
}

int CvUnit::strAdjperAttTotal() const
{
	int iStrAdjperAtt = getExtraStrAdjperAtt();
#ifdef BATTLEWORN
	iStrAdjperAtt += m_pUnitInfo->getStrAdjperAtt();
#endif
	if (iStrAdjperAtt < 0)
	{
		iStrAdjperAtt = std::max(0, (iStrAdjperAtt + enduranceTotal()));
	}
	return (iStrAdjperAtt);
}

int CvUnit::strAdjperDefTotal() const
{
	if (noDefensiveBonus())
	{
		return 0;
	}
	return getExtraStrAdjperDef()
#ifdef BATTLEWORN
		+ m_pUnitInfo->getStrAdjperDef()
#endif
	;
}

int CvUnit::withdrawAdjperAttTotal() const
{
	int iWithdrawAdjperAtt = getExtraWithdrawAdjperAtt();
#ifdef BATTLEWORN
	iWithdrawAdjperAtt += m_pUnitInfo->getWithdrawAdjperAtt();
#endif
	if (iWithdrawAdjperAtt < 0)
	{
		iWithdrawAdjperAtt = std::max(0, (iWithdrawAdjperAtt + enduranceTotal()));
	}
	return iWithdrawAdjperAtt;
}

int CvUnit::currentStrAdjperRndTotal() const
{
	return strAdjperRndTotal() * getRoundCount();
}

int CvUnit::currentStrAdjperAttTotal() const
{
	return strAdjperAttTotal() * getAttackCount();
}

int CvUnit::currentStrAdjperDefTotal() const
{
	if (noDefensiveBonus())
	{
		return 0;
	}
	return strAdjperDefTotal() * getDefenseCount();
}

int CvUnit::currentWithdrawAdjperAttTotal() const
{
	return withdrawAdjperAttTotal() * getAttackCount();
}

int CvUnit::unnerveTotal() const
{
	return std::max(0, (m_pUnitInfo->getUnnerve() + getExtraUnnerve()));
}

int CvUnit::encloseTotal() const
{
	return std::max(0, (m_pUnitInfo->getEnclose() + getExtraEnclose()));
}

int CvUnit::lungeTotal() const
{
	return std::max(0, (m_pUnitInfo->getLunge() + getExtraLunge()));
}

int CvUnit::dynamicDefenseTotal() const
{
	int iData = m_pUnitInfo->getDynamicDefense() + getExtraDynamicDefense();

	if (plot()->isCity(false, getTeam()))
	{
		iData += plot()->getPlotCity()->getExtraLocalDynamicDefense();
	}
	return std::max(0, iData);
}

bool CvUnit::canAnimalIgnoresBorders() const
{
    if (GC.getGame().isOption(GAMEOPTION_DANGEROUS_WILDLIFE))
    {
        return true;
    }
	if (!GC.getGame().isOption(GAMEOPTION_ANIMALS_STAY_OUT) && mayAnimalIgnoresBorders())
	{
		return true;
	}
	return false;
}

bool CvUnit::canAnimalIgnoresImprovements() const
{
    if (GC.getGame().isOption(GAMEOPTION_DANGEROUS_WILDLIFE))
    {
        return true;
    }
	if (!GC.getGame().isOption(GAMEOPTION_ANIMALS_STAY_OUT))
	{
		int iAnswer = m_pUnitInfo->canAnimalIgnoresBorders();
		iAnswer += getAnimalIgnoresBordersCount();
		return (iAnswer > 1);
	}
	return false;
}

bool CvUnit::canAnimalIgnoresCities() const
{
	if (!GC.getGame().isOption(GAMEOPTION_ANIMALS_STAY_OUT))
	{
		int iAnswer = m_pUnitInfo->canAnimalIgnoresBorders();
		iAnswer += getAnimalIgnoresBordersCount();
		return (iAnswer > 2);
	}
	return false;
}

bool CvUnit::canOnslaught() const
{
	return m_pUnitInfo->isOnslaught() || mayOnslaught();
}

bool CvUnit::hasCombatType(UnitCombatTypes eCombatType) const
{
	if ((getUnitCombatType() == eCombatType || hasExtraSubCombatType(eCombatType)) && !hasRemovesUnitCombatType(eCombatType))
	{
		return true;
	}
	// AIAndy: This could be removed if the unit type sub combat types get added to the extra sub combat type counts
	return algo::any_of_equal(m_pUnitInfo->getSubCombatTypes(), eCombatType);;
}

bool CvUnit::hasSubCombatType(UnitCombatTypes eCombatType) const
{
	const bool bSubCombat = algo::any_of_equal(m_pUnitInfo->getSubCombatTypes(), eCombatType);

	if ((bSubCombat || hasExtraSubCombatType(eCombatType)) && m_pUnitInfo->getUnitCombatType() != eCombatType && !hasRemovesUnitCombatType(eCombatType))
	{
		return true;
	}
	return false;
}

#ifdef OUTBREAKS_AND_AFFLICTIONS
bool CvUnit::hasCureAfflictionType(PromotionLineTypes ePromotionLineType) const
{
	bool bCureAffliction = ePromotionLineType != NO_PROMOTIONLINE && hasExtraCureAffliction(ePromotionLineType);
	if (!bCureAffliction)
	{
		for (int iI = 0; iI < m_pUnitInfo->getNumCureAfflictionTypes(); iI++)
		{
			if (m_pUnitInfo->getCureAfflictionType(iI) == (int)ePromotionLineType)
			{
				bCureAffliction = true;
			}
		}
	}
	return bCureAffliction;
}

int CvUnit::fortitudeTotal() const
{
	return m_pUnitInfo->getFortitude() + getExtraFortitude();
}

int CvUnit::aidTotal(PropertyTypes eProperty) const
{
	return std::max(0, (m_pUnitInfo->getAidChange((int)eProperty) + extraAidChange(eProperty)));
}
#endif // OUTBREAKS_AND_AFFLICTIONS

int CvUnit::dodgeTotal() const
{
	const int iChill = std::max(
		0, getColdDamage() - getColdDamage() * enduranceTotal() / 10
	);
	const int iDodge = m_pUnitInfo->getDodgeModifier() + getExtraDodgeModifier() + 100;

	return iDodge - iDodge * iChill / 100;
}

int CvUnit::precisionTotal() const
{
	const int iChill = std::max(
		0, getColdDamage() - getColdDamage() * enduranceTotal() / 10
	);
	const int iPrecision = m_pUnitInfo->getPrecisionModifier() + getExtraPrecisionModifier() + 100;

	return iPrecision - iPrecision * iChill / 100;
}

int CvUnit::powerShotsTotal() const
{
	return m_pUnitInfo->getPowerShots() + getExtraPowerShots();
}

int CvUnit::powerShotCombatModifierTotal() const
{
	return m_pUnitInfo->getPowerShotCombatModifier() + getExtraPowerShotCombatModifier();
}

int CvUnit::powerShotPunctureModifierTotal() const
{
	return m_pUnitInfo->getPowerShotPunctureModifier() + getExtraPowerShotPunctureModifier();
}

int CvUnit::powerShotPrecisionModifierTotal() const
{
	return m_pUnitInfo->getPowerShotPrecisionModifier() + getExtraPowerShotPrecisionModifier();
}

int CvUnit::powerShotCriticalModifierTotal() const
{
	return m_pUnitInfo->getPowerShotCriticalModifier() + getExtraPowerShotCriticalModifier();
}

int CvUnit::criticalModifierTotal() const
{
	return m_pUnitInfo->getCriticalModifier() + getExtraCriticalModifier();
}

int CvUnit::enduranceTotal() const
{
	return m_pUnitInfo->getEndurance() + getExtraEndurance();
}

bool CvUnit::dealsColdDamage() const
{
	return (m_pUnitInfo->isDealsColdDamage() || mayDealColdDamage()) && !cannotDealColdDamage();
}

bool CvUnit::hasImmunitytoColdDamage() const
{
	return (m_pUnitInfo->isColdImmune() || mayColdImmune()) && !cannotColdImmune();
}

int CvUnit::poisonProbabilityModifierTotal() const
{
	return m_pUnitInfo->getPoisonProbabilityModifier() + getExtraPoisonProbabilityModifier();
}
//TB Combat Mods End


int CvUnit::collateralDamage() const
{
	int iTotal = m_pUnitInfo->getCollateralDamage();
	iTotal += getExtraCollateralDamage();
	return std::max(0, iTotal);
}

int CvUnit::collateralDamageLimit() const
{
	return std::max(0, (m_pUnitInfo->getCollateralDamageLimit() + getCollateralDamageLimitChange()) * GC.getMAX_HIT_POINTS() / 100);
}

int CvUnit::collateralDamageMaxUnits() const
{
	return std::max(0, (m_pUnitInfo->getCollateralDamageMaxUnits() + getCollateralDamageMaxUnitsChange()));
}


int CvUnit::cityAttackModifier() const
{
	return (m_pUnitInfo->getCityAttackModifier() + getExtraCityAttackPercent());
}

int CvUnit::cityDefenseModifier() const
{
	if (noDefensiveBonus())
	{
		return 0;
	}
	return (m_pUnitInfo->getCityDefenseModifier() + getExtraCityDefensePercent());
}

int CvUnit::cityDefenseVSOpponent(const CvUnit* pOpponent) const
{
	if (noDefensiveBonus())
	{
		return 0;
	}
	const CvCity* pCity = plot()->getPlotCity();
	int iValue = 0;

	for (std::map<UnitCombatTypes, UnitCombatKeyedInfo>::const_iterator it = pOpponent->m_unitCombatKeyedInfo.begin(), end = pOpponent->m_unitCombatKeyedInfo.end(); it != end; ++it)
	{
		if (it->second.m_bHasUnitCombat)
		{
			if (plot()->isCity(false, getTeam()))
			{
				iValue += pCity->getUnitCombatDefenseAgainstModifierTotal(it->first);
			}
		}
	}
	return iValue;
}


int CvUnit::animalCombatModifier() const
{
	return m_pUnitInfo->getAnimalCombatModifier();
}


int CvUnit::hillsAttackModifier() const
{
	return (m_pUnitInfo->getHillsAttackModifier() + getExtraHillsAttackPercent());
}


int CvUnit::hillsDefenseModifier() const
{
	if (noDefensiveBonus())
	{
		return 0;
	}
	return (m_pUnitInfo->getHillsDefenseModifier() + getExtraHillsDefensePercent());
}


int CvUnit::terrainAttackModifier(TerrainTypes eTerrain) const
{
	FASSERT_BOUNDS(0, GC.getNumTerrainInfos(), eTerrain);
	return (m_pUnitInfo->getTerrainAttackModifier(eTerrain) + getExtraTerrainAttackPercent(eTerrain));
}


int CvUnit::terrainDefenseModifier(TerrainTypes eTerrain) const
{
	if (noDefensiveBonus())
	{
		return 0;
	}
	FASSERT_BOUNDS(0, GC.getNumTerrainInfos(), eTerrain);
	return (m_pUnitInfo->getTerrainDefenseModifier(eTerrain) + getExtraTerrainDefensePercent(eTerrain));
}


int CvUnit::featureAttackModifier(FeatureTypes eFeature) const
{
	FASSERT_BOUNDS(0, GC.getNumFeatureInfos(), eFeature);
	return (m_pUnitInfo->getFeatureAttackModifier(eFeature) + getExtraFeatureAttackPercent(eFeature));
}

int CvUnit::featureDefenseModifier(FeatureTypes eFeature) const
{
	if (noDefensiveBonus())
	{
		return 0;
	}
	FASSERT_BOUNDS(0, GC.getNumFeatureInfos(), eFeature);
	return (m_pUnitInfo->getFeatureDefenseModifier(eFeature) + getExtraFeatureDefensePercent(eFeature));
}

int CvUnit::unitAttackModifier(UnitTypes eUnit) const
{
	FASSERT_BOUNDS(0, GC.getNumUnitInfos(), eUnit);
	return m_pUnitInfo->getUnitAttackModifier(eUnit);
}


int CvUnit::unitDefenseModifier(UnitTypes eUnit) const
{
	if (noDefensiveBonus())
	{
		return 0;
	}
	FASSERT_BOUNDS(0, GC.getNumUnitInfos(), eUnit);
	return m_pUnitInfo->getUnitDefenseModifier(eUnit);
}


int CvUnit::unitCombatModifier(UnitCombatTypes eUnitCombat) const
{
	FASSERT_BOUNDS(0, GC.getNumUnitCombatInfos(), eUnitCombat);
	return (m_pUnitInfo->getUnitCombatModifier(eUnitCombat) + getExtraUnitCombatModifier(eUnitCombat));
}


int CvUnit::domainModifier(DomainTypes eDomain) const
{
	FASSERT_BOUNDS(0, NUM_DOMAIN_TYPES, eDomain);
	return (m_pUnitInfo->getDomainModifier(eDomain) + getExtraDomainModifier(eDomain));
}



SpecialUnitTypes CvUnit::specialCargo() const
{
	return getSpecialCargo();
}

SpecialUnitTypes CvUnit::SMspecialCargo() const
{
	return getSMSpecialCargo();
}

SpecialUnitTypes CvUnit::SMnotSpecialCargo() const
{
	return getSMNotSpecialCargo();
}

DomainTypes CvUnit::domainCargo() const
{
	return getDomainCargo();
}

int CvUnit::cargoSpace() const
{
	int iCargoCapacity = m_pUnitInfo->getCargoSpace() + m_iCargoCapacity;

	if (getDomainType() == DOMAIN_SEA)
	{
		iCargoCapacity += GET_PLAYER(getOwner()).getNationalNavalCargoSpaceChange();
	}
	if (specialCargo() == GC.getSPECIALUNIT_MISSILE())
	{
		iCargoCapacity += GET_PLAYER(getOwner()).getNationalMissileCargoSpaceChange();
	}
	return iCargoCapacity;
}

void CvUnit::changeCargoSpace(int iChange)
{
	if (iChange != 0)
	{
		m_iCargoCapacity += iChange;
		FASSERT_NOT_NEGATIVE(m_iCargoCapacity);
		setInfoBarDirty(true);
	}
}

bool CvUnit::isFull() const
{
	if (GC.getGame().isOption(GAMEOPTION_SIZE_MATTERS))
	{
		return SMgetCargo() >= SMcargoSpace();
	}
	return getCargo() >= cargoSpace();
}


int CvUnit::cargoSpaceAvailable(SpecialUnitTypes eSpecialCargo, DomainTypes eDomainCargo) const
{
	if (specialCargo() != NO_SPECIALUNIT && specialCargo() != eSpecialCargo)
	{
		return 0;
	}
	if (domainCargo() != NO_DOMAIN && domainCargo() != eDomainCargo)
	{
		return 0;
	}
	return std::max(0, cargoSpace() - getCargo());
}


int CvUnit::SMcargoSpaceAvailable(SpecialUnitTypes eSpecialCargo, DomainTypes eDomainCargo) const
{
	if  (eSpecialCargo != NO_SPECIALUNIT)
	{
		if (SMspecialCargo() != NO_SPECIALUNIT
		&& !GC.getSpecialUnitInfo(eSpecialCargo).isSMLoadSame()
		&& SMspecialCargo() != eSpecialCargo)
		{
			return 0;
		}
		if (SMnotSpecialCargo() != NO_SPECIALUNIT
		&& SMnotSpecialCargo() == eSpecialCargo)
		{
			return 0;
		}
	}
	if (eDomainCargo != NO_DOMAIN
	&& domainCargo() != NO_DOMAIN
	&& domainCargo() != eDomainCargo)
	{
		return 0;
	}
	return std::max(0, SMcargoSpace() - SMgetCargo());
}


bool CvUnit::hasCargo() const
{
	return SMgetCargo() > 0 || getCargo() > 0;
}


bool CvUnit::canCargoAllMove() const
{
	return algo::none_of(plot()->units(),
		CvUnit::fn::getTransportUnit() == this &&
		CvUnit::fn::getDomainType() == DOMAIN_LAND &&
		!CvUnit::fn::canMove()
	);
}

bool CvUnit::canCargoEnterArea(TeamTypes eTeam, const CvArea* pArea, bool bIgnoreRightOfPassage) const
{
	return algo::none_of(plot()->units(),
		CvUnit::fn::getTransportUnit() == this &&
		!CvUnit::fn::canEnterArea(eTeam, pArea, bIgnoreRightOfPassage)
	);
}

int CvUnit::getUnitAICargo(UnitAITypes eUnitAI) const
{
	std::vector<CvUnit*> aCargoUnits;
	getCargoUnits(aCargoUnits);
	return algo::count_if(aCargoUnits, bind(CvUnit::AI_getUnitAIType, _1) == eUnitAI);
}


int CvUnit::getID() const
{
	return m_iID;
}


int CvUnit::getIndex() const
{
	return (getID() & FLTA_INDEX_MASK);
}


IDInfo CvUnit::getIDInfo() const
{
	IDInfo unit(getOwner(), getID());
	return unit;
}


void CvUnit::setID(int iID)
{
	m_iID = iID;
}


int CvUnit::getGroupID() const
{
	return m_iGroupID;
}


bool CvUnit::isInGroup() const
{
	return(getGroupID() != FFreeList::INVALID_INDEX);
}


bool CvUnit::isGroupHead() const
{
	return getGroup()->getHeadUnit() == this;
}


CvSelectionGroup* CvUnit::getGroup() const
{
	return GET_PLAYER(getOwner()).getSelectionGroup(getGroupID());
}

bool CvUnit::canJoinGroup(const CvPlot* pPlot, const CvSelectionGroup* pSelectionGroup) const
{
	// do not allow someone to join a group that is about to be split apart
	// this prevents a case of a never-ending turn
	if (pSelectionGroup->AI_isForceSeparate())
	{
		return false;
	}
	const CvUnit* pHeadUnit = pSelectionGroup->getHeadUnit();

	if (pSelectionGroup->getOwner() == NO_PLAYER)
	{
		if (pHeadUnit != NULL && pHeadUnit->getOwner() != getOwner())
		{
			return false;
		}
	}
	else if (pSelectionGroup->getOwner() != getOwner())
	{
		return false;
	}

	if (pSelectionGroup->getNumUnits() > 0)
	{
		if (pPlot != NULL && !pSelectionGroup->atPlot(pPlot))
		{
			return false;
		}

		//	Can't join a group that is loaded onto a transport as this
		//	would bypass the transport's record of what units it has on
		//	board
		if (pHeadUnit->isCargo())
		{
			if (pHeadUnit->isHuman() && pHeadUnit->getTransportUnit() == getTransportUnit())
			{
				return true;
			}
			return false;
		}
		//TB Note: Although it seems very unusual, checking for null pPlot allows this check to be safe for inter-domain upgrades.
		//this is important for immobile units to land or sea or air.  Could also enable some units to go from land or sea to air or vice versa.
		//if pPlot is NULL, the only known cause would be that the unit is, in fact, upgrading.
		if (pPlot != NULL && pSelectionGroup->getDomainType() != getDomainType())
		{
			return false;
		}
	}

	return true;
}


void CvUnit::joinGroup(CvSelectionGroup* pSelectionGroup, bool bRemoveSelected, bool bRejoin)
{
	PROFILE_FUNC();

	CvSelectionGroup* pOldSelectionGroup = GET_PLAYER(getOwner()).getSelectionGroup(getGroupID());
	CvSelectionGroup* pNewSelectionGroup = NULL;

	if (pSelectionGroup != pOldSelectionGroup && pSelectionGroup != NULL
	&& pSelectionGroup->getHeadUnit() != NULL
	&& pSelectionGroup->getHeadUnit()->isWaitingOnUnitAI((int)AI_getUnitAIType()))
	{
		pSelectionGroup->getHeadUnit()->setToWaitOnUnitAI(AI_getUnitAIType(), false);
	}

	if (pSelectionGroup != pOldSelectionGroup || pOldSelectionGroup == NULL)
	{
		CvPlot* pPlot = plot();

		if (pSelectionGroup != NULL)
		{
			pNewSelectionGroup = pSelectionGroup;
		}
		else if (bRejoin)
		{
			const int iSelectionRegroup = GET_PLAYER(getOwner()).getSelectionRegroup();

			if (iSelectionRegroup != NULL)
			{
				pNewSelectionGroup = GET_PLAYER(getOwner()).getSelectionGroup(iSelectionRegroup);

				if (!canJoinGroup(pPlot, pNewSelectionGroup))
				{
					pNewSelectionGroup = GET_PLAYER(getOwner()).addSelectionGroup();
					FAssert(pNewSelectionGroup != NULL);
					pNewSelectionGroup->init(pNewSelectionGroup->getID(), getOwner());
				}
			}
			else
			{
				pNewSelectionGroup = GET_PLAYER(getOwner()).addSelectionGroup();
				FAssert(pNewSelectionGroup != NULL);
				pNewSelectionGroup->init(pNewSelectionGroup->getID(), getOwner());
			}
		}

		if (pNewSelectionGroup == NULL || canJoinGroup(pPlot, pNewSelectionGroup))
		{
			if (pOldSelectionGroup != NULL)
			{
				const bool bWasHead = !isHuman()
					&& pOldSelectionGroup->getNumUnits() > 1
					&& pOldSelectionGroup->getHeadUnit() == this;

				pOldSelectionGroup->removeUnit(this);

				// if we were the head, if the head unitAI changed, then force the group to separate (non-humans)
				if (bWasHead)
				{
					if (isWaitingOnUnitAIAny())
					{
						for (int iI = 0; iI < NUM_UNITAI_TYPES; iI++)
						{
							if (isWaitingOnUnitAI(iI))
							{
								setToWaitOnUnitAI((UnitAITypes)iI, false);
							}
						}
					}
					FAssert(pOldSelectionGroup->getHeadUnit() != NULL);

					if (!pOldSelectionGroup->isChoosingNewLeader()
					&& pOldSelectionGroup->getHeadUnit()->AI_getUnitAIType() != AI_getUnitAIType()
					// Special case to try to hold together city attacks that are breaking up but can still succeed
					// If we have lost the last city_attack AI unit see if we have a unit that COULD take over in the SAME role
					&& (UNITAI_ATTACK_CITY != AI_getUnitAIType() || !pOldSelectionGroup->findNewLeader(UNITAI_ATTACK_CITY)))
					{
						pOldSelectionGroup->AI_makeForceSeparate();
					}
				}
			}

			if (pNewSelectionGroup != NULL)
			{
				if (pNewSelectionGroup->getHeadUnit() != NULL && pNewSelectionGroup->getHeadUnit()->isWaitingOnUnitAI((int)AI_getUnitAIType()))
				{
					pNewSelectionGroup->getHeadUnit()->setToWaitOnUnitAI(AI_getUnitAIType(), false);
				}

				//	Normal rules apply when we join someone else's group unless
				//	the priority chnage was actually to DOWNgrade our priority
				if (AI_groupFirstVal() != LEADER_PRIORITY_MIN)
				{
					AI_setLeaderPriority(-1);
				}

				m_iGroupID = pNewSelectionGroup->getID();

				if (!pNewSelectionGroup->addUnit(this, false))
				{
					m_iGroupID = FFreeList::INVALID_INDEX;
				}
			}
			else
			{
				//	Normal rules apply when we are alone again
				AI_setLeaderPriority(-1);

				m_iGroupID = FFreeList::INVALID_INDEX;
			}

			if (getGroup() != NULL)
			{
				if (getGroup()->getNumUnits() > 1)
				{
					if (getGroup()->canAllMove())
					{
						getGroup()->setActivityType(ACTIVITY_AWAKE);
					}
				}
				else
				{
					GET_PLAYER(getOwner()).updateGroupCycle(this, false);
				}
			}

			if (pPlot != NULL && getTeam() == GC.getGame().getActiveTeam())
			{
				pPlot->setFlagDirty(true);
			}

			if (pPlot == gDLL->getInterfaceIFace()->getSelectionPlot())
			{
				gDLL->getInterfaceIFace()->setDirty(PlotListButtons_DIRTY_BIT, true);
			}
		}

		if (bRemoveSelected && IsSelected())
		{
			gDLL->getInterfaceIFace()->removeFromSelectionList(this);
		}
	}
}


int CvUnit::getHotKeyNumber()
{
	return m_iHotKeyNumber;
}


void CvUnit::setHotKeyNumber(int iNewValue)
{
	FAssert(getOwner() != NO_PLAYER);

	if (getHotKeyNumber() != iNewValue)
	{
		if (iNewValue != -1)
		{
			foreach_(CvUnit* pLoopUnit, GET_PLAYER(getOwner()).units())
			{
				if (pLoopUnit->getHotKeyNumber() == iNewValue)
				{
					pLoopUnit->setHotKeyNumber(-1);
				}
			}
		}

		m_iHotKeyNumber = iNewValue;

		if (IsSelected())
		{
			gDLL->getInterfaceIFace()->setDirty(InfoPane_DIRTY_BIT, true);
		}
	}
}


int CvUnit::getViewportX() const
{
	const CvViewport* pCurrentViewPort = GC.getCurrentViewport();
	FAssert(pCurrentViewPort != NULL);

	return pCurrentViewPort->getViewportXFromMapX(m_iX);
}


int CvUnit::getViewportY() const
{
	const CvViewport* pCurrentViewPort = GC.getCurrentViewport();
	FAssert(pCurrentViewPort != NULL);

	return pCurrentViewPort->getViewportYFromMapY(m_iY);
}

bool CvUnit::isInViewport() const
{
	return GC.getCurrentViewport()->isInViewport(m_iX, m_iY);
}

bool CvUnit::isTempUnit() const
{
	return GET_PLAYER(getOwner()).isTempUnit(this);
}

void CvUnit::setXY(int iX, int iY, bool bGroup, bool bUpdate, bool bShow, bool bCheckPlotVisible, bool bInit)
{
	PROFILE_FUNC();
	/*GC.getGame().logOOSSpecial(1, getID(), iX, iY);*/

	// Temp units do not really exist, and are just used to provide a data anchor for virtual pathing calculations.
	// As such they do not need to process their position into the wider game state and indeed should not without additional concurrency protection.
	if (isTempUnit())
	{
		m_iX = iX;
		m_iY = iY;

		if (getGroup() == NULL)
		{
			joinGroup(NULL);
		}
		/*GC.getGame().logOOSSpecial(2, getID(), iX, iY);*/
		return;
	}
	const PlayerTypes eMyPlayer = getOwner();
	CvPlayer& myPlayer = GET_PLAYER(eMyPlayer);

	// If a unit moves we need to flush any combat str cache entries relating to it
	FlushCombatStrCache(this);

	/*
	// OOS!! Temporary for Out-of-Sync madness debugging...
	if (GC.getLogging())
	{
		PROFILE("CvUnit::setXY.OOSLogging");

		char szOut[1024];
		sprintf(szOut, "Player %d Unit %d (%S's %S) moving from %d:%d to %d:%d\n", eMyPlayer, getID(), myPlayer.getNameKey(), getName().GetCString(), getX(), getY(), iX, iY);
		gDLL->messageControlLog(szOut);
	}
	*/

	if (isFighting())
	{
		setCombatUnit(NULL);
	}
	if (at(iX, iY))
	{
		return;
	}
	FAssert(iX == INVALID_PLOT_COORD || GC.getMap().plot(iX, iY)->getX() == iX);
	FAssert(iY == INVALID_PLOT_COORD || GC.getMap().plot(iX, iY)->getY() == iY);

	// Activity before moving to the new plot
	const ActivityTypes eOldActivityType = getGroup() != NULL ? getGroup()->getActivityType() : NO_ACTIVITY;

	setBlockading(false);

	if (!bGroup || isCargo())
	{
		bShow = false;
	}

	CvPlot* pNewPlot = GC.getMap().plot(iX, iY);
	CvPlot* pOldPlot = plot();

	//	Koshling - Forcing the unit into a new group causes rapid cycling through the group id
	//	space, which is a scaling issue, so only do it when necessary
	//	Note - it used o do this unconditionally for cargo and changing that behavior
	//	might be dangerous, but it solves some scaling problems and I cannot think of a reason why
	//	it should be problematics, nor is it causing any issues in test cases I have tried
	if (!bGroup && (getGroup() == NULL || getGroup()->getNumUnits() > 1))
	{
		// Need valid plot() for joinGroup() so set our position now
		if (bInit || pOldPlot == nullptr)
		{
			m_iX = iX;
			m_iY = iY;
		}
		joinGroup(NULL, true);
	}

	if (pNewPlot != NULL)
	{
		PROFILE("CvUnit::setXY.NewPlot");

		CvUnit* pTransportUnit = getTransportUnit();

		if (pTransportUnit != NULL && !pTransportUnit->atPlot(pNewPlot))
		{
			setTransportUnit(NULL); // Departed from transport
		}

		if (canFight() && !isCargo())
		{
			if (!bInit && pOldPlot != NULL && !pNewPlot->isCity(false) && canAttack() && getDomainType() != DOMAIN_AIR)
			{
				if (!pNewPlot->hasDefender(false, NO_PLAYER, eMyPlayer, this, true, false, false, true))
				{
					while (pNewPlot->hasStealthDefender(this))
					{
						pNewPlot->revealBestStealthDefender(this);
						attack(pNewPlot, true, true);

						if (isDead() || at(iX, iY))
						{
							return;
						}
					}
				}
				else if (pNewPlot->getBestDefender(NO_PLAYER, eMyPlayer, this, true, true, false, false, true) != NULL)
				{
					attack(pNewPlot, true, false, true);

					if (isDead() || at(iX, iY))
					{
						return;
					}
				}
			}
			///TB: This next portion is to reset the plot list of the new plot before moving on after units may (probably were) have been destroyed in combat there.
			//This might be necessary for the trap segment below, to rerun this.
			if (!bInit && pOldPlot != NULL)
			{
				foreach_(CvUnit* unitX, pNewPlot->units_safe())
				{
					if ((isEnemy(unitX->getTeam(), pNewPlot) || unitX->isEnemy(getTeam()))
					&& !unitX->canCoexistWithAttacker(*this))
					{
						if (unitX->isArmedTrap())
						{
							unitX->doTrap(this);
						}
						else if (!unitX->canDefend(pNewPlot) && !unitX->isInvisible(getTeam(), false) && !unitX->isCargo())
						{
							//TB NOTE: This is where units that can't defend themselves are auto-captured IF the unit has a defined capture tag and cannot defend.
							if (!isNoCapture() && NO_UNIT != unitX->getUnitInfo().getUnitCaptureType())
							{
								if (isHiddenNationality() || unitX->isHiddenNationality())
								{
									GET_TEAM(unitX->getTeam()).changeWarWeariness(getTeam(), *pNewPlot, GC.getDefineINT("WW_UNIT_CAPTURED"));
									GET_TEAM(getTeam()).changeWarWeariness(unitX->getTeam(), *pNewPlot, GC.getDefineINT("WW_CAPTURED_UNIT"));
									GET_TEAM(getTeam()).AI_changeWarSuccess(unitX->getTeam(), GC.getDefineINT("WAR_SUCCESS_UNIT_CAPTURING"));
								}
								unitX->setCapturingPlayer(eMyPlayer);
								unitX->setCapturingUnit(this);
							}
							unitX->kill(false, eMyPlayer, true);
						}
					}
				}
			}
		}

		if (pNewPlot->isGoody(getTeam()) && !isNPC() && !m_pUnitInfo->isNoRevealMap())
		{
			myPlayer.doGoody(pNewPlot, this);
		}

		pNewPlot->area()->changeUnitsPerPlayer(eMyPlayer, 1);
		pNewPlot->area()->changePower(eMyPlayer, getPowerValueTotal());

		if (AI_getUnitAIType() != NO_UNITAI)
		{
			pNewPlot->area()->changeNumAIUnits(eMyPlayer, AI_getUnitAIType(), 1);
		}

		if (isAnimal())
		{
			pNewPlot->area()->changeAnimalsPerPlayer(eMyPlayer, 1);
		}

		if (pNewPlot->getTeam() != getTeam() && (pNewPlot->getTeam() == NO_TEAM || !GET_TEAM(pNewPlot->getTeam()).isVassal(getTeam())))
		{
			myPlayer.changeNumOutsideUnits(1);
		}
	}

	if (pOldPlot != NULL)
	{
		PROFILE("CvUnit::setXY.OldPlot");

		pOldPlot->removeUnit(this, bUpdate && !hasCargo());

		setFortifyTurns(0);

		pOldPlot->changeAdjacentSight(getTeam(), visibilityRange(pOldPlot), false, this, true);
		changeDebugCount(-1);

		pOldPlot->area()->changeUnitsPerPlayer(eMyPlayer, -1);
		pOldPlot->area()->changePower(eMyPlayer, -getPowerValueTotal());

		if (AI_getUnitAIType() != NO_UNITAI)
		{
			pOldPlot->area()->changeNumAIUnits(eMyPlayer, AI_getUnitAIType(), -1);
		}

		if (isAnimal())
		{
			pOldPlot->area()->changeAnimalsPerPlayer(eMyPlayer, -1);
		}

		if (pOldPlot->getTeam() != getTeam() && (pOldPlot->getTeam() == NO_TEAM || !GET_TEAM(pOldPlot->getTeam()).isVassal(getTeam())))
		{
			myPlayer.changeNumOutsideUnits(-1);
		}

		setLastMoveTurn(GC.getGame().getTurnSlice());

		CvCity* pOldCity = pOldPlot->getPlotCity();

		if (pOldCity != NULL)
		{
			if (isMilitaryHappiness())
			{
				pOldCity->changeMilitaryHappinessUnits(-1);
			}
			pOldCity->noteUnitMoved(this);
		}

		{
			CvCity* pWorkingCity = pOldPlot->getWorkingCity();

			if (pWorkingCity != NULL && canSiege(pWorkingCity->getTeam()))
			{
				pWorkingCity->AI_setAssignWorkDirty(true);
			}

			if (pOldPlot->isWater())
			{
				foreach_(const CvPlot* pLoopPlot, pOldPlot->adjacent() | filtered(CvPlot::fn::isWater()))
				{
					pWorkingCity = pLoopPlot->getWorkingCity();

					if (pWorkingCity != NULL && canSiege(pWorkingCity->getTeam()))
					{
						pWorkingCity->AI_setAssignWorkDirty(true);
					}
				}
			}
		}

		if (pOldPlot->isActiveVisible(true))
		{
			pOldPlot->updateMinimapColor();
		}

		if (pOldPlot == gDLL->getInterfaceIFace()->getSelectionPlot())
		{
			gDLL->getInterfaceIFace()->verifyPlotListColumn();

			gDLL->getInterfaceIFace()->setDirty(PlotListButtons_DIRTY_BIT, true);
		}
	}

	if (pNewPlot != NULL)
	{
		m_iX = pNewPlot->getX();
		m_iY = pNewPlot->getY();
	}
	else
	{
		m_iX = INVALID_PLOT_COORD;
		m_iY = INVALID_PLOT_COORD;
	}

	FAssertMsg(plot() == pNewPlot, "plot is expected to equal pNewPlot");

	if (pNewPlot != NULL)
	{
		PROFILE("CvUnit::setXY.NewPlot2");

		CvCity* pNewCity = pNewPlot->getPlotCity();

		if (pNewCity != NULL)//Again... is bUpdate only for when the unit is not cargo?
		{
			PROFILE("CvUnit::setXY.NewPlot2.NewCity");

			if (myPlayer.isInvasionCapablePlayer()
			&& !isBlendIntoCity()
			&& isEnemy(pNewCity->getTeam())
			&& (
				!canCoexistWithTeamOnPlot(pNewCity->getTeam(), *pNewPlot)
				|| !pNewPlot->isVisibleEnemyDefender(this)
			)
			&& canFight()
			&& !(isHiddenNationality() && pNewCity->isNPC())
			&& !isCargo())
			{
				GET_TEAM(getTeam()).changeWarWeariness(pNewCity->getTeam(), *pNewPlot, GC.getDefineINT("WW_CAPTURED_CITY"));

				// Double war success if capturing capital city, always a significant blow to enemy
				// pNewCity still points to old city here, hasn't been acquired yet
				GET_TEAM(getTeam()).AI_changeWarSuccess(pNewCity->getTeam(), (pNewCity->isCapital() ? 2 : 1)*GC.getWAR_SUCCESS_CITY_CAPTURING());


				const PlayerTypes eNewOwner =
				(
					isHiddenNationality()
					?
					BARBARIAN_PLAYER
					:
					myPlayer.pickConqueredCityOwner(*pNewCity)
				);
				if (NO_PLAYER != eNewOwner)
				{
					GET_PLAYER(eNewOwner).acquireCity(pNewCity, true, false, true); // will delete the pointer
					pNewCity = NULL;
				}
			}
			else
			{
				pNewCity->noteUnitMoved(this);
			}
		}

		// Koshling - modified a little to merge Super Forts logic
		const ImprovementTypes eImprovement = pNewPlot->getImprovementType();

		if (eImprovement != NO_IMPROVEMENT && GC.getImprovementInfo(eImprovement).isActsAsCity() && !isNoCapture()
		&& !isBlendIntoCity() && !isHiddenNationality() && myPlayer.isInvasionCapablePlayer() && !isCargo())
		{
			PROFILE("CvUnit::setXY.NewPlot2.ActAsCity");

			if (pNewPlot->getOwner() != NO_PLAYER)
			{
				const CvPlayer& pNewPlotOwner = GET_PLAYER(pNewPlot->getOwner());

				if ((isEnemy(pNewPlotOwner.getTeam()) || !pNewPlotOwner.isAlive())
				&& !canCoexistWithTeamOnPlot(pNewPlotOwner.getTeam(), *pNewPlot) && canFight())
				{
					AddDLLMessage(
						pNewPlot->getOwner(), false, GC.getEVENT_MESSAGE_TIME(),
						gDLL->getText("TXT_KEY_MISC_CITY_CAPTURED_BY", GC.getImprovementInfo(eImprovement).getText(), myPlayer.getCivilizationDescriptionKey()),
						"AS2D_CITYCAPTURED", MESSAGE_TYPE_MAJOR_EVENT, GC.getImprovementInfo(eImprovement).getButton(), GC.getCOLOR_RED(), pNewPlot->getX(), pNewPlot->getY(), true, true
					);
					myPlayer.acquireFort(pNewPlot);
				}
			}
			else myPlayer.acquireFort(pNewPlot);
		}

		//update facing direction
		if (pOldPlot != NULL)
		{
			const DirectionTypes newDirection = estimateDirection(pOldPlot, pNewPlot);
			if (newDirection != NO_DIRECTION)
				m_eFacingDirection = newDirection;
		}

		//update cargo mission animations
		if (isCargo())
		{
			PROFILE("CvUnit::setXY.NewPlot2.Cargo");

			if (eOldActivityType != ACTIVITY_MISSION)
			{
				getGroup()->setActivityType(eOldActivityType);
			}
		}

		pNewPlot->changeAdjacentSight(getTeam(), visibilityRange(pNewPlot), true, this, true); // needs to be here so that the square is considered visible when we move into it...
		changeDebugCount(1);
		pNewPlot->addUnit(this, bUpdate && !hasCargo());

		if (!bInit && shouldLoadOnMove(pNewPlot))
		{
			PROFILE("CvUnit::setXY.NewPlot2.Load");

			load();
		}
		{
			PROFILE("CvUnit::setXY.NewPlot2.Meet");

			for (int iI = 0; iI < MAX_PC_TEAMS; iI++)
			{
				if (GET_TEAM((TeamTypes)iI).isAlive() && !isInvisible((TeamTypes)iI, false) && pNewPlot->isVisible((TeamTypes)iI, false))
				{
					GET_TEAM((TeamTypes)iI).meet(getTeam(), true);
				}
			}
		}

		{
			CvCity* pNewCity = pNewPlot->getPlotCity();

			if (pNewCity != NULL && isMilitaryHappiness())
			{
				pNewCity->changeMilitaryHappinessUnits(1);
			}
		}
		{
			CvCity* pWorkingCity = pNewPlot->getWorkingCity();

			if (pWorkingCity != NULL)
			{
				PROFILE("CvUnit::setXY.NewPlot2.WorkingCity");

				if (canSiege(pWorkingCity->getTeam()))
				{
					pWorkingCity->verifyWorkingPlot(pWorkingCity->getCityPlotIndex(pNewPlot));
				}
			}

			if (pNewPlot->isWater())
			{
				PROFILE("CvUnit::setXY.NewPlot2.Water");

				foreach_(const CvPlot* pLoopPlot, pNewPlot->adjacent() | filtered(CvPlot::fn::isWater()))
				{
					pWorkingCity = pLoopPlot->getWorkingCity();

					if (pWorkingCity != NULL && canSiege(pWorkingCity->getTeam()))
					{
						pWorkingCity->verifyWorkingPlot(pWorkingCity->getCityPlotIndex(pLoopPlot));
					}
				}
			}
		}

		if (pNewPlot->isActiveVisible(true))
		{
			pNewPlot->updateMinimapColor();
		}

		if (GC.IsGraphicsInitialized() && isInViewport())
		{
			PROFILE("CvUnit::setXY.NewPlot2.Visibility");

			// Override bShow if check plot visible
			if (bShow || bCheckPlotVisible && pNewPlot->isVisibleToWatchingHuman())
			{
				QueueMove(pNewPlot);
			}
			else SetPosition(pNewPlot);
		}

		if (pNewPlot == gDLL->getInterfaceIFace()->getSelectionPlot())
		{
			gDLL->getInterfaceIFace()->verifyPlotListColumn();
			gDLL->getInterfaceIFace()->setDirty(PlotListButtons_DIRTY_BIT, true);
		}

		if (isPillageOnMove() && pNewPlot->isOwned()
		&& GET_PLAYER(pNewPlot->getOwner()).getTeam() != myPlayer.getTeam()
		&& pNewPlot->getImprovementType() != NO_IMPROVEMENT
		&& !GC.getImprovementInfo((ImprovementTypes)pNewPlot->getImprovementType()).isPermanent())
		{
			if (atWar(getTeam(), GET_PLAYER(pNewPlot->getOwner()).getTeam()))
			{
				int iPillageGold = Cy::call<int>(PYGameModule, "doPillageGold", Cy::Args() << pNewPlot << this);

				if (iPillageGold > 0)
				{
					iPillageGold = iPillageGold * getPillageChange() / 100;
					myPlayer.changeGold(iPillageGold);

					AddDLLMessage(
						eMyPlayer, true, GC.getEVENT_MESSAGE_TIME(),
						gDLL->getText("TXT_KEY_MISC_PLUNDERED_GOLD_FROM_IMP", iPillageGold, GC.getImprovementInfo(pNewPlot->getImprovementType()).getTextKeyWide()),
						"AS2D_PILLAGE", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_GREEN(), pNewPlot->getX(), pNewPlot->getY()
					);
					for (int iI = 0; iI < NUM_COMMERCE_TYPES; ++iI)
					{
						switch (static_cast<CommerceTypes>(iI))
						{
							case COMMERCE_GOLD:
							{
								if (isPillageMarauder())
								{
									myPlayer.changeGold(iPillageGold);
									pNewPlot->setImprovementType(GC.getImprovementInfo(pNewPlot->getImprovementType()).getImprovementPillage());

									AddDLLMessage(
										eMyPlayer, true, GC.getEVENT_MESSAGE_TIME(),
										gDLL->getText("TXT_KEY_MISC_MARAUDERS_PLUNDERED_IMP", iPillageGold, GC.getImprovementInfo(pNewPlot->getImprovementType()).getTextKeyWide()),
										"AS2D_PILLAGE", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_GREEN(), pNewPlot->getX(), pNewPlot->getY()
									);
									AddDLLMessage(
										pNewPlot->getOwner(), false, GC.getEVENT_MESSAGE_TIME(),
										gDLL->getText("TXT_KEY_MISC_IMP_DESTROYED_BY_MARAUDERS", getVisualCivAdjective(getTeam())),
										"AS2D_PILLAGED", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_RED(), pNewPlot->getX(), pNewPlot->getY(), true, true
									);
								}
								break;
							}
							case COMMERCE_RESEARCH:
							{
								if (isPillageResearch())
								{
									const int iPillageResearch = iPillageGold;
									GET_TEAM(myPlayer.getTeam()).changeResearchProgress(myPlayer.getCurrentResearch(), iPillageResearch, eMyPlayer);

									AddDLLMessage(
										eMyPlayer, true, GC.getEVENT_MESSAGE_TIME(),
										gDLL->getText(
											"TXT_KEY_MISC_PLUNDERED_RESEARCH_FROM_IMP",
											iPillageResearch, GC.getImprovementInfo(pNewPlot->getImprovementType()).getTextKeyWide()
										),
										"AS2D_PILLAGE", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_GREEN(), pNewPlot->getX(), pNewPlot->getY()
									);
								}
								break;
							}
							case COMMERCE_CULTURE: break;
							case COMMERCE_ESPIONAGE:
							{
								if (isPillageEspionage() && pNewPlot->getTeam() != NO_TEAM)
								{
									const int iPillageEspionage = iPillageGold;
									GET_TEAM(myPlayer.getTeam()).changeEspionagePointsAgainstTeam(pNewPlot->getTeam(), iPillageEspionage);

									AddDLLMessage(
										eMyPlayer, true, GC.getEVENT_MESSAGE_TIME(),
										gDLL->getText(
											"TXT_KEY_MISC_PLUNDERED_ESPIONAGE_FROM_IMP",
											iPillageEspionage, GC.getImprovementInfo(pNewPlot->getImprovementType()).getTextKeyWide()
										),
										"AS2D_PILLAGE", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_GREEN(), pNewPlot->getX(), pNewPlot->getY()
									);
								}
								break;
							}
						}
					}
					if (pNewPlot->isOwned())
					{
						AddDLLMessage(
							pNewPlot->getOwner(), false, GC.getEVENT_MESSAGE_TIME(),
							gDLL->getText(
								"TXT_KEY_MISC_IMP_DESTROYED",
								GC.getImprovementInfo(pNewPlot->getImprovementType()).getTextKeyWide(),
								getNameKey(), getVisualCivAdjective(pNewPlot->getTeam())
							),
							"AS2D_PILLAGED", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_RED(), pNewPlot->getX(), pNewPlot->getY(), true, true
						);
					}
				}
			}
			if (pNewPlot->getImprovementType() != NO_IMPROVEMENT)
			{
				pNewPlot->setImprovementType(GC.getImprovementInfo(pNewPlot->getImprovementType()).getImprovementPillage());
			}
		}
	}

	if (pOldPlot != NULL && hasCargo())
	{
		PROFILE("CvUnit::setXY.OldPlot2");

		std::vector<CvUnit*> cargoUnits;

		foreach_(CvUnit* pLoopUnit, pOldPlot->units())
		{
			if (pLoopUnit->getTransportUnit() == this)
			{
				//GC.getGame().logOOSSpecial(22, pLoopUnit->getID(), iX, iY);
				cargoUnits.push_back(pLoopUnit);
			}
		}
		foreach_(CvUnit* pLoopUnit, cargoUnits)
		{
			pLoopUnit->setXY(iX, iY, bGroup, false);
		}
#ifdef _DEBUG
		foreach_(const CvUnit* pLoopUnit, pOldPlot->units())
		{
			if (pLoopUnit->getTransportUnit() == this)
			{
				pLoopUnit->getGroup()->validateLocations();
			}
		}
#endif
	}

	if (bUpdate)// && hasCargo())
	{
		PROFILE("CvUnit::setXY.updateCenter");

		if (pOldPlot != NULL)
		{
			pOldPlot->updateCenterUnit();
			pOldPlot->setFlagDirty(true);
		}

		if (pNewPlot != NULL)
		{
			pNewPlot->updateCenterUnit();
			pNewPlot->setFlagDirty(true);
		}
	}

	const bool bFarMove =
	(
		pOldPlot == NULL || pNewPlot == NULL
		||
		3 < stepDistance(pOldPlot->getX(), pOldPlot->getY(), pNewPlot->getX(), pNewPlot->getY())
	);

	FAssert(pOldPlot != pNewPlot);
	myPlayer.updateGroupCycle(this, bFarMove);

	if (pNewPlot != NULL)
	{
		setHasAnyInvisibility();

		if ((pOldPlot != NULL && pOldPlot->isInViewport()) != pNewPlot->isInViewport()
		|| g_bUseDummyEntities
		&& (pOldPlot != NULL && pOldPlot->isActiveVisible(false)) != pNewPlot->isActiveVisible(false))
		{
			reloadEntity();
		}
	}

	setInfoBarDirty(true);

	if (IsSelected())
	{
		if (isFound())
		{
			gDLL->getInterfaceIFace()->setDirty(GlobeLayer_DIRTY_BIT, true);

			if (!isUsingDummyEntities() && isInViewport())
			{
				gDLL->getEngineIFace()->updateFoundingBorder();
			}
		}
		gDLL->getInterfaceIFace()->setDirty(ColoredPlots_DIRTY_BIT, true);
	}

	//update glow
	if (pNewPlot != NULL && !isUsingDummyEntities() && isInViewport())
	{
		gDLL->getEntityIFace()->updateEnemyGlow(getUnitEntity());
	}

	/*GC.getGame().logOOSSpecial(5, getID(), iX, iY);*/
}


bool CvUnit::at(int iX, int iY) const
{
	return getX() == iX && getY() == iY;
}


bool CvUnit::atPlot(const CvPlot* pPlot) const
{
	return plot() == pPlot;
}


CvPlot* CvUnit::plot() const
{
	//FAssertMsg(isInViewport(), "Can't get plot of unit that is not in the viewport");
	//FAssertMsg(!isUsingDummyEntities(), "Can't get plot of unit that is using dummy entities");
	return GC.getMap().plotSorenINLINE(getX(), getY());
}

CvPlot* CvUnit::plotExternal() const
{
	FAssertMsg(isInViewport(), "Can't get plot of unit that is not in the viewport");
	FAssertMsg(!isUsingDummyEntities(), "Can't get plot of unit that is using dummy entities");
	return GC.getMap().plotSorenINLINE(getX(), getY());
}


int CvUnit::getArea() const
{
	return plot()->getArea();
}


CvArea* CvUnit::area() const
{
	return plot()->area();
}


bool CvUnit::onMap() const
{
	return plot() != NULL;
}


int CvUnit::getLastMoveTurn() const
{
	return m_iLastMoveTurn;
}


void CvUnit::setLastMoveTurn(int iNewValue)
{
	m_iLastMoveTurn = iNewValue;
	FASSERT_NOT_NEGATIVE(m_iLastMoveTurn);
}


CvPlot* CvUnit::getReconPlot() const
{
	return GC.getMap().plotSorenINLINE(m_iReconX, m_iReconY);
}


void CvUnit::setReconPlot(CvPlot* pNewValue)
{
	CvPlot* pOldPlot = getReconPlot();

	if (pOldPlot != pNewValue)
	{
		if (pOldPlot != NULL)
		{
			pOldPlot->changeAdjacentSight(getTeam(), GC.getRECON_VISIBILITY_RANGE(), false, this, true);
			pOldPlot->changeReconCount(-1); // changeAdjacentSight() tests for getReconCount()
			changeDebugCount(-1);
		}

		if (pNewValue == NULL)
		{
			m_iReconX = INVALID_PLOT_COORD;
			m_iReconY = INVALID_PLOT_COORD;
		}
		else
		{
			m_iReconX = pNewValue->getX();
			m_iReconY = pNewValue->getY();

			pNewValue->changeReconCount(1); // changeAdjacentSight() tests for getReconCount()
			pNewValue->changeAdjacentSight(getTeam(), GC.getRECON_VISIBILITY_RANGE(), true, this, true);
			changeDebugCount(1);
		}
	}
}


int CvUnit::getGameTurnCreated() const
{
	return m_iGameTurnCreated;
}


void CvUnit::setGameTurnCreated(int iNewValue)
{
	m_iGameTurnCreated = iNewValue;
	FASSERT_NOT_NEGATIVE(getGameTurnCreated());
}


int CvUnit::getDamage() const
{
	return m_iDamage;
}

int CvUnit::getHealAsDamage(UnitCombatTypes eHealAsType) const
{
	FASSERT_BOUNDS(0, GC.getNumUnitCombatInfos(), eHealAsType);

	const UnitCombatKeyedInfo* info = findUnitCombatKeyedInfo(eHealAsType);

	return info == NULL ? 0 : info->m_iHealAsDamage;
}

void CvUnit::changeHealAsDamage(UnitCombatTypes eHealAsType, int iChange, PlayerTypes ePlayer)
{
	FASSERT_BOUNDS(0, GC.getNumUnitCombatInfos(), eHealAsType);

	if (iChange != 0)
	{
		const UnitCombatKeyedInfo* info = findOrCreateUnitCombatKeyedInfo(eHealAsType);

		const int iNewValue = (info->m_iHealAsDamage + iChange);

		setHealAsDamage(eHealAsType, range(iNewValue, 0, getMaxHP()), ePlayer);

		FASSERT_NOT_NEGATIVE(info->m_iHealAsDamage);
	}
}

void CvUnit::setHealAsDamage(UnitCombatTypes eHealAsType, int iNewValue, PlayerTypes ePlayer, bool bNotifyEntity)
{
	FASSERT_BOUNDS(0, GC.getNumUnitCombatInfos(), eHealAsType);

	UnitCombatKeyedInfo* info = findOrCreateUnitCombatKeyedInfo(eHealAsType);

	info->m_iHealAsDamage = range(iNewValue, 0, getMaxHP());

	int iHighestDamage = 0;
	for (int iI = 0; iI < m_pUnitInfo->getNumHealAsTypes(); iI++)
	{
		const UnitCombatKeyedInfo* info2 = findOrCreateUnitCombatKeyedInfo((UnitCombatTypes)m_pUnitInfo->getHealAsType(iI));
		if (info2->m_iHealAsDamage > iHighestDamage)
		{
			iHighestDamage = info2->m_iHealAsDamage;
		}
	}
	if (iHighestDamage != getDamage())
	{
		setDamage(iHighestDamage, ePlayer, bNotifyEntity, NO_UNITCOMBAT, true);
	}
	FASSERT_NOT_NEGATIVE(info->m_iHealAsDamage);
}

int CvUnit::getDamagePercent() const
{
	return 100 * m_iDamage / getMaxHP();
}

void CvUnit::setupPreCombatDamage()
{
	m_iPreCombatDamage = m_iDamage;
}

int CvUnit::getPreCombatDamage() const
{
	return m_iPreCombatDamage;
}

void CvUnit::setDamage(int iNewValue, PlayerTypes ePlayer, bool bNotifyEntity, UnitCombatTypes eHealAsType, bool bSecondPass)
{
	const int iOldValue = getDamage();

	if (eHealAsType == NO_UNITCOMBAT && !bSecondPass && m_pUnitInfo->getNumHealAsTypes() > 0)
	{
		for (int iI = 0; iI < m_pUnitInfo->getNumHealAsTypes(); iI++)
		{
			setHealAsDamage((UnitCombatTypes)m_pUnitInfo->getHealAsType(iI), iNewValue, ePlayer, bNotifyEntity);
		}
	}
	else if (eHealAsType != NO_UNITCOMBAT && m_pUnitInfo->getNumHealAsTypes() > 0)
	{
		setHealAsDamage(eHealAsType, iNewValue, ePlayer, bNotifyEntity);
	}
	else
	{
		m_iDamage = range(iNewValue, 0, getMaxHP());

		if (iOldValue != getDamage())
		{
			if (GC.getGame().isFinalInitialized() && bNotifyEntity)
			{
				NotifyEntity(MISSION_DAMAGE);
			}

			setInfoBarDirty(true);

			if (IsSelected())
			{
				gDLL->getInterfaceIFace()->setDirty(InfoPane_DIRTY_BIT, true);
			}

			if (plot() == gDLL->getInterfaceIFace()->getSelectionPlot())
			{
				gDLL->getInterfaceIFace()->setDirty(PlotListButtons_DIRTY_BIT, true);
			}
		}
	}
	FAssertMsg(getHP() >= 0, "getHP() is expected to be non-negative (invalid Index)");

	if (isDead())
	{
		kill(true, ePlayer);
	}
}


void CvUnit::changeDamage(int iChange, PlayerTypes ePlayer, UnitCombatTypes eHealAsType)
{
	if (eHealAsType == NO_UNITCOMBAT && m_pUnitInfo->getNumHealAsTypes() > 0)
	{
		for (int iI = 0; iI < m_pUnitInfo->getNumHealAsTypes(); iI++)
		{
			changeHealAsDamage((UnitCombatTypes)m_pUnitInfo->getHealAsType(iI), iChange, ePlayer);
		}
	}
	else if (m_pUnitInfo->getNumHealAsTypes() > 0)
	{
		changeHealAsDamage(eHealAsType, iChange, ePlayer);
	}
	else setDamage(getDamage() + iChange, ePlayer);
}

void CvUnit::changeDamagePercent(int iChange, PlayerTypes ePlayer)
{
	setDamage((getDamagePercent() + iChange) * getMaxHP() / 100, ePlayer);
}


int CvUnit::getMoves() const
{
	return m_iMoves;
}


void CvUnit::setMoves(int iNewValue)
{
	if (m_iMoves != iNewValue)
	{
		CvPlot* pPlot = plot();

		m_iMoves = iNewValue;

		FASSERT_NOT_NEGATIVE(m_iMoves);

		if (pPlot != NULL && getTeam() == GC.getGame().getActiveTeam())
		{
			pPlot->setFlagDirty(true);
		}

		if (IsSelected())
		{
			gDLL->getFAStarIFace()->ForceReset(&GC.getInterfacePathFinder());

			gDLL->getInterfaceIFace()->setDirty(InfoPane_DIRTY_BIT, true);
		}

		if (pPlot == gDLL->getInterfaceIFace()->getSelectionPlot())
		{
			gDLL->getInterfaceIFace()->setDirty(PlotListButtons_DIRTY_BIT, true);
		}
	}
}


void CvUnit::changeMoves(int iChange)
{
	setMoves(m_iMoves + iChange);
}


void CvUnit::finishMoves()
{
	setMoves(maxMoves());
}


int CvUnit::getExperience100() const
{
	return m_iExperience;
}

void CvUnit::setExperience100(int iNewValue, int iMax)
{
	if (iMax < 0) iMax = MAX_INT;

	iNewValue = range(iNewValue, 0, iMax);

	if (m_iExperience != iNewValue && (m_iExperience < iMax || iNewValue < m_iExperience))
	{
		m_iExperience = iNewValue;

		if (IsSelected())
		{
			gDLL->getInterfaceIFace()->setDirty(InfoPane_DIRTY_BIT, true);
		}
	}
}

void CvUnit::changeExperience100(int iChange, int iMax, bool bFromCombat, bool bInBorders, bool bUpdateGlobal)
{
	int iExp = iChange;

	if (bFromCombat)
	{
		CvPlayer& kPlayer = GET_PLAYER(getOwner());

		int iMod = getExperiencePercent();
		int iModGG = kPlayer.getGreatGeneralRateModifier();

		if (bInBorders)
		{
			iMod += kPlayer.getExpInBorderModifier();
			iModGG += kPlayer.getDomesticGreatGeneralRateModifier() + kPlayer.getExpInBorderModifier();
		}
		iExp = getModifiedIntValue(iExp, iMod);

		if (bUpdateGlobal)
		{
			kPlayer.changeFractionalCombatExperience(getModifiedIntValue(iExp, iModGG), getGGExperienceEarnedTowardsType());
		}

		CvUnit* pCommander = getUsedCommander();
		if (pCommander != NULL)
		{
			pCommander->setExperience100(pCommander->getExperience100() + 60); //0.6 xp every time, make global define?
		}
	}
	setExperience100(getExperience100() + iExp, iMax);
}

int CvUnit::getExperience() const
{
	return getExperience100() / 100;
}

void CvUnit::setExperience(int iNewValue, int iMax)
{
	setExperience100(iNewValue * 100, iMax > -1 && iMax < MAX_INT/100 ? iMax * 100 : -1);
}

void CvUnit::changeExperience(int iChange, int iMax, bool bFromCombat, bool bInBorders, bool bUpdateGlobal)
{
	changeExperience100(iChange * 100, iMax > -1 && MAX_INT/100 > iMax ? iMax * 100 : -1, bFromCombat, bInBorders, bUpdateGlobal);
}


int CvUnit::getLevel() const
{
	return m_iLevel;
}

void CvUnit::setLevel(int iNewValue)
{
	if (getLevel() != iNewValue)
	{
		m_iLevel = iNewValue;
		FAssert(getLevel() > 0);

		if (getLevel() > GET_PLAYER(getOwner()).getHighestUnitLevel())
		{
			GET_PLAYER(getOwner()).setHighestUnitLevel(getLevel());
		}

		if (IsSelected())
		{
			gDLL->getInterfaceIFace()->setDirty(InfoPane_DIRTY_BIT, true);
		}
	}
}

void CvUnit::changeLevel(int iChange)
{
	setLevel(getLevel() + iChange);
}

int CvUnit::getCargo() const
{
	return m_iCargo;
}

int CvUnit::SMgetCargo() const
{
	return m_iSMCargo;
}

void CvUnit::changeCargo(int iChange)
{
	m_iCargo += iChange;
	FAssertRecalcMsg(getCargo() >= 0, "Transported units is less than 0");
}

void CvUnit::SMchangeCargo(int iChange)
{
	m_iSMCargo += iChange;
	FAssertOptionRecalcMsg(GAMEOPTION_SIZE_MATTERS, SMgetCargo() >= 0, "Transported cargo is less than 0");
}

void CvUnit::getCargoUnits(std::vector<CvUnit*>& aUnits) const
{
	aUnits.clear();

#if FASSERT_ENABLE
	int iCheck = 0;
#endif
	if (hasCargo())
	{
		foreach_(CvUnit* pLoopUnit, plot()->units())
		{
			if (pLoopUnit->getTransportUnit() == this)
			{
				aUnits.push_back(pLoopUnit);
#if FASSERT_ENABLE
				if (GC.getGame().isOption(GAMEOPTION_SIZE_MATTERS))
				{
					iCheck += pLoopUnit->SMCargoVolume();
				}
				else
				{
					iCheck++;
				}
#endif
			}
		}
	}

	FAssertOptionRecalcMsg(GAMEOPTION_SIZE_MATTERS, SMgetCargo() == iCheck, "Cargo size doesn't match expectations");
	FAssertRecalcMsg(getCargo() == aUnits.size(), "Number of cargo units found doesn't match cached number");
}

void CvUnit::validateCargoUnits()
{
#if FASSERT_ENABLE
	int iCheck = 0;
	int iCount = 0;
	const CvPlot* pPlot = plot();

	if (hasCargo())
	{
		foreach_(const CvUnit* pLoopUnit, pPlot->units())
		{
			if (pLoopUnit->getTransportUnit() == this)
			{
				if (GC.getGame().isOption(GAMEOPTION_SIZE_MATTERS))
				{
					iCheck += pLoopUnit->SMCargoVolume();
					iCount++;
				}
				else
				{
					iCheck++;
					iCount++;
				}
			}
		}
	}

	if (GC.getGame().isOption(GAMEOPTION_SIZE_MATTERS))
	{
		//TB: Backend cleanup - Assert is coming up and we have ghost loads so this is a quickfix only - still evaluating to see how this takes place
		if (SMgetCargo() != iCheck)
		{
			FErrorMsg("Load Volume is incorrect");
			m_iSMCargo = 0;
			foreach_(const CvUnit* pLoopUnit, pPlot->units())
			{
				if (pLoopUnit->getTransportUnit() == this)
				{
					SMchangeCargo(pLoopUnit->SMCargoVolume());
				}
			}
			//rerun check
			iCheck = 0;
			iCount = 0;
			foreach_(const CvUnit* pLoopUnit, pPlot->units())
			{
				if (pLoopUnit->getTransportUnit() == this)
				{
					if (GC.getGame().isOption(GAMEOPTION_SIZE_MATTERS))
					{
						iCheck += pLoopUnit->SMCargoVolume();
						iCount++;
					}
					else
					{
						iCheck++;
						iCount++;
					}
				}
			}
			if (SMgetCargo() != iCheck)
			{
				FErrorMsg("Load Volume is incorrect");//If this persists, then the problem is due to having a unit that's not sharing the same plot being loaded onto the transport.
				std::vector<CvUnit*> aCargoUnits;
				getCargoUnits(aCargoUnits);
				foreach_(CvUnit* pCargo, aCargoUnits)
				{
					pCargo->setTransportUnit(NULL);
					if (pCargo->plot() == plot())
					{
						pCargo->setTransportUnit(this);
					}
				}
				m_iSMCargo = 0;
				iCount = 0;
				foreach_(const CvUnit* pCargo, aCargoUnits)
				{
					SMchangeCargo(pCargo->SMCargoVolume());
					iCount++;
				}
			}
		}
	}
	else
	{
		FAssert(iCheck == iCount);
	}
	FAssert(getCargo() == iCount);
#endif
}

CvPlot* CvUnit::getAttackPlot() const
{
	return GC.getMap().plotSorenINLINE(m_iAttackPlotX, m_iAttackPlotY);
}


void CvUnit::setAttackPlot(const CvPlot* pNewValue, bool bAirCombat)
{
	if (getAttackPlot() != pNewValue)
	{
		if (pNewValue != NULL)
		{
			m_iAttackPlotX = pNewValue->getX();
			m_iAttackPlotY = pNewValue->getY();
		}
		else
		{
			m_iAttackPlotX = INVALID_PLOT_COORD;
			m_iAttackPlotY = INVALID_PLOT_COORD;
		}
	}

	m_bAirCombat = bAirCombat;
}

bool CvUnit::isAirCombat() const
{
	return m_bAirCombat;
}

int CvUnit::getCombatTimer() const
{
	return m_iCombatTimer;
}

void CvUnit::setCombatTimer(int iNewValue)
{
	m_iCombatTimer = iNewValue;
	FASSERT_NOT_NEGATIVE(getCombatTimer());
}

void CvUnit::changeCombatTimer(int iChange)
{
	setCombatTimer(getCombatTimer() + iChange);
}

int CvUnit::getCombatFirstStrikes() const
{
	return m_iCombatFirstStrikes;
}

void CvUnit::setCombatFirstStrikes(int iNewValue)
{
	m_iCombatFirstStrikes = iNewValue;
	FASSERT_NOT_NEGATIVE(getCombatFirstStrikes());
}

void CvUnit::changeCombatFirstStrikes(int iChange)
{
	setCombatFirstStrikes(getCombatFirstStrikes() + iChange);
}

int CvUnit::getFortifyTurns() const
{
	return m_iFortifyTurns;
}

void CvUnit::setFortifyTurns(int iNewValue)
{
	const int iMaxFortify = GC.getDefineINT("MAX_FORTIFY_TURNS");

	iNewValue = range(iNewValue, 0, iMaxFortify);

	if (iNewValue != m_iFortifyTurns)
	{
		m_iFortifyTurns = iNewValue;
		setInfoBarDirty(true);

		if (iNewValue == 0 && isBuildUp())
		{
			clearBuildups();
		}
	}
}

int CvUnit::getBlitzCount() const
{
	return m_iBlitzCount;
}

bool CvUnit::isBlitz() const
{
	return m_iBlitzCount > 0;
}

void CvUnit::changeBlitzCount(int iChange)
{
	m_iBlitzCount += iChange;
	FASSERT_NOT_NEGATIVE(m_iBlitzCount);
}

int CvUnit::getAmphibCount() const
{
	return m_iAmphibCount;
}

bool CvUnit::isAmphib() const
{
	return (getAmphibCount() > 0 || canFliesToMove());
}

void CvUnit::changeAmphibCount(int iChange)
{
	m_iAmphibCount += iChange;
	FASSERT_NOT_NEGATIVE(getAmphibCount());
}

int CvUnit::getRiverCount() const
{
	return m_iRiverCount;
}

bool CvUnit::isRiver() const
{
	return (getRiverCount() > 0 || canFliesToMove());
}

void CvUnit::changeRiverCount(int iChange)
{
	m_iRiverCount += iChange;
	FASSERT_NOT_NEGATIVE(getRiverCount());
}

int CvUnit::getEnemyRouteCount() const
{
	return m_iEnemyRouteCount;
}

bool CvUnit::isEnemyRoute() const
{
	return (getEnemyRouteCount() > 0);
}

void CvUnit::changeEnemyRouteCount(int iChange)
{
	m_iEnemyRouteCount += iChange;
	FASSERT_NOT_NEGATIVE(getEnemyRouteCount());
}

int CvUnit::getAlwaysHealCount() const
{
	return m_iAlwaysHealCount;
}

bool CvUnit::isAlwaysHeal() const
{
	return (getAlwaysHealCount() > 0);
}

void CvUnit::changeAlwaysHealCount(int iChange)
{
	m_iAlwaysHealCount += iChange;
	FASSERT_NOT_NEGATIVE(getAlwaysHealCount());
}

int CvUnit::getHillsDoubleMoveCount() const
{
	return m_iHillsDoubleMoveCount;
}

bool CvUnit::isHillsDoubleMove() const
{
	return (getHillsDoubleMoveCount() > 0);
}

void CvUnit::changeHillsDoubleMoveCount(int iChange)
{
	m_iHillsDoubleMoveCount += iChange;
	FASSERT_NOT_NEGATIVE(getHillsDoubleMoveCount());
}

int CvUnit::getImmuneToFirstStrikesCount() const
{
	return m_iImmuneToFirstStrikesCount;
}

void CvUnit::changeImmuneToFirstStrikesCount(int iChange)
{
	m_iImmuneToFirstStrikesCount += iChange;
	FASSERT_NOT_NEGATIVE(getImmuneToFirstStrikesCount());
}


int CvUnit::getAlwaysInvisibleCount() const
{
	return m_iAlwaysInvisibleCount;
}

void CvUnit::changeAlwaysInvisibleCount(int iChange)
{
	m_iAlwaysInvisibleCount += iChange;
	FASSERT_NOT_NEGATIVE(getAlwaysInvisibleCount());
}


int CvUnit::getDefensiveVictoryMoveCount() const
{
	return m_iDefensiveVictoryMoveCount;
}

bool CvUnit::isDefensiveVictoryMove() const
{
	return (getDefensiveVictoryMoveCount() > 0);
}

void CvUnit::changeDefensiveVictoryMoveCount(int iChange)
{
	m_iDefensiveVictoryMoveCount += iChange;
	FASSERT_NOT_NEGATIVE(getDefensiveVictoryMoveCount());
}


int CvUnit::getFreeDropCount() const
{
	return m_iFreeDropCount;
}

bool CvUnit::isFreeDrop() const
{
	return (getFreeDropCount() > 0);
}

void CvUnit::changeFreeDropCount(int iChange)
{
	m_iFreeDropCount += iChange;
	FASSERT_NOT_NEGATIVE(getFreeDropCount());
}


int CvUnit::getOffensiveVictoryMoveCount() const
{
	return m_iOffensiveVictoryMoveCount;
}

bool CvUnit::isOffensiveVictoryMove() const
{
	return (getOffensiveVictoryMoveCount() > 0);
}

void CvUnit::changeOffensiveVictoryMoveCount(int iChange)
{
	m_iOffensiveVictoryMoveCount += iChange;
	FASSERT_NOT_NEGATIVE(getOffensiveVictoryMoveCount());
}


int CvUnit::getOneUpCount() const
{
	return m_iOneUpCount;
}

bool CvUnit::isOneUp() const
{
	return getOneUpCount() > 0;
}

void CvUnit::changeOneUpCount(int iChange)
{
	m_iOneUpCount += iChange;
	FASSERT_NOT_NEGATIVE(getOneUpCount());
}

int CvUnit::getPillageEspionageCount() const
{
	return m_iPillageEspionageCount;
}

bool CvUnit::isPillageEspionage() const
{
	return getPillageEspionageCount() > 0;
}

void CvUnit::changePillageEspionageCount(int iChange)
{
	m_iPillageEspionageCount += iChange;
	FASSERT_NOT_NEGATIVE(getPillageEspionageCount());
}


int CvUnit::getPillageMarauderCount() const
{
	return m_iPillageMarauderCount;
}

bool CvUnit::isPillageMarauder() const
{
	return getPillageMarauderCount() > 0;
}

void CvUnit::changePillageMarauderCount(int iChange)
{
	m_iPillageMarauderCount += iChange;
	FASSERT_NOT_NEGATIVE(getPillageMarauderCount());
}


int CvUnit::getPillageOnMoveCount() const
{
	return m_iPillageOnMoveCount;
}

bool CvUnit::isPillageOnMove() const
{
	return getPillageOnMoveCount() > 0 && !isCargo();
}

void CvUnit::changePillageOnMoveCount(int iChange)
{
	m_iPillageOnMoveCount += iChange;
	FASSERT_NOT_NEGATIVE(getPillageOnMoveCount());
}


int CvUnit::getPillageOnVictoryCount() const
{
	return m_iPillageOnVictoryCount;
}

bool CvUnit::isPillageOnVictory() const
{
	return getPillageOnVictoryCount() > 0;
}

void CvUnit::changePillageOnVictoryCount(int iChange)
{
	m_iPillageOnVictoryCount += iChange;
	FASSERT_NOT_NEGATIVE(getPillageOnVictoryCount());
}


int CvUnit::getPillageResearchCount() const
{
	return m_iPillageResearchCount;
}

bool CvUnit::isPillageResearch() const
{
	return (getPillageResearchCount() > 0);
}

void CvUnit::changePillageResearchCount(int iChange)
{
	m_iPillageResearchCount += iChange;
	FASSERT_NOT_NEGATIVE(getPillageResearchCount());
}


int CvUnit::getAirCombatLimitChange() const
{
	return m_iAirCombatLimitChange;
}

void CvUnit::changeAirCombatLimitChange(int iChange)
{
	if (iChange != 0)
	{
		m_iAirCombatLimitChange += iChange;

		setInfoBarDirty(true);
	}
}

int CvUnit::getCelebrityHappy() const
{
	return m_iCelebrityHappy;
}

void CvUnit::changeCelebrityHappy(int iChange)
{
	if (iChange != 0)
	{
		m_iCelebrityHappy += iChange;

		setInfoBarDirty(true);
	}
}

int CvUnit::getCollateralDamageLimitChange() const
{
	return m_iCollateralDamageLimitChange;
}

void CvUnit::changeCollateralDamageLimitChange(int iChange)
{
	if (iChange != 0)
	{
		m_iCollateralDamageLimitChange += iChange;

		setInfoBarDirty(true);
	}
}

int CvUnit::getCollateralDamageMaxUnitsChange() const
{
	return m_iCollateralDamageMaxUnitsChange;
}

void CvUnit::changeCollateralDamageMaxUnitsChange(int iChange)
{
	if (iChange != 0)
	{
		m_iCollateralDamageMaxUnitsChange += iChange;

		setInfoBarDirty(true);
	}
}

int CvUnit::getCombatLimitChange() const
{
	return m_iCombatLimitChange;
}

void CvUnit::changeCombatLimitChange(int iChange)
{
	if (iChange != 0)
	{
		m_iCombatLimitChange += iChange;

		setInfoBarDirty(true);
	}
}

int CvUnit::getExtraDropRange() const
{
	return m_iExtraDropRange;
}

void CvUnit::changeExtraDropRange(int iChange)
{
	if (iChange != 0)
	{
		m_iExtraDropRange += iChange;

		setInfoBarDirty(true);
	}
}

int CvUnit::getSurvivorChance() const
{
	return m_iSurvivorChance;
}

void CvUnit::changeSurvivorChance(int iChange)
{
	if (iChange != 0)
	{
		m_iSurvivorChance += iChange;

		setInfoBarDirty(true);
	}
}

int CvUnit::getVictoryAdjacentHeal() const
{
	return m_iVictoryAdjacentHeal;
}

void CvUnit::changeVictoryAdjacentHeal(int iChange)
{
	if (iChange != 0)
	{
		m_iVictoryAdjacentHeal += iChange;

		setInfoBarDirty(true);
	}
}

int CvUnit::getVictoryHeal() const
{
	return m_iVictoryHeal;
}

void CvUnit::changeVictoryHeal(int iChange)
{
	if (iChange != 0)
	{
		m_iVictoryHeal += iChange;

		setInfoBarDirty(true);
	}
}

int CvUnit::getVictoryStackHeal() const
{
	return m_iVictoryStackHeal;
}

void CvUnit::changeVictoryStackHeal(int iChange)
{
	if (iChange != 0)
	{
		m_iVictoryStackHeal += iChange;

		setInfoBarDirty(true);
	}
}


int CvUnit::getExtraVisibilityRange() const
{
	if (!isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander != NULL)
		{
			return m_iExtraVisibilityRange + pCommander->m_iExtraVisibilityRange;
		}
	}
	return m_iExtraVisibilityRange;
}

void CvUnit::changeExtraVisibilityRange(int iChange)
{
	if (iChange != 0)
	{
		if (plot() != NULL)
		{
			plot()->changeAdjacentSight(getTeam(), visibilityRange(plot()), false, this, false);
			changeDebugCount(-1);
		}

		m_iExtraVisibilityRange += iChange;
		FASSERT_NOT_NEGATIVE(getExtraVisibilityRange());

		if (plot() != NULL)
		{
			plot()->changeAdjacentSight(getTeam(), visibilityRange(plot()), true, this, false);
			changeDebugCount(1);
		}
	}
}

int CvUnit::getExtraMoves() const
{
	if (!isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander != NULL)
		{
			return m_iExtraMoves + pCommander->m_iExtraMoves;
		}
	}
	return m_iExtraMoves;
}

void CvUnit::changeExtraMoves(int iChange)
{
	m_iExtraMoves += iChange;
	m_iMaxMoveCacheTurn--;

	FASSERT_NOT_NEGATIVE(getExtraMoves());
}

int CvUnit::getExtraMoveDiscount() const
{
	if (!isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander != NULL)
		{
			return m_iExtraMoveDiscount + pCommander->m_iExtraMoveDiscount;
		}
	}
	return m_iExtraMoveDiscount;
}

void CvUnit::changeExtraMoveDiscount(int iChange)
{
	m_iExtraMoveDiscount += iChange;
	FASSERT_NOT_NEGATIVE(getExtraMoveDiscount());
}


int CvUnit::getExtraAirRange() const
{
	if (!isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander != NULL)
		{
			return m_iExtraAirRange + pCommander->m_iExtraAirRange;
		}
	}
	return m_iExtraAirRange;
}

void CvUnit::changeExtraAirRange(int iChange)
{
	m_iExtraAirRange += iChange;
}

int CvUnit::getExtraIntercept(bool bIgnoreCommanders) const
{
	if (!bIgnoreCommanders && !isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander != NULL)
		{
			return m_iExtraIntercept + pCommander->m_iExtraIntercept;
		}
	}
	return m_iExtraIntercept;
}

void CvUnit::changeExtraIntercept(int iChange)
{
	m_iExtraIntercept += iChange;
}

int CvUnit::getExtraEvasion(bool bIgnoreCommanders) const
{
	if (!bIgnoreCommanders && !isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander != NULL)
		{
			return m_iExtraEvasion + pCommander->m_iExtraEvasion;
		}
	}
	return m_iExtraEvasion;
}

void CvUnit::changeExtraEvasion(int iChange)
{
	m_iExtraEvasion += iChange;
}

int CvUnit::getExtraFirstStrikes() const
{
	if (!isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander != NULL)
		{
			return std::max(0, m_iExtraFirstStrikes + pCommander->getExtraFirstStrikes());
		}
	}
	return std::max(0, m_iExtraFirstStrikes);
}

void CvUnit::changeExtraFirstStrikes(int iChange)
{
	m_iExtraFirstStrikes += iChange;
}

int CvUnit::getExtraChanceFirstStrikes() const
{
	if (!isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander != NULL)
		{
			return std::max(0, m_iExtraChanceFirstStrikes + pCommander->getExtraChanceFirstStrikes());
		}
	}
	return std::max(0, m_iExtraChanceFirstStrikes);
}

void CvUnit::changeExtraChanceFirstStrikes(int iChange)
{
	m_iExtraChanceFirstStrikes += iChange;
}

int CvUnit::getExtraWithdrawal(bool bIgnoreCommanders) const
{
	if (!bIgnoreCommanders && !isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander != NULL)
		{
			return m_iExtraWithdrawal + pCommander->m_iExtraWithdrawal;
		}
	}
	return m_iExtraWithdrawal;
}

void CvUnit::changeExtraWithdrawal(int iChange)
{
	m_iExtraWithdrawal += iChange;
}

//TB Combat Mods Begin
int CvUnit::getExtraAttackCombatModifier(bool bIgnoreCommanders) const
{
	if (!bIgnoreCommanders && !isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander != NULL)
		{
			return m_iExtraAttackCombatModifier + pCommander->m_iExtraAttackCombatModifier;
		}
	}
	return m_iExtraAttackCombatModifier;
}

void CvUnit::changeExtraAttackCombatModifier(int iChange)
{
	m_iExtraAttackCombatModifier +=iChange;
}

int CvUnit::getExtraDefenseCombatModifier(bool bIgnoreCommanders) const
{
	if (noDefensiveBonus())
	{
		return 0;
	}
	if (!bIgnoreCommanders && !isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander != NULL)
		{
			return m_iExtraDefenseCombatModifier + pCommander->m_iExtraDefenseCombatModifier;
		}
	}
	return m_iExtraDefenseCombatModifier;
}

void CvUnit::changeExtraDefenseCombatModifier(int iChange)
{
	m_iExtraDefenseCombatModifier +=iChange;
}

int CvUnit::getExtraPursuit(bool bIgnoreCommanders) const
{
	if (!bIgnoreCommanders && !isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander != NULL)
		{
			return m_iExtraPursuit + pCommander->m_iExtraPursuit;
		}
	}
	return m_iExtraPursuit;
}

void CvUnit::changeExtraPursuit(int iChange)
{
	m_iExtraPursuit +=iChange;
}

int CvUnit::getExtraEarlyWithdraw(bool bIgnoreCommanders) const
{
	if (!bIgnoreCommanders && !isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander != NULL)
		{
			return m_iExtraEarlyWithdraw + pCommander->m_iExtraEarlyWithdraw;
		}
	}
	return m_iExtraEarlyWithdraw;
}

void CvUnit::changeExtraEarlyWithdraw(int iChange)
{
	m_iExtraEarlyWithdraw +=iChange;
}

int CvUnit::getExtraVSBarbs(bool bIgnoreCommanders) const
{
	if (!bIgnoreCommanders && !isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander != NULL)
		{
			return m_iExtraVSBarbs + pCommander->m_iExtraVSBarbs;
		}
	}
	return m_iExtraVSBarbs;
}

void CvUnit::changeExtraVSBarbs(int iChange)
{
	m_iExtraVSBarbs += iChange;
	FASSERT_NOT_NEGATIVE(getExtraVSBarbs());
}

int CvUnit::getExtraReligiousCombatModifier(bool bIgnoreCommanders) const
{
	if (!bIgnoreCommanders && !isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander != NULL)
		{
			return m_iExtraReligiousCombatModifier + pCommander->m_iExtraReligiousCombatModifier;
		}
	}
	return m_iExtraReligiousCombatModifier;
}

void CvUnit::changeExtraReligiousCombatModifier(int iChange)
{
	m_iExtraReligiousCombatModifier += iChange;
}

int CvUnit::getExtraArmor(bool bIgnoreCommanders) const
{
	if (!bIgnoreCommanders && !isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander != NULL)
		{
			return std::max(0, m_iExtraArmor + pCommander->m_iExtraArmor);
		}
	}
	return std::max(0, m_iExtraArmor);
}

void CvUnit::changeExtraArmor(int iChange)
{
	m_iExtraArmor +=iChange;
}

int CvUnit::getExtraPuncture(bool bIgnoreCommanders) const
{
	if (!bIgnoreCommanders && !isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander != NULL)
		{
			return std::max(0, m_iExtraPuncture + pCommander->getExtraPuncture());
		}
	}
	return std::max(0, m_iExtraPuncture);
}

void CvUnit::changeExtraPuncture(int iChange)
{
	m_iExtraPuncture +=iChange;
}

int CvUnit::getExtraDamageModifier(bool bIgnoreCommanders) const
{
	if (!bIgnoreCommanders && !isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander != NULL)
		{
			return m_iExtraDamageModifier + pCommander->m_iExtraDamageModifier;
		}
	}
	return m_iExtraDamageModifier;
}

void CvUnit::changeExtraDamageModifier(int iChange)
{
	m_iExtraDamageModifier += iChange;
}

// Toffer - Upkeep
void CvUnit::changeExtraUpkeep100(const int iChange)
{
	if (iChange != 0)
	{
		m_iExtraUpkeep100 += iChange;
		calcUpkeep100();
	}
}

int CvUnit::getExtraUpkeep100() const
{
	return m_iExtraUpkeep100;
}

void CvUnit::changeUpkeepModifier(const int iChange)
{
	if (iChange != 0)
	{
		m_iUpkeepModifier += iChange;
		calcUpkeep100();
	}
}

int CvUnit::getUpkeepModifier() const
{
	return m_iUpkeepModifier;
}

int CvUnit::getUpkeepMultiplierSM() const
{
	return m_iUpkeepMultiplierSM;
}

void CvUnit::calcUpkeepMultiplierSM(const int iGroupOffset)
{
	m_iUpkeepMultiplierSM = 0;

	if (iGroupOffset > 0)
	{
		for (int iI = 0; iI < iGroupOffset; iI++)
		{
			m_iUpkeepMultiplierSM = (100 + m_iUpkeepMultiplierSM) * 150 / 100 - 100;
		}
	}
	else if (iGroupOffset < 0)
	{
		for (int iI = 0; iI < -iGroupOffset; iI++)
		{
			m_iUpkeepMultiplierSM = (100 + m_iUpkeepMultiplierSM) * 150 / 100 - 100;
		}
		m_iUpkeepMultiplierSM = -m_iUpkeepMultiplierSM;
	}
	calcUpkeep100();
}

void CvUnit::calcUpkeep100()
{
	if (isNPC())
	{
		return;
	}
	int iCalc = 100 * m_pUnitInfo->getBaseUpkeep();
	if (iCalc > 0)
	{
		iCalc += m_iExtraUpkeep100;

		if (iCalc > 0)
		{
			iCalc = getModifiedIntValue(iCalc, m_iUpkeepModifier);
			iCalc = getModifiedIntValue(iCalc, m_iUpkeepMultiplierSM);

			const int iOldUpkeep = m_iUpkeep100;
			m_iUpkeep100 = std::max(0,  iCalc);

			// Update player total
			if (m_iUpkeep100 != iOldUpkeep)
			{
				GET_PLAYER(getOwner()).changeUnitUpkeep(m_iUpkeep100 - iOldUpkeep, m_pUnitInfo->isMilitarySupport());
			}
		}
	}
}

int CvUnit::getUpkeep100() const
{
	return m_iUpkeep100;
}

void CvUnit::recalculateUnitUpkeep()
{
	m_iUpkeep100 = 0;
	calcUpkeep100();
}
// ! Upkeep


int CvUnit::getExtraOverrun(bool bIgnoreCommanders) const
{
	if (!bIgnoreCommanders && !isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander != NULL)
		{
			return m_iExtraOverrun + pCommander->m_iExtraOverrun;
		}
	}
	return m_iExtraOverrun;
}

void CvUnit::changeExtraOverrun(int iChange)
{
	m_iExtraOverrun += iChange;
	FASSERT_NOT_NEGATIVE(getExtraOverrun());
}

int CvUnit::getExtraRepel(bool bIgnoreCommanders) const
{
	if (noDefensiveBonus())
	{
		return 0;
	}
	if (!bIgnoreCommanders && !isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander != NULL)
		{
			return m_iExtraRepel + pCommander->m_iExtraRepel;
		}
	}
	return m_iExtraRepel;
}

void CvUnit::changeExtraRepel(int iChange)
{
	m_iExtraRepel += iChange;
	FASSERT_NOT_NEGATIVE(getExtraRepel());
}

int CvUnit::getExtraFortRepel(bool bIgnoreCommanders) const
{
	if (noDefensiveBonus())
	{
		return 0;
	}
	if (!bIgnoreCommanders && !isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander != NULL)
		{
			return m_iExtraFortRepel + pCommander->m_iExtraFortRepel;
		}
	}
	return m_iExtraFortRepel;
}

void CvUnit::changeExtraFortRepel(int iChange)
{
	m_iExtraFortRepel += iChange;
	FASSERT_NOT_NEGATIVE(getExtraFortRepel());
}

int CvUnit::getExtraRepelRetries(bool bIgnoreCommanders) const
{
	if (noDefensiveBonus())
	{
		return 0;
	}
	if (!bIgnoreCommanders && !isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander != NULL)
		{
			return m_iExtraRepelRetries + pCommander->m_iExtraRepelRetries;
		}
	}
	return m_iExtraRepelRetries;
}

void CvUnit::changeExtraRepelRetries(int iChange)
{
	m_iExtraRepelRetries += iChange;
	FASSERT_NOT_NEGATIVE(getExtraRepelRetries());
}

int CvUnit::getExtraUnyielding(bool bIgnoreCommanders) const
{
	if (!bIgnoreCommanders && !isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander != NULL)
		{
			return m_iExtraUnyielding + pCommander->m_iExtraUnyielding;
		}
	}
	return m_iExtraUnyielding;
}

void CvUnit::changeExtraUnyielding(int iChange)
{
	m_iExtraUnyielding += iChange;
	FASSERT_NOT_NEGATIVE(getExtraUnyielding());
}

int CvUnit::getExtraKnockback(bool bIgnoreCommanders) const
{
	if (!bIgnoreCommanders && !isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander != NULL)
		{
			return m_iExtraKnockback + pCommander->m_iExtraKnockback;
		}
	}
	return m_iExtraKnockback;
}

void CvUnit::changeExtraKnockback(int iChange)
{
	m_iExtraKnockback += iChange;
	FASSERT_NOT_NEGATIVE(getExtraKnockback());
}

int CvUnit::getExtraKnockbackRetries(bool bIgnoreCommanders) const
{
	if (!bIgnoreCommanders && !isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander != NULL)
		{
			return m_iExtraKnockbackRetries + pCommander->m_iExtraKnockbackRetries;
		}
	}
	return m_iExtraKnockbackRetries;
}

void CvUnit::changeExtraKnockbackRetries(int iChange)
{
	m_iExtraKnockbackRetries += iChange;
	FASSERT_NOT_NEGATIVE(getExtraKnockbackRetries());
}

int CvUnit::getStampedeCount() const
{
	return m_iStampedeCount;
}

bool CvUnit::cannotStampede() const
{
	return getStampedeCount() < 0;
}

bool CvUnit::mayStampede() const
{
	return getStampedeCount() > 0;
}

void CvUnit::changeStampedeCount(int iChange)
{
	m_iStampedeCount += iChange;
}

int CvUnit::getAttackOnlyCitiesCount() const
{
	return m_iAttackOnlyCitiesCount;
}

void CvUnit::setAttackOnlyCitiesCount(int iChange)
{
	m_iAttackOnlyCitiesCount = iChange;
}

void CvUnit::changeAttackOnlyCitiesCount(int iChange)
{
	m_iAttackOnlyCitiesCount += iChange;
}

int CvUnit::getIgnoreNoEntryLevelCount() const
{
	return m_iIgnoreNoEntryLevelCount;
}

void CvUnit::setIgnoreNoEntryLevelCount(int iChange)
{
	m_iIgnoreNoEntryLevelCount = iChange;
}

void CvUnit::changeIgnoreNoEntryLevelCount(int iChange)
{
	m_iIgnoreNoEntryLevelCount += iChange;
}

int CvUnit::getIgnoreZoneofControlCount() const
{
	return m_iIgnoreZoneofControlCount;
}

void CvUnit::setIgnoreZoneofControlCount(int iChange)
{
	m_iIgnoreZoneofControlCount = iChange;
}

void CvUnit::changeIgnoreZoneofControlCount(int iChange)
{
	m_iIgnoreZoneofControlCount += iChange;
}

int CvUnit::getFliesToMoveCount() const
{
	return m_iFliesToMoveCount;
}

void CvUnit::setFliesToMoveCount(int iChange)
{
	m_iFliesToMoveCount = iChange;
}

void CvUnit::changeFliesToMoveCount(int iChange)
{
	m_iFliesToMoveCount += iChange;
}

int CvUnit::getExtraStrAdjperRnd(bool bIgnoreCommanders) const
{
	if (!bIgnoreCommanders && !isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander != NULL)
		{
			return m_iExtraStrAdjperRnd + pCommander->m_iExtraStrAdjperRnd;
		}
	}
	return m_iExtraStrAdjperRnd;
}

void CvUnit::changeExtraStrAdjperRnd(int iChange)
{
	m_iExtraStrAdjperRnd += iChange;
	FASSERT_NOT_NEGATIVE(getExtraStrAdjperRnd());
}

int CvUnit::getExtraStrAdjperAtt(bool bIgnoreCommanders) const
{
	if (!bIgnoreCommanders && !isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander != NULL)
		{
			return m_iExtraStrAdjperAtt + pCommander->m_iExtraStrAdjperAtt;
		}
	}
	return m_iExtraStrAdjperAtt;
}

void CvUnit::changeExtraStrAdjperAtt(int iChange)
{
	m_iExtraStrAdjperAtt += iChange;
	FASSERT_NOT_NEGATIVE(getExtraStrAdjperAtt());
}

int CvUnit::getExtraStrAdjperDef(bool bIgnoreCommanders) const
{
	if (noDefensiveBonus())
	{
		return 0;
	}
	if (!bIgnoreCommanders && !isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander != NULL)
		{
			return m_iExtraStrAdjperDef + pCommander->m_iExtraStrAdjperDef;
		}
	}
	return m_iExtraStrAdjperDef;
}

void CvUnit::changeExtraStrAdjperDef(int iChange)
{
	m_iExtraStrAdjperDef += iChange;
	FASSERT_NOT_NEGATIVE(getExtraStrAdjperDef());
}

int CvUnit::getExtraWithdrawAdjperAtt(bool bIgnoreCommanders) const
{
	if (!bIgnoreCommanders && !isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander != NULL)
		{
			return m_iExtraWithdrawAdjperAtt + pCommander->m_iExtraWithdrawAdjperAtt;
		}
	}
	return m_iExtraWithdrawAdjperAtt;
}

void CvUnit::changeExtraWithdrawAdjperAtt(int iChange)
{
	m_iExtraWithdrawAdjperAtt += iChange;
	FASSERT_NOT_NEGATIVE(getExtraWithdrawAdjperAtt());
}

int CvUnit::getExtraUnnerve(bool bIgnoreCommanders) const
{
	if (!bIgnoreCommanders && !isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander != NULL)
		{
			return m_iExtraUnnerve + pCommander->m_iExtraUnnerve;
		}
	}
	return m_iExtraUnnerve;
}

void CvUnit::changeExtraUnnerve(int iChange)
{
	m_iExtraUnnerve += iChange;
	FASSERT_NOT_NEGATIVE(getExtraUnnerve());
}

int CvUnit::getExtraEnclose(bool bIgnoreCommanders) const
{
	if (!bIgnoreCommanders && !isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander != NULL)
		{
			return m_iExtraEnclose + pCommander->m_iExtraEnclose;
		}
	}
	return m_iExtraEnclose;
}

void CvUnit::changeExtraEnclose(int iChange)
{
	m_iExtraEnclose += iChange;
	FASSERT_NOT_NEGATIVE(getExtraEnclose());
}

int CvUnit::getExtraLunge(bool bIgnoreCommanders) const
{
	if (!bIgnoreCommanders && !isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander != NULL)
		{
			return m_iExtraLunge + pCommander->m_iExtraLunge;
		}
	}
	return m_iExtraLunge;
}

void CvUnit::changeExtraLunge(int iChange)
{
	m_iExtraLunge += iChange;
	FASSERT_NOT_NEGATIVE(getExtraLunge());
}

int CvUnit::getExtraDynamicDefense(bool bIgnoreCommanders) const
{
	if (!bIgnoreCommanders && !isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander != NULL)
		{
			return m_iExtraDynamicDefense + pCommander->m_iExtraDynamicDefense;
		}
	}
	return m_iExtraDynamicDefense;
}

void CvUnit::changeExtraDynamicDefense(int iChange)
{
	m_iExtraDynamicDefense += iChange;
	FASSERT_NOT_NEGATIVE(getExtraDynamicDefense());
}

int CvUnit::getAnimalIgnoresBordersCount() const
{
	return m_iAnimalIgnoresBordersCount;
}

bool CvUnit::mayAnimalIgnoresBorders() const
{
	int iAnswer = m_pUnitInfo->canAnimalIgnoresBorders();
	iAnswer += getAnimalIgnoresBordersCount();
	return (iAnswer > 0);
}

void CvUnit::changeAnimalIgnoresBordersCount(int iChange)
{
	m_iAnimalIgnoresBordersCount += iChange;
}

int CvUnit::getOnslaughtCount() const
{
	return m_iOnslaughtCount;
}

bool CvUnit::mayOnslaught() const
{
	return getOnslaughtCount() > 0;
}

void CvUnit::changeOnslaughtCount(int iChange)
{
	m_iOnslaughtCount += iChange;
	FASSERT_NOT_NEGATIVE(getOnslaughtCount());
}

int CvUnit::getDealColdDamageCount() const
{
	return m_iDealColdDamageCount;
}

bool CvUnit::cannotDealColdDamage() const
{
	return getDealColdDamageCount() < 0;
}

bool CvUnit::mayDealColdDamage() const
{
	return getDealColdDamageCount() > 0;
}

void CvUnit::changeDealColdDamageCount(int iChange)
{
	m_iDealColdDamageCount += iChange;
}

int CvUnit::getColdImmuneCount() const
{
	return m_iColdImmuneCount;
}

bool CvUnit::cannotColdImmune() const
{
	return getColdImmuneCount() < 0;
}

bool CvUnit::mayColdImmune() const
{
	return getColdImmuneCount() > 0;
}

void CvUnit::changeColdImmuneCount(int iChange)
{
	m_iColdImmuneCount += iChange;
}

//TB SubCombat Mod Begin
int CvUnit::getSubCombatTypeCount(UnitCombatTypes eCombatType) const
{
	FASSERT_BOUNDS(0, GC.getNumUnitCombatInfos(), eCombatType);

	const UnitCombatKeyedInfo* info = findUnitCombatKeyedInfo(eCombatType);

	return info == NULL ? 0 : info->m_iSubCombatTypeCount;
}

bool CvUnit::hasExtraSubCombatType(UnitCombatTypes eCombatType) const
{
	FASSERT_BOUNDS(0, GC.getNumUnitCombatInfos(), eCombatType);
	return (getSubCombatTypeCount(eCombatType) > 0);
}

void CvUnit::changeSubCombatTypeCount(UnitCombatTypes eCombatType, int iChange)
{
	FASSERT_BOUNDS(0, GC.getNumUnitCombatInfos(), eCombatType);

	if (iChange != 0)
	{
		UnitCombatKeyedInfo* info = findOrCreateUnitCombatKeyedInfo(eCombatType);

		info->m_iSubCombatTypeCount += iChange;
		FASSERT_NOT_NEGATIVE(info->m_iSubCombatTypeCount);
	}
}

int CvUnit::getRemovesUnitCombatTypeCount(UnitCombatTypes eCombatType) const
{
	FASSERT_BOUNDS(0, GC.getNumUnitCombatInfos(), eCombatType);

	const UnitCombatKeyedInfo* info = findUnitCombatKeyedInfo(eCombatType);

	return info == NULL ? 0 : info->m_iRemovesUnitCombatTypeCount;
}

bool CvUnit::hasRemovesUnitCombatType(UnitCombatTypes eCombatType) const
{
	FASSERT_BOUNDS(0, GC.getNumUnitCombatInfos(), eCombatType);
	return (getRemovesUnitCombatTypeCount(eCombatType) > 0);
}

void CvUnit::changeRemovesUnitCombatTypeCount(UnitCombatTypes eCombatType, int iChange)
{
	FASSERT_BOUNDS(0, GC.getNumUnitCombatInfos(), eCombatType);

	if (iChange != 0)
	{
		UnitCombatKeyedInfo* info = findOrCreateUnitCombatKeyedInfo(eCombatType);

		info->m_iRemovesUnitCombatTypeCount += iChange;
		FASSERT_NOT_NEGATIVE(info->m_iRemovesUnitCombatTypeCount);
	}
}
//TB SubCombat Mod End

#ifdef OUTBREAKS_AND_AFFLICTIONS
int CvUnit::getCureAfflictionCount(PromotionLineTypes ePromotionLineType) const
{
	FASSERT_BOUNDS(0, GC.getNumPromotionLineInfos(), ePromotionLineType);

	const PromotionLineKeyedInfo* info = findPromotionLineKeyedInfo(ePromotionLineType);

	return info == NULL ? 0 : info->m_iCureAfflictionTypeCount;
}

bool CvUnit::hasExtraCureAffliction(PromotionLineTypes ePromotionLineType) const
{
	FASSERT_BOUNDS(0, GC.getNumPromotionLineInfos(), ePromotionLineType);
	return (getCureAfflictionCount(ePromotionLineType) > 0);
}

void CvUnit::changeCureAfflictionCount(PromotionLineTypes ePromotionLineType, int iChange)
{
	FASSERT_BOUNDS(0, GC.getNumPromotionLineInfos(), ePromotionLineType);

	if (iChange != 0)
	{
		PromotionLineKeyedInfo* info = findOrCreatePromotionLineKeyedInfo(ePromotionLineType);

		info->m_iCureAfflictionTypeCount += iChange;
	}
}
#endif // OUTBREAKS_AND_AFFLICTIONS

int CvUnit::getExtraFortitude(bool bIgnoreCommanders) const
{
	if (!bIgnoreCommanders && !isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander != NULL)
		{
			return m_iExtraFortitude + pCommander->m_iExtraFortitude;
		}
	}
	return m_iExtraFortitude;
}

void CvUnit::changeExtraFortitude(int iChange)
{
	m_iExtraFortitude += iChange;
	FASSERT_NOT_NEGATIVE(getExtraFortitude());
}

int CvUnit::getExtraDodgeModifier (bool bIgnoreCommanders) const
{
	if (!bIgnoreCommanders && !isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander != NULL)
		{
			return m_iExtraDodgeModifier + pCommander->m_iExtraDodgeModifier;
		}
	}
	return m_iExtraDodgeModifier;
}

void CvUnit::changeExtraDodgeModifier(int iChange)
{
	m_iExtraDodgeModifier +=iChange;
}

int CvUnit::getExtraPrecisionModifier(bool bIgnoreCommanders) const
{
	if (!bIgnoreCommanders && !isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander != NULL)
		{
			return m_iExtraPrecisionModifier + pCommander->m_iExtraPrecisionModifier;
		}
	}
	return m_iExtraPrecisionModifier;
}

void CvUnit::changeExtraPrecisionModifier(int iChange)
{
	m_iExtraPrecisionModifier +=iChange;
}

int CvUnit::getExtraPowerShots(bool bIgnoreCommanders) const
{
	if (!bIgnoreCommanders && !isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander != NULL)
		{
			return m_iExtraPowerShots + pCommander->m_iExtraPowerShots;
		}
	}
	return m_iExtraPowerShots;
}

void CvUnit::changeExtraPowerShots(int iChange)
{
	m_iExtraPowerShots += iChange;
	FASSERT_NOT_NEGATIVE(getExtraPowerShots());
}

int CvUnit::getExtraPowerShotCombatModifier(bool bIgnoreCommanders) const
{
	if (!bIgnoreCommanders && !isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander != NULL)
		{
			return m_iExtraPowerShotCombatModifier + pCommander->m_iExtraPowerShotCombatModifier;
		}
	}
	return m_iExtraPowerShotCombatModifier;
}

void CvUnit::changeExtraPowerShotCombatModifier(int iChange)
{
	m_iExtraPowerShotCombatModifier += iChange;
	FASSERT_NOT_NEGATIVE(getExtraPowerShotCombatModifier());
}

int CvUnit::getExtraPowerShotPunctureModifier(bool bIgnoreCommanders) const
{
	if (!bIgnoreCommanders && !isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander != NULL)
		{
			return m_iExtraPowerShotPunctureModifier + pCommander->m_iExtraPowerShotPunctureModifier;
		}
	}
	return m_iExtraPowerShotPunctureModifier;
}

void CvUnit::changeExtraPowerShotPunctureModifier(int iChange)
{
	m_iExtraPowerShotPunctureModifier += iChange;
	FASSERT_NOT_NEGATIVE(getExtraPowerShotPunctureModifier());
}

int CvUnit::getExtraPowerShotPrecisionModifier(bool bIgnoreCommanders) const
{
	if (!bIgnoreCommanders && !isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander != NULL)
		{
			return m_iExtraPowerShotPrecisionModifier + pCommander->m_iExtraPowerShotPrecisionModifier;
		}
	}
	return m_iExtraPowerShotPrecisionModifier;
}

void CvUnit::changeExtraPowerShotPrecisionModifier(int iChange)
{
	m_iExtraPowerShotPrecisionModifier += iChange;
	FASSERT_NOT_NEGATIVE(getExtraPowerShotPrecisionModifier());
}

int CvUnit::getExtraPowerShotCriticalModifier(bool bIgnoreCommanders) const
{
	if (!bIgnoreCommanders && !isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander != NULL)
		{
			return m_iExtraPowerShotCriticalModifier + pCommander->m_iExtraPowerShotCriticalModifier;
		}
	}
	return m_iExtraPowerShotCriticalModifier;
}

void CvUnit::changeExtraPowerShotCriticalModifier(int iChange)
{
	m_iExtraPowerShotCriticalModifier += iChange;
	FASSERT_NOT_NEGATIVE(getExtraPowerShotCriticalModifier());
}

int CvUnit::getExtraCriticalModifier(bool bIgnoreCommanders) const
{
	if (!bIgnoreCommanders && !isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander != NULL)
		{
			return m_iExtraCriticalModifier + pCommander->m_iExtraCriticalModifier;
		}
	}
	return m_iExtraCriticalModifier;
}

void CvUnit::changeExtraCriticalModifier(int iChange)
{
	m_iExtraCriticalModifier += iChange;
	FASSERT_NOT_NEGATIVE(getExtraCriticalModifier());
}

int CvUnit::getExtraEndurance(bool bIgnoreCommanders) const
{
	if (!bIgnoreCommanders && !isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander != NULL)
		{
			return m_iExtraEndurance + pCommander->m_iExtraEndurance;
		}
	}
	return m_iExtraEndurance;
}

void CvUnit::changeExtraEndurance(int iChange)
{
	m_iExtraEndurance += iChange;
	FASSERT_NOT_NEGATIVE(getExtraEndurance());
}

int CvUnit::getExtraPoisonProbabilityModifier(bool bIgnoreCommanders) const
{
	if (!bIgnoreCommanders && !isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander != NULL)
		{
			return m_iExtraPoisonProbabilityModifier + pCommander->m_iExtraPoisonProbabilityModifier;
		}
	}
	return m_iExtraPoisonProbabilityModifier;
}

void CvUnit::changeExtraPoisonProbabilityModifier(int iChange)
{
	m_iExtraPoisonProbabilityModifier += iChange;
	FASSERT_NOT_NEGATIVE(getExtraPoisonProbabilityModifier());
}

//TB Combat Mods End
int CvUnit::getExtraCollateralDamage() const
{
	if (!isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander != NULL)
		{
			return m_iExtraCollateralDamage + pCommander->m_iExtraCollateralDamage;
		}
	}
	return m_iExtraCollateralDamage;
}

void CvUnit::changeExtraCollateralDamage(int iChange)
{
	m_iExtraCollateralDamage += iChange;
	FASSERT_NOT_NEGATIVE(getExtraCollateralDamage());
}

int CvUnit::getExtraEnemyHeal() const
{
	if (!isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander != NULL)
			return m_iExtraEnemyHeal + pCommander->m_iExtraEnemyHeal;
	}
	return m_iExtraEnemyHeal;
}

void CvUnit::changeExtraEnemyHeal(int iChange)
{
	m_iExtraEnemyHeal += iChange;
	//FASSERT_NOT_NEGATIVE(getExtraEnemyHeal());
}

int CvUnit::getExtraNeutralHeal() const
{
	if (!isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander != NULL)
			return m_iExtraNeutralHeal + pCommander->m_iExtraNeutralHeal;
	}
	return m_iExtraNeutralHeal;
}

void CvUnit::changeExtraNeutralHeal(int iChange)
{
	m_iExtraNeutralHeal += iChange;
	//FASSERT_NOT_NEGATIVE(getExtraNeutralHeal());
}

int CvUnit::getExtraFriendlyHeal() const
{
	if (!isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander != NULL)
			return m_iExtraFriendlyHeal + pCommander->m_iExtraFriendlyHeal;
	}
	return m_iExtraFriendlyHeal;
}


void CvUnit::changeExtraFriendlyHeal(int iChange)
{
	m_iExtraFriendlyHeal += iChange;
	//FASSERT_NOT_NEGATIVE(getExtraFriendlyHeal())
}

int CvUnit::getSameTileHeal() const
{
	return m_iSameTileHeal;
}

void CvUnit::changeSameTileHeal(int iChange)
{
	m_iSameTileHeal += iChange;
	FASSERT_NOT_NEGATIVE(getSameTileHeal());
}

int CvUnit::getAdjacentTileHeal() const
{
	return m_iAdjacentTileHeal;
}

void CvUnit::changeAdjacentTileHeal(int iChange)
{
	m_iAdjacentTileHeal += iChange;
	FASSERT_NOT_NEGATIVE(getAdjacentTileHeal());
}

int CvUnit::getExtraCombatPercent() const
{
	if (!isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander != NULL)
			return m_iExtraCombatPercent + pCommander->m_iExtraCombatPercent;
	}
	return m_iExtraCombatPercent;
}

void CvUnit::changeExtraCombatPercent(int iChange)
{
	if (iChange != 0)
	{
		m_iExtraCombatPercent += iChange;

		setInfoBarDirty(true);
	}
}

int CvUnit::getExtraCityAttackPercent() const
{
	if (!isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander != NULL)
			return m_iExtraCityAttackPercent + pCommander->m_iExtraCityAttackPercent;
	}
	return m_iExtraCityAttackPercent;
}

void CvUnit::changeExtraCityAttackPercent(int iChange)
{
	if (iChange != 0)
	{
		m_iExtraCityAttackPercent += iChange;

		setInfoBarDirty(true);
	}
}

int CvUnit::getExtraCityDefensePercent() const
{
	if (noDefensiveBonus())
	{
		return 0;
	}
	if (!isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander != NULL)
			return m_iExtraCityDefensePercent + pCommander->m_iExtraCityDefensePercent;
	}
	return m_iExtraCityDefensePercent;
}

void CvUnit::changeExtraCityDefensePercent(int iChange)
{
	if (iChange != 0)
	{
		m_iExtraCityDefensePercent += iChange;

		setInfoBarDirty(true);
	}
}

int CvUnit::getExtraHillsAttackPercent() const
{
	if (!isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander != NULL)
			return m_iExtraHillsAttackPercent + pCommander->m_iExtraHillsAttackPercent;
	}
	return m_iExtraHillsAttackPercent;
}

void CvUnit::changeExtraHillsAttackPercent(int iChange)
{
	if (iChange != 0)
	{
		m_iExtraHillsAttackPercent += iChange;

		setInfoBarDirty(true);
	}
}

int CvUnit::getExtraHillsDefensePercent() const
{
	if (noDefensiveBonus())
	{
		return 0;
	}
	if (!isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander != NULL)
			return m_iExtraHillsDefensePercent + pCommander->m_iExtraHillsDefensePercent;
	}
	return m_iExtraHillsDefensePercent;
}

void CvUnit::changeExtraHillsDefensePercent(int iChange)
{
	if (iChange != 0)
	{
		m_iExtraHillsDefensePercent += iChange;

		setInfoBarDirty(true);
	}
}

//WorkRateMod
int CvUnit::hillsWorkModifier() const
{
	return m_worker != NULL ? m_worker->getHillsWorkModifier() : 0;
}

int CvUnit::peaksWorkModifier() const
{
	return m_worker != NULL ? m_worker->getPeaksWorkModifier() : 0;
}

int CvUnit::getWorkModifier() const
{
	return m_worker != NULL ? m_worker->getWorkModifier() : 0;
}

int CvUnit::getExtraWorkModForBuild(const BuildTypes eBuild) const
{
	return m_worker != NULL ? m_worker->getExtraWorkModForBuild(eBuild) : 0;
}


int CvUnit::getCollateralDamageProtection() const
{
	return m_iCollateralDamageProtection;
}

void CvUnit::changeCollateralDamageProtection(int iChange)
{
	if (iChange != 0)
	{
		m_iCollateralDamageProtection += iChange;

		setInfoBarDirty(true);
	}
}

int CvUnit::getPillageChange() const
{
	return m_iPillageChange;
}

void CvUnit::changePillageChange(int iChange)
{
	if (iChange != 0)
	{
		m_iPillageChange += iChange;

		setInfoBarDirty(true);
	}
}

int CvUnit::getUpgradeDiscount() const
{
	return m_iUpgradeDiscount;
}

void CvUnit::changeUpgradeDiscount(int iChange)
{
	if (iChange != 0)
	{
		m_iUpgradeDiscount += iChange;

		setInfoBarDirty(true);
	}
}

int CvUnit::getExperiencePercent() const
{
	if (isCommander())
	{
		return 0; // Afforess - Great Commanders can not gain XP faster
	}
	const CvUnit* pCommander = getCommander();

	if (pCommander != NULL)
	{
		return m_iExperiencePercent + pCommander->getExperiencePercent();
	}
	return m_iExperiencePercent;

	//return !isCommander() ? m_iExperiencePercent : 0;
}

void CvUnit::changeExperiencePercent(int iChange)
{
	if (iChange != 0)
	{
		m_iExperiencePercent += iChange;

		setInfoBarDirty(true);
	}
}

int CvUnit::getKamikazePercent() const
{
	return m_iKamikazePercent;
}

void CvUnit::changeKamikazePercent(int iChange)
{
	if (iChange != 0)
	{
		m_iKamikazePercent += iChange;

		setInfoBarDirty(true);
	}
}

DirectionTypes CvUnit::getFacingDirection(bool checkLineOfSightProperty) const
{
	if (checkLineOfSightProperty && !m_pUnitInfo->isLineOfSight())
	{
		return NO_DIRECTION; //look in all directions
	}
	return m_eFacingDirection; //only look in facing direction
}

void CvUnit::setFacingDirection(DirectionTypes eFacingDirection)
{
	if (eFacingDirection != m_eFacingDirection)
	{
		m_eFacingDirection = eFacingDirection;
		NotifyEntity(NO_MISSION);
	}
}

void CvUnit::rotateFacingDirectionClockwise()
{
	//change direction
	DirectionTypes eNewDirection = (DirectionTypes) ((m_eFacingDirection + 1) % NUM_DIRECTION_TYPES);
	setFacingDirection(eNewDirection);
}

void CvUnit::rotateFacingDirectionCounterClockwise()
{
	//change direction
	DirectionTypes eNewDirection = (DirectionTypes) ((m_eFacingDirection + NUM_DIRECTION_TYPES - 1) % NUM_DIRECTION_TYPES);
	setFacingDirection(eNewDirection);
}

int CvUnit::getImmobileTimer() const
{
	return m_iImmobileTimer;
}

void CvUnit::setImmobileTimer(int iNewValue)
{
	if (iNewValue != getImmobileTimer())
	{
		m_iImmobileTimer = iNewValue;

		setInfoBarDirty(true);
	}
}

void CvUnit::changeImmobileTimer(int iChange)
{
	if (iChange != 0)
	{
		setImmobileTimer(std::max(0, getImmobileTimer() + iChange));
	}
}

//Team Project (2)
/*****************************************************************************************************/
/**  Author: TheLadiesOgre                                                                          **/
/**  Date: 21.09.2009                                                                               **/
/**  ModComp: TLOTags                                                                               **/
/**  Reason Added: New Bool Flags                                                                   **/
/**  Notes:                                                                                         **/
/*****************************************************************************************************/
bool CvUnit::isCanRespawn() const
{
	return m_bCanRespawn;
}


void CvUnit::setCanRespawn(bool bNewValue)
{
	m_bCanRespawn = bNewValue;
}


bool CvUnit::isSurvivor() const
{
	return m_bSurvivor;
}


void CvUnit::setSurvivor(bool bNewValue)
{
	m_bSurvivor = bNewValue;
}


/*****************************************************************************************************/
/**  TheLadiesOgre; 21.09.2009; TLOTags                                                             **/
/*****************************************************************************************************/

bool CvUnit::isMadeAttack() const
{
	return m_bMadeAttack;
}


void CvUnit::setMadeAttack(bool bNewValue)
{
	m_bMadeAttack = bNewValue;
}


//TB Combat Mods (Att&DefCounters)
int CvUnit::getRoundCount() const
{
	return m_iRoundCount;
}

void CvUnit::changeRoundCount(int iChange)
{
	if (iChange != 0)
	{
		m_iRoundCount += iChange;
	}
}

int CvUnit::getAttackCount() const
{
	return m_iAttackCount;
}

void CvUnit::changeAttackCount(int iChange)
{
	if (iChange != 0)
	{
		m_iAttackCount += iChange;
	}
}

int CvUnit::getDefenseCount() const
{
	return m_iDefenseCount;
}

void CvUnit::changeDefenseCount(int iChange)
{
	if (iChange != 0)
	{
		m_iDefenseCount += iChange;
	}
}
//TB Combat Mods End

bool CvUnit::isMadeInterception() const
{
	return m_bMadeInterception;
}


void CvUnit::setMadeInterception(bool bNewValue)
{
	m_bMadeInterception = bNewValue;
}


bool CvUnit::isPromotionReady() const
{
	return m_bPromotionReady;
}


void CvUnit::setPromotionReady(bool bNewValue)
{
	if (isPromotionReady() != bNewValue)
	{
		m_bPromotionReady = bNewValue;

/************************************************************************************************/
/* Afforess	                  Start		 09/16/10                                               */
/*                                                                                              */
/* Advanced Automations                                                                         */
/************************************************************************************************/
		if ( !isUsingDummyEntities() && isInViewport())
		{
			gDLL->getEntityIFace()->showPromotionGlow(getUnitEntity(), bNewValue);
		}

		if (m_bPromotionReady)
		{
			if (isAutoPromoting())
			{
				if(AI_promote())
				{
					setPromotionReady(false);
					testPromotionReady();
				}
				else
				{
					setPromotionReady(false);
					FErrorMsg("Couldn't apply promotion");
				}
			}
			else
			{
				MissionAITypes eMissionAI = getGroup()->AI_getMissionAIType();

				//	Don't interrupt units on their way to delivery or rally plots
				if ( (MISSIONAI_CONTRACT != eMissionAI && MISSIONAI_CONTRACT_UNIT != eMissionAI) ||
					 getGroup()->AI_getMissionAIPlot() == plot() )
				{
					getGroup()->setAutomateType(NO_AUTOMATE);
					getGroup()->clearMissionQueue();
					getGroup()->setActivityType(ACTIVITY_AWAKE);
				}
			}
/************************************************************************************************/
/* Afforess	                     END                                                            */
/************************************************************************************************/
		}

		if (IsSelected())
		{
			gDLL->getInterfaceIFace()->setDirty(SelectionButtons_DIRTY_BIT, true);
		}
	}
}


void CvUnit::testPromotionReady()
{
	//TB Combat Mod
	bool bPromotionReady = false;
	if (getExperience() >= experienceNeeded() && canAcquirePromotionAny())
	{
		logBBAI("Exp for promotion present (%d vs %d)\n", getExperience(), experienceNeeded());
		bPromotionReady = true;
	}
	if (getRetrainsAvailable() > 0 && canAcquirePromotionAny())
	{
		logBBAI("Retrain available (%d left)\n", getRetrainsAvailable());
		bPromotionReady = true;
	}

	setPromotionReady(bPromotionReady);
	//TB Combat Mod end
}


bool CvUnit::isDelayedDeath() const
{
	return m_bDeathDelay;
}


void CvUnit::startDelayedDeath()
{
	m_bDeathDelay = true;
}


// Returns true if killed...
bool CvUnit::doDelayedDeath()
{
	// Koshling - added 'isDead' check to clean up units with 100% damage that have somehow been left behind
	if ((m_bDeathDelay || isDead()) && !isFighting())
	{
		killUnconditional(false, NO_PLAYER, true);
		return true;
	}
	return false;
}


bool CvUnit::isCombatFocus() const
{
	return m_bCombatFocus;
}


bool CvUnit::isInfoBarDirty() const
{
	return m_bInfoBarDirty;
}


void CvUnit::setInfoBarDirty(bool bNewValue)
{
	m_bInfoBarDirty = bNewValue;
}

bool CvUnit::isBlockading() const
{
	return m_bBlockading;
}

void CvUnit::setBlockading(bool bNewValue)
{
	if (bNewValue != isBlockading())
	{
		m_bBlockading = bNewValue;

		updatePlunder(isBlockading() ? 1 : -1, true);
	}
}

void CvUnit::collectBlockadeGold()
{
	if (plot()->getTeam() == getTeam())
	{
		return;
	}

	const int iBlockadeRange = GC.getDefineINT("SHIP_BLOCKADE_RANGE");

	foreach_(const CvPlot* pLoopPlot, plot()->rect(iBlockadeRange, iBlockadeRange)
	| filtered(CvPlot::fn::isRevealed(getTeam(), false)))
	{
		CvCity* pCity = pLoopPlot->getPlotCity();

		if (NULL != pCity && !pCity->isPlundered() && isEnemy(pCity->getTeam()) && !atWar(pCity->getTeam(), getTeam()))
		{
			if (pCity->area() == area() || pCity->plot()->isAdjacentToArea(area()))
			{
				int iGold = pCity->calculateTradeProfit(pCity) * pCity->getTradeRoutes();
				iGold *= (100 + GET_PLAYER(getOwner()).calculateInflationRate());
				iGold /= 100;
				if (iGold > 0)
				{
					pCity->setPlundered(true);
					GET_PLAYER(getOwner()).changeGold(iGold);
					GET_PLAYER(pCity->getOwner()).changeGold(-iGold);


					const CvWString szBuffer = gDLL->getText("TXT_KEY_MISC_TRADE_ROUTE_PLUNDERED", getNameKey(), pCity->getNameKey(), iGold);
					AddDLLMessage(getOwner(), false, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_BUILD_BANK", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_GREEN(), getX(), getY());

					const CvWString szBuffer2 = gDLL->getText("TXT_KEY_MISC_TRADE_ROUTE_PLUNDER", getNameKey(), pCity->getNameKey(), iGold);
					AddDLLMessage(pCity->getOwner(), false, GC.getEVENT_MESSAGE_TIME(), szBuffer2, "AS2D_BUILD_BANK", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_RED(), pCity->getX(), pCity->getY());
				}
			}
		}
	}
}


PlayerTypes CvUnit::getVisualOwner(TeamTypes eForTeam) const
{
	if (NO_TEAM == eForTeam)
	{
		eForTeam = GC.getGame().getActiveTeam();
	}

	if (getTeam() != eForTeam && eForTeam != BARBARIAN_TEAM && isHiddenNationality() && !plot()->isCity(true, getTeam()))
	{
		return BARBARIAN_PLAYER;
	}
	return getOwner();
}


PlayerTypes CvUnit::getCombatOwner(TeamTypes eForTeam, const CvPlot* pPlot) const
{
	if (eForTeam != NO_TEAM && getTeam() != eForTeam && eForTeam != BARBARIAN_TEAM && isAlwaysHostile(pPlot))
	{
		return BARBARIAN_PLAYER;
	}
	return getOwner();
}

TeamTypes CvUnit::getTeam() const
{
	return GET_PLAYER(getOwner()).getTeam();
}


PlayerTypes CvUnit::getCapturingPlayer() const
{
	return m_eCapturingPlayer;
}


void CvUnit::setCapturingPlayer(PlayerTypes eNewValue)
{
	m_eCapturingPlayer = eNewValue;
}

CvUnit* CvUnit::getCapturingUnit() const
{
	return getUnit(m_eCapturingUnit);
}

void CvUnit::setCapturingUnit(const CvUnit* pCapturingUnit)
{
	m_eCapturingUnit = pCapturingUnit->getIDInfo();
}

const UnitTypes CvUnit::getUnitType() const
{
	return m_eUnitType;
}

const CvUnitInfo& CvUnit::getUnitInfo() const
{
	return *m_pUnitInfo;
}

const UnitTypes CvUnit::getLeaderUnitType() const
{
	return m_eLeaderUnitType;
}

void CvUnit::setLeaderUnitType(UnitTypes leaderUnitType)
{
	if (m_eLeaderUnitType != leaderUnitType)
	{
		m_eLeaderUnitType = leaderUnitType;
		reloadEntity();
	}
}

CvUnit* CvUnit::getCombatUnit() const
{
	return getUnit(m_combatUnit);
}


void CvUnit::setCombatUnit(CvUnit* pCombatUnit, bool bAttacking, bool bStealthAttack, bool bStealthDefense)
{
	if (isCombatFocus())
	{
		gDLL->getInterfaceIFace()->setCombatFocus(false);
	}

	if (pCombatUnit != NULL)
	{
		if (bAttacking)
		{
			if (GC.getLogging() && GC.getGame().isDebugMode())
			{
				// Log info about this combat...
				char szOut[1024];
				sprintf( szOut, "*** KOMBAT!\n     ATTACKER: Player %d Unit %d (%S's %S), CombatStrength=%d\n     DEFENDER: Player %d Unit %d (%S's %S), CombatStrength=%d\n",
					getOwner(), getID(), GET_PLAYER(getOwner()).getName(), getName().GetCString(), currCombatStr(NULL, NULL),
					pCombatUnit->getOwner(), pCombatUnit->getID(), GET_PLAYER(pCombatUnit->getOwner()).getName(), pCombatUnit->getName().GetCString(), pCombatUnit->currCombatStr(pCombatUnit->plot(), this));
				gDLL->messageControlLog(szOut);
			}

			if (showSeigeTower(pCombatUnit) && !isUsingDummyEntities()  && isInViewport())
			{
				CvDLLEntity::SetSiegeTower(true);
			}
			if (!bStealthAttack && !bStealthDefense)
			{
				setCombatFirstStrikes((pCombatUnit->immuneToFirstStrikes()) ? 0 : (firstStrikes() + GC.getGame().getSorenRandNum(chanceFirstStrikes() + 1, "First Strike")));
			}
			else if (bStealthAttack)
			{
				setCombatFirstStrikes(stealthStrikesTotal());
			}
		}
		else if (bStealthDefense)
		{
			setCombatFirstStrikes(stealthStrikesTotal());
		}
		else
		{
			setCombatFirstStrikes((pCombatUnit->immuneToFirstStrikes()) ? 0 : (firstStrikes() + GC.getGame().getSorenRandNum(chanceFirstStrikes() + 1, "First Strike")));
		}

		FAssertMsg(getCombatUnit() == NULL, "Combat Unit is not expected to be assigned");
		/*FAssertMsg(!(plot()->isFighting()), "(plot()->isFighting()) did not return false as expected");*///TB - this can happen now safely.
		m_bCombatFocus = (bAttacking && !(gDLL->getInterfaceIFace()->isFocusedWidget()) && ((getOwner() == GC.getGame().getActivePlayer()) || ((pCombatUnit->getOwner() == GC.getGame().getActivePlayer()) && !(GC.getGame().isMPOption(MPOPTION_SIMULTANEOUS_TURNS)))));
		m_combatUnit = pCombatUnit->getIDInfo();
		if (!bStealthAttack)
		{
			setCombatFirstStrikes((pCombatUnit->immuneToFirstStrikes()) ? 0 : (firstStrikes() + GC.getGame().getSorenRandNum(chanceFirstStrikes() + 1, "First Strike")));
		}
		else
		{
			setCombatFirstStrikes(stealthStrikesTotal());
		}
		//TB Combat mod begin
		int iKnockbackAttempts = 0;
		setCombatPowerShots(powerShotsTotal());
		if (knockbackTotal() > 0)
		{
			iKnockbackAttempts = knockbackRetriesTotal() + 1;
			setCombatKnockbacks(iKnockbackAttempts);
		}
		int iRepelAttempts = 0;
		if (repelTotal() > 0)
		{
			iRepelAttempts = repelRetriesTotal() + 1;
			setCombatRepels(iRepelAttempts);
		}
		setCombatStuns(0);
		//TB Combat Mod end
	}
	else if (getCombatUnit() != NULL)
	{
		FAssertMsg(getCombatUnit() != NULL, "getCombatUnit() is not expected to be equal with NULL");
		FAssertMsg(plot()->isFighting(), "plot()->isFighting is expected to be true");
		m_bCombatFocus = false;
		m_combatUnit.reset();
		setCombatFirstStrikes(0);
		//TB Combat Mod begin
		setCombatPowerShots(0);
		setCombatKnockbacks(0);
		setCombatRepels(0);
		setCombatStuns(0);
		//TB Combat mod end

		if (IsSelected())
		{
			gDLL->getInterfaceIFace()->setDirty(InfoPane_DIRTY_BIT, true);
		}

		if (plot() == gDLL->getInterfaceIFace()->getSelectionPlot())
		{
			gDLL->getInterfaceIFace()->setDirty(PlotListButtons_DIRTY_BIT, true);
		}

		if ( !isUsingDummyEntities()  && isInViewport())
		{
			CvDLLEntity::SetSiegeTower(false);
		}
	}

	setCombatTimer(0);
	setInfoBarDirty(true);

	if (isCombatFocus())
	{
		gDLL->getInterfaceIFace()->setCombatFocus(true);
	}
}

// K-Mod. Return true if the combat animation should include a seige tower
// (code copied from setCombatUnit, above)
bool CvUnit::showSeigeTower(const CvUnit* pDefender) const
{
	return getDomainType() == DOMAIN_LAND
		&& !m_pUnitInfo->isIgnoreBuildingDefense()
		&& pDefender->plot()->getPlotCity()
		&& pDefender->plot()->getPlotCity()->getBuildingDefense() > 0
		&& cityAttackModifier() >= GC.getDefineINT("MIN_CITY_ATTACK_MODIFIER_FOR_SIEGE_TOWER");
}
// K-Mod end

CvUnit* CvUnit::getTransportUnit() const
{
	return getUnit(m_transportUnit);
}


bool CvUnit::isCargo() const
{
	return getTransportUnit() != NULL;
}


void CvUnit::setTransportUnit(CvUnit* pTransportUnit)
{
	CvUnit* pOldTransportUnit = getTransportUnit();

	if (pOldTransportUnit != pTransportUnit)
	{
		if (pOldTransportUnit != NULL)
		{
			if (GC.getGame().isOption(GAMEOPTION_SIZE_MATTERS))
			{
				pOldTransportUnit->SMchangeCargo(-SMCargoVolume());
				pOldTransportUnit->changeCargo(-1);
			}
			else
			{
				pOldTransportUnit->changeCargo(-1);
			}
			if (getSpecialUnitType() != NO_SPECIALUNIT)
			{
				pOldTransportUnit->processLoadedSpecialUnit(false, getSpecialUnitType());
			}
		}

		if (pTransportUnit != NULL)
		{
			if (GC.getGame().isOption(GAMEOPTION_SIZE_MATTERS))
			{
				FAssertMsg(pTransportUnit->SMcargoSpaceAvailable(getSpecialUnitType(), getDomainType()) > 0, "Cargo space is expected to be available");
				//Can Happen without it being a bug if the unit was forced reloaded by means of an adjustment when already loaded that allowed the unit to overload the transport.
			}
			else
			{
				FAssertMsg(pTransportUnit->cargoSpaceAvailable(getSpecialUnitType(), getDomainType()) > 0, "Cargo space is expected to be available");
			}

			joinGroup(NULL, true); // Because what if a group of 3 tries to get in a transport which can hold 2...

			m_transportUnit = pTransportUnit->getIDInfo();
			setInhibitMerge(false);
			setInhibitSplit(false);

			if (getDomainType() != DOMAIN_AIR)
			{
				getGroup()->setActivityType(ACTIVITY_SLEEP);
			}

			if (GC.getGame().isFinalInitialized())
			{
				finishMoves();
			}

			if (GC.getGame().isOption(GAMEOPTION_SIZE_MATTERS))
			{
				pTransportUnit->SMchangeCargo(SMCargoVolume());
				pTransportUnit->changeCargo(1);
			}
			else
			{
				pTransportUnit->changeCargo(1);
			}
			if (getSpecialUnitType() != NO_SPECIALUNIT)
			{
				pTransportUnit->processLoadedSpecialUnit(true, getSpecialUnitType());
			}
			pTransportUnit->getGroup()->setActivityType(ACTIVITY_AWAKE);
		}
		else
		{
			m_transportUnit.reset();

			getGroup()->setActivityType(ACTIVITY_AWAKE);
/************************************************************************************************/
/* Afforess	                  Start		 09/01/10                                               */
/*                                                                                              */
/*  After a Barb Transport is done, set it to attack AI                                         */
/************************************************************************************************/
			if (pOldTransportUnit != NULL && !pOldTransportUnit->hasCargo())
			{
				if (pOldTransportUnit->getDomainType() == DOMAIN_SEA && pOldTransportUnit->getOwner() == BARBARIAN_PLAYER)
				{
					pOldTransportUnit->AI_setUnitAIType(UNITAI_ATTACK_SEA);
				}
			}
/************************************************************************************************/
/* Afforess	                     END                                                            */
/************************************************************************************************/

			//	Koshling - have the AI prioritize regrouping with other units when unloaded
			getGroup()->AI_setMissionAI(MISSIONAI_REGROUP, NULL, NULL);
		}

#ifdef _DEBUG
		std::vector<CvUnit*> aCargoUnits;
		if (pOldTransportUnit != NULL)
		{
			pOldTransportUnit->getCargoUnits(aCargoUnits);
			if (aCargoUnits.size() > 0)
			{
				pOldTransportUnit->validateCargoUnits();
			}
		}
		if (pTransportUnit != NULL)
		{
			pTransportUnit->getCargoUnits(aCargoUnits);
			if (aCargoUnits.size() > 0)
			{
				pTransportUnit->validateCargoUnits();
			}
		}

		getGroup()->validateLocations();
#endif

	}
}


int CvUnit::getExtraDomainModifier(DomainTypes eIndex) const
{
	FASSERT_BOUNDS(0, NUM_DOMAIN_TYPES, eIndex);

	if (!isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander != NULL)
		{
			return m_aiExtraDomainModifier[eIndex] + pCommander->m_aiExtraDomainModifier[eIndex];
		}
	}
	return m_aiExtraDomainModifier[eIndex];
}


void CvUnit::changeExtraDomainModifier(DomainTypes eIndex, int iChange)
{
	FASSERT_BOUNDS(0, NUM_DOMAIN_TYPES, eIndex);
	m_aiExtraDomainModifier[eIndex] += iChange;
}


const CvWString CvUnit::getDescription(uint uiForm) const
{
	if (m_pUnitInfo->getCivilizationName(getCivilizationType()) != NULL
	&& !CvWString(m_pUnitInfo->getCivilizationName(getCivilizationType())).empty())
	{
		return gDLL->getText(m_pUnitInfo->getCivilizationName(getCivilizationType()));
	}
	return m_pUnitInfo->getDescription(uiForm);
}

const CvWString CvUnit::getName(uint uiForm) const
{
	CvWString szBuffer;

	if (m_szName.empty())
	{
		return getDescription(uiForm);
	}

	if (isDescInName())
	{
		return m_szName;
	}

	szBuffer.Format(L"%s (%s)", m_szName.GetCString(), getDescription(uiForm).GetCString());

	return szBuffer;
}

bool CvUnit::isDescInName() const
{
	return (m_szName.find(getDescription()) != -1);
}


const wchar_t* CvUnit::getNameKey() const
{
	if (m_szName.empty())
	{
		return m_pUnitInfo->getTextKeyWide();
	}
	return m_szName.GetCString();
}


const CvWString& CvUnit::getNameNoDesc() const
{
	return m_szName;
}


void CvUnit::setName(CvWString szNewValue)
{
	gDLL->stripSpecialCharacters(szNewValue);

	m_szName = szNewValue;

	if (IsSelected())
	{
		gDLL->getInterfaceIFace()->setDirty(InfoPane_DIRTY_BIT, true);
	}
}


std::string CvUnit::getScriptData() const
{
	return m_szScriptData;
}


void CvUnit::setScriptData(std::string szNewValue)
{
	m_szScriptData = szNewValue;
}


int CvUnit::getTerrainDoubleMoveCount(TerrainTypes eIndex) const
{
	FASSERT_BOUNDS(0, GC.getNumTerrainInfos(), eIndex);

	const TerrainKeyedInfo* info = findTerrainKeyedInfo(eIndex);

	return info == NULL ? 0 : info->m_iTerrainDoubleMoveCount;
}


bool CvUnit::isTerrainDoubleMove(TerrainTypes eIndex) const
{
	FASSERT_BOUNDS(0, GC.getNumTerrainInfos(), eIndex);
	return getTerrainDoubleMoveCount(eIndex) > 0;
}


void CvUnit::changeTerrainDoubleMoveCount(TerrainTypes eIndex, int iChange)
{
	FASSERT_BOUNDS(0, GC.getNumTerrainInfos(), eIndex);

	if (iChange != 0)
	{
		TerrainKeyedInfo* info = findOrCreateTerrainKeyedInfo(eIndex);

		info->m_iTerrainDoubleMoveCount += iChange;
		FASSERT_NOT_NEGATIVE(info->m_iTerrainDoubleMoveCount);
	}
}


int CvUnit::getFeatureDoubleMoveCount(FeatureTypes eIndex) const
{
	FASSERT_BOUNDS(0, GC.getNumFeatureInfos(), eIndex);

	const FeatureKeyedInfo* info = findFeatureKeyedInfo(eIndex);

	return info == NULL ? 0 : info->m_iFeatureDoubleMoveCount;
}


bool CvUnit::isFeatureDoubleMove(FeatureTypes eIndex) const
{
	FASSERT_BOUNDS(0, GC.getNumFeatureInfos(), eIndex);
	return (getFeatureDoubleMoveCount(eIndex) > 0);
}


void CvUnit::changeFeatureDoubleMoveCount(FeatureTypes eIndex, int iChange)
{
	FASSERT_BOUNDS(0, GC.getNumFeatureInfos(), eIndex);

	if (iChange != 0)
	{
		FeatureKeyedInfo* info = findOrCreateFeatureKeyedInfo(eIndex);

		info->m_iFeatureDoubleMoveCount += iChange;
		FASSERT_NOT_NEGATIVE(info->m_iFeatureDoubleMoveCount);
	}
}

int CvUnit::getExtraTerrainWorkPercent(TerrainTypes eIndex) const
{
	FASSERT_BOUNDS(0, GC.getNumTerrainInfos(), eIndex);

	const TerrainKeyedInfo* info = findTerrainKeyedInfo(eIndex);

	return info == NULL ? 0 : info->m_iExtraTerrainWorkPercent;
}

void CvUnit::changeExtraTerrainWorkPercent(TerrainTypes eIndex, int iChange)
{
	FASSERT_BOUNDS(0, GC.getNumTerrainInfos(), eIndex);

	if (iChange != 0)
	{
		TerrainKeyedInfo* info = findOrCreateTerrainKeyedInfo(eIndex);

		info->m_iExtraTerrainWorkPercent += iChange;

		setInfoBarDirty(true);
	}
}


int CvUnit::getExtraFeatureWorkPercent(FeatureTypes eIndex) const
{
	FASSERT_BOUNDS(0, GC.getNumFeatureInfos(), eIndex);

	const FeatureKeyedInfo* info = findFeatureKeyedInfo(eIndex);

	return info == NULL ? 0 : info->m_iExtraFeatureWorkPercent;
}

void CvUnit::changeExtraFeatureWorkPercent(FeatureTypes eIndex, int iChange)
{
	FASSERT_BOUNDS(0, GC.getNumFeatureInfos(), eIndex);

	if (iChange != 0)
	{
		FeatureKeyedInfo* info = findOrCreateFeatureKeyedInfo(eIndex);

		info->m_iExtraFeatureWorkPercent += iChange;

		setInfoBarDirty(true);
	}
}

//get totals
int CvUnit::terrainWorkPercent(TerrainTypes eIndex) const
{
	FASSERT_BOUNDS(0, GC.getNumTerrainInfos(), eIndex);
	return m_pUnitInfo->getTerrainWorkRateModifierType(eIndex) + getExtraTerrainWorkPercent(eIndex);
}

int CvUnit::featureWorkPercent(FeatureTypes eIndex) const
{
	FASSERT_BOUNDS(0, GC.getNumFeatureInfos(), eIndex);
	return m_pUnitInfo->getFeatureWorkRateModifierType(eIndex) + getExtraFeatureWorkPercent(eIndex);
}

int CvUnit::buildWorkPercent(BuildTypes eIndex) const
{
	FASSERT_BOUNDS(0, GC.getNumBuildInfos(), eIndex);
	return m_pUnitInfo->getBuildWorkRateModifierType(eIndex) + getExtraWorkModForBuild(eIndex);
}


int CvUnit::getExtraTerrainAttackPercent(TerrainTypes eIndex) const
{
	FASSERT_BOUNDS(0, GC.getNumTerrainInfos(), eIndex);

	const TerrainKeyedInfo* info = findTerrainKeyedInfo(eIndex);

	const int iBaseAmount = (info == NULL ? 0 : info->m_iExtraTerrainAttackPercent);

	if (!isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander != NULL)
			return iBaseAmount + pCommander->getExtraTerrainAttackPercent(eIndex);
	}
	return iBaseAmount;
}


void CvUnit::changeExtraTerrainAttackPercent(TerrainTypes eIndex, int iChange)
{
	FASSERT_BOUNDS(0, GC.getNumTerrainInfos(), eIndex);

	if (iChange != 0)
	{
		TerrainKeyedInfo* info = findOrCreateTerrainKeyedInfo(eIndex);

		info->m_iExtraTerrainAttackPercent += iChange;

		setInfoBarDirty(true);
	}
}

int CvUnit::getExtraTerrainDefensePercent(TerrainTypes eIndex) const
{
	if (noDefensiveBonus())
	{
		return 0;
	}
	FASSERT_BOUNDS(0, GC.getNumTerrainInfos(), eIndex);

	const TerrainKeyedInfo* info = findTerrainKeyedInfo(eIndex);

	const int iBaseAmount = (info == NULL ? 0 : info->m_iExtraTerrainDefensePercent);

	if (!isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander != NULL)
			return iBaseAmount + pCommander->getExtraTerrainDefensePercent(eIndex);
	}
	return iBaseAmount;
}


void CvUnit::changeExtraTerrainDefensePercent(TerrainTypes eIndex, int iChange)
{
	FASSERT_BOUNDS(0, GC.getNumTerrainInfos(), eIndex);

	if (iChange != 0)
	{
		TerrainKeyedInfo* info = findOrCreateTerrainKeyedInfo(eIndex);

		info->m_iExtraTerrainDefensePercent += iChange;

		setInfoBarDirty(true);
	}
}

int CvUnit::getExtraFeatureAttackPercent(FeatureTypes eIndex) const
{
	FASSERT_BOUNDS(0, GC.getNumFeatureInfos(), eIndex);

	const FeatureKeyedInfo* info = findFeatureKeyedInfo(eIndex);

	const int iBaseAmount = (info == NULL ? 0 : info->m_iExtraFeatureAttackPercent);

	if (!isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander != NULL)
			return iBaseAmount + pCommander->getExtraFeatureAttackPercent(eIndex);
	}
	return iBaseAmount;
}


void CvUnit::changeExtraFeatureAttackPercent(FeatureTypes eIndex, int iChange)
{
	FASSERT_BOUNDS(0, GC.getNumFeatureInfos(), eIndex);

	if (iChange != 0)
	{
		FeatureKeyedInfo* info = findOrCreateFeatureKeyedInfo(eIndex);

		info->m_iExtraFeatureAttackPercent += iChange;

		setInfoBarDirty(true);
	}
}

int CvUnit::getExtraFeatureDefensePercent(FeatureTypes eIndex) const
{
	if (noDefensiveBonus())
	{
		return 0;
	}
	FASSERT_BOUNDS(0, GC.getNumFeatureInfos(), eIndex);

	const FeatureKeyedInfo* info = findFeatureKeyedInfo(eIndex);

	const int iBaseAmount = (info == NULL ? 0 : info->m_iExtraFeatureDefensePercent);

	if (!isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander != NULL)
			return iBaseAmount + pCommander->getExtraFeatureDefensePercent(eIndex);
	}
	return iBaseAmount;
}


void CvUnit::changeExtraFeatureDefensePercent(FeatureTypes eIndex, int iChange)
{
	FASSERT_BOUNDS(0, GC.getNumFeatureInfos(), eIndex);

	if (iChange != 0)
	{
		FeatureKeyedInfo* info = findOrCreateFeatureKeyedInfo(eIndex);

		info->m_iExtraFeatureDefensePercent += iChange;

		setInfoBarDirty(true);
	}
}

int CvUnit::getExtraUnitCombatModifier(UnitCombatTypes eIndex) const
{
	FASSERT_BOUNDS(0, GC.getNumUnitCombatInfos(), eIndex);

	const UnitCombatKeyedInfo* info = findUnitCombatKeyedInfo(eIndex);

	const int iBaseAmount = (info == NULL ? 0 : info->m_iExtraUnitCombatModifier);

	if (!isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander != NULL)
			return iBaseAmount + pCommander->getExtraUnitCombatModifier(eIndex);
	}
	return iBaseAmount;
}


void CvUnit::changeExtraUnitCombatModifier(UnitCombatTypes eIndex, int iChange)
{
	FASSERT_BOUNDS(0, GC.getNumUnitCombatInfos(), eIndex);

	if (iChange != 0)
	{
		UnitCombatKeyedInfo* info = findOrCreateUnitCombatKeyedInfo(eIndex);

		info->m_iExtraUnitCombatModifier += iChange;
	}
}

bool CvUnit::canAcquirePromotion(PromotionTypes ePromotion, PromotionRequirements::flags requirements) const
{
	return canAcquirePromotion(ePromotion,
		requirements & PromotionRequirements::IgnoreHas,
		requirements & PromotionRequirements::Equip,
		requirements & PromotionRequirements::Afflict,
		requirements & PromotionRequirements::ForLeader,
		requirements & PromotionRequirements::ForOffset,
		requirements & PromotionRequirements::ForFree,
		requirements & PromotionRequirements::ForBuildUp,
		requirements & PromotionRequirements::ForStatus
	);
}

bool CvUnit::canAcquirePromotion(PromotionTypes ePromotion, bool bIgnoreHas, bool bEquip, bool bAfflict, bool bForLeader, bool bForOffset, bool bForFree, bool bForBuildUp, bool bForStatus) const
{
	PROFILE_FUNC();

	FASSERT_BOUNDS(NO_PROMOTION, GC.getNumPromotionInfos(), ePromotion);

	if (ePromotion == NO_PROMOTION || !bIgnoreHas && isHasPromotion(ePromotion))
	{
		return false;
	}

	const CvPromotionInfo& promo = GC.getPromotionInfo(ePromotion);

	if (!bForStatus && promo.isStatus())
	{
		return false;
	}

	if (promo.getStateReligionPrereq() != NO_RELIGION && GET_PLAYER(getOwner()).getStateReligion() != promo.getStateReligionPrereq())
	{
		return false;
	}

	if (!isPromotionValid(ePromotion, bForFree))
	{
		return false;
	}

	//TB Combat Mod begin
	if (!bEquip && promo.isEquipment())
	{
		return false;
	}

#ifdef OUTBREAKS_AND_AFFLICTIONS
	if (!bAfflict && promo.isAffliction())
	{
		return false;
	}
#endif // OUTBREAKS_AND_AFFLICTIONS

	//TB Debug Note: If the promotion being evaluated for is the sort you get from a leader as it attaches to the unit that then qualifies you for other
	//promotions, and the check being called here is not for that specific purpose, then return false for that promotion.
	if (!bForLeader && promo.isLeader())
	{
		return false;
	}

	if (!bForOffset && promo.isForOffset())
	{
		return false;
	}

	if (promo.getObsoleteTech() != NO_TECH && GET_TEAM(getTeam()).isHasTech(promo.getObsoleteTech()))
	{
		return false;
	}

	//Units without a primary unitcombat are unable to be assigned promos
	if (getUnitCombatType() == NO_UNITCOMBAT)
	{
		return false;
	}

	if (promo.getReplacesUnitCombat() != NO_UNITCOMBAT && !isHasUnitCombat(promo.getReplacesUnitCombat()))
	{
		return false;
	}

	if (getLevel() < promo.getLevelPrereq() && !bForOffset)
	{
		return false;
	}
	if (promo.isRBombardPrereq() && !canRBombard(true))
	{
		return false;
	}
	const CvPlot* pPlot = plot();
	if (!isMapCategory(*pPlot, promo) || !isMapCategory(*m_pUnitInfo, promo))
	{
		return false;
	}
	//TB Combat Mods Begin
	if (!bForFree || bForBuildUp)
	{
		const PromotionTypes ePromotionPrerequisite = (PromotionTypes)promo.getPrereqPromotion();

		if (ePromotionPrerequisite != NO_PROMOTION && !isHasPromotion(ePromotionPrerequisite))
		{
			return false;
		}
		const PromotionTypes ePromotionPrerequisite1 = (PromotionTypes)promo.getPrereqOrPromotion1();
		const PromotionTypes ePromotionPrerequisite2 = (PromotionTypes)promo.getPrereqOrPromotion2();

		if ((ePromotionPrerequisite1 != NO_PROMOTION || ePromotionPrerequisite2 != NO_PROMOTION)
		&&  (ePromotionPrerequisite1 == NO_PROMOTION || !isHasPromotion(ePromotionPrerequisite1))
		&&  (ePromotionPrerequisite2 == NO_PROMOTION || !isHasPromotion(ePromotionPrerequisite2)))
		{
			return false;
		}
	}

	if (promo.isEquipment())
	{
		if (!pPlot->isCity(false, getTeam()))
		{
			//TB will be replacing this when units can carry and transport equipments without owning them as promos
			return false;
		}
		const CvCity* pCity = pPlot->getPlotCity();

		foreach_(const BonusTypes ePrereqBonus, promo.getPrereqBonuses())
		{
			if (ePrereqBonus != NO_BONUS && !pCity->hasBonus(ePrereqBonus))
			{
				return false;
			}
		}
	}

	{
		const int iMinEraInt = promo.getMinEraType();
		const int iMaxEraInt = promo.getMaxEraType();
		if (iMinEraInt > NO_ERA || iMaxEraInt > NO_ERA)
		{
			for (int iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
			{
				if (isHasUnitCombat((UnitCombatTypes)iI) && GC.getUnitCombatInfo((UnitCombatTypes)iI).getEra() != NO_ERA)
				{
					const int iEra = (int)GC.getUnitCombatInfo((UnitCombatTypes)iI).getEra();
					if (
						iMinEraInt > NO_ERA && iMinEraInt > iEra
					||	iMaxEraInt > NO_ERA && iMaxEraInt < iEra
					) return false;

					break;
				}
			}
		}
	}

	for (int iI = 0; iI < promo.getNumSubCombatChangeTypes(); iI++)
	{
		//If we have the unitcombat the promotion will give us already
		if (isHasUnitCombat((UnitCombatTypes)promo.getSubCombatChangeType(iI)))
		{
			return false;
		}
	}
	const PromotionLineTypes ePromotionLine = promo.getPromotionLine();

	if (bForBuildUp && (ePromotionLine == NO_PROMOTIONLINE || !GC.getPromotionLineInfo(ePromotionLine).isBuildUp())
	|| !bForBuildUp && ePromotionLine != NO_PROMOTIONLINE && GC.getPromotionLineInfo(ePromotionLine).isBuildUp())
	{
		return false;
	}

	if (
		promo.isNotOnDomainType((int)getDomainType())
	||
		ePromotionLine != NO_PROMOTIONLINE
	&&	GC.getPromotionLineInfo(ePromotionLine).isNotOnDomainType((int)getDomainType())
	) return false;

	// Afflictions and equipment promotions that are part of a line can only be acquired
	//	if you don't already have a higher priority one from the same line, since each line can only
	//	have one specific present at a time (and higher priority takes precedence)
	if (ePromotionLine != NO_PROMOTIONLINE
		&& (
#ifdef OUTBREAKS_AND_AFFLICTIONS
			promo.isAffliction() ||
#endif // OUTBREAKS_AND_AFFLICTIONS
			promo.isEquipment()))
	{
		for (int iI = 0; iI < GC.getNumPromotionInfos(); iI++)
		{
			if (GC.getPromotionInfo((PromotionTypes)iI).getPromotionLine() == ePromotionLine && isHasPromotion((PromotionTypes)iI)
			&& GC.getPromotionInfo((PromotionTypes)iI).getLinePriority() > promo.getLinePriority())
			{
				return false;
			}
		}
	}
	//TB SubCombat Mod End

	// Must have the next less promotionline priority unless this is an affliction, equipment, or BuildUp or Status.
	if (ePromotionLine != NO_PROMOTIONLINE && !bAfflict && !bEquip && !promo.isCritical() && !bForBuildUp && !bForStatus && promo.getLinePriority() > 1)
	{
		const CvPromotionLineInfo& promoLine = GC.getPromotionLineInfo(ePromotionLine);
		const int numPromotions = promoLine.getNumPromotions();
		for (int iJ = 0; iJ < numPromotions; iJ++)
		{
			const PromotionTypes ePrereq = (PromotionTypes)promoLine.getPromotion(iJ);
			if (GC.getPromotionInfo(ePrereq).getLinePriority() == promo.getLinePriority() - 1 && !isHasPromotion(ePrereq))
			{
				return false;
			}
		}
	}
	// For Statuses, you can only have one promotion in the line but iLinePriority is not necessarily a hierarchy, just an index in the line.
	//	However, you can set multiple promos with the same iLinePriority that cannot be swapped out for each other.
	if (bForStatus)
	{
		bool bPrereqFound = ePromotionLine == NO_PROMOTIONLINE || promo.getLinePriority() != 1;

		if (!bPrereqFound)
		{
			const int numPromotionInfos = GC.getNumPromotionInfos();
			for (int iI = 0; iI < numPromotionInfos; iI++)
			{
				const PromotionTypes ePrereq = (PromotionTypes)iI;
				if (isHasPromotion(ePrereq))
				{
					const CvPromotionInfo& kPrereqPromotion = GC.getPromotionInfo(ePrereq);
					if (kPrereqPromotion.getPromotionLine() == ePromotionLine)
					{
						if (kPrereqPromotion.getLinePriority() == promo.getLinePriority())
						{
							return false;
						}
						if (promo.getLinePriority() == 1)
						{
							// This establishes all Status Promos with an iLinePriority of 1 as being the status that erases any of the statuses.
							bPrereqFound = true;
							break;
						}
					}
				}
			}
		}
		if (!bPrereqFound)
		{
			return false;
		}
	}
	//TB Combat Mod end


	if (isHuman() && GC.getGame().isOption(GAMEOPTION_SIZE_MATTERS))
	{
		if (
			promo.getSMSpecialCargoPrereq() != NO_SPECIALUNIT
		&&	promo.getSMSpecialCargoPrereq() != getSMSpecialCargo()
		||
			promo.getSMNotSpecialCargoPrereq() != NO_SPECIALUNIT
		&&	promo.getSMNotSpecialCargoPrereq() != SMnotSpecialCargo()
		||
			promo.isCargoPrereq() && SMcargoSpace() < 1
		) return false;
	}
	else if (
		promo.getSpecialCargoPrereq() != NO_SPECIALUNIT
	&&	promo.getSpecialCargoPrereq() != getSpecialCargo()
	||	promo.isCargoPrereq() && cargoSpace() < 1
	) return false;

	if (!bForFree)
	{
		if (promo.getTechPrereq() != NO_TECH && !GET_TEAM(getTeam()).isHasTech(promo.getTechPrereq()))
		{
			return false;
		}
		if (ePromotionLine != NO_PROMOTIONLINE
		&&
			GC.getPromotionLineInfo(ePromotionLine).getPrereqTech() != NO_TECH
		&&
			!GET_TEAM(getTeam()).isHasTech(GC.getPromotionLineInfo(ePromotionLine).getPrereqTech()))
		{
			return false;
		}
	}

	bool bValid = true;

	for (int iI = 0; iI < promo.getNumPrereqTerrainTypes(); iI++)
	{
		const TerrainTypes ePrereqTerrain = (TerrainTypes)promo.getPrereqTerrainType(iI);

		if (ePrereqTerrain != NO_TERRAIN)
		{
			bValid = false;

			if (ePrereqTerrain == GC.getTERRAIN_PEAK())
			{
				if (plot()->isAsPeak())
				{
					bValid = true;
					break;
				}
			}
			else if (ePrereqTerrain == GC.getTERRAIN_HILL())
			{
				if (plot()->isHills())
				{
					bValid = true;
					break;
				}
			}
			else if (ePrereqTerrain == plot()->getTerrainType())
			{
				bValid = true;
				break;
			}
		}
	}
	if (!bValid)
	{
		return false;
	}

	for (int iI = 0; iI < promo.getNumPrereqFeatureTypes(); iI++)
	{
		const FeatureTypes ePrereqFeature = (FeatureTypes)promo.getPrereqFeatureType(iI);

		if (ePrereqFeature != NO_FEATURE)
		{
			bValid = false;
			if (plot()->getFeatureType() == ePrereqFeature)
			{
				bValid = true;
				break;
			}
		}
	}
	if (!bValid)
	{
		return false;
	}

	// Improvements and buildings is an OR statement between all of them.
	{
		bool bFirst = true;

		for (int iI = 0; iI < promo.getNumPrereqImprovementTypes(); iI++)
		{
			ImprovementTypes ePrereqImprovement = (ImprovementTypes)promo.getPrereqImprovementType(iI);
			if (ePrereqImprovement != NO_IMPROVEMENT)
			{
				bFirst = false;
				bValid = false;
				if (plot()->isCity(true) && ePrereqImprovement == GC.getIMPROVEMENT_CITY())
				{
					bValid = true;
					break;
				}
				if (plot()->getImprovementType() == ePrereqImprovement)
				{
					bValid = true;
					break;
				}
			}
		}
		if (bFirst || !bValid)
		{
			const int iNumPrereqLocalBuilding = promo.getNumPrereqLocalBuildingTypes();
			if (iNumPrereqLocalBuilding > 0)
			{
				bValid = false;
				for (int iI = 0; iI < iNumPrereqLocalBuilding; iI++)
				{
					if (plot()->isCity(false)

					&& pPlot->getPlotCity()->getNumActiveBuilding((BuildingTypes)promo.getPrereqLocalBuildingType(iI)) > 0)
					{
						bValid = true;
						break;
					}
				}
			}
		}
	}
	if (!bValid)
	{
		return false;
	}

	for (int iI = 0; iI < promo.getNumPrereqPlotBonusTypes(); iI++)
	{
		const BonusTypes ePrereqBonus = (BonusTypes)promo.getPrereqPlotBonusType(iI);

		if (ePrereqBonus != NO_BONUS)
		{
			bValid = false;
			if (plot()->getBonusType(getTeam()) == ePrereqBonus)
			{
				bValid = true;
				break;
			}
		}
	}
	if (!bValid)
	{
		return false;
	}

	if (promo.isPrereqNormInvisible() && !hasInvisibleAbility())
	{
		return false;
	}

	if (!bForOffset && promo.getQualityChange() > 0 && getRetrainsAvailable() > 0)
	{
		return false;
	}

	return true;
}

bool CvUnit::isPromotionValid(PromotionTypes ePromotion, bool bFree, bool bKeepCheck) const
{
	const CvPromotionInfo& promo = GC.getPromotionInfo(ePromotion);

	if (!bKeepCheck) // If the unit got the promo then these checks have already passed.
	{
		if (m_pUnitInfo->isSpy() && !GC.isSS_ENABLED())
		{
			return false;
		}

		//Disable via NotOnGameOption tag:
		for (int iI = 0; iI < promo.getNumNotOnGameOptions(); iI++)
		{
			if (GC.getGame().isOption((GameOptionTypes)promo.getNotOnGameOption(iI)))
			{
				return false;
			}
		}
		for (int iI = 0; iI < promo.getNumOnGameOptions(); iI++)
		{
			if (!GC.getGame().isOption((GameOptionTypes)promo.getOnGameOption(iI)))
			{
				return false;
			}
		}
		if (promo.getPromotionLine() != NO_PROMOTIONLINE)
		{
			for (int iI = 0; iI < GC.getPromotionLineInfo(promo.getPromotionLine()).getNumNotOnGameOptions(); iI++)
			{
				if (GC.getGame().isOption((GameOptionTypes)GC.getPromotionLineInfo(promo.getPromotionLine()).getNotOnGameOption(iI)))
				{
					return false;
				}
			}
			for (int iI = 0; iI < GC.getPromotionLineInfo(promo.getPromotionLine()).getNumNotOnGameOptions(); iI++)
			{
				if (!GC.getGame().isOption((GameOptionTypes)GC.getPromotionLineInfo(promo.getPromotionLine()).getNotOnGameOption(iI)))
				{
					return false;
				}
			}
		}
	}
	// Very few reasons to deny a unit promotions that are specifically set to be a free for it.
	if (m_pUnitInfo->getFreePromotions(ePromotion) || GET_PLAYER(getOwner()).isFreePromotion(getUnitType(), ePromotion))
	{
		return true;
	}

	if (m_pUnitInfo->getUnitCombatType() == NO_UNITCOMBAT)
	{
		return false;
	}
	if (promo.getObsoleteTech() != NO_TECH && GET_TEAM(getTeam()).isHasTech(promo.getObsoleteTech()))
	{
		return false;
	}
	if (!bFree)
	{
		if (promo.getTechPrereq() != NO_TECH && !GET_TEAM(getTeam()).isHasTech(promo.getTechPrereq()))
		{
			return false;
		}
		const PromotionLineTypes ePromotionLine = promo.getPromotionLine();

		if (ePromotionLine != NO_PROMOTIONLINE
		&& GC.getPromotionLineInfo(ePromotionLine).getPrereqTech() != NO_TECH
		&& !GET_TEAM(getTeam()).isHasTech(GC.getPromotionLineInfo(ePromotionLine).getPrereqTech()))
		{
			return false;
		}
	}
	{
		// Toffer - Promotionline is factored in for the (dis)qualified caches.
		for (int iI = 0; iI < promo.getNumDisqualifiedUnitCombatTypes(); iI++)
		{
			if (isHasUnitCombat((UnitCombatTypes)promo.getDisqualifiedUnitCombatType(iI)))
			{
				return false;
			}
		}
		// TB SubCombat Mod Begin
		// The two solid ways to identify a Size Matters promotion that would not normally have a CC prereq.
		// Note: Apparently having no CC prereq is a clear way to isolate promotions to only being assigned directly by event or other special injection.
		// Thus it was necessary to pass the Size Matters promos despite having no particular CC prereq.
		if (!promo.isForOffset() && !promo.isZeroesXP())
		{
			bool bValid = false;

			for (int iI = promo.getNumQualifiedUnitCombatTypes() - 1; iI > -1; iI--)
			{
				if (isHasUnitCombat((UnitCombatTypes)promo.getQualifiedUnitCombatType(iI)))
				{
					bValid = true;
					break;
				}
			}
			if (!bValid)
			{
				return false;
			}
		}
	}

	if (isSpy())
	{
		return true;
	}

	//Disable Looter Promos for units that cannot pillage
	if (promo.getPillageChange() > 0 && !m_pUnitInfo->isPillage())
	{
		return false;
	}

	if (isCommander() && (promo.getGroupChange() != 0 || promo.getQualityChange() != 0))
	{
		return false;
	}

	if (isBlendIntoCity() && promo.getCityDefensePercent() != 0)
	{
		return false;
	}

	if (!bKeepCheck)
	{
		if (promo.getInterceptChange() + maxInterceptionProbability(true) > GC.getDefineINT("MAX_INTERCEPTION_PROBABILITY")
		||	promo.getEvasionChange() + evasionProbability(true) > GC.getDefineINT("MAX_EVASION_PROBABILITY")
		||	promo.getQualityChange() > 0 && getExperience() >= experienceNeeded(1))
		{
			return false;
		}
	}

	return true;
}


bool CvUnit::canAcquirePromotionAny() const
{
	//TB Debug note: I had not originally considered how this was really only to be used for determination of the unit being able to access any
	//skill based promos only.  This is here to check if any skill promos are left that can be accessed right now and my previous considerations
	//to include the potential to receive equipments and afflictions will now be disincluded from this routine to avoid screwing up the entire purpose
	//of this function.  A check through reveals I never utilize this function in the processing of those features anyhow and it is only used for
	//its original purpose of making sure the unit still has something it can select when taking a skill-based promo.

	for (int iI = GC.getNumPromotionInfos() - 1; iI > -1; iI--)
	{
		const PromotionTypes ePromotion = static_cast<PromotionTypes>(iI);

		PromotionRequirements::flags promoFlags = PromotionRequirements::Promote;

		if (GC.getPromotionInfo(ePromotion).isLeader())
		{
			promoFlags |= PromotionRequirements::ForLeader;
		}
		if (canAcquirePromotion(ePromotion, promoFlags))
		{
			return true;
		}
	}
	return false;
}

PromotionKeyedInfo*	CvUnit::findOrCreatePromotionKeyedInfo(PromotionTypes ePromotion, bool bCreate)
{
	PROFILE_FUNC();

	std::map<PromotionTypes, PromotionKeyedInfo>::iterator itr = m_promotionKeyedInfo.find(ePromotion);

	if (itr != m_promotionKeyedInfo.end())
	{
		return &(itr->second);
	}

	if (bCreate)
	{
		PromotionKeyedInfo newInfo;

		return &(m_promotionKeyedInfo.insert(std::make_pair(ePromotion, newInfo)).first->second);
	}

	return NULL;
}

const PromotionKeyedInfo* CvUnit::findPromotionKeyedInfo(PromotionTypes ePromotion) const
{
	std::map<PromotionTypes, PromotionKeyedInfo>::const_iterator itr = m_promotionKeyedInfo.find(ePromotion);

	if (itr == m_promotionKeyedInfo.end())
	{
		return NULL;
	}

	if (m_promotionKeyedInfo.size() > 32 && itr->second.Empty())
	{
		m_promotionKeyedInfo.erase(itr->first); // Alberts2 - Erase empty elemnts to save memory
		return NULL;
	}

	return &(itr->second);
}

PromotionIterator CvUnit::getPromotionBegin()
{
	return m_promotionKeyedInfo.begin();
}

PromotionIterator CvUnit::getPromotionEnd()
{
	return m_promotionKeyedInfo.end();
}

PromotionLineKeyedInfo* CvUnit::findOrCreatePromotionLineKeyedInfo(PromotionLineTypes ePromotionLine, bool bCreate)
{
	std::map<PromotionLineTypes, PromotionLineKeyedInfo>::iterator itr = m_promotionLineKeyedInfo.find(ePromotionLine);

	if (itr != m_promotionLineKeyedInfo.end())
	{
		return &(itr->second);
	}

	if (bCreate)
	{
		PromotionLineKeyedInfo newInfo;

		return &(m_promotionLineKeyedInfo.insert(std::make_pair(ePromotionLine, newInfo)).first->second);
	}

	return NULL;
}

const PromotionLineKeyedInfo* CvUnit::findPromotionLineKeyedInfo(PromotionLineTypes ePromotionLine) const
{
	std::map<PromotionLineTypes, PromotionLineKeyedInfo>::const_iterator itr = m_promotionLineKeyedInfo.find(ePromotionLine);

	if (itr == m_promotionLineKeyedInfo.end())
	{
		return NULL;
	}

	if (m_promotionLineKeyedInfo.size() > 16 && itr->second.Empty())
	{
		m_promotionLineKeyedInfo.erase(itr->first); // Alberts2 - Erase empty elemnts to save memory
		return NULL;
	}

	return &(itr->second);
}

std::map<PromotionLineTypes, PromotionLineKeyedInfo>& CvUnit::getPromotionLineKeyedInfo() const
{
	return m_promotionLineKeyedInfo;
}

TerrainKeyedInfo* CvUnit::findOrCreateTerrainKeyedInfo(TerrainTypes eTerrain, bool bCreate)
{
	std::map<TerrainTypes, TerrainKeyedInfo>::iterator itr = m_terrainKeyedInfo.find(eTerrain);

	if (itr != m_terrainKeyedInfo.end())
	{
		return &(itr->second);
	}

	if (bCreate)
	{
		TerrainKeyedInfo newInfo;

		return &(m_terrainKeyedInfo.insert(std::make_pair(eTerrain, newInfo)).first->second);
	}

	return NULL;
}

const TerrainKeyedInfo*	CvUnit::findTerrainKeyedInfo(TerrainTypes eTerrain) const
{
	std::map<TerrainTypes, TerrainKeyedInfo>::const_iterator itr = m_terrainKeyedInfo.find(eTerrain);

	if (itr == m_terrainKeyedInfo.end())
	{
		return NULL;
	}
	if (m_terrainKeyedInfo.size() > 16 && itr->second.Empty())
	{
		m_terrainKeyedInfo.erase(itr->first); // Alberts2 - Erase empty elemnts to save memory
		return NULL;
	}
	return &(itr->second);
}

FeatureKeyedInfo* CvUnit::findOrCreateFeatureKeyedInfo(FeatureTypes eFeature, bool bCreate)
{
	std::map<FeatureTypes, FeatureKeyedInfo>::iterator itr = m_featureKeyedInfo.find(eFeature);

	if (itr != m_featureKeyedInfo.end())
	{
		return &(itr->second);
	}

	if (bCreate)
	{
		FeatureKeyedInfo newInfo;

		return &(m_featureKeyedInfo.insert(std::make_pair(eFeature, newInfo)).first->second);
	}

	return NULL;
}

const FeatureKeyedInfo* CvUnit::findFeatureKeyedInfo(FeatureTypes eFeature) const
{
	std::map<FeatureTypes, FeatureKeyedInfo>::const_iterator itr = m_featureKeyedInfo.find(eFeature);

	if (itr == m_featureKeyedInfo.end())
	{
		return NULL;
	}
	if (m_featureKeyedInfo.size() > 16 && itr->second.Empty())
	{
		m_featureKeyedInfo.erase(itr->first); // Alberts2 - Erase empty elemnts to save memory
		return NULL;
	}
	return &(itr->second);
}

UnitCombatKeyedInfo* CvUnit::findOrCreateUnitCombatKeyedInfo(UnitCombatTypes eUnitCombat, bool bCreate)
{
	std::map<UnitCombatTypes, UnitCombatKeyedInfo>::iterator itr = m_unitCombatKeyedInfo.find(eUnitCombat);

	if (itr != m_unitCombatKeyedInfo.end())
	{
		return &(itr->second);
	}

	if (bCreate)
	{
		UnitCombatKeyedInfo	newInfo;

		return &(m_unitCombatKeyedInfo.insert(std::make_pair(eUnitCombat, newInfo)).first->second);
	}

	return NULL;
}

const UnitCombatKeyedInfo* CvUnit::findUnitCombatKeyedInfo(UnitCombatTypes eUnitCombat) const
{
	std::map<UnitCombatTypes, UnitCombatKeyedInfo>::const_iterator itr = m_unitCombatKeyedInfo.find(eUnitCombat);

	if (itr == m_unitCombatKeyedInfo.end())
	{
		return NULL;
	}
	if (m_unitCombatKeyedInfo.size() > 32 && itr->second.Empty())
	{
		m_unitCombatKeyedInfo.erase(itr->first); // Alberts2 - Erase empty elemnts to save memory
		return NULL;
	}
	return &(itr->second);
}

std::map<UnitCombatTypes, UnitCombatKeyedInfo>& CvUnit::getUnitCombatKeyedInfo() const
{
	return m_unitCombatKeyedInfo;
}

bool CvUnit::isHealsUnitCombat(UnitCombatTypes eIndex) const
{
	FASSERT_BOUNDS(NO_UNITCOMBAT, GC.getNumUnitCombatInfos(), eIndex);
	const UnitCombatKeyedInfo* info = findUnitCombatKeyedInfo(eIndex);

	return (info != NULL && (info->m_iHealUnitCombatTypeVolume > 0));
}

bool CvUnit::isHasUnitCombat(UnitCombatTypes eIndex) const
{
	FASSERT_BOUNDS(NO_UNITCOMBAT, GC.getNumUnitCombatInfos(), eIndex);
	const UnitCombatKeyedInfo* info = findUnitCombatKeyedInfo(eIndex);

	return (info != NULL && info->m_bHasUnitCombat);
}

void CvUnit::processUnitCombat(UnitCombatTypes eIndex, bool bAdding, bool bByPromo)
{
	const CvUnitCombatInfo& kUnitCombat = GC.getUnitCombatInfo(eIndex);
	const int iChange = (bAdding ? 1 : -1);
	int	iI;

	bool bSM = GC.getGame().isOption(GAMEOPTION_SIZE_MATTERS);

	if (bSM)
	{
		if (!bByPromo)
		{
			if (kUnitCombat.getQualityBase() > -10)
			{
				setQualityBaseTotal(kUnitCombat.getQualityBase());
			}
			if (kUnitCombat.getSizeBase() > -10)
			{
				setSizeBaseTotal(kUnitCombat.getSizeBase());
			}
			if (kUnitCombat.getGroupBase() > -10)
			{
				setGroupBaseTotal(kUnitCombat.getGroupBase());
			}
		}
		if (bAdding && kUnitCombat.getGroupBase() > -10)
		{
			calcUpkeepMultiplierSM(kUnitCombat.getGroupBase() - getGroupBaseTotal());
		}
	}

	changeExtraVisibilityRange(kUnitCombat.getVisibilityChange() * iChange);//no merge/split diff
	changeExtraMoves(kUnitCombat.getMovesChange() * iChange);//no merge/split diff
	changeExtraMoveDiscount(kUnitCombat.getMoveDiscountChange() * iChange);//no merge/split diff
	changeExtraAirRange(kUnitCombat.getAirRangeChange() * iChange);//no merge/split diff
	changeExtraIntercept(kUnitCombat.getInterceptChange() * iChange);//no merge/split diff
	changeExtraEvasion(kUnitCombat.getEvasionChange() * iChange);//no merge/split diff
	if (isAnimal())
	{
		if (GC.getGame().isOption(GAMEOPTION_FIGHT_OR_FLIGHT))
		{
			changeExtraWithdrawal(kUnitCombat.getWithdrawalChange() * iChange);//no merge/split diff
		}
	}
	else
	{
		changeExtraWithdrawal(kUnitCombat.getWithdrawalChange() * iChange);//no merge/split diff
	}
	changeCargoSpace(kUnitCombat.getCargoChange() * iChange);//no merge/split diff (since this mechanism is either a base setter or is for non-SM or non-player on SM.

	changeSMCargoSpace(kUnitCombat.getSMCargoChange() * iChange);//merge/split volumetric
	changeCargoVolume(kUnitCombat.getSMCargoVolumeChange() * iChange);//merge/split volumetric
	changeCargoVolumeModifier(kUnitCombat.getSMCargoVolumeModifierChange() * iChange);//merge/split volumetric

	changeExtraCollateralDamage(kUnitCombat.getCollateralDamageChange() * iChange);//I suspect no merge/split
	changeExtraBombardRate(kUnitCombat.getBombardRateChange() * iChange);//no merge/split (affect this volumetrically on the final value)
	changeExtraFirstStrikes(kUnitCombat.getFirstStrikesChange() * iChange);//no merge/split
	changeExtraChanceFirstStrikes(kUnitCombat.getChanceFirstStrikesChange() * iChange);//no merge/split
	changeExtraEnemyHeal(kUnitCombat.getEnemyHealChange() * iChange);//no merge/split (modified but not multiplicative)
	changeExtraNeutralHeal(kUnitCombat.getNeutralHealChange() * iChange);//no merge/split (modified but not multiplicative)
	changeExtraFriendlyHeal(kUnitCombat.getFriendlyHealChange() * iChange);//no merge/split (modified but not multiplicative)
	changeSameTileHeal(kUnitCombat.getSameTileHealChange() * iChange);//no merge/split (modified but not multiplicative)
	changeAdjacentTileHeal(kUnitCombat.getAdjacentTileHealChange() * iChange);//no merge/split (modified but not multiplicative)
	changeExtraCombatPercent(kUnitCombat.getCombatPercent() * iChange);//no merge/split
	changeExtraCityAttackPercent(kUnitCombat.getCityAttackPercent() * iChange);//no merge/split
	changeExtraCityDefensePercent(kUnitCombat.getCityDefensePercent() * iChange);//no merge/split
	changeExtraHillsAttackPercent(kUnitCombat.getHillsAttackPercent() * iChange);//no merge/split
	changeExtraHillsDefensePercent(kUnitCombat.getHillsDefensePercent() * iChange);//no merge/split
	// Assume only worker units can get the relevant unit combats, if not then we'll need a retroactive unitComp late init function.
	if (isWorker())
	{
		bool bChanged = false;
		if (kUnitCombat.getHillsWorkPercent() != 0)
		{
			m_worker->changeHillsWorkModifier(kUnitCombat.getHillsWorkPercent() * iChange);
			bChanged = true;
		}
		if (kUnitCombat.getPeaksWorkPercent() != 0)
		{
			m_worker->changePeaksWorkModifier(kUnitCombat.getPeaksWorkPercent() * iChange);
			bChanged = true;
		}
		if (kUnitCombat.getWorkRatePercent() != 0)
		{
			m_worker->changeWorkModifier(kUnitCombat.getWorkRatePercent() * iChange);
			bChanged = true;
		}
		for (int iI = 0; iI < kUnitCombat.getNumBuildWorkChangeModifiers(); iI++)
		{
			m_worker->changeExtraWorkModForBuild((BuildTypes)kUnitCombat.getBuildWorkChangeModifier(iI).eBuild, kUnitCombat.getBuildWorkChangeModifier(iI).iModifier * iChange);
			bChanged = true;
		}
		if (bChanged) setInfoBarDirty(true);
	}
	changeRevoltProtection(kUnitCombat.getRevoltProtection() * iChange);// merge/split
	changeCollateralDamageProtection(kUnitCombat.getCollateralDamageProtection() * iChange);//no merge/split
	changePillageChange(kUnitCombat.getPillageChange() * iChange);//no merge/split
	changeUpgradeDiscount(kUnitCombat.getUpgradeDiscount() * iChange);//no merge/split (modified but not multiplicative)
	changeExperiencePercent(kUnitCombat.getExperiencePercent() * iChange);//no merge/split (modified but not multiplicative)
	changeKamikazePercent((kUnitCombat.getKamikazePercent()) * iChange);//no merge/split
	changeAirCombatLimitChange((kUnitCombat.getAirCombatLimitChange()) * iChange);//no merge/split
	changeCelebrityHappy((kUnitCombat.getCelebrityHappy()) * iChange);//no merge/split
	changeCollateralDamageLimitChange((kUnitCombat.getCollateralDamageLimitChange()) * iChange);//no merge/split
	changeCollateralDamageMaxUnitsChange((kUnitCombat.getCollateralDamageMaxUnitsChange()) * iChange);//no merge/split
	changeCombatLimitChange((kUnitCombat.getCombatLimitChange()) * iChange);//no merge/split
	changeExtraDropRange((kUnitCombat.getExtraDropRange()) * iChange);//no merge/split
	changeExtraNoDefensiveBonusCount((kUnitCombat.getNoDefensiveBonusChange()) * iChange);
	changeExtraGatherHerdCount((kUnitCombat.getGatherHerdChange()) * iChange);
	changeSurvivorChance((kUnitCombat.getSurvivorChance()) * iChange);//no merge/split
	changeVictoryAdjacentHeal((kUnitCombat.getVictoryAdjacentHeal()) * iChange);//no merge/split
	changeVictoryHeal((kUnitCombat.getVictoryHeal()) * iChange);//no merge/split
	changeVictoryStackHeal((kUnitCombat.getVictoryStackHeal()) * iChange);//no merge/split
	changeExtraAttackCombatModifier(kUnitCombat.getAttackCombatModifierChange() * iChange);//no merge/split
	changeExtraDefenseCombatModifier(kUnitCombat.getDefenseCombatModifierChange() * iChange);//no merge/split
	changeExtraPursuit(kUnitCombat.getPursuitChange() * iChange);//no merge/split
	changeExtraEarlyWithdraw(kUnitCombat.getEarlyWithdrawChange() * iChange);//no merge/split
	changeExtraVSBarbs(kUnitCombat.getVSBarbsChange() * iChange);//no merge/split
	changeExtraReligiousCombatModifier(kUnitCombat.getReligiousCombatModifierChange() * iChange);//no merge/split
	changeExtraArmor(kUnitCombat.getArmorChange() * iChange);//no merge/split
	changeExtraPuncture(kUnitCombat.getPunctureChange() * iChange);//no merge/split
	changeExtraDamageModifier(kUnitCombat.getDamageModifierChange() * iChange);//no merge/split
	changeExtraOverrun(kUnitCombat.getOverrunChange() * iChange);//no merge/split
	changeExtraRepel(kUnitCombat.getRepelChange() * iChange);//no merge/split
	changeExtraFortRepel(kUnitCombat.getFortRepelChange() * iChange);//no merge/split
	changeExtraRepelRetries(kUnitCombat.getRepelRetriesChange() * iChange);//no merge/split
	changeExtraUnyielding(kUnitCombat.getUnyieldingChange() * iChange);//no merge/split
	changeExtraKnockback(kUnitCombat.getKnockbackChange() * iChange);//no merge/split
	changeExtraKnockbackRetries(kUnitCombat.getKnockbackRetriesChange() * iChange);//no merge/split
#ifdef BATTLEWORN
	changeExtraStrAdjperAtt(kUnitCombat.getStrAdjperAttChange() * iChange);//no merge/split
	changeExtraStrAdjperDef(kUnitCombat.getStrAdjperDefChange() * iChange);//no merge/split
	changeExtraWithdrawAdjperAtt(kUnitCombat.getWithdrawAdjperAttChange() * iChange);//no merge/split
#endif // BATTLEWORN
	changeExtraUnnerve(kUnitCombat.getUnnerveChange() * iChange);//no merge/split
	changeExtraEnclose(kUnitCombat.getEncloseChange() * iChange);//no merge/split
	changeExtraLunge(kUnitCombat.getLungeChange() * iChange);//no merge/split
	changeExtraDynamicDefense(kUnitCombat.getDynamicDefenseChange() * iChange);//no merge/split
	changeExtraStrength(kUnitCombat.getStrengthChange() * iChange);//no merge/split (but included into merge/split mult)
	changeExtraFortitude(kUnitCombat.getFortitudeChange() * iChange);//no merge/split
#ifdef OUTBREAKS_AND_AFFLICTIONS
	for (iI = 0; iI < GC.getNumPropertyInfos(); iI++)
	{
		changeExtraAidChange((PropertyTypes)iI, kUnitCombat.getAidChange(iI) * iChange);//no merge/split
	}
#endif
#ifdef STRENGTH_IN_NUMBERS
	changeExtraFrontSupportPercent(kUnitCombat.getFrontSupportPercentChange() * iChange);//no merge/split
	changeExtraShortRangeSupportPercent(kUnitCombat.getShortRangeSupportPercentChange() * iChange);//no merge/split
	changeExtraMediumRangeSupportPercent(kUnitCombat.getMediumRangeSupportPercentChange() * iChange);//no merge/split
	changeExtraLongRangeSupportPercent(kUnitCombat.getLongRangeSupportPercentChange() * iChange);//no merge/split
	changeExtraFlankSupportPercent(kUnitCombat.getFlankSupportPercentChange() * iChange);//no merge/split
#endif // STRENGTH_IN_NUMBERS

	changeExtraDodgeModifier(kUnitCombat.getDodgeModifierChange() * iChange);//no merge/split
	changeExtraPrecisionModifier(kUnitCombat.getPrecisionModifierChange() * iChange);//no merge/split
	changeExtraPowerShots(kUnitCombat.getPowerShotsChange() * iChange);//no merge/split
	changeExtraPowerShotCombatModifier(kUnitCombat.getPowerShotCombatModifierChange() * iChange);//no merge/split
	changeExtraPowerShotPunctureModifier(kUnitCombat.getPowerShotPunctureModifierChange() * iChange);//no merge/split
	changeExtraPowerShotPrecisionModifier(kUnitCombat.getPowerShotPrecisionModifierChange() * iChange);//no merge/split
	changeExtraPowerShotCriticalModifier(kUnitCombat.getPowerShotCriticalModifierChange() * iChange);//no merge/split
	changeExtraCriticalModifier(kUnitCombat.getCriticalModifierChange() * iChange);//no merge/split
	changeExtraEndurance(kUnitCombat.getEnduranceChange() * iChange);//no merge/split
	changeExtraRoundStunProb(kUnitCombat.getRoundStunProbChange() * iChange);//no merge/split
	changeExtraPoisonProbabilityModifier(kUnitCombat.getPoisonProbabilityModifierChange() * iChange);//no merge/split
	changeExtraCaptureProbabilityModifier(kUnitCombat.getCaptureProbabilityModifierChange() * iChange);//no merge/split
	changeExtraCaptureResistanceModifier(kUnitCombat.getCaptureResistanceModifierChange() * iChange);//no merge/split

	changeExtraBreakdownChance(kUnitCombat.getBreakdownChanceChange() * iChange);//no merge/split (larger/smaller just more/less survivable)
	changeExtraBreakdownDamage(kUnitCombat.getBreakdownDamageChange() * iChange);//no merge/split
	changeExtraTaunt(kUnitCombat.getTauntChange() * iChange);//no merge/split
	changeExtraMaxHP(kUnitCombat.getMaxHPChange() * iChange);//merge/split
	changeExtraStrengthModifier(kUnitCombat.getStrengthModifier() * iChange);//merge/split

	changeExtraCombatModifierPerSizeMore(kUnitCombat.getCombatModifierPerSizeMoreChange() * iChange);//no merge/split
	changeExtraCombatModifierPerSizeLess(kUnitCombat.getCombatModifierPerSizeLessChange() * iChange);//no merge/split
	changeExtraCombatModifierPerVolumeMore(kUnitCombat.getCombatModifierPerVolumeMoreChange() * iChange);//no merge/split
	changeExtraCombatModifierPerVolumeLess(kUnitCombat.getCombatModifierPerVolumeLessChange() * iChange);//no merge/split
	//
	changeExcileCount(kUnitCombat.getExcileChange() * iChange);
	changePassageCount(kUnitCombat.getPassageChange() * iChange);
	changeNoNonOwnedCityEntryCount(kUnitCombat.getNoNonOwnedCityEntryChange() * iChange);
	changeBarbCoExistCount(kUnitCombat.getBarbCoExistChange() * iChange);
	changeBlendIntoCityCount(kUnitCombat.getBlendIntoCityChange() * iChange);
	//
	changeBaseRBombardDamage(kUnitCombat.getRBombardDamageBase() * iChange, bAdding, eIndex);//no merge/split
	changeBaseRBombardDamageLimit(kUnitCombat.getRBombardDamageLimitBase() * iChange, bAdding, eIndex);//no merge/split
	changeBaseRBombardDamageMaxUnits(kUnitCombat.getRBombardDamageMaxUnitsBase() * iChange, bAdding, eIndex);//no merge/split
	changeBaseDCMBombRange(kUnitCombat.getDCMBombRangeBase() * iChange, bAdding, eIndex);//no merge/split
	changeBaseDCMBombAccuracy(kUnitCombat.getDCMBombAccuracyBase() * iChange, bAdding, eIndex);//no merge/split
	changeBombardDirectCount((kUnitCombat.isRBombardDirect()) ? iChange : 0);
	//

	//booleans //no merge/split
	changeDefensiveVictoryMoveCount((kUnitCombat.isDefensiveVictoryMove()) ? iChange : 0);//no merge/split
	changeFreeDropCount((kUnitCombat.isFreeDrop()) ? iChange : 0);//no merge/split
	changeOffensiveVictoryMoveCount((kUnitCombat.isOffensiveVictoryMove()) ? iChange : 0);//no merge/split
	changeOneUpCount((kUnitCombat.isOneUp()) ? iChange : 0);//no merge/split
	changePillageEspionageCount((kUnitCombat.isPillageEspionage()) ? iChange : 0);//no merge/split
	changePillageMarauderCount((kUnitCombat.isPillageMarauder()) ? iChange : 0);//no merge/split
	changePillageOnMoveCount((kUnitCombat.isPillageOnMove()) ? iChange : 0);//no merge/split
	changePillageOnVictoryCount((kUnitCombat.isPillageOnVictory()) ? iChange : 0);//no merge/split
	changePillageResearchCount((kUnitCombat.isPillageResearch()) ? iChange : 0);//no merge/split
	changeBlitzCount((kUnitCombat.isBlitz()) ? iChange : 0);//no merge/split
	changeAmphibCount((kUnitCombat.isAmphib()) ? iChange : 0);//no merge/split
	changeRiverCount((kUnitCombat.isRiver()) ? iChange : 0);//no merge/split
	changeEnemyRouteCount((kUnitCombat.isEnemyRoute()) ? iChange : 0);//no merge/split
	changeAlwaysHealCount((kUnitCombat.isAlwaysHeal()) ? iChange : 0);
	changeHillsDoubleMoveCount((kUnitCombat.isHillsDoubleMove()) ? iChange : 0);
	changeImmuneToFirstStrikesCount((kUnitCombat.isImmuneToFirstStrikes()) ? iChange : 0);
	changeAlwaysInvisibleCount((kUnitCombat.isAlwaysInvisible()) ? iChange : 0);
	changeStampedeCount((kUnitCombat.isStampedeChange()) ? iChange : 0);
	changeStampedeCount((kUnitCombat.isRemoveStampede()) ? -iChange : 0);
	changeAnimalIgnoresBordersCount(kUnitCombat.getAnimalIgnoresBordersChange() * iChange);
	changeOnslaughtCount((kUnitCombat.isOnslaughtChange()) ? iChange : 0);
	changeDealColdDamageCount((kUnitCombat.isMakesDamageCold()) ? iChange : 0);
	changeDealColdDamageCount((kUnitCombat.isMakesDamageNotCold()) ? -iChange : 0);
	changeColdImmuneCount((kUnitCombat.isAddsColdImmunity()) ? iChange : 0);
	changeColdImmuneCount((kUnitCombat.isRemovesColdImmunity()) ? -iChange : 0);
	changeAttackOnlyCitiesCount((kUnitCombat.isAttackOnlyCitiesAdd()) ? iChange : 0);
	changeAttackOnlyCitiesCount((kUnitCombat.isAttackOnlyCitiesSubtract()) ? -iChange : 0);
	changeIgnoreNoEntryLevelCount((kUnitCombat.isIgnoreNoEntryLevelAdd()) ? iChange : 0);
	changeIgnoreNoEntryLevelCount((kUnitCombat.isIgnoreNoEntryLevelSubtract()) ? -iChange : 0);
	changeIgnoreZoneofControlCount((kUnitCombat.isIgnoreZoneofControlAdd()) ? iChange : 0);
	changeIgnoreZoneofControlCount((kUnitCombat.isIgnoreZoneofControlSubtract()) ? -iChange : 0);
	changeFliesToMoveCount((kUnitCombat.isFliesToMoveAdd()) ? iChange : 0);
	changeFliesToMoveCount((kUnitCombat.isFliesToMoveSubtract()) ? -iChange : 0);
	if ( kUnitCombat.changesMoveThroughPlots() )
	{
		m_movementCharacteristicsHash ^= kUnitCombat.getZobristValue();
		m_iMaxMoveCacheTurn = -1;
	}
	changeCanMovePeaksCount((kUnitCombat.isCanMovePeaks()) ? iChange : 0);
	changeCanLeadThroughPeaksCount((kUnitCombat.isCanLeadThroughPeaks()) ? iChange : 0);
	changeZoneOfControlCount((kUnitCombat.isZoneOfControl()) ? iChange : 0);
	changeCannotMergeSplitCount((kUnitCombat.isCannotMergeSplit()) ? iChange : 0);
	changeRBombardForceAbilityCount((kUnitCombat.isRBombardForceAbility()) ? iChange : 0);
	changeNoSelfHealCount((kUnitCombat.isNoSelfHeal()) ? iChange : 0);
	changeExtraSelfHealModifier(kUnitCombat.getSelfHealModifier() * iChange);
	changeExtraNumHealSupport(kUnitCombat.getNumHealSupport() * iChange);
	changeExtraInsidiousness(kUnitCombat.getInsidiousnessChange() * iChange);
	changeExtraInvestigation(kUnitCombat.getInvestigationChange() * iChange);
	changeExtraStealthStrikes(kUnitCombat.getStealthStrikesChange() * iChange);
	changeExtraStealthCombatModifier(kUnitCombat.getStealthCombatModifierChange() * iChange);
	changeStealthDefenseCount(kUnitCombat.getStealthDefenseChange() * iChange);
	changeOnlyDefensiveCount(kUnitCombat.getDefenseOnlyChange() * iChange);
	changeNoInvisibilityCount(kUnitCombat.getNoInvisibilityChange() * iChange);
	changeNoCaptureCount(kUnitCombat.getNoCaptureChange() * iChange);

	// Arrays
	if (kUnitCombat.isAnyDomainModifierPercent())
	{
		for (iI = 0; iI < NUM_DOMAIN_TYPES; iI++)
		{
			changeExtraDomainModifier(((DomainTypes)iI), (kUnitCombat.getDomainModifierPercent(iI) * iChange));
		}
	}

#ifdef OUTBREAKS_AND_AFFLICTIONS
	// bool vector with delayed resolution
	if (GC.getGame().isOption(GAMEOPTION_OUTBREAKS_AND_AFFLICTIONS))
	{
		for (iI = 0; iI < kUnitCombat.getNumCureAfflictionChangeTypes(); iI++)
		{
			changeCureAfflictionCount(((PromotionLineTypes)kUnitCombat.getCureAfflictionChangeType(iI)), iChange);
		}
		for (iI = 0; iI < kUnitCombat.getNumAfflictionFortitudeChangeModifiers(); iI++)
		{
			changeFortitudeModifierTypeAmount(((PromotionLineTypes)kUnitCombat.getAfflictionFortitudeChangeModifier(iI).ePromotionLine), kUnitCombat.getAfflictionFortitudeChangeModifier(iI).iModifier * iChange);
		}
	}
#endif // OUTBREAKS_AND_AFFLICTIONS

	for (iI = 0; iI < kUnitCombat.getNumTerrainIgnoreDamageChangeTypes(); iI++)
	{
		changeTerrainProtected(((TerrainTypes)kUnitCombat.getTerrainIgnoreDamageChangeType(iI)), iChange);
	}

	for (iI = 0; iI < kUnitCombat.getNumTerrainDoubleMoveChangeTypes(); iI++)
	{
		changeTerrainDoubleMoveCount(((TerrainTypes)kUnitCombat.getTerrainDoubleMoveChangeType(iI)), iChange);
	}

	for (iI = 0; iI < kUnitCombat.getNumFeatureDoubleMoveChangeTypes(); iI++)
	{
		changeFeatureDoubleMoveCount(((FeatureTypes)kUnitCombat.getFeatureDoubleMoveChangeType(iI)), iChange);
	}

	for (iI = 0; iI < kUnitCombat.getNumTrapImmunityUnitCombatTypes(); iI++)
	{
		changeTrapImmunityUnitCombatCount((UnitCombatTypes)kUnitCombat.getTrapImmunityUnitCombatType(iI), iChange);
	}

#ifdef OUTBREAKS_AND_AFFLICTIONS
	for (iI = 0; iI < kUnitCombat.getNumDistanceAttackCommunicabilityTypeChanges(); iI++)
	{
		changeDistanceAttackCommunicability((PromotionLineTypes)kUnitCombat.getDistanceAttackCommunicabilityTypeChange(iI).eAfflictionLine, kUnitCombat.getDistanceAttackCommunicabilityTypeChange(iI).iChange * iChange);
	}
#endif
	// int vector utilizing pairing without delayed resolution
	for (iI = 0; iI < GC.getNumTerrainInfos(); iI++)
	{
		changeExtraWithdrawOnTerrainType(((TerrainTypes)iI), (kUnitCombat.getWithdrawOnTerrainTypeChange(iI) * iChange));
	}

	for (iI = 0; iI < GC.getNumFeatureInfos(); iI++)
	{
		changeExtraWithdrawOnFeatureType(((FeatureTypes)iI), (kUnitCombat.getWithdrawOnFeatureTypeChange(iI) * iChange));
	}

	for (iI = 0; iI < GC.getNumInvisibleInfos(); iI++)
	{
		changeExtraVisibilityIntensityType(((InvisibleTypes)iI), (kUnitCombat.getVisibilityIntensityChangeType(iI) * iChange));
		changeExtraInvisibilityIntensityType(((InvisibleTypes)iI), (kUnitCombat.getInvisibilityIntensityChangeType(iI) * iChange));
		changeExtraVisibilityIntensityRangeType(((InvisibleTypes)iI), (kUnitCombat.getVisibilityIntensityRangeChangeType(iI) * iChange));
		changeExtraVisibilityIntensitySameTileType(((InvisibleTypes)iI), (kUnitCombat.getVisibilityIntensitySameTileChangeType(iI) * iChange));
	}

	for (iI = 0; iI < kUnitCombat.getNumInvisibleTerrainChanges(); iI++)
	{
		changeExtraInvisibleTerrain((InvisibleTypes)kUnitCombat.getInvisibleTerrainChange(iI).eInvisible,(TerrainTypes)kUnitCombat.getInvisibleTerrainChange(iI).eTerrain, kUnitCombat.getInvisibleTerrainChange(iI).iIntensity * iChange);
	}

	for (iI = 0; iI < kUnitCombat.getNumInvisibleFeatureChanges(); iI++)
	{
		changeExtraInvisibleFeature((InvisibleTypes)kUnitCombat.getInvisibleFeatureChange(iI).eInvisible,(FeatureTypes)kUnitCombat.getInvisibleFeatureChange(iI).eFeature, kUnitCombat.getInvisibleFeatureChange(iI).iIntensity * iChange);
	}

	for (iI = 0; iI < kUnitCombat.getNumInvisibleImprovementChanges(); iI++)
	{
		changeExtraInvisibleImprovement((InvisibleTypes)kUnitCombat.getInvisibleImprovementChange(iI).eInvisible,(ImprovementTypes)kUnitCombat.getInvisibleImprovementChange(iI).eImprovement, kUnitCombat.getInvisibleImprovementChange(iI).iIntensity * iChange);
	}

	for (iI = 0; iI < kUnitCombat.getNumVisibleTerrainChanges(); iI++)
	{
		changeExtraVisibleTerrain((InvisibleTypes)kUnitCombat.getVisibleTerrainChange(iI).eInvisible,(TerrainTypes)kUnitCombat.getVisibleTerrainChange(iI).eTerrain, kUnitCombat.getVisibleTerrainChange(iI).iIntensity * iChange);
	}

	for (iI = 0; iI < kUnitCombat.getNumVisibleFeatureChanges(); iI++)
	{
		changeExtraVisibleFeature((InvisibleTypes)kUnitCombat.getVisibleFeatureChange(iI).eInvisible,(FeatureTypes)kUnitCombat.getVisibleFeatureChange(iI).eFeature, kUnitCombat.getVisibleFeatureChange(iI).iIntensity * iChange);
	}

	for (iI = 0; iI < kUnitCombat.getNumVisibleImprovementChanges(); iI++)
	{
		changeExtraVisibleImprovement((InvisibleTypes)kUnitCombat.getVisibleImprovementChange(iI).eInvisible,(ImprovementTypes)kUnitCombat.getVisibleImprovementChange(iI).eImprovement, kUnitCombat.getVisibleImprovementChange(iI).iIntensity * iChange);
	}

	for (iI = 0; iI < kUnitCombat.getNumVisibleTerrainRangeChanges(); iI++)
	{
		changeExtraVisibleTerrainRange((InvisibleTypes)kUnitCombat.getVisibleTerrainRangeChange(iI).eInvisible,(TerrainTypes)kUnitCombat.getVisibleTerrainRangeChange(iI).eTerrain, kUnitCombat.getVisibleTerrainRangeChange(iI).iIntensity * iChange);
	}

	for (iI = 0; iI < kUnitCombat.getNumVisibleFeatureRangeChanges(); iI++)
	{
		changeExtraVisibleFeatureRange((InvisibleTypes)kUnitCombat.getVisibleFeatureRangeChange(iI).eInvisible,(FeatureTypes)kUnitCombat.getVisibleFeatureRangeChange(iI).eFeature, kUnitCombat.getVisibleFeatureRangeChange(iI).iIntensity * iChange);
	}

	for (iI = 0; iI < kUnitCombat.getNumVisibleImprovementRangeChanges(); iI++)
	{
		changeExtraVisibleImprovementRange((InvisibleTypes)kUnitCombat.getVisibleImprovementRangeChange(iI).eInvisible,(ImprovementTypes)kUnitCombat.getVisibleImprovementRangeChange(iI).eImprovement, kUnitCombat.getVisibleImprovementRangeChange(iI).iIntensity * iChange);
	}

	// int vector utilizing struct with delayed resolution
	for (iI = 0; iI < kUnitCombat.getNumTerrainAttackChangeModifiers(); iI++)
	{
		changeExtraTerrainAttackPercent(((TerrainTypes)kUnitCombat.getTerrainAttackChangeModifier(iI).eTerrain), kUnitCombat.getTerrainAttackChangeModifier(iI).iModifier * iChange);
	}

	for (iI = 0; iI < kUnitCombat.getNumTerrainDefenseChangeModifiers(); iI++)
	{
		changeExtraTerrainDefensePercent(((TerrainTypes)kUnitCombat.getTerrainDefenseChangeModifier(iI).eTerrain), kUnitCombat.getTerrainDefenseChangeModifier(iI).iModifier * iChange);
	}

	for (iI = 0; iI < kUnitCombat.getNumTerrainWorkChangeModifiers(); iI++)
	{
		changeExtraTerrainWorkPercent(((TerrainTypes)kUnitCombat.getTerrainWorkChangeModifier(iI).eTerrain), kUnitCombat.getTerrainWorkChangeModifier(iI).iModifier * iChange);
	}

	for (iI = 0; iI < kUnitCombat.getNumFeatureAttackChangeModifiers(); iI++)
	{
		changeExtraFeatureAttackPercent(((FeatureTypes)kUnitCombat.getFeatureAttackChangeModifier(iI).eFeature), kUnitCombat.getFeatureAttackChangeModifier(iI).iModifier * iChange);
	}

	for (iI = 0; iI < kUnitCombat.getNumFeatureDefenseChangeModifiers(); iI++)
	{
		changeExtraFeatureDefensePercent(((FeatureTypes)kUnitCombat.getFeatureDefenseChangeModifier(iI).eFeature), kUnitCombat.getFeatureDefenseChangeModifier(iI).iModifier * iChange);
	}

	for (iI = 0; iI < kUnitCombat.getNumFeatureWorkChangeModifiers(); iI++)
	{
		changeExtraFeatureWorkPercent(((FeatureTypes)kUnitCombat.getFeatureWorkChangeModifier(iI).eFeature), kUnitCombat.getFeatureWorkChangeModifier(iI).iModifier * iChange);
	}

	for (iI = 0; iI < kUnitCombat.getNumUnitCombatChangeModifiers(); iI++)
	{
		changeExtraUnitCombatModifier(((UnitCombatTypes)kUnitCombat.getUnitCombatChangeModifier(iI).eUnitCombat), kUnitCombat.getUnitCombatChangeModifier(iI).iModifier * iChange);
	}

	for (iI = 0; iI < kUnitCombat.getNumFlankingStrengthbyUnitCombatTypesChange(); iI++)
	{
		changeExtraFlankingStrengthbyUnitCombatType(((UnitCombatTypes)kUnitCombat.getFlankingStrengthbyUnitCombatTypeChange(iI).eUnitCombat), kUnitCombat.getFlankingStrengthbyUnitCombatTypeChange(iI).iModifier * iChange);
	}

	for (iI = 0; iI < kUnitCombat.getNumWithdrawVSUnitCombatTypesChange(); iI++)
	{
		changeExtraWithdrawVSUnitCombatType(((UnitCombatTypes)kUnitCombat.getWithdrawVSUnitCombatTypeChange(iI).eUnitCombat), kUnitCombat.getWithdrawVSUnitCombatTypeChange(iI).iModifier * iChange);
	}

	if (GC.getGame().isOption(GAMEOPTION_FIGHT_OR_FLIGHT))
	{
		for (iI = 0; iI < kUnitCombat.getNumPursuitVSUnitCombatTypesChange(); iI++)
		{
			changeExtraPursuitVSUnitCombatType(((UnitCombatTypes)kUnitCombat.getPursuitVSUnitCombatTypeChange(iI).eUnitCombat), kUnitCombat.getPursuitVSUnitCombatTypeChange(iI).iModifier * iChange);
		}
	}

	if (GC.getGame().isOption(GAMEOPTION_HEART_OF_WAR))
	{
		for (iI = 0; iI < kUnitCombat.getNumRepelVSUnitCombatTypesChange(); iI++)
		{
			changeExtraRepelVSUnitCombatType(((UnitCombatTypes)kUnitCombat.getRepelVSUnitCombatTypeChange(iI).eUnitCombat), kUnitCombat.getRepelVSUnitCombatTypeChange(iI).iModifier * iChange);
		}

		for (iI = 0; iI < kUnitCombat.getNumKnockbackVSUnitCombatTypesChange(); iI++)
		{
			changeExtraKnockbackVSUnitCombatType(((UnitCombatTypes)kUnitCombat.getKnockbackVSUnitCombatTypeChange(iI).eUnitCombat), kUnitCombat.getKnockbackVSUnitCombatTypeChange(iI).iModifier * iChange);
		}
	}

	for (iI = 0; iI < kUnitCombat.getNumPunctureVSUnitCombatTypesChange(); iI++)
	{
		changeExtraPunctureVSUnitCombatType(((UnitCombatTypes)kUnitCombat.getPunctureVSUnitCombatTypeChange(iI).eUnitCombat), kUnitCombat.getPunctureVSUnitCombatTypeChange(iI).iModifier * iChange);
	}

	for (iI = 0; iI < kUnitCombat.getNumArmorVSUnitCombatTypesChange(); iI++)
	{
		changeExtraArmorVSUnitCombatType(((UnitCombatTypes)kUnitCombat.getArmorVSUnitCombatTypeChange(iI).eUnitCombat), kUnitCombat.getArmorVSUnitCombatTypeChange(iI).iModifier * iChange);
	}

	for (iI = 0; iI < kUnitCombat.getNumDodgeVSUnitCombatTypesChange(); iI++)
	{
		changeExtraDodgeVSUnitCombatType(((UnitCombatTypes)kUnitCombat.getDodgeVSUnitCombatTypeChange(iI).eUnitCombat), kUnitCombat.getDodgeVSUnitCombatTypeChange(iI).iModifier * iChange);
	}

	for (iI = 0; iI < kUnitCombat.getNumPrecisionVSUnitCombatTypesChange(); iI++)
	{
		changeExtraPrecisionVSUnitCombatType(((UnitCombatTypes)kUnitCombat.getPrecisionVSUnitCombatTypeChange(iI).eUnitCombat), kUnitCombat.getPrecisionVSUnitCombatTypeChange(iI).iModifier * iChange);
	}

	for (iI = 0; iI < kUnitCombat.getNumCriticalVSUnitCombatTypesChange(); iI++)
	{
		changeExtraCriticalVSUnitCombatType(((UnitCombatTypes)kUnitCombat.getCriticalVSUnitCombatTypeChange(iI).eUnitCombat), kUnitCombat.getCriticalVSUnitCombatTypeChange(iI).iModifier * iChange);
	}

	for (iI = 0; iI < kUnitCombat.getNumRoundStunVSUnitCombatTypesChange(); iI++)
	{
		changeExtraRoundStunVSUnitCombatType(((UnitCombatTypes)kUnitCombat.getRoundStunVSUnitCombatTypeChange(iI).eUnitCombat), kUnitCombat.getRoundStunVSUnitCombatTypeChange(iI).iModifier * iChange);
	}

	for (iI = 0; iI < kUnitCombat.getNumTrapAvoidanceUnitCombatTypes(); iI++)
	{
		changeExtraTrapAvoidanceUnitCombatType(((UnitCombatTypes)kUnitCombat.getTrapAvoidanceUnitCombatType(iI).eUnitCombat), kUnitCombat.getTrapAvoidanceUnitCombatType(iI).iModifier * iChange);
	}

#ifdef OUTBREAKS_AND_AFFLICTIONS
	for (iI = 0; iI < kUnitCombat.getNumAfflictOnAttackChangeTypes(); iI++)
	{
		changeAfflictOnAttackTypeCount(((PromotionLineTypes)kUnitCombat.getAfflictOnAttackChangeType(iI).eAfflictionLine), iChange);
		changeAfflictOnAttackTypeProbability(((PromotionLineTypes)kUnitCombat.getAfflictOnAttackChangeType(iI).eAfflictionLine), kUnitCombat.getAfflictOnAttackChangeType(iI).iProbabilityChange * iChange);
		changeAfflictOnAttackTypeMeleeCount(((PromotionLineTypes)kUnitCombat.getAfflictOnAttackChangeType(iI).eAfflictionLine), kUnitCombat.getAfflictOnAttackChangeType(iI).iMelee * iChange);
		changeAfflictOnAttackTypeDistanceCount(((PromotionLineTypes)kUnitCombat.getAfflictOnAttackChangeType(iI).eAfflictionLine), kUnitCombat.getAfflictOnAttackChangeType(iI).iDistance * iChange);
		changeAfflictOnAttackTypeImmediateCount(((PromotionLineTypes)kUnitCombat.getAfflictOnAttackChangeType(iI).eAfflictionLine), kUnitCombat.getAfflictOnAttackChangeType(iI).iImmediate * iChange);
	}
#endif
	if (bSM && bByPromo)
	{
		setSMValues();
	}

	if (kUnitCombat.getReligion() != NO_RELIGION)
	{
		defineReligion();
	}

	changeExtraUpkeep100(kUnitCombat.getExtraUpkeep100() * iChange);
	changeUpkeepModifier(kUnitCombat.getUpkeepModifier() * iChange);

	establishBuildups();

	if (bByPromo)
	{
		setGGExperienceEarnedTowardsType();
	}
}

void CvUnit::setHasUnitCombat(UnitCombatTypes eIndex, bool bNewValue, bool bByPromo)
{
	PROFILE_FUNC();

	if (isHasUnitCombat(eIndex) != bNewValue)
	{
		const CvUnitCombatInfo& info = GC.getUnitCombatInfo(eIndex);

		if (GC.getGame().isValidByGameOption(info)
		// Disable spy promotions mechanism, exempt commando promotion
		&& (!isSpy() || GC.isSS_ENABLED() || info.isEnemyRoute()))
		{
			UnitCombatKeyedInfo* infoKeyed =
			(
				bNewValue
				?
				findOrCreateUnitCombatKeyedInfo(eIndex)
				:
				(UnitCombatKeyedInfo*)findUnitCombatKeyedInfo(eIndex)
			);

			if (infoKeyed != NULL)
			{
				infoKeyed->m_bHasUnitCombat = bNewValue;
			}
			processUnitCombat(eIndex, bNewValue, bByPromo);

			AI_flushValueCache();

			//	Updates the grpahics last after everything is calculated
			//  Not entirely sure this will be necessary?  Koshling what say you?
			if (IsSelected())
			{
				gDLL->getInterfaceIFace()->setDirty(SelectionButtons_DIRTY_BIT, true);
				gDLL->getInterfaceIFace()->setDirty(InfoPane_DIRTY_BIT, true);
			}

			//update graphics
			if (!isUsingDummyEntities() && isInViewport())
			{
				gDLL->getEntityIFace()->updatePromotionLayers(getUnitEntity());
			}
		}
		setHealUnitCombatCount();
	}
}

bool CvUnit::isHasPromotion(PromotionTypes eIndex) const
{
	FASSERT_BOUNDS(NO_PROMOTION, GC.getNumPromotionInfos(), eIndex);
	const PromotionKeyedInfo* info = findPromotionKeyedInfo(eIndex);

	return (info != NULL && info->m_bHasPromotion);
}

void CvUnit::processPromotion(PromotionTypes eIndex, bool bAdding, bool bInitial)
{
	const CvPromotionInfo& kPromotion = GC.getPromotionInfo(eIndex);
	const int iChange = (bAdding ? 1 : -1);
	int	iI;
	bool bSMrecalc = false;

#ifdef OUTBREAKS_AND_AFFLICTIONS
	//	On affliction removal get rid of the accrued per-turn detrimental effects
	if (kPromotion.isAffliction() && !bAdding)
	{
		// Make sure we don't remove or reset these counts if we're taking away lesser versions of worsening afflictions
		PromotionLineTypes eAfflictionLine = kPromotion.getPromotionLine();
		if (kPromotion.getLinePriority() > getAfflictionLineCount(eAfflictionLine))
		{
			removeAfflictionHits(eIndex);
			setAfflictionHitCount(eIndex, 0);
		}
	}
#endif

	if (kPromotion.isParalyze() && bAdding)
	{
		setImmobileTimer(1);
	}

	if ( kPromotion.changesMoveThroughPlots() )
	{
		m_movementCharacteristicsHash ^= kPromotion.getZobristValue();
		m_iMaxMoveCacheTurn = -1;
	}

	CvWString szNullValue;
	CvWString szNewValue = kPromotion.getRenamesUnitTo();
	if (szNewValue != szNullValue)
	{
		setName(szNewValue);
	}

	if (kPromotion.getDomainCargoChange() != NO_DOMAIN)
	{
		if (bAdding)
		{
			setNewDomainCargo(kPromotion.getDomainCargoChange());
		}
		else
		{
			setNewDomainCargo(NO_DOMAIN);
		}
	}
	if (kPromotion.getSpecialCargoChange() != NO_SPECIALUNIT)
	{
		if (bAdding)
		{
			setNewSpecialCargo(kPromotion.getSpecialCargoChange());
		}
		else
		{
			setNewSpecialCargo(NO_SPECIALUNIT);
		}
	}
	if (kPromotion.getSMSpecialCargoChange() != NO_SPECIALUNIT)
	{
		if (bAdding)
		{
			setNewSMSpecialCargo(kPromotion.getSMSpecialCargoChange());
		}
		else
		{
			setNewSMSpecialCargo(NO_SPECIALUNIT);
		}
	}
	if (kPromotion.getSMNotSpecialCargoChange() != NO_SPECIALUNIT)
	{
		if (bAdding)
		{
			setNewSMNotSpecialCargo(kPromotion.getSMNotSpecialCargoChange());
		}
		else
		{
			setNewSMNotSpecialCargo(NO_SPECIALUNIT);
		}
	}

	for (iI = 0; iI < kPromotion.getNumAddsBuildTypes(); iI++)
	{
		changeExtraBuildType(bAdding, (BuildTypes)kPromotion.getAddsBuildType(iI));
	}

	changeBlitzCount((kPromotion.isBlitz()) ? iChange : 0);
	changeAmphibCount((kPromotion.isAmphib()) ? iChange : 0);
	changeRiverCount((kPromotion.isRiver()) ? iChange : 0);
	changeEnemyRouteCount((kPromotion.isEnemyRoute()) ? iChange : 0);
	changeAlwaysHealCount((kPromotion.isAlwaysHeal()) ? iChange : 0);
	changeHillsDoubleMoveCount((kPromotion.isHillsDoubleMove()) ? iChange : 0);

	changeCanMovePeaksCount((kPromotion.isCanMovePeaks()) ? iChange : 0);
	//	Koshling - enhanced mountaineering mode to differentiate between ability to move through
	//	mountains, and ability to lead a stack through mountains
	changeCanLeadThroughPeaksCount((kPromotion.isCanLeadThroughPeaks()) ? iChange : 0);

	// Toffer - Assume promotions with commander stats can only be gained by commanders.
	//	If assumption is wrong, we'll need setCommander(true) to go through all promotions the unit has,
	//	and apply commander specific stats at that point.
	if (isCommander())
	{
		m_commander->changeControlPoints(kPromotion.getControlPoints() * iChange);
		m_commander->changeCommandRange(kPromotion.getCommandRange() * iChange);
	}

	changeImmuneToFirstStrikesCount((kPromotion.isImmuneToFirstStrikes()) ? iChange : 0);

	changeDefensiveVictoryMoveCount((kPromotion.isDefensiveVictoryMove()) ? iChange : 0);
	changeFreeDropCount((kPromotion.isFreeDrop()) ? iChange : 0);
	changeOffensiveVictoryMoveCount((kPromotion.isOffensiveVictoryMove()) ? iChange : 0);

	changeOneUpCount((kPromotion.isOneUp()) ? iChange : 0);
	changePillageEspionageCount((kPromotion.isPillageEspionage()) ? iChange : 0);
	changePillageMarauderCount((kPromotion.isPillageMarauder()) ? iChange : 0);
	changePillageOnMoveCount((kPromotion.isPillageOnMove()) ? iChange : 0);
	changePillageOnVictoryCount((kPromotion.isPillageOnVictory()) ? iChange : 0);
	changePillageResearchCount((kPromotion.isPillageResearch()) ? iChange : 0);
	changeAirCombatLimitChange((kPromotion.getAirCombatLimitChange()) * iChange);
	changeCelebrityHappy((kPromotion.getCelebrityHappy()) * iChange);
	changeCollateralDamageLimitChange((kPromotion.getCollateralDamageLimitChange()) * iChange);
	changeCollateralDamageMaxUnitsChange((kPromotion.getCollateralDamageMaxUnitsChange()) * iChange);
	changeCombatLimitChange((kPromotion.getCombatLimitChange()) * iChange);
	changeExtraDropRange((kPromotion.getExtraDropRange()) * iChange);
	changeExtraNoDefensiveBonusCount((kPromotion.getNoDefensiveBonusChange()) * iChange);
	changeExtraGatherHerdCount((kPromotion.getGatherHerdChange()) * iChange);

	changeSurvivorChance((kPromotion.getSurvivorChance()) * iChange);
	changeVictoryAdjacentHeal((kPromotion.getVictoryAdjacentHeal()) * iChange);
	changeVictoryHeal((kPromotion.getVictoryHeal()) * iChange);
	changeVictoryStackHeal((kPromotion.getVictoryStackHeal()) * iChange);

	changeExtraVisibilityRange(kPromotion.getVisibilityChange() * iChange);
	changeExtraMoves(kPromotion.getMovesChange() * iChange);
	changeExtraMoveDiscount(kPromotion.getMoveDiscountChange() * iChange);
	changeExtraAirRange(kPromotion.getAirRangeChange() * iChange);
	changeExtraIntercept(kPromotion.getInterceptChange() * iChange);
	changeExtraEvasion(kPromotion.getEvasionChange() * iChange);
	changeExtraFirstStrikes(kPromotion.getFirstStrikesChange() * iChange);
	changeExtraChanceFirstStrikes(kPromotion.getChanceFirstStrikesChange() * iChange);
	changeExtraWithdrawal(kPromotion.getWithdrawalChange() * iChange);
	//TB Combat Mods Begin
	changeExtraAttackCombatModifier(kPromotion.getAttackCombatModifierChange() * iChange);
	changeExtraDefenseCombatModifier(kPromotion.getDefenseCombatModifierChange() * iChange);
	changeExtraPursuit(kPromotion.getPursuitChange() * iChange);
	changeExtraEarlyWithdraw(kPromotion.getEarlyWithdrawChange() * iChange);
	changeExtraVSBarbs(kPromotion.getVSBarbsChange() * iChange);
	changeExtraReligiousCombatModifier(kPromotion.getReligiousCombatModifierChange() * iChange);
	changeExtraArmor(kPromotion.getArmorChange() * iChange);
	changeExtraPuncture(kPromotion.getPunctureChange() * iChange);
	changeExtraDamageModifier(kPromotion.getDamageModifierChange() * iChange);

	changeExtraUpkeep100(kPromotion.getExtraUpkeep100() * iChange);
	changeUpkeepModifier(kPromotion.getUpkeepModifier() * iChange);

	changeExtraOverrun(kPromotion.getOverrunChange() * iChange);
	changeExtraRepel(kPromotion.getRepelChange() * iChange);
	changeExtraFortRepel(kPromotion.getFortRepelChange() * iChange);
	changeExtraRepelRetries(kPromotion.getRepelRetriesChange() * iChange);
	changeExtraUnyielding(kPromotion.getUnyieldingChange() * iChange);
	changeExtraKnockback(kPromotion.getKnockbackChange() * iChange);
	changeExtraKnockbackRetries(kPromotion.getKnockbackRetriesChange() * iChange);
	changeStampedeCount((kPromotion.isStampedeChange()) ? iChange : 0);
	changeStampedeCount((kPromotion.isRemoveStampede()) ? -iChange : 0);
	changeAttackOnlyCitiesCount((kPromotion.isAttackOnlyCitiesAdd()) ? iChange : 0);
	changeAttackOnlyCitiesCount((kPromotion.isAttackOnlyCitiesSubtract()) ? -iChange : 0);
	changeIgnoreNoEntryLevelCount((kPromotion.isIgnoreNoEntryLevelAdd()) ? iChange : 0);
	changeIgnoreNoEntryLevelCount((kPromotion.isIgnoreNoEntryLevelSubtract()) ? -iChange : 0);
	changeIgnoreZoneofControlCount((kPromotion.isIgnoreZoneofControlAdd()) ? iChange : 0);
	changeIgnoreZoneofControlCount((kPromotion.isIgnoreZoneofControlSubtract()) ? -iChange : 0);
	changeFliesToMoveCount((kPromotion.isFliesToMoveAdd()) ? iChange : 0);
	changeFliesToMoveCount((kPromotion.isFliesToMoveSubtract()) ? -iChange : 0);
#ifdef BATTLEWORN
	changeExtraStrAdjperRnd(kPromotion.getStrAdjperRndChange() * iChange);
	changeExtraStrAdjperAtt(kPromotion.getStrAdjperAttChange() * iChange);
	changeExtraStrAdjperDef(kPromotion.getStrAdjperDefChange() * iChange);
	changeExtraWithdrawAdjperAtt(kPromotion.getWithdrawAdjperAttChange() * iChange);
#endif // BATTLEWORN
	changeExtraUnnerve(kPromotion.getUnnerveChange() * iChange);
	changeExtraEnclose(kPromotion.getEncloseChange() * iChange);
	changeExtraLunge(kPromotion.getLungeChange() * iChange);
	changeExtraDynamicDefense(kPromotion.getDynamicDefenseChange() * iChange);
	if (kPromotion.getStrengthChange() != 0)
	{
		changeExtraStrength(kPromotion.getStrengthChange() * iChange);
		bSMrecalc = true;
	}
	changeAnimalIgnoresBordersCount(kPromotion.getAnimalIgnoresBordersChange() * iChange);
	changeOnslaughtCount((kPromotion.isOnslaughtChange()) ? iChange : 0);
	changeExtraFortitude(kPromotion.getFortitudeChange() * iChange);
#ifdef OUTBREAKS_AND_AFFLICTIONS
	for (iI = 0; iI < GC.getNumPropertyInfos(); iI++)
	{
		changeExtraAidChange((PropertyTypes)iI, kPromotion.getAidChange(iI) * iChange);
	}
#endif
#ifdef STRENGTH_IN_NUMBERS
	changeExtraFrontSupportPercent(kPromotion.getFrontSupportPercentChange() * iChange);
	changeExtraShortRangeSupportPercent(kPromotion.getShortRangeSupportPercentChange() * iChange);
	changeExtraMediumRangeSupportPercent(kPromotion.getMediumRangeSupportPercentChange() * iChange);
	changeExtraLongRangeSupportPercent(kPromotion.getLongRangeSupportPercentChange() * iChange);
	changeExtraFlankSupportPercent(kPromotion.getFlankSupportPercentChange() * iChange);
#endif // STRENGTH_IN_NUMBERS

	changeExtraDodgeModifier(kPromotion.getDodgeModifierChange() * iChange);
	changeExtraPrecisionModifier(kPromotion.getPrecisionModifierChange() * iChange);
	changeExtraPowerShots(kPromotion.getPowerShotsChange() * iChange);
	changeExtraPowerShotCombatModifier(kPromotion.getPowerShotCombatModifierChange() * iChange);
	changeExtraPowerShotPunctureModifier(kPromotion.getPowerShotPunctureModifierChange() * iChange);
	changeExtraPowerShotPrecisionModifier(kPromotion.getPowerShotPrecisionModifierChange() * iChange);
	changeExtraPowerShotCriticalModifier(kPromotion.getPowerShotCriticalModifierChange() * iChange);
	changeExtraCriticalModifier(kPromotion.getCriticalModifierChange() * iChange);
	changeExtraEndurance(kPromotion.getEnduranceChange() * iChange);
	changeDealColdDamageCount((kPromotion.isMakesDamageCold()) ? iChange : 0);
	changeDealColdDamageCount((kPromotion.isMakesDamageNotCold()) ? -iChange : 0);
	changeColdImmuneCount((kPromotion.isAddsColdImmunity()) ? iChange : 0);
	changeColdImmuneCount((kPromotion.isRemovesColdImmunity()) ? -iChange : 0);
	changeExtraRoundStunProb(kPromotion.getRoundStunProbChange() * iChange);
	changeExtraPoisonProbabilityModifier(kPromotion.getPoisonProbabilityModifierChange() * iChange);

	changeExtraCaptureProbabilityModifier(kPromotion.getCaptureProbabilityModifierChange() * iChange);
	changeExtraCaptureResistanceModifier(kPromotion.getCaptureResistanceModifierChange() * iChange);

	changeExtraBreakdownChance(kPromotion.getBreakdownChanceChange() * iChange);
	changeExtraBreakdownDamage(kPromotion.getBreakdownDamageChange() * iChange);
	changeExtraTaunt(kPromotion.getTauntChange() * iChange);
	changeExcileCount(kPromotion.getExcileChange() * iChange);
	changePassageCount(kPromotion.getPassageChange() * iChange);
	changeNoNonOwnedCityEntryCount(kPromotion.getNoNonOwnedCityEntryChange() * iChange);
	changeBarbCoExistCount(kPromotion.getBarbCoExistChange() * iChange);
	changeBlendIntoCityCount(kPromotion.getBlendIntoCityChange() * iChange);
	changeUpgradeAnywhereCount(kPromotion.getUpgradeAnywhereChange() * iChange);

	if (kPromotion.getMaxHPChange() != 0)
	{
		changeExtraMaxHP(kPromotion.getMaxHPChange() * iChange);
		bSMrecalc = true;
	}
	if (kPromotion.getStrengthModifier() != 0)
	{
		changeExtraStrengthModifier(kPromotion.getStrengthModifier() * iChange);
		bSMrecalc = true;
	}
	//TB Combat Mods End
	changeExtraCollateralDamage(kPromotion.getCollateralDamageChange() * iChange);
	if (kPromotion.getBombardRateChange() != 0)
	{
		changeExtraBombardRate(kPromotion.getBombardRateChange() * iChange);
		bSMrecalc = true;
	}
	changeExtraEnemyHeal(kPromotion.getEnemyHealChange() * iChange);
	changeExtraNeutralHeal(kPromotion.getNeutralHealChange() * iChange);
	changeExtraFriendlyHeal(kPromotion.getFriendlyHealChange() * iChange);
	changeSameTileHeal(kPromotion.getSameTileHealChange() * iChange);
	changeAdjacentTileHeal(kPromotion.getAdjacentTileHealChange() * iChange);
	changeExtraCombatPercent(kPromotion.getCombatPercent() * iChange);
	changeExtraCityAttackPercent(kPromotion.getCityAttackPercent() * iChange);
	changeExtraCityDefensePercent(kPromotion.getCityDefensePercent() * iChange);
	changeExtraHillsAttackPercent(kPromotion.getHillsAttackPercent() * iChange);
	changeExtraHillsDefensePercent(kPromotion.getHillsDefensePercent() * iChange);
	// Assume only worker units can get the relevant promotions, if not then we'll need a retroactive unitComp late init function.
	if (isWorker())
	{
		bool bChanged = false;
		if (kPromotion.getHillsWorkPercent() != 0)
		{
			m_worker->changeHillsWorkModifier(kPromotion.getHillsWorkPercent() * iChange);
			bChanged = true;
		}
		if (kPromotion.getPeaksWorkPercent() != 0)
		{
			m_worker->changePeaksWorkModifier(kPromotion.getPeaksWorkPercent() * iChange);
			bChanged = true;
		}
		if (kPromotion.getWorkRatePercent() != 0)
		{
			m_worker->changeWorkModifier(kPromotion.getWorkRatePercent() * iChange);
			bChanged = true;
		}
		for (int iI = 0; iI < GC.getNumBuildInfos(); iI++)
		{
			if (kPromotion.getBuildWorkRateModifierChangeType(iI) != 0)
			{
				m_worker->changeExtraWorkModForBuild((BuildTypes)iI, kPromotion.getBuildWorkRateModifierChangeType(iI) * iChange);
				bChanged = true;
			}
		}
		if (bChanged) setInfoBarDirty(true);
	}
	changeRevoltProtection(kPromotion.getRevoltProtection() * iChange);
	changeCollateralDamageProtection(kPromotion.getCollateralDamageProtection() * iChange);
	changePillageChange(kPromotion.getPillageChange() * iChange);
	changeUpgradeDiscount(kPromotion.getUpgradeDiscount() * iChange);
	changeExperiencePercent(kPromotion.getExperiencePercent() * iChange);
	changeKamikazePercent((kPromotion.getKamikazePercent()) * iChange);
	if (kPromotion.getCargoChange() != 0)
	{
		changeCargoSpace(kPromotion.getCargoChange() * iChange);
		bSMrecalc = true;
	}
	if (kPromotion.getSMCargoChange() != 0)
	{
		changeSMCargoSpace(kPromotion.getSMCargoChange() * iChange);
		bSMrecalc = true;
	}
	if (kPromotion.getSMCargoVolumeChange() != 0)
	{
		changeExtraCargoVolume(kPromotion.getSMCargoVolumeChange() * iChange);
		bSMrecalc = true;
	}
	if (kPromotion.getSMCargoVolumeModifierChange() != 0)
	{
		changeCargoVolumeModifier(kPromotion.getSMCargoVolumeModifierChange() * iChange);
		bSMrecalc = true;
	}

	changeExtraCombatModifierPerSizeMore(kPromotion.getCombatModifierPerSizeMoreChange() * iChange);//no merge/split
	changeExtraCombatModifierPerSizeLess(kPromotion.getCombatModifierPerSizeLessChange() * iChange);//no merge/split
	changeExtraCombatModifierPerVolumeMore(kPromotion.getCombatModifierPerVolumeMoreChange() * iChange);//no merge/split
	changeExtraCombatModifierPerVolumeLess(kPromotion.getCombatModifierPerVolumeLessChange() * iChange);//no merge/split

	changeExtraRBombardDamage(kPromotion.getRBombardDamageChange() * iChange);
	changeExtraRBombardDamageLimit(kPromotion.getRBombardDamageLimitChange() * iChange);
	changeExtraRBombardDamageMaxUnits(kPromotion.getRBombardDamageMaxUnitsChange() * iChange);
	changeExtraDCMBombRange(kPromotion.getDCMBombRangeChange() * iChange);
	changeExtraDCMBombAccuracy(kPromotion.getDCMBombAccuracyChange() * iChange);
	changeNoSelfHealCount((kPromotion.isNoSelfHeal()) ? iChange : 0);
	changeExtraSelfHealModifier(kPromotion.getSelfHealModifier() * iChange);
	changeExtraNumHealSupport(kPromotion.getNumHealSupport() * iChange);
	changeExtraInsidiousness(kPromotion.getInsidiousnessChange() * iChange);
	changeExtraInvestigation(kPromotion.getInvestigationChange() * iChange);
	changeAssassinCount(kPromotion.getAssassinChange() * iChange);
	changeExtraStealthStrikes(kPromotion.getStealthStrikesChange() * iChange);
	changeExtraStealthCombatModifier(kPromotion.getStealthCombatModifierChange() * iChange);
	changeStealthDefenseCount(kPromotion.getStealthDefenseChange() * iChange);
	changeOnlyDefensiveCount(kPromotion.getDefenseOnlyChange() * iChange);
	changeNoInvisibilityCount(kPromotion.getNoInvisibilityChange() * iChange);
	changeExtraTrapDamageMax(kPromotion.getTrapDamageMax() * iChange);
	changeExtraTrapDamageMin(kPromotion.getTrapDamageMin() * iChange);
	changeExtraTrapComplexity(kPromotion.getTrapComplexity() * iChange);
	changeExtraNumTriggers(kPromotion.getNumTriggers() * iChange);
	changeTriggerBeforeAttackCount(kPromotion.getTriggerBeforeAttackChange() * iChange);
	changeHiddenNationalityCount(kPromotion.getHiddenNationalityChange() * iChange);

	if (kPromotion.getQualityChange() != 0)
	{
		changeExtraQuality(kPromotion.getQualityChange() * iChange);
		bSMrecalc = true;
	}
	if (kPromotion.getGroupChange() != 0)
	{
		changeExtraGroup(kPromotion.getGroupChange() * iChange);
		bSMrecalc = true;
	}

#ifdef OUTBREAKS_AND_AFFLICTIONS
	if (!bAdding && kPromotion.isAffliction())
	{
		changeUnitAfflictionTolerance(((PromotionLineTypes)kPromotion.getPromotionLine()),GC.getPromotionLineInfo((PromotionLineTypes)kPromotion.getPromotionLine()).getToleranceBuildup() * iChange);
	}
#endif

	if (kPromotion.isZoneOfControl())
	{
		changeZoneOfControlCount(iChange > 0 ? 1 : -1);
	}

	if (kPromotion.getIgnoreTerrainDamage() != NO_TERRAIN)
	{
		changeTerrainProtected((TerrainTypes)kPromotion.getIgnoreTerrainDamage(), iChange);
	}

	for (iI = 0; iI < GC.getNumTerrainInfos(); iI++)
	{
		changeExtraTerrainAttackPercent(((TerrainTypes)iI), (kPromotion.getTerrainAttackPercent(iI) * iChange));
		changeExtraTerrainDefensePercent(((TerrainTypes)iI), (kPromotion.getTerrainDefensePercent(iI) * iChange));

		changeExtraTerrainWorkPercent(((TerrainTypes)iI), (kPromotion.getTerrainWorkPercent(iI) * iChange));

		changeTerrainDoubleMoveCount(((TerrainTypes)iI), ((kPromotion.getTerrainDoubleMove(iI)) ? iChange : 0));
		changeExtraWithdrawOnTerrainType(((TerrainTypes)iI), (kPromotion.getWithdrawOnTerrainTypeChange(iI) * iChange));
	}

	for (iI = 0; iI < GC.getNumFeatureInfos(); iI++)
	{
		changeExtraFeatureAttackPercent(((FeatureTypes)iI), (kPromotion.getFeatureAttackPercent(iI) * iChange));
		changeExtraFeatureDefensePercent(((FeatureTypes)iI), (kPromotion.getFeatureDefensePercent(iI) * iChange));

		changeExtraFeatureWorkPercent(((FeatureTypes)iI), (kPromotion.getFeatureWorkPercent(iI) * iChange));

		changeFeatureDoubleMoveCount(((FeatureTypes)iI), ((kPromotion.getFeatureDoubleMove(iI)) ? iChange : 0));
		changeExtraWithdrawOnFeatureType(((FeatureTypes)iI), (kPromotion.getWithdrawOnFeatureTypeChange(iI) * iChange));
	}

	for (iI = 0; iI < GC.getNumInvisibleInfos(); iI++)
	{
		changeExtraVisibilityIntensityType(((InvisibleTypes)iI), (kPromotion.getVisibilityIntensityChangeType(iI) * iChange));
		changeExtraInvisibilityIntensityType(((InvisibleTypes)iI), (kPromotion.getInvisibilityIntensityChangeType(iI) * iChange));
		changeExtraVisibilityIntensityRangeType(((InvisibleTypes)iI), (kPromotion.getVisibilityIntensityRangeChangeType(iI) * iChange));
	}

	for (iI = 0; iI < kPromotion.getNumNegatesInvisibilityTypes(); iI++)
	{
		changeNegatesInvisibleCount((InvisibleTypes)kPromotion.getNegatesInvisibilityType(iI), iChange);
	}

	for (iI = 0; iI < kPromotion.getNumTrapSetWithPromotionTypes(); iI++)
	{
		changeTrapSetWithPromotionCount((PromotionTypes)kPromotion.getTrapSetWithPromotionType(iI), iChange);
	}

	for (iI = 0; iI < kPromotion.getNumTrapImmunityUnitCombatTypes(); iI++)
	{
		changeTrapImmunityUnitCombatCount((UnitCombatTypes)kPromotion.getTrapImmunityUnitCombatType(iI), iChange);
	}

	for (iI = 0; iI < kPromotion.getNumTargetUnitCombatTypes(); iI++)
	{
		changeTargetUnitCombatCount((UnitCombatTypes)kPromotion.getTargetUnitCombatType(iI), iChange);
	}

	for (iI = 0; iI < kPromotion.getNumInvisibleTerrainChanges(); iI++)
	{
		changeExtraInvisibleTerrain((InvisibleTypes)kPromotion.getInvisibleTerrainChange(iI).eInvisible,(TerrainTypes)kPromotion.getInvisibleTerrainChange(iI).eTerrain, kPromotion.getInvisibleTerrainChange(iI).iIntensity * iChange);
	}

	for (iI = 0; iI < kPromotion.getNumInvisibleFeatureChanges(); iI++)
	{
		changeExtraInvisibleFeature((InvisibleTypes)kPromotion.getInvisibleFeatureChange(iI).eInvisible,(FeatureTypes)kPromotion.getInvisibleFeatureChange(iI).eFeature, kPromotion.getInvisibleFeatureChange(iI).iIntensity * iChange);
	}

	for (iI = 0; iI < kPromotion.getNumInvisibleImprovementChanges(); iI++)
	{
		changeExtraInvisibleImprovement((InvisibleTypes)kPromotion.getInvisibleImprovementChange(iI).eInvisible,(ImprovementTypes)kPromotion.getInvisibleImprovementChange(iI).eImprovement, kPromotion.getInvisibleImprovementChange(iI).iIntensity * iChange);
	}

	for (iI = 0; iI < kPromotion.getNumVisibleTerrainChanges(); iI++)
	{
		changeExtraVisibleTerrain((InvisibleTypes)kPromotion.getVisibleTerrainChange(iI).eInvisible,(TerrainTypes)kPromotion.getVisibleTerrainChange(iI).eTerrain, kPromotion.getVisibleTerrainChange(iI).iIntensity * iChange);
	}

	for (iI = 0; iI < kPromotion.getNumVisibleFeatureChanges(); iI++)
	{
		changeExtraVisibleFeature((InvisibleTypes)kPromotion.getVisibleFeatureChange(iI).eInvisible,(FeatureTypes)kPromotion.getVisibleFeatureChange(iI).eFeature, kPromotion.getVisibleFeatureChange(iI).iIntensity * iChange);
	}

	for (iI = 0; iI < kPromotion.getNumVisibleImprovementChanges(); iI++)
	{
		changeExtraVisibleImprovement((InvisibleTypes)kPromotion.getVisibleImprovementChange(iI).eInvisible,(ImprovementTypes)kPromotion.getVisibleImprovementChange(iI).eImprovement, kPromotion.getVisibleImprovementChange(iI).iIntensity * iChange);
	}

	for (iI = 0; iI < kPromotion.getNumVisibleTerrainRangeChanges(); iI++)
	{
		changeExtraVisibleTerrainRange((InvisibleTypes)kPromotion.getVisibleTerrainRangeChange(iI).eInvisible,(TerrainTypes)kPromotion.getVisibleTerrainRangeChange(iI).eTerrain, kPromotion.getVisibleTerrainRangeChange(iI).iIntensity * iChange);
	}

	for (iI = 0; iI < kPromotion.getNumVisibleFeatureRangeChanges(); iI++)
	{
		changeExtraVisibleFeatureRange((InvisibleTypes)kPromotion.getVisibleFeatureRangeChange(iI).eInvisible,(FeatureTypes)kPromotion.getVisibleFeatureRangeChange(iI).eFeature, kPromotion.getVisibleFeatureRangeChange(iI).iIntensity * iChange);
	}

	for (iI = 0; iI < kPromotion.getNumVisibleImprovementRangeChanges(); iI++)
	{
		changeExtraVisibleImprovementRange((InvisibleTypes)kPromotion.getVisibleImprovementRangeChange(iI).eInvisible,(ImprovementTypes)kPromotion.getVisibleImprovementRangeChange(iI).eImprovement, kPromotion.getVisibleImprovementRangeChange(iI).iIntensity * iChange);
	}

#ifdef OUTBREAKS_AND_AFFLICTIONS
	for (iI = 0; iI < kPromotion.getNumDistanceAttackCommunicabilityTypeChanges(); iI++)
	{
		changeDistanceAttackCommunicability((PromotionLineTypes)kPromotion.getDistanceAttackCommunicabilityTypeChange(iI).eAfflictionLine, kPromotion.getDistanceAttackCommunicabilityTypeChange(iI).iChange * iChange);
	}
#endif
	const int numUnitCombatInfos = GC.getNumUnitCombatInfos();
	for (iI = 0; iI < numUnitCombatInfos; iI++)
	{
		changeExtraUnitCombatModifier(((UnitCombatTypes)iI), (kPromotion.getUnitCombatModifierPercent(iI) * iChange));
		changeExtraFlankingStrengthbyUnitCombatType(((UnitCombatTypes)iI), (kPromotion.getFlankingStrengthbyUnitCombatTypeChange(iI) * iChange));
		changeExtraWithdrawVSUnitCombatType(((UnitCombatTypes)iI), (kPromotion.getWithdrawVSUnitCombatChangeType(iI) * iChange));
		changeExtraPursuitVSUnitCombatType(((UnitCombatTypes)iI), (kPromotion.getPursuitVSUnitCombatChangeType(iI) * iChange));
		changeExtraRepelVSUnitCombatType(((UnitCombatTypes)iI), (kPromotion.getRepelVSUnitCombatChangeType(iI) * iChange));
		changeExtraKnockbackVSUnitCombatType(((UnitCombatTypes)iI), (kPromotion.getKnockbackVSUnitCombatChangeType(iI) * iChange));
		changeExtraPunctureVSUnitCombatType(((UnitCombatTypes)iI), (kPromotion.getPunctureVSUnitCombatChangeType(iI) * iChange));
		changeExtraArmorVSUnitCombatType(((UnitCombatTypes)iI), (kPromotion.getArmorVSUnitCombatChangeType(iI) * iChange));
		changeExtraDodgeVSUnitCombatType(((UnitCombatTypes)iI), (kPromotion.getDodgeVSUnitCombatChangeType(iI) * iChange));
		changeExtraPrecisionVSUnitCombatType(((UnitCombatTypes)iI), (kPromotion.getPrecisionVSUnitCombatChangeType(iI) * iChange));
		changeExtraCriticalVSUnitCombatType(((UnitCombatTypes)iI), (kPromotion.getCriticalVSUnitCombatChangeType(iI) * iChange));
		changeExtraRoundStunVSUnitCombatType(((UnitCombatTypes)iI), (kPromotion.getRoundStunVSUnitCombatChangeType(iI) * iChange));
		changeExtraTrapDisableUnitCombatType(((UnitCombatTypes)iI), (kPromotion.getTrapDisableUnitCombatType(iI) * iChange));
		changeExtraTrapAvoidanceUnitCombatType(((UnitCombatTypes)iI), (kPromotion.getTrapAvoidanceUnitCombatType(iI) * iChange));
		changeExtraTrapTriggerUnitCombatType(((UnitCombatTypes)iI), (kPromotion.getTrapTriggerUnitCombatType(iI) * iChange));
	}

	for (iI = 0; iI < kPromotion.getNumSubCombatChangeTypes(); iI++)
	{
		setHasUnitCombat(((UnitCombatTypes)kPromotion.getSubCombatChangeType(iI)), bAdding, true);
	}

	for (iI = 0; iI < kPromotion.getNumRemovesUnitCombatTypes(); iI++)
	{
		setHasUnitCombat(((UnitCombatTypes)kPromotion.getRemovesUnitCombatType(iI)), bAdding ? false : true, true);
	}

#ifdef OUTBREAKS_AND_AFFLICTIONS
	if (GC.getGame().isOption(GAMEOPTION_OUTBREAKS_AND_AFFLICTIONS))
	{
		for (iI = 0; iI < kPromotion.getNumCureAfflictionChangeTypes(); iI++)
		{
			changeCureAfflictionCount(((PromotionLineTypes)kPromotion.getCureAfflictionChangeType(iI)), bAdding);
		}

		for (iI = 0; iI < kPromotion.getNumAfflictionFortitudeChangeModifiers(); iI++)
		{
			changeFortitudeModifierTypeAmount(((PromotionLineTypes)kPromotion.getAfflictionFortitudeChangeModifier(iI).ePromotionLine), kPromotion.getAfflictionFortitudeChangeModifier(iI).iModifier * iChange);
		}

		for (iI = 0; iI < kPromotion.getNumAfflictOnAttackChangeTypes(); iI++)
		{
			changeAfflictOnAttackTypeCount(((PromotionLineTypes)kPromotion.getAfflictOnAttackChangeType(iI).eAfflictionLine), iChange);
			changeAfflictOnAttackTypeProbability(((PromotionLineTypes)kPromotion.getAfflictOnAttackChangeType(iI).eAfflictionLine), kPromotion.getAfflictOnAttackChangeType(iI).iProbabilityChange * iChange);
			changeAfflictOnAttackTypeMeleeCount(((PromotionLineTypes)kPromotion.getAfflictOnAttackChangeType(iI).eAfflictionLine), kPromotion.getAfflictOnAttackChangeType(iI).iMelee * iChange);
			changeAfflictOnAttackTypeDistanceCount(((PromotionLineTypes)kPromotion.getAfflictOnAttackChangeType(iI).eAfflictionLine), kPromotion.getAfflictOnAttackChangeType(iI).iDistance * iChange);
			changeAfflictOnAttackTypeImmediateCount(((PromotionLineTypes)kPromotion.getAfflictOnAttackChangeType(iI).eAfflictionLine), kPromotion.getAfflictOnAttackChangeType(iI).iImmediate * iChange);
		}
	}
#endif // OUTBREAKS_AND_AFFLICTIONS

	for (iI = 0; iI < kPromotion.getNumHealUnitCombatChangeTypes(); iI++)
	{
		changeHealUnitCombatTypeVolume(((UnitCombatTypes)kPromotion.getHealUnitCombatChangeType(iI).eUnitCombat), kPromotion.getHealUnitCombatChangeType(iI).iHeal * iChange);
		changeHealUnitCombatTypeAdjacentVolume(((UnitCombatTypes)kPromotion.getHealUnitCombatChangeType(iI).eUnitCombat), kPromotion.getHealUnitCombatChangeType(iI).iAdjacentHeal * iChange);
	}

	if (kPromotion.setSpecialUnit() != NO_SPECIALUNIT)
	{
		setSpecialUnit(iChange, kPromotion.setSpecialUnit());
	}
	//TB Combat Mod End

	for (iI = 0; iI < NUM_DOMAIN_TYPES; iI++)
	{
		changeExtraDomainModifier(((DomainTypes)iI), (kPromotion.getDomainModifierPercent(iI) * iChange));
	}

	if (bAdding && bInitial && kPromotion.isZeroesXP())
	{
		setExperience(0);
	}

	if (bSMrecalc && GC.getGame().isOption(GAMEOPTION_SIZE_MATTERS))
	{
		setSMValues();
	}

	establishBuildups();
}

void CvUnit::setHasPromotion(PromotionTypes eIndex, bool bNewValue, PromotionApply::flags flags)
{
	setHasPromotion
	(
		eIndex, bNewValue,
		flags & PromotionApply::Free,
		flags & PromotionApply::Dying,
		flags & PromotionApply::Initial,
		flags & PromotionApply::FromTrait
	);
}

void CvUnit::setHasPromotion(PromotionTypes eIndex, bool bNewValue, bool bFree, bool bDying, bool bInitial, bool bFromTrait)
{
	PROFILE_FUNC();

	FAssertMsg(eIndex < GC.getNumPromotionInfos(), "Invalid promotion");

	if (eIndex == NO_PROMOTION)
	{
		FErrorMsg("Invalid promotion");
		return;
	}

	CvPromotionInfo& kPromotion = GC.getPromotionInfo(eIndex);
	// Disable spy promotions mechanism
#ifdef OUTBREAKS_AND_AFFLICTIONS
	//TB Combat Mods begin (first, regardless of remove, add, or ignore because they already have it, reset AfflictionTurnCount to 0,
	//and another check is necessary here for equips and afflicts to ensure unusual means of reaching this point cannot bypass some necessary disqualifiers)
	if (kPromotion.isAffliction())
	{
		PromotionLineTypes eAfflict = (PromotionLineTypes)kPromotion.getPromotionLine();
		setAfflictionTurnCount(eAfflict, 0);
	}
	//TB Combat Mods end
#endif
	bool canPromote = !isSpy() || GC.isSS_ENABLED() || kPromotion.isEnemyRoute(); //exempt commando promotion

	bool bAssignFree = false;
	if (bFree)
	{
		if (bNewValue)
		{
			// Check canKeep to ensure we're not wasting our time on free promos
			canPromote = canKeepPromotion(eIndex, true, false);
			// Following removes the need to count all those promos as free.
			if (canPromote)
			{
				bAssignFree = true;
			}
		}
		else // Remove free status
		{
			setPromotionFreeCount(eIndex, 0);

			if (bFromTrait)
			{
				setPromotionFromTrait(eIndex, 0);
			}
		}
	}

	if (isHasPromotion(eIndex) != bNewValue)
	{
		// If we check all normal promotions through this routine we'll accidentally disqualify a number of free promos on the basis of tech prereq.
		// Important this only runs a check for equps and afflicts.  All other means of getting here should
		// already be checked in their own way.  A better check for those would be canKeepPromotion() which they should
		// run up against regularly by default anyhow.  If we notice units getting free promos they can't keep, then
		// we'll have to find the source and check against canKeepPromotion before they qualify to get to setHasPromotion in the first place.
		if (canPromote && bNewValue && (kPromotion.isEquipment()
#ifdef OUTBREAKS_AND_AFFLICTIONS
			|| kPromotion.isAffliction()
#endif
			))
		{
			// When trying to add a promotion: check we are allowed to have it.
			// Note - this check filters out attempts to set lower priority equipment
			//	or afflication promotions from the same line as an existing one that has a higher priority
			PromotionRequirements::flags promoFlags = PromotionRequirements::None;
			if (kPromotion.isEquipment()) promoFlags |= PromotionRequirements::Equip;
#ifdef OUTBREAKS_AND_AFFLICTIONS
			if (kPromotion.isAffliction()) promoFlags |= PromotionRequirements::Afflict;
#endif
			canPromote = canAcquirePromotion(eIndex, promoFlags);
		}


		if (canPromote)
		{
			PromotionKeyedInfo* info =
			(
				bNewValue
				?
				findOrCreatePromotionKeyedInfo(eIndex)
				:
				(PromotionKeyedInfo*)findPromotionKeyedInfo(eIndex)
			);

			if (info != NULL)
			{
				info->m_bHasPromotion = bNewValue;
			}

			if (bAssignFree)
			{
				setPromotionFreeCount(eIndex, 1);
				if (bFromTrait)
				{
					setPromotionFromTrait(eIndex, 1);
				}
			}

			// Never Initial if Free or Removing
			if (bInitial && (!bNewValue || bFree))
			{
				bInitial = false;
			}

			processPromotion(eIndex, bNewValue, bInitial);

			AI_flushValueCache();

			// A unit can only have a single promotion in a promotion line for equipment or affliction promotions,
			//	if we're applying a higher priority one make sure any lower priority one from the same line that was present previously is removed
			// QUESTION FOR TB - should removing an afflication add in the affliction below it (priority wise)
			//	in its line??  (I assume not for equipments, but wasn't sure for afflictions)
			if (bNewValue)
			{
				if (kPromotion.getPromotionLine() != NO_PROMOTIONLINE
				&& (
#ifdef OUTBREAKS_AND_AFFLICTIONS
					kPromotion.isAffliction() ||
#endif
					kPromotion.isEquipment()))
				{
					for (int iI = 0; iI < GC.getNumPromotionInfos(); iI++)
					{
						if (isHasPromotion((PromotionTypes)iI)
						&& GC.getPromotionInfo((PromotionTypes)iI).getPromotionLine() == kPromotion.getPromotionLine()
						&& GC.getPromotionInfo((PromotionTypes)iI).getLinePriority() < kPromotion.getLinePriority())
						{
							setHasPromotion((PromotionTypes)iI, false);
						}
					}
				}
				if (kPromotion.isRemoveAfterSet())
				{
					setHasPromotion(eIndex, false, bFree, bDying, bInitial);
				}
			}

			// When promotions are being removed as part of killing a unit we dont want to add any more or invoke obsoletion checks,
			//	which results in lots of extra processing, and can also generate retrain messages for the dying units!
			if (!isDead() && !isDelayedDeath() && !bDying)
			{
				checkPromotionObsoletion();
				checkFreetoCombatClass();
			}

			//	Updates the grpahics last after everything is calculated
			if (IsSelected())
			{
				gDLL->getInterfaceIFace()->setDirty(SelectionButtons_DIRTY_BIT, true);
				gDLL->getInterfaceIFace()->setDirty(InfoPane_DIRTY_BIT, true);
			}

			//update graphics
			if (!isUsingDummyEntities() && isInViewport())
			{
				gDLL->getEntityIFace()->updatePromotionLayers(getUnitEntity());
			}
		}
	}
}


bool CvUnit::applyUnitPromotions(const std::vector<CvUnit*>& units, int number, PromotionPredicateFn promotionPredicateFn)
{
	FAssertMsg(number >= 0, "Number of promotions to apply cannot be negative");

	if (units.size() == 0)
		return true;

	while (number > 0)
	{
		PromotionTypes foundPromo = GC.findPromotion(promotionPredicateFn);
		if (foundPromo == NO_PROMOTION)
			break;
		foreach_(CvUnit* unit, units)
		{
			unit->setHasPromotion(foundPromo, true, PromotionApply::Free);
		}
		number--;
	}
	return number == 0;
}

bool CvUnit::applyUnitPromotions(CvUnit* unit, int number, PromotionPredicateFn promotionPredicateFn)
{
	std::vector<CvUnit*> units;
	units.push_back(unit);
	return applyUnitPromotions(units, number, promotionPredicateFn);
}

bool CvUnit::normalizeUnitPromotions(const std::vector<CvUnit*>& units, int offset, PromotionPredicateFn upgradePredicateFn, PromotionPredicateFn downgradePredicateFn)
{
	return offset == 0 ? true : applyUnitPromotions(units, std::abs(offset), offset > 0 ? upgradePredicateFn : downgradePredicateFn);
}

bool CvUnit::normalizeUnitPromotions(CvUnit* unit, int offset, PromotionPredicateFn upgradePredicateFn, PromotionPredicateFn downgradePredicateFn)
{
	return offset == 0 ? true : applyUnitPromotions(unit, std::abs(offset), offset > 0 ? upgradePredicateFn : downgradePredicateFn);
}

UnitCombatTypes CvUnit::getBestHealingType()
{
	UnitCombatTypes eBestUnitCombat = NO_UNITCOMBAT;
	int iBestValue = 0;

	for (int iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
	{
		if (GC.getUnitCombatInfo((UnitCombatTypes)iI).isHealsAs())
		{
			const int iValue = getHealUnitCombatTypeTotal((UnitCombatTypes)iI);
			if (iValue > iBestValue)
			{
				iBestValue = iValue;
				eBestUnitCombat = (UnitCombatTypes)iI;
			}
		}
	}
	return eBestUnitCombat;
}

UnitCombatTypes CvUnit::getBestHealingTypeConst() const
{
	UnitCombatTypes eBestUnitCombat = NO_UNITCOMBAT;
	int iBestValue = 0;

	for (int iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
	{
		if (GC.getUnitCombatInfo((UnitCombatTypes)iI).isHealsAs())
		{
			const int iValue = getHealUnitCombatTypeTotal((UnitCombatTypes)iI);
			if (iValue > iBestValue)
			{
				iBestValue = iValue;
				eBestUnitCombat = (UnitCombatTypes)iI;
			}
		}
	}
	return eBestUnitCombat;
}

int CvUnit::getSubUnitCount() const
{
	if (GC.getGame().isOption(GAMEOPTION_SIZE_MATTERS) && groupRank() > 0)
	{
		return groupRank();
	}
	return m_pUnitInfo->getGroupSize();
}


int CvUnit::getSubUnitsAlive() const
{
	return getSubUnitsAlive(getDamage());
}


int CvUnit::getSubUnitsAlive(int iDamage) const
{
	const int iMaxHP = getMaxHP();
	if (iDamage >= iMaxHP)
	{
		return 0;
	}
	return std::max(1, (getSubUnitCount() * (iMaxHP - iDamage) + iMaxHP / (2*getSubUnitCount() + 1)) / iMaxHP);
}
// returns true if unit can initiate a war action with plot (possibly by declaring war)
bool CvUnit::potentialWarAction(const CvPlot* pPlot) const
{
	TeamTypes ePlotTeam = pPlot->getTeam();

	if (ePlotTeam == NO_TEAM)
	{
		return false;
	}

	if (isEnemy(ePlotTeam, pPlot))
	{
		return true;
	}

	if (getGroup()->AI_isDeclareWar(pPlot) && GET_TEAM(getTeam()).AI_getWarPlan(ePlotTeam) != NO_WARPLAN)
	{
		return true;
	}

	return false;
}

void CvUnit::read(FDataStreamBase* pStream)
{
	int iI;

	// Init data before load
	reset();

	CvTaggedSaveFormatWrapper&	wrapper = CvTaggedSaveFormatWrapper::getSaveFormatWrapper();

	wrapper.AttachToStream(pStream);

	WRAPPER_READ_OBJECT_START(wrapper);

	WRAPPER_READ(wrapper, "CvUnit", &m_iDCMBombRange);
	WRAPPER_READ(wrapper, "CvUnit", &m_iDCMBombAccuracy);

	// @SAVEBREAK DELETE - Toffer
	WRAPPER_SKIP_ELEMENT(wrapper, "CvUnit", m_bMADEnabled, SAVE_VALUE_ANY);
	WRAPPER_SKIP_ELEMENT(wrapper, "CvUnit", m_iMADTargetPlotX, SAVE_VALUE_ANY);
	WRAPPER_SKIP_ELEMENT(wrapper, "CvUnit", m_iMADTargetPlotY, SAVE_VALUE_ANY);
	WRAPPER_SKIP_ELEMENT(wrapper, "CvUnit", m_pMADTargetPlotOwner, SAVE_VALUE_ANY);
	// SAVEBREAK@

	WRAPPER_READ(wrapper, "CvUnit", &m_iID);
	WRAPPER_READ(wrapper, "CvUnit", &m_iGroupID);
	WRAPPER_READ(wrapper, "CvUnit", &m_iHotKeyNumber);
	WRAPPER_READ(wrapper, "CvUnit", &m_iX);
	WRAPPER_READ(wrapper, "CvUnit", &m_iY);
	WRAPPER_READ(wrapper, "CvUnit", &m_iLastMoveTurn);
	WRAPPER_READ(wrapper, "CvUnit", &m_iReconX);
	WRAPPER_READ(wrapper, "CvUnit", &m_iReconY);
	WRAPPER_READ(wrapper, "CvUnit", &m_iGameTurnCreated);
	WRAPPER_READ(wrapper, "CvUnit", &m_iDamage);
	WRAPPER_READ(wrapper, "CvUnit", &m_iMoves);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExperience);
	WRAPPER_READ(wrapper, "CvUnit", &m_iLevel);
	WRAPPER_READ(wrapper, "CvUnit", &m_iCargo);
	WRAPPER_READ(wrapper, "CvUnit", &m_iCargoCapacity);
	WRAPPER_READ(wrapper, "CvUnit", &m_iAttackPlotX);
	WRAPPER_READ(wrapper, "CvUnit", &m_iAttackPlotY);
	WRAPPER_READ(wrapper, "CvUnit", &m_iCombatTimer);
	WRAPPER_READ(wrapper, "CvUnit", &m_iCombatFirstStrikes);
	WRAPPER_READ(wrapper, "CvUnit", &m_iFortifyTurns);
	WRAPPER_READ(wrapper, "CvUnit", &m_iBlitzCount);
	WRAPPER_READ(wrapper, "CvUnit", &m_iAmphibCount);
	WRAPPER_READ(wrapper, "CvUnit", &m_iRiverCount);
	WRAPPER_READ(wrapper, "CvUnit", &m_iEnemyRouteCount);
	WRAPPER_READ(wrapper, "CvUnit", &m_iAlwaysHealCount);
	WRAPPER_READ(wrapper, "CvUnit", &m_iHillsDoubleMoveCount);

	WRAPPER_READ(wrapper, "CvUnit", &m_iCanMovePeaksCount);
	WRAPPER_READ(wrapper, "CvUnit", &m_iCanLeadThroughPeaksCount);

	WRAPPER_READ(wrapper, "CvUnit", &m_iSleepTimer);

	// SAVEBRERAK - Toffer - Cleanup commander mess.
	int iExtraControlPoints = 0;
	WRAPPER_READ_DECORATED(wrapper, "CvUnit", &iExtraControlPoints, "m_iExtraControlPoints");
	int iExtraCommandRange = 0;
	WRAPPER_READ_DECORATED(wrapper, "CvUnit", &iExtraCommandRange, "m_iExtraCommandRange");
	int iControlPointsLeft = 0;
	WRAPPER_READ_DECORATED(wrapper, "CvUnit", &iControlPointsLeft, "m_iControlPointsLeft");

	WRAPPER_READ(wrapper, "CvUnit", &m_iCommanderID); //id will be used later on player initialization to get m_pUsedCommander pointer

	WRAPPER_READ(wrapper, "CvUnit", (int*)&m_eOriginalOwner);

	bool bCommander = false;
	WRAPPER_READ_DECORATED(wrapper, "CvUnit", &bCommander, "m_bCommander");

	WRAPPER_READ(wrapper, "CvUnit", &m_bAutoPromoting);
	WRAPPER_READ(wrapper, "CvUnit", &m_bAutoUpgrading);

	WRAPPER_READ(wrapper, "CvUnit", (int*)&m_shadowUnit.eOwner);
	WRAPPER_READ(wrapper, "CvUnit", &m_shadowUnit.iID);
	WRAPPER_READ_CLASS_ENUM(wrapper, "CvUnit", REMAPPED_CLASS_TYPE_TECHS, (int*)&m_eDesiredDiscoveryTech);

	WRAPPER_READ(wrapper, "CvUnit", &m_iImmuneToFirstStrikesCount);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraVisibilityRange);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraMoves);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraMoveDiscount);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraAirRange);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraIntercept);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraEvasion);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraFirstStrikes);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraChanceFirstStrikes);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraWithdrawal);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraCollateralDamage);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraBombardRate);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraEnemyHeal);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraNeutralHeal);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraFriendlyHeal);
	WRAPPER_READ(wrapper, "CvUnit", &m_iSameTileHeal);
	WRAPPER_READ(wrapper, "CvUnit", &m_iAdjacentTileHeal);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraCombatPercent);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraCityAttackPercent);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraCityDefensePercent);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraHillsAttackPercent);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraHillsDefensePercent);

	int iExtraHillsWorkPercent = 0;
	WRAPPER_READ_DECORATED(wrapper, "CvUnit", &iExtraHillsWorkPercent, "m_iExtraHillsWorkPercent");
	int iExtraWorkPercent = 0;
	WRAPPER_READ_DECORATED(wrapper, "CvUnit", &iExtraWorkPercent, "m_iExtraWorkPercent");

	WRAPPER_READ(wrapper, "CvUnit", &m_iRevoltProtection);
	WRAPPER_READ(wrapper, "CvUnit", &m_iCollateralDamageProtection);
	WRAPPER_READ(wrapper, "CvUnit", &m_iPillageChange);
	WRAPPER_READ(wrapper, "CvUnit", &m_iUpgradeDiscount);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExperiencePercent);
	WRAPPER_READ(wrapper, "CvUnit", &m_iKamikazePercent);
	WRAPPER_READ(wrapper, "CvUnit", &m_iBaseCombat);
	WRAPPER_READ(wrapper, "CvUnit", (int*)&m_eFacingDirection);
	WRAPPER_READ(wrapper, "CvUnit", &m_iImmobileTimer);

	WRAPPER_READ(wrapper, "CvUnit", &m_bMadeAttack);
	WRAPPER_READ(wrapper, "CvUnit", &m_bMadeInterception);
	WRAPPER_READ(wrapper, "CvUnit", &m_bPromotionReady);
	WRAPPER_READ(wrapper, "CvUnit", &m_bDeathDelay);
	WRAPPER_READ(wrapper, "CvUnit", &m_bCombatFocus);
	// m_bInfoBarDirty not saved...
	WRAPPER_READ(wrapper, "CvUnit", &m_bBlockading);
	WRAPPER_READ(wrapper, "CvUnit", &m_bAirCombat);

	WRAPPER_READ(wrapper, "CvUnit", (int*)&m_eOwner);
	WRAPPER_READ(wrapper, "CvUnit", (int*)&m_eCapturingPlayer);
	WRAPPER_READ_CLASS_ENUM(wrapper, "CvUnit", REMAPPED_CLASS_TYPE_UNITS, (int*)&m_eUnitType);
	if (NO_UNIT == m_eUnitType)
	{
		// Assets must have removed this type (which will have been flagged in a queued error message).
		// Just give it a valid type and mark it to be killed.
		m_eUnitType = (UnitTypes)0;
		m_bDeathDelay = true;
		// Unit type 0 was never initialized, so we need to add its unit count before it dies.
		GET_PLAYER(getOwner()).changeUnitCount(m_eUnitType, 1);
		if (GC.getGame().isOption(GAMEOPTION_SIZE_MATTERS)
		// if unit doesn't have a group rank, it doesn't count as a SM unit at all
		&& GC.getUnitInfo(m_eUnitType).getBaseGroupRank() > 0)
		{
			GET_PLAYER(getOwner()).changeUnitCountSM(m_eUnitType, intPow(3, GC.getUnitInfo(m_eUnitType).getBaseGroupRank() - 1));
		}
	}
	m_pUnitInfo = &GC.getUnitInfo(m_eUnitType);
	m_movementCharacteristicsHash = m_pUnitInfo->getZobristValue();

	WRAPPER_READ_CLASS_ENUM(wrapper, "CvUnit", REMAPPED_CLASS_TYPE_UNITS, (int*)&m_eLeaderUnitType);

	WRAPPER_READ(wrapper, "CvUnit", (int*)&m_combatUnit.eOwner);
	WRAPPER_READ(wrapper, "CvUnit", &m_combatUnit.iID);
	WRAPPER_READ(wrapper, "CvUnit", (int*)&m_transportUnit.eOwner);
	WRAPPER_READ(wrapper, "CvUnit", &m_transportUnit.iID);

	WRAPPER_READ_ARRAY(wrapper, "CvUnit", NUM_DOMAIN_TYPES, m_aiExtraDomainModifier);

	WRAPPER_READ_STRING(wrapper, "CvUnit", m_szName);
	WRAPPER_READ_STRING(wrapper, "CvUnit", m_szScriptData);


	// Read compressed data format
	for(iI = 0; iI < GC.getNumPromotionInfos(); iI++)
	{
		g_pabTempHasPromotion[iI] = false;
	}
	do
	{
		iI= -1;
		WRAPPER_READ_DECORATED(wrapper, "CvUnit", &iI, "hasPromotion");
		if (iI != -1)
		{
			const int iNewIndex = wrapper.getNewClassEnumValue(REMAPPED_CLASS_TYPE_PROMOTIONS, iI, true);

			if (iNewIndex != NO_PROMOTION)
			{
				g_pabTempHasPromotion[iNewIndex] = true;
			}
		}
	} while(iI != -1);


	for (iI = 0; iI < GC.getNumPromotionInfos(); iI++)
	{
		if (g_pabTempHasPromotion[iI])
		{
			if (!GC.getPromotionInfo((PromotionTypes)iI).isRemoveAfterSet())
			{
				findOrCreatePromotionKeyedInfo((PromotionTypes)iI)->m_bHasPromotion = true;
			}

			if (GC.getPromotionInfo((PromotionTypes)iI).getPromotionLine() != NO_PROMOTIONLINE
			&& !GC.getPromotionInfo((PromotionTypes)iI).isEquipment()
#ifdef OUTBREAKS_AND_AFFLICTIONS
			&& !GC.getPromotionInfo((PromotionTypes)iI).isAffliction()
#endif
			&& !GC.getPromotionInfo((PromotionTypes)iI).isStatus())
			{
				//	All lesser priority promotions on the same line are implied - make sure they are set
				for (int iJ = 0; iJ < GC.getNumPromotionInfos(); iJ++)
				{
					if (GC.getPromotionInfo((PromotionTypes)iJ).getPromotionLine() == GC.getPromotionInfo((PromotionTypes)iI).getPromotionLine()
					&& GC.getPromotionInfo((PromotionTypes)iI).getLinePriority() > GC.getPromotionInfo((PromotionTypes)iJ).getLinePriority())
					{
						//	Set the map directly not via a call to setHasPromotion because the older versions
						//	would have the effect of the promotion already even though the flag was not set
						findOrCreatePromotionKeyedInfo((PromotionTypes)iI)->m_bHasPromotion = true;
					}
				}
			}
		}
	}

	do
	{
		iI = -1;
		WRAPPER_READ_DECORATED(wrapper, "CvUnit", &iI, "hasTerrainInfo");
		if (iI != -1)
		{
			const int iNewIndex = wrapper.getNewClassEnumValue(REMAPPED_CLASS_TYPE_TERRAINS, iI, true);

			if (iNewIndex != NO_TERRAIN)
			{
				TerrainKeyedInfo* info = findOrCreateTerrainKeyedInfo((TerrainTypes)iNewIndex);

				WRAPPER_READ_DECORATED(wrapper, "CvUnit", &info->m_iTerrainProtected, "TerrainProtected");
				WRAPPER_READ_DECORATED(wrapper, "CvUnit", &info->m_iTerrainDoubleMoveCount, "TerrainDoubleMove");
				WRAPPER_READ_DECORATED(wrapper, "CvUnit", &info->m_iExtraTerrainAttackPercent, "extraAttackPercent");
				WRAPPER_READ_DECORATED(wrapper, "CvUnit", &info->m_iExtraTerrainDefensePercent, "extraDefensePercent");
				// SAVEBREAK - Toffer - Remove
				WRAPPER_SKIP_ELEMENT(wrapper, "CvUnit", terrainWorkPercent, SAVE_VALUE_TYPE_INT);
				// ! SAVEBREAK
				WRAPPER_READ_DECORATED(wrapper, "CvUnit", &info->m_iExtraTerrainWorkPercent, "terrainExtraWorkPercent");
				WRAPPER_READ_DECORATED(wrapper, "CvUnit", &info->m_iExtraWithdrawOnTerrainType, "extraWithdrawOnTerrainType");
			}
		}
	} while(iI != -1);

	do
	{
		iI = -1;
		WRAPPER_READ_DECORATED(wrapper, "CvUnit", &iI, "hasFeatureInfo");
		if (iI != -1)
		{
			const int iNewIndex = wrapper.getNewClassEnumValue(REMAPPED_CLASS_TYPE_FEATURES, iI, true);

			if (iNewIndex != NO_FEATURE)
			{
				FeatureKeyedInfo* info = findOrCreateFeatureKeyedInfo((FeatureTypes)iNewIndex);

				WRAPPER_READ_DECORATED(wrapper, "CvUnit", &info->m_iFeatureDoubleMoveCount, "FeatureDoubleMove");
				WRAPPER_READ_DECORATED(wrapper, "CvUnit", &info->m_iExtraFeatureAttackPercent, "extraAttackPercent");
				WRAPPER_READ_DECORATED(wrapper, "CvUnit", &info->m_iExtraFeatureDefensePercent, "extraDefensePercent");
				// SAVEBREAK - Toffer - Remove
				WRAPPER_SKIP_ELEMENT(wrapper, "CvUnit", featureWorkPercent, SAVE_VALUE_TYPE_INT);
				// ! SAVEBREAK
				WRAPPER_READ_DECORATED(wrapper, "CvUnit", &info->m_iExtraFeatureWorkPercent, "featureExtraWorkPercent");
				WRAPPER_READ_DECORATED(wrapper, "CvUnit", &info->m_iExtraWithdrawOnFeatureType, "extraWithdrawOnFeatureType");
			}
		}
	} while(iI != -1);

	for(iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
	{
		g_paiTempExtraUnitCombatModifier[iI] = 0;
	}
	do
	{
		iI= -1;
		WRAPPER_READ_DECORATED(wrapper, "CvUnit", &iI, "hasUnitCombatInfo");
		if ( iI != -1 )
		{
			int iNewIndex = wrapper.getNewClassEnumValue(REMAPPED_CLASS_TYPE_COMBATINFOS, iI, true);

			if ( iNewIndex != NO_UNITCOMBAT )
			{
				WRAPPER_READ_DECORATED(wrapper, "CvUnit", &g_paiTempExtraUnitCombatModifier[iNewIndex], "ExtraUnitCombatMod");
			}
		}
	} while(iI != -1);

	for(iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
	{
		if ( g_paiTempExtraUnitCombatModifier[iI] != 0 )
		{
			UnitCombatKeyedInfo* info = findOrCreateUnitCombatKeyedInfo((UnitCombatTypes)iI);

			info->m_iExtraUnitCombatModifier = g_paiTempExtraUnitCombatModifier[iI];
		}
	}

	m_Properties.readWrapper(pStream);

	//TB Combat Mods Begin  TB SubCombat Mods Begin
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraPursuit);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraEarlyWithdraw);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraVSBarbs);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraArmor);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraPuncture);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraOverrun);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraRepel);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraFortRepel);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraRepelRetries);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraUnyielding);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraKnockback);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraKnockbackRetries);
	WRAPPER_READ(wrapper, "CvUnit", &m_iStampedeCount);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraStrAdjperRnd);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraStrAdjperAtt);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraStrAdjperDef);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraWithdrawAdjperAtt);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraUnnerve);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraEnclose);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraLunge);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraDynamicDefense);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraStrength);
	WRAPPER_READ(wrapper, "CvUnit", &m_iAnimalIgnoresBordersCount);
	WRAPPER_READ(wrapper, "CvUnit", &m_iOnslaughtCount);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraFortitude);

	// Read compressed data format
	for(iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
	{
		g_paiTempSubCombatTypeCount[iI] = 0;
	}
	do
	{
		iI= -1;
		WRAPPER_READ_DECORATED(wrapper, "CvUnit", &iI, "hasUnitCombatInfo2");
		if (iI != -1)
		{
			int iNewIndex = wrapper.getNewClassEnumValue(REMAPPED_CLASS_TYPE_COMBATINFOS, iI, true);

			if (iNewIndex != NO_UNITCOMBAT)
			{
				WRAPPER_READ_DECORATED(wrapper, "CvUnit", &g_paiTempSubCombatTypeCount[iNewIndex], "subCombatCount");
			}
		}
	} while(iI != -1);

	for (iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
	{
		if (g_paiTempSubCombatTypeCount[iI] != 0)
		{
			UnitCombatKeyedInfo* info = findOrCreateUnitCombatKeyedInfo((UnitCombatTypes)iI);

			info->m_iSubCombatTypeCount = g_paiTempSubCombatTypeCount[iI];
		}
	}

	for (iI = 0; iI < GC.getNumPromotionInfos(); iI++)
	{
		g_paiTempAfflictOnAttackCount[iI] = 0;
		g_paiTempCureAfflictionCount[iI] = 0;
		g_paiTempAfflictionTurnCount[iI] = 0;
		g_paiTempAfflictionHitCount[iI] = 0;
		g_paiTempAfflictionTolerance[iI] = 0;
		g_paiTempFortitudeModifierTypeAmount[iI] = 0;
		g_paiTempTrapSetWithPromotionCount[iI] = 0;
		g_paiTempPromotionFromTraitCount[iI] = 0;
	}
	do
	{
		iI= -1;
		WRAPPER_READ_DECORATED(wrapper, "CvUnit", &iI, "hasAfflicationInfo");
		if ( iI != -1 )
		{
			int iNewIndex = wrapper.getNewClassEnumValue(REMAPPED_CLASS_TYPE_PROMOTIONS, iI, true);

			if ( iNewIndex != NO_PROMOTION )
			{
				WRAPPER_READ_DECORATED(wrapper, "CvUnit", &g_paiTempAfflictOnAttackCount[iNewIndex], "afflictOnAttack");
				WRAPPER_READ_DECORATED(wrapper, "CvUnit", &g_paiTempCureAfflictionCount[iNewIndex], "cureAffliction");
				WRAPPER_READ_DECORATED(wrapper, "CvUnit", &g_paiTempAfflictionTurnCount[iNewIndex], "afflictionTurn");
				WRAPPER_READ_DECORATED(wrapper, "CvUnit", &g_paiTempAfflictionHitCount[iNewIndex], "afflictionHit");
				WRAPPER_READ_DECORATED(wrapper, "CvUnit", &g_paiTempAfflictionTolerance[iNewIndex], "afflictionTolerance");
				WRAPPER_READ_DECORATED(wrapper, "CvUnit", &g_paiTempFortitudeModifierTypeAmount[iNewIndex], "fortitudeModifierType");
				WRAPPER_READ_DECORATED(wrapper, "CvUnit", &g_paiTempTrapSetWithPromotionCount[iNewIndex], "trapSetWithPromotionType");
				WRAPPER_READ_DECORATED(wrapper, "CvUnit", &g_paiTempPromotionFromTraitCount[iNewIndex], "promotionFromTraitCount");
			}
		}
	} while(iI != -1);

	for(iI = 0; iI < GC.getNumPromotionInfos(); iI++)
	{
		if (
		   0 != g_paiTempAfflictOnAttackCount[iI]
		|| 0 != g_paiTempCureAfflictionCount[iI]
		|| 0 != g_paiTempAfflictionTurnCount[iI]
		|| 0 != g_paiTempAfflictionHitCount[iI]
		|| 0 != g_paiTempAfflictionTolerance[iI]
		|| 0 != g_paiTempFortitudeModifierTypeAmount[iI]
		|| 0 != g_paiTempTrapSetWithPromotionCount[iI]
		|| 0 != g_paiTempPromotionFromTraitCount[iI])
		{
			PromotionKeyedInfo* info = findOrCreatePromotionKeyedInfo((PromotionTypes)iI);

			info->m_iAfflictOnAttackCount = g_paiTempAfflictOnAttackCount[iI];
			info->m_iCureAfflictionCount = g_paiTempCureAfflictionCount[iI];
			info->m_iAfflictionTurnCount = g_paiTempAfflictionTurnCount[iI];
			info->m_iAfflictionHitCount = g_paiTempAfflictionHitCount[iI];
			info->m_iAfflictionTolerance = g_paiTempAfflictionTolerance[iI];
			info->m_iFortitudeModifierTypeAmount = g_paiTempFortitudeModifierTypeAmount[iI];
			info->m_iTrapSetWithPromotionCount = g_paiTempTrapSetWithPromotionCount[iI];
			info->m_iPromotionFromTraitCount = g_paiTempPromotionFromTraitCount[iI];
		}
	}

	WRAPPER_READ(wrapper, "CvUnit", &m_iRoundCount);
	WRAPPER_READ(wrapper, "CvUnit", &m_iAttackCount);
	WRAPPER_READ(wrapper, "CvUnit", &m_iDefenseCount);

#ifdef STRENGTH_IN_NUMBERS
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraFrontSupportPercent);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraShortRangeSupportPercent);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraMediumRangeSupportPercent);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraLongRangeSupportPercent);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraFlankSupportPercent);
	WRAPPER_READ(wrapper, "CvUnit", &m_iSupportCount);
	WRAPPER_READ(wrapper, "CvUnit", &m_iAttackFromPlotX);
	WRAPPER_READ(wrapper, "CvUnit", &m_iAttackFromPlotY);
	WRAPPER_READ(wrapper, "CvUnit", (int*)&afIUnit.eOwner);
	WRAPPER_READ(wrapper, "CvUnit", &afIUnit.iID);
	WRAPPER_READ(wrapper, "CvUnit", (int*)&afIIUnit.eOwner);
	WRAPPER_READ(wrapper, "CvUnit", &afIIUnit.iID);
	WRAPPER_READ(wrapper, "CvUnit", (int*)&asrIUnit.eOwner);
	WRAPPER_READ(wrapper, "CvUnit", &asrIUnit.iID);
	WRAPPER_READ(wrapper, "CvUnit", (int*)&asrIIUnit.eOwner);
	WRAPPER_READ(wrapper, "CvUnit", &asrIIUnit.iID);
	WRAPPER_READ(wrapper, "CvUnit", (int*)&amrIUnit.eOwner);
	WRAPPER_READ(wrapper, "CvUnit", &amrIUnit.iID);
	WRAPPER_READ(wrapper, "CvUnit", (int*)&amrIIUnit.eOwner);
	WRAPPER_READ(wrapper, "CvUnit", &amrIIUnit.iID);
	WRAPPER_READ(wrapper, "CvUnit", (int*)&alrIUnit.eOwner);
	WRAPPER_READ(wrapper, "CvUnit", &alrIUnit.iID);
	WRAPPER_READ(wrapper, "CvUnit", (int*)&alrIIUnit.eOwner);
	WRAPPER_READ(wrapper, "CvUnit", &alrIIUnit.iID);
	WRAPPER_READ(wrapper, "CvUnit", (int*)&aflIUnit.eOwner);
	WRAPPER_READ(wrapper, "CvUnit", &aflIUnit.iID);
	WRAPPER_READ(wrapper, "CvUnit", (int*)&aflIIUnit.eOwner);
	WRAPPER_READ(wrapper, "CvUnit", &aflIIUnit.iID);
	WRAPPER_READ(wrapper, "CvUnit", (int*)&dfIUnit.eOwner);
	WRAPPER_READ(wrapper, "CvUnit", &dfIUnit.iID);
	WRAPPER_READ(wrapper, "CvUnit", (int*)&dfIIUnit.eOwner);
	WRAPPER_READ(wrapper, "CvUnit", &dfIIUnit.iID);
	WRAPPER_READ(wrapper, "CvUnit", (int*)&dsrIUnit.eOwner);
	WRAPPER_READ(wrapper, "CvUnit", &dsrIUnit.iID);
	WRAPPER_READ(wrapper, "CvUnit", (int*)&dsrIIUnit.eOwner);
	WRAPPER_READ(wrapper, "CvUnit", &dsrIIUnit.iID);
	WRAPPER_READ(wrapper, "CvUnit", (int*)&dmrIUnit.eOwner);
	WRAPPER_READ(wrapper, "CvUnit", &dmrIUnit.iID);
	WRAPPER_READ(wrapper, "CvUnit", (int*)&dmrIIUnit.eOwner);
	WRAPPER_READ(wrapper, "CvUnit", &dmrIIUnit.iID);
	WRAPPER_READ(wrapper, "CvUnit", (int*)&dlrIUnit.eOwner);
	WRAPPER_READ(wrapper, "CvUnit", &dlrIUnit.iID);
	WRAPPER_READ(wrapper, "CvUnit", (int*)&dlrIIUnit.eOwner);
	WRAPPER_READ(wrapper, "CvUnit", &dlrIIUnit.iID);
	WRAPPER_READ(wrapper, "CvUnit", (int*)&dflIUnit.eOwner);
	WRAPPER_READ(wrapper, "CvUnit", &dflIUnit.iID);
	WRAPPER_READ(wrapper, "CvUnit", (int*)&dflIIUnit.eOwner);
	WRAPPER_READ(wrapper, "CvUnit", &dflIIUnit.iID);
#else
	WRAPPER_SKIP_ELEMENT(wrapper, "CvUnit", m_iExtraFrontSupportPercent, SAVE_VALUE_TYPE_INT);
	WRAPPER_SKIP_ELEMENT(wrapper, "CvUnit", m_iExtraShortRangeSupportPercent, SAVE_VALUE_TYPE_INT);
	WRAPPER_SKIP_ELEMENT(wrapper, "CvUnit", m_iExtraMediumRangeSupportPercent, SAVE_VALUE_TYPE_INT);
	WRAPPER_SKIP_ELEMENT(wrapper, "CvUnit", m_iExtraLongRangeSupportPercent, SAVE_VALUE_TYPE_INT);
	WRAPPER_SKIP_ELEMENT(wrapper, "CvUnit", m_iExtraFlankSupportPercent, SAVE_VALUE_TYPE_INT);
	WRAPPER_SKIP_ELEMENT(wrapper, "CvUnit", m_iSupportCount, SAVE_VALUE_TYPE_INT);
	WRAPPER_SKIP_ELEMENT(wrapper, "CvUnit", m_iAttackFromPlotX, SAVE_VALUE_TYPE_INT);
	WRAPPER_SKIP_ELEMENT(wrapper, "CvUnit", m_iAttackFromPlotY, SAVE_VALUE_TYPE_INT);

	WRAPPER_SKIP_ELEMENT(wrapper, "CvUnit", (int*)afIUnit.eOwner, SAVE_VALUE_TYPE_INT);
	WRAPPER_SKIP_ELEMENT(wrapper, "CvUnit", afIUnit.iID, SAVE_VALUE_TYPE_INT);
	WRAPPER_SKIP_ELEMENT(wrapper, "CvUnit", (int*)afIIUnit.eOwner, SAVE_VALUE_TYPE_INT);
	WRAPPER_SKIP_ELEMENT(wrapper, "CvUnit", afIIUnit.iID, SAVE_VALUE_TYPE_INT);
	WRAPPER_SKIP_ELEMENT(wrapper, "CvUnit", (int*)asrIUnit.eOwner, SAVE_VALUE_TYPE_INT);
	WRAPPER_SKIP_ELEMENT(wrapper, "CvUnit", asrIUnit.iID, SAVE_VALUE_TYPE_INT);
	WRAPPER_SKIP_ELEMENT(wrapper, "CvUnit", (int*)asrIIUnit.eOwner, SAVE_VALUE_TYPE_INT);
	WRAPPER_SKIP_ELEMENT(wrapper, "CvUnit", asrIIUnit.iID, SAVE_VALUE_TYPE_INT);
	WRAPPER_SKIP_ELEMENT(wrapper, "CvUnit", (int*)amrIUnit.eOwner, SAVE_VALUE_TYPE_INT);
	WRAPPER_SKIP_ELEMENT(wrapper, "CvUnit", amrIUnit.iID, SAVE_VALUE_TYPE_INT);
	WRAPPER_SKIP_ELEMENT(wrapper, "CvUnit", (int*)amrIIUnit.eOwner, SAVE_VALUE_TYPE_INT);
	WRAPPER_SKIP_ELEMENT(wrapper, "CvUnit", amrIIUnit.iID, SAVE_VALUE_TYPE_INT);
	WRAPPER_SKIP_ELEMENT(wrapper, "CvUnit", (int*)alrIUnit.eOwner, SAVE_VALUE_TYPE_INT);
	WRAPPER_SKIP_ELEMENT(wrapper, "CvUnit", alrIUnit.iID, SAVE_VALUE_TYPE_INT);
	WRAPPER_SKIP_ELEMENT(wrapper, "CvUnit", (int*)alrIIUnit.eOwner, SAVE_VALUE_TYPE_INT);
	WRAPPER_SKIP_ELEMENT(wrapper, "CvUnit", alrIIUnit.iID, SAVE_VALUE_TYPE_INT);
	WRAPPER_SKIP_ELEMENT(wrapper, "CvUnit", (int*)aflIUnit.eOwner, SAVE_VALUE_TYPE_INT);
	WRAPPER_SKIP_ELEMENT(wrapper, "CvUnit", aflIUnit.iID, SAVE_VALUE_TYPE_INT);
	WRAPPER_SKIP_ELEMENT(wrapper, "CvUnit", (int*)aflIIUnit.eOwner, SAVE_VALUE_TYPE_INT);
	WRAPPER_SKIP_ELEMENT(wrapper, "CvUnit", aflIIUnit.iID, SAVE_VALUE_TYPE_INT);
	WRAPPER_SKIP_ELEMENT(wrapper, "CvUnit", (int*)dfIUnit.eOwner, SAVE_VALUE_TYPE_INT);
	WRAPPER_SKIP_ELEMENT(wrapper, "CvUnit", dfIUnit.iID, SAVE_VALUE_TYPE_INT);
	WRAPPER_SKIP_ELEMENT(wrapper, "CvUnit", (int*)dfIIUnit.eOwner, SAVE_VALUE_TYPE_INT);
	WRAPPER_SKIP_ELEMENT(wrapper, "CvUnit", dfIIUnit.iID, SAVE_VALUE_TYPE_INT);
	WRAPPER_SKIP_ELEMENT(wrapper, "CvUnit", (int*)dsrIUnit.eOwner, SAVE_VALUE_TYPE_INT);
	WRAPPER_SKIP_ELEMENT(wrapper, "CvUnit", dsrIUnit.iID, SAVE_VALUE_TYPE_INT);
	WRAPPER_SKIP_ELEMENT(wrapper, "CvUnit", (int*)dsrIIUnit.eOwner, SAVE_VALUE_TYPE_INT);
	WRAPPER_SKIP_ELEMENT(wrapper, "CvUnit", dsrIIUnit.iID, SAVE_VALUE_TYPE_INT);
	WRAPPER_SKIP_ELEMENT(wrapper, "CvUnit", (int*)dmrIUnit.eOwner, SAVE_VALUE_TYPE_INT);
	WRAPPER_SKIP_ELEMENT(wrapper, "CvUnit", dmrIUnit.iID, SAVE_VALUE_TYPE_INT);
	WRAPPER_SKIP_ELEMENT(wrapper, "CvUnit", (int*)dmrIIUnit.eOwner, SAVE_VALUE_TYPE_INT);
	WRAPPER_SKIP_ELEMENT(wrapper, "CvUnit", dmrIIUnit.iID, SAVE_VALUE_TYPE_INT);
	WRAPPER_SKIP_ELEMENT(wrapper, "CvUnit", (int*)dlrIUnit.eOwner, SAVE_VALUE_TYPE_INT);
	WRAPPER_SKIP_ELEMENT(wrapper, "CvUnit", dlrIUnit.iID, SAVE_VALUE_TYPE_INT);
	WRAPPER_SKIP_ELEMENT(wrapper, "CvUnit", (int*)dlrIIUnit.eOwner, SAVE_VALUE_TYPE_INT);
	WRAPPER_SKIP_ELEMENT(wrapper, "CvUnit", dlrIIUnit.iID, SAVE_VALUE_TYPE_INT);
	WRAPPER_SKIP_ELEMENT(wrapper, "CvUnit", (int*)dflIUnit.eOwner, SAVE_VALUE_TYPE_INT);
	WRAPPER_SKIP_ELEMENT(wrapper, "CvUnit", dflIUnit.iID, SAVE_VALUE_TYPE_INT);
	WRAPPER_SKIP_ELEMENT(wrapper, "CvUnit", (int*)dflIIUnit.eOwner, SAVE_VALUE_TYPE_INT);
	WRAPPER_SKIP_ELEMENT(wrapper, "CvUnit", dflIIUnit.iID, SAVE_VALUE_TYPE_INT);
#endif // STRENGTH_IN_NUMBERS

	// Read compressed data format
	for (iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
	{
		g_paiTempOngoingTrainingCount[iI] = 0;
		g_paiTempHealUnitCombatTypeVolume[iI] = 0;
		g_paiTempHealUnitCombatTypeAdjacentVolume[iI] = 0;
		g_paiTempTrapImmunityUnitCombatCount[iI] = 0;
		g_paiTempTargetUnitCombatCount[iI] = 0;
		g_paiTempExtraTrapDisableUnitCombatType[iI] = 0;
		g_paiTempExtraTrapAvoidanceUnitCombatType[iI] = 0;
		g_paiTempExtraTrapTriggerUnitCombatType[iI] = 0;
	}
	do
	{
		iI= -1;
		WRAPPER_READ_DECORATED(wrapper, "CvUnit", &iI, "hasUnitCombatInfo3");
		if ( iI != -1 )
		{
			int iNewIndex = wrapper.getNewClassEnumValue(REMAPPED_CLASS_TYPE_COMBATINFOS, iI, true);

			if ( iNewIndex != NO_UNITCOMBAT )
			{
				WRAPPER_READ_DECORATED(wrapper, "CvUnit", &g_paiTempOngoingTrainingCount[iNewIndex], "ongoingTrainingCount");
				WRAPPER_READ_DECORATED(wrapper, "CvUnit", &g_paiTempHealUnitCombatTypeVolume[iNewIndex], "healUnitCombatTypeVolume");
				WRAPPER_READ_DECORATED(wrapper, "CvUnit", &g_paiTempHealUnitCombatTypeAdjacentVolume[iNewIndex], "healUnitCombatTypeAdjacentVolume");
				WRAPPER_READ_DECORATED(wrapper, "CvUnit", &g_paiTempTrapImmunityUnitCombatCount[iNewIndex], "trapImmunityUnitCombatCount");
				WRAPPER_READ_DECORATED(wrapper, "CvUnit", &g_paiTempTargetUnitCombatCount[iNewIndex], "targetUnitCombatCount");
				WRAPPER_READ_DECORATED(wrapper, "CvUnit", &g_paiTempExtraTrapDisableUnitCombatType[iNewIndex], "extraTrapDisableUnitCombatType");
				WRAPPER_READ_DECORATED(wrapper, "CvUnit", &g_paiTempExtraTrapAvoidanceUnitCombatType[iNewIndex], "extraTrapAvoidanceUnitCombatType");
				WRAPPER_READ_DECORATED(wrapper, "CvUnit", &g_paiTempExtraTrapTriggerUnitCombatType[iNewIndex], "extraTrapTriggerUnitCombatType");
			}
		}
	} while(iI != -1);

	for(iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
	{
		if ( g_paiTempOngoingTrainingCount[iI] != 0
			|| g_paiTempHealUnitCombatTypeVolume[iI] != 0
			|| g_paiTempHealUnitCombatTypeAdjacentVolume[iI] != 0
			|| g_paiTempTrapImmunityUnitCombatCount[iI] != 0
			|| g_paiTempTargetUnitCombatCount[iI] != 0
			|| g_paiTempExtraTrapDisableUnitCombatType[iI] != 0
			|| g_paiTempExtraTrapAvoidanceUnitCombatType[iI] != 0
			|| g_paiTempExtraTrapTriggerUnitCombatType[iI] != 0)
		{
			UnitCombatKeyedInfo* info = findOrCreateUnitCombatKeyedInfo((UnitCombatTypes)iI);

			info->m_iOngoingTrainingCount = g_paiTempOngoingTrainingCount[iI];
			info->m_iHealUnitCombatTypeVolume = g_paiTempHealUnitCombatTypeVolume[iI];
			info->m_iHealUnitCombatTypeAdjacentVolume = g_paiTempHealUnitCombatTypeAdjacentVolume[iI];
			info->m_iTrapImmunityUnitCombatCount = g_paiTempTrapImmunityUnitCombatCount[iI];
			info->m_iTargetUnitCombatCount = g_paiTempTargetUnitCombatCount[iI];
			info->m_iExtraTrapDisableUnitCombatType = g_paiTempExtraTrapDisableUnitCombatType[iI];
			info->m_iExtraTrapAvoidanceUnitCombatType = g_paiTempExtraTrapAvoidanceUnitCombatType[iI];
			info->m_iExtraTrapTriggerUnitCombatType = g_paiTempExtraTrapTriggerUnitCombatType[iI];
		}
	}

	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraDodgeModifier);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraPrecisionModifier);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraPowerShots);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraPowerShotCombatModifier);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraPowerShotPunctureModifier);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraPowerShotPrecisionModifier);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraPowerShotCriticalModifier);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraCriticalModifier);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraEndurance);
	WRAPPER_READ(wrapper, "CvUnit", &m_iColdDamage);
	WRAPPER_READ(wrapper, "CvUnit", &m_iDealColdDamageCount);
	WRAPPER_READ(wrapper, "CvUnit", &m_iColdImmuneCount);
	WRAPPER_READ(wrapper, "CvUnit", &m_iCombatPowerShots);

	// Read compressed data format
	for(iI = 0; iI < GC.getNumPromotionInfos(); iI++)
	{
		g_paiTempPromotionFreeCount[iI] = 0;
	}
	do
	{
		iI= -1;
		WRAPPER_READ_DECORATED(wrapper, "CvUnit", &iI, "hasFreePromotionCount");
		if ( iI != -1 )
		{
			int iNewIndex = wrapper.getNewClassEnumValue(REMAPPED_CLASS_TYPE_PROMOTIONS, iI, true);

			if ( iNewIndex != NO_PROMOTION )
			{
				WRAPPER_READ_DECORATED(wrapper, "CvUnit", &g_paiTempPromotionFreeCount[iNewIndex], "FreePromoCount");
			}
		}
	} while(iI != -1);

	for(iI = 0; iI < GC.getNumPromotionInfos(); iI++)
	{
		if ( g_paiTempPromotionFreeCount[iI] != 0 )
		{
			PromotionKeyedInfo* info = findOrCreatePromotionKeyedInfo((PromotionTypes)iI);

			info->m_iPromotionFreeCount = g_paiTempPromotionFreeCount[iI];
		}
	}
	WRAPPER_READ(wrapper, "CvUnit", &m_iCombatKnockbacks);
	WRAPPER_READ(wrapper, "CvUnit", &m_iCombatRepels);

	// Read compressed data format
	for(iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
	{
		g_paiTempRemovesUnitCombatTypeCount[iI] = 0;
	}
	do
	{
		iI= -1;
		WRAPPER_READ_DECORATED(wrapper, "CvUnit", &iI, "hasUnitCombatInfo4");
		if ( iI != -1 )
		{
			int iNewIndex = wrapper.getNewClassEnumValue(REMAPPED_CLASS_TYPE_COMBATINFOS, iI, true);

			if ( iNewIndex != NO_UNITCOMBAT )
			{
				WRAPPER_READ_DECORATED(wrapper, "CvUnit", &g_paiTempRemovesUnitCombatTypeCount[iNewIndex], "removesUnitCombatCount");
			}
		}
	} while(iI != -1);

	for(iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
	{
		if ( g_paiTempRemovesUnitCombatTypeCount[iI] != 0 )
		{
			UnitCombatKeyedInfo* info = findOrCreateUnitCombatKeyedInfo((UnitCombatTypes)iI);

			info->m_iRemovesUnitCombatTypeCount = g_paiTempRemovesUnitCombatTypeCount[iI];
		}
	}

	// Read compressed data format
	for(iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
	{
		g_paiTempExtraFlankingStrengthbyUnitCombatType[iI] = 0;
	}
	do
	{
		iI= -1;
		WRAPPER_READ_DECORATED(wrapper, "CvUnit", &iI, "hasUnitCombatInfo5");
		if ( iI != -1 )
		{
			int iNewIndex = wrapper.getNewClassEnumValue(REMAPPED_CLASS_TYPE_COMBATINFOS, iI, true);

			if ( iNewIndex != NO_UNITCOMBAT )
			{
				WRAPPER_READ_DECORATED(wrapper, "CvUnit", &g_paiTempExtraFlankingStrengthbyUnitCombatType[iNewIndex], "extraFlankingStrengthbyUnitCombatType");
			}
		}
	} while(iI != -1);

	for(iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
	{
		if ( g_paiTempExtraFlankingStrengthbyUnitCombatType[iI] != 0 )
		{
			UnitCombatKeyedInfo* info = findOrCreateUnitCombatKeyedInfo((UnitCombatTypes)iI);

			info->m_iExtraFlankingStrengthbyUnitCombatType = g_paiTempExtraFlankingStrengthbyUnitCombatType[iI];
		}
	}

	// Read compressed data format
	for(iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
	{
		g_paiTempExtraWithdrawVSUnitCombatType[iI] = 0;
	}
	do
	{
		iI= -1;
		WRAPPER_READ_DECORATED(wrapper, "CvUnit", &iI, "hasUnitCombatInfo6");
		if ( iI != -1 )
		{
			int iNewIndex = wrapper.getNewClassEnumValue(REMAPPED_CLASS_TYPE_COMBATINFOS, iI, true);

			if ( iNewIndex != NO_UNITCOMBAT )
			{
				WRAPPER_READ_DECORATED(wrapper, "CvUnit", &g_paiTempExtraWithdrawVSUnitCombatType[iNewIndex], "extraWithdrawVSUnitCombatType");
			}
		}
	} while(iI != -1);

	for(iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
	{
		if ( g_paiTempExtraWithdrawVSUnitCombatType[iI] != 0 )
		{
			UnitCombatKeyedInfo* info = findOrCreateUnitCombatKeyedInfo((UnitCombatTypes)iI);

			info->m_iExtraWithdrawVSUnitCombatType = g_paiTempExtraWithdrawVSUnitCombatType[iI];
		}
	}

	// Read compressed data format
	for(iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
	{
		g_paiTempExtraRepelVSUnitCombatType[iI] = 0;
	}
	do
	{
		iI= -1;
		WRAPPER_READ_DECORATED(wrapper, "CvUnit", &iI, "hasUnitCombatInfo7");
		if ( iI != -1 )
		{
			int iNewIndex = wrapper.getNewClassEnumValue(REMAPPED_CLASS_TYPE_COMBATINFOS, iI, true);

			if ( iNewIndex != NO_UNITCOMBAT )
			{
				WRAPPER_READ_DECORATED(wrapper, "CvUnit", &g_paiTempExtraRepelVSUnitCombatType[iNewIndex], "extraRepelVSUnitCombatType");
			}
		}
	} while(iI != -1);

	for(iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
	{
		if ( g_paiTempExtraRepelVSUnitCombatType[iI] != 0 )
		{
			UnitCombatKeyedInfo* info = findOrCreateUnitCombatKeyedInfo((UnitCombatTypes)iI);

			info->m_iExtraRepelVSUnitCombatType = g_paiTempExtraRepelVSUnitCombatType[iI];
		}
	}

	// Read compressed data format
	for(iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
	{
		g_paiTempExtraKnockbackVSUnitCombatType[iI] = 0;
	}
	do
	{
		iI= -1;
		WRAPPER_READ_DECORATED(wrapper, "CvUnit", &iI, "hasUnitCombatInfo8");
		if ( iI != -1 )
		{
			int iNewIndex = wrapper.getNewClassEnumValue(REMAPPED_CLASS_TYPE_COMBATINFOS, iI, true);

			if ( iNewIndex != NO_UNITCOMBAT )
			{
				WRAPPER_READ_DECORATED(wrapper, "CvUnit", &g_paiTempExtraKnockbackVSUnitCombatType[iNewIndex], "extraKnockbackVSUnitCombatType");
			}
		}
	} while(iI != -1);

	for(iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
	{
		if ( g_paiTempExtraKnockbackVSUnitCombatType[iI] != 0 )
		{
			UnitCombatKeyedInfo* info = findOrCreateUnitCombatKeyedInfo((UnitCombatTypes)iI);

			info->m_iExtraKnockbackVSUnitCombatType = g_paiTempExtraKnockbackVSUnitCombatType[iI];
		}
	}

	// Read compressed data format
	for(iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
	{
		g_paiTempExtraPunctureVSUnitCombatType[iI] = 0;
	}
	do
	{
		iI= -1;
		WRAPPER_READ_DECORATED(wrapper, "CvUnit", &iI, "hasUnitCombatInfo9");
		if ( iI != -1 )
		{
			int iNewIndex = wrapper.getNewClassEnumValue(REMAPPED_CLASS_TYPE_COMBATINFOS, iI, true);

			if ( iNewIndex != NO_UNITCOMBAT )
			{
				WRAPPER_READ_DECORATED(wrapper, "CvUnit", &g_paiTempExtraPunctureVSUnitCombatType[iNewIndex], "extraPunctureVSUnitCombatType");
			}
		}
	} while(iI != -1);

	for(iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
	{
		if ( g_paiTempExtraPunctureVSUnitCombatType[iI] != 0 )
		{
			UnitCombatKeyedInfo* info = findOrCreateUnitCombatKeyedInfo((UnitCombatTypes)iI);

			info->m_iExtraPunctureVSUnitCombatType = g_paiTempExtraPunctureVSUnitCombatType[iI];
		}
	}

	// Read compressed data format
	for(iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
	{
		g_paiTempExtraArmorVSUnitCombatType[iI] = 0;
	}
	do
	{
		iI= -1;
		WRAPPER_READ_DECORATED(wrapper, "CvUnit", &iI, "hasUnitCombatInfo10");
		if ( iI != -1 )
		{
			int iNewIndex = wrapper.getNewClassEnumValue(REMAPPED_CLASS_TYPE_COMBATINFOS, iI, true);

			if ( iNewIndex != NO_UNITCOMBAT )
			{
				WRAPPER_READ_DECORATED(wrapper, "CvUnit", &g_paiTempExtraArmorVSUnitCombatType[iNewIndex], "extraArmorVSUnitCombatType");
			}
		}
	} while(iI != -1);

	for(iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
	{
		if ( g_paiTempExtraArmorVSUnitCombatType[iI] != 0 )
		{
			UnitCombatKeyedInfo* info = findOrCreateUnitCombatKeyedInfo((UnitCombatTypes)iI);

			info->m_iExtraArmorVSUnitCombatType = g_paiTempExtraArmorVSUnitCombatType[iI];
		}
	}

	// Read compressed data format
	for(iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
	{
		g_paiTempExtraDodgeVSUnitCombatType[iI] = 0;
	}
	do
	{
		iI= -1;
		WRAPPER_READ_DECORATED(wrapper, "CvUnit", &iI, "hasUnitCombatInfo11");
		if ( iI != -1 )
		{
			int iNewIndex = wrapper.getNewClassEnumValue(REMAPPED_CLASS_TYPE_COMBATINFOS, iI, true);

			if ( iNewIndex != NO_UNITCOMBAT )
			{
				WRAPPER_READ_DECORATED(wrapper, "CvUnit", &g_paiTempExtraDodgeVSUnitCombatType[iNewIndex], "extraDodgeVSUnitCombatType");
			}
		}
	} while(iI != -1);

	for(iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
	{
		if ( g_paiTempExtraDodgeVSUnitCombatType[iI] != 0 )
		{
			UnitCombatKeyedInfo* info = findOrCreateUnitCombatKeyedInfo((UnitCombatTypes)iI);

			info->m_iExtraDodgeVSUnitCombatType = g_paiTempExtraDodgeVSUnitCombatType[iI];
		}
	}

	// Read compressed data format
	for(iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
	{
		g_paiTempExtraPrecisionVSUnitCombatType[iI] = 0;
	}
	do
	{
		iI= -1;
		WRAPPER_READ_DECORATED(wrapper, "CvUnit", &iI, "hasUnitCombatInfo12");
		if ( iI != -1 )
		{
			int iNewIndex = wrapper.getNewClassEnumValue(REMAPPED_CLASS_TYPE_COMBATINFOS, iI, true);

			if ( iNewIndex != NO_UNITCOMBAT )
			{
				WRAPPER_READ_DECORATED(wrapper, "CvUnit", &g_paiTempExtraPrecisionVSUnitCombatType[iNewIndex], "extraPrecisionVSUnitCombatType");
			}
		}
	} while(iI != -1);

	for(iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
	{
		if ( g_paiTempExtraPrecisionVSUnitCombatType[iI] != 0 )
		{
			UnitCombatKeyedInfo* info = findOrCreateUnitCombatKeyedInfo((UnitCombatTypes)iI);

			info->m_iExtraPrecisionVSUnitCombatType = g_paiTempExtraPrecisionVSUnitCombatType[iI];
		}
	}

	// Read compressed data format
	for(iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
	{
		g_paiTempExtraCriticalVSUnitCombatType[iI] = 0;
	}
	do
	{
		iI= -1;
		WRAPPER_READ_DECORATED(wrapper, "CvUnit", &iI, "hasUnitCombatInfo13");
		if ( iI != -1 )
		{
			int iNewIndex = wrapper.getNewClassEnumValue(REMAPPED_CLASS_TYPE_COMBATINFOS, iI, true);

			if ( iNewIndex != NO_UNITCOMBAT )
			{
				WRAPPER_READ_DECORATED(wrapper, "CvUnit", &g_paiTempExtraCriticalVSUnitCombatType[iNewIndex], "extraCriticalVSUnitCombatType");
			}
		}
	} while(iI != -1);

	for(iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
	{
		if ( g_paiTempExtraCriticalVSUnitCombatType[iI] != 0 )
		{
			UnitCombatKeyedInfo* info = findOrCreateUnitCombatKeyedInfo((UnitCombatTypes)iI);

			info->m_iExtraCriticalVSUnitCombatType = g_paiTempExtraCriticalVSUnitCombatType[iI];
		}
	}

	// Read compressed data format
	for(iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
	{
		g_paiTempExtraRoundStunVSUnitCombatType[iI] = 0;
	}
	do
	{
		iI= -1;
		WRAPPER_READ_DECORATED(wrapper, "CvUnit", &iI, "hasUnitCombatInfo14");
		if ( iI != -1 )
		{
			int iNewIndex = wrapper.getNewClassEnumValue(REMAPPED_CLASS_TYPE_COMBATINFOS, iI, true);

			if ( iNewIndex != NO_UNITCOMBAT )
			{
				WRAPPER_READ_DECORATED(wrapper, "CvUnit", &g_paiTempExtraRoundStunVSUnitCombatType[iNewIndex], "extraRoundStunVSUnitCombatType");
			}
		}
	} while(iI != -1);

	for(iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
	{
		if ( g_paiTempExtraRoundStunVSUnitCombatType[iI] != 0 )
		{
			UnitCombatKeyedInfo* info = findOrCreateUnitCombatKeyedInfo((UnitCombatTypes)iI);

			info->m_iExtraRoundStunVSUnitCombatType = g_paiTempExtraRoundStunVSUnitCombatType[iI];
		}
	}
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraRoundStunProb);
	WRAPPER_READ(wrapper, "CvUnit", &m_iCombatStuns);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraPoisonProbabilityModifier);

	// Read compressed data format
	for(iI = 0; iI < GC.getNumPromotionLineInfos(); iI++)
	{
		g_pabTempValidBuildUp[iI] = false;
#ifdef OUTBREAKS_AND_AFFLICTIONS
		g_paiTempAfflictOnAttackTypeProbability[iI] = 0;
		g_paiTempAfflictOnAttackTypeCount[iI] = 0;
		g_paiTempAfflictOnAttackTypeImmediateCount[iI] = 0;
		g_paiTempAfflictOnAttackTypeAttemptedCount[iI] = 0;
		g_paiTempCureAfflictionTypeCount[iI] = 0;
		g_paiTempAfflictionTurnTypeCount[iI] = 0;
		g_paiTempAfflictionLineCount[iI] = 0;
		g_paiTempAfflictionTypeTolerance[iI] = 0;
		g_paiTempFortitudeModifierAmount[iI] = 0;
		g_paiTempDistanceAttackCommunicability[iI] = 0;
		g_paiTempAfflictOnAttackTypeMeleeCount[iI] = 0;
		g_paiTempAfflictOnAttackTypeDistanceCount[iI] = 0;
#endif
	}
	do
	{
		iI= -1;
		WRAPPER_READ_DECORATED(wrapper, "CvUnit", &iI, "hasAfflictOnAttackInfo");
		if ( iI != -1 )
		{
			int iNewIndex = wrapper.getNewClassEnumValue(REMAPPED_CLASS_TYPE_PROMOTIONLINES, iI, true);

			if ( iNewIndex != NO_PROMOTIONLINE )
			{
				WRAPPER_READ_DECORATED(wrapper, "CvUnit", &g_pabTempValidBuildUp[iNewIndex], "validBuildUp");
//#ifdef OUTBREAKS_AND_AFFLICTIONS
				WRAPPER_READ_DECORATED(wrapper, "CvUnit", &g_paiTempAfflictOnAttackTypeProbability[iNewIndex], "afflictOnAttackTypeProb");
				WRAPPER_READ_DECORATED(wrapper, "CvUnit", &g_paiTempAfflictOnAttackTypeCount[iNewIndex], "afflictOnAttackTypeCount");
				WRAPPER_READ_DECORATED(wrapper, "CvUnit", &g_paiTempAfflictOnAttackTypeImmediateCount[iNewIndex], "afflictOnAttackTypeImmediateCount");
				WRAPPER_READ_DECORATED(wrapper, "CvUnit", &g_paiTempAfflictOnAttackTypeAttemptedCount[iNewIndex], "afflictOnAttackTypeAttemptedCount");
				WRAPPER_READ_DECORATED(wrapper, "CvUnit", &g_paiTempCureAfflictionTypeCount[iNewIndex], "cureAfflictionType");
				WRAPPER_READ_DECORATED(wrapper, "CvUnit", &g_paiTempAfflictionTurnTypeCount[iNewIndex], "afflictionTurnType");
				WRAPPER_READ_DECORATED(wrapper, "CvUnit", &g_paiTempAfflictionLineCount[iNewIndex], "hasAfflictionLine");
				WRAPPER_READ_DECORATED(wrapper, "CvUnit", &g_paiTempAfflictionTypeTolerance[iNewIndex], "afflictionToleranceType");
				WRAPPER_READ_DECORATED(wrapper, "CvUnit", &g_paiTempFortitudeModifierAmount[iNewIndex], "fortitudeModifier");
				WRAPPER_READ_DECORATED(wrapper, "CvUnit", &g_paiTempDistanceAttackCommunicability[iNewIndex], "distanceAttackCommunicability");
				WRAPPER_READ_DECORATED(wrapper, "CvUnit", &g_paiTempAfflictOnAttackTypeMeleeCount[iNewIndex], "afflictOnAttackTypeMeleeCount");
				WRAPPER_READ_DECORATED(wrapper, "CvUnit", &g_paiTempAfflictOnAttackTypeDistanceCount[iNewIndex], "afflictOnAttackTypeDistanceCount");
//#endif
			}
		}
	} while(iI != -1);

	for(iI = 0; iI < GC.getNumPromotionLineInfos(); iI++)
	{
		bool	bNonDefaultValue =
			g_pabTempValidBuildUp[iI]
#ifdef OUTBREAKS_AND_AFFLICTIONS
			|| g_paiTempAfflictOnAttackTypeProbability[iI] != 0
			|| g_paiTempAfflictOnAttackTypeCount[iI] != 0
			|| g_paiTempAfflictOnAttackTypeImmediateCount[iI] != 0
			|| g_paiTempAfflictOnAttackTypeAttemptedCount[iI] != 0
			|| g_paiTempCureAfflictionTypeCount[iI] != 0
			|| g_paiTempAfflictionTurnTypeCount[iI] != 0
			|| g_paiTempAfflictionLineCount[iI] != 0
			|| g_paiTempAfflictionTypeTolerance[iI] != 0
			|| g_paiTempFortitudeModifierAmount[iI] != 0
			|| g_paiTempDistanceAttackCommunicability[iI] != 0
			|| g_paiTempAfflictOnAttackTypeMeleeCount[iI] != 0
			|| g_paiTempAfflictOnAttackTypeDistanceCount[iI] != 0
#endif
		;

		if ( bNonDefaultValue )
		{
			PromotionLineKeyedInfo* info = findOrCreatePromotionLineKeyedInfo((PromotionLineTypes)iI);

			info->m_bValidBuildUp = g_pabTempValidBuildUp[iI];
#ifdef OUTBREAKS_AND_AFFLICTIONS
			info->m_iAfflictOnAttackTypeProbability = g_paiTempAfflictOnAttackTypeProbability[iI];
			info->m_iAfflictOnAttackTypeCount = g_paiTempAfflictOnAttackTypeCount[iI];
			info->m_iAfflictOnAttackTypeImmediateCount = g_paiTempAfflictOnAttackTypeImmediateCount[iI];
			info->m_iAfflictOnAttackTypeAttemptedCount = g_paiTempAfflictOnAttackTypeAttemptedCount[iI];
			info->m_iCureAfflictionTypeCount = g_paiTempCureAfflictionTypeCount[iI];
			info->m_iAfflictionTurnTypeCount = g_paiTempAfflictionTurnTypeCount[iI];
			info->m_iAfflictionLineCount = g_paiTempAfflictionLineCount[iI];
			info->m_iAfflictionTypeTolerance = g_paiTempAfflictionTypeTolerance[iI];
			info->m_iFortitudeModifierAmount = g_paiTempFortitudeModifierAmount[iI];
			info->m_iDistanceAttackCommunicability = g_paiTempDistanceAttackCommunicability[iI];
			info->m_iAfflictOnAttackTypeMeleeCount = g_paiTempAfflictOnAttackTypeMeleeCount[iI];
			info->m_iAfflictOnAttackTypeDistanceCount = g_paiTempAfflictOnAttackTypeDistanceCount[iI];
#endif
		}
	}
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraAttackCombatModifier);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraDefenseCombatModifier);
	WRAPPER_READ(wrapper, "CvUnit", &m_iRetrainsAvailable);
	//TB Combat Mods End  TB SubCombat Mods End
/*****************************************************************************************************/
/**  Author: TheLadiesOgre                                                                          **/
/**  Date: 16.09.2009                                                                               **/
/**  ModComp: TLOTags                                                                               **/
/**  Reason Added: New Tag Definition                                                               **/
/**  Notes: Adapted by Thunderbrd for C2C                                                           **/
/*****************************************************************************************************/
	WRAPPER_READ(wrapper, "CvUnit", &m_iDefensiveVictoryMoveCount);
	WRAPPER_READ(wrapper, "CvUnit", &m_iFreeDropCount);
	WRAPPER_READ(wrapper, "CvUnit", &m_iOffensiveVictoryMoveCount);
	WRAPPER_READ(wrapper, "CvUnit", &m_iPillageCultureCount);
	WRAPPER_READ(wrapper, "CvUnit", &m_iPillageEspionageCount);
	WRAPPER_READ(wrapper, "CvUnit", &m_iPillageMarauderCount);
	WRAPPER_READ(wrapper, "CvUnit", &m_iPillageOnMoveCount);
	WRAPPER_READ(wrapper, "CvUnit", &m_iPillageOnVictoryCount);
	WRAPPER_READ(wrapper, "CvUnit", &m_iPillageResearchCount);
	WRAPPER_READ(wrapper, "CvUnit", &m_iAirCombatLimitChange);
	WRAPPER_READ(wrapper, "CvUnit", &m_iCelebrityHappy);
	WRAPPER_READ(wrapper, "CvUnit", &m_iCollateralDamageLimitChange);
	WRAPPER_READ(wrapper, "CvUnit", &m_iCollateralDamageMaxUnitsChange);
	WRAPPER_READ(wrapper, "CvUnit", &m_iCombatLimitChange);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraDropRange);
	WRAPPER_READ(wrapper, "CvUnit", &m_iVictoryHeal);
	WRAPPER_READ(wrapper, "CvUnit", &m_iOneUpCount);
	WRAPPER_READ(wrapper, "CvUnit", &m_iSurvivorChance);
	WRAPPER_READ(wrapper, "CvUnit", &m_iVictoryAdjacentHeal);
	WRAPPER_READ(wrapper, "CvUnit", &m_iVictoryStackHeal);
	WRAPPER_READ(wrapper, "CvUnit", &m_bSurvivor);
/*****************************************************************************************************/
/**  TheLadiesOgre; 16.09.2009; TLOTags                                                             **/
/*****************************************************************************************************/

	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraCaptureProbabilityModifier);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraCaptureResistanceModifier);

	// Read compressed data format
	for(iI = 0; iI < GC.getNumBuildInfos(); iI++)
	{
		g_paiTempExtraBuildWorkPercent[iI] = 0;
	}
	do
	{
		iI= -1;
		WRAPPER_READ_DECORATED(wrapper, "CvUnit", &iI, "hasBuildInfo");
		if ( iI != -1 )
		{
			int iNewIndex = wrapper.getNewClassEnumValue(REMAPPED_CLASS_TYPE_BUILDS, iI, true);

			if ( iNewIndex != NO_BUILD )
			{
				WRAPPER_READ_DECORATED(wrapper, "CvUnit", &g_paiTempExtraBuildWorkPercent[iNewIndex], "extraBuildWorkPercent");
			}
		}
	} while(iI != -1);

	int iExtraPeaksWorkPercent = 0;
	WRAPPER_READ_DECORATED(wrapper, "CvUnit", &iExtraPeaksWorkPercent, "m_iExtraPeaksWorkPercent");

	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraBreakdownChance);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraBreakdownDamage);

	// Read compressed data format
	for(iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
	{
		g_pabTempHasUnitCombat[iI] = false;
	}
	do
	{
		iI= -1;
		WRAPPER_READ_DECORATED(wrapper, "CvUnit", &iI, "hasUnitCombat");
		if ( iI != -1 )
		{
			int iNewIndex = wrapper.getNewClassEnumValue(REMAPPED_CLASS_TYPE_COMBATINFOS, iI, true);

			if ( iNewIndex != NO_UNITCOMBAT )
			{
				g_pabTempHasUnitCombat[iNewIndex] = true;
			}
		}
	} while(iI != -1);

	for(iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
	{
		if (g_pabTempHasUnitCombat[iI])
		{
			UnitCombatKeyedInfo* info = findOrCreateUnitCombatKeyedInfo((UnitCombatTypes)iI);

			info->m_bHasUnitCombat = true;
		}
	}

	WRAPPER_READ(wrapper, "CvUnit", &m_iAttackOnlyCitiesCount);
	WRAPPER_READ(wrapper, "CvUnit", &m_iIgnoreNoEntryLevelCount);
	WRAPPER_READ(wrapper, "CvUnit", &m_iIgnoreZoneofControlCount);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraTaunt);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraMaxHP);

	// Read compressed data format
	for(iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
	{
		g_paiTempExtraPursuitVSUnitCombatType[iI] = 0;
	}
	do
	{
		iI= -1;
		WRAPPER_READ_DECORATED(wrapper, "CvUnit", &iI, "hasUnitCombatInfo15");
		if ( iI != -1 )
		{
			int iNewIndex = wrapper.getNewClassEnumValue(REMAPPED_CLASS_TYPE_COMBATINFOS, iI, true);

			if ( iNewIndex != NO_UNITCOMBAT )
			{
				WRAPPER_READ_DECORATED(wrapper, "CvUnit", &g_paiTempExtraPursuitVSUnitCombatType[iNewIndex], "extraPursuitVSUnitCombatType");
			}
		}
	} while(iI != -1);

	for(iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
	{
		if ( g_paiTempExtraPursuitVSUnitCombatType[iI] != 0 )
		{
			UnitCombatKeyedInfo* info = findOrCreateUnitCombatKeyedInfo((UnitCombatTypes)iI);

			info->m_iExtraPursuitVSUnitCombatType = g_paiTempExtraPursuitVSUnitCombatType[iI];
		}
	}

	WRAPPER_READ(wrapper, "CvUnit", &m_iFliesToMoveCount);
	WRAPPER_READ(wrapper, "CvUnit", &m_iQualityBaseTotal);
	WRAPPER_READ(wrapper, "CvUnit", &m_iGroupBaseTotal);
	WRAPPER_READ(wrapper, "CvUnit", &m_iSizeBaseTotal);
	WRAPPER_READ(wrapper, "CvUnit", &m_iCannotMergeSplitCount);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraStrengthModifier);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraDamageModifier);

	WRAPPER_READ_CLASS_ENUM(wrapper, "CvUnit", REMAPPED_CLASS_TYPE_UNITS, (int*)&m_eGGExperienceEarnedTowardsType);
	WRAPPER_READ(wrapper, "CvUnit", &m_iSMCargo);
	WRAPPER_READ(wrapper, "CvUnit", &m_iSMCargoCapacity);
	WRAPPER_READ(wrapper, "CvUnit", &m_iSMCargoVolume);
	WRAPPER_READ(wrapper, "CvUnit", &m_iSMCargoVolumeModifier);
	WRAPPER_READ(wrapper, "CvUnit", (int*)&m_eNewDomainCargo);
	WRAPPER_READ_CLASS_ENUM_ALLOW_MISSING(wrapper, "CvUnit", REMAPPED_CLASS_TYPE_SPECIAL_UNITS, (int*)&m_eNewSpecialCargo);
	WRAPPER_READ_CLASS_ENUM_ALLOW_MISSING(wrapper, "CvUnit", REMAPPED_CLASS_TYPE_SPECIAL_UNITS, (int*)&m_eNewSMSpecialCargo);
	WRAPPER_READ_CLASS_ENUM_ALLOW_MISSING(wrapper, "CvUnit", REMAPPED_CLASS_TYPE_SPECIAL_UNITS, (int*)&m_eNewSMNotSpecialCargo);
	// SAVEBREAK - Toffer - Remove
	WRAPPER_SKIP_ELEMENT(wrapper, "CvUnit", m_iExtraPowerValue, SAVE_VALUE_TYPE_INT);
	WRAPPER_SKIP_ELEMENT(wrapper, "CvUnit", m_iExtraAssetValue, SAVE_VALUE_TYPE_INT);
	// ! SAVEBREAK
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraQuality);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraGroup);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraSize);
	WRAPPER_READ(wrapper, "CvUnit", &m_iSMStrength);
	WRAPPER_READ(wrapper, "CvUnit", &m_iSMAssetValue);
	WRAPPER_READ(wrapper, "CvUnit", &m_iSMPowerValue);
	WRAPPER_READ(wrapper, "CvUnit", &m_iSMHPValue);
	WRAPPER_READ(wrapper, "CvUnit", &m_iSMExtraCargoVolume);
	WRAPPER_READ(wrapper, "CvUnit", &m_iSMBombardRate);
	WRAPPER_READ(wrapper, "CvUnit", &m_iSMAirBombBaseRate);
	WRAPPER_READ(wrapper, "CvUnit", &m_iSMBaseWorkRate);
	WRAPPER_READ(wrapper, "CvUnit", &m_iSMRevoltProtection);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraRBombardDamage);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraRBombardDamageLimit);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraRBombardDamageMaxUnits);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraDCMBombRange);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraDCMBombAccuracy);
	WRAPPER_READ(wrapper, "CvUnit", &m_iBaseRBombardDamage);
	WRAPPER_READ(wrapper, "CvUnit", &m_iBaseRBombardDamageLimit);
	WRAPPER_READ(wrapper, "CvUnit", &m_iBaseRBombardDamageMaxUnits);
	WRAPPER_READ(wrapper, "CvUnit", &m_iBaseDCMBombRange);
	WRAPPER_READ(wrapper, "CvUnit", &m_iBaseDCMBombAccuracy);
	WRAPPER_READ(wrapper, "CvUnit", &m_iBombardDirectCount);
	WRAPPER_READ(wrapper, "CvUnit", &m_iRBombardForceAbilityCount);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraCombatModifierPerSizeMore);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraCombatModifierPerSizeLess);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraCombatModifierPerVolumeMore);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraCombatModifierPerVolumeLess);
	WRAPPER_READ(wrapper, "CvUnit", &m_iAlwaysInvisibleCount);
	WRAPPER_READ(wrapper, "CvUnit", &m_iHealUnitCombatCount);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraSelfHealModifier);
	WRAPPER_READ(wrapper, "CvUnit", &m_iNoSelfHealCount);

	// Read compressed data format
	for(iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
	{
		g_paiTempHealAsDamage[iI] = 0;
	}
	do
	{
		iI= -1;
		WRAPPER_READ_DECORATED(wrapper, "CvUnit", &iI, "healAsDamageInfo");
		if ( iI != -1 )
		{
			int iNewIndex = wrapper.getNewClassEnumValue(REMAPPED_CLASS_TYPE_COMBATINFOS, iI, true);

			if ( iNewIndex != NO_UNITCOMBAT )
			{
				WRAPPER_READ_DECORATED(wrapper, "CvUnit", &g_paiTempHealAsDamage[iNewIndex], "healAsDamage");
			}
		}
	} while(iI != -1);

	for(iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
	{
		if ( g_paiTempHealAsDamage[iI] != 0 )
		{
			UnitCombatKeyedInfo* info = findOrCreateUnitCombatKeyedInfo((UnitCombatTypes)iI);

			info->m_iHealAsDamage = g_paiTempHealAsDamage[iI];//g_paiTempSubCombatTypeCount[iI];
		}
	}

	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraNumHealSupport);
	WRAPPER_READ(wrapper, "CvUnit", &m_iHealSupportUsed);
	WRAPPER_READ_CLASS_ENUM_ALLOW_MISSING(wrapper, "CvUnit", REMAPPED_CLASS_TYPE_MISSIONS, (int*)&m_eSleepType);
	WRAPPER_READ(wrapper, "CvUnit", &m_bHasBuildUp);
	WRAPPER_READ_CLASS_ENUM(wrapper, "CvUnit", REMAPPED_CLASS_TYPE_PROMOTIONLINES, (int*)&m_eCurrentBuildUpType);
	WRAPPER_READ(wrapper, "CvUnit", &m_iZoneOfControlCount);
	WRAPPER_READ(wrapper, "CvUnit", &m_bInhibitMerge);
	WRAPPER_READ(wrapper, "CvUnit", &m_bInhibitSplit);
	WRAPPER_READ(wrapper, "CvUnit", &m_bIsBuildUp);
	WRAPPER_READ_CLASS_ENUM_ALLOW_MISSING(wrapper, "CvUnit", REMAPPED_CLASS_TYPE_SPECIAL_UNITS, (int*)&m_eSpecialUnit);
	WRAPPER_READ(wrapper, "CvUnit", &m_bHasHNCapturePromotion);
	WRAPPER_READ(wrapper, "CvUnit", (int*)&m_eCapturingUnit.eOwner);
	WRAPPER_READ(wrapper, "CvUnit", &m_eCapturingUnit.iID);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExcileCount);
	WRAPPER_READ(wrapper, "CvUnit", &m_iPassageCount);
	WRAPPER_READ(wrapper, "CvUnit", &m_iNoNonOwnedCityEntryCount);
	WRAPPER_READ(wrapper, "CvUnit", &m_iBarbCoExistCount);
	WRAPPER_READ(wrapper, "CvUnit", &m_iBlendIntoCityCount);
	WRAPPER_READ(wrapper, "CvUnit", &m_iUpgradeAnywhereCount);

	// Read compressed data format
	for(iI = 0; iI < GC.getNumInvisibleInfos(); iI++)
	{
		m_aiExtraVisibilityIntensity[iI] = 0;
		m_aiExtraInvisibilityIntensity[iI] = 0;
		m_aiExtraVisibilityIntensityRange[iI] = 0;
		m_aiNegatesInvisibleCount[iI] = 0;
		m_aiExtraVisibilityIntensitySameTile[iI] = 0;
	}
	do
	{
		iI= -1;
		WRAPPER_READ_DECORATED(wrapper, "CvUnit", &iI, "Visibilities");
		if ( iI != -1 )
		{
			int iNewIndex = wrapper.getNewClassEnumValue(REMAPPED_CLASS_TYPE_INVISIBLES, iI, true);

			if ( iNewIndex != NO_UNITCOMBAT )
			{
				WRAPPER_READ_DECORATED(wrapper, "CvUnit", &m_aiExtraVisibilityIntensity[iNewIndex], "extraVisibilityIntensity");
				WRAPPER_READ_DECORATED(wrapper, "CvUnit", &m_aiExtraInvisibilityIntensity[iNewIndex], "extraInvisibilityIntensity");
				WRAPPER_READ_DECORATED(wrapper, "CvUnit", &m_aiExtraVisibilityIntensityRange[iNewIndex], "extraVisibilityIntensityRange");
				WRAPPER_READ_DECORATED(wrapper, "CvUnit", &m_aiNegatesInvisibleCount[iNewIndex], "negatesInvisibleCount");
				WRAPPER_READ_DECORATED(wrapper, "CvUnit", &m_aiExtraVisibilityIntensitySameTile[iNewIndex], "extraVisibilityIntensitySameTile");
			}
		}
	} while(iI != -1);

	WRAPPER_READ(wrapper, "CvUnit", &m_bHasAnyInvisibility);

	int iType1 = 0;
	int iType2 = 0;
	int iType3 = 0;

	int iSize1 = 0;
	WRAPPER_READ_DECORATED(wrapper, "CvUnit", &iSize1, "m_aExtraInvisibleTerrains.size");
	m_aExtraInvisibleTerrains.resize(iSize1);
	if (iSize1 > 0)
	{
		for (iI = 0; iI < iSize1; iI++)
		{
			iType1 = 0;
			iType2 = 0;
			iType3 = 0;
			WRAPPER_READ(wrapper, "CvUnit", &iType1);
			WRAPPER_READ(wrapper, "CvUnit", &iType2);
			WRAPPER_READ(wrapper, "CvUnit", &iType3);
			m_aExtraInvisibleTerrains[iI].eInvisible = (InvisibleTypes)iType1;
			m_aExtraInvisibleTerrains[iI].eTerrain = (TerrainTypes)iType2;
			m_aExtraInvisibleTerrains[iI].iIntensity = iType3;
		}
	}

	int iSize2 = 0;
	WRAPPER_READ_DECORATED(wrapper, "CvUnit", &iSize2, "m_aExtraInvisibleFeatures.size");
	m_aExtraInvisibleFeatures.resize(iSize2);
	if (iSize2 > 0)
	{
		for (iI = 0; iI < iSize2; iI++)
		{
			iType1 = 0;
			iType2 = 0;
			iType3 = 0;
			WRAPPER_READ(wrapper, "CvUnit", &iType1);
			WRAPPER_READ(wrapper, "CvUnit", &iType2);
			WRAPPER_READ(wrapper, "CvUnit", &iType3);
			m_aExtraInvisibleFeatures[iI].eInvisible = (InvisibleTypes)iType1;
			m_aExtraInvisibleFeatures[iI].eFeature = (FeatureTypes)iType2;
			m_aExtraInvisibleFeatures[iI].iIntensity = iType3;
		}
	}

	int iSize3 = 0;
	WRAPPER_READ_DECORATED(wrapper, "CvUnit", &iSize3, "m_aExtraInvisibleImprovements.size");
	m_aExtraInvisibleImprovements.resize(iSize3);
	if (iSize3 > 0)
	{
		for (iI = 0; iI < iSize3; iI++)
		{
			iType1 = 0;
			iType2 = 0;
			iType3 = 0;
			WRAPPER_READ(wrapper, "CvUnit", &iType1);
			WRAPPER_READ(wrapper, "CvUnit", &iType2);
			WRAPPER_READ(wrapper, "CvUnit", &iType3);
			m_aExtraInvisibleImprovements[iI].eInvisible = (InvisibleTypes)iType1;
			m_aExtraInvisibleImprovements[iI].eImprovement = (ImprovementTypes)iType2;
			m_aExtraInvisibleImprovements[iI].iIntensity = iType3;
		}
	}

	int iSize4 = 0;
	WRAPPER_READ_DECORATED(wrapper, "CvUnit", &iSize4, "m_aExtraVisibleTerrains.size");
	m_aExtraVisibleTerrains.resize(iSize4);
	if (iSize4 > 0)
	{
		for (iI = 0; iI < iSize4; iI++)
		{
			iType1 = 0;
			iType2 = 0;
			iType3 = 0;
			WRAPPER_READ(wrapper, "CvUnit", &iType1);
			WRAPPER_READ(wrapper, "CvUnit", &iType2);
			WRAPPER_READ(wrapper, "CvUnit", &iType3);
			m_aExtraVisibleTerrains[iI].eInvisible = (InvisibleTypes)iType1;
			m_aExtraVisibleTerrains[iI].eTerrain = (TerrainTypes)iType2;
			m_aExtraVisibleTerrains[iI].iIntensity = iType3;
		}
	}

	int iSize5 = 0;
	WRAPPER_READ_DECORATED(wrapper, "CvUnit", &iSize5, "m_aExtraVisibleFeatures.size");
	m_aExtraVisibleFeatures.resize(iSize5);
	if (iSize5 > 0)
	{
		for (iI = 0; iI < iSize5; iI++)
		{
			iType1 = 0;
			iType2 = 0;
			iType3 = 0;
			WRAPPER_READ(wrapper, "CvUnit", &iType1);
			WRAPPER_READ(wrapper, "CvUnit", &iType2);
			WRAPPER_READ(wrapper, "CvUnit", &iType3);
			m_aExtraVisibleFeatures[iI].eInvisible = (InvisibleTypes)iType1;
			m_aExtraVisibleFeatures[iI].eFeature = (FeatureTypes)iType2;
			m_aExtraVisibleFeatures[iI].iIntensity = iType3;
		}
	}

	int iSize6 = 0;
	WRAPPER_READ_DECORATED(wrapper, "CvUnit", &iSize6, "m_aExtraVisibleImprovements.size");
	m_aExtraVisibleImprovements.resize(iSize6);
	if (iSize6 > 0)
	{
		for (iI = 0; iI < iSize6; iI++)
		{
			iType1 = 0;
			iType2 = 0;
			iType3 = 0;
			WRAPPER_READ(wrapper, "CvUnit", &iType1);
			WRAPPER_READ(wrapper, "CvUnit", &iType2);
			WRAPPER_READ(wrapper, "CvUnit", &iType3);
			m_aExtraVisibleImprovements[iI].eInvisible = (InvisibleTypes)iType1;
			m_aExtraVisibleImprovements[iI].eImprovement = (ImprovementTypes)iType2;
			m_aExtraVisibleImprovements[iI].iIntensity = iType3;
		}
	}

	int iSize7 = 0;
	WRAPPER_READ_DECORATED(wrapper, "CvUnit", &iSize7, "m_aExtraVisibleTerrainRanges.size");
	m_aExtraVisibleTerrainRanges.resize(iSize7);
	if (iSize7 > 0)
	{
		for (iI = 0; iI < iSize7; iI++)
		{
			iType1 = 0;
			iType2 = 0;
			iType3 = 0;
			WRAPPER_READ(wrapper, "CvUnit", &iType1);
			WRAPPER_READ(wrapper, "CvUnit", &iType2);
			WRAPPER_READ(wrapper, "CvUnit", &iType3);
			m_aExtraVisibleTerrainRanges[iI].eInvisible = (InvisibleTypes)iType1;
			m_aExtraVisibleTerrainRanges[iI].eTerrain = (TerrainTypes)iType2;
			m_aExtraVisibleTerrainRanges[iI].iIntensity = iType3;
		}
	}

	int iSize8 = 0;
	WRAPPER_READ_DECORATED(wrapper, "CvUnit", &iSize8, "m_aExtraVisibleFeatureRanges.size");
	m_aExtraVisibleFeatureRanges.resize(iSize8);
	if (iSize8 > 0)
	{
		for (iI = 0; iI < iSize8; iI++)
		{
			iType1 = 0;
			iType2 = 0;
			iType3 = 0;
			WRAPPER_READ(wrapper, "CvUnit", &iType1);
			WRAPPER_READ(wrapper, "CvUnit", &iType2);
			WRAPPER_READ(wrapper, "CvUnit", &iType3);
			m_aExtraVisibleFeatureRanges[iI].eInvisible = (InvisibleTypes)iType1;
			m_aExtraVisibleFeatureRanges[iI].eFeature = (FeatureTypes)iType2;
			m_aExtraVisibleFeatureRanges[iI].iIntensity = iType3;
		}
	}

	int iSize9 = 0;
	WRAPPER_READ_DECORATED(wrapper, "CvUnit", &iSize9, "m_aExtraVisibleImprovementRanges.size");
	m_aExtraVisibleImprovementRanges.resize(iSize9);
	if (iSize9 > 0)
	{
		for (iI = 0; iI < iSize9; iI++)
		{
			iType1 = 0;
			iType2 = 0;
			iType3 = 0;
			WRAPPER_READ(wrapper, "CvUnit", &iType1);
			WRAPPER_READ(wrapper, "CvUnit", &iType2);
			WRAPPER_READ(wrapper, "CvUnit", &iType3);
			m_aExtraVisibleImprovementRanges[iI].eInvisible = (InvisibleTypes)iType1;
			m_aExtraVisibleImprovementRanges[iI].eImprovement = (ImprovementTypes)iType2;
			m_aExtraVisibleImprovementRanges[iI].iIntensity = iType3;
		}
	}
	// SAVEBREAK - Toffer - Remove
	WRAPPER_SKIP_ELEMENT(wrapper, "CvUnit", m_bHasAnyInvisibilityAbility, SAVE_VALUE_TYPE_INT);
	// ! SAVEBREAK
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraInsidiousness);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraInvestigation);
	WRAPPER_READ(wrapper, "CvUnit", (int*)&m_pPlayerInvestigated);
	WRAPPER_READ(wrapper, "CvUnit", &m_iAssassinCount);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraStealthStrikes);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraStealthCombatModifier);
	WRAPPER_READ(wrapper, "CvUnit", &m_iStealthDefenseCount);
	WRAPPER_READ(wrapper, "CvUnit", &m_bRevealed);
	WRAPPER_READ(wrapper, "CvUnit", &m_iOnlyDefensiveCount);
	WRAPPER_READ(wrapper, "CvUnit", &m_iNoInvisibilityCount);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraTrapDamageMax);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraTrapDamageMin);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraTrapComplexity);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraNumTriggers);
	WRAPPER_READ(wrapper, "CvUnit", &m_iNumTimesTriggered);
	WRAPPER_READ(wrapper, "CvUnit", &m_iTriggerBeforeAttackCount);
	WRAPPER_READ(wrapper, "CvUnit", &m_bIsArmed);
	WRAPPER_READ(wrapper, "CvUnit", &m_iHiddenNationalityCount);
	WRAPPER_READ(wrapper, "CvUnit", &m_iNoCaptureCount);
	int iSize10 = 0;
	WRAPPER_READ_DECORATED(wrapper, "CvUnit", &iSize10, "m_aExtraAidChanges.size");
	if (iSize10 > 0)
	{
		for (iI = 0; iI < iSize10; iI++)
		{
			iType1 = -1;
			iType2 = 0;
			WRAPPER_READ_CLASS_ENUM_DECORATED_ALLOW_MISSING(wrapper, "CvUnit", REMAPPED_CLASS_TYPE_PROPERTIES, &iType1, "AidChange.eProperty");
			WRAPPER_READ_DECORATED(wrapper, "CvUnit", &iType2, "AidChange.iChange");

			if (iType1 != -1)
			{

				AidStruct AidChange;
				AidChange.eProperty = (PropertyTypes)iType1;
				AidChange.iChange = iType2;

				m_aExtraAidChanges.push_back(AidChange);
			}
		}
	}

	WRAPPER_READ(wrapper, "CvUnit", &m_iXOrigin);
	WRAPPER_READ(wrapper, "CvUnit", &m_iYOrigin);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraNoDefensiveBonusCount);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraGatherHerdCount);
	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraReligiousCombatModifier);
	WRAPPER_READ_CLASS_ENUM(wrapper, "CvUnit", REMAPPED_CLASS_TYPE_RELIGIONS, (int*)&m_eReligionType);
	WRAPPER_READ(wrapper, "CvUnit", &m_bIsReligionLocked);

	WRAPPER_READ(wrapper, "CvUnit", &m_iExtraUpkeep100);
	WRAPPER_READ(wrapper, "CvUnit", &m_iUpkeepModifier);
	WRAPPER_READ(wrapper, "CvUnit", &m_iUpkeepMultiplierSM);
	WRAPPER_READ(wrapper, "CvUnit", &m_iUpkeep100);
	WRAPPER_READ(wrapper, "CvUnit", &m_iBuildUpTurns);

	//bool bWorker = false;
	//WRAPPER_READ_DECORATED(wrapper, "CvUnit", &bWorker, "bWorker");

	WRAPPER_READ_OBJECT_END(wrapper);

	// Toffer - Initialize Components
	if (bCommander)
	{
		m_commander = new UnitCompCommander();

		m_commander->changeControlPoints(iExtraControlPoints + m_pUnitInfo->getControlPoints());
		m_commander->changeControlPointsLeft(iControlPointsLeft - m_commander->getControlPoints());

		m_commander->changeCommandRange(iExtraCommandRange + m_pUnitInfo->getCommandRange());
	}
	// Toffer - Maybe a unit without builds were given builds in xml since this game was saved?
	//	If all builds are removed from a unit in xml since save, and the unit doesn't have extra builds from promotions,
	//	then an uneeded worker component will be initialized for this unit, won't cause any real harm though.
	if (/*bWorker ||*/ m_pUnitInfo->getNumBuilds() > 0)
	{
		m_worker = new UnitCompWorker();

		m_worker->changeHillsWorkModifier(iExtraHillsWorkPercent + m_pUnitInfo->getHillsWorkModifier());
		m_worker->changePeaksWorkModifier(iExtraPeaksWorkPercent + m_pUnitInfo->getPeaksWorkModifier());
		m_worker->changeWorkModifier(iExtraWorkPercent);

		// SAVEBREAK - Toffer - see storage method of m_unitProductionMod in CvCity.
		for (int iI = 0; iI < GC.getNumBuildInfos(); iI++)
		{
			if (g_paiTempExtraBuildWorkPercent[iI] != 0)
			{
				m_worker->changeExtraWorkModForBuild(static_cast<BuildTypes>(iI), (short)g_paiTempExtraBuildWorkPercent[iI]);
			}
		}
	}

	//Example of how to skip an outdated and unnecessary save element (at least for ints and bools)
	/*WRAPPER_SKIP_ELEMENT(wrapper,"CvUnit",&m_bHiddenNationality, SAVE_VALUE_ANY);*/

	// Post Process
	if (GC.getGame().isOption(GAMEOPTION_SIZE_MATTERS))
	{
		setSMValues(true);
	}
	//	Zobrist characteristic hashes are not serialized so recalculate
	//	Right now it's just characteristics that affect what a unit might
	//	be able to move through that matter, so its unit class + certain promotions

	for (iI = 0; iI < GC.getNumPromotionInfos(); iI++)
	{
		if (isHasPromotion((PromotionTypes)iI))
		{
			if (GC.getPromotionInfo((PromotionTypes)iI).changesMoveThroughPlots())
			{
				m_movementCharacteristicsHash ^= GC.getPromotionInfo((PromotionTypes)iI).getZobristValue();
			}
			// Toffer - Perhaps just as well to not store this data in the save... Mandatory recalc for one variable.
			for (int iJ = 0; iJ < GC.getPromotionInfo((PromotionTypes)iI).getNumAddsBuildTypes(); iJ++)
			{
				if ((BuildTypes)GC.getPromotionInfo((PromotionTypes)iI).getAddsBuildType(iJ) != NO_BUILD)
				{
					changeExtraBuildType(true, (BuildTypes)GC.getPromotionInfo((PromotionTypes)iI).getAddsBuildType(iJ));
				}
			}
		}
	}

	for (iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
	{
		if (isHasUnitCombat((UnitCombatTypes)iI) && GC.getUnitCombatInfo((UnitCombatTypes)iI).changesMoveThroughPlots())
		{
			m_movementCharacteristicsHash ^= GC.getUnitCombatInfo((UnitCombatTypes)iI).getZobristValue();
		}
	}
	establishBuildups();
}


void CvUnit::write(FDataStreamBase* pStream)
{
	CvTaggedSaveFormatWrapper&	wrapper = CvTaggedSaveFormatWrapper::getSaveFormatWrapper();
	int iI;

	wrapper.AttachToStream(pStream);

	WRAPPER_WRITE_OBJECT_START(wrapper);

	WRAPPER_WRITE(wrapper, "CvUnit", m_iDCMBombRange);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iDCMBombAccuracy);

	WRAPPER_WRITE(wrapper, "CvUnit", m_iID);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iGroupID);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iHotKeyNumber);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iX);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iY);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iLastMoveTurn);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iReconX);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iReconY);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iGameTurnCreated);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iDamage);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iMoves);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExperience);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iLevel);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iCargo);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iCargoCapacity);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iAttackPlotX);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iAttackPlotY);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iCombatTimer);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iCombatFirstStrikes);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iFortifyTurns);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iBlitzCount);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iAmphibCount);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iRiverCount);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iEnemyRouteCount);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iAlwaysHealCount);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iHillsDoubleMoveCount);

	WRAPPER_WRITE(wrapper, "CvUnit", m_iCanMovePeaksCount);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iCanLeadThroughPeaksCount);

	WRAPPER_WRITE(wrapper, "CvUnit", m_iSleepTimer);

	// SAVEBRERAK - Toffer - Cleanup unit-component mess.
	const bool bCommander = isCommander();
	WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", (bCommander ? m_commander->getControlPoints() - m_pUnitInfo->getControlPoints() : 0), "m_iExtraControlPoints");
	WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", (bCommander ? m_commander->getCommandRange() - m_pUnitInfo->getCommandRange() : 0), "m_iExtraCommandRange");
	WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", (bCommander ? m_commander->getControlPointsLeft() : 0), "m_iControlPointsLeft");

	WRAPPER_WRITE(wrapper, "CvUnit", m_iCommanderID); //-1 means there is no used commander

	WRAPPER_WRITE(wrapper, "CvUnit", m_eOriginalOwner);

	WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", bCommander, "m_bCommander");

	WRAPPER_WRITE(wrapper, "CvUnit", m_bAutoPromoting);
	WRAPPER_WRITE(wrapper, "CvUnit", m_bAutoUpgrading);

	WRAPPER_WRITE(wrapper, "CvUnit", m_shadowUnit.eOwner);
	WRAPPER_WRITE(wrapper, "CvUnit", m_shadowUnit.iID);
	WRAPPER_WRITE_CLASS_ENUM(wrapper, "CvUnit", REMAPPED_CLASS_TYPE_TECHS, m_eDesiredDiscoveryTech);

	WRAPPER_WRITE(wrapper, "CvUnit", m_iImmuneToFirstStrikesCount);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraVisibilityRange);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraMoves);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraMoveDiscount);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraAirRange);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraIntercept);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraEvasion);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraFirstStrikes);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraChanceFirstStrikes);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraWithdrawal);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraCollateralDamage);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraBombardRate);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraEnemyHeal);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraNeutralHeal);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraFriendlyHeal);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iSameTileHeal);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iAdjacentTileHeal);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraCombatPercent);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraCityAttackPercent);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraCityDefensePercent);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraHillsAttackPercent);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraHillsDefensePercent);

	const bool bWorker = isWorker();
	WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", (bWorker ? m_worker->getHillsWorkModifier() - m_pUnitInfo->getHillsWorkModifier() : 0), "m_iExtraHillsWorkPercent");
	WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", (bWorker ? m_worker->getWorkModifier() : 0), "m_iExtraWorkPercent");

	WRAPPER_WRITE(wrapper, "CvUnit", m_iRevoltProtection);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iCollateralDamageProtection);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iPillageChange);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iUpgradeDiscount);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExperiencePercent);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iKamikazePercent);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iBaseCombat);
	WRAPPER_WRITE(wrapper, "CvUnit", m_eFacingDirection);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iImmobileTimer);

	WRAPPER_WRITE(wrapper, "CvUnit", m_bMadeAttack);
	WRAPPER_WRITE(wrapper, "CvUnit", m_bMadeInterception);
	WRAPPER_WRITE(wrapper, "CvUnit", m_bPromotionReady);
	WRAPPER_WRITE(wrapper, "CvUnit", m_bDeathDelay);
	WRAPPER_WRITE(wrapper, "CvUnit", m_bCombatFocus);
	// m_bInfoBarDirty not saved...
	WRAPPER_WRITE(wrapper, "CvUnit", m_bBlockading);
	WRAPPER_WRITE(wrapper, "CvUnit", m_bAirCombat);

	WRAPPER_WRITE(wrapper, "CvUnit", m_eOwner);
	WRAPPER_WRITE(wrapper, "CvUnit", m_eCapturingPlayer);
	WRAPPER_WRITE_CLASS_ENUM(wrapper, "CvUnit", REMAPPED_CLASS_TYPE_UNITS, m_eUnitType);
	WRAPPER_WRITE_CLASS_ENUM(wrapper, "CvUnit", REMAPPED_CLASS_TYPE_UNITS, m_eLeaderUnitType);

	WRAPPER_WRITE(wrapper, "CvUnit", m_combatUnit.eOwner);
	WRAPPER_WRITE(wrapper, "CvUnit", m_combatUnit.iID);
	WRAPPER_WRITE(wrapper, "CvUnit", m_transportUnit.eOwner);
	WRAPPER_WRITE(wrapper, "CvUnit", m_transportUnit.iID);

	WRAPPER_WRITE_ARRAY(wrapper, "CvUnit", NUM_DOMAIN_TYPES, m_aiExtraDomainModifier);

	WRAPPER_WRITE_STRING(wrapper, "CvUnit", m_szName);
	WRAPPER_WRITE_STRING(wrapper, "CvUnit", m_szScriptData);

	//	Use condensed format now - only save non-default array elements
	for(iI = 0; iI < GC.getNumPromotionInfos(); iI++)
	{
		if ( isHasPromotion((PromotionTypes)iI) )
		{
			WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", iI, "hasPromotion");
		}
	}

	for (std::map<TerrainTypes, TerrainKeyedInfo>::iterator it = m_terrainKeyedInfo.begin(), itEnd = m_terrainKeyedInfo.end(); it != itEnd; ++it)
	{
		const TerrainKeyedInfo& info = it->second;
		if (!info.Empty())
		{
			WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", it->first, "hasTerrainInfo");
			WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", info.m_iTerrainProtected, "TerrainProtected");
			WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", info.m_iTerrainDoubleMoveCount, "TerrainDoubleMove");
			WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", info.m_iExtraTerrainAttackPercent, "extraAttackPercent");
			WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", info.m_iExtraTerrainDefensePercent, "extraDefensePercent");
			WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", info.m_iExtraTerrainWorkPercent, "terrainExtraWorkPercent");
			WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", info.m_iExtraWithdrawOnTerrainType, "extraWithdrawOnTerrainType");
		}
	}
	for (std::map<FeatureTypes, FeatureKeyedInfo>::iterator it = m_featureKeyedInfo.begin(), itEnd = m_featureKeyedInfo.end(); it != itEnd; ++it)
	{
		const FeatureKeyedInfo& info = it->second;
		if (!info.Empty())
		{
			WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", it->first, "hasFeatureInfo");
			WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", info.m_iFeatureDoubleMoveCount, "FeatureDoubleMove");
			WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", info.m_iExtraFeatureAttackPercent, "extraAttackPercent");
			WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", info.m_iExtraFeatureDefensePercent, "extraDefensePercent");
			WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", info.m_iExtraFeatureWorkPercent, "featureExtraWorkPercent");
			WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", info.m_iExtraWithdrawOnFeatureType, "extraWithdrawOnFeatureType");
		}
	}
	for(iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
	{
		if ( getExtraUnitCombatModifier((UnitCombatTypes)iI) != 0 )
		{
			WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", iI, "hasUnitCombatInfo");
			WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", getExtraUnitCombatModifier((UnitCombatTypes)iI), "ExtraUnitCombatMod");
		}
	}

	m_Properties.writeWrapper(pStream);

	//TB Combat Mods Begin
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraPursuit);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraEarlyWithdraw);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraVSBarbs);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraArmor);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraPuncture);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraOverrun);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraRepel);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraFortRepel);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraRepelRetries);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraUnyielding);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraKnockback);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraKnockbackRetries);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iStampedeCount);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraStrAdjperRnd);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraStrAdjperAtt);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraStrAdjperDef);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraWithdrawAdjperAtt);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraUnnerve);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraEnclose);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraLunge);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraDynamicDefense);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraStrength);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iAnimalIgnoresBordersCount);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iOnslaughtCount);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraFortitude);
	//TB SubCombat Mods Begin
	//	Use condensed format now - only save non-default array elements
	for(iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
	{
		if ( getSubCombatTypeCount((UnitCombatTypes)iI) != 0 )
		{
			WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", iI, "hasUnitCombatInfo2");
			WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", getSubCombatTypeCount((UnitCombatTypes)iI), "subCombatCount");
		}
	}
	//TB SubCombat Mods End

#ifdef OUTBREAKS_AND_AFFLICTIONS
	//	Use condensed format now - only save non-default array elements
	for(iI = 0; iI < GC.getNumPromotionInfos(); iI++)
	{
		if ( getAfflictionHitCount((PromotionTypes)iI) != 0)
		{
			WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", iI, "hasAfflicationInfo");
			WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", getAfflictionHitCount((PromotionTypes)iI), "afflictOnAttack");
			WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", getAfflictionHitCount((PromotionTypes)iI), "cureAffliction");
			WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", getAfflictionHitCount((PromotionTypes)iI), "afflictionTurn");
			WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", getAfflictionHitCount((PromotionTypes)iI), "afflictionHit");
			WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", getAfflictionHitCount((PromotionTypes)iI), "afflictionTolerance");
			WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", getAfflictionHitCount((PromotionTypes)iI), "fortitudeModifierType");
			WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", getTrapSetWithPromotionCount((PromotionTypes)iI), "trapSetWithPromotionType");
			WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", getAfflictionHitCount((PromotionTypes)iI), "promotionFromTraitCount");
		}
	}
#endif
	WRAPPER_WRITE(wrapper, "CvUnit", m_iRoundCount);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iAttackCount);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iDefenseCount);

#ifdef STRENGTH_IN_NUMBERS
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraFrontSupportPercent);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraShortRangeSupportPercent);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraMediumRangeSupportPercent);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraLongRangeSupportPercent);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraFlankSupportPercent);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iSupportCount);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iAttackFromPlotX);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iAttackFromPlotY);
	WRAPPER_WRITE(wrapper, "CvUnit", afIUnit.eOwner);
	WRAPPER_WRITE(wrapper, "CvUnit", afIUnit.iID);
	WRAPPER_WRITE(wrapper, "CvUnit", afIIUnit.eOwner);
	WRAPPER_WRITE(wrapper, "CvUnit", afIIUnit.iID);
	WRAPPER_WRITE(wrapper, "CvUnit", asrIUnit.eOwner);
	WRAPPER_WRITE(wrapper, "CvUnit", asrIUnit.iID);
	WRAPPER_WRITE(wrapper, "CvUnit", asrIIUnit.eOwner);
	WRAPPER_WRITE(wrapper, "CvUnit", asrIIUnit.iID);
	WRAPPER_WRITE(wrapper, "CvUnit", amrIUnit.eOwner);
	WRAPPER_WRITE(wrapper, "CvUnit", amrIUnit.iID);
	WRAPPER_WRITE(wrapper, "CvUnit", amrIIUnit.eOwner);
	WRAPPER_WRITE(wrapper, "CvUnit", amrIIUnit.iID);
	WRAPPER_WRITE(wrapper, "CvUnit", alrIUnit.eOwner);
	WRAPPER_WRITE(wrapper, "CvUnit", alrIUnit.iID);
	WRAPPER_WRITE(wrapper, "CvUnit", alrIIUnit.eOwner);
	WRAPPER_WRITE(wrapper, "CvUnit", alrIIUnit.iID);
	WRAPPER_WRITE(wrapper, "CvUnit", aflIUnit.eOwner);
	WRAPPER_WRITE(wrapper, "CvUnit", aflIUnit.iID);
	WRAPPER_WRITE(wrapper, "CvUnit", aflIIUnit.eOwner);
	WRAPPER_WRITE(wrapper, "CvUnit", aflIIUnit.iID);
	WRAPPER_WRITE(wrapper, "CvUnit", dfIUnit.eOwner);
	WRAPPER_WRITE(wrapper, "CvUnit", dfIUnit.iID);
	WRAPPER_WRITE(wrapper, "CvUnit", dfIIUnit.eOwner);
	WRAPPER_WRITE(wrapper, "CvUnit", dfIIUnit.iID);
	WRAPPER_WRITE(wrapper, "CvUnit", dsrIUnit.eOwner);
	WRAPPER_WRITE(wrapper, "CvUnit", dsrIUnit.iID);
	WRAPPER_WRITE(wrapper, "CvUnit", dsrIIUnit.eOwner);
	WRAPPER_WRITE(wrapper, "CvUnit", dsrIIUnit.iID);
	WRAPPER_WRITE(wrapper, "CvUnit", dmrIUnit.eOwner);
	WRAPPER_WRITE(wrapper, "CvUnit", dmrIUnit.iID);
	WRAPPER_WRITE(wrapper, "CvUnit", dmrIIUnit.eOwner);
	WRAPPER_WRITE(wrapper, "CvUnit", dmrIIUnit.iID);
	WRAPPER_WRITE(wrapper, "CvUnit", dlrIUnit.eOwner);
	WRAPPER_WRITE(wrapper, "CvUnit", dlrIUnit.iID);
	WRAPPER_WRITE(wrapper, "CvUnit", dlrIIUnit.eOwner);
	WRAPPER_WRITE(wrapper, "CvUnit", dlrIIUnit.iID);
	WRAPPER_WRITE(wrapper, "CvUnit", dflIUnit.eOwner);
	WRAPPER_WRITE(wrapper, "CvUnit", dflIUnit.iID);
	WRAPPER_WRITE(wrapper, "CvUnit", dflIIUnit.eOwner);
	WRAPPER_WRITE(wrapper, "CvUnit", dflIIUnit.iID);
#endif // STRENGTH_IN_NUMBERS

	//	Use condensed format now - only save non-default array elements
	for (iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
	{
		if (getSubCombatTypeCount((UnitCombatTypes)iI) != 0)
		{
			WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", iI, "hasUnitCombatInfo3");
			WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", getOngoingTrainingCount((UnitCombatTypes)iI), "ongoingTrainingCount");
			WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", getHealUnitCombatTypeTotal((UnitCombatTypes)iI), "healUnitCombatTypeVolume");
			WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", getHealUnitCombatTypeAdjacentTotal((UnitCombatTypes)iI), "healUnitCombatTypeAdjacentVolume");
			WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", getTrapImmunityUnitCombatCount((UnitCombatTypes)iI), "trapImmunityUnitCombatCount");
			WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", getTargetUnitCombatCount((UnitCombatTypes)iI), "targetUnitCombatCount");
			WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", getExtraTrapDisableUnitCombatType((UnitCombatTypes)iI), "extraTrapDisableUnitCombatType");
			WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", getExtraTrapAvoidanceUnitCombatType((UnitCombatTypes)iI), "extraTrapAvoidanceUnitCombatType");
			WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", getExtraTrapTriggerUnitCombatType((UnitCombatTypes)iI), "extraTrapTriggerUnitCombatType");
		}
	}

	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraDodgeModifier);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraPrecisionModifier);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraPowerShots);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraPowerShotCombatModifier);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraPowerShotPunctureModifier);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraPowerShotPrecisionModifier);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraPowerShotCriticalModifier);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraCriticalModifier);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraEndurance);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iColdDamage);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iDealColdDamageCount);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iColdImmuneCount);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iCombatPowerShots);

	//	Use condensed format now - only save non-default array elements
	for(iI = 0; iI < GC.getNumPromotionInfos(); iI++)
	{
		if ( getPromotionFreeCount((PromotionTypes)iI) != 0 )
		{
			WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", iI, "hasFreePromotionCount");
			WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", getPromotionFreeCount((PromotionTypes)iI), "FreePromoCount");
		}
	}

	WRAPPER_WRITE(wrapper, "CvUnit", m_iCombatKnockbacks);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iCombatRepels);


	//	Use condensed format now - only save non-default array elements
	for(iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
	{
		if ( getRemovesUnitCombatTypeCount((UnitCombatTypes)iI) != 0 )
		{
			WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", iI, "hasUnitCombatInfo4");
			WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", getRemovesUnitCombatTypeCount((UnitCombatTypes)iI), "removesUnitCombatCount");
		}
	}

	//	Use condensed format now - only save non-default array elements
	for(iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
	{
		if ( getExtraFlankingStrengthbyUnitCombatType((UnitCombatTypes)iI) != 0 )
		{
			WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", iI, "hasUnitCombatInfo5");
			WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", getExtraFlankingStrengthbyUnitCombatType((UnitCombatTypes)iI), "extraFlankingStrengthbyUnitCombatType");
		}
	}

	//	Use condensed format now - only save non-default array elements
	for(iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
	{
		if ( getExtraWithdrawVSUnitCombatType((UnitCombatTypes)iI) != 0 )
		{
			WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", iI, "hasUnitCombatInfo6");
			WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", getExtraWithdrawVSUnitCombatType((UnitCombatTypes)iI), "extraWithdrawVSUnitCombatType");
		}
	}

	//	Use condensed format now - only save non-default array elements
	for(iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
	{
		if ( getExtraRepelVSUnitCombatType((UnitCombatTypes)iI) != 0 )
		{
			WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", iI, "hasUnitCombatInfo7");
			WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", getExtraRepelVSUnitCombatType((UnitCombatTypes)iI), "extraRepelVSUnitCombatType");
		}
	}

	//	Use condensed format now - only save non-default array elements
	for(iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
	{
		if ( getExtraKnockbackVSUnitCombatType((UnitCombatTypes)iI) != 0 )
		{
			WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", iI, "hasUnitCombatInfo8");
			WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", getExtraKnockbackVSUnitCombatType((UnitCombatTypes)iI), "extraKnockbackVSUnitCombatType");
		}
	}

	//	Use condensed format now - only save non-default array elements
	for(iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
	{
		if ( getExtraPunctureVSUnitCombatType((UnitCombatTypes)iI) != 0 )
		{
			WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", iI, "hasUnitCombatInfo9");
			WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", getExtraPunctureVSUnitCombatType((UnitCombatTypes)iI), "extraPunctureVSUnitCombatType");
		}
	}

	//	Use condensed format now - only save non-default array elements
	for(iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
	{
		if ( getExtraArmorVSUnitCombatType((UnitCombatTypes)iI) != 0 )
		{
			WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", iI, "hasUnitCombatInfo10");
			WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", getExtraArmorVSUnitCombatType((UnitCombatTypes)iI), "extraArmorVSUnitCombatType");
		}
	}

	//	Use condensed format now - only save non-default array elements
	for(iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
	{
		if ( getExtraDodgeVSUnitCombatType((UnitCombatTypes)iI) != 0 )
		{
			WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", iI, "hasUnitCombatInfo11");
			WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", getExtraDodgeVSUnitCombatType((UnitCombatTypes)iI), "extraDodgeVSUnitCombatType");
		}
	}

	//	Use condensed format now - only save non-default array elements
	for(iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
	{
		if ( getExtraPrecisionVSUnitCombatType((UnitCombatTypes)iI) != 0 )
		{
			WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", iI, "hasUnitCombatInfo12");
			WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", getExtraPrecisionVSUnitCombatType((UnitCombatTypes)iI), "extraPrecisionVSUnitCombatType");
		}
	}

	//	Use condensed format now - only save non-default array elements
	for(iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
	{
		if ( getExtraCriticalVSUnitCombatType((UnitCombatTypes)iI) != 0 )
		{
			WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", iI, "hasUnitCombatInfo13");
			WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", getExtraCriticalVSUnitCombatType((UnitCombatTypes)iI), "extraCriticalVSUnitCombatType");
		}
	}

	//	Use condensed format now - only save non-default array elements
	for(iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
	{
		if ( getExtraRoundStunVSUnitCombatType((UnitCombatTypes)iI) != 0 )
		{
			WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", iI, "hasUnitCombatInfo14");
			WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", getExtraRoundStunVSUnitCombatType((UnitCombatTypes)iI), "extraRoundStunVSUnitCombatType");
		}
	}
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraRoundStunProb);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iCombatStuns);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraPoisonProbabilityModifier);

#ifdef OUTBREAKS_AND_AFFLICTIONS
	//	Use condensed format now - only save non-default array elements
	for(iI = 0; iI < GC.getNumPromotionLineInfos(); iI++)
	{
		if ( getAfflictOnAttackTypeProbability((PromotionLineTypes)iI) != 0 ||
			 getAfflictOnAttackTypeCount((PromotionLineTypes)iI) != 0 ||
			 getAfflictOnAttackTypeImmediateCount((PromotionLineTypes)iI) != 0 ||
			 getAfflictOnAttackTypeAttemptedCount((PromotionLineTypes)iI) != 0 ||
			 getCureAfflictionCount((PromotionLineTypes)iI) != 0 ||
			 getAfflictionTurnCount((PromotionLineTypes)iI) != 0 ||
			 getAfflictionLineCount((PromotionLineTypes)iI) != 0 ||
			 getUnitAfflictionTolerance((PromotionLineTypes)iI) != 0 ||
			 getFortitudeModifierTypeAmount((PromotionLineTypes)iI) != 0)
		{
			WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", iI, "hasAfflictOnAttackInfo");
			WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", getAfflictOnAttackTypeProbability((PromotionLineTypes)iI), "afflictOnAttackTypeProb");
			WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", getAfflictOnAttackTypeCount((PromotionLineTypes)iI), "afflictOnAttackTypeCount");
			WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", getAfflictOnAttackTypeImmediateCount((PromotionLineTypes)iI), "afflictOnAttackTypeImmediateCount");
			WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", getAfflictOnAttackTypeAttemptedCount((PromotionLineTypes)iI), "afflictOnAttackTypeAttemptedCount");
			WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", getCureAfflictionCount((PromotionLineTypes)iI), "cureAfflictionType");
			WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", getAfflictionTurnCount((PromotionLineTypes)iI), "afflictionTurnType");
			WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", getAfflictionLineCount((PromotionLineTypes)iI), "hasAfflictionLine");
			WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", getUnitAfflictionTolerance((PromotionLineTypes)iI), "afflictionToleranceType");
			WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", getFortitudeModifierTypeAmount((PromotionLineTypes)iI), "fortitudeModifier");
		}
	}
#endif
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraAttackCombatModifier);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraDefenseCombatModifier);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iRetrainsAvailable);
	//TB Combat Mods end

	WRAPPER_WRITE(wrapper, "CvUnit", m_iDefensiveVictoryMoveCount);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iFreeDropCount);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iOffensiveVictoryMoveCount);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iPillageCultureCount);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iPillageEspionageCount);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iPillageMarauderCount);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iPillageOnMoveCount);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iPillageOnVictoryCount);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iPillageResearchCount);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iAirCombatLimitChange);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iCelebrityHappy);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iCollateralDamageLimitChange);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iCollateralDamageMaxUnitsChange);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iCombatLimitChange);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraDropRange);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iVictoryHeal);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iOneUpCount);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iSurvivorChance);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iVictoryAdjacentHeal);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iVictoryStackHeal);
	WRAPPER_WRITE(wrapper, "CvUnit", m_bSurvivor);

	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraCaptureProbabilityModifier);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraCaptureResistanceModifier);

	//WorkRateMod
	//	Use condensed format now - only save non-default array elements
	for (iI = 0; iI < GC.getNumBuildInfos(); iI++)
	{
		if (getExtraWorkModForBuild((BuildTypes)iI) != 0)
		{
			WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", iI, "hasBuildInfo");
			WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", getExtraWorkModForBuild((BuildTypes)iI), "extraBuildWorkPercent");
		}
	}
	WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", (bWorker ? m_worker->getPeaksWorkModifier() - m_pUnitInfo->getPeaksWorkModifier() : 0), "m_iExtraPeaksWorkPercent");

	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraBreakdownChance);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraBreakdownDamage);

	//	Use condensed format now - only save non-default array elements
	for(iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
	{
		if ( isHasUnitCombat((UnitCombatTypes)iI) )
		{
			WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", iI, "hasUnitCombat");
		}
	}
	WRAPPER_WRITE(wrapper, "CvUnit", m_iAttackOnlyCitiesCount);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iIgnoreNoEntryLevelCount);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iIgnoreZoneofControlCount);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraTaunt);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraMaxHP);


	//	Use condensed format now - only save non-default array elements
	for(iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
	{
		if ( getExtraPursuitVSUnitCombatType((UnitCombatTypes)iI) != 0 )
		{
			WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", iI, "hasUnitCombatInfo15");
			WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", getExtraPursuitVSUnitCombatType((UnitCombatTypes)iI), "extraPursuitVSUnitCombatType");
		}
	}
	WRAPPER_WRITE(wrapper, "CvUnit", m_iFliesToMoveCount);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iQualityBaseTotal);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iGroupBaseTotal);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iSizeBaseTotal);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iCannotMergeSplitCount);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraStrengthModifier);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraDamageModifier);
	WRAPPER_WRITE_CLASS_ENUM(wrapper, "CvUnit", REMAPPED_CLASS_TYPE_UNITS, m_eGGExperienceEarnedTowardsType);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iSMCargo);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iSMCargoCapacity);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iSMCargoVolume);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iSMCargoVolumeModifier);
	WRAPPER_WRITE(wrapper, "CvUnit", m_eNewDomainCargo);
	WRAPPER_WRITE_CLASS_ENUM(wrapper, "CvUnit", REMAPPED_CLASS_TYPE_SPECIAL_UNITS, m_eNewSpecialCargo);
	WRAPPER_WRITE_CLASS_ENUM(wrapper, "CvUnit", REMAPPED_CLASS_TYPE_SPECIAL_UNITS, m_eNewSMSpecialCargo);
	WRAPPER_WRITE_CLASS_ENUM(wrapper, "CvUnit", REMAPPED_CLASS_TYPE_SPECIAL_UNITS, m_eNewSMNotSpecialCargo);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraQuality);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraGroup);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraSize);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iSMStrength);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iSMAssetValue);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iSMPowerValue);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iSMHPValue);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iSMExtraCargoVolume);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iSMBombardRate);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iSMAirBombBaseRate);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iSMBaseWorkRate);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iSMRevoltProtection);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraRBombardDamage);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraRBombardDamageLimit);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraRBombardDamageMaxUnits);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraDCMBombRange);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraDCMBombAccuracy);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iBaseRBombardDamage);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iBaseRBombardDamageLimit);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iBaseRBombardDamageMaxUnits);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iBaseDCMBombRange);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iBaseDCMBombAccuracy);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iBombardDirectCount);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iRBombardForceAbilityCount);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraCombatModifierPerSizeMore);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraCombatModifierPerSizeLess);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraCombatModifierPerVolumeMore);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraCombatModifierPerVolumeLess);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iAlwaysInvisibleCount);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iHealUnitCombatCount);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraSelfHealModifier);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iNoSelfHealCount);
	for(iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
	{
		if ( getHealAsDamage((UnitCombatTypes)iI) != 0 )
		{
			WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", iI, "healAsDamageInfo");
			WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", getHealAsDamage((UnitCombatTypes)iI), "healAsDamage");
		}
	}

	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraNumHealSupport);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iHealSupportUsed);
	WRAPPER_WRITE_CLASS_ENUM(wrapper, "CvUnit", REMAPPED_CLASS_TYPE_MISSIONS, m_eSleepType);
	WRAPPER_WRITE(wrapper, "CvUnit", m_bHasBuildUp);
	WRAPPER_WRITE_CLASS_ENUM(wrapper, "CvUnit", REMAPPED_CLASS_TYPE_PROMOTIONLINES, m_eCurrentBuildUpType);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iZoneOfControlCount);
	WRAPPER_WRITE(wrapper, "CvUnit", m_bInhibitMerge);
	WRAPPER_WRITE(wrapper, "CvUnit", m_bInhibitSplit);
	WRAPPER_WRITE(wrapper, "CvUnit", m_bIsBuildUp);
	WRAPPER_WRITE_CLASS_ENUM(wrapper, "CvUnit", REMAPPED_CLASS_TYPE_SPECIAL_UNITS, m_eSpecialUnit);
	//WRAPPER_WRITE(wrapper, "CvUnit", m_bHiddenNationality);
	WRAPPER_WRITE(wrapper, "CvUnit", m_bHasHNCapturePromotion);
	WRAPPER_WRITE(wrapper, "CvUnit", m_eCapturingUnit.eOwner);
	WRAPPER_WRITE(wrapper, "CvUnit", m_eCapturingUnit.iID);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExcileCount);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iPassageCount);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iNoNonOwnedCityEntryCount);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iBarbCoExistCount);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iBlendIntoCityCount);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iUpgradeAnywhereCount);
	//	Use condensed format now - only save non-default array elements
	for(iI = 0; iI < GC.getNumInvisibleInfos(); iI++)
	{
		if ( m_aiExtraVisibilityIntensity[iI] != 0 ||
			m_aiExtraInvisibilityIntensity[iI] != 0 ||
			m_aiExtraVisibilityIntensityRange[iI] != 0 ||
			m_aiNegatesInvisibleCount[iI] != 0 ||
			m_aiExtraVisibilityIntensitySameTile[iI] != 0)
		{
			WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", iI, "Visibilities");
			WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", m_aiExtraVisibilityIntensity[iI], "extraVisibilityIntensity");
			WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", m_aiExtraInvisibilityIntensity[iI], "extraInvisibilityIntensity");
			WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", m_aiExtraVisibilityIntensityRange[iI], "extraVisibilityIntensityRange");
			WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", m_aiNegatesInvisibleCount[iI], "negatesInvisibleCount");
			WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", m_aiExtraVisibilityIntensitySameTile[iI], "extraVisibilityIntensitySameTile");
		}
	}
	WRAPPER_WRITE(wrapper, "CvUnit", m_bHasAnyInvisibility);

	int iType1 = 0;
	int iType2 = 0;
	int iType3 = 0;

	int iSize1 = (int)m_aExtraInvisibleTerrains.size();
	WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", iSize1, "m_aExtraInvisibleTerrains.size");
	if (iSize1 > 0)
	{
		for (iI = 0; iI < iSize1; iI++)
		{
			iType1 = (int)m_aExtraInvisibleTerrains[iI].eInvisible;
			iType2 = (int)m_aExtraInvisibleTerrains[iI].eTerrain;
			iType3 = m_aExtraInvisibleTerrains[iI].iIntensity;
			WRAPPER_WRITE(wrapper, "CvUnit", iType1);
			WRAPPER_WRITE(wrapper, "CvUnit", iType2);
			WRAPPER_WRITE(wrapper, "CvUnit", iType3);
		}
	}

	int iSize2 = (int)m_aExtraInvisibleFeatures.size();
	WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", iSize2, "m_aExtraInvisibleFeatures.size");
	if (iSize2 > 0)
	{
		for (iI = 0; iI < iSize2; iI++)
		{
			iType1 = (int)m_aExtraInvisibleFeatures[iI].eInvisible;
			iType2 = (int)m_aExtraInvisibleFeatures[iI].eFeature;
			iType3 = m_aExtraInvisibleFeatures[iI].iIntensity;
			WRAPPER_WRITE(wrapper, "CvUnit", iType1);
			WRAPPER_WRITE(wrapper, "CvUnit", iType2);
			WRAPPER_WRITE(wrapper, "CvUnit", iType3);
		}
	}

	int iSize3 = (int)m_aExtraInvisibleImprovements.size();
	WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", iSize3, "m_aExtraInvisibleImprovements.size");
	if (iSize3 > 0)
	{
		for (iI = 0; iI < iSize3; iI++)
		{
			iType1 = (int)m_aExtraInvisibleImprovements[iI].eInvisible;
			iType2 = (int)m_aExtraInvisibleImprovements[iI].eImprovement;
			iType3 = m_aExtraInvisibleImprovements[iI].iIntensity;
			WRAPPER_WRITE(wrapper, "CvUnit", iType1);
			WRAPPER_WRITE(wrapper, "CvUnit", iType2);
			WRAPPER_WRITE(wrapper, "CvUnit", iType3);
		}
	}

	int iSize4 = (int)m_aExtraVisibleTerrains.size();
	WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", iSize4, "m_aExtraVisibleTerrains.size");
	if (iSize4 > 0)
	{
		for (iI = 0; iI < iSize4; iI++)
		{
			iType1 = (int)m_aExtraVisibleTerrains[iI].eInvisible;
			iType2 = (int)m_aExtraVisibleTerrains[iI].eTerrain;
			iType3 = m_aExtraVisibleTerrains[iI].iIntensity;
			WRAPPER_WRITE(wrapper, "CvUnit", iType1);
			WRAPPER_WRITE(wrapper, "CvUnit", iType2);
			WRAPPER_WRITE(wrapper, "CvUnit", iType3);
		}
	}

	int iSize5 = (int)m_aExtraVisibleFeatures.size();
	WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", iSize5, "m_aExtraVisibleFeatures.size");
	if (iSize5 > 0)
	{
		for (iI = 0; iI < iSize5; iI++)
		{
			iType1 = (int)m_aExtraVisibleFeatures[iI].eInvisible;
			iType2 = (int)m_aExtraVisibleFeatures[iI].eFeature;
			iType3 = m_aExtraVisibleFeatures[iI].iIntensity;
			WRAPPER_WRITE(wrapper, "CvUnit", iType1);
			WRAPPER_WRITE(wrapper, "CvUnit", iType2);
			WRAPPER_WRITE(wrapper, "CvUnit", iType3);
		}
	}

	int iSize6 = (int)m_aExtraVisibleImprovements.size();
	WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", iSize6, "m_aExtraVisibleImprovements.size");
	if (iSize6 > 0)
	{
		for (iI = 0; iI < iSize6; iI++)
		{
			iType1 = (int)m_aExtraVisibleImprovements[iI].eInvisible;
			iType2 = (int)m_aExtraVisibleImprovements[iI].eImprovement;
			iType3 = m_aExtraVisibleImprovements[iI].iIntensity;
			WRAPPER_WRITE(wrapper, "CvUnit", iType1);
			WRAPPER_WRITE(wrapper, "CvUnit", iType2);
			WRAPPER_WRITE(wrapper, "CvUnit", iType3);
		}
	}

	int iSize7 = (int)m_aExtraVisibleTerrainRanges.size();
	WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", iSize7, "m_aExtraVisibleTerrainRanges.size");
	if (iSize7 > 0)
	{
		for (iI = 0; iI < iSize7; iI++)
		{
			iType1 = (int)m_aExtraVisibleTerrainRanges[iI].eInvisible;
			iType2 = (int)m_aExtraVisibleTerrainRanges[iI].eTerrain;
			iType3 = m_aExtraVisibleTerrainRanges[iI].iIntensity;
			WRAPPER_WRITE(wrapper, "CvUnit", iType1);
			WRAPPER_WRITE(wrapper, "CvUnit", iType2);
			WRAPPER_WRITE(wrapper, "CvUnit", iType3);
		}
	}

	int iSize8 = (int)m_aExtraVisibleFeatureRanges.size();
	WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", iSize8, "m_aExtraVisibleFeatureRanges.size");
	if (iSize8 > 0)
	{
		for (iI = 0; iI < iSize8; iI++)
		{
			iType1 = (int)m_aExtraVisibleFeatureRanges[iI].eInvisible;
			iType2 = (int)m_aExtraVisibleFeatureRanges[iI].eFeature;
			iType3 = m_aExtraVisibleFeatureRanges[iI].iIntensity;
			WRAPPER_WRITE(wrapper, "CvUnit", iType1);
			WRAPPER_WRITE(wrapper, "CvUnit", iType2);
			WRAPPER_WRITE(wrapper, "CvUnit", iType3);
		}
	}

	int iSize9 = (int)m_aExtraVisibleImprovementRanges.size();
	WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", iSize9, "m_aExtraVisibleImprovementRanges.size");
	if (iSize9 > 0)
	{
		for (iI = 0; iI < iSize9; iI++)
		{
			iType1 = (int)m_aExtraVisibleImprovementRanges[iI].eInvisible;
			iType2 = (int)m_aExtraVisibleImprovementRanges[iI].eImprovement;
			iType3 = m_aExtraVisibleImprovementRanges[iI].iIntensity;
			WRAPPER_WRITE(wrapper, "CvUnit", iType1);
			WRAPPER_WRITE(wrapper, "CvUnit", iType2);
			WRAPPER_WRITE(wrapper, "CvUnit", iType3);
		}
	}

	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraInsidiousness);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraInvestigation);
	WRAPPER_WRITE(wrapper, "CvUnit", (int)m_pPlayerInvestigated);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iAssassinCount);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraStealthStrikes);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraStealthCombatModifier);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iStealthDefenseCount);
	WRAPPER_WRITE(wrapper, "CvUnit", m_bRevealed);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iOnlyDefensiveCount);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iNoInvisibilityCount);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraTrapDamageMax);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraTrapDamageMin);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraTrapComplexity);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraNumTriggers);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iNumTimesTriggered);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iTriggerBeforeAttackCount);
	WRAPPER_WRITE(wrapper, "CvUnit", m_bIsArmed);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iHiddenNationalityCount);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iNoCaptureCount);

	int iSize10 = (int)m_aExtraAidChanges.size();
	WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", iSize10, "m_aExtraAidChanges.size");
	if (iSize10 > 0)
	{
		for (iI = 0; iI < iSize10; iI++)
		{
			iType1 = (int)m_aExtraAidChanges[iI].eProperty;
			iType2 = m_aExtraAidChanges[iI].iChange;
			WRAPPER_WRITE_CLASS_ENUM_DECORATED(wrapper, "CvUnit", REMAPPED_CLASS_TYPE_PROPERTIES, iType1, "AidChange.eProperty");
			WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", iType2, "AidChange.iChange");
		}
	}
	WRAPPER_WRITE(wrapper, "CvUnit", m_iXOrigin);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iYOrigin);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraNoDefensiveBonusCount);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraGatherHerdCount);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraReligiousCombatModifier);
	WRAPPER_WRITE_CLASS_ENUM(wrapper, "CvUnit", REMAPPED_CLASS_TYPE_RELIGIONS, m_eReligionType);
	WRAPPER_WRITE(wrapper, "CvUnit", m_bIsReligionLocked);

	WRAPPER_WRITE(wrapper, "CvUnit", m_iExtraUpkeep100);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iUpkeepModifier);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iUpkeepMultiplierSM);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iUpkeep100);
	WRAPPER_WRITE(wrapper, "CvUnit", m_iBuildUpTurns);

	//WRAPPER_WRITE_DECORATED(wrapper, "CvUnit", isWorker(), "bWorker");

	WRAPPER_WRITE_OBJECT_END(wrapper);
}

// Protected Functions...

bool CvUnit::canAdvance(const CvPlot* pPlot, int iThreshold) const
{
	FAssert(canFight());
	//TB Combat Mod next line
	FAssert(!isAnimal() || canAnimalIgnoresBorders() || !pPlot->isCity());
	FAssert(getDomainType() != DOMAIN_AIR);
	FAssert(getDomainType() != DOMAIN_IMMOBILE);

	if (pPlot->getNumVisiblePotentialEnemyDefenders(this) > iThreshold
	|| isNoCapture() && pPlot->isEnemyCity(*this))
	{
		return false;
	}
	return true;
}


void CvUnit::collateralCombat(const CvPlot* pPlot, CvUnit* pSkipUnit)
{
	const int iCollateralStrength = (getDomainType() == DOMAIN_AIR ? airBaseCombatStr() : baseCombatStr()) * collateralDamage() / 100;

	if (iCollateralStrength == 0)
	{
		return;
	}
	std::map<CvUnit*, int> mapUnitDamage;
	std::map<CvUnit*, int>::iterator it;

	const int iPossibleTargets = std::min((pPlot->getNumVisiblePotentialEnemyDefenders(this) - 1), collateralDamageMaxUnits());

	foreach_(CvUnit* pLoopUnit, pPlot->units())
	{
		if (pLoopUnit != pSkipUnit
		&& isEnemy(pLoopUnit->getTeam(), pPlot, pLoopUnit)
		&& !pLoopUnit->isInvisible(getTeam(), false)
		&& pLoopUnit->canDefend())
		{
			mapUnitDamage[pLoopUnit] = pLoopUnit->getHP() * (1 + GC.getGame().getSorenRandNum(10000, "Collateral Damage"));
		}
	}

	CvCity* pCity = NULL;
	if (getDomainType() == DOMAIN_AIR)
	{
		pCity = pPlot->getPlotCity();
	}
	int iDamageCount = 0;
	int iCount = 0;

	while (iCount < iPossibleTargets)
	{
		int iBestValue = 0;
		CvUnit* pBestUnit = NULL;

		for (it = mapUnitDamage.begin(); it != mapUnitDamage.end(); ++it)
		{
			if (it->second > iBestValue)
			{
				iBestValue = it->second;
				pBestUnit = it->first;
			}
		}

		if (pBestUnit == NULL)
		{
			break;
		}
		mapUnitDamage.erase(pBestUnit);
		//TB SubCombat Mod Begin
		int iI;
		UnitCombatTypes eUnitCombatType;
		bool isCollateralImmune = false;

		for (iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
		{
			if (/*pBestUnit->*/isHasUnitCombat((UnitCombatTypes)iI))
			{
				eUnitCombatType = ((UnitCombatTypes)iI);
				if (pBestUnit->getUnitInfo().getUnitCombatCollateralImmune(eUnitCombatType))
				{
					isCollateralImmune = true;
				}
			}
		}
		//TB SubCombat Mod End (with the exception of the following reference to 'isCollateralImmune'
		if (!isCollateralImmune)
		{
			const int iTheirStrength = pBestUnit->baseCombatStr();
			const int iStrengthFactor = (iCollateralStrength + iTheirStrength + 1) / 2;

			int iCollateralDamage = 100 * GC.getDefineINT("COLLATERAL_COMBAT_DAMAGE");

			iCollateralDamage *= iStrengthFactor + iCollateralStrength;
			iCollateralDamage /= iStrengthFactor + iTheirStrength;

			iCollateralDamage -= std::min(100, std::max(0, pBestUnit->getCollateralDamageProtection())) * iCollateralDamage / 100;
			iCollateralDamage = std::max(0, iCollateralDamage);
			//TB Combat Mods end

			if (pCity != NULL)
			{
				iCollateralDamage *= 100 + pCity->getAirModifier();
				iCollateralDamage /= 100;
			}

			iCollateralDamage /= 100;

			//TB note: Armor should be checked against the puncture of the attacker (with the weapon in use) and act as a value that diminishes the damage if any armor is left
			//TB note: A dodge check should also be made (% check) to see if the defender evades the random blast or scattered sources of damage coming at him (entirely - all or nothing).

			iCollateralDamage = std::max(0, iCollateralDamage);

			const int iMaxDamage = std::min(collateralDamageLimit(), (collateralDamageLimit() * (iCollateralStrength + iStrengthFactor)) / (iTheirStrength + iStrengthFactor));
			const int iUnitDamage = std::max(pBestUnit->getDamage(), std::min(pBestUnit->getDamage() + iCollateralDamage, iMaxDamage));

			if (pBestUnit->getDamage() != iUnitDamage)
			{
// BUG - Combat Events - start
				int iDamageDone = iUnitDamage - pBestUnit->getDamage();
				pBestUnit->setDamage(iUnitDamage, getOwner());
				//TB Combat Mod begin
				if (dealsColdDamage())
				{
					pBestUnit->setColdDamage(iUnitDamage);
				}
				//TB Combat Mod end
				CvEventReporter::getInstance().combatLogCollateral(this, pBestUnit, iDamageDone);
// BUG - Combat Events - end
				iDamageCount++;
			}
		}
		iCount++;
	}

	if (iDamageCount > 0)
	{
		AddDLLMessage(
			pSkipUnit->getOwner(), pSkipUnit->getDomainType() != DOMAIN_AIR, GC.getEVENT_MESSAGE_TIME(),
			gDLL->getText("TXT_KEY_MISC_YOU_SUFFER_COL_DMG", iDamageCount), "AS2D_COLLATERAL",
			MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_RED(), pSkipUnit->getX(), pSkipUnit->getY(), true, true
		);
		AddDLLMessage(
			getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
			gDLL->getText("TXT_KEY_MISC_YOU_INFLICT_COL_DMG", getNameKey(), iDamageCount),
			"AS2D_COLLATERAL", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_GREEN(), pSkipUnit->getX(), pSkipUnit->getY()
		);
	}
}

void CvUnit::rBombardCombat(const CvPlot* pPlot, CvUnit* pFirstUnit)
{
	const int iRBombardStrength = (getDomainType() == DOMAIN_AIR ? airBaseCombatStr() : baseCombatStr()) * rBombardDamage() / 100;

	if (iRBombardStrength == 0)
	{
		return;
	}
	CvCity* pCity = pPlot->getPlotCity();

	const int iPossibleTargets = std::min(pPlot->getNumVisiblePotentialEnemyDefenders(this), rBombardDamageMaxUnits());

#ifdef OUTBREAKS_AND_AFFLICTIONS
	int iDistanceAttackCommunicability = 0;
	std::vector<int> m_iAfflictionIndex;
	bool bAffliction = false;
	if (GC.getGame().isOption(GAMEOPTION_OUTBREAKS_AND_AFFLICTIONS))
	{
		for (int iI = 0; iI < GC.getNumPromotionLineInfos(); iI++)
		{
			iDistanceAttackCommunicability = getDistanceAttackCommunicability((PromotionLineTypes)iI);
			if (iDistanceAttackCommunicability > 0)
			{
				bAffliction = true;
				PromotionLineTypes eAfflictionLine = ((PromotionLineTypes)iI);
				if (pCity != NULL)
				{
					pCity->changePromotionLineAfflictionAttackCommunicability(eAfflictionLine, iDistanceAttackCommunicability);
				}
				m_iAfflictionIndex.push_back(iI);
			}
		}
	}
#endif // OUTBREAKS_AND_AFFLICTIONS

	std::map<CvUnit*, int>::iterator it;
	std::map<CvUnit*, int> mapUnitDamage;

	foreach_(CvUnit* pLoopUnit, pPlot->units())
	{
		if (pLoopUnit->isEnemy(getTeam(), pPlot, this) && !pLoopUnit->isInvisible(getTeam(), false) && pLoopUnit->canDefend())
		{
			int iValue = pLoopUnit->getHP() * (1 + GC.getGame().getSorenRandNum(100, "Ranged Bombard Damage"));

			//Favor striking the bigger targets
			if (GC.getGame().isOption(GAMEOPTION_SIZE_MATTERS))
			{
				iValue *= pLoopUnit->getSizeMattersSpacialOffsetValue() + 10;
			}

			//Favor the first defender on the front lines less
			if (!isRBombardDirect() && pLoopUnit == pFirstUnit)
			{
				iValue /= 10;
			}
			mapUnitDamage[pLoopUnit] = iValue;
		}
	}

	PlayerTypes eBUPlayer = NO_PLAYER;
	DomainTypes eBUDomain = NO_DOMAIN;
	CvUnit* pBestUnit = NULL;
	int iDamageCount = 0;
	int iCount = 0;

	while (iCount < iPossibleTargets)
	{
		int iBestValue = 0;
		pBestUnit = NULL;

		for (it = mapUnitDamage.begin(); it != mapUnitDamage.end(); ++it)
		{
			if (it->second > iBestValue)
			{
				iBestValue = it->second;
				pBestUnit = it->first;
			}
		}

		if (pBestUnit == NULL)
		{
			break;
		}
		eBUPlayer = pBestUnit->getOwner();
		eBUDomain = pBestUnit->getDomainType();

		mapUnitDamage.erase(pBestUnit);
		//TB SubCombat Mod Begin
		bool isCollateralImmune = false;

		for (int iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
		{
			const UnitCombatTypes eType = static_cast<UnitCombatTypes>(iI);

			if (pBestUnit->isHasUnitCombat(eType) && pBestUnit->getUnitInfo().getUnitCombatCollateralImmune(eType))
			{
				isCollateralImmune = true;
				break;
			}
		}
		//TB SubCombat Mod End (with the exception of the following reference to 'isCollateralImmune'
		if (!isCollateralImmune)
		{
			const int iTheirStrength = pBestUnit->baseCombatStr();
			const int iStrengthFactor = (iRBombardStrength + iTheirStrength + 1) / 2;

			int iRBombardDamage = 100 * GC.getDefineINT("COLLATERAL_COMBAT_DAMAGE");

			iRBombardDamage *= iStrengthFactor + iRBombardStrength;
			iRBombardDamage /= iStrengthFactor + iTheirStrength;

			//TB Combat Mods begin (fortified collateral defense) Reference to iCollatDef was pBestUnit->getCollateralDamageProtection()
			//int iOverrunMod = overrunTotal();
			//int iFortDef = pBestUnit->fortifyCollateralDefenseModifier() - iOverrunMod;
			//int iFortDefzero = iFortDef < 0 ? 0 : iFortDef;
			//int iStdDef = pBestUnit->getCollateralDamageProtection();
			//int iUncheckedDef = /*iFortDefzero +*/ iStdDef;
			//int iUncheckedDefzero = std::max(0, iStdDef);
			int iCollatDef = std::max(0, std::min(pBestUnit->getCollateralDamageProtection(), 100));
			// Reduce bombard damage based on collatoral damage protection factor
			iRBombardDamage -= (iRBombardDamage * iCollatDef) / 100;
			//TB Combat Mods end

			if (pCity != NULL)
			{
				iRBombardDamage *= 100 + pCity->getAirModifier();
				iRBombardDamage /= 100;
			}

			iRBombardDamage /= 100;

			iRBombardDamage = std::max(0, iRBombardDamage);

			//Save data for the message:

			const int iMaxDamage = std::min(rBombardDamageLimit(), rBombardDamageLimit() * (iRBombardStrength + iStrengthFactor) / (iTheirStrength + iStrengthFactor));

			const int iUnitDamage = std::max(pBestUnit->getDamage(), std::min(pBestUnit->getDamage() + iRBombardDamage, iMaxDamage));

			if (pBestUnit->getDamage() != iUnitDamage)
			{
// BUG - Combat Events - start
				int iDamageDone = iUnitDamage - pBestUnit->getDamage();
				pBestUnit->setDamage(iUnitDamage, getOwner());
				//TB Combat Mod begin
				if (dealsColdDamage())
				{
					pBestUnit->setColdDamage(iUnitDamage);
				}
				//TB Combat Mod end
#ifdef OUTBREAKS_AND_AFFLICTIONS
				//Distance Communicability
				if (GC.getGame().isOption(GAMEOPTION_OUTBREAKS_AND_AFFLICTIONS))
				{
					if (bAffliction)
					{
						int iSize = (int)m_iAfflictionIndex.size();
						for (int iJ = 0; iJ < iSize; iJ++)
						{
							int iIndex = m_iAfflictionIndex[iJ];
							PromotionLineTypes eAfflictionLine = (PromotionLineTypes)iIndex;
							int iDAC = getDistanceAttackCommunicability(eAfflictionLine);
							if (pBestUnit->checkContractDisease(eAfflictionLine, iDAC))
							{
								pBestUnit->afflict(eAfflictionLine);
							}
						}
					}
					//Afflict On Attack
					for (int iJ = 0; iJ < GC.getNumPromotionLineInfos(); iJ++)
					{
						if (hasAfflictOnAttackType((PromotionLineTypes)iJ) && isAfflictOnAttackTypeDistance((PromotionLineTypes)iJ) && GC.getPromotionLineInfo((PromotionLineTypes)iJ).isAffliction())
						{
							PromotionLineTypes eAfflictionLinePoison = ((PromotionLineTypes)iJ);
							int iAfflictChance = getAfflictOnAttackTypeProbability(eAfflictionLinePoison) - pBestUnit->fortitudeTotal() - pBestUnit->getUnitAfflictionTolerance(eAfflictionLinePoison);
							int iAfflictCheckResult = GC.getGame().getSorenRandNum(100, "Trap Affliction Check");
							if (iAfflictCheckResult < iAfflictChance)
							{
								pBestUnit->afflict(eAfflictionLinePoison, true, this, false);
							}
						}
					}
				}
#endif // OUTBREAKS_AND_AFFLICTIONS
				CvEventReporter::getInstance().combatLogCollateral(this, pBestUnit, iDamageDone);
// BUG - Combat Events - end
				iDamageCount++;
			}
		}
		iCount++;
	}

	if (pBestUnit == NULL)
	{
		return;
	}
	if (iDamageCount > 0  && pPlot->getX() != -1 && pPlot->getY() != -1)
	{
		AddDLLMessage(
			eBUPlayer, (eBUDomain != DOMAIN_AIR), GC.getEVENT_MESSAGE_TIME(),
			gDLL->getText("TXT_KEY_MISC_YOU_SUFFER_COL_DMG", iDamageCount),
			"AS2D_COLLATERAL", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_RED(), pPlot->getX(), pPlot->getY(), true, true
		);
		AddDLLMessage(
			getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
			gDLL->getText("TXT_KEY_MISC_YOU_INFLICT_COL_DMG", getNameKey(), iDamageCount),
			"AS2D_COLLATERAL", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_GREEN(), pPlot->getX(), pPlot->getY()
		);
	}
	else
	{
		FAssertMsg(pPlot->getX() != -1 && pPlot->getY() != -1, "Unit's X or Y is out of valid range in Ranged Assault");
	}
#ifdef OUTBREAKS_AND_AFFLICTIONS
	m_iAfflictionIndex.clear();
#endif
}


void CvUnit::flankingStrikeCombat(const CvPlot* pPlot, int iAttackerStrength, int iAttackerFirepower, int iDefenderOdds, int iDefenderDamage, CvUnit* pSkipUnit)
{
	if (pSkipUnit && pPlot->isCity(true, pSkipUnit->getTeam()))
	{
		return;
	}

	std::vector< std::pair<CvUnit*, int> > listFlankedUnits;
	foreach_(CvUnit* pLoopUnit, pPlot->units())
	{
		if (pLoopUnit != pSkipUnit && !pLoopUnit->isDead() && isEnemy(pLoopUnit->getTeam(), pPlot, pLoopUnit)
		&& !pLoopUnit->isInvisible(getTeam(), false) && pLoopUnit->canDefend())
		{
			int iFlankingStrength = m_pUnitInfo->getFlankingStrikeUnit(pLoopUnit->getUnitType());

			for (int iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
			{
				if (pLoopUnit->isHasUnitCombat((UnitCombatTypes)iI))
				{
					iFlankingStrength += flankingStrengthbyUnitCombatTotal((UnitCombatTypes)iI);
				}
			}

			if (iFlankingStrength > 0)
			{
				int iFlankedDefenderStrength;
				int iFlankedDefenderOdds;
				int iAttackerDamage;
				int iFlankedDefenderDamage;
				getDefenderCombatValues(*pLoopUnit, pPlot, iAttackerStrength, iAttackerFirepower, iFlankedDefenderOdds, iFlankedDefenderStrength, iAttackerDamage, iFlankedDefenderDamage, NULL, pLoopUnit);

				if (GC.getGame().getSorenRandNum(GC.getCOMBAT_DIE_SIDES(), "Flanking Combat") >= iDefenderOdds)
				{
					const int iUnitDamage = std::max(pLoopUnit->getDamage(), pLoopUnit->getDamage() + iFlankingStrength * iDefenderDamage / 100);

					if (pLoopUnit->getDamage() != iUnitDamage)
					{
						listFlankedUnits.push_back(std::make_pair(pLoopUnit, iUnitDamage));
					}
				}
			}
		}
	}

	int iNumUnitsHit = std::min((int)listFlankedUnits.size(), collateralDamageMaxUnits());

	for (int i = 0; i < iNumUnitsHit; ++i)
	{
		int iIndexHit = GC.getGame().getSorenRandNum(listFlankedUnits.size(), "Pick Flanked Unit");
		CvUnit* pUnit = listFlankedUnits[iIndexHit].first;
		int iDamage = listFlankedUnits[iIndexHit].second;
// BUG - Combat Events - start
		int iDamageDone = iDamage - pUnit->getDamage();
// BUG - Combat Events - end
		pUnit->setDamage(iDamage, getOwner());
		//TB Combat Mod begin
		if (dealsColdDamage())
		{
			pUnit->setColdDamage(iDamage);
		}
		//TB Combat mod end
		if (pUnit->isDead())
		{
			{

				CvWString szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_KILLED_UNIT_BY_FLANKING", getNameKey(), pUnit->getNameKey(), pUnit->getVisualCivAdjective(getTeam()));
				AddDLLMessage(getOwner(), false, GC.getEVENT_MESSAGE_TIME(), szBuffer, GC.getEraInfo(GC.getGame().getCurrentEra()).getAudioUnitVictoryScript(), MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_GREEN(), pPlot->getX(), pPlot->getY());
				szBuffer = gDLL->getText("TXT_KEY_MISC_YOUR_UNIT_DIED_BY_FLANKING", pUnit->getNameKey(), getNameKey(), getVisualCivAdjective(pUnit->getTeam()));
				AddDLLMessage(pUnit->getOwner(), false, GC.getEVENT_MESSAGE_TIME(), szBuffer, GC.getEraInfo(GC.getGame().getCurrentEra()).getAudioUnitDefeatScript(), MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_RED(), pPlot->getX(), pPlot->getY());
			}

			pUnit->kill(false, NO_PLAYER, true);
		}
// BUG - Combat Events - start
		CvEventReporter::getInstance().combatLogFlanking(this, pUnit, iDamageDone);
// BUG - Combat Events - end

		listFlankedUnits.erase(std::remove(listFlankedUnits.begin(), listFlankedUnits.end(), listFlankedUnits[iIndexHit]));
	}

	if (iNumUnitsHit > 0)
	{

		CvWString szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_DAMAGED_UNITS_BY_FLANKING", getNameKey(), iNumUnitsHit);
		AddDLLMessage(getOwner(), false, GC.getEVENT_MESSAGE_TIME(), szBuffer, GC.getEraInfo(GC.getGame().getCurrentEra()).getAudioUnitVictoryScript(), MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_GREEN(), pPlot->getX(), pPlot->getY());

		if (NULL != pSkipUnit)
		{
			szBuffer = gDLL->getText("TXT_KEY_MISC_YOUR_UNITS_DAMAGED_BY_FLANKING", getNameKey(), iNumUnitsHit);
			AddDLLMessage(pSkipUnit->getOwner(), false, GC.getEVENT_MESSAGE_TIME(), szBuffer, GC.getEraInfo(GC.getGame().getCurrentEra()).getAudioUnitDefeatScript(), MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_RED(), pPlot->getX(), pPlot->getY());
		}
	}
}


// Returns true if we were intercepted...
bool CvUnit::interceptTest(const CvPlot* pPlot)
{
	if (GC.getGame().getSorenRandNum(100, "Evasion Rand") >= evasionProbability())
	{
		CvUnit* pInterceptor = bestInterceptor(pPlot);
		if (pInterceptor != NULL)
		{
/************************************************************************************************/
/* Afforess	                  Start		 03/6/10                                                */
/*                                                                                              */
/*  Better Air Interception                                                                     */
/************************************************************************************************/
			int iInterceptionOdds;
			if (GC.getGame().isModderGameOption(MODDERGAMEOPTION_BETTER_INTERCETION))
			{
				iInterceptionOdds = interceptionChance(pPlot);
			}
			else
			{
				iInterceptionOdds = pInterceptor->currInterceptionProbability();
			}
			if (GC.getGame().getSorenRandNum(100, "Intercept Rand (Air)") < iInterceptionOdds)
/************************************************************************************************/
/* Afforess	                     END                                                            */
/************************************************************************************************/
			{
				fightInterceptor(pPlot, false);

				return true;
			}
		}
	}

	return false;
}


CvUnit* CvUnit::airStrikeTarget(const CvPlot* pPlot) const
{
	CvUnit* pDefender = pPlot->getBestDefender(NO_PLAYER, getOwner(), this, true);

	if (pDefender != NULL && !pDefender->isDead() && pDefender->canDefend())
	{
		return pDefender;
	}
	return NULL;
}


bool CvUnit::canAirStrike(const CvPlot* pPlot) const
{
	if (getDomainType() != DOMAIN_AIR)
	{
		return false;
	}

	if (!canAirAttack())
	{
		return false;
	}

	if (pPlot == plot())
	{
		return false;
	}

	if (!pPlot->isVisible(getTeam(), false))
	{
		return false;
	}

	if (plotDistance(getX(), getY(), pPlot->getX(), pPlot->getY()) > airRange())
	{
		return false;
	}

	if (airStrikeTarget(pPlot) == NULL)
	{
		return false;
	}

	if (isMadeAttack())
	{
		return false;
	}

	return true;
}


bool CvUnit::airStrike(CvPlot* pPlot)//
{
	if (!canAirStrike(pPlot))
	{
		return false;
	}

	if (interceptTest(pPlot))
	{
		return false;
	}

	CvUnit* pDefender = airStrikeTarget(pPlot);
	if (pDefender == NULL)
	{
		return false;
	}

	FAssert(pDefender != NULL);
	FAssert(pDefender->canDefend());

	setReconPlot(pPlot);

	CvCity* pCity = pPlot->getPlotCity();

	setMadeAttack(true);
	changeMoves(GC.getMOVE_DENOMINATOR());

	int iDamage = airCombatDamage(pDefender);

	int iUnitDamage = std::max(pDefender->getDamage(), std::min((pDefender->getDamage() + iDamage), airCombatLimit(pDefender)));

	{

		CvWString szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_ARE_ATTACKED_BY_AIR", pDefender->getNameKey(), getNameKey(), -(((iUnitDamage - pDefender->getDamage()) * 100) / pDefender->getMaxHP()));
		AddDLLMessage(pDefender->getOwner(), false, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_AIR_ATTACK", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_RED(), pPlot->getX(), pPlot->getY(), true, true);

		szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_ATTACK_BY_AIR", getNameKey(), pDefender->getNameKey(), -(((iUnitDamage - pDefender->getDamage()) * 100) / pDefender->getMaxHP()));
		AddDLLMessage(getOwner(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_AIR_ATTACKED", MESSAGE_TYPE_INFO, pDefender->getButton(), GC.getCOLOR_GREEN(), pPlot->getX(), pPlot->getY());
	}

	collateralCombat(pPlot, pDefender);

#ifdef OUTBREAKS_AND_AFFLICTIONS
	//Afflict
	int iDistanceAttackCommunicability = 0;
	bool bAffliction = false;
	if (GC.getGame().isOption(GAMEOPTION_OUTBREAKS_AND_AFFLICTIONS))
	{
		for (int iI = 0; iI < GC.getNumPromotionLineInfos(); iI++)
		{
			//Distance Communicability
			iDistanceAttackCommunicability = getDistanceAttackCommunicability((PromotionLineTypes)iI);
			if (iDistanceAttackCommunicability > 0)
			{
				bAffliction = true;
				PromotionLineTypes eAfflictionLine = ((PromotionLineTypes)iI);
				if (pDefender->checkContractDisease(eAfflictionLine, iDistanceAttackCommunicability))
				{
					pDefender->afflict(eAfflictionLine);
				}
				if (pCity != NULL)
				{
					pCity->changePromotionLineAfflictionAttackCommunicability(eAfflictionLine, iDistanceAttackCommunicability);
				}
			}
			//Afflict On Attack
			if (hasAfflictOnAttackType((PromotionLineTypes)iI)  && isAfflictOnAttackTypeDistance((PromotionLineTypes)iI) && GC.getPromotionLineInfo((PromotionLineTypes)iI).isAffliction())
			{
				PromotionLineTypes eAfflictionLinePoison = ((PromotionLineTypes)iI);
				int iAfflictChance = getAfflictOnAttackTypeProbability(eAfflictionLinePoison) - pDefender->fortitudeTotal() - pDefender->getUnitAfflictionTolerance(eAfflictionLinePoison);
				int iAfflictCheckResult = GC.getGame().getSorenRandNum(100, "Air Raid Affliction Check");
				if (iAfflictCheckResult < iAfflictChance)
				{
					pDefender->afflict(eAfflictionLinePoison, true, this, false);
				}
			}
		}
	}
#endif // OUTBREAKS_AND_AFFLICTIONS

	pDefender->setDamage(iUnitDamage, getOwner());
	//TB Combat Mod Begin
	if (dealsColdDamage())
	{
		pDefender->setColdDamage(iUnitDamage);
	}
	//TB Combat mod end
/************************************************************************************************/
/* Afforess	                  Start		 08/03/10                                               */
/*                                                                                              */
/*                                                                                              */
/************************************************************************************************/
	if (GC.getGame().isModderGameOption(MODDERGAMEOPTION_IMPROVED_XP))
	{
		setExperience100(getExperience100() + 25);
	}
/************************************************************************************************/
/* Afforess	                     END                                                            */
/************************************************************************************************/


	return true;
}

bool CvUnit::canRangeStrike() const
{
	if (getDomainType() == DOMAIN_AIR)
	{
		return false;
	}

	if (airRange() <= 0)
	{
		return false;
	}

	if (airBaseCombatStr() <= 0)
	{
		return false;
	}

	if (!canFight())
	{
		return false;
	}

	if (isMadeAttack() && !isBlitz())
	{
		return false;
	}

	if (!canMove() && getMoves() > 0)
	{
		return false;
	}

	return true;
}

bool CvUnit::canRangeStrikeAt(const CvPlot* pPlot, int iX, int iY) const
{
	if (!canRangeStrike())
	{
		return false;
	}

	const CvPlot* pTargetPlot = GC.getMap().plot(iX, iY);

	if (NULL == pTargetPlot)
	{
		return false;
	}

	if (!pPlot->isVisible(getTeam(), false))
	{
		return false;
	}

/************************************************************************************************/
/* UNOFFICIAL_PATCH                       05/10/10                             jdog5000         */
/*                                                                                              */
/* Bugfix                                                                                       */
/************************************************************************************************/
	// Need to check target plot too
	//Fuyu: AI-controlled units can strike even when tile is invisible
	if (isHuman() && !isAutomated() && !pTargetPlot->isVisible(getTeam(), false))
	{
		return false;
	}
/************************************************************************************************/
/* UNOFFICIAL_PATCH                        END                                                  */
/************************************************************************************************/

	if (plotDistance(pPlot->getX(), pPlot->getY(), pTargetPlot->getX(), pTargetPlot->getY()) > airRange())
	{
		return false;
	}

	const CvUnit* pDefender = airStrikeTarget(pTargetPlot);
	if (NULL == pDefender)
	{
		return false;
	}

	if (!pPlot->canSeePlot(pTargetPlot, getTeam(), airRange(), getFacingDirection(true)))
	{
		return false;
	}

	return true;
}


bool CvUnit::rangeStrike(int iX, int iY)
{
	CvPlot* pPlot = GC.getMap().plot(iX, iY);
	if (NULL == pPlot)
	{
		return false;
	}
	if (!canRangeStrikeAt(plot(), iX, iY))
	{
		return false;
	}

	CvUnit* pDefender = airStrikeTarget(pPlot);

	FAssert(pDefender != NULL);
	FAssert(pDefender->canDefend());

	if (GC.getDefineINT("RANGED_ATTACKS_USE_MOVES") == 0)
	{
		setMadeAttack(true);
	}
	changeMoves(GC.getMOVE_DENOMINATOR());

	const int iUnitDamage = std::max(
		pDefender->getDamage(),
		std::min(
			pDefender->getDamage() + rangeCombatDamage(pDefender),
			airCombatLimit(pDefender)
		)
	);

	{

		CvWString szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_ARE_ATTACKED_BY_AIR",
			pDefender->getNameKey(), getNameKey(), (iUnitDamage - pDefender->getDamage()) * -100 / pDefender->getMaxHP()
		);
		//red icon over attacking unit
		AddDLLMessage(pDefender->getOwner(), false, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_COMBAT", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_RED(), this->getX(), this->getY(), true, true);
		//white icon over defending unit
		AddDLLMessage(pDefender->getOwner(), false, 0, L"", "AS2D_COMBAT", MESSAGE_TYPE_DISPLAY_ONLY, pDefender->getButton(), GC.getCOLOR_WHITE(), pDefender->getX(), pDefender->getY(), true, true);

		szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_ATTACK_BY_AIR", getNameKey(), pDefender->getNameKey(), -(((iUnitDamage - pDefender->getDamage()) * 100) / pDefender->getMaxHP()));
		AddDLLMessage(getOwner(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_COMBAT", MESSAGE_TYPE_INFO, pDefender->getButton(), GC.getCOLOR_GREEN(), pPlot->getX(), pPlot->getY());
	}

	collateralCombat(pPlot, pDefender);

#ifdef OUTBREAKS_AND_AFFLICTIONS
	//Afflict
	int iDistanceAttackCommunicability = 0;
	bool bAffliction = false;
	if (GC.getGame().isOption(GAMEOPTION_OUTBREAKS_AND_AFFLICTIONS))
	{
		CvCity* pCity = pPlot->getPlotCity();

		for (int iI = 0; iI < GC.getNumPromotionLineInfos(); iI++)
		{
			//Distance Communicability
			iDistanceAttackCommunicability = getDistanceAttackCommunicability((PromotionLineTypes)iI);
			if (iDistanceAttackCommunicability > 0)
			{
				bAffliction = true;
				PromotionLineTypes eAfflictionLine = ((PromotionLineTypes)iI);
				if (pDefender->checkContractDisease(eAfflictionLine, iDistanceAttackCommunicability))
				{
					pDefender->afflict(eAfflictionLine);
				}
				if (pCity != NULL)
				{
					pCity->changePromotionLineAfflictionAttackCommunicability(eAfflictionLine, iDistanceAttackCommunicability);
				}
			}
			//Afflict On Attack
			if (hasAfflictOnAttackType((PromotionLineTypes)iI) && isAfflictOnAttackTypeDistance((PromotionLineTypes)iI) && GC.getPromotionLineInfo((PromotionLineTypes)iI).isAffliction())
			{
				PromotionLineTypes eAfflictionLinePoison = ((PromotionLineTypes)iI);
				int iAfflictChance = getAfflictOnAttackTypeProbability(eAfflictionLinePoison) - pDefender->fortitudeTotal() - pDefender->getUnitAfflictionTolerance(eAfflictionLinePoison);
				int iAfflictCheckResult = GC.getGame().getSorenRandNum(100, "Air Raid Affliction Check");
				if (iAfflictCheckResult < iAfflictChance)
				{
					pDefender->afflict(eAfflictionLinePoison, true, this, false);
				}
			}
		}
	}
#endif
	//set damage but don't update entity damage visibility
	pDefender->setDamage(iUnitDamage, getOwner(), false);
	//TB Combat Mod begin
	if (dealsColdDamage())
	{
		pDefender->setColdDamage(iUnitDamage);
	}
	//TB Combat Mod end

	// Range strike entity mission
	addMission(CvMissionDefinition(MISSION_RANGE_ATTACK, pDefender->plot(), this, pDefender));

	return true;
}

//------------------------------------------------------------------------------------------------
// FUNCTION:    CvUnit::planBattle
//! \brief      Determines in general how a battle will progress.
//!
//!				Note that the outcome of the battle is not determined here. This function plans
//!				how many sub-units die and in which 'rounds' of battle.
//! \param      kBattleDefinition The battle definition, which receives the battle plan.
//! \retval     The number of game turns that the battle should be given.
//------------------------------------------------------------------------------------------------
int CvUnit::planBattle( CvBattleDefinition & kBattleDefinition ) const
{
#define BATTLE_TURNS_SETUP 4
/************************************************************************************************/
/* Afforess	                  Start		 6/20/11                                                */
/*                                                                                              */
/* Boost ending rounds to allow all unit animations to end                                      */
/************************************************************************************************/
/*
#define BATTLE_TURNS_ENDING 4
*/
#define BATTLE_TURNS_ENDING 6
/************************************************************************************************/
/* Afforess	                     END                                                            */
/************************************************************************************************/


#define BATTLE_TURNS_MELEE 6
#define BATTLE_TURNS_RANGED 6
#define BATTLE_TURN_RECHECK 4

	int								aiUnitsBegin[BATTLE_UNIT_COUNT];
	int								aiUnitsEnd[BATTLE_UNIT_COUNT];
	int								aiToKillMelee[BATTLE_UNIT_COUNT];
	int								aiToKillRanged[BATTLE_UNIT_COUNT];
	CvBattleRoundVector::iterator	iIterator;
	int								i, j;
	bool							bIsLoser;
	int								iRoundIndex;
	int								iTotalRounds = 0;
	int								iRoundCheck = BATTLE_TURN_RECHECK;

	// Initial conditions
	kBattleDefinition.setNumRangedRounds(0);
	kBattleDefinition.setNumMeleeRounds(0);

	int iFirstStrikesDelta = kBattleDefinition.getFirstStrikes(BATTLE_UNIT_ATTACKER) - kBattleDefinition.getFirstStrikes(BATTLE_UNIT_DEFENDER);
	if (iFirstStrikesDelta > 0) // Attacker first strikes
	{
		int iKills = computeUnitsToDie( kBattleDefinition, true, BATTLE_UNIT_DEFENDER );
		kBattleDefinition.setNumRangedRounds(std::max(iFirstStrikesDelta, iKills / iFirstStrikesDelta));
	}
	else if (iFirstStrikesDelta < 0) // Defender first strikes
	{
		int iKills = computeUnitsToDie( kBattleDefinition, true, BATTLE_UNIT_ATTACKER );
		iFirstStrikesDelta = -iFirstStrikesDelta;
		kBattleDefinition.setNumRangedRounds(std::max(iFirstStrikesDelta, iKills / iFirstStrikesDelta));
	}
	increaseBattleRounds( kBattleDefinition);


	// Keep randomizing until we get something valid
	do
	{
		iRoundCheck++;
		if ( iRoundCheck >= BATTLE_TURN_RECHECK )
		{
			increaseBattleRounds( kBattleDefinition);
			iTotalRounds = kBattleDefinition.getNumRangedRounds() + kBattleDefinition.getNumMeleeRounds();
			iRoundCheck = 0;
		}

		// Make sure to clear the battle plan, we may have to do this again if we can't find a plan that works.
		kBattleDefinition.clearBattleRounds();

		// Create the round list
		CvBattleRound kRound;
		kBattleDefinition.setBattleRound(iTotalRounds, kRound);

		// For the attacker and defender
		for ( i = 0; i < BATTLE_UNIT_COUNT; i++ )
		{
			// Gather some initial information
			BattleUnitTypes unitType = (BattleUnitTypes) i;
			aiUnitsBegin[unitType] = kBattleDefinition.getUnit(unitType)->getSubUnitsAlive(kBattleDefinition.getDamage(unitType, BATTLE_TIME_BEGIN));
			aiToKillRanged[unitType] = computeUnitsToDie( kBattleDefinition, true, unitType);
			aiToKillMelee[unitType] = computeUnitsToDie( kBattleDefinition, false, unitType);
			aiUnitsEnd[unitType] = aiUnitsBegin[unitType] - aiToKillMelee[unitType] - aiToKillRanged[unitType];

			// Make sure that if they aren't dead at the end, they have at least one unit left
			if ( aiUnitsEnd[unitType] == 0 && !kBattleDefinition.getUnit(unitType)->isDead() )
			{
				aiUnitsEnd[unitType]++;
				if ( aiToKillMelee[unitType] > 0 )
				{
					aiToKillMelee[unitType]--;
				}
				else
				{
					aiToKillRanged[unitType]--;
				}
			}

			// If one unit is the loser, make sure that at least one of their units dies in the last round
			if ( aiUnitsEnd[unitType] == 0 )
			{
				kBattleDefinition.getBattleRound(iTotalRounds - 1).addNumKilled(unitType, 1);
				if ( aiToKillMelee[unitType] > 0)
				{
					aiToKillMelee[unitType]--;
				}
				else
				{
					aiToKillRanged[unitType]--;
				}
			}

			// Randomize in which round each death occurs
			bIsLoser = aiUnitsEnd[unitType] == 0;

			// Randomize the ranged deaths
			for ( j = 0; j < aiToKillRanged[unitType]; j++ )
			{
				iRoundIndex = GC.getGame().getSorenRandNum( range( kBattleDefinition.getNumRangedRounds(), 0, kBattleDefinition.getNumRangedRounds()), "Ranged combat death");
				kBattleDefinition.getBattleRound(iRoundIndex).addNumKilled(unitType, 1);
			}

			// Randomize the melee deaths
			for ( j = 0; j < aiToKillMelee[unitType]; j++ )
			{
				iRoundIndex = GC.getGame().getSorenRandNum( range( kBattleDefinition.getNumMeleeRounds() - (bIsLoser ? 1 : 2 ), 0, kBattleDefinition.getNumMeleeRounds()), "Melee combat death");
				kBattleDefinition.getBattleRound(kBattleDefinition.getNumRangedRounds() + iRoundIndex).addNumKilled(unitType, 1);
			}

			// Compute alive sums
			int iNumberKilled = 0;
			for(int j=0;j<kBattleDefinition.getNumBattleRounds();j++)
			{
				CvBattleRound &round = kBattleDefinition.getBattleRound(j);
				round.setRangedRound(j < kBattleDefinition.getNumRangedRounds());
				iNumberKilled += round.getNumKilled(unitType);
				round.setNumAlive(unitType, aiUnitsBegin[unitType] - iNumberKilled);
			}
		}

		// Now compute wave sizes
		for(int i=0;i<kBattleDefinition.getNumBattleRounds();i++)
		{
			CvBattleRound &round = kBattleDefinition.getBattleRound(i);
			round.setWaveSize(computeWaveSize(round.isRangedRound(), round.getNumAlive(BATTLE_UNIT_ATTACKER) + round.getNumKilled(BATTLE_UNIT_ATTACKER), round.getNumAlive(BATTLE_UNIT_DEFENDER) + round.getNumKilled(BATTLE_UNIT_DEFENDER)));
		}

		if ( iTotalRounds > 400 )
		{
			kBattleDefinition.setNumMeleeRounds(1);
			kBattleDefinition.setNumRangedRounds(0);
			break;
		}
	}
	while ( !verifyRoundsValid( kBattleDefinition ));

	//add a little extra time for leader to surrender
	bool attackerLeader = false;
	bool defenderLeader = false;
	bool attackerDie = false;
	bool defenderDie = false;
	int lastRound = kBattleDefinition.getNumBattleRounds() - 1;
	if(kBattleDefinition.getUnit(BATTLE_UNIT_ATTACKER)->getLeaderUnitType() != NO_UNIT)
		attackerLeader = true;
	if(kBattleDefinition.getUnit(BATTLE_UNIT_DEFENDER)->getLeaderUnitType() != NO_UNIT)
		defenderLeader = true;
	if(kBattleDefinition.getBattleRound(lastRound).getNumAlive(BATTLE_UNIT_ATTACKER) == 0)
		attackerDie = true;
	if(kBattleDefinition.getBattleRound(lastRound).getNumAlive(BATTLE_UNIT_DEFENDER) == 0)
		defenderDie = true;

	int extraTime = 0;
	if((attackerLeader && attackerDie) || (defenderLeader && defenderDie))
		extraTime = BATTLE_TURNS_MELEE;

	if ( (!kBattleDefinition.getUnit(BATTLE_UNIT_ATTACKER)->isUsingDummyEntities() && kBattleDefinition.getUnit(BATTLE_UNIT_ATTACKER)->isInViewport() && showSeigeTower(kBattleDefinition.getUnit(BATTLE_UNIT_ATTACKER))) || //K-mod
		 (!kBattleDefinition.getUnit(BATTLE_UNIT_DEFENDER)->isUsingDummyEntities() && kBattleDefinition.getUnit(BATTLE_UNIT_DEFENDER)->isInViewport() && showSeigeTower(kBattleDefinition.getUnit(BATTLE_UNIT_DEFENDER))) )  //K-mod
	{
		extraTime = BATTLE_TURNS_MELEE;
	}

	return BATTLE_TURNS_SETUP + BATTLE_TURNS_ENDING + kBattleDefinition.getNumMeleeRounds() * BATTLE_TURNS_MELEE + kBattleDefinition.getNumRangedRounds() * BATTLE_TURNS_MELEE + extraTime;
}

//------------------------------------------------------------------------------------------------
// FUNCTION:	CvBattleManager::computeDeadUnits
//! \brief		Computes the number of units dead, for either the ranged or melee portion of combat.
//! \param		kDefinition The battle definition.
//! \param		bRanged true if computing the number of units that die during the ranged portion of combat,
//!					false if computing the number of units that die during the melee portion of combat.
//! \param		iUnit The index of the unit to compute (BATTLE_UNIT_ATTACKER or BATTLE_UNIT_DEFENDER).
//! \retval		The number of units that should die for the given unit in the given portion of combat
//------------------------------------------------------------------------------------------------
int CvUnit::computeUnitsToDie( const CvBattleDefinition & kDefinition, bool bRanged, BattleUnitTypes iUnit ) const
{
	FAssertMsg( iUnit == BATTLE_UNIT_ATTACKER || iUnit == BATTLE_UNIT_DEFENDER, "Invalid unit index");

	BattleTimeTypes iBeginIndex = bRanged ? BATTLE_TIME_BEGIN : BATTLE_TIME_RANGED;
	BattleTimeTypes iEndIndex = bRanged ? BATTLE_TIME_RANGED : BATTLE_TIME_END;
	return kDefinition.getUnit(iUnit)->getSubUnitsAlive(kDefinition.getDamage(iUnit, iBeginIndex)) -
		kDefinition.getUnit(iUnit)->getSubUnitsAlive( kDefinition.getDamage(iUnit, iEndIndex));
}

//------------------------------------------------------------------------------------------------
// FUNCTION:    CvUnit::verifyRoundsValid
//! \brief      Verifies that all rounds in the battle plan are valid
//! \param      vctBattlePlan The battle plan
//! \retval     true if the battle plan (seems) valid, false otherwise
//------------------------------------------------------------------------------------------------
bool CvUnit::verifyRoundsValid( const CvBattleDefinition & battleDefinition ) const
{
	for(int i=0;i<battleDefinition.getNumBattleRounds();i++)
	{
		if(!battleDefinition.getBattleRound(i).isValid())
			return false;
	}
	return true;
}

//------------------------------------------------------------------------------------------------
// FUNCTION:    CvUnit::increaseBattleRounds
//! \brief      Increases the number of rounds in the battle.
//! \param      kBattleDefinition The definition of the battle
//------------------------------------------------------------------------------------------------
void CvUnit::increaseBattleRounds( CvBattleDefinition & kBattleDefinition ) const
{
	if ( kBattleDefinition.getUnit(BATTLE_UNIT_ATTACKER)->isRanged() && kBattleDefinition.getUnit(BATTLE_UNIT_DEFENDER)->isRanged())
	{
		kBattleDefinition.addNumRangedRounds(1);
	}
	else
	{
		kBattleDefinition.addNumMeleeRounds(1);
	}
}

//------------------------------------------------------------------------------------------------
// FUNCTION:    CvUnit::computeWaveSize
//! \brief      Computes the wave size for the round.
//! \param      bRangedRound true if the round is a ranged round
//! \param		iAttackerMax The maximum number of attackers that can participate in a wave (alive)
//! \param		iDefenderMax The maximum number of Defenders that can participate in a wave (alive)
//! \retval     The desired wave size for the given parameters
//------------------------------------------------------------------------------------------------
int CvUnit::computeWaveSize( bool bRangedRound, int iAttackerMax, int iDefenderMax ) const
{
	FAssertMsg( getCombatUnit() != NULL, "You must be fighting somebody!" );
	int aiDesiredSize[BATTLE_UNIT_COUNT];
	if ( bRangedRound )
	{
		aiDesiredSize[BATTLE_UNIT_ATTACKER] = getUnitInfo().getRangedWaveSize();
		aiDesiredSize[BATTLE_UNIT_DEFENDER] = getCombatUnit()->getUnitInfo().getRangedWaveSize();
	}
	else
	{
		aiDesiredSize[BATTLE_UNIT_ATTACKER] = getUnitInfo().getMeleeWaveSize();
		aiDesiredSize[BATTLE_UNIT_DEFENDER] = getCombatUnit()->getUnitInfo().getMeleeWaveSize();
	}

	aiDesiredSize[BATTLE_UNIT_DEFENDER] = aiDesiredSize[BATTLE_UNIT_DEFENDER] <= 0 ? iDefenderMax : aiDesiredSize[BATTLE_UNIT_DEFENDER];
	aiDesiredSize[BATTLE_UNIT_ATTACKER] = aiDesiredSize[BATTLE_UNIT_ATTACKER] <= 0 ? iDefenderMax : aiDesiredSize[BATTLE_UNIT_ATTACKER];
	return std::min( std::min( aiDesiredSize[BATTLE_UNIT_ATTACKER], iAttackerMax ), std::min( aiDesiredSize[BATTLE_UNIT_DEFENDER],
		iDefenderMax) );
}

bool CvUnit::isTargetOf(const CvUnit& attacker) const
{
	const CvUnitInfo& attackerInfo = attacker.getUnitInfo();
	const CvUnitInfo& ourInfo = getUnitInfo();

	//if (!plot()->isCity(true, getTeam()) || (attacker.plot() == plot() && (attacker.isAssassin() || isAssassin())))
	//{

	if (getUnitType() != NO_UNIT && attackerInfo.isTargetUnit(getUnitType()))
	{
		return true;
	}

	if (attacker.getUnitType() != NO_UNIT && ourInfo.isDefendAgainstUnit(attacker.getUnitType()))
	{
		return true;
	}

	// TB SubCombat Mod Begin - Original code:
	for (std::map<UnitCombatTypes, UnitCombatKeyedInfo>::const_iterator it = m_unitCombatKeyedInfo.begin(), end = m_unitCombatKeyedInfo.end(); it != end; ++it)
	{
		if(it->second.m_bHasUnitCombat)
		{
			if (attackerInfo.getTargetUnitCombat(it->first) ||
				attacker.hasTargetUnitCombat(it->first))
			{
				return true;
			}
		}
	}
	//TB SubCombat Mod End

	//}


	// TB SubCombat Mod Begin
	for (std::map<UnitCombatTypes, UnitCombatKeyedInfo>::const_iterator it = attacker.m_unitCombatKeyedInfo.begin(), end = attacker.m_unitCombatKeyedInfo.end(); it != end; ++it)
	{
		if(it->second.m_bHasUnitCombat)
		{
			if (ourInfo.getDefenderUnitCombat(it->first))
			{
				return true;
			}
		}
	}
	//TB SubCombat Mod End

	return false;
}

bool CvUnit::isEnemy(TeamTypes eTeam, const CvPlot* pPlot, const CvUnit* pUnit) const
{
	if (pUnit != NULL && (isBarbCoExist() && pUnit->isHominid() || pUnit->isBarbCoExist() && isHominid()))
	{
		return false;
	}

	if (pPlot == NULL)
	{
		pPlot = plot();
	}

	return atWar(GET_PLAYER(getCombatOwner(eTeam, pPlot)).getTeam(), eTeam);
}

bool CvUnit::isPotentialEnemy(TeamTypes eTeam, const CvPlot* pPlot, const CvUnit* pUnit) const
{
	if (pUnit != NULL && (isBarbCoExist() && pUnit->isHominid() || pUnit->isBarbCoExist() && isHominid()))
	{
		return false;
	}

	if (pPlot == NULL)
	{
		pPlot = plot();
	}

	return ::isPotentialEnemy(GET_PLAYER(getCombatOwner(eTeam, pPlot)).getTeam(), eTeam);
}

bool CvUnit::isSuicide() const
{
	return m_pUnitInfo->isSuicide() || getKamikazePercent() != 0;
}

int CvUnit::getDropRange() const
{
	return (m_pUnitInfo->getDropRange() + getExtraDropRange());
}

void CvUnit::getDefenderCombatValues(const CvUnit& kDefender, const CvPlot* pPlot, int iOurStrength, int iOurFirepower, int& iTheirOdds, int& iTheirStrength, int& iOurDamage, int& iTheirDamage, CombatDetails* pTheirDetails, const CvUnit* pDefender) const
{
	//TB Combat Mod begin
	iTheirStrength = std::max(1,kDefender.currCombatStr(pPlot, this, pTheirDetails));
	int iTheirFirepower = std::max(1, kDefender.currFirepower(pPlot, this));

	if (kDefender.getCombatPowerShots() > 0)
	{
		iTheirStrength += ((iTheirStrength * kDefender.powerShotCombatModifierTotal())/100);
		iTheirFirepower += ((iTheirFirepower * kDefender.powerShotCombatModifierTotal())/100);
	}
	if (getCombatPowerShots() > 0)
	{
		iOurStrength += ((iOurStrength * powerShotCombatModifierTotal())/100);
		iOurFirepower += ((iOurFirepower * powerShotCombatModifierTotal())/100);
	}

#ifdef STRENGTH_IN_NUMBERS
	if (GC.getGame().isOption(GAMEOPTION_STRENGTH_IN_NUMBERS))
	{
		int iTheirSupportStrength = kDefender.getDefenderSupportValue(this);
		int iOurSupportStrength = getAttackerSupportValue();
		iOurStrength += iOurSupportStrength;
		iOurFirepower += iOurSupportStrength;
		iTheirStrength += iTheirSupportStrength;
		iTheirFirepower += iTheirSupportStrength;
	}
#endif // STRENGTH_IN_NUMBERS

	//TB Combat Mod end

	FAssert((iOurStrength + iTheirStrength) > 0);
	FAssert((iOurFirepower + iTheirFirepower) > 0);

	iTheirOdds = ((GC.getCOMBAT_DIE_SIDES() * iTheirStrength) / (iOurStrength + iTheirStrength));

	// Free wins against NPC
	if (isNPC())
	{
		if (!kDefender.isNPC() && GET_PLAYER(kDefender.getOwner()).getWinsVsBarbs() < GC.getHandicapInfo(GET_PLAYER(kDefender.getOwner()).getHandicapType()).getFreeWinsVsBarbs())
		{
			iTheirOdds =  std::max((90 * GC.getCOMBAT_DIE_SIDES()) / 100, iTheirOdds);
		}
	}
	else if (kDefender.isNPC() && GET_PLAYER(getOwner()).getWinsVsBarbs() < GC.getHandicapInfo(GET_PLAYER(getOwner()).getHandicapType()).getFreeWinsVsBarbs())
	{
		iTheirOdds = std::min((10 * GC.getCOMBAT_DIE_SIDES()) / 100, iTheirOdds);
	}

	int iStrengthFactor = ((iOurFirepower + iTheirFirepower + 1) / 2);
	//TB Combat Mods Begin
	CvUnit* pAttacker = (CvUnit*)this;
	int iAttackArmorTotal = armorVSOpponentProbTotal(pDefender);
	int iDefendPunctureTotal = kDefender.punctureVSOpponentProbTotal(pAttacker);
	int iAttackPunctureTotal = punctureVSOpponentProbTotal(pDefender);
	int iDefendArmorTotal = kDefender.armorVSOpponentProbTotal(pAttacker);
	if (kDefender.getCombatPowerShots() > 0)
	{
		iDefendPunctureTotal += kDefender.powerShotPunctureModifierTotal();
	}
	if (getCombatPowerShots() > 0)
	{
		iAttackPunctureTotal += powerShotPunctureModifierTotal();
	}

	int iUnmodifiedDefenderArmor = (iDefendArmorTotal - iAttackPunctureTotal);
	int iUnmodifiedAttackerArmor = (iAttackArmorTotal - iDefendPunctureTotal);
	int iModifiedDefenderArmorZero = (iUnmodifiedDefenderArmor < 0 ? 0 : iUnmodifiedDefenderArmor);
	int iModifiedAttackerArmorZero = (iUnmodifiedAttackerArmor < 0 ? 0 : iUnmodifiedAttackerArmor);
	int iModifiedDefenderArmor = (iModifiedDefenderArmorZero < 95 ? iModifiedDefenderArmorZero : 95);
	int iModifiedAttackerArmor = (iModifiedAttackerArmorZero < 95 ? iModifiedAttackerArmorZero: 95);

	int iDefenderArmor = (100 - iModifiedDefenderArmor);
	int iAttackerArmor = (100 - iModifiedAttackerArmor);
	// UncutDragon
/* original code
	iOurDamage = std::max(1, ((GC.getDefineINT("COMBAT_DAMAGE") * (iTheirFirepower + iStrengthFactor)) / (iOurFirepower + iStrengthFactor)));
	iTheirDamage = std::max(1, ((GC.getDefineINT("COMBAT_DAMAGE") * (iOurFirepower + iStrengthFactor)) / (iTheirFirepower + iStrengthFactor)));
*/	// modified by both UncutDragon and TB
	int iDefendDamageModifierTotal = kDefender.damageModifierTotal();
	int iAttackDamageModifierTotal = damageModifierTotal();

	int iOurDamageBase = ((GC.getCOMBAT_DAMAGE() * (iTheirFirepower + iStrengthFactor)) / std::max(1, (iOurFirepower + iStrengthFactor)));
	int iTheirDamageBase = ((GC.getCOMBAT_DAMAGE() * (iOurFirepower + iStrengthFactor)) / std::max(1, (iTheirFirepower + iStrengthFactor)));
	int iOurDamageModified = iOurDamageBase + ((iOurDamageBase * iDefendDamageModifierTotal)/100);
	int iTheirDamageModified = iTheirDamageBase + ((iTheirDamageBase * iAttackDamageModifierTotal)/100);
	int iOurDamageArmor = (iOurDamageModified * iAttackerArmor)/100;
	int iTheirDamageArmor = (iTheirDamageModified * iDefenderArmor)/100;
	iOurDamage  = std::max(1, iOurDamageArmor);
	iTheirDamage  = std::max(1, iTheirDamageArmor);
	//iOurDamage = std::max(1, ((((GC.getCOMBAT_DAMAGE() * (iTheirFirepower + iStrengthFactor)) / (iOurFirepower + iStrengthFactor)) * iAttackerArmor)/100));
	//iTheirDamage = std::max(1, ((((GC.getCOMBAT_DAMAGE() * (iOurFirepower + iStrengthFactor)) / (iTheirFirepower + iStrengthFactor)) * iDefenderArmor)/100));
	// /UncutDragon
	//TB Combat Mods End
/************************************************************************************************/
/* BETTER_BTS_AI_MOD                       END                                                  */
/************************************************************************************************/
	iTheirStrength = std::max(1,iTheirStrength);
}

int CvUnit::getTriggerValue(EventTriggerTypes eTrigger, const CvPlot* pPlot, bool bCheckPlot) const
{
	const CvEventTriggerInfo& kTrigger = GC.getEventTriggerInfo(eTrigger);
	if (kTrigger.getNumUnits() <= 0)
	{
		return MIN_INT;
	}

	if (isDead())
	{
		return MIN_INT;
	}

	if (kTrigger.getNumUnitsRequired() > 0)
	{
		bool bFoundValid = false;
		for (int i = 0; i < kTrigger.getNumUnitsRequired(); ++i)
		{
			if (getUnitType() == kTrigger.getUnitRequired(i))
			{
				bFoundValid = true;
				break;
			}
		}

		if (!bFoundValid)
		{
			return MIN_INT;
		}
	}

	if (bCheckPlot && plot() != NULL)
	{
		if (kTrigger.isUnitsOnPlot())
		{
			if (!plot()->canTrigger(eTrigger, getOwner()))
			{
				return MIN_INT;
			}
		}
	}

	int iValue = 0;

	if (0 == getDamage() && kTrigger.getUnitDamagedWeight() > 0)
	{
		return MIN_INT;
	}

	//	Call out to Python last as its the most expensive part of the calcuation
	//	and we'll often have decided the trigger is inapplicable before this
	if (!CvString(kTrigger.getPythonCanDoUnit()).empty())
	{
		if (!Cy::call<bool>(PYRandomEventModule, kTrigger.getPythonCanDoUnit(), Cy::Args()
			<< eTrigger
			<< getOwner()
			<< getID()))
		{
			return MIN_INT;
		}
	}

	iValue += getDamage() * kTrigger.getUnitDamagedWeight();

	iValue += getExperience() * kTrigger.getUnitExperienceWeight();

	if (NULL != pPlot)
	{
		iValue += plotDistance(getX(), getY(), pPlot->getX(), pPlot->getY()) * kTrigger.getUnitDistanceWeight();
	}

	return iValue;
}

bool CvUnit::canApplyEvent(EventTypes eEvent) const
{
	const CvEventInfo& kEvent = GC.getEventInfo(eEvent);

	if (0 != kEvent.getUnitExperience())
	{
		if (!canAcquirePromotionAny())
		{
			return false;
		}
	}

	if (kEvent.getUnitImmobileTurns() > 0)
	{
		if (!canAttack())
		{
			return false;
		}
	}
	return true;
}

void CvUnit::applyEvent(EventTypes eEvent)
{
	if (!canApplyEvent(eEvent))
	{
		return;
	}

	const CvEventInfo& kEvent = GC.getEventInfo(eEvent);

	if (0 != kEvent.getUnitExperience())
	{
		setDamage(0);
		changeExperience(kEvent.getUnitExperience());
	}


	if (kEvent.getUnitImmobileTurns() > 0)
	{
		changeImmobileTimer(kEvent.getUnitImmobileTurns());


		CvWString szText = gDLL->getText("TXT_KEY_EVENT_UNIT_IMMOBILE", getNameKey(), kEvent.getUnitImmobileTurns());
		AddDLLMessage(getOwner(), false, GC.getEVENT_MESSAGE_TIME(), szText, "AS2D_UNITGIFTED", MESSAGE_TYPE_INFO, getButton(), (ColorTypes)GC.getInfoTypeForString("COLOR_UNIT_TEXT"), getX(), getY(), true, true);
	}

	CvWString szNameKey(kEvent.getUnitNameKey());

	if (!szNameKey.empty())
	{
		setName(gDLL->getText(kEvent.getUnitNameKey()));
	}

	if (kEvent.isDisbandUnit())
	{
		kill(false, NO_PLAYER, true);
	}
}

const CvArtInfoUnit* CvUnit::getArtInfo(int i, EraTypes eEra) const
{
	return m_pUnitInfo->getArtInfo(i, eEra, (UnitArtStyleTypes) GC.getCivilizationInfo(getCivilizationType()).getUnitArtStyleType());
}

const char* CvUnit::getButton() const
{
	const CvArtInfoUnit* pArtInfo = getArtInfo(0, GET_PLAYER(getOwner()).getCurrentEra());

	if (NULL != pArtInfo)
	{
		return pArtInfo->getButton();
	}

	return m_pUnitInfo->getButton();
}

int CvUnit::getGroupSize() const
{
	if (GC.getGame().isOption(GAMEOPTION_SIZE_MATTERS) && groupRank() > 0)
	{
		return groupRank();
	}
	return m_pUnitInfo->getGroupSize();
}

int CvUnit::getGroupDefinitions() const
{
	return m_pUnitInfo->getGroupDefinitions();
}

int CvUnit::getUnitGroupRequired(int i) const
{
	return m_pUnitInfo->getUnitGroupRequired(i);
}

bool CvUnit::isRenderAlways() const
{
	return m_pUnitInfo->isRenderAlways();
}

float CvUnit::getAnimationMaxSpeed() const
{
	return m_pUnitInfo->getUnitMaxSpeed();
}

float CvUnit::getAnimationPadTime() const
{
	return m_pUnitInfo->getUnitPadTime();
}

const char* CvUnit::getFormationType() const
{
	return m_pUnitInfo->getFormationType();
}

bool CvUnit::isMechUnit() const
{
	return m_pUnitInfo->isMechUnit();
}

bool CvUnit::isRenderBelowWater() const
{
	return m_pUnitInfo->isRenderBelowWater();
}

int CvUnit::getRenderPriority(UnitSubEntityTypes eUnitSubEntity, int iMeshGroupType, int UNIT_MAX_SUB_TYPES) const
{
	if (eUnitSubEntity == UNIT_SUB_ENTITY_SIEGE_TOWER)
	{
		return (getOwner() * (GC.getNumUnitInfos() + 2) * UNIT_MAX_SUB_TYPES) + iMeshGroupType;
	}
	else
	{
		return (getOwner() * (GC.getNumUnitInfos() + 2) * UNIT_MAX_SUB_TYPES) + m_eUnitType * UNIT_MAX_SUB_TYPES + iMeshGroupType;
	}
}

bool CvUnit::isAlwaysHostile(const CvPlot* pPlot) const
{
	if (!m_pUnitInfo->isAlwaysHostile() && getHiddenNationalityCount() < 1)
	{
		return false;
	}

	if (pPlot != NULL && pPlot->isCity(true, getTeam()))
	{
		if (isBlendIntoCity())
		{
			return isAssassin() && pPlot == plot();
		}

		return (!(pPlot->getOwner() == getOwner() || (isBarbCoExist() && pPlot->isHominid())));//TBBARBCOEXIST
	}

	return true;
}

bool CvUnit::verifyStackValid()
{
	const CvPlot* pPlot = plot();
	if (canCoexistAlwaysOnPlot(*pPlot))
	{
		return true;
	}
	foreach_ (const CvUnit* unit, pPlot->units())
	{
		if (unit != this && isEnemy(unit->getTeam(), NULL, unit)
		&& !isInvisible(unit->getTeam())
		&& !canCoexistWithTeam(unit->getTeam())
		&& !unit->canCoexistWithTeamOnPlot(getTeam(), *pPlot))
		{
			return jumpToNearestValidPlot();
		}
	}
	return true;
}


//check if quick combat
bool CvUnit::isCombatVisible(const CvUnit* pDefender) const
{
	if (!m_pUnitInfo->isQuickCombat() && (NULL == pDefender || !pDefender->getUnitInfo().isQuickCombat()))
	{
		if (isHuman())
		{
			if (!GET_PLAYER(getOwner()).isOption(PLAYEROPTION_QUICK_ATTACK))
			{
				return true;
			}
		}
		else if (NULL != pDefender && pDefender->isHuman() && !GET_PLAYER(pDefender->getOwner()).isOption(PLAYEROPTION_QUICK_DEFENSE))
		{
			return true;
		}
	}
	return false;
}

// used by the executable for the red glow and plot indicators
bool CvUnit::shouldShowEnemyGlow(TeamTypes eForTeam) const
{
	if (isDelayedDeath() || getDomainType() == DOMAIN_AIR || !canFight())
	{
		return false;
	}

	const CvPlot* pPlot = plot();
	if (pPlot == NULL)
	{
		return false;
	}

	const TeamTypes ePlotTeam = pPlot->getTeam();
	if (ePlotTeam != eForTeam || !isEnemy(ePlotTeam))
	{
		return false;
	}

	return true;
}

bool CvUnit::shouldShowFoundBorders() const
{
	return isFound();
}


void CvUnit::cheat(bool bCtrl, bool bAlt, bool bShift)
{
	if (gDLL->getChtLvl() > 0 && bCtrl)
	{
		setPromotionReady(true);
	}
}

float CvUnit::getHealthBarModifier() const
{
	if (GC.getGame().isOption(GAMEOPTION_SIZE_MATTERS))
	{
		const int iWidthDivisor = (1 + (int)GET_PLAYER(getOwner()).getCurrentEra()) * 4;
		return ((GC.getDefineFLOAT("HEALTH_BAR_WIDTH") / iWidthDivisor) / (GC.getGame().getBestLandUnitCombat() * 2));
	}
	return (GC.getDefineFLOAT("HEALTH_BAR_WIDTH") / (GC.getGame().getBestLandUnitCombat() * 2));
}

void CvUnit::getLayerAnimationPaths(std::vector<AnimationPathTypes>& aAnimationPaths) const
{
	for (int i = 0; i < GC.getNumPromotionInfos(); ++i)
	{
		if (isHasPromotion((PromotionTypes)i))
		{
			const AnimationPathTypes eAnimationPath = (AnimationPathTypes)GC.getPromotionInfo((PromotionTypes)i).getLayerAnimationPath();
			if (eAnimationPath != ANIMATIONPATH_NONE)
			{
				aAnimationPaths.push_back(eAnimationPath);
			}
		}
	}
}

int CvUnit::getSelectionSoundScript() const
{
	int iScriptId = getArtInfo(0, GET_PLAYER(getOwner()).getCurrentEra())->getSelectionSoundScriptId();
	if (iScriptId == -1)
	{
		iScriptId = GC.getCivilizationInfo(getCivilizationType()).getSelectionSoundScriptId();
	}
	return iScriptId;
}


// Dale - AB: Bombing
bool CvUnit::canAirBomb1() const
{
	if (!GC.isDCM_AIR_BOMBING())
	{
		return false;
	}
	if (!m_pUnitInfo->getDCMAirBomb1())
	{
		return false;
	}
	if (getDomainType() != DOMAIN_AIR)
	{
		return false;
	}

	if (getAirBombBaseRate() == 0)
	{
		return false;
	}

	if (isMadeAttack())
	{
		return false;
	}

	return true;
}


bool CvUnit::canAirBomb1At(const CvPlot* pPlot, int iX, int iY) const
{
	if (!canAirBomb1())
	{
		return false;
	}

	const CvPlot* pTargetPlot = GC.getMap().plot(iX, iY);
	if (plotDistance(pPlot->getX(), pPlot->getY(), pTargetPlot->getX(), pTargetPlot->getY()) > airRange()
	|| pTargetPlot->isOwned() && !atWar(pTargetPlot->getTeam(), getTeam()))
	{
		return false;
	}

	const CvCity* pCity = pTargetPlot->getPlotCity();
	if (pCity != NULL && pCity->isBombardable(this))
	{
		return true;
	}
	if (pTargetPlot->isImprovementDestructible())
	{
		return true;
	}
	return false;
}


bool CvUnit::airBomb1(int iX, int iY)
{
	if (!canAirBomb1At(plot(), iX, iY))
	{
		return false;
	}

	CvPlot* pPlot = GC.getMap().plot(iX, iY);

	if (interceptTest(pPlot))
	{
		return true;
	}
	CvWString szBuffer;

	CvCity* pCity = pPlot->getPlotCity();
	if (pCity != NULL)
	{
		pCity->changeDefenseDamage(getAirBombCurrRate());

		changeExperience(GC.getDefineINT("MIN_EXPERIENCE_PER_COMBAT"), maxXPValue(NULL, pCity->isHominid()), pCity->getOwner() == getOwner());


		szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_DEFENSES_REDUCED_TO", pCity->getNameKey(), pCity->getDefenseModifier(false), getNameKey());
		AddDLLMessage(pCity->getOwner(), false, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_BOMBARDED", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_RED(), pCity->getX(), pCity->getY(), true, true);

		szBuffer = gDLL->getText("TXT_KEY_MISC_ENEMY_DEFENSES_REDUCED_TO", getNameKey(), pCity->getNameKey(), pCity->getDefenseModifier(false));
		AddDLLMessage(getOwner(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_BOMBARD", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_GREEN(), pCity->getX(), pCity->getY());
	}
	else
	{
		if (pPlot->getImprovementType() != NO_IMPROVEMENT)
		{
			if (GC.getGame().getSorenRandNum(getAirBombCurrRate(), "Air Bomb - Offense") >=
					GC.getGame().getSorenRandNum(GC.getImprovementInfo(pPlot->getImprovementType()).getAirBombDefense(), "Air Bomb - Defense"))
			{
				{

					szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_UNIT_DESTROYED_IMP", getNameKey(), GC.getImprovementInfo(pPlot->getImprovementType()).getTextKeyWide());
					AddDLLMessage(getOwner(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_PILLAGE", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_GREEN(), pPlot->getX(), pPlot->getY());
				}

				if (pPlot->isOwned())
				{
					{

						szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_IMP_WAS_DESTROYED", GC.getImprovementInfo(pPlot->getImprovementType()).getTextKeyWide(), getNameKey(), GET_PLAYER(getOwner()).getCivilizationAdjectiveKey());
						AddDLLMessage(pPlot->getOwner(), false, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_PILLAGED", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_RED(), pPlot->getX(), pPlot->getY(), true, true);
					}
					changeExperience(GC.getDefineINT("MIN_EXPERIENCE_PER_COMBAT"), maxXPValue(NULL, pPlot->isHominid()), true, pPlot->getOwner() == getOwner());
				}

				pPlot->setImprovementType(GC.getImprovementInfo(pPlot->getImprovementType()).getImprovementPillage());

#ifdef OUTBREAKS_AND_AFFLICTIONS
				//Afflict
				int iDistanceAttackCommunicability = 0;
				bool bAffliction = false;
				if (GC.getGame().isOption(GAMEOPTION_OUTBREAKS_AND_AFFLICTIONS))
				{
					for (int iI = 0; iI < GC.getNumPromotionLineInfos(); iI++)
					{
						if (GC.getPromotionLineInfo((PromotionLineTypes)iI).isAffliction() && !GC.getPromotionLineInfo((PromotionLineTypes)iI).isCritical())
						{
							//Distance Communicability
							iDistanceAttackCommunicability = getDistanceAttackCommunicability((PromotionLineTypes)iI);
							bool bDistAttComm = iDistanceAttackCommunicability > 0;
							PromotionLineTypes eAfflictionLine = ((PromotionLineTypes)iI);
							bool bAffonAtt = (hasAfflictOnAttackType(eAfflictionLine) && isAfflictOnAttackTypeDistance(eAfflictionLine));
							if (bDistAttComm || bAffonAtt)
							{
								bAffliction = true;
								foreach_(CvUnit* pLoopUnit, pPlot->units())
								{
									if (bDistAttComm && pLoopUnit->checkContractDisease(eAfflictionLine, iDistanceAttackCommunicability))
									{
										pLoopUnit->afflict(eAfflictionLine);
									}
									if (bAffonAtt)
									{
										int iAttackersPoisonChance = getAfflictOnAttackTypeProbability(eAfflictionLine) - pLoopUnit->fortitudeTotal() - pLoopUnit->getUnitAfflictionTolerance(eAfflictionLine);

										if (GC.getGame().getSorenRandNum(100, "AttackersPoisonRoll") < iAttackersPoisonChance)
										{
											pLoopUnit->afflict(eAfflictionLine, true, this);
										}
									}
								}
							}
						}
					}
				}
#endif // OUTBREAKS_AND_AFFLICTIONS
			}
			else
			{

				szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_UNIT_FAIL_DESTROY_IMP", getNameKey(), GC.getImprovementInfo(pPlot->getImprovementType()).getTextKeyWide());
				AddDLLMessage(getOwner(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_BOMB_FAILS", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_RED(), pPlot->getX(), pPlot->getY());
			}
		}
	}

	setReconPlot(pPlot);

	setMadeAttack(true);
	changeMoves(GC.getMOVE_DENOMINATOR());

	addMission(CvAirMissionDefinition(MISSION_AIRBOMB, pPlot, this));

	if (isSuicide())
	{
		kill(true);
	}
	return true;
}

bool CvUnit::canAirBomb2() const
{
	if (!GC.isDCM_AIR_BOMBING())
	{
		return false;
	}
	if (!m_pUnitInfo->getDCMAirBomb2())
	{
		return false;
	}
	if (getDomainType() != DOMAIN_AIR)
	{
		return false;
	}
	if (getAirBombBaseRate() == 0)
	{
		return false;
	}
	if (isMadeAttack())
	{
		return false;
	}
	return true;
}


bool CvUnit::canAirBomb2At(const CvPlot* pPlot, int iX, int iY) const
{
	if (!canAirBomb2())
	{
		return false;
	}
	const CvPlot* pTargetPlot = GC.getMap().plot(iX, iY);
	if (plotDistance(pPlot->getX(), pPlot->getY(), pTargetPlot->getX(), pTargetPlot->getY()) > airRange())
	{
		return false;
	}
	if (pTargetPlot->isOwned() && !atWar(pTargetPlot->getTeam(), getTeam()))
	{
		return false;
	}
	return pTargetPlot->getPlotCity() != NULL;
}


bool CvUnit::airBomb2(int iX, int iY)
{
	CvCity* pCity;
	CvPlot* pPlot;
	CvWString szBuffer;
	int build, iI, iAttempts, iMaxAttempts;
	bool bNoTarget = true;
	bool abTech1 = false;
	bool abTech2 = false;
	CLinkList<int> buildingList;

	if (!canAirBomb2At(plot(), iX, iY))
	{
		return false;
	}
	pPlot = GC.getMap().plot(iX, iY);
	if (interceptTest(pPlot))
	{
		return true;
	}

	pCity = pPlot->getPlotCity();

	for (iI = 0; iI < GC.getNumTechInfos(); iI++)
	{
		if (GC.getTechInfo((TechTypes)iI).getDCMAirBombTech1())
		{
            if (GET_TEAM(GET_PLAYER(getOwner()).getTeam()).isHasTech((TechTypes)iI))
			{
				abTech1 = true;
			}
		}
		if (GC.getTechInfo((TechTypes)iI).getDCMAirBombTech2())
		{
            if (GET_TEAM(GET_PLAYER(getOwner()).getTeam()).isHasTech((TechTypes)iI))
			{
				abTech2 = true;
			}
		}
	}
	if (pCity != NULL)
	{
		buildingList.clear();
		for (iI = 0; iI < GC.getNumBuildingInfos(); iI++)
		{
			if (GC.getBuildingInfo((BuildingTypes)iI).getDCMAirbombMission() == 2)
			{
				buildingList.insertAtEnd(iI);
			}
		}
		if (buildingList.getLength() > 0)
		{
			iI = GC.getGame().getSorenRandNum(buildingList.getLength(), "Airbomb building");
			build = buildingList.nodeNum(iI)->m_data;
			if (pCity->getNumActiveBuilding((BuildingTypes)build) > 0)
			{
				bNoTarget = false;
			}
			if (abTech1)
			{
				iAttempts = 0;
				if (abTech2)
				{
					iMaxAttempts = 8;
				}
				else
				{
					iMaxAttempts = 4;
				}
				while (bNoTarget)
				{
					iAttempts++;
					iI = GC.getGame().getSorenRandNum(buildingList.getLength(), "Airbomb building");
					build = buildingList.nodeNum(iI)->m_data;
					if (pCity->getNumActiveBuilding((BuildingTypes)build) > 0 || iAttempts > iMaxAttempts)
					{
						bNoTarget = false;
					}
				}
			}
			if (pCity->getNumActiveBuilding((BuildingTypes)build) > 0)
			{
				bNoTarget = false;
				changeExperience(GC.getDefineINT("MIN_EXPERIENCE_PER_COMBAT"), maxXPValue(NULL, pCity->isHominid()), true, pCity->getOwner() == getOwner());

				pCity->setNumRealBuilding((BuildingTypes)build, 0);
				{

					szBuffer = gDLL->getText("TXT_KEY_MISC_ENEMY_AIRBOMB2SUCCESS", GC.getBuildingInfo((BuildingTypes)build).getTextKeyWide(), pCity->getNameKey());
					AddDLLMessage(pCity->getOwner(), false, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_BOMBARDED", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_RED(), pCity->getX(), pCity->getY(), true, true);
					szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_AIRBOMB2SUCCESS", GC.getBuildingInfo((BuildingTypes)build).getTextKeyWide(), pCity->getNameKey());
					AddDLLMessage(getOwner(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_BOMBARD", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_GREEN(), pCity->getX(), pCity->getY(), true, true);
				}

#ifdef OUTBREAKS_AND_AFFLICTIONS
				//Afflict
				int iDistanceAttackCommunicability = 0;
				bool bAffliction = false;
				if (GC.getGame().isOption(GAMEOPTION_OUTBREAKS_AND_AFFLICTIONS))
				{
					for (int iI = 0; iI < GC.getNumPromotionLineInfos(); iI++)
					{
						if (GC.getPromotionLineInfo((PromotionLineTypes)iI).isAffliction() && !GC.getPromotionLineInfo((PromotionLineTypes)iI).isCritical())
						{
							//Distance Communicability
							iDistanceAttackCommunicability = getDistanceAttackCommunicability((PromotionLineTypes)iI);
							bool bDistAttComm = iDistanceAttackCommunicability > 0;
							PromotionLineTypes eAfflictionLine = ((PromotionLineTypes)iI);
							bool bAffonAtt = (hasAfflictOnAttackType(eAfflictionLine) && isAfflictOnAttackTypeDistance(eAfflictionLine));
							if (bDistAttComm || bAffonAtt)
							{
								bAffliction = true;
								foreach_(CvUnit* pLoopUnit, pPlot->units())
								{
									if (bDistAttComm)
									{
										if (pLoopUnit->checkContractDisease(eAfflictionLine, iDistanceAttackCommunicability))
										{
											pLoopUnit->afflict(eAfflictionLine);
										}
										if (pCity != NULL)
										{
											pCity->changePromotionLineAfflictionAttackCommunicability(eAfflictionLine, iDistanceAttackCommunicability);
										}
									}
									if (bAffonAtt)
									{
										int iAttackersPoisonChance = getAfflictOnAttackTypeProbability(eAfflictionLine) - pLoopUnit->fortitudeTotal() - pLoopUnit->getUnitAfflictionTolerance(eAfflictionLine);

										if (GC.getGame().getSorenRandNum(100, "AttackersPoisonRoll") < iAttackersPoisonChance)
										{
											pLoopUnit->afflict(eAfflictionLine, true, this);
										}
									}
								}
							}
						}
					}
				}
#endif // OUTBREAKS_AND_AFFLICTIONS
			}
			else
			{

				szBuffer = gDLL->getText("TXT_KEY_MISC_ENEMY_AIRBOMB2FAIL", pCity->getNameKey());
				AddDLLMessage(pCity->getOwner(), false, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_BOMBARDED", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_RED(), pCity->getX(), pCity->getY(), true, true);
				szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_AIRBOMB2FAIL", pCity->getNameKey());
				AddDLLMessage(getOwner(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_BOMBARD", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_GREEN(), pCity->getX(), pCity->getY(), true, true);
			}
		}
		if(bNoTarget)
		{
			if(pCity->getPopulation() > 1)
			{
				if(GC.getGame().getSorenRandNum(5, "Airbomb population") < 2)
				{
					pCity->changePopulation(-1);

					{

						szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_AIRBOMB_POP");
						AddDLLMessage(getOwner(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_BOMBARD", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_GREEN(), pCity->getX(), pCity->getY(), true, true);
						szBuffer = gDLL->getText("TXT_KEY_MISC_ENEMY_AIRBOMB_POP");
						AddDLLMessage(pCity->getOwner(), false, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_BOMBARDED", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_RED(), pCity->getX(), pCity->getY(), true, true);
					}
				}
			}
		}
	}
	setReconPlot(pPlot);
	setMadeAttack(true);
	changeMoves(GC.getMOVE_DENOMINATOR());

	addMission(CvAirMissionDefinition(MISSION_AIRBOMB, pPlot, this));

	if (isSuicide())
	{
		kill(true);
	}
	return true;
}

bool CvUnit::canAirBomb3() const
{
	if (!GC.isDCM_AIR_BOMBING())
	{
		return false;
	}
	if (!m_pUnitInfo->getDCMAirBomb3())
	{
		return false;
	}
	if (getDomainType() != DOMAIN_AIR)
	{
		return false;
	}
	if (getAirBombBaseRate() == 0)
	{
		return false;
	}
	if (isMadeAttack())
	{
		return false;
	}
	return true;
}


bool CvUnit::canAirBomb3At(const CvPlot* pPlot, int iX, int iY) const
{
	if (!canAirBomb3())
	{
		return false;
	}
	const CvPlot* pTargetPlot = GC.getMap().plot(iX, iY);
	if (plotDistance(pPlot->getX(), pPlot->getY(), pTargetPlot->getX(), pTargetPlot->getY()) > airRange())
	{
		return false;
	}
	if (pTargetPlot->isOwned())
	{
		if (!atWar(pTargetPlot->getTeam(), getTeam()))
		{
			return false;
		}
	}
	const CvCity* pCity = pTargetPlot->getPlotCity();
	if (pCity == NULL)
	{
		return false;
	}
	return true;
}


bool CvUnit::airBomb3(int iX, int iY)
{
	CvCity* pCity;
	CvPlot* pPlot;
	CvWString szBuffer;
	int build, iI, iAttempts, iMaxAttempts;
	bool bNoTarget = true;
	bool abTech1 = false;
	bool abTech2 = false;
	CLinkList<int> buildingList;
	bool bSuccess = false;

	if (!canAirBomb3At(plot(), iX, iY))
	{
		return false;
	}
	pPlot = GC.getMap().plot(iX, iY);
	if (interceptTest(pPlot))
	{
		return true;
	}

	pCity = pPlot->getPlotCity();

	for (iI = 0; iI < GC.getNumTechInfos(); iI++)
	{
		if (GC.getTechInfo((TechTypes)iI).getDCMAirBombTech1())
		{
            if (GET_TEAM(GET_PLAYER(getOwner()).getTeam()).isHasTech((TechTypes)iI))
			{
				abTech1 = true;
			}
		}
		if (GC.getTechInfo((TechTypes)iI).getDCMAirBombTech2())
		{
            if (GET_TEAM(GET_PLAYER(getOwner()).getTeam()).isHasTech((TechTypes)iI))
			{
				abTech2 = true;
			}
		}
	}
	if (pCity != NULL)
	{
		buildingList.clear();
		for (iI = 0; iI < GC.getNumBuildingInfos(); iI++)
		{
			if (GC.getBuildingInfo((BuildingTypes)iI).getDCMAirbombMission() == 3)
			{
				buildingList.insertAtEnd(iI);
			}
		}
		if (buildingList.getLength() > 0)
		{
			iI = GC.getGame().getSorenRandNum(buildingList.getLength(), "Airbomb building");
			build = buildingList.nodeNum(iI)->m_data;
			if (pCity->getNumActiveBuilding((BuildingTypes)build) > 0)
			{
				bNoTarget = false;
			}
			if (abTech1)
			{
				iAttempts = 0;
				if (abTech2)
				{
					iMaxAttempts = 8;
				}
				else
				{
					iMaxAttempts = 4;
				}
				while (bNoTarget)
				{
					iAttempts++;
					iI = GC.getGame().getSorenRandNum(buildingList.getLength(), "Airbomb building");
					build = buildingList.nodeNum(iI)->m_data;
					if (pCity->getNumActiveBuilding((BuildingTypes)build) > 0 || iAttempts > iMaxAttempts)
					{
						bNoTarget = false;
					}
				}
			}
			if (pCity->getNumActiveBuilding((BuildingTypes)build) > 0)
			{
				pCity->setNumRealBuilding((BuildingTypes)build, 0);

				changeExperience(GC.getDefineINT("MIN_EXPERIENCE_PER_COMBAT"), maxXPValue(NULL, pCity->isHominid()), true, pCity->getOwner() == getOwner());
				{

					szBuffer = gDLL->getText("TXT_KEY_MISC_ENEMY_AIRBOMB3SUCCESS", GC.getBuildingInfo((BuildingTypes)build).getTextKeyWide(), pCity->getNameKey());
					AddDLLMessage(pCity->getOwner(), false, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_BOMBARDED", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_RED(), pCity->getX(), pCity->getY(), true, true);
					szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_AIRBOMB3SUCCESS", GC.getBuildingInfo((BuildingTypes)build).getTextKeyWide(), pCity->getNameKey());
					AddDLLMessage(getOwner(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_BOMBARD", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_GREEN(), pCity->getX(), pCity->getY(), true, true);
				}
				bSuccess = true;
			}
			else
			{

				szBuffer = gDLL->getText("TXT_KEY_MISC_ENEMY_AIRBOMB3FAIL", pCity->getNameKey());
				AddDLLMessage(pCity->getOwner(), false, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_BOMBARDED", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_RED(), pCity->getX(), pCity->getY(), true, true);
				szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_AIRBOMB3FAIL", pCity->getNameKey());
				AddDLLMessage(getOwner(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_BOMBARD", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_GREEN(), pCity->getX(), pCity->getY(), true, true);
			}
		}
		if(bNoTarget)
		{
			if(pCity->getPopulation() > 1)
			{
				if(GC.getGame().getSorenRandNum(5, "Airbomb population") < 1)
				{
					pCity->changePopulation(-1);

					{

						szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_AIRBOMB_POP");
						AddDLLMessage(getOwner(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_BOMBARD", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_GREEN(), pCity->getX(), pCity->getY(), true, true);
						szBuffer = gDLL->getText("TXT_KEY_MISC_ENEMY_AIRBOMB_POP");
						AddDLLMessage(pCity->getOwner(), false, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_BOMBARDED", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_RED(), pCity->getX(), pCity->getY(), true, true);
					}
					bSuccess = true;
				}
			}
		}
	}
	setReconPlot(pPlot);
	setMadeAttack(true);
	changeMoves(GC.getMOVE_DENOMINATOR());
#ifdef OUTBREAKS_AND_AFFLICTIONS
	if (bSuccess)
	{
		//Afflict
		int iDistanceAttackCommunicability = 0;
		bool bAffliction = false;
		if (GC.getGame().isOption(GAMEOPTION_OUTBREAKS_AND_AFFLICTIONS))
		{
			for (int iI = 0; iI < GC.getNumPromotionLineInfos(); iI++)
			{
				if (GC.getPromotionLineInfo((PromotionLineTypes)iI).isAffliction() && !GC.getPromotionLineInfo((PromotionLineTypes)iI).isCritical())
				{
					//Distance Communicability
					iDistanceAttackCommunicability = getDistanceAttackCommunicability((PromotionLineTypes)iI);
					bool bDistAttComm = iDistanceAttackCommunicability > 0;
					PromotionLineTypes eAfflictionLine = ((PromotionLineTypes)iI);
					bool bAffonAtt = (hasAfflictOnAttackType(eAfflictionLine) && isAfflictOnAttackTypeDistance(eAfflictionLine));
					if (bDistAttComm || bAffonAtt)
					{
						bAffliction = true;
						foreach_(CvUnit* pLoopUnit, pPlot->units())
						{
							if (bDistAttComm)
							{
								if (pLoopUnit->checkContractDisease(eAfflictionLine, iDistanceAttackCommunicability))
								{
									pLoopUnit->afflict(eAfflictionLine);
								}
								if (pCity != NULL)
								{
									pCity->changePromotionLineAfflictionAttackCommunicability(eAfflictionLine, iDistanceAttackCommunicability);
								}
							}
							if (bAffonAtt)
							{
								int iAttackersPoisonChance = getAfflictOnAttackTypeProbability(eAfflictionLine) - pLoopUnit->fortitudeTotal() - pLoopUnit->getUnitAfflictionTolerance(eAfflictionLine);

								if (GC.getGame().getSorenRandNum(100, "AttackersPoisonRoll") < iAttackersPoisonChance)
								{
									pLoopUnit->afflict(eAfflictionLine, true, this);
								}
							}
						}
					}
				}
			}
		}
	}
#endif // OUTBREAKS_AND_AFFLICTIONS
	addMission(CvAirMissionDefinition(MISSION_AIRBOMB, pPlot, this));

	if (isSuicide())
	{
		kill(true);
	}
	return true;
}

bool CvUnit::canAirBomb4() const
{
	if (!GC.isDCM_AIR_BOMBING())
	{
		return false;
	}
	if (!m_pUnitInfo->getDCMAirBomb4())
	{
		return false;
	}
	if (getDomainType() != DOMAIN_AIR)
	{
		return false;
	}
	if (getAirBombBaseRate() == 0)
	{
		return false;
	}
	if (isMadeAttack())
	{
		return false;
	}
	return true;
}


bool CvUnit::canAirBomb4At(const CvPlot* pPlot, int iX, int iY) const
{
	if (!canAirBomb4())
	{
		return false;
	}
	const CvPlot* pTargetPlot = GC.getMap().plot(iX, iY);
	if (plotDistance(pPlot->getX(), pPlot->getY(), pTargetPlot->getX(), pTargetPlot->getY()) > airRange())
	{
		return false;
	}
	if (pTargetPlot->isOwned())
	{
		if (!atWar(pTargetPlot->getTeam(), getTeam()))
		{
			return false;
		}
	}
	const CvCity* pCity = pTargetPlot->getPlotCity();
	if (pCity != NULL)
	{
		for (int iI = 0; iI < MAX_PLAYERS; ++iI)
		{
			if (atWar(GET_PLAYER((PlayerTypes)iI).getTeam(), getTeam()))
			{
				if (algo::any_of(GET_PLAYER((PlayerTypes)iI).units(),
					CvUnit::fn::plot() == pTargetPlot && CvUnit::fn::getDomainType() == DOMAIN_SEA))
				{
					return true;
				}
			}
		}
	}
	if (pTargetPlot->getImprovementType() != NO_IMPROVEMENT)
	{
		if (GC.getImprovementInfo(pTargetPlot->getImprovementType()).isActsAsCity() && pCity == NULL)
		{
			for (int iI = 0; iI < MAX_PLAYERS; ++iI)
			{
				if (atWar(GET_PLAYER((PlayerTypes)iI).getTeam(), getTeam()))
				{
					if (algo::any_of(GET_PLAYER((PlayerTypes)iI).units(),
						CvUnit::fn::plot() == pTargetPlot && CvUnit::fn::getDomainType() == DOMAIN_SEA))
					{
						return true;
					}
				}
			}
		}
	}
	return false;
}


bool CvUnit::airBomb4(int iX, int iY)
{
	CvUnit* pUnit;
	CvWString szBuffer;
	bool bSuccess = false, bNoTarget = true;
	int iDamage, iUnitDamage;

	if (!canAirBomb4At(plot(), iX, iY))
	{
		return false;
	}
	CvPlot* pPlot = GC.getMap().plot(iX, iY);
	if (interceptTest(pPlot))
	{
		return true;
	}

	CvCity* pCity = pPlot->getPlotCity();
	int iCount = algo::count_if(pPlot->units(), CvUnit::fn::getDomainType() == DOMAIN_SEA);
	iCount = (GC.getGame().getSorenRandNum(iCount, "Choose ship") + 1);
	CLLNode<IDInfo>* pUnitNode = pPlot->headUnitNode();
	while (iCount > 0)
	{
		CvUnit* pLoopUnit = ::getUnit(pUnitNode->m_data);
		pUnitNode = pPlot->nextUnitNode(pUnitNode);
		if (pLoopUnit->getDomainType() == DOMAIN_SEA)
		{
			iCount--;
			pUnit = pLoopUnit;
		}
	}

	{
		if (pUnit != NULL)
		{
			bNoTarget = false;
			changeExperience(GC.getDefineINT("MIN_EXPERIENCE_PER_COMBAT"), maxXPValue(pUnit), true, pPlot->getOwner() == getOwner());

			iDamage = (airCombatDamage(pUnit) * 2);
			iUnitDamage = std::max(pUnit->getDamage(), std::min((pUnit->getDamage() + iDamage), airCombatLimit(pUnit)));

			{

				szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_ARE_ATTACKED_BY_AIR", pUnit->getNameKey(), getNameKey(), -(((iUnitDamage - pUnit->getDamage()) * 100) / pUnit->getMaxHP()));
				AddDLLMessage(pUnit->getOwner(), false, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_AIR_ATTACK", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_RED(), pPlot->getX(), pPlot->getY(), true, true);
				szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_ATTACK_BY_AIR", getNameKey(), pUnit->getNameKey(), -(((iUnitDamage - pUnit->getDamage()) * 100) / pUnit->getMaxHP()));
				AddDLLMessage(getOwner(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_AIR_ATTACKED", MESSAGE_TYPE_INFO, pUnit->getButton(), GC.getCOLOR_GREEN(), pPlot->getX(), pPlot->getY(), true, true);
			}
			bSuccess = true;
			pUnit->setDamage(iUnitDamage, getOwner());
			//TB Combat Mod begin
			if (dealsColdDamage())
			{
				pUnit->setColdDamage(iUnitDamage);
			}
			//TB Combat mod end
			if (GC.getGame().getSorenRandNum(100, "Spin the dice") < 50)
			{
				pUnit->setDamage(pUnit->getMaxHP());

				{

					szBuffer = gDLL->getText("TXT_KEY_MISC_ENEMYSINK_AIRBOMB4SUCCESS", pUnit->getNameKey());
					AddDLLMessage(pUnit->getOwner(), false, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_BOMBARDED", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_RED(), pPlot->getX(), pPlot->getY(), true, true);
					szBuffer = gDLL->getText("TXT_KEY_MISC_YOUSINK_AIRBOMB4SUCCESS", pUnit->getNameKey());
					AddDLLMessage(getOwner(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_BOMBARD", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_GREEN(), pPlot->getX(), pPlot->getY(), true, true);
				}
			}
		}
		else
		{

			szBuffer = gDLL->getText("TXT_KEY_MISC_ENEMY_AIRBOMB4FAIL", pCity->getNameKey());
			AddDLLMessage(pCity->getOwner(), false, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_BOMBARDED", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_RED(), pPlot->getX(), pPlot->getY(), true, true);
			szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_AIRBOMB4FAIL", pCity->getNameKey());
			AddDLLMessage(getOwner(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_BOMBARD", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_GREEN(), pPlot->getX(), pPlot->getY(), true, true);
		}
		if(bNoTarget)
		{
			if (pCity != NULL)
			{
				if(pCity->getPopulation() > 1)
				{
					if(GC.getGame().getSorenRandNum(5, "Airbomb population") < 1)
					{
						pCity->changePopulation(-1);
						bSuccess = true;

						{

							szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_AIRBOMB_POP");
							AddDLLMessage(getOwner(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_BOMBARD", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_GREEN(), pPlot->getX(), pPlot->getY(), true, true);
							szBuffer = gDLL->getText("TXT_KEY_MISC_ENEMY_AIRBOMB_POP");
							AddDLLMessage(pCity->getOwner(), false, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_BOMBARDED", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_RED(), pPlot->getX(), pPlot->getY(), true, true);
						}
					}
				}
			}
		}
	}
	setReconPlot(pPlot);
	setMadeAttack(true);
	changeMoves(GC.getMOVE_DENOMINATOR());
#ifdef OUTBREAKS_AND_AFFLICTIONS
	if (bSuccess)
	{
		//Afflict
		int iDistanceAttackCommunicability = 0;
		bool bAffliction = false;
		if (GC.getGame().isOption(GAMEOPTION_OUTBREAKS_AND_AFFLICTIONS))
		{
			for (int iI = 0; iI < GC.getNumPromotionLineInfos(); iI++)
			{
				if (GC.getPromotionLineInfo((PromotionLineTypes)iI).isAffliction() && !GC.getPromotionLineInfo((PromotionLineTypes)iI).isCritical())
				{
					//Distance Communicability
					iDistanceAttackCommunicability = getDistanceAttackCommunicability((PromotionLineTypes)iI);
					bool bDistAttComm = iDistanceAttackCommunicability > 0;
					PromotionLineTypes eAfflictionLine = ((PromotionLineTypes)iI);
					bool bAffonAtt = (hasAfflictOnAttackType(eAfflictionLine) && isAfflictOnAttackTypeDistance(eAfflictionLine));
					if (bDistAttComm || bAffonAtt)
					{
						bAffliction = true;
						foreach_(CvUnit* pLoopUnit, pPlot->units())
						{
							if (bDistAttComm)
							{
								if (pLoopUnit->checkContractDisease(eAfflictionLine, iDistanceAttackCommunicability))
								{
									pLoopUnit->afflict(eAfflictionLine);
								}
								if (pCity != NULL)
								{
									pCity->changePromotionLineAfflictionAttackCommunicability(eAfflictionLine, iDistanceAttackCommunicability);
								}
							}
							if (bAffonAtt)
							{
								int iAttackersPoisonChance = getAfflictOnAttackTypeProbability(eAfflictionLine) - pLoopUnit->fortitudeTotal() - pLoopUnit->getUnitAfflictionTolerance(eAfflictionLine);

								if (GC.getGame().getSorenRandNum(100, "AttackersPoisonRoll") < iAttackersPoisonChance)
								{
									pLoopUnit->afflict(eAfflictionLine, true, this);
								}
							}
						}
					}
				}
			}
		}
	}
#endif // OUTBREAKS_AND_AFFLICTIONS
	addMission(CvAirMissionDefinition(MISSION_AIRBOMB, pPlot, this));

	if (isSuicide())
	{
		kill(true);
	}
	return true;
}

bool CvUnit::canAirBomb5() const
{
	if (!GC.isDCM_AIR_BOMBING())
	{
		return false;
	}
	if (!m_pUnitInfo->getDCMAirBomb5())
	{
		return false;
	}
	if (getDomainType() != DOMAIN_AIR)
	{
		return false;
	}
	if (getAirBombBaseRate() == 0)
	{
		return false;
	}
	if (isMadeAttack())
	{
		return false;
	}
	return true;
}


bool CvUnit::canAirBomb5At(const CvPlot* pPlot, int iX, int iY) const
{
	if (!canAirBomb5())
	{
		return false;
	}
	const CvPlot* pTargetPlot = GC.getMap().plot(iX, iY);
	if (plotDistance(pPlot->getX(), pPlot->getY(), pTargetPlot->getX(), pTargetPlot->getY()) > airRange())
	{
		return false;
	}
	if (pTargetPlot->isOwned())
	{
		if (!atWar(pTargetPlot->getTeam(), getTeam()))
		{
			return false;
		}
	}
	const CvCity* pCity = pTargetPlot->getPlotCity();
	if (pCity == NULL)
	{
		return false;
	}
	return true;
}


bool CvUnit::airBomb5(int iX, int iY)
{
	CvCity* pCity;
	CvPlot* pPlot;
	CvWString szBuffer;
	bool bNoTarget = true;
	bool bSuccess = false;

	if (!canAirBomb5At(plot(), iX, iY))
	{
		return false;
	}
	pPlot = GC.getMap().plot(iX, iY);
	if (interceptTest(pPlot))
	{
		return true;
	}

	pCity = pPlot->getPlotCity();

	if (pCity != NULL)
	{
		if (GC.getGame().getSorenRandNum(100, "Airbomb") < 50)
		{
			bNoTarget = false;
			pCity->setProduction(pCity->getProduction() / 2);
			bSuccess = true;
			{

				szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_AIRBOMB5SUCCESS", pCity->getNameKey());
				AddDLLMessage(getOwner(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_BOMBARD", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_GREEN(), pCity->getX(), pCity->getY(), true, true);
				szBuffer = gDLL->getText("TXT_KEY_MISC_ENEMY_AIRBOMB5SUCCESS", pCity->getNameKey());
				AddDLLMessage(pCity->getOwner(), false, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_BOMBARDED", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_RED(), pCity->getX(), pCity->getY(), true, true);
			}
			changeExperience(GC.getDefineINT("MIN_EXPERIENCE_PER_COMBAT"), maxXPValue(NULL, pCity->isHominid()), true, pCity->getOwner() == getOwner());
		}
		else
		{

			szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_AIRBOMB5FAIL", pCity->getNameKey());
			AddDLLMessage(getOwner(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_BOMBARD", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_GREEN(), pCity->getX(), pCity->getY(), true, true);
			szBuffer = gDLL->getText("TXT_KEY_MISC_ENEMY_AIRBOMB5FAIL", pCity->getNameKey());
			AddDLLMessage(pCity->getOwner(), false, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_BOMBARDED", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_RED(), pCity->getX(), pCity->getY(), true, true);
		}
		if(bNoTarget)
		{
			if(pCity->getPopulation() > 1)
			{
				if(GC.getGame().getSorenRandNum(5, "Airbomb population") < 1)
				{
					pCity->changePopulation(-1);
					bSuccess = true;

					{

						szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_AIRBOMB_POP");
						AddDLLMessage(getOwner(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_BOMBARD", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_GREEN(), pCity->getX(), pCity->getY(), true, true);
						szBuffer = gDLL->getText("TXT_KEY_MISC_ENEMY_AIRBOMB_POP");
						AddDLLMessage(pCity->getOwner(), false, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_BOMBARDED", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_RED(), pCity->getX(), pCity->getY(), true, true);
					}
				}
			}
		}
	}
	setReconPlot(pPlot);
	setMadeAttack(true);
	changeMoves(GC.getMOVE_DENOMINATOR());
#ifdef OUTBREAKS_AND_AFFLICTIONS
	if (bSuccess)
	{
		//Afflict
		int iDistanceAttackCommunicability = 0;
		bool bAffliction = false;
		if (GC.getGame().isOption(GAMEOPTION_OUTBREAKS_AND_AFFLICTIONS))
		{
			for (int iI = 0; iI < GC.getNumPromotionLineInfos(); iI++)
			{
				if (GC.getPromotionLineInfo((PromotionLineTypes)iI).isAffliction() && !GC.getPromotionLineInfo((PromotionLineTypes)iI).isCritical())
				{
					//Distance Communicability
					iDistanceAttackCommunicability = getDistanceAttackCommunicability((PromotionLineTypes)iI);
					bool bDistAttComm = iDistanceAttackCommunicability > 0;
					PromotionLineTypes eAfflictionLine = ((PromotionLineTypes)iI);
					bool bAffonAtt = (hasAfflictOnAttackType(eAfflictionLine) && isAfflictOnAttackTypeDistance(eAfflictionLine));
					if (bDistAttComm || bAffonAtt)
					{
						bAffliction = true;
						foreach_(CvUnit* pLoopUnit, pPlot->units())
						{
							if (bDistAttComm)
							{
								if (pLoopUnit->checkContractDisease(eAfflictionLine, iDistanceAttackCommunicability))
								{
									pLoopUnit->afflict(eAfflictionLine);
								}
								if (pCity != NULL)
								{
									pCity->changePromotionLineAfflictionAttackCommunicability(eAfflictionLine, iDistanceAttackCommunicability);
								}
							}
							if (bAffonAtt)
							{
								int iAttackersPoisonChance = getAfflictOnAttackTypeProbability(eAfflictionLine) - pLoopUnit->fortitudeTotal() - pLoopUnit->getUnitAfflictionTolerance(eAfflictionLine);

								if (GC.getGame().getSorenRandNum(100, "AttackersPoisonRoll") < iAttackersPoisonChance)
								{
									pLoopUnit->afflict(eAfflictionLine, true, this);
								}
							}
						}
					}
				}
			}
		}
	}
#endif // OUTBREAKS_AND_AFFLICTIONS
	addMission(CvAirMissionDefinition(MISSION_AIRBOMB, pPlot, this));

	if (isSuicide())
	{
		kill(true);
	}
	return true;
}
// ! Dale - AB: Bombing

// Dale - RB: Field Bombard
bool CvUnit::canRBombard(bool bEver) const
{
	if (!GC.isDCM_RANGE_BOMBARD())
	{
		return false;
	}

	//No longer evaluates the unit itself so much as its Combat Classes (the weapon ones are the source of the ability)
	if (getBaseDCMBombRange() < 1)
	{
        return false;
	}

	if (isOnlyDefensive() && !hasRBombardForceAbility())
	{
		return false;
	}

	if (getDomainType() == DOMAIN_AIR)
	{
		return false;
	}

	if (isMadeAttack() && !bEver)
	{
		return false;
	}

	if (isCargo() && !bEver)
	{
		return false;
	}

	return true;
}

bool CvUnit::canBombardAtRanged(const CvPlot* pPlot, int iX, int iY) const
{
	if (!canRBombard() || iX < 0 || iY < 0)
	{
		return false;
	}
	CvPlot* pTargetPlot = GC.getMap().plot(iX, iY);

	if (plotDistance(pPlot->getX(), pPlot->getY(), pTargetPlot->getX(), pTargetPlot->getY()) > getDCMBombRange())
	{
		return false;
	}
	const bool bNotMyTerritory = pTargetPlot->getTeam() != getTeam();

	if (pTargetPlot->isOwned() && bNotMyTerritory && !atWar(pTargetPlot->getTeam(), getTeam()))
	{
		return false;
	}

	if (pTargetPlot->getNumVisiblePotentialEnemyDefenders(this) > 0)
	{
		return true;
	}
	if (bNotMyTerritory)
	{
		if (pTargetPlot->isImprovementDestructible())
		{
			return true;
		}
		CvCity* pCity = pTargetPlot->getPlotCity();

		if (pCity != NULL && pCity->isBombardable(this))
		{
			return true;
		}
	}
	return false;
}

// RevolutionDCM - significant chances to this function
bool CvUnit::bombardRanged(int iX, int iY, bool sAttack)
{
	if (!canBombardAtRanged(plot(), iX, iY))
	{
		return false;
	}
	CvPlot* pPlot = GC.getMap().plot(iX, iY);

	if (pPlot == NULL)
	{
		return false;
	}
	CvWString szBuffer;

	CvUnit* pLoopUnit = NULL;
	CvCity* pCity = pPlot->getPlotCity();

	if (pCity != NULL)
	{
		pLoopUnit = pPlot->getBestDefender(NO_PLAYER, getOwner(), this, true);
		if (pLoopUnit != NULL)
		{
			//TB Combat Mod adjustment
			//We have Bombard Defense Values in the city and it would be best if it came into play rather than a static modifier
			//Also... why would we want a city that still has better stronger defenses to be MORE vulnerable to bombard attack??? Eugh...
			const int iBombardDefense =
			(
				pCity->getBuildingBombardDefense()
				*
				pCity->getDefenseModifier(false) / std::max(1, pCity->getTotalDefense(false))
			);
			// standard odds made worse if greater than one tile out
			const int odds = 100 + iBombardDefense + (plotDistance(getX(), getY(), pPlot->getX(), pPlot->getY()) - 1) * 30;

			// RevolutionDCM - change proposal to ranged bombardment. Only collateral damage can be issued.
			if (GC.getGame().getSorenRandNum(odds, "Bombard Accuracy") <= getDCMBombAccuracy())
			{
				{

					szBuffer = gDLL->getText("TXT_KEY_HAS_RANGED_BOMBARD_ATTACKED", getNameKey());
					AddDLLMessage(getOwner(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_BOMBARDED", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_GREEN(), getX(), getY());
					szBuffer = gDLL->getText("TXT_KEY_HAS_BEEN_RANGED_BOMBARD_ATTACKED", getNameKey());
					AddDLLMessage(pLoopUnit->getOwner(), false, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_BOMBARDED", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_RED(), getX(), getY(), true, true);
				}
				rBombardCombat(pPlot, pLoopUnit);
				changeExperience100(100, -1, true, pLoopUnit->getOwner() == getOwner());
			}
			else
			{

				szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_BOMB_MISSED", getNameKey());
				AddDLLMessage(getOwner(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_BOMBARDED", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_RED(), getX(), getY());
				szBuffer = gDLL->getText("TXT_KEY_MISC_ENEMY_BOMB_MISSED", getNameKey());
				AddDLLMessage(pLoopUnit->getOwner(), false, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_BOMBARDED", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_GREEN(), getX(), getY(), true, true);
			}
		}
	}
	else
	{
		// Field bombard case.
		pLoopUnit = pPlot->getBestDefender(NO_PLAYER, getOwner(), this, true);
		if (pLoopUnit != NULL)
		{
			// standard odds made worse if greater than one tile out
			const int odds = 100 + 30*(plotDistance(getX(), getY(), pPlot->getX(), pPlot->getY()) - 1);

			//RevolutionDCM - change proposal to ranged bombardment. Only collateral damage can be issued.
			if (GC.getGame().getSorenRandNum(odds, "Bombard Accuracy") <= getDCMBombAccuracy())
			{
				{

					szBuffer = gDLL->getText("TXT_KEY_HAS_RANGED_BOMBARD_ATTACKED", getNameKey());
					AddDLLMessage(getOwner(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_BOMBARDED", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_GREEN(), getX(), getY());
					szBuffer = gDLL->getText("TXT_KEY_HAS_BEEN_RANGED_BOMBARD_ATTACKED", getNameKey());
					AddDLLMessage(pLoopUnit->getOwner(), false, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_BOMBARDED", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_RED(), getX(), getY(), true, true);
				}
				rBombardCombat(pPlot, pLoopUnit);
				changeExperience100(100, -1, true, pLoopUnit->getOwner() == getOwner());
			}
			else
			{

				szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_BOMB_MISSED", getNameKey());
				AddDLLMessage(getOwner(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_BOMBARDED", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_RED(), getX(), getY());
				szBuffer = gDLL->getText("TXT_KEY_MISC_ENEMY_BOMB_MISSED", getNameKey());
				AddDLLMessage(pLoopUnit->getOwner(), false, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_BOMBARDED", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_GREEN(), getX(), getY(), true, true);
			}
		}
		// Plot bombardment
		else if (pPlot->getImprovementType() != NO_IMPROVEMENT)
		{
			if (
				GC.getGame().getSorenRandNum(getBombardRate(), "Bomb - Offense")
				>=
				GC.getGame().getSorenRandNum(GC.getImprovementInfo(pPlot->getImprovementType()).getAirBombDefense(), "Bomb - Defense")
			)
			{
				{

					szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_UNIT_DESTROYED_IMP", getNameKey(), GC.getImprovementInfo(pPlot->getImprovementType()).getTextKeyWide());
					AddDLLMessage(getOwner(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_PILLAGE", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_GREEN(), pPlot->getX(), pPlot->getY());
					if (pPlot->isOwned())
					{
						szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_IMP_WAS_DESTROYED", GC.getImprovementInfo(pPlot->getImprovementType()).getTextKeyWide(), getNameKey(), GET_PLAYER(getOwner()).getCivilizationAdjectiveKey());
						AddDLLMessage(pPlot->getOwner(), false, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_PILLAGE", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_RED(), pPlot->getX(), pPlot->getY(), true, true);
					}
				}
				pPlot->setImprovementType(GC.getImprovementInfo(pPlot->getImprovementType()).getImprovementPillage());
				changeExperience100(100, -1, true);
			}
			else
			{

				szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_UNIT_FAIL_DESTROY_IMP", getNameKey(), GC.getImprovementInfo(pPlot->getImprovementType()).getTextKeyWide());
				AddDLLMessage(getOwner(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_BOMB_FAILS", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_RED(), pPlot->getX(), pPlot->getY());
			}
		}
	}

	if (!sAttack)
	{
		setMadeAttack(true);
		changeMoves(GC.getMOVE_DENOMINATOR());
	}

	addMission(CvMissionDefinition(MISSION_BOMBARD, pPlot, this, pLoopUnit, GC.getMissionInfo(MISSION_RBOMBARD).getTime()* gDLL->getSecsPerTurn()));

	return true;
}

// RevolutionDCM - ranged bombard
// Estimate if a unit stack is worth range bombarding
bool CvUnit::isRbombardable(int iMinStack) const
{
	int collateralCount = 0;
	int averageDamage = 0;
	int averageProtection = 0;
	int seigeCount = 0;

	CvUnit* nextUnit = NULL;
	int unitCount = plot()->getNumUnits();
	if (unitCount >= iMinStack)
	{
		for (int i = 0; i < unitCount; i++)
		{
			nextUnit = plot()->getUnitByIndex(i);
			if (nextUnit != NULL)
			{
				if (nextUnit->canRBombard())
				{
					seigeCount++;
				}
				averageDamage += nextUnit->getDamage();
				//TB Combat Mods begin (fortified collateral defense) Reference to iCollatDef was nextUnit->getCollateralDamageProtection()
				//int iFortDef = nextUnit->fortifyCollateralDefenseModifier();
				//int iFortDefzero = iFortDef < 0 ? 0 : iFortDef;
				int iStdDef = nextUnit->getCollateralDamageProtection();
				int iUncheckedDef = /*iFortDefzero +*/ iStdDef;
				int iUncheckedDefzero = iUncheckedDef < 0 ? 0 : iUncheckedDef;
				int iCollatDef = iUncheckedDefzero > 100 ? 100 : iUncheckedDefzero;
				averageProtection += iCollatDef;
				//TB Combat Mods end
			}
		}
		if (unitCount > 0)
		{
			collateralCount = unitCount - seigeCount;
			averageDamage /= unitCount;
			averageProtection /= unitCount;
			if (collateralCount > 1 && collateralCount < 8 && averageDamage < 40 && averageProtection < 10)
			{
				return true;
			}
		}
	}
	return false;
}

int CvUnit::getRbombardSeigeCount(const CvPlot* pPlot) const
{
	return pPlot ? algo::count_if(pPlot->units(), CvUnit::fn::canRBombard()) : 0;
}

void CvUnit::doOpportunityFire()
{
	//TB Notes regarding Opportunity Fire:
	//While the mechanism has been updated to only target the strongest adjacent unit with this opportunity fire, there is still some work here to do.
	//There is absolutely zero resistability to this damage and no potential for failure to strike, making it far more powerful than any player determined
	//action.  Once I get to focusing in on the Bombard function and adding some more dynamics there to address the above noted issues,
	//I'll have to enforce those mechanisms onto this Opportunity Fire process as well.
	int iI;
	int iUnitDamage = 0;
	int iVolumeDefenders = 0;
	int iBestUnitStr = 0;
	int ipDefenderStr = 0;
	CvPlot* pLoopPlot;
	CvPlot* pAttackPlot = NULL;
	CvUnit* pDefender = NULL;
	CvWString szBuffer;
	CvUnit* pBestUnit;

	if (!GC.isDCM_OPP_FIRE())
	{
		return;
	}
	if (getBombardRate() <= 0 || getDCMBombRange() <= 0)
	{
		return;
	}

	if (getFortifyTurns() > 0)
	{
		for (iI = 0; iI < NUM_DIRECTION_TYPES; iI++)
		{
			pLoopPlot = plotDirection(getX(), getY(), (DirectionTypes)iI);
			if (pLoopPlot != NULL)
			{
				iVolumeDefenders = pLoopPlot->getNumUnits();
				if (iVolumeDefenders > 0)
				{
					pBestUnit = NULL;
					pBestUnit = pLoopPlot->getBestDefender(NO_PLAYER, getOwner(), this, true);
					if (pBestUnit != NULL)
					{
						iBestUnitStr = pBestUnit->currCombatStr(pLoopPlot, this, NULL, true);
						if (pDefender != NULL)
						{
							if (iBestUnitStr > ipDefenderStr)
							{
								pDefender = pBestUnit;
								pAttackPlot = pLoopPlot;
								ipDefenderStr = pDefender->currCombatStr(pLoopPlot, this, NULL, true);
							}
						}
						else
						{
							pDefender = pBestUnit;
							pAttackPlot = pLoopPlot;
							ipDefenderStr = pDefender->currCombatStr(pLoopPlot, this, NULL, true);
						}
					}
				}
			}
		}
		if (pDefender != NULL)
		{
			iUnitDamage = (GC.getGame().getSorenRandNum(getBombardRate(), "Bombard damage") * 5);
			pDefender->changeDamage(iUnitDamage, getOwner());
			//TB Combat Mod begin
			if (dealsColdDamage())
			{
				pDefender->changeColdDamage(iUnitDamage);
			}
			//TB Combat Mod end

			{

				szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_OPP_FIRE", getNameKey(), pDefender->getNameKey());
				AddDLLMessage(getOwner(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_OUR_WITHDRAWL", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_GREEN(), pAttackPlot->getX(), pAttackPlot->getY(), true, true);
				szBuffer = gDLL->getText("TXT_KEY_MISC_ENEMY_OPP_FIRE", getNameKey(), pDefender->getNameKey());
				AddDLLMessage(pDefender->getOwner(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_THEIR_WITHDRAWL", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_RED(), pAttackPlot->getX(), pAttackPlot->getY(), true, true);
			}

			// Bombard entity mission
			addMission(CvMissionDefinition(MISSION_BOMBARD, pAttackPlot, this, pDefender));
		}
	}
}
// ! Dale - SA: Opp Fire

// Dale - SA: Active Defense
void CvUnit::doActiveDefense()
{
	int iDamage, iUnitDamage;
	CvUnit* pDefender = NULL;
	CvCity* pCity = NULL;
	bool bSuccess = false;
	CvWString szBuffer;
	if (!GC.isDCM_ACTIVE_DEFENSE())
	{
		return;
	}
	if (getGroup()->getActivityType() != ACTIVITY_INTERCEPT)
	{
		return;
	}
	foreach_(CvPlot* pLoopPlot, plot()->rect(2, 2))
	{
		if (pLoopPlot->getNumUnits() > 0)
		{
			pDefender = airStrikeTarget(pLoopPlot);
			if (pDefender != NULL)
			{
				iDamage = airCombatDamage(pDefender);
				iUnitDamage = std::max(pDefender->getDamage(), std::min((pDefender->getDamage() + iDamage), airCombatLimit(pDefender)));

				{

					szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_ARE_ATTACKED_BY_AIR", pDefender->getNameKey(), getNameKey(), -(((iUnitDamage - pDefender->getDamage()) * 100) / pDefender->getMaxHP()));
					AddDLLMessage(pDefender->getOwner(), false, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_AIR_ATTACK", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_RED(), pLoopPlot->getX(), pLoopPlot->getY(), true, true);
					szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_ATTACK_BY_AIR", getNameKey(), pDefender->getNameKey(), -(((iUnitDamage - pDefender->getDamage()) * 100) / pDefender->getMaxHP()));
					AddDLLMessage(getOwner(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_AIR_ATTACKED", MESSAGE_TYPE_INFO, pDefender->getButton(), GC.getCOLOR_GREEN(), pLoopPlot->getX(), pLoopPlot->getY());
				}
				collateralCombat(pLoopPlot, pDefender);
				pDefender->setDamage(iUnitDamage, getOwner());
				bSuccess = true;
				//TB Combat Mod begin
				if (dealsColdDamage())
				{
					pDefender->setColdDamage(iUnitDamage);
				}
				//TB Combat mod end
				if (pLoopPlot->isActiveVisible(false) && (!pDefender->isUsingDummyEntities() && pDefender->isInViewport()))
				{
					setCombatTimer(GC.getMissionInfo(MISSION_AIRSTRIKE).getTime());
					GC.getGame().incrementTurnTimer(getCombatTimer());

					addMission(CvAirMissionDefinition(MISSION_AIRSTRIKE, pLoopPlot, this, pDefender));
				}
			}
		}
#ifdef OUTBREAKS_AND_AFFLICTIONS
		if (bSuccess)
		{
			//Afflict
			int iDistanceAttackCommunicability = 0;
			bool bAffliction = false;
			if (GC.getGame().isOption(GAMEOPTION_OUTBREAKS_AND_AFFLICTIONS))
			{
				for (int iI = 0; iI < GC.getNumPromotionLineInfos(); iI++)
				{
					if (GC.getPromotionLineInfo((PromotionLineTypes)iI).isAffliction() && !GC.getPromotionLineInfo((PromotionLineTypes)iI).isCritical())
					{
						//Distance Communicability
						iDistanceAttackCommunicability = getDistanceAttackCommunicability((PromotionLineTypes)iI);
						bool bDistAttComm = iDistanceAttackCommunicability > 0;
						PromotionLineTypes eAfflictionLine = ((PromotionLineTypes)iI);
						bool bAffonAtt = (hasAfflictOnAttackType(eAfflictionLine) && isAfflictOnAttackTypeDistance(eAfflictionLine));
						if (bDistAttComm || bAffonAtt)
						{
							bAffliction = true;
							foreach_(CvUnit* pLoopUnit, pLoopPlot->units())
							{
								if (bDistAttComm)
								{
									if (pLoopUnit->checkContractDisease(eAfflictionLine, iDistanceAttackCommunicability))
									{
										pLoopUnit->afflict(eAfflictionLine);
									}
									pCity = pLoopPlot->getPlotCity();
									if (pCity != NULL)
									{
										pCity->changePromotionLineAfflictionAttackCommunicability(eAfflictionLine, iDistanceAttackCommunicability);
									}
								}
								if (bAffonAtt)
								{
									int iAttackersPoisonChance = getAfflictOnAttackTypeProbability(eAfflictionLine) - pLoopUnit->fortitudeTotal() - pLoopUnit->getUnitAfflictionTolerance(eAfflictionLine);

									if (GC.getGame().getSorenRandNum(100, "AttackersPoisonRoll") < iAttackersPoisonChance)
									{
										pLoopUnit->afflict(eAfflictionLine, true, this);
									}
								}
							}
						}
					}
				}
			}
		}
#endif // OUTBREAKS_AND_AFFLICTIONS
	}
}
// ! Dale - SA: Active Defense

// Dale - FE: Fighters
bool CvUnit::canFEngage() const
{
	if(!GC.isDCM_FIGHTER_ENGAGE())
	{
		return false;
	}
	if (!m_pUnitInfo->getDCMFighterEngage())
	{
		return false;
	}
	if (getDomainType() != DOMAIN_AIR)
	{
		return false;
	}
	if (isMadeAttack())
	{
		return false;
	}
//	if (isCargo())
//	{
//		return false;
//	}
	return true;
}

bool CvUnit::canFEngageAt(const CvPlot* pPlot, int iX, int iY) const
{
	if (!canFEngage())
	{
		return false;
	}
	if (iX < 0 || iY < 0)
	{
		return false;
	}
	const CvPlot* pTargetPlot = GC.getMap().plot(iX, iY);

	if (plotDistance(pPlot->getX(), pPlot->getY(), pTargetPlot->getX(), pTargetPlot->getY()) > airRange())
	{
		return false;
	}
	if (pTargetPlot->isOwned() && pTargetPlot->getTeam() != getTeam()
	&& !atWar(pTargetPlot->getTeam(), getTeam()))
	{
		return false;
	}
	for (int iI = 0; iI < MAX_PLAYERS; ++iI)
	{
		if (atWar(GET_PLAYER((PlayerTypes)iI).getTeam(), getTeam())
		&& algo::any_of(GET_PLAYER((PlayerTypes)iI).units(), CvUnit::fn::plot() == pTargetPlot && CvUnit::fn::getDomainType() == DOMAIN_AIR))
		{
			return true;
		}
	}
	return false;
}

bool CvUnit::fighterEngage(int iX, int iY)
{
	if (!canFEngageAt(plot(), iX, iY))
	{
		return false;
	}
	CvPlot* pPlot = GC.getMap().plot(iX, iY);

	if (interceptTest(pPlot))
	{
		return true;
	}
	int iCount = algo::count_if(pPlot->units(), CvUnit::fn::getDomainType() == DOMAIN_AIR);
	iCount = 1 + GC.getGame().getSorenRandNum(iCount, "Choose plane");
	CvUnit* pDefender = NULL;
	CLLNode<IDInfo>* pUnitNode = pPlot->headUnitNode();
	while (iCount > 0)
	{
		CvUnit* pLoopUnit = ::getUnit(pUnitNode->m_data);
		if (pLoopUnit->getDomainType() == DOMAIN_AIR)
		{
			iCount--;
			pDefender = pLoopUnit;
		}
		pUnitNode = pPlot->nextUnitNode(pUnitNode);
	}
	if (pDefender != NULL)
	{
		CvAirMissionDefinition kAirMission(MISSION_AIRSTRIKE, pPlot, this, pDefender);
		resolveAirCombat(pDefender, pPlot, kAirMission);
		if (kAirMission.isValid())
		{
			setCombatTimer(GC.getMissionInfo(MISSION_AIRSTRIKE).getTime());
			GC.getGame().incrementTurnTimer(getCombatTimer());
			addMission(kAirMission);
		}

		if (isDead())
		{

			CvWString szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_SHOT_DOWN_ENEMY", pDefender->getNameKey(), getNameKey(), getVisualCivAdjective(pDefender->getTeam()));
			AddDLLMessage(pDefender->getOwner(), false, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_INTERCEPT", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_GREEN(), pPlot->getX(), pPlot->getY(), true, true);
			szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_UNIT_SHOT_DOWN", getNameKey(), pDefender->getNameKey());
			AddDLLMessage(getOwner(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_INTERCEPTED", MESSAGE_TYPE_INFO, pDefender->getButton(), GC.getCOLOR_RED(), pPlot->getX(), pPlot->getY());
		}
		else if (kAirMission.getDamage(BATTLE_UNIT_ATTACKER) > 0)
		{

			CvWString szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_HURT_ENEMY_AIR", pDefender->getNameKey(), getNameKey(), -(kAirMission.getDamage(BATTLE_UNIT_ATTACKER)), getVisualCivAdjective(pDefender->getTeam()));
			AddDLLMessage(pDefender->getOwner(), false, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_INTERCEPT", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_GREEN(), pPlot->getX(), pPlot->getY(), true, true);
			szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_AIR_UNIT_HURT", getNameKey(), pDefender->getNameKey(), -(kAirMission.getDamage(BATTLE_UNIT_ATTACKER)));
			AddDLLMessage(getOwner(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_INTERCEPTED", MESSAGE_TYPE_INFO, pDefender->getButton(), GC.getCOLOR_RED(), pPlot->getX(), pPlot->getY());
		}
		if (pDefender->isDead())
		{

			CvWString szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_SHOT_DOWN_ENEMY", getNameKey(), pDefender->getNameKey(), pDefender->getVisualCivAdjective(getTeam()));
			AddDLLMessage(getOwner(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_INTERCEPT", MESSAGE_TYPE_INFO, pDefender->getButton(), GC.getCOLOR_GREEN(), pPlot->getX(), pPlot->getY(), true, true);
			szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_UNIT_SHOT_DOWN", pDefender->getNameKey(), getNameKey());
			AddDLLMessage(pDefender->getOwner(), false, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_INTERCEPTED", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_RED(), pPlot->getX(), pPlot->getY());
		}
		else if (kAirMission.getDamage(BATTLE_UNIT_DEFENDER) > 0)
		{

			CvWString szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_DAMAGED_ENEMY_AIR", getNameKey(), pDefender->getNameKey(), -(kAirMission.getDamage(BATTLE_UNIT_DEFENDER)), pDefender->getVisualCivAdjective(getTeam()));
			AddDLLMessage(getOwner(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_INTERCEPT", MESSAGE_TYPE_INFO, pDefender->getButton(), GC.getCOLOR_GREEN(), pPlot->getX(), pPlot->getY(), true, true);
			szBuffer = gDLL->getText("TXT_KEY_MISC_YOUR_AIR_UNIT_DAMAGED", pDefender->getNameKey(), getNameKey(), -(kAirMission.getDamage(BATTLE_UNIT_DEFENDER)));
			AddDLLMessage(pDefender->getOwner(), false, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_INTERCEPTED", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_RED(), pPlot->getX(), pPlot->getY());
		}
		if (0 == kAirMission.getDamage(BATTLE_UNIT_ATTACKER) + kAirMission.getDamage(BATTLE_UNIT_DEFENDER))
		{

			CvWString szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_ABORTED_ENEMY_AIR", pDefender->getNameKey(), getNameKey(), getVisualCivAdjective(getTeam()));
			AddDLLMessage(pDefender->getOwner(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_INTERCEPT", MESSAGE_TYPE_INFO, pDefender->getButton(), GC.getCOLOR_GREEN(), pPlot->getX(), pPlot->getY(), true, true);
			szBuffer = gDLL->getText("TXT_KEY_MISC_YOUR_AIR_UNIT_ABORTED", getNameKey(), pDefender->getNameKey());
			AddDLLMessage(getOwner(), false, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_INTERCEPTED", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_RED(), pPlot->getX(), pPlot->getY());
		}
	}
	setMadeAttack(true);
	changeMoves(GC.getMOVE_DENOMINATOR());
	return true;
}
// ! Dale - FE: Fighters


/************************************************************************************************/
/* INFLUENCE_DRIVEN_WAR                   04/16/09                                johnysmith    */
/*                                                                                              */
/* Original Author Moctezuma              Start                                                 */
/************************************************************************************************/
// unit influences combat area after victory
// returns influence % in defended plot
float CvUnit::doVictoryInfluence(CvUnit* pLoserUnit, bool bAttacking, bool bWithdrawal)
{
	PROFILE_FUNC();

	if (!pLoserUnit->canDefend())
	{
		return 0.0f; // no influence from worker capture
	}
	if (GET_PLAYER(pLoserUnit->getOwner()).hasFixedBorders())
	{
		return 0.0f;
	}
	if (plot()->getWorkingCity() != NULL && plot()->getWorkingCity()->isProtectedCulture())
	{
		return 0.0f;
	}
	if (pLoserUnit->plot()->getWorkingCity() != NULL && pLoserUnit->plot()->getWorkingCity()->isProtectedCulture())
	{
		return 0.0f;
	}
	if (isAnimal() || pLoserUnit->isAnimal())
	{
		return 0.0f;
	}
	if (isAlwaysHostile(plot()) || pLoserUnit->isAlwaysHostile(pLoserUnit->plot()))
	{
		return 0.0f;
	}
	if (GC.isIDW_NO_BARBARIAN_INFLUENCE() && (isHominid() || pLoserUnit->isHominid()))
	{
		return 0.0f;
	}
	if (GC.isIDW_NO_NAVAL_INFLUENCE() && DOMAIN_SEA == getDomainType())
	{
		return 0.0f;
	}

	CvPlot* pWinnerPlot = plot();
	CvPlot* pLoserPlot = pLoserUnit->plot();

	const CvPlot* pDefenderPlot = bAttacking ? pLoserPlot : pWinnerPlot;

	const int iWinnerCultureBefore = pDefenderPlot->getCulture(getOwner()); //used later for influence %

	int iWinnerPlotMultiplier = GC.getIDW_WINNER_PLOT_MULTIPLIER();
	int iLoserPlotMultiplier = GC.getIDW_LOSER_PLOT_MULTIPLIER();
	if (bWithdrawal)
	{
		iWinnerPlotMultiplier /= 3;
		iLoserPlotMultiplier /= 3;
	}
	if (pLoserPlot->isEnemyCity(*this, true)) // city combat
	{
		int iDefenders = pLoserPlot->getNumVisibleEnemyDefenders(this);

		if (iDefenders < 4 && GC.isIDW_EMERGENCY_DRAFT_ENABLED())
		{
			const int iDefenderCulture = pLoserPlot->getCulture(pLoserUnit->getOwner());
			const int iAttackerCulture = pLoserPlot->getCulture(getOwner());

			if (iDefenderCulture >= iAttackerCulture * 2)
			{
				// if defender culture in city's central tile is still higher then atacker culture
				// -> city is not captured yet but emergency militia is drafted
				pLoserPlot->getPlotCity()->emergencyConscript();
				iDefenders++;

				// calculate city resistence % (to be displayed in game log)
				const float fResistence = (iDefenderCulture-iAttackerCulture) * 100.0f / (2 * pDefenderPlot->countTotalCulture());
				{

					CvWString szBuffer;
					CvWString szResistence;
					szBuffer = gDLL->getText("TXT_KEY_MISC_CITY_MILITIA_EMERGED");
					szResistence.Format(L" %.1f%%", fResistence);
					szBuffer += szResistence;
					//szBuffer.Format(L"City militia has emerged! Resistance: %.1f%%", fResistence);
					AddDLLMessage(pLoserUnit->getOwner(), false, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_UNIT_BUILD_UNIT", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_GREEN(), pLoserPlot->getX(), pLoserPlot->getY(), true, true);
					AddDLLMessage(getOwner(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_UNIT_BUILD_UNIT", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_RED(), pLoserPlot->getX(), pLoserPlot->getY());
				}
			}
		}
		if (iDefenders == 0) // City Capture
		{
			const int iNoCityDefenderMultiplier = GC.getIDW_NO_CITY_DEFENDER_MULTIPLIER();

			influencePlots(pLoserPlot, pLoserUnit->getOwner(), iLoserPlotMultiplier * iNoCityDefenderMultiplier / 100);
			influencePlots(pWinnerPlot, pLoserUnit->getOwner(), iWinnerPlotMultiplier * iNoCityDefenderMultiplier / 100);
		}
		else // As field combat
		{
			influencePlots(pLoserPlot, pLoserUnit->getOwner(), iLoserPlotMultiplier);
			influencePlots(pWinnerPlot, pLoserUnit->getOwner(), iWinnerPlotMultiplier);
		}
	}
	else if (pLoserPlot->isActsAsCity() && pLoserPlot->getNumVisibleEnemyDefenders(this) > 1)
	{
		// Fort captured
		const int iFortCaptureMultiplier = GC.getIDW_FORT_CAPTURE_MULTIPLIER();

		influencePlots(pLoserPlot, pLoserUnit->getOwner(), iLoserPlotMultiplier * iFortCaptureMultiplier / 100);
		influencePlots(pWinnerPlot, pLoserUnit->getOwner(), iWinnerPlotMultiplier * iFortCaptureMultiplier / 100);
	}
	else // Field combat
	{
		influencePlots(pLoserPlot, pLoserUnit->getOwner(), iLoserPlotMultiplier);
		influencePlots(pWinnerPlot, pLoserUnit->getOwner(), iWinnerPlotMultiplier);
	}

	// calculate influence % in defended plot (to be displayed in game log)
	const int iTotalCulture = pDefenderPlot->countTotalCulture();

	if (iTotalCulture > 0)
	{
		return (pDefenderPlot->getCulture(getOwner()) - iWinnerCultureBefore) * 100.0f / iTotalCulture;
	}
    return 0.0f;
}

// unit influences given plot and surounding area i.e. transfers culture from target civ to unit's owner
void CvUnit::influencePlots(CvPlot* pCentralPlot, const PlayerTypes eTargetPlayer, const int iLocationMultiplier)
{
	// get influence radius
	const int iInfluenceRadius = GC.getIDW_INFLUENCE_RADIUS();
	if (iInfluenceRadius < 0)
		return;

	// calculate base multiplier used for all plots
	int iMultiplier = GC.getIDW_BASE_COMBAT_INFLUENCE() * iLocationMultiplier / 100;
	if (iMultiplier < 1)
		return;

	if (NO_UNIT != getLeaderUnitType()) // warlord is here
	{
		iMultiplier *= GC.getIDW_WARLORD_MULTIPLIER();
		iMultiplier /= 100;
	}
	if (iMultiplier < 1) return;

	const int iCityPlotMultiplier = GC.isIDW_EMERGENCY_DRAFT_ENABLED() ? 100 : GC.getIDW_CITY_TILE_MULTIPLIER();

	//CvWString szBuffer;
	//szBuffer.Format(L"Factors: %d, %d, %d, %d, %d", GC.getIDW_BASE_COMBAT_INFLUENCE(), iLocationMultiplier, iWarlordMultiplier, iMultiplier, iInfluenceRadius);
	//AddDLLMessage(getOwner(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_UNIT_BUILD_UNIT", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_RED(), pCentralPlot->getX(), pCentralPlot->getY());

	for (int iDX = -iInfluenceRadius; iDX <= iInfluenceRadius; iDX++)
	{
		for (int iDY = -iInfluenceRadius; iDY <= iInfluenceRadius; iDY++)
		{
			const int iDistance = plotDistance(0, 0, iDX, iDY);

			if (iDistance <= iInfluenceRadius)
			{
				CvPlot* pLoopPlot = plotXY(pCentralPlot->getX(), pCentralPlot->getY(), iDX, iDY);

				if (pLoopPlot != NULL)
				{
					const int iTargetCulture = pLoopPlot->getCulture(eTargetPlayer);
					if (iTargetCulture < 1)
						continue;

					int iMult = iMultiplier;
					// calculate distance multiplier for current plot
					int iDistanceMultiplier = 100 / (iDistance + 1);
					if (iDistanceMultiplier < 1)
						continue;
					if (pLoopPlot->isCity())
					{
						iMult *= iCityPlotMultiplier;
						iMult /= 100;
					}
					if (iMult < 1) continue;

					//szBuffer.Format(L"Value=%d, root=%d", iTargetCulture, intSqrt(iTargetCulture));
					//AddDLLMessage(getOwner(), true, 24, szBuffer);

					int iCultureTransfer = iMult * iDistanceMultiplier * intSqrt(iTargetCulture) / 10000;
					//szBuffer.Format(L"CultureChange=%d", iCultureTransfer);
					//AddDLLMessage(getOwner(), true, 24, szBuffer);

					if (iTargetCulture < iCultureTransfer)
					{
						// cannot transfer more culture than remaining target culure
						iCultureTransfer = iTargetCulture;
					}
					else if (iCultureTransfer < 1)
					{
						// always at least 1 point of culture must be transfered
						// othervise we may have the problems with capturing of very low culture cities.
						iCultureTransfer = 1;
					}

					if (iCultureTransfer == iTargetCulture
					&& (pLoopPlot->isActsAsCity() // fort, must not lose all culture when it may still be garrisoned
					// plot without city can't lose the last point of culture if its owner has fixed borders, otherwise it'd flip
					|| pLoopPlot->getPlotCity() == NULL && GET_PLAYER(eTargetPlayer).hasFixedBorders()))
					{
						iCultureTransfer--;
					}

					if (iCultureTransfer > 0)
					{
						// target player's culture in plot is lowered
						pLoopPlot->changeCulture(eTargetPlayer, -iCultureTransfer, false);
						// owners's culture in plot is raised
						pLoopPlot->changeCulture(getOwner(), iCultureTransfer, true);
					}
				}
			}
		}
	}
}


// unit influences current tile via pillaging
// returns influence % in current plot
float CvUnit::doPillageInfluence()
{
	if (isAnimal() || isHiddenNationality())
	{
		return 0.0f;
	}
	if (isHominid() && GC.isIDW_NO_BARBARIAN_INFLUENCE())
	{
		return 0.0f;
	}
	if (DOMAIN_SEA == getDomainType() && GC.isIDW_NO_NAVAL_INFLUENCE())
	{
		return 0.0f;
	}

	CvPlot* pPlot = plot();
	if (pPlot == NULL)
	{
		FErrorMsg("pPlot == NULL; should not happen");
		return 0.0f;
	}
	if (pPlot->getWorkingCity() != NULL && pPlot->getWorkingCity()->isProtectedCulture())
	{
		return 0.0f;
	}

	const PlayerTypes eTargetPlayer = pPlot->getOwner();
	const int iTargetCulture = pPlot->getCulture(eTargetPlayer);
	if (iTargetCulture < 1)
	{
		FErrorMsg("iTargetCulture < 1; should not happen");
		return 0.0f;
	}
	int iCultureTransfer = GC.getIDW_BASE_PILLAGE_INFLUENCE() * intSqrt(iTargetCulture) / 100;
	if (iCultureTransfer < 1)
		iCultureTransfer = 1;
	// cannot transfer more culture than remaining target culure
	if (iTargetCulture <= iCultureTransfer)
	{
		iCultureTransfer = iTargetCulture;
		// plot can't lose the last point of culture if its owner has fixed borders, otherwise it'd flip
		if (GET_PLAYER(eTargetPlayer).hasFixedBorders())
		{
			iCultureTransfer--;
		}
	}

	if (iCultureTransfer > 0)
	{
		const int iOurCultureBefore = pPlot->getCulture(getOwner()); //used later for influence %

		pPlot->changeCulture(eTargetPlayer, -iCultureTransfer, false);
		pPlot->changeCulture(getOwner(), iCultureTransfer, true);

		// calculate influence % in pillaged plot (to be displayed in game log)
		return (pPlot->getCulture(getOwner()) - iOurCultureBefore) * 100.0f / pPlot->countTotalCulture();
	}
	return 0.0f;
}
// ------ END InfluenceDrivenWar ---------------------------------


bool CvUnit::canPerformInquisition(const CvPlot* pPlot) const
{
	if (!m_pUnitInfo->isInquisitor())
	{
		return false;
	}
	const CvCity* pCity = pPlot->getPlotCity();

	if (pCity == NULL)
	{
		return false;
	}
	if (GET_PLAYER(getOwner()).getStateReligion() == NO_RELIGION)
	{
		return false;
	}
	if (!pCity->isHasReligion(GET_PLAYER(getOwner()).getStateReligion()))
	{
		return false;
	}
	// Allow inquisitions in vassals
	if (pCity->getTeam() != getTeam() && !GET_TEAM(pCity->getTeam()).isVassal(getTeam()))
	{
		return false;
	}
	if (!pCity->isInquisitionConditions() || !GET_PLAYER(getOwner()).isInquisitionConditions())
	{
		return false;
	}
	if (GET_PLAYER(getOwner()).getStateReligion() != GET_PLAYER(pCity->getOwner()).getStateReligion())
	{
		return false;
	}
	return true;
}


bool CvUnit::performInquisition()
{
	const CvPlot* pPlot = plot();

	if (!canPerformInquisition(pPlot))
	{
		return false;
	}
	CvCity* pCity = pPlot->getPlotCity();

	if (pCity != NULL)
	{
		CvWString szBuffer;

		for (int iI = 0; iI < MAX_PC_PLAYERS; iI++)
		{
			const CvPlayer& kLoopPlayer = GET_PLAYER((PlayerTypes)iI);
			if (kLoopPlayer.isAlive()
			&& (pPlot->isVisible(kLoopPlayer.getTeam(), true) || pPlot->isRevealed(kLoopPlayer.getTeam(), true)))
			{
				gDLL->getInterfaceIFace()->playGeneralSound("AS3D_UN_CHRIST_MISSIONARY_ACTIVATE", pPlot->getPoint());
			}
		}

		int iHolyCityVal = 0;
		int iReligionCount = 0;
		for (int iI = 0; iI < GC.getNumReligionInfos(); iI++)
		{
			if ((ReligionTypes)iI != GET_PLAYER(getOwner()).getStateReligion() && pCity->isHasReligion((ReligionTypes)iI))
			{
				iReligionCount++;
				if (pCity->isHolyCity((ReligionTypes)iI))
				{
					iHolyCityVal = 50;
				}
			}
		}
		int iCompensationGold = 0;

		if (GC.getGame().getSorenRandNum(100, "Inquisition Persection Chance") < std::max(25, (95 - iHolyCityVal - (5 * iReligionCount))))
		{
			// Change memory if we are removing a religion that is another player's state religion
			for (int iI = 0; iI < MAX_PC_PLAYERS; iI++)
			{
				CvPlayer& kLoopPlayer = GET_PLAYER((PlayerTypes)iI);
				if (kLoopPlayer.isAlive()
				&& (pPlot->isVisible(kLoopPlayer.getTeam(), false) || pPlot->isRevealed(kLoopPlayer.getTeam(), false))
				&& GET_TEAM(kLoopPlayer.getTeam()).isHasMet(GET_PLAYER(getOwner()).getTeam()))
				{
					for (int iJ = 0; iJ < GC.getNumReligionInfos(); iJ++)
					{
						if (GET_PLAYER(getOwner()).getStateReligion() != (ReligionTypes)iJ
						// if the player has the holy city, or has the religion as a state religion.
						&& (kLoopPlayer.hasHolyCity((ReligionTypes)iJ) || pCity->isHasReligion((ReligionTypes)iJ) && kLoopPlayer.getStateReligion() == (ReligionTypes)iJ))
						{
							kLoopPlayer.AI_changeMemoryCount(getOwner(), MEMORY_INQUISITION, 1);
							break;
						}
					}
				}
			}
			//Remove temples, monasteries, etc...
			for (int iI = 0; iI < GC.getNumBuildingInfos(); iI++)
			{
				if (pCity->getNumRealBuilding((BuildingTypes)iI) > 0)
				{
					const CvBuildingInfo& kLoopBuilding = GC.getBuildingInfo((BuildingTypes)iI);
					for (int iJ = 0; iJ < GC.getNumReligionInfos(); iJ++)
					{
						if (GET_PLAYER(getOwner()).getStateReligion() != (ReligionTypes)iJ
						&& kLoopBuilding.getPrereqReligion() == (ReligionTypes)iJ)
						{
							pCity->setNumRealBuilding((BuildingTypes)iI, 0);
							iCompensationGold += kLoopBuilding.getProductionCost() * GC.getGameSpeedInfo(GC.getGame().getGameSpeedType()).getHammerCostPercent() / std::max(1, GC.getDefineINT("INQUISITION_BUILDING_GOLD_DIVISOR"));
						}
					}
				}
			}
			//Remove the Religion & Holy Cities
			for (int iI = 0; iI < GC.getNumReligionInfos(); iI++)
			{
				if (GET_PLAYER(getOwner()).getStateReligion() != (ReligionTypes)iI)
				{
					if (pCity->isHolyCity((ReligionTypes)iI))
					{
						//TODO: This value needs to be set from python
						if (GC.getDefineINT("OC_RESPAWN_HOLY_CITIES"))
						{
							GC.getGame().setHolyCity((ReligionTypes)iI, NULL , false);
							iCompensationGold += GC.getDefineINT("HOLYCITY_REMOVAL_GOLD");
							pCity->setHasReligion((ReligionTypes)iI, false, false, false);

							//Find the best place to replace the holy city
							PlayerTypes eBestPlayer = NO_PLAYER;
							int iBestCount = 0;
							for (int iJ = 0; iJ < MAX_PC_PLAYERS; iJ++)
							{
								const CvPlayerAI& kLoopPlayer = GET_PLAYER((PlayerTypes)iJ);

								if (kLoopPlayer.isAlive())
								{
									const int iCount = kLoopPlayer.getHasReligionCount((ReligionTypes)iI);
									if (iCount > iBestCount)
									{
										iBestCount = iCount;
										eBestPlayer = (PlayerTypes)iJ;
									}
								}
							}
							//Relocate the holy city
							if (eBestPlayer != NO_PLAYER)
							{
								const CvPlayerAI& kPlayer = GET_PLAYER(eBestPlayer);
								foreach_(const CvCity* pLoopCity, kPlayer.cities())
								{
									if (pLoopCity->isHasReligion((ReligionTypes)iI))
									{
										GC.getGame().setHolyCity((ReligionTypes)iI, pLoopCity, true);
										//TODO: Create a text entry: "A Holy City Religion has been Respawned"
										{

											szBuffer = gDLL->getText("TXT_KEY_MSG_HOLY_CITY_RESPAWNED");
											AddDLLMessage(
												GC.getGame().getActivePlayer(), true, GC.getEVENT_MESSAGE_TIME(),
												szBuffer, "AS2D_DISCOVERBONUS", MESSAGE_TYPE_MAJOR_EVENT,
												"Art/Interface/Buttons/TerrainFeatures/Forest.dds",
												ColorTypes(8), getX(), getY(), false, false
											);
										}
										break;
									}
								}
							}
						}
					}
					else if (pCity->isHasReligion((ReligionTypes)iI))
					{
						pCity->setHasReligion((ReligionTypes)iI, false, false, false);
						iCompensationGold += GC.getDefineINT("RELIGION_REMOVAL_GOLD");
					}
				}
			}

			for (int iI = 0; iI < MAX_PC_PLAYERS; iI++)
			{
				const CvPlayer& kLoopPlayer = GET_PLAYER((PlayerTypes)iI);
				if (kLoopPlayer.isAlive()
				&& (pPlot->isVisible(kLoopPlayer.getTeam(), true) || pPlot->isRevealed(kLoopPlayer.getTeam(), true)))
				{
					szBuffer = gDLL->getText("TXT_KEY_MSG_INQUISITION", pCity->getNameKey());
					AddDLLMessage(((PlayerTypes)iI), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_PLAGUE", MESSAGE_TYPE_MAJOR_EVENT, getButton() , ColorTypes(8), getX(), getY(), true, true);
				}
			}

			//Increase Temp Anger
			pCity->changeHurryAngerTimer(pCity->flatHurryAngerLength());
			if (GC.getGame().isOption(GAMEOPTION_REVOLUTION))
			{
				//Avoid setting the Rev Index below 0...
				pCity->changeLocalRevIndex(-std::min(pCity->getRevolutionIndex(), iCompensationGold));
			}
			else GET_PLAYER(getOwner()).changeGold(iCompensationGold);
		}
		//Inquisition Fails...
		else
		{
			for (int iI = 0; iI < MAX_PC_PLAYERS; iI++)
			{
				const CvPlayer& kLoopPlayer = GET_PLAYER((PlayerTypes)iI);
				if (kLoopPlayer.isAlive()
				&& (pPlot->isVisible(kLoopPlayer.getTeam(), true) || pPlot->isRevealed(kLoopPlayer.getTeam(), true)))
				{
					szBuffer = gDLL->getText("TXT_KEY_MSG_INQUISITION_FAIL", pCity->getNameKey());
					AddDLLMessage(((PlayerTypes)iI), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_SABOTAGE", MESSAGE_TYPE_MAJOR_EVENT, getButton() , ColorTypes(8), getX(), getY(), true, true);
				}
			}
			pCity->changeHurryAngerTimer(pCity->flatHurryAngerLength());

			if (GC.getGame().isOption(GAMEOPTION_REVOLUTION))
			{
				pCity->changeLocalRevIndex(iCompensationGold / 2);
			}
		}
		if (pPlot->isActiveVisible(false))
		{
			NotifyEntity(MISSION_INQUISITION);
		}
	}
	kill(true, NO_PLAYER, true);
	return true;
}


bool CvUnit::canTradeUnit(PlayerTypes eReceivingPlayer) const
{
	if (eReceivingPlayer == NO_PLAYER || eReceivingPlayer > MAX_PLAYERS)
	{
		return false;
	}
	if (hasCargo())
	{
		return false;
	}
	if (getDomainType() == DOMAIN_SEA)
	{
		CvArea* pWaterArea;
		bool bCoast = false;
		foreach_(const CvCity* pLoopCity, GET_PLAYER(eReceivingPlayer).cities())
		{
			if ((pWaterArea = pLoopCity->waterArea()) != NULL && !pWaterArea->isLake())
			{
				bCoast = true;
				break;
			}
		}
		if (!bCoast)
		{
			return false;
		}
	}
	return true;
}

void CvUnit::tradeUnit(PlayerTypes eReceivingPlayer)
{
	if (eReceivingPlayer == NO_PLAYER)
	{
		return;
	}
	CvPlayerAI& receiver = GET_PLAYER(eReceivingPlayer);
	CvCity* pBestCity = NULL;

	if (getDomainType() == DOMAIN_SEA)
	{
		pBestCity = receiver.findBestCoastalCity();
	}
	else pBestCity = receiver.getCapitalCity();

	CvUnit* pTradeUnit = receiver.initUnit(
		getUnitType(), pBestCity->getX(), pBestCity->getY(), AI_getUnitAIType(), NO_DIRECTION,
		GC.getGame().getSorenRandNum(10000, "AI Unit Birthmark")
	);
	if (pTradeUnit != NULL)
	{
		pTradeUnit->convert(this);
		if (receiver.isHuman())
		{
			AddDLLMessage(
				eReceivingPlayer, false, GC.getEVENT_MESSAGE_TIME(),
				gDLL->getText(
					"TXT_KEY_MISC_TRADED_UNIT_TO_YOU",
					GET_PLAYER(getOwner()).getNameKey(), pTradeUnit->getNameKey()
				),
				"AS2D_UNITGIFTED", MESSAGE_TYPE_INFO, pTradeUnit->getButton(),
				GC.getCOLOR_WHITE(), pTradeUnit->getX(), pTradeUnit->getY(), true, true
			);
		}
	}
}

bool CvUnit::spyNukeAffected(const CvPlot* pPlot, TeamTypes eTeam, int iRange) const
{
	if (!GET_TEAM(eTeam).isAlive() || eTeam == getTeam())
	{
		return false;
	}
	foreach_(const CvPlot* pLoopPlot, pPlot->rect(iRange, iRange))
	{
		if (pLoopPlot->getTeam() == eTeam)
		{
			return true;
		}
		if (pLoopPlot->plotCheck(PUF_isCombatTeam, eTeam, getTeam()) != NULL)
		{
			return true;
		}
	}
	return false;
}

bool CvUnit::spyNuke(int iX, int iY, bool bCaught)
{
	bool abTeamsAffected[MAX_TEAMS];

	CvPlot* pPlot = GC.getMap().plot(iX, iY);

	for (int iI = 0; iI < MAX_TEAMS; iI++)
	{
		abTeamsAffected[iI] = spyNukeAffected(pPlot, (TeamTypes)iI, 1);
	}

	if (bCaught)
	{
		const TeamTypes eTeam = getTeam();
		CvTeamAI& team = GET_TEAM(eTeam);

		for (int iI = 0; iI < MAX_PC_TEAMS; iI++)
		{
			if (abTeamsAffected[iI])
			{
				if (!isEnemy((TeamTypes)iI) && iI != eTeam)
				{
					team.declareWar((TeamTypes)iI, false, WARPLAN_TOTAL);
				}
				GET_TEAM((TeamTypes)iI).changeWarWeariness(eTeam, 100 * GC.getDefineINT("WW_HIT_BY_NUKE"));
				team.changeWarWeariness((TeamTypes)iI, 100 * GC.getDefineINT("WW_ATTACKED_WITH_NUKE"));
				team.AI_changeWarSuccess((TeamTypes)iI, GC.getDefineINT("WAR_SUCCESS_NUKE"));
			}
		}
		for (int iI = 0; iI < MAX_PC_TEAMS; iI++)
		{
			if (GET_TEAM((TeamTypes)iI).isAlive() && iI != eTeam)
			{
				if (abTeamsAffected[iI])
				{
					for (int iJ = 0; iJ < MAX_PC_PLAYERS; iJ++)
					{
						if (GET_PLAYER((PlayerTypes)iJ).isAliveAndTeam((TeamTypes)iI))
						{
							GET_PLAYER((PlayerTypes)iJ).AI_changeMemoryCount(getOwner(), MEMORY_NUKED_US, 1);
						}
					}
				}
				else
				{
					for (int iJ = 0; iJ < MAX_PC_TEAMS; iJ++)
					{
						if (GET_TEAM((TeamTypes)iJ).isAlive() && abTeamsAffected[iJ]
						&& GET_TEAM((TeamTypes)iI).isHasMet((TeamTypes)iJ)
						&& GET_TEAM((TeamTypes)iI).AI_getAttitude((TeamTypes)iJ) >= ATTITUDE_CAUTIOUS)
						{
							for (int iK = 0; iK < MAX_PC_PLAYERS; iK++)
							{
								if (GET_PLAYER((PlayerTypes)iK).isAliveAndTeam((TeamTypes)iI))
								{
									GET_PLAYER((PlayerTypes)iK).AI_changeMemoryCount(getOwner(), MEMORY_NUKED_FRIEND, 1);
								}
							}
							break;
						}
					}
				}
			}
		}
	}
	const CvWString szBuffer =
	(
		bCaught
		?
		gDLL->getText("TXT_KEY_MISC_NUKE_ENEMY_SPY", GET_PLAYER(getOwner()).getNameKey(), GET_PLAYER(pPlot->getOwner()).getNameKey())
		:
		gDLL->getText("TXT_KEY_MISC_NUKE_UNKNOWN", GET_PLAYER(pPlot->getOwner()).getNameKey())
	);
	for (int iI = 0; iI < MAX_PC_PLAYERS; iI++)
	{
		if (GET_PLAYER((PlayerTypes)iI).isAlive() && GET_PLAYER((PlayerTypes)iI).isHuman())
		{
			AddDLLMessage(
				(PlayerTypes)iI, iI == getOwner(), GC.getEVENT_MESSAGE_TIME(),
				szBuffer, "AS2D_NUKE_EXPLODES", MESSAGE_TYPE_MAJOR_EVENT, getButton(),
				GC.getCOLOR_RED(), pPlot->getX(), pPlot->getY(), true, true
			);
		}
	}

	//This is just so the espionage mission makes the cool explosion effect.
	if (GC.getInfoTypeForString("EFFECT_ICBM_NUCLEAR_EXPLOSION") != -1)
	{
		gDLL->getEngineIFace()->TriggerEffect((EffectTypes)GC.getInfoTypeForString("EFFECT_ICBM_NUCLEAR_EXPLOSION"), pPlot->getPoint(), 0);
		gDLL->getInterfaceIFace()->playGeneralSound("AS2D_NUKE_EXPLODES", pPlot->getPoint());
	}
	pPlot->nukeExplosion(1);
	return true;
}


bool CvUnit::canClaimTerritory(const CvPlot* pPlot) const
{
	if (!GET_PLAYER(getOwner()).hasFixedBorders())
	{
		return false;
	}

	if (isNPC() || m_pUnitInfo->isAlwaysHostile() || isHiddenNationality() || !m_pUnitInfo->isPillage())
	{
		return false;
	}

	if (pPlot != NULL)
	{
		if (getOwner() == pPlot->getOwner())
		{
			return false;
		}
		// if we or someone else (a friend) already claimed this plot in this turn
		if (pPlot->getClaimingOwner() != NO_PLAYER)
		{
			return false;
		}

		if (!pPlot->isPotentialCityWork())
		{
			return false;
		}

		if (pPlot->isCity() || pPlot->isCity(true) && !GET_TEAM(getTeam()).isAtWar(pPlot->getTeam()))
		{
			return false;
		}

		if (GC.getGame().getModderGameOption(MODDERGAMEOPTION_CANNOT_CLAIM_OCEAN) && pPlot->isWater())
		{
			return false;
		}

		/* plots adjacent to cities always belong to those cities' owners */
		if (pPlot->getAdjacentCity(pPlot->getOwner()) != NULL)
		{
			return false;
		}

		if (!pPlot->isOwned() || potentialWarAction(pPlot))
		{
			return true;
		}
		return false;
	}
	return true;
}

bool CvUnit::claimTerritory()
{
	//logging::logMsg("C2C.log", "%S claims territory from %S at (%d, %d)", GET_PLAYER(getOwner()).getCivilizationShortDescription(), GET_PLAYER(plot()->getOwner()).getCivilizationShortDescription(), getX(), getY());
	CvPlot* pPlot = plot();

	if (!canClaimTerritory(pPlot))
	{
		return false;
	}
	PlayerTypes pPlayerThatLostTerritory = NO_PLAYER;

	if (pPlot->isOwned())
	{
		pPlayerThatLostTerritory = pPlot->getOwner();
		TeamTypes tTeamThatLostTerritory = GET_PLAYER(pPlayerThatLostTerritory).getTeam();

		GET_TEAM(tTeamThatLostTerritory).changeWarWeariness(getTeam(), *pPlot, GC.getDefineINT("WW_PLOT_CAPTURED"));
		GET_TEAM(getTeam()).changeWarWeariness(tTeamThatLostTerritory, *pPlot, GC.getDefineINT("WW_CAPTURED_PLOT"));
		GET_TEAM(getTeam()).AI_changeWarSuccess(tTeamThatLostTerritory, GC.getDefineINT("WAR_SUCCESS_PLOT_CAPTURING"));
	}
	pPlot->setClaimingOwner(getOwner());

	if (pPlayerThatLostTerritory != NO_PLAYER)
	{
		CvWString szBuffer;
		CvCity *pNearestCity = GC.getMap().findCity(pPlot->getX(), pPlot->getY(), pPlayerThatLostTerritory, NO_TEAM, false);

		if (pNearestCity != NULL)
		{
			szBuffer = gDLL->getText("TXT_KEY_MISSION_CLAIM_TERRITORY_CIV_SUCCESS_NEAR", GET_PLAYER(getOwner()).getCivilizationAdjectiveKey(), pNearestCity->getName().GetCString());
		}
		else
		{
			szBuffer = gDLL->getText("TXT_KEY_MISSION_CLAIM_TERRITORY_CIV_SUCCESS", GET_PLAYER(getOwner()).getCivilizationAdjectiveKey());
		}
		AddDLLMessage(pPlayerThatLostTerritory, true, GC.getEVENT_MESSAGE_TIME(), szBuffer, GC.getEraInfo(GC.getGame().getCurrentEra()).getAudioUnitDefeatScript(), MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_RED(), pPlot->getX(), pPlot->getY());
	}
	finishMoves();

	return true;
}

int CvUnit::surroundedDefenseModifier(const CvPlot *pPlot, const CvUnit *pDefender) const
{
	if (!GC.getGame().isOption(GAMEOPTION_SAD))
	{
		return 0;
	}
	const DirectionTypes dtDirectionAttacker = directionXY(pPlot, plot());
	int iExtraModifier = 0;
	//TB Combat Mods Begin (Enclose)
	int iEnclose = 0;
	//TB Combat Mods End

	for (int iI = 0; iI < NUM_DIRECTION_TYPES; iI++)
	{
		if (iI != dtDirectionAttacker)
		{
			CvPlot* pLoopPlot = plotDirection(pPlot->getX(), pPlot->getY(), static_cast<DirectionTypes>(iI));

			if (pLoopPlot != NULL && pLoopPlot->isWater() == pPlot->isWater())
			{
				CvUnit* pBestUnit = NULL;
				int iBestCurrCombatStr = 0;
				int iLowestCurrCombatStr = INT_MAX;

				foreach_(CvUnit* pLoopUnit, pLoopPlot->units())
				{
					if (pLoopUnit->getTeam() == getTeam())
					{
						//TB Combat Mods (Enclose) Begin
						iEnclose += pLoopUnit->encloseTotal();

						// if pDefender == null - use the last config of maxCombatStr() where pAttacker == this, else - use the pDefender to find the best attacker
						if (pDefender != NULL)
						{
							//TB Combat Mods Begin
							// pPlot == NULL -> defender gets no plot defense bonuses (hills, forest, fortify, etc.) against surrounding units (will have them for the attacker)
							const int iTmpCurrCombatStrOnly = pDefender->currCombatStr(NULL, pLoopUnit, NULL, false);
							const int iTmpCurrCombatStr = std::max(1, iTmpCurrCombatStrOnly - iTmpCurrCombatStrOnly * pLoopUnit->unnerveTotal() / 100);
							//TB Combat Mods End

							if (iTmpCurrCombatStr < iLowestCurrCombatStr)
							{
								iLowestCurrCombatStr = iTmpCurrCombatStr;
								pBestUnit = pLoopUnit;
							}
						}
						else
						{
							//TB Combat Mods begin
							const int iTmpCurrCombatStrOnly = pLoopUnit->currCombatStr(pPlot, pLoopUnit, NULL, false);
							const int iTmpCurrCombatStr = iTmpCurrCombatStrOnly + iTmpCurrCombatStrOnly * pLoopUnit->unnerveTotal() / 100;
							//TB Combat Mods end

							if (iTmpCurrCombatStr > iBestCurrCombatStr)
							{
								iBestCurrCombatStr = iTmpCurrCombatStr;
								pBestUnit = pLoopUnit;
							}
						}
					}
				}

				double fAttDeffFactor = 0.0;
				if (pDefender != NULL)
				{
					if (pBestUnit != NULL)
					{
						//TB Combat Mods (unnerve)... actually, I don't think I need this due to the adjustment to iLowestCurrCombatStr above...
						fAttDeffFactor = ((double) pBestUnit->currCombatStr(pPlot, pBestUnit, NULL, false));
						//double fUnnerve = (double) pBestUnit->unnerveTotal();
						//double fUnnerveModifier = ((fUnnerve * fAttDeffFactor) /100.0f);
						//fAttDeffFactor += fUnnerveModifier;
						fAttDeffFactor /= iLowestCurrCombatStr;
						//TB Combat Mods (unnerve end)
					}
				}
				else
				{
					fAttDeffFactor = (double) iBestCurrCombatStr;
				}
				if (fAttDeffFactor != 0)
				{
					/* surrounding distance = 1, 2, 3 or 4; the bigger the better */
					double fSurroundingDistanceFactor;

					switch (abs(std::min(abs(iI - dtDirectionAttacker), abs(abs(iI - dtDirectionAttacker) - 8))))
					{
						case 1:
							fSurroundingDistanceFactor = GC.getSAD_FACTOR_1();
							break;
						case 2:
							fSurroundingDistanceFactor = GC.getSAD_FACTOR_2();
							break;
						case 3:
							fSurroundingDistanceFactor = GC.getSAD_FACTOR_3();
							break;
						case 4:
							fSurroundingDistanceFactor = GC.getSAD_FACTOR_4();
							break;
						default:
							fSurroundingDistanceFactor = GC.getSAD_FACTOR_1();
							break;
					}
					if (fAttDeffFactor == 1)
					{
						iExtraModifier += int(fSurroundingDistanceFactor);
					}
					else
					{
						iExtraModifier += int(fSurroundingDistanceFactor * ((fAttDeffFactor - 1) * pow(abs(fAttDeffFactor - 1), -0.75) + 1));
					}
				}
			}
		}
	}
	//TB Combat Mods Begin (SAD mods)
	const int iSurroundModifier = std::min(GC.getSAD_MAX_MODIFIER() + iEnclose, iExtraModifier);

	return iSurroundModifier + iSurroundModifier * lungeTotal() / 100;
	//TB Combat Mods End (SAD mods)
}


bool CvUnit::isCanMovePeaks() const
{
	return m_iCanMovePeaksCount > 0;
}

void CvUnit::changeCanMovePeaksCount(int iChange)
{
	m_iCanMovePeaksCount += iChange;
	FASSERT_NOT_NEGATIVE(m_iCanMovePeaksCount);
}

// Koshling - enhanced mountaineering mode to differentiate between ability to move through
//	mountains, and ability to lead a stack through mountains
bool CvUnit::isCanLeadThroughPeaks() const
{
	return m_iCanLeadThroughPeaksCount > 0;
}

void CvUnit::changeCanLeadThroughPeaksCount(int iChange)
{
	m_iCanLeadThroughPeaksCount += iChange;
	FASSERT_NOT_NEGATIVE(m_iCanLeadThroughPeaksCount);
}


int CvUnit::getMaxHurryFood() const
{
	return std::max(0, m_pUnitInfo->getBaseFoodChange() * GC.getGameSpeedInfo(GC.getGame().getGameSpeedType()).getHammerCostPercent() / 100);
}

int CvUnit::getHurryFood(const CvPlot* pPlot) const
{
	const CvCity* pCity = pPlot->getPlotCity();
	if (pCity == NULL) return 0;

	return std::max(0, std::min(pCity->growthThreshold() - pCity->getFood(), getMaxHurryFood()));
}

bool CvUnit::canHurryFood(const CvPlot* pPlot) const
{
	if (isDelayedDeath() || getHurryFood(pPlot) == 0)
	{
		return false;
	}

	const CvCity* pCity = pPlot->getPlotCity();
	if (pCity == NULL || pCity->getOwner() != getOwner() || pCity->getFoodTurnsLeft() == 1)
	{
		return false;
	}
	return true;
}


bool CvUnit::hurryFood()
{
	if (!canHurryFood(plot()))
	{
		return false;
	}

	CvCity* pCity = plot()->getPlotCity();

	if (pCity != NULL)
	{
		pCity->changeFood(getHurryFood(plot()));
	}

	if (plot()->isActiveVisible(false))
	{
		NotifyEntity(MISSION_HURRY_FOOD);
	}

	kill(true, NO_PLAYER, true);

	return true;
}

bool CvUnit::sleepForEspionage()
{
	if (!canSleep() || !canEspionage(plot(), true))
	{
		return false;
	}

	if (getFortifyTurns() == GC.getMAX_FORTIFY_TURNS())
	{
		return false;
	}

	getGroup()->setActivityType(ACTIVITY_SLEEP);

	m_iSleepTimer = 1;

	return true;
}

CvUnit* CvUnit::getCommander() const
{
	PROFILE_FUNC();

	// This routine gets called a HUGE number of times per turn (100s of millions in large games!)
	//	so short-circuit the most common case of the unit having no commander when we can
	//	Similarly protect against calls during initialization of a unit (before it has a plot set)
	if (m_iCachedCommander == NO_COMMANDER_ID || plot() == NULL)
	{
		return NULL;
	}
	CvUnit* pBestCommander = getUsedCommander();

	if (pBestCommander != NULL) //return already used one if it is not dead.
	{
		// Recently destroyed commanders could cause a crash here without this protection.
		if (pBestCommander->plot() != NULL && pBestCommander->controlPointsLeft() > 0
		&& plotDistance(pBestCommander->getX(), pBestCommander->getY(), getX(), getY()) <= pBestCommander->commandRange())
		{
			return pBestCommander;
		}
		// The one we used would have been the cached one so will have to search again
		pBestCommander = NULL;
		m_iCommanderCacheTurn = -1;
	}

	if (m_iCommanderCacheTurn == GC.getGame().getGameTurn())
	{
		pBestCommander = GET_PLAYER(getOwner()).getUnit(m_iCachedCommander);
		if (pBestCommander != NULL)
		{
			// Guard against this being called during the death of said GC!
			if (pBestCommander->plot() != NULL && pBestCommander->controlPointsLeft() > 0
			&& plotDistance(pBestCommander->getX(), pBestCommander->getY(), getX(), getY()) <= pBestCommander->commandRange())
			{
				return pBestCommander;
			}
			pBestCommander = NULL;
		}
	}

	int iBestCommanderDistance = 9999999;
	if (getOwner() != NO_PLAYER)
	{
		const CvPlayer& kPlayer = GET_PLAYER(getOwner());

		for (int i=0; i < (int)kPlayer.Commanders.size(); i++)		//loop through player's commanders
		{
			CvUnit* pCommander = kPlayer.Commanders[i];

			if (pCommander->controlPointsLeft() <= 0)
			{
				continue;
			}
			const CvPlot* pCommPlot = pCommander->plot();

			if (pCommPlot == NULL)
			{
				FErrorMsg("Commander Should Exist!");
				continue;
			}
			const int iDistance = plotDistance(pCommPlot->getX(), pCommPlot->getY(), getX(), getY());

			if (iDistance > pCommander->commandRange())
			{
				continue;
			}
			if (pBestCommander == NULL
			// Best commander is at shorter distance, or at same distance but has more XP:
			|| (iBestCommanderDistance < iDistance || iBestCommanderDistance == iDistance && pCommander->getExperience() > pBestCommander->getExperience()))
			{
				pBestCommander = pCommander;
				iBestCommanderDistance = iDistance;
			}
		}
	}

	//	Don't cache the human player because they may make abortive odds calculations
	//	that lock a unit to a commander via the caching, and then not execute the attack that
	//	gave rise to the odds calculation

	//Perhaps do not cache commanders because it causes an OOS error to do so?  AIs make abortive odds calcs as well do they not?
	if (!isHuman() && !GC.getGame().isMPOption(MPOPTION_SIMULTANEOUS_TURNS))
	{
		m_iCommanderCacheTurn = GC.getGame().getGameTurn();
		m_iCachedCommander = (pBestCommander == NULL ? NO_COMMANDER_ID : pBestCommander->getID());
	}
	return pBestCommander;
}

void CvUnit::tryUseCommander()
{
	CvUnit* pCommander = getUsedCommander();

	if ( pCommander == NULL || pCommander->controlPointsLeft() <= 0 )
	{
		pCommander = getCommander();
	}

	if (pCommander != NULL) //commander is used when any unit under his command fights in combat
	{
		pCommander->m_commander->changeControlPointsLeft(-1);
		m_iCommanderID = pCommander->getID();

		if (pCommander->m_commander->getControlPointsLeft() <= 0)
		{
			FlushCombatStrCache(NULL);
		}
	}
}

bool CvUnit::isCommander() const
{
	return m_commander != NULL;
}

/* Toffer - May need this one at some point... maybe
UnitCompCommander* CvUnit::getCommanderComp() const
{
	return m_commander;
}
*/

void CvUnit::setCommander(bool bNewVal)
{
	if (isCommander() == bNewVal) return;

	if (bNewVal)
	{
		m_commander = new UnitCompCommander(m_pUnitInfo);

		GET_PLAYER(getOwner()).Commanders.push_back(this);

		foreach_(const UnitCombatTypes eSubCombat, m_pUnitInfo->getSubCombatTypes())
		{
			if (GC.getUnitCombatInfo(eSubCombat).getQualityBase() > -10)
			{
				setHasUnitCombat(eSubCombat, false);
			}
		}
	}
	else
	{
		delete m_commander;
		m_commander = NULL;
	}
}

void CvUnit::nullUsedCommander()
{
	m_iCommanderID = -1;
}

CvUnit* CvUnit::getUsedCommander() const
{
	return (m_iCommanderID == -1 ? NULL : GET_PLAYER(getOwner()).getUnit(m_iCommanderID));
}

void CvUnit::clearCommanderCache()
{
	m_iCachedCommander = GC.getGame().isOption(GAMEOPTION_GREAT_COMMANDERS) ? -1 : NO_COMMANDER_ID;
}

int CvUnit::controlPoints() const
{
	return m_commander != NULL ? m_commander->getControlPoints() : 0;
}

int CvUnit::controlPointsLeft() const
{
	return m_commander != NULL ? m_commander->getControlPointsLeft() : 0;
}

int CvUnit::commandRange() const
{
	return m_commander != NULL ? m_commander->getCommandRange() : 0;
}

int CvUnit::interceptionChance(const CvPlot* pPlot) const
{
	int iNoInterceptionChanceTimes100 = 10000;

	for (int iI = 0; iI < MAX_PLAYERS; iI++)
	{
		if (GET_PLAYER((PlayerTypes)iI).isAlive() && !isInvisible(GET_PLAYER((PlayerTypes)iI).getTeam(), false, false))
		{
			foreach_(const CvUnit* pLoopUnit, GET_PLAYER((PlayerTypes)iI).units())
			{
				if (pLoopUnit->canAirDefend() && !pLoopUnit->isMadeInterception() && isEnemy(pLoopUnit->getTeam(), NULL, pLoopUnit)
				&& (pLoopUnit->getDomainType() != DOMAIN_AIR || !pLoopUnit->hasMoved() && pLoopUnit->getGroup()->getActivityType() == ACTIVITY_INTERCEPT)
				&& plotDistance(pLoopUnit->getX(), pLoopUnit->getY(), pPlot->getX(), pPlot->getY()) <= pLoopUnit->airRange())
				{
					const int iValue = pLoopUnit->currInterceptionProbability();

					if (iValue > 0)
					{
						if (iValue > 99) return 100;

						iNoInterceptionChanceTimes100 *= 100 - iValue;
						iNoInterceptionChanceTimes100 /= 100;
						if (iNoInterceptionChanceTimes100 < 100)
						{
							return 100;
						}
					}
				}
			}
		}
	}
	return 100 - iNoInterceptionChanceTimes100 / 100;
}

PlayerTypes CvUnit::getOriginalOwner() const
{
	return m_eOriginalOwner;
}

void CvUnit::doBattleFieldPromotions(CvUnit* pDefender, const CombatDetails& cdDefenderDetails, const CvPlot* pPlot, bool bAttackerHasLostNoHP, bool bAttackerWithdrawn, int iAttackerInitialDamage, int iWinningOdds, int iInitialAttXP, int iInitialAttGGXP, int iDefenderInitialDamage, int iInitialDefXP, int iInitialDefGGXP, bool& bAttackerPromoted, bool& bDefenderPromoted, int iNonLethalAttackWinChance, int iNonLethalDefenseWinChance, int iDefenderFirstStrikes, int iAttackerFirstStrikes)
{
	if (!GC.getGame().getModderGameOption(MODDERGAMEOPTION_BATTLEFIELD_PROMOTIONS) ||
		getUnitCombatType() == NO_UNITCOMBAT || pDefender->getUnitCombatType() == NO_UNITCOMBAT)
	{
		return;
	}

	bool bNoDefBon = noDefensiveBonus();
	std::vector<PromotionTypes> aAttackerAvailablePromotions;
	std::vector<PromotionTypes> aDefenderAvailablePromotions;
	for (int iI = 0; iI < GC.getNumPromotionInfos(); iI++)
	{
		const PromotionTypes promotionType = static_cast<PromotionTypes>(iI);
		const CvPromotionInfo& kPromotion = GC.getPromotionInfo(promotionType);
		/* Block These Promotions */
		if (kPromotion.getKamikazePercent() > 0 ||
			kPromotion.isLeader() ||
			kPromotion.hasNegativeEffects())
		{
			continue;
		}

		//TB Combat Mods Begin
		if (pDefender->isDead() || m_combatResult.bDefenderKnockedBack)
		{
			if (!canAcquirePromotion(promotionType)) //attacker can not acquire this promotion
			{
				continue;
			}
			//* attacker may receive pursuit
			if (m_combatResult.bDefenderWithdrawn && kPromotion.getPursuitChange() > 0)
			{
				aAttackerAvailablePromotions.push_back(promotionType);
			}
			if (m_combatResult.bDefenderPursued && kPromotion.getPursuitChange() > 0)
			{
				aAttackerAvailablePromotions.push_back(promotionType);
			}
			//* attacker was attacking a fortified defender and may receive Overrun
			if (cdDefenderDetails.iFortifyModifier > 0 && kPromotion.getOverrunChange() > 0)
			{
				aAttackerAvailablePromotions.push_back(promotionType);
			}
			//* attacker was unyielding against a Repel
			if (!bNoDefBon)
			{
				if (m_combatResult.bAttackerRefusedtoYield && kPromotion.getUnyieldingChange() > 0)
				{
					aAttackerAvailablePromotions.push_back(promotionType);
				}
			}
			//* attacker Knocked back defender
			if (m_combatResult.bDefenderKnockedBack && kPromotion.getKnockbackChange() > 0)
			{
				aAttackerAvailablePromotions.push_back(promotionType);
			}
			//* attacker was attacking with S&D bonus
			if (kPromotion.getLungeChange() > 0 && surroundedDefenseModifier(pPlot, pDefender) != 0)
			{
				aAttackerAvailablePromotions.push_back(promotionType);
			}
			//* attacker had less dodge than defender's precision
			if (kPromotion.getDodgeModifierChange() > 0 && (dodgeVSOpponentProbTotal(pDefender) < pDefender->precisionVSOpponentProbTotal(this)))
			{
				aAttackerAvailablePromotions.push_back(promotionType);
			}
			//* defender had more dodge than attacker's precision
			if (kPromotion.getPrecisionModifierChange() > 0 && (pDefender->dodgeVSOpponentProbTotal(this) > precisionVSOpponentProbTotal(pDefender)))
			{
				aAttackerAvailablePromotions.push_back(promotionType);
			}
			//* attacker is developing critical chance
			if (kPromotion.getCriticalModifierChange() > 0 && (criticalVSOpponentProbTotal(pDefender) > 0))
			{
				aAttackerAvailablePromotions.push_back(promotionType);
			}
			//* attacker is developing endurance
			if (kPromotion.getEnduranceChange() > 0 && (enduranceTotal() > 0))
			{
				aAttackerAvailablePromotions.push_back(promotionType);
			}
			//TB Combat Mods End
			//* attacker was crossing river
			if (kPromotion.isRiver() && cdDefenderDetails.iRiverAttackModifier != 0)	//this bonus is being applied to defender
			{
				aAttackerAvailablePromotions.push_back(promotionType);
			}
			//* attack from water
			if (kPromotion.isAmphib() && cdDefenderDetails.iAmphibAttackModifier != 0)
			{
				aAttackerAvailablePromotions.push_back(promotionType);
			}
			//* attack terrain
			if (kPromotion.getTerrainAttackPercent((int)pPlot->getTerrainType()) > 0)
			{
				aAttackerAvailablePromotions.push_back(promotionType);
			}
			//* attack feature
			if (pPlot->getFeatureType() != NO_FEATURE &&
				kPromotion.getFeatureAttackPercent((int)pPlot->getFeatureType()) > 0)
			{
				aAttackerAvailablePromotions.push_back(promotionType);
			}
			//* attack hills
			if (kPromotion.getHillsAttackPercent() > 0 && pPlot->isHills())
			{
				aAttackerAvailablePromotions.push_back(promotionType);
			}
			//* attack city
			if (kPromotion.getCityAttackPercent() > 0 && pPlot->isCity(true))	//count forts too
			{
				aAttackerAvailablePromotions.push_back(promotionType);
			}
			//* first strikes/chanses promotions
			if ((kPromotion.getFirstStrikesChange() > 0 ||
				kPromotion.getChanceFirstStrikesChange() > 0) && (firstStrikes() > 0 || chanceFirstStrikes() > 0))
			{
				aAttackerAvailablePromotions.push_back(promotionType);
			}
			//* unit combat mod
			if (kPromotion.getUnitCombatModifierPercent((int)pDefender->getUnitCombatType()) > 0)
			{
				aAttackerAvailablePromotions.push_back(promotionType);
			}
			//TB Combat Mods Begin * anti-barbarian combat mod
			if (kPromotion.getVSBarbsChange() > 0 && (pDefender->isHominid()))
			{
				aAttackerAvailablePromotions.push_back(promotionType);
			}
			if (kPromotion.getStrengthChange() > 0)
			{
				aAttackerAvailablePromotions.push_back(promotionType);
			}
			if (kPromotion.getAttackCombatModifierChange() > 0)
			{
				aAttackerAvailablePromotions.push_back(promotionType);
			}
			//TB Combat Mods End
			//* combat strength promotions
			if (kPromotion.getCombatPercent() > 0 && !kPromotion.isAmphib())
			{
				aAttackerAvailablePromotions.push_back(promotionType);
			}
			//* domain mod
			if (kPromotion.getDomainModifierPercent((int)pDefender->getDomainType()))
			{
				aAttackerAvailablePromotions.push_back(promotionType);
			}
			//* blitz
			if (kPromotion.isBlitz() && bAttackerHasLostNoHP)
			{
				aAttackerAvailablePromotions.push_back(promotionType);
			}
		}	//if defender is dead or withdrawn
		//* defender withdrawn, give him withdrawal promo
		else if (m_combatResult.bDefenderWithdrawn)
		{
			if (kPromotion.getWithdrawalChange() > 0 &&
				pDefender->canAcquirePromotion(promotionType))
			{
				aDefenderAvailablePromotions.push_back(promotionType);
			}
		}
		//* attacker withdrawn
		else if (bAttackerWithdrawn)
		{
			if (kPromotion.getWithdrawalChange() > 0 &&
				canAcquirePromotion(promotionType))
			{
				aAttackerAvailablePromotions.push_back(promotionType);
			}
			if (kPromotion.getPursuitChange() > 0 &&
				pDefender->canAcquirePromotion(promotionType))
			{
				aDefenderAvailablePromotions.push_back(promotionType);
			}
		}
		//* attacker is presumably dead
		else
		{
			FAssertMsg(isDead(), "Attacker is expected to be dead");
			if (!pDefender->canAcquirePromotion(promotionType))
			{
				continue;
			}
			//TB Combat Mods Begin
				//* Defender may recieve pursuit
			if (m_combatResult.bAttackerPursued && kPromotion.getPursuitChange() > 0)
			{
				aDefenderAvailablePromotions.push_back(promotionType);
			}
			//* Defender Repelled Attacker
			if (!bNoDefBon)
			{
				if (m_combatResult.bAttackerRepelled && kPromotion.getRepelChange() > 0)
				{
					aDefenderAvailablePromotions.push_back(promotionType);
				}
				//* Defender Repelled Attacker while Fortified
				if (m_combatResult.bAttackerRepelled && cdDefenderDetails.iFortifyModifier > 0 && kPromotion.getFortRepelChange() > 0)
				{
					aDefenderAvailablePromotions.push_back(promotionType);
				}
			}
			//* Defender Refused to be Knocked Back
			if (m_combatResult.bDefenderRefusedtoYield && kPromotion.getUnyieldingChange() > 0)
			{
				aDefenderAvailablePromotions.push_back(promotionType);
			}
			//* Defender Suffered Surround and Destroy Modifier
			if (kPromotion.getDynamicDefenseChange() > 0 && surroundedDefenseModifier(pPlot, pDefender) != 0)
			{
				aDefenderAvailablePromotions.push_back(promotionType);
			}
			if (kPromotion.getStrengthChange() > 0)
			{
				aDefenderAvailablePromotions.push_back(promotionType);
			}
			if (kPromotion.getAnimalIgnoresBordersChange() > 0 && pDefender->isAnimal() && !GC.getGame().isOption(GAMEOPTION_ANIMALS_STAY_OUT))
			{
				aDefenderAvailablePromotions.push_back(promotionType);
			}
			//TB Combat Mods End
			//* defend terrain
			if (!noDefensiveBonus() && (kPromotion.getTerrainDefensePercent((int)pPlot->getTerrainType()) > 0))
			{
				aDefenderAvailablePromotions.push_back(promotionType);
			}
			//* defend feature
			if (!noDefensiveBonus() && (pPlot->getFeatureType() != NO_FEATURE &&
				kPromotion.getFeatureDefensePercent((int)pPlot->getFeatureType()) > 0))
			{
				aDefenderAvailablePromotions.push_back(promotionType);
			}
			//* defend hills
			if (!noDefensiveBonus() && (kPromotion.getHillsDefensePercent() > 0 && pPlot->isHills()))
			{
				aDefenderAvailablePromotions.push_back(promotionType);
			}
			//* defend city
			if (!noDefensiveBonus() && kPromotion.getCityDefensePercent() > 0 && pPlot->isCity(true))	//count forts too
			{
				aDefenderAvailablePromotions.push_back(promotionType);
			}
			//* first strikes/chanses promotions
			if ((kPromotion.getFirstStrikesChange() > 0 ||
				kPromotion.getChanceFirstStrikesChange() > 0) &&
				(pDefender->firstStrikes() > 0 || pDefender->chanceFirstStrikes() > 0))
			{
				aDefenderAvailablePromotions.push_back(promotionType);
			}
			//* unit combat mod vs attacker unit type
			if (kPromotion.getUnitCombatModifierPercent((int)getUnitCombatType()) > 0)
			{
				aDefenderAvailablePromotions.push_back(promotionType);
			}
			//TB Combat Mods Begin * anti-barbarian combat mod
			if (kPromotion.getVSBarbsChange() > 0 && isHominid())
			{
				aDefenderAvailablePromotions.push_back(promotionType);
			}

			if (!noDefensiveBonus() && kPromotion.getDefenseCombatModifierChange() > 0)
			{
				aDefenderAvailablePromotions.push_back(promotionType);
			}
			//* defemder had less dodge than attacker's precision
			if (kPromotion.getDodgeModifierChange() > 0 && (pDefender->dodgeVSOpponentProbTotal(this) < precisionVSOpponentProbTotal(pDefender)))
			{
				aDefenderAvailablePromotions.push_back(promotionType);
			}
			//* attacker had more dodge than defender's precision
			if (kPromotion.getPrecisionModifierChange() > 0 && (dodgeVSOpponentProbTotal(pDefender) > pDefender->precisionVSOpponentProbTotal(this)))
			{
				aDefenderAvailablePromotions.push_back(promotionType);
			}
			//* defender is developing critical chance
			if (kPromotion.getCriticalModifierChange() > 0 && (pDefender->criticalVSOpponentProbTotal(this) > 0))
			{
				aDefenderAvailablePromotions.push_back(promotionType);
			}
			//* defender is developing endurance
			if (kPromotion.getEnduranceChange() > 0 && (pDefender->enduranceTotal() > 0))
			{
				aDefenderAvailablePromotions.push_back(promotionType);
			}
			//TB Combat Mods End
			//* combat strength promotions
			if (kPromotion.getCombatPercent() > 0)
			{
				aDefenderAvailablePromotions.push_back(promotionType);
			}
			//* domain mod
			if (kPromotion.getDomainModifierPercent((int)getDomainType()))
			{
				aDefenderAvailablePromotions.push_back(promotionType);
			}
		}	//if attacker withdrawn
	}	//end promotion types cycle

	//promote attacker:
	if (!isDead() && aAttackerAvailablePromotions.size() > 0)
	{
		FAssertMsg(getMaxHP() - iAttackerInitialDamage > 0, "Attacker is Dead!");
		int iHealthPercent = (getMaxHP() - getDamage()) * 100 / std::max(1, getMaxHP() - iAttackerInitialDamage);
		iNonLethalAttackWinChance *= 10;
		int iOdds = std::max(iWinningOdds, iNonLethalAttackWinChance);
		int iPromotionChance = (GC.getCOMBAT_DIE_SIDES() - iOdds)/* * (100 + iPromotionChanceModifier) / 100*/;

		int iFirstStrikes = 1 + iAttackerFirstStrikes;
		iFirstStrikes = std::max(1, iFirstStrikes);

		iPromotionChance /= iFirstStrikes;
		if (GC.getGame().getSorenRandNum(GC.getCOMBAT_DIE_SIDES(), "Occasional Promotion") < iPromotionChance)
		{
			//select random promotion from available
			PromotionTypes ptPromotion = aAttackerAvailablePromotions[
				GC.getGame().getSorenRandNum(aAttackerAvailablePromotions.size(), "Select Promotion Type")];
			//promote
			//TB Combat Mod next line
			setHasPromotion(ptPromotion, true, false);
			bAttackerPromoted = true;

			setExperience100(iInitialAttXP);
			GET_PLAYER(getOwner()).setCombatExperience(iInitialAttGGXP, getGGExperienceEarnedTowardsType());

			// Great Commander XP
			if (getUsedCommander() != NULL)
			{
				getUsedCommander()->setExperience100(getUsedCommander()->getExperience100() + 100);
			}
			//show message
			{

				const CvWString szBuffer = gDLL->getText("TXT_KEY_MISC_YOUR_UNIT_PROMOTED_IN_BATTLE", getNameKey(), GC.getPromotionInfo(ptPromotion).getText());
				AddDLLMessage(
					getOwner(), false, GC.getEVENT_MESSAGE_TIME(), szBuffer,
					GC.getPromotionInfo((PromotionTypes)0).getSound(), MESSAGE_TYPE_INFO, NULL,
					GC.getCOLOR_GREEN(), getX(), getY()
				);
			}
		}
	}

	//promote defender:
	if (!pDefender->isDead() && aDefenderAvailablePromotions.size() > 0)
	{
		FAssertMsg(pDefender->getMaxHP() - iDefenderInitialDamage > 0, "Defender is Dead!");
		int iHealthPercent = (pDefender->getMaxHP() - pDefender->getDamage()) * 100 / std::max(1, pDefender->getMaxHP() - iDefenderInitialDamage);
		iNonLethalDefenseWinChance *= 10;
		iNonLethalDefenseWinChance = std::max(0, (GC.getCOMBAT_DIE_SIDES() - iNonLethalDefenseWinChance));
		int iOdds = std::min(iWinningOdds, iNonLethalDefenseWinChance);
		int iPromotionChance = iOdds/* * (100 + iPromotionChanceModifier) / 100*/;
		int iFirstStrikes = 1 + iDefenderFirstStrikes;
		//change to stealth strikes if stealth combat
		iFirstStrikes = std::max(1, iFirstStrikes);
		iPromotionChance /= iFirstStrikes;
		if (GC.getGame().getSorenRandNum(GC.getCOMBAT_DIE_SIDES(), "Occasional Promotion") < iPromotionChance)
		{
			//select random promotion from available
			PromotionTypes ptPromotion = aDefenderAvailablePromotions[
				GC.getGame().getSorenRandNum(aDefenderAvailablePromotions.size(), "Select Promotion Type")];
			//promote
			//TB Combat Mod next line
			pDefender->setHasPromotion(ptPromotion, true, false);

			pDefender->setExperience100(iInitialDefXP);
			GET_PLAYER(pDefender->getOwner()).setCombatExperience(iInitialDefGGXP, pDefender->getGGExperienceEarnedTowardsType());
			bDefenderPromoted = true;

			// Great Commander XP
			if (pDefender->getUsedCommander() != NULL)
			{
				pDefender->getUsedCommander()->setExperience100(pDefender->getUsedCommander()->getExperience100() + 100);
			}
			//show message
			{

				CvWString szBuffer = gDLL->getText("TXT_KEY_MISC_YOUR_UNIT_PROMOTED_IN_BATTLE", pDefender->getNameKey(),
					GC.getPromotionInfo(ptPromotion).getText());
				AddDLLMessage(
					pDefender->getOwner(), false, GC.getEVENT_MESSAGE_TIME(), szBuffer,
					GC.getPromotionInfo((PromotionTypes)0).getSound(), MESSAGE_TYPE_INFO, NULL,
					GC.getCOLOR_GREEN(), pPlot->getX(), pPlot->getY());
			}
		}
	}
}
void CvUnit::doDynamicXP(CvUnit* pDefender, const CvPlot* pPlot, int iAttackerInitialDamage, int iWinningOdds, int iDefenderInitialDamage, int iInitialAttXP, int iInitialDefXP, int iInitialAttGGXP, int iInitialDefGGXP, bool bPromotion, bool bDefPromotion)
{
	if (GC.getGame().isModderGameOption(MODDERGAMEOPTION_IMPROVED_XP))
	{
		if (!isDead() && !bPromotion && getUnitCombatType() != NO_UNITCOMBAT)
		{
			//reset XP
			setExperience100(iInitialAttXP);

			FAssertMsg(getMaxHP() - iAttackerInitialDamage > 0, "Attacker is Dead!");
			int iHealthPercentLost = 100 - (getMaxHP() - getDamage()) * 100 / std::max(1, getMaxHP() - iAttackerInitialDamage);
			int iExperienceModifier = iHealthPercentLost * iHealthPercentLost / getMaxHP();
			//Chance of losing
			int iOdds = GC.getCOMBAT_DIE_SIDES() - iWinningOdds;
			int iExperience = iOdds * (100 + iExperienceModifier) / 100;

			if (attackXPValue() > 0)
			{
				iExperience = range(iExperience, getRandomMinExperienceTimes100(), attackXPValue() * 100);
				changeExperience100(iExperience, maxXPValue(pDefender), true, pPlot->getOwner() == getOwner(), true);
			}
		}
		if (!pDefender->isDead() && !bDefPromotion && pDefender->getUnitCombatType() != NO_UNITCOMBAT)
		{
			//reset XP
			pDefender->setExperience100(iInitialDefXP);

			FAssertMsg(pDefender->getMaxHP() - iDefenderInitialDamage > 0, "Defender is Dead!");
			int iHealthPercentLost = 100 - (pDefender->getMaxHP() - pDefender->getDamage()) * 100 / std::max(1,(pDefender->getMaxHP() - iDefenderInitialDamage));
			int iExperienceModifier = iHealthPercentLost * iHealthPercentLost / pDefender->getMaxHP();
			//Chance of Losing
			int iExperience = iWinningOdds * (100 + iExperienceModifier) / 100;

			if (pDefender->defenseXPValue() > 0)
			{
				iExperience = range(iExperience, getRandomMinExperienceTimes100(), pDefender->defenseXPValue() * 100);
				pDefender->changeExperience100(iExperience, pDefender->maxXPValue(this), true, pPlot->getOwner() == pDefender->getOwner(), true);
			}
		}
	}
}

int CvUnit::getRandomMinExperienceTimes100() const
{
	return GC.getGame().getSorenRandNum(26, "Random Min XP") + (GC.getMIN_EXPERIENCE_PER_COMBAT() * 25);
}

bool CvUnit::isTerrainProtected(TerrainTypes eIndex) const
{
	FASSERT_BOUNDS(0, GC.getNumTerrainInfos(), eIndex);
	return getTerrainProtectedCount(eIndex) > 0;
}

int CvUnit::getTerrainProtectedCount(TerrainTypes eIndex, bool bIgnoreCommanders) const
{
	FASSERT_BOUNDS(0, GC.getNumTerrainInfos(), eIndex);

	const TerrainKeyedInfo* info = findTerrainKeyedInfo(eIndex);

	int iTotal = info != NULL ? info->m_iTerrainProtected : 0;

	if (!bIgnoreCommanders && !isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander != NULL)
		{
			iTotal += pCommander->getTerrainProtectedCount(eIndex);
		}
	}

	return iTotal;
}


void CvUnit::changeTerrainProtected(TerrainTypes eIndex, int iChange)
{
	FASSERT_BOUNDS(0, GC.getNumTerrainInfos(), eIndex);

	if (iChange != 0)
	{
		TerrainKeyedInfo* info = findOrCreateTerrainKeyedInfo(eIndex);

		info->m_iTerrainProtected += iChange;
	}
}


int CvUnit::getZoneOfControlCount() const
{
	return m_iZoneOfControlCount;
}

bool CvUnit::isZoneOfControl() const
{
	return (getZoneOfControlCount() > 0);
}

void CvUnit::changeZoneOfControlCount(int iChange)
{
	m_iZoneOfControlCount += iChange;
	if (isZoneOfControl())
	{
		GC.getGame().toggleAnyoneHasUnitZoneOfControl();
	}
	//TB Combat Mod Debug
	FASSERT_NOT_NEGATIVE(getZoneOfControlCount());
}

bool CvUnit::isAutoPromoting() const
{
	return m_bAutoPromoting;
}
void CvUnit::setAutoPromoting(bool bNewValue)
{
	m_bAutoPromoting = bNewValue;
	if (bNewValue)
	{
		//Force recalculation
		setPromotionReady(false);
		testPromotionReady();
	}
}

bool CvUnit::isAutoUpgrading() const
{
	return m_bAutoUpgrading;
}

void CvUnit::setAutoUpgrading(bool bNewValue)
{
	m_bAutoUpgrading = bNewValue;
}


bool CvUnit::canShadow() const
{
	if (!canAttack())
	{
		return false;
	}

	if (GET_PLAYER(getOwner()).isModderOption(MODDEROPTION_HIDE_AUTO_PROTECT))
	{
		return false;
	}

	return true;
}

bool CvUnit::canShadowAt(const CvPlot* pShadowPlot, CvUnit* pShadowUnit) const
{
	if (!canShadow())
	{
		return false;
	}

	if (pShadowPlot == NULL)
	{
		return false;
	}

	if (pShadowUnit == NULL)
	{
		pShadowUnit = pShadowPlot->getCenterUnit();
	}

	if (pShadowUnit == NULL)
	{
		return false;
	}

	if (pShadowUnit->getTeam() != getTeam())
	{
		return false;
	}

	if (pShadowUnit->baseMoves() > baseMoves())
	{
		return false;
	}

	if (pShadowUnit == this)
	{
		return false;
	}

	int iPathTurns;
	if (!generatePath(pShadowPlot, 0, true, &iPathTurns))
	{
		return false;
	}

	return true;
}

CvUnit* CvUnit::getShadowUnit() const
{
	return getUnit(m_shadowUnit);
}


void CvUnit::setShadowUnit(const CvUnit* pUnit)
{
	if (pUnit != NULL)
	{
		m_shadowUnit = pUnit->getIDInfo();
	}
	else
	{
		m_shadowUnit.reset();
	}
}


void CvUnit::setDesiredDiscoveryTech(TechTypes eTech)
{
	m_eDesiredDiscoveryTech = eTech;

	getGroup()->setActivityType(ACTIVITY_SLEEP);
}

TechTypes CvUnit::getDesiredDiscoveryTech() const
{
	return m_eDesiredDiscoveryTech;
}

void CvUnit::waitForTech(int iFlag, int eTech)
{
	if (iFlag != GC.getNumTechInfos())
	{
		CvPopupInfo* pInfo = new CvPopupInfo(BUTTONPOPUP_SELECT_DISCOVERY_TECH, getID(), 0, 0);
		if (pInfo)
		{
			gDLL->getInterfaceIFace()->addPopup(pInfo, getOwner(), true);
		}
	}
	else
	{
		setDesiredDiscoveryTech((TechTypes)eTech);
	}
}

CvProperties* CvUnit::getProperties()
{
	return &m_Properties;
}

const CvProperties* CvUnit::getPropertiesConst() const
{
	return &m_Properties;
}

void CvUnit::addMission(const CvMissionDefinition& mission)
{
	if (mission.isValid())
	{
		gDLL->getEntityIFace()->AddMission(&mission);
	}
}

bool CvUnit::isArcher() const
{
	return isHasUnitCombat(GC.getUNITCOMBAT_ARCHER());
}

//TB Combat Mods begin
bool CvUnit::isPromotionOverriden(PromotionTypes ePromotionType) const
{
	if (isHasPromotion(ePromotionType))
	{
		for (int iI = 0; iI < GC.getNumPromotionInfos(); iI++)
		{
			const PromotionTypes ePromotion = ((PromotionTypes)iI);
			if (isHasPromotion(ePromotion))
			{
				if (GC.getPromotionInfo(ePromotionType).getPromotionLine() != NO_PROMOTIONLINE)
				{
					if (GC.getPromotionInfo(ePromotionType).getPromotionLine() == GC.getPromotionInfo(ePromotion).getPromotionLine())
					{
						if (GC.getPromotionInfo(ePromotionType).getLinePriority() < GC.getPromotionInfo(ePromotion).getLinePriority())
						{
							return true;
						}
					}
				}
			}
		}
	}
	return false;
}


#ifdef OUTBREAKS_AND_AFFLICTIONS
bool CvUnit::canCure(const CvPlot* pPlot, PromotionLineTypes eAfflictionLine) const
{
	if (!GC.getGame().isOption(GAMEOPTION_OUTBREAKS_AND_AFFLICTIONS))
	{
		return false;
	}

	if (hasCureAfflictionType(eAfflictionLine))
	{
		//Check our current tile
		foreach_(const CvUnit* pLoopUnit, pPlot->units())
		{
			if (pLoopUnit->getTeam() == getTeam())
			{
				if (pLoopUnit->hasAfflictionLine(eAfflictionLine))
				{
					return true;
				}
			}
		}
	}
	return false;
}

bool CvUnit::CureAffliction(PromotionLineTypes eAfflictionLine)
{
	const CvPlot* pPlot = plot();

	if (!canCure(pPlot, eAfflictionLine))
	{
		return false;
	}

	//Check our current tile
	foreach_(CvUnit* pLoopUnit, pPlot->units())
	{
		if (pLoopUnit->getTeam() == getTeam())
		{
			if (pLoopUnit->hasAfflictionLine(eAfflictionLine))
			{
				pLoopUnit->recover(eAfflictionLine);

				if (pPlot->isActiveVisible(false))
				{
					NotifyEntity(MISSION_CURE);
				}
				break;
			}
		}
	}
	return false;
}

int CvUnit::getTotalCommunicableExposure(PromotionLineTypes eAfflictionLine) const
{
	//const CvPromotionLineInfo& kAffliction = GC.getPromotionLineInfo(eAfflictionLine);
	const CvPlot* pPlot = plot();
	if (pPlot == NULL)
	{
		return 0;
	}

	int	iTileCommunicability = pPlot->getCommunicability(eAfflictionLine, false, true, true);
	int iUnitCommunicability = getUnitCommunicability(eAfflictionLine);
	int iCityCommunicability = getCityCommunicability(eAfflictionLine);
	int iTotal = iTileCommunicability + iUnitCommunicability + iCityCommunicability;
	return iTotal;
}

int CvUnit::getCityCommunicability(PromotionLineTypes eAfflictionLine) const
{
	CvPlot* pPlot = plot();
	if (pPlot == NULL)
	{
		return 0;
	}

	CvCity* pCity = pPlot->getPlotCity();
	int iCommunicability = 0;

	if (pCity != NULL && pCity->hasAfflictionType(eAfflictionLine)
	&& !GC.getPromotionLineInfo(eAfflictionLine).isNoSpreadCitytoUnit())
	{
		for (int iI = 0; iI < GC.getPromotionLineInfo(eAfflictionLine).getNumBuildings(); iI++)
		{
			BuildingTypes eAfflictionBuilding = (BuildingTypes)GC.getPromotionLineInfo(eAfflictionLine).getBuilding(iI);
			if (pCity->getNumActiveBuilding(eAfflictionBuilding) > 0)
			{
				iCommunicability += GC.getBuildingInfo(eAfflictionBuilding).getTradeCommunicability();
			}
		}
	}
	return iCommunicability;
}

int CvUnit::getUnitCommunicability(PromotionLineTypes eAfflictionLine) const
{
	int iWorstCommunicability = 0;
	int iCommunicability = 0;
	const CvPlot* pPlot = plot();
	if (pPlot == NULL)
	{
		return 0;
	}

	if (!GC.getPromotionLineInfo(eAfflictionLine).isNoSpreadUnitProximity())
	{
		const int iBaseCommunicability = GC.getPromotionLineInfo(eAfflictionLine).getCommunicability();
		foreach_(const CvUnit* pLoopUnit, pPlot->units())
		{
			if (pLoopUnit != this && pLoopUnit->hasAfflictionLine(eAfflictionLine))
			{
				iCommunicability = iBaseCommunicability;
				iCommunicability += pLoopUnit->worsenedProbabilitytoAfflict(eAfflictionLine);
				if (iWorstCommunicability < iCommunicability)
				{
					iWorstCommunicability = iCommunicability;
				}
			}
		}
	}
	return iWorstCommunicability;
}

void CvUnit::doOvercomeAttempt(PromotionLineTypes eAfflictionLine)
{
	CvWString szBuffer;
	int iOvercomeChance = getChancetoOvercome(eAfflictionLine);
	int iOvercomeRollResult;

	iOvercomeRollResult = GC.getGame().getSorenRandNum(100, "Overcome");
	if (iOvercomeRollResult < iOvercomeChance)
	{
		recover(eAfflictionLine);
	}
}

int CvUnit::getChancetoOvercome(PromotionLineTypes eAfflictionLine) const
{
	if (eAfflictionLine == NO_PROMOTIONLINE)
	{
		return 0;
	}
	PropertyTypes eProperty = GC.getPromotionLineInfo(eAfflictionLine).getPropertyType();
	if (eProperty == NO_PROPERTY)
	{
		return 0;
	}

	int iChance = GC.getPromotionLineInfo(eAfflictionLine).getOvercomeProbability();
	iChance += fortitudeTotal();
	iChance += getFortitudeModifierTypeAmount(eAfflictionLine);
	iChance += aidVolume(plot(), eProperty);
	iChance += currentOvercome(eAfflictionLine);
	iChance += getUnitAfflictionTolerance(eAfflictionLine);
	iChance += getOvercomeChange(eAfflictionLine);
	iChance += (GC.getPromotionLineInfo(eAfflictionLine).getWorsenedOvercomeIncrementModifier() * (getAfflictionLineCount(eAfflictionLine)-1));

	iChance *= GC.getPromotionLineInfo(eAfflictionLine).getOvercomeModifier();
	iChance /= 100;
	return iChance;
}

int CvUnit::currentOvercome(PromotionLineTypes eAfflictionLine) const
{
	return (GC.getPromotionLineInfo(eAfflictionLine).getOvercomeAdjperTurn() * getAfflictionTurnCount(eAfflictionLine));
}

int CvUnit::getAfflictionTurnCount(PromotionLineTypes ePromotionLineType) const
{
	FASSERT_BOUNDS(0, GC.getNumPromotionLineInfos(), ePromotionLineType);

	const PromotionLineKeyedInfo* info = findPromotionLineKeyedInfo(ePromotionLineType);

	return info == NULL ? 0 : info->m_iAfflictionTurnTypeCount;
}

void CvUnit::changeAfflictionTurnCount(PromotionLineTypes ePromotionLineType, int iChange)
{
	FASSERT_BOUNDS(0, GC.getNumPromotionLineInfos(), ePromotionLineType);

	if (iChange != 0)
	{
		PromotionLineKeyedInfo* info = findOrCreatePromotionLineKeyedInfo(ePromotionLineType);

		info->m_iAfflictionTurnTypeCount += iChange;
	}
}

void CvUnit::setAfflictionTurnCount(PromotionLineTypes ePromotionLineType, int iChange)
{
	FASSERT_BOUNDS(0, GC.getNumPromotionLineInfos(), ePromotionLineType);

	PromotionLineKeyedInfo* info = findOrCreatePromotionLineKeyedInfo(ePromotionLineType, iChange != 0);

	if (info != NULL)
	{
		info->m_iAfflictionTurnTypeCount = iChange;
	}
}

int CvUnit::aidVolume(const CvPlot* pPlot, PropertyTypes eProperty) const
{
	PROFILE_FUNC();

	const CvCity* pCity = pPlot->getPlotCity();

	int iTotalAid = 0;

	if (pPlot->isCity(true, getTeam()))
	{
		if (pCity && !pCity->isOccupation())
		{
			iTotalAid += pCity->getAidRate(eProperty);
		}
	}

	int iBestAid = 0;

	foreach_(const CvUnit* pLoopUnit, pPlot->units())
	{
		if (pLoopUnit->getTeam() == getTeam())
		{
			const int iAid = pLoopUnit->aidTotal(eProperty);

			if (iAid > iBestAid)
			{
				iBestAid = iAid;
			}
		}
	}

	iTotalAid += iBestAid;

	return iTotalAid;
}

int CvUnit::getAfflictionHitCount(PromotionTypes ePromotionType) const
{
	FASSERT_BOUNDS(0, GC.getNumPromotionInfos(), ePromotionType);

	const PromotionKeyedInfo* info = findPromotionKeyedInfo(ePromotionType);

	return info == NULL ? 0 : info->m_iAfflictionHitCount;
}

void CvUnit::changeAfflictionHitCount(PromotionTypes ePromotionType, int iChange)
{
	FASSERT_BOUNDS(0, GC.getNumPromotionInfos(), ePromotionType);

	if (iChange != 0)
	{
		PromotionKeyedInfo* info = findOrCreatePromotionKeyedInfo(ePromotionType);

		info->m_iAfflictionHitCount += iChange;
	}
}

void CvUnit::setAfflictionHitCount(PromotionTypes ePromotionType, int iChange)
{
	FASSERT_BOUNDS(0, GC.getNumPromotionInfos(), ePromotionType);

	PromotionKeyedInfo* info = findOrCreatePromotionKeyedInfo(ePromotionType, iChange != 0);

	if (info != NULL)
	{
		info->m_iAfflictionHitCount = iChange;
	}
}

bool CvUnit::removeAfflictionHits(PromotionTypes ePromotionType)
{
	int iStrChange;
	int iCombChange;

	iStrChange = -(GC.getPromotionInfo(ePromotionType).getStrAdjperTurn() * getAfflictionHitCount(ePromotionType));
	iCombChange = -(GC.getPromotionInfo(ePromotionType).getWeakenperTurn() * getAfflictionHitCount(ePromotionType));
	changeExtraStrength(iStrChange);
	changeExtraCombatPercent(iCombChange);
	return true;
}

bool CvUnit::updateAfflictionHits(PromotionTypes ePromotionType)
{
	int iStrChange;
	int iCombChange;
	int iDamageChange;

	iStrChange = GC.getPromotionInfo(ePromotionType).getStrAdjperTurn();
	iCombChange = GC.getPromotionInfo(ePromotionType).getWeakenperTurn();
	iDamageChange = (GC.getPromotionInfo(ePromotionType).getDamageperTurn() + getDamage());

	changeExtraStrength(iStrChange);
	changeExtraCombatPercent(iCombChange);
	changeDamage(iDamageChange);
	return true;
}

bool CvUnit::checkContractDisease(PromotionLineTypes eAfflictionLine, int iCommunicableExposure)
{
	PROFILE_FUNC();

	bool bCheck = false;
	for (int iI = 0; iI < GC.getPromotionLineInfo(eAfflictionLine).getNumPromotions(); iI++)
	{
		PromotionTypes eAffliction = (PromotionTypes)GC.getPromotionLineInfo(eAfflictionLine).getPromotion(iI);
		if (GC.getPromotionInfo(eAffliction).getLinePriority() == (getAfflictionLineCount(eAfflictionLine)+1))
		{
			if (canAcquirePromotion(eAffliction, PromotionRequirements::Afflict | PromotionRequirements::ForFree))
			{
				bCheck = true;
				break;
			}
		}
	}
	if (bCheck)
	{
		int iChancetoContract = getChancetoContract(eAfflictionLine, iCommunicableExposure);//yeah... needing work. redundancies.

		int iContractRollResult = GC.getGame().getSorenRandNum(100, "Unit Outbreak Check");
		if (iContractRollResult < iChancetoContract)
		{
			return true;
		}
	}

	return false;
}

int CvUnit::getChancetoContract(PromotionLineTypes eAfflictionLine, int iCommunicableExposure) const
{
	if (eAfflictionLine == NO_PROMOTIONLINE)
	{
		return 0;
	}
	PropertyTypes eProperty = GC.getPromotionLineInfo(eAfflictionLine).getPropertyType();
	if (eProperty == NO_PROPERTY)
	{
		return 0;
	}

	int	iContract = GC.getPromotionLineInfo(eAfflictionLine).getCommunicability();
	if (iCommunicableExposure > 0 && iCommunicableExposure > iContract)
	{
		iContract = iCommunicableExposure;
	}
	iContract += getContractChanceChange(eAfflictionLine);
	iContract -= fortitudeTotal();
	iContract -= getFortitudeModifierTypeAmount(eAfflictionLine);
	iContract -= getUnitAfflictionTolerance(eAfflictionLine);
	if (hasAfflictionLine(eAfflictionLine))
	{
		iContract += (getAfflictionLineCount(eAfflictionLine) * GC.getPromotionLineInfo(eAfflictionLine).getWorseningProbabilityIncrementModifier());
	}
	int iChanceModifier = GC.getPromotionLineInfo(eAfflictionLine).getOutbreakModifier();
	iContract *= iChanceModifier;
	iContract /= 100;
	return iContract;
}

int CvUnit::getUnitAfflictionTolerance(PromotionLineTypes ePromotionLineType) const
{
	FASSERT_BOUNDS(0, GC.getNumPromotionLineInfos(), ePromotionLineType);

	const PromotionLineKeyedInfo* info = findPromotionLineKeyedInfo(ePromotionLineType);

	return info == NULL ? 0 : info->m_iAfflictionTypeTolerance;
}

void CvUnit::changeUnitAfflictionTolerance(PromotionLineTypes ePromotionLineType, int iChange)
{
	FASSERT_BOUNDS(0, GC.getNumPromotionLineInfos(), ePromotionLineType);

	if (iChange != 0)
	{
		PromotionLineKeyedInfo* info = findOrCreatePromotionLineKeyedInfo(ePromotionLineType);

		info->m_iAfflictionTypeTolerance = std::max(0, info->m_iAfflictionTypeTolerance + iChange);
	}
}

void CvUnit::setUnitAfflictionTolerance(PromotionLineTypes ePromotionLineType, int iChange)
{
	FASSERT_BOUNDS(0, GC.getNumPromotionLineInfos(), ePromotionLineType);

	PromotionLineKeyedInfo* info = findOrCreatePromotionLineKeyedInfo(ePromotionLineType, iChange != 0);

	if (info != NULL)
	{
		info->m_iAfflictionTypeTolerance = iChange;
	}
}

int CvUnit::getContractChanceChange(PromotionLineTypes eAfflictionLine) const
{
	int iI;
	int iModifier = 0;

	for (iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
	{
		UnitCombatTypes eUnitCombat = ((UnitCombatTypes)iI);
		if (isHasUnitCombat(eUnitCombat))
		{
			iModifier += GC.getPromotionLineInfo(eAfflictionLine).getUnitCombatContractChanceChange(iI);
		}
	}

	for (iI = 0; iI < GC.getNumTechInfos(); iI++)
	{
		TechTypes eTech = ((TechTypes)iI);
		if (GET_TEAM(getTeam()).isHasTech(eTech))
		{
			iModifier += GC.getPromotionLineInfo(eAfflictionLine).getTechContractChanceChange(iI);
		}
	}

	return iModifier;
}

int CvUnit::getOvercomeChange(PromotionLineTypes eAfflictionLine) const
{
	int iI;
	int iModifier = 0;

	for (iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
	{
		UnitCombatTypes eUnitCombat = ((UnitCombatTypes)iI);
		if (isHasUnitCombat(eUnitCombat))
		{
			iModifier += GC.getPromotionLineInfo(eAfflictionLine).getUnitCombatOvercomeChange(iI);
		}
	}

	for (iI = 0; iI < GC.getNumTechInfos(); iI++)
	{
		TechTypes eTech = ((TechTypes)iI);
		if (GET_TEAM(getTeam()).isHasTech(eTech))
		{
			iModifier += GC.getPromotionLineInfo(eAfflictionLine).getTechOvercomeChange(iI);
		}
	}

	return iModifier;
}

int CvUnit::getFortitudeModifierTypeAmount(PromotionLineTypes ePromotionLineType) const
{
	FASSERT_BOUNDS(0, GC.getNumPromotionLineInfos(), ePromotionLineType);

	const PromotionLineKeyedInfo* info = findPromotionLineKeyedInfo(ePromotionLineType);

	int iEvaluation = (info == NULL ? 0 : info->m_iFortitudeModifierAmount);
	const int iNum = m_pUnitInfo->getNumAfflictionFortitudeModifiers();

	for (int iI = 0; iI < iNum; iI++)
	{
		const PromotionLineTypes eAfflictionLine = m_pUnitInfo->getAfflictionFortitudeModifier(iI).ePromotionLine;
		if (eAfflictionLine == ePromotionLineType)
		{
			iEvaluation += m_pUnitInfo->getAfflictionFortitudeModifier(iI).iModifier;
		}
	}
	return iEvaluation;
}

void CvUnit::changeFortitudeModifierTypeAmount(PromotionLineTypes ePromotionLineType, int iChange)
{
	FASSERT_BOUNDS(0, GC.getNumPromotionLineInfos(), ePromotionLineType);

	if (iChange != 0)
	{
		PromotionLineKeyedInfo* info = findOrCreatePromotionLineKeyedInfo(ePromotionLineType);

		info->m_iFortitudeModifierAmount += iChange;
	}
}

void CvUnit::setFortitudeModifierTypeAmount(PromotionLineTypes ePromotionLineType, int iChange)
{
	FASSERT_BOUNDS(0, GC.getNumPromotionLineInfos(), ePromotionLineType);

	PromotionLineKeyedInfo* info = findOrCreatePromotionLineKeyedInfo(ePromotionLineType, iChange != 0);

	if (info != NULL)
	{
		info->m_iFortitudeModifierAmount = iChange;
	}
}
#endif // OUTBREAKS_AND_AFFLICTIONS

int CvUnit::getCityRepel() const
{
	if (noDefensiveBonus())
	{
		return 0;
	}
	PROFILE_FUNC();

	UnitCombatTypes eUnitCombat;
	int iI;
	CvCity* pCity;
	int iCityRepel = 0;

	if (plot() != NULL)
	{
		if (plot()->getPlotCity() != NULL)
		{
			pCity = plot()->getPlotCity();
			iCityRepel += pCity->getExtraLocalRepel();

			for(iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
			{
				eUnitCombat = ((UnitCombatTypes)iI);
				if (isHasUnitCombat(eUnitCombat))
				{
					iCityRepel += pCity->getUnitCombatRepelModifierTotal(eUnitCombat);
				}
			}
		}
	}
	return iCityRepel;
}

#ifdef STRENGTH_IN_NUMBERS

int CvUnit::getCityFrontSupportPercentModifier() const
{
	PROFILE_FUNC();

	CvCity* pCity;
	int iModifier = 0;
	if (plot() != NULL)
	{
		if (plot()->getPlotCity() != NULL)
		{
			pCity = plot()->getPlotCity();
			iModifier += pCity->getTotalFrontSupportPercentModifier();
		}
	}
	return iModifier;
}

int CvUnit::getCityShortRangeSupportPercentModifier() const
{
	PROFILE_FUNC();

	CvCity* pCity;
	int iModifier = 0;
	if (plot() != NULL)
	{
		if (plot()->getPlotCity() != NULL)
		{
			pCity = plot()->getPlotCity();
			iModifier += pCity->getTotalShortRangeSupportPercentModifier();
		}
	}
	return iModifier;
}

int CvUnit::getCityMediumRangeSupportPercentModifier() const
{
	PROFILE_FUNC();

	CvCity* pCity;
	int iModifier = 0;
	if (plot() != NULL)
	{
		if (plot()->getPlotCity() != NULL)
		{
			pCity = plot()->getPlotCity();
			iModifier += pCity->getTotalMediumRangeSupportPercentModifier();
		}
	}
	return iModifier;
}

int CvUnit::getCityLongRangeSupportPercentModifier() const
{
	PROFILE_FUNC();

	CvCity* pCity;
	int iModifier = 0;
	if (plot() != NULL)
	{
		if (plot()->getPlotCity() != NULL)
		{
			pCity = plot()->getPlotCity();
			iModifier += pCity->getTotalLongRangeSupportPercentModifier();
		}
	}
	return iModifier;
}

int CvUnit::getCityFlankSupportPercentModifier() const
{
	PROFILE_FUNC();

	CvCity* pCity;
	int iModifier = 0;
	if (plot() != NULL)
	{
		if (plot()->getPlotCity() != NULL)
		{
			pCity = plot()->getPlotCity();
			iModifier += pCity->getTotalFlankSupportPercentModifier();
		}
	}
	return iModifier;
}

int CvUnit::getExtraFrontSupportPercent(bool bIgnoreCommanders) const
{
	if (!bIgnoreCommanders && !isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander != NULL)
		{
			return m_iExtraFrontSupportPercent + pCommander->m_iExtraFrontSupportPercent;
		}
	}
	return m_iExtraFrontSupportPercent;
}

void CvUnit::changeExtraFrontSupportPercent(int iChange)
{
	m_iExtraFrontSupportPercent +=iChange;
	FASSERT_NOT_NEGATIVE(getExtraFrontSupportPercent());
}

int CvUnit::getExtraShortRangeSupportPercent(bool bIgnoreCommanders) const
{
	if (!bIgnoreCommanders && !isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander != NULL)
		{
			return m_iExtraShortRangeSupportPercent + pCommander->m_iExtraShortRangeSupportPercent;
		}
	}
	return m_iExtraShortRangeSupportPercent;
}

void CvUnit::changeExtraShortRangeSupportPercent(int iChange)
{
	m_iExtraShortRangeSupportPercent +=iChange;
	FASSERT_NOT_NEGATIVE(getExtraShortRangeSupportPercent());
}

int CvUnit::getExtraMediumRangeSupportPercent(bool bIgnoreCommanders) const
{
	if (!bIgnoreCommanders && !isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander != NULL)
		{
			return m_iExtraMediumRangeSupportPercent + pCommander->m_iExtraMediumRangeSupportPercent;
		}
	}
	return m_iExtraMediumRangeSupportPercent;
}

void CvUnit::changeExtraMediumRangeSupportPercent(int iChange)
{
	m_iExtraMediumRangeSupportPercent +=iChange;
	FASSERT_NOT_NEGATIVE(getExtraMediumRangeSupportPercent());
}

int CvUnit::getExtraLongRangeSupportPercent(bool bIgnoreCommanders) const
{
	if (!bIgnoreCommanders && !isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander != NULL)
		{
			return m_iExtraLongRangeSupportPercent + pCommander->m_iExtraLongRangeSupportPercent;
		}
	}
	return m_iExtraLongRangeSupportPercent;
}

void CvUnit::changeExtraLongRangeSupportPercent(int iChange)
{
	m_iExtraLongRangeSupportPercent +=iChange;
	FASSERT_NOT_NEGATIVE(getExtraLongRangeSupportPercent());
}

int CvUnit::getExtraFlankSupportPercent(bool bIgnoreCommanders) const
{
	if (!bIgnoreCommanders && !isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander != NULL)
		{
			return m_iExtraFlankSupportPercent + pCommander->m_iExtraFlankSupportPercent;
		}
	}
	return m_iExtraFlankSupportPercent;
}

void CvUnit::changeExtraFlankSupportPercent(int iChange)
{
	m_iExtraFlankSupportPercent +=iChange;
	FASSERT_NOT_NEGATIVE(getExtraFlankSupportPercent());
}

int CvUnit::frontSupportPercentTotal() const
{
	return std::max(0, (m_pUnitInfo->getFrontSupportPercent() + getExtraFrontSupportPercent() + getCityFrontSupportPercentModifier()));
}

int CvUnit::shortRangeSupportPercentTotal() const
{
	return std::max(0, (m_pUnitInfo->getShortRangeSupportPercent() + getExtraShortRangeSupportPercent() + getCityShortRangeSupportPercentModifier()));
}

int CvUnit::mediumRangeSupportPercentTotal() const
{
	return std::max(0, (m_pUnitInfo->getMediumRangeSupportPercent() + getExtraMediumRangeSupportPercent() + getCityMediumRangeSupportPercentModifier()));
}

int CvUnit::longRangeSupportPercentTotal() const
{
	return std::max(0, (m_pUnitInfo->getLongRangeSupportPercent() + getExtraLongRangeSupportPercent() + getCityLongRangeSupportPercentModifier()));
}

int CvUnit::flankSupportPercentTotal() const
{
	return std::max(0, (m_pUnitInfo->getFlankSupportPercent() + getExtraFlankSupportPercent() + getCityFlankSupportPercentModifier()));
}

bool CvUnit::isFrontSupporter() const
{
	return (std::max(0, (m_pUnitInfo->getFrontSupportPercent() + getExtraFrontSupportPercent())) > 0);
}

bool CvUnit::isShortRangeSupporter() const
{
	return (std::max(0, (m_pUnitInfo->getShortRangeSupportPercent() + getExtraShortRangeSupportPercent())) > 0);
}

bool CvUnit::isMediumRangeSupporter() const
{
	return (std::max(0, (m_pUnitInfo->getMediumRangeSupportPercent() + getExtraMediumRangeSupportPercent())) > 0);
}

bool CvUnit::isLongRangeSupporter() const
{
	return (std::max(0, (m_pUnitInfo->getLongRangeSupportPercent() + getExtraLongRangeSupportPercent())) > 0);
}

bool CvUnit::isFlankSupporter() const
{
	return (std::max(0, (m_pUnitInfo->getFlankSupportPercent() + getExtraFlankSupportPercent())) > 0);
}

CvPlot* CvUnit::getAttackFromPlot() const
{
	return GC.getMap().plotSorenINLINE(m_iAttackFromPlotX, m_iAttackFromPlotY);
}

void CvUnit::setAttackFromPlot(const CvPlot* pNewValue)
{
	if (getAttackFromPlot() != pNewValue)
	{
		if (pNewValue != NULL)
		{
			m_iAttackFromPlotX = pNewValue->getX();
			m_iAttackFromPlotY = pNewValue->getY();
		}
		else
		{
			m_iAttackFromPlotX = INVALID_PLOT_COORD;
			m_iAttackFromPlotY = INVALID_PLOT_COORD;
		}
	}
}

int CvUnit::getAttackerSupportValue() const
{
	if (!GC.getGame().isOption(GAMEOPTION_STRENGTH_IN_NUMBERS))
	{
		return 0;
	}
	PROFILE_FUNC();

	CvPlot* aPlot = getAttackFromPlot();
	CvPlot* pPlot = getAttackPlot();
	CvUnit* pDefender;
	pDefender = pPlot->getBestDefender(NO_PLAYER, getOwner(), this, true);
	int iTotalSupport = 0;
	int iFrontOne = getAttackerFirstFrontSupportValue(aPlot, pPlot, pDefender);
	int iFrontTwo = getAttackerSecondFrontSupportValue(aPlot, pPlot, pDefender);
	int iShortOne = getAttackerFirstShortRangeSupportValue(aPlot, pPlot, pDefender);
	int iShortTwo = getAttackerSecondShortRangeSupportValue(aPlot, pPlot, pDefender);
	int iMedOne = getAttackerFirstMediumRangeSupportValue(aPlot, pPlot, pDefender);
	int iMedTwo = getAttackerSecondMediumRangeSupportValue(aPlot, pPlot, pDefender);
	int iLongOne = getAttackerFirstLongRangeSupportValue(aPlot, pPlot, pDefender);
	int iLongTwo = getAttackerSecondLongRangeSupportValue(aPlot, pPlot, pDefender);
	int iFlankOne = getAttackerFirstFlankSupportValue(aPlot, pPlot, pDefender);
	int iFlankTwo = getAttackerSecondFlankSupportValue(aPlot, pPlot, pDefender);
	iTotalSupport = (iFrontOne + iFrontTwo + iShortOne + iShortTwo + iMedOne + iMedTwo + iLongOne + iLongTwo + iFlankOne + iFlankTwo);
	return iTotalSupport;
}

int CvUnit::getAttackerFirstFrontSupportValue(const CvPlot* aPlot, const CvPlot* pPlot, const CvUnit* pDefender) const
{
	PROFILE_FUNC();

	CvUnit* pBestUnit;
	CvUnit* pAttacker;

	int iBestCurrCombatStr = 0;
	int iLowestCurrDefenderCombatStr = 0;
	int iBestFrontSupport = 0;

	int iFrontSupportPercent = 0;

	foreach_(CvUnit* pLoopUnit, aPlot->units())
	{
		if (pLoopUnit->isAttacking())
		{
			pAttacker = pLoopUnit;
		}
		if (pLoopUnit->getTeam() == getTeam() && !(pLoopUnit->isAttacking()) && !(pLoopUnit->isSupporting()) && (pLoopUnit->canAttack()) && (pLoopUnit->isFrontSupporter()))
		{
			iFrontSupportPercent = pLoopUnit->frontSupportPercentTotal();
			// if pDefender == null - use the last config of maxCombatStr() where pAttacker == this, else - use the pDefender to find the best attacker
			if (pDefender != NULL)
			{
				int iTmpCurrDefenderCombatStr = pDefender->currCombatStr(NULL, pLoopUnit, NULL, true);
				iTmpCurrDefenderCombatStr -= ((iTmpCurrDefenderCombatStr * iFrontSupportPercent)/100);

				if (iTmpCurrDefenderCombatStr < iLowestCurrDefenderCombatStr)
				{
					iLowestCurrDefenderCombatStr = iTmpCurrDefenderCombatStr;
					pBestUnit = pLoopUnit;
				}
			}
			else
			{
				//TB Combat Mods begin
				int iTmpCurrCombatStr = pLoopUnit->currCombatStr(pPlot, pLoopUnit, NULL, true);
				iTmpCurrCombatStr = ((iTmpCurrCombatStr * iFrontSupportPercent)/100);
				//TB Combat Mods end

				if (iTmpCurrCombatStr > iBestCurrCombatStr)
				{
					iBestCurrCombatStr = iTmpCurrCombatStr;
					pBestUnit = pLoopUnit;
				}
			}
		}
	}

	if (pBestUnit != NULL)
	{
		pBestUnit->setSupportCount(1);
		pAttacker->setAttackerFirstFrontSupportingUnit(pBestUnit);
		iBestFrontSupport = (((pBestUnit->currCombatStr(pPlot, pLoopUnit, NULL, true))* pBestUnit->frontSupportPercentTotal())/100);
	}

	return iBestFrontSupport;
}

int CvUnit::getAttackerSecondFrontSupportValue(const CvPlot* aPlot, const CvPlot* pPlot, const CvUnit* pDefender) const
{
	PROFILE_FUNC();

	CvUnit* pBestUnit;
	CvUnit* pAttacker;

	int iBestCurrCombatStr = 0;
	int iLowestCurrDefenderCombatStr = 0;
	int iBestFrontSupport = 0;

	int iFrontSupportPercent = 0;

	foreach_(CvUnit* pLoopUnit, aPlot->units())
	{
		if (pLoopUnit->isAttacking())
		{
			pAttacker = pLoopUnit;
		}

		if (pLoopUnit->getTeam() == getTeam() && !(pLoopUnit->isAttacking()) && !(pLoopUnit->isSupporting()) && (pLoopUnit->canAttack()) && (pLoopUnit->isFrontSupporter()))
		{
			iFrontSupportPercent = pLoopUnit->frontSupportPercentTotal();
			// if pDefender == null - use the last config of maxCombatStr() where pAttacker == this, else - use the pDefender to find the best attacker
			if (pDefender != NULL)
			{
				int iTmpCurrDefenderCombatStr = pDefender->currCombatStr(NULL, pLoopUnit, NULL, true);
				iTmpCurrDefenderCombatStr -= ((iTmpCurrDefenderCombatStr * iFrontSupportPercent)/100);

				if (iTmpCurrDefenderCombatStr < iLowestCurrDefenderCombatStr)
				{
					iLowestCurrDefenderCombatStr = iTmpCurrDefenderCombatStr;
					pBestUnit = pLoopUnit;
				}
			}
			else
			{
				//TB Combat Mods begin
				int iTmpCurrCombatStr = pLoopUnit->currCombatStr(pPlot, pLoopUnit, NULL, true);
				iTmpCurrCombatStr = ((iTmpCurrCombatStr * iFrontSupportPercent)/100);
				//TB Combat Mods end

				if (iTmpCurrCombatStr > iBestCurrCombatStr)
				{
					iBestCurrCombatStr = iTmpCurrCombatStr;
					pBestUnit = pLoopUnit;
				}
			}
		}
	}

	if (pBestUnit != NULL)
	{
		pBestUnit->setSupportCount(1);
		pAttacker->setAttackerSecondFrontSupportingUnit(pBestUnit);
		iBestFrontSupport = (((pBestUnit->currCombatStr(pPlot, pLoopUnit, NULL, true))* pBestUnit->frontSupportPercentTotal())/100);
	}

	return iBestFrontSupport;
}

int CvUnit::getAttackerFirstShortRangeSupportValue(const CvPlot* aPlot, const CvPlot* pPlot, const CvUnit* pDefender) const
{
	PROFILE_FUNC();

	CvUnit* pBestUnit;
	CvUnit* pAttacker;

	int iBestCurrCombatStr = 0;
	int iLowestCurrDefenderCombatStr = 0;
	int iBestShortRangeSupport = 0;

	int iShortRangeSupportPercent = 0;

	foreach_(CvUnit* pLoopUnit, aPlot->units())
	{
		if (pLoopUnit->isAttacking())
		{
			pAttacker = pLoopUnit;
		}

		if (pLoopUnit->getTeam() == getTeam() && !(pLoopUnit->isAttacking()) && !(pLoopUnit->isSupporting()) && (pLoopUnit->canAttack()) && (pLoopUnit->isShortRangeSupporter()))
		{
			iShortRangeSupportPercent = pLoopUnit->shortRangeSupportPercentTotal();
			// if pDefender == null - use the last config of maxCombatStr() where pAttacker == this, else - use the pDefender to find the best attacker
			if (pDefender != NULL)
			{
				int iTmpCurrDefenderCombatStr = pDefender->currCombatStr(NULL, pLoopUnit, NULL, true);
				iTmpCurrDefenderCombatStr -= ((iTmpCurrDefenderCombatStr * iShortRangeSupportPercent)/100);

				if (iTmpCurrDefenderCombatStr < iLowestCurrDefenderCombatStr)
				{
					iLowestCurrDefenderCombatStr = iTmpCurrDefenderCombatStr;
					pBestUnit = pLoopUnit;
				}
			}
			else
			{
				//TB Combat Mods begin
				int iTmpCurrCombatStr = pLoopUnit->currCombatStr(pPlot, pLoopUnit, NULL, true);
				iTmpCurrCombatStr = ((iTmpCurrCombatStr * iShortRangeSupportPercent)/100);
				//TB Combat Mods end

				if (iTmpCurrCombatStr > iBestCurrCombatStr)
				{
					iBestCurrCombatStr = iTmpCurrCombatStr;
					pBestUnit = pLoopUnit;
				}
			}
		}
	}

	if (pBestUnit != NULL)
	{
		pBestUnit->setSupportCount(1);
		pAttacker->setAttackerFirstShortRangeSupportingUnit(pBestUnit);
		iBestShortRangeSupport = (((pBestUnit->currCombatStr(pPlot, pLoopUnit, NULL, true))* pBestUnit->shortRangeSupportPercentTotal())/100);
	}

	return iBestShortRangeSupport;
}

int CvUnit::getAttackerSecondShortRangeSupportValue(const CvPlot* aPlot, const CvPlot* pPlot, const CvUnit* pDefender) const
{
	PROFILE_FUNC();

	CvUnit* pBestUnit;
	CvUnit* pAttacker;

	int iBestCurrCombatStr = 0;
	int iLowestCurrDefenderCombatStr = 0;
	int iBestShortRangeSupport = 0;

	int iShortRangeSupportPercent = 0;

	foreach_(CvUnit* pLoopUnit, aPlot->units())
	{
		if (pLoopUnit->isAttacking())
		{
			pAttacker = pLoopUnit;
		}

		if (pLoopUnit->getTeam() == getTeam() && !(pLoopUnit->isAttacking()) && !(pLoopUnit->isSupporting()) && (pLoopUnit->canAttack()) && (pLoopUnit->isShortRangeSupporter()))
		{
			iShortRangeSupportPercent = pLoopUnit->shortRangeSupportPercentTotal();
			// if pDefender == null - use the last config of maxCombatStr() where pAttacker == this, else - use the pDefender to find the best attacker
			if (pDefender != NULL)
			{
				int iTmpCurrDefenderCombatStr = pDefender->currCombatStr(NULL, pLoopUnit, NULL, true);
				iTmpCurrDefenderCombatStr -= ((iTmpCurrDefenderCombatStr * iShortRangeSupportPercent)/100);

				if (iTmpCurrDefenderCombatStr < iLowestCurrDefenderCombatStr)
				{
					iLowestCurrDefenderCombatStr = iTmpCurrDefenderCombatStr;
					pBestUnit = pLoopUnit;
				}
			}
			else
			{
				//TB Combat Mods begin
				int iTmpCurrCombatStr = pLoopUnit->currCombatStr(pPlot, pLoopUnit, NULL, true);
				iTmpCurrCombatStr = ((iTmpCurrCombatStr * iShortRangeSupportPercent)/100);
				//TB Combat Mods end

				if (iTmpCurrCombatStr > iBestCurrCombatStr)
				{
					iBestCurrCombatStr = iTmpCurrCombatStr;
					pBestUnit = pLoopUnit;
				}
			}
		}
	}

	if (pBestUnit != NULL)
	{
		pBestUnit->setSupportCount(1);
		pAttacker->setAttackerSecondShortRangeSupportingUnit(pBestUnit);
		iBestShortRangeSupport = (((pBestUnit->currCombatStr(pPlot, pLoopUnit, NULL, true))* pBestUnit->shortRangeSupportPercentTotal())/100);
	}

	return iBestShortRangeSupport;
}

int CvUnit::getAttackerFirstMediumRangeSupportValue(const CvPlot* aPlot, const CvPlot* pPlot, const CvUnit* pDefender) const
{
	PROFILE_FUNC();

	CvUnit* pBestUnit;
	CvUnit* pAttacker;

	int iBestCurrCombatStr = 0;
	int iLowestCurrDefenderCombatStr = 0;
	int iBestMediumRangeSupport = 0;

	int iMediumRangeSupportPercent = 0;

	foreach_(CvUnit* pLoopUnit, aPlot->units())
	{
		if (pLoopUnit->isAttacking())
		{
			pAttacker = pLoopUnit;
		}

		if (pLoopUnit->getTeam() == getTeam() && !(pLoopUnit->isAttacking()) && !(pLoopUnit->isSupporting()) && (pLoopUnit->canAttack()) && (pLoopUnit->isMediumRangeSupporter()))
		{
			iMediumRangeSupportPercent = pLoopUnit->mediumRangeSupportPercentTotal();
			// if pDefender == null - use the last config of maxCombatStr() where pAttacker == this, else - use the pDefender to find the best attacker
			if (pDefender != NULL)
			{
				int iTmpCurrDefenderCombatStr = pDefender->currCombatStr(NULL, pLoopUnit, NULL, true);
				iTmpCurrDefenderCombatStr -= ((iTmpCurrDefenderCombatStr * iMediumRangeSupportPercent)/100);

				if (iTmpCurrDefenderCombatStr < iLowestCurrDefenderCombatStr)
				{
					iLowestCurrDefenderCombatStr = iTmpCurrDefenderCombatStr;
					pBestUnit = pLoopUnit;
				}
			}
			else
			{
				//TB Combat Mods begin
				int iTmpCurrCombatStr = pLoopUnit->currCombatStr(pPlot, pLoopUnit, NULL, true);
				iTmpCurrCombatStr = ((iTmpCurrCombatStr * iMediumRangeSupportPercent)/100);
				//TB Combat Mods end

				if (iTmpCurrCombatStr > iBestCurrCombatStr)
				{
					iBestCurrCombatStr = iTmpCurrCombatStr;
					pBestUnit = pLoopUnit;
				}
			}
		}
	}

	if (pBestUnit != NULL)
	{
		pBestUnit->setSupportCount(1);
		pAttacker->setAttackerFirstMediumRangeSupportingUnit(pBestUnit);
		iBestMediumRangeSupport = (((pBestUnit->currCombatStr(pPlot, pLoopUnit, NULL, true))* pBestUnit->mediumRangeSupportPercentTotal())/100);
	}

	return iBestMediumRangeSupport;
}

int CvUnit::getAttackerSecondMediumRangeSupportValue(const CvPlot* aPlot, const CvPlot* pPlot, const CvUnit* pDefender) const
{
	PROFILE_FUNC();

	CvUnit* pBestUnit;
	CvUnit* pAttacker;

	int iBestCurrCombatStr = 0;
	int iLowestCurrDefenderCombatStr = 0;
	int iBestMediumRangeSupport = 0;

	int iMediumRangeSupportPercent = 0;

	foreach_(CvUnit* pLoopUnit, aPlot->units())
	{
		if (pLoopUnit->isAttacking())
		{
			pAttacker = pLoopUnit;
		}

		if (pLoopUnit->getTeam() == getTeam() && !(pLoopUnit->isAttacking()) && !(pLoopUnit->isSupporting()) && (pLoopUnit->canAttack()) && (pLoopUnit->isMediumRangeSupporter()))
		{
			iMediumRangeSupportPercent = pLoopUnit->mediumRangeSupportPercentTotal();
			// if pDefender == null - use the last config of maxCombatStr() where pAttacker == this, else - use the pDefender to find the best attacker
			if (pDefender != NULL)
			{
				int iTmpCurrDefenderCombatStr = pDefender->currCombatStr(NULL, pLoopUnit, NULL, true);
				iTmpCurrDefenderCombatStr -= ((iTmpCurrDefenderCombatStr * iMediumRangeSupportPercent)/100);

				if (iTmpCurrDefenderCombatStr < iLowestCurrDefenderCombatStr)
				{
					iLowestCurrDefenderCombatStr = iTmpCurrDefenderCombatStr;
					pBestUnit = pLoopUnit;
				}
			}
			else
			{
				//TB Combat Mods begin
				int iTmpCurrCombatStr = pLoopUnit->currCombatStr(pPlot, pLoopUnit, NULL, true);
				iTmpCurrCombatStr = ((iTmpCurrCombatStr * iMediumRangeSupportPercent)/100);
				//TB Combat Mods end

				if (iTmpCurrCombatStr > iBestCurrCombatStr)
				{
					iBestCurrCombatStr = iTmpCurrCombatStr;
					pBestUnit = pLoopUnit;
				}
			}
		}
	}

	if (pBestUnit != NULL)
	{
		pBestUnit->setSupportCount(1);
		pAttacker->setAttackerSecondMediumRangeSupportingUnit(pBestUnit);
		iBestMediumRangeSupport = (((pBestUnit->currCombatStr(pPlot, pLoopUnit, NULL, true))* pBestUnit->mediumRangeSupportPercentTotal())/100);
	}

	return iBestMediumRangeSupport;
}

int CvUnit::getAttackerFirstLongRangeSupportValue(const CvPlot* aPlot, const CvPlot* pPlot, const CvUnit* pDefender) const
{
	PROFILE_FUNC();

	CvUnit* pBestUnit;
	CvUnit* pAttacker;

	int iBestCurrCombatStr = 0;
	int iLowestCurrDefenderCombatStr = 0;
	int iBestLongRangeSupport = 0;

	int iLongRangeSupportPercent = 0;

	foreach_(CvUnit* pLoopUnit, aPlot->units())
	{
		if (pLoopUnit->isAttacking())
		{
			pAttacker = pLoopUnit;
		}

		if (pLoopUnit->getTeam() == getTeam() && !(pLoopUnit->isAttacking()) && !(pLoopUnit->isSupporting()) && (pLoopUnit->canAttack()) && (pLoopUnit->isLongRangeSupporter()))
		{
			iLongRangeSupportPercent = pLoopUnit->longRangeSupportPercentTotal();
			// if pDefender == null - use the last config of maxCombatStr() where pAttacker == this, else - use the pDefender to find the best attacker
			if (pDefender != NULL)
			{
				int iTmpCurrDefenderCombatStr = pDefender->currCombatStr(NULL, pLoopUnit, NULL, true);
				iTmpCurrDefenderCombatStr -= ((iTmpCurrDefenderCombatStr * iLongRangeSupportPercent)/100);

				if (iTmpCurrDefenderCombatStr < iLowestCurrDefenderCombatStr)
				{
					iLowestCurrDefenderCombatStr = iTmpCurrDefenderCombatStr;
					pBestUnit = pLoopUnit;
				}
			}
			else
			{
				//TB Combat Mods begin
				int iTmpCurrCombatStr = pLoopUnit->currCombatStr(pPlot, pLoopUnit, NULL, true);
				iTmpCurrCombatStr = ((iTmpCurrCombatStr * iLongRangeSupportPercent)/100);
				//TB Combat Mods end

				if (iTmpCurrCombatStr > iBestCurrCombatStr)
				{
					iBestCurrCombatStr = iTmpCurrCombatStr;
					pBestUnit = pLoopUnit;
				}
			}
		}
	}

	if (pBestUnit != NULL)
	{
		pBestUnit->setSupportCount(1);
		pAttacker->setAttackerFirstLongRangeSupportingUnit(pBestUnit);
		iBestLongRangeSupport = (((pBestUnit->currCombatStr(pPlot, pLoopUnit, NULL, true))* pBestUnit->longRangeSupportPercentTotal())/100);
	}

	return iBestLongRangeSupport;
}

int CvUnit::getAttackerSecondLongRangeSupportValue(const CvPlot* aPlot, const CvPlot* pPlot, const CvUnit* pDefender) const
{
	PROFILE_FUNC();

	CvUnit* pBestUnit;
	CvUnit* pAttacker;

	int iBestCurrCombatStr = 0;
	int iLowestCurrDefenderCombatStr = 0;
	int iBestLongRangeSupport = 0;

	int iLongRangeSupportPercent = 0;

	foreach_(CvUnit* pLoopUnit, aPlot->units())
	{
		if (pLoopUnit->isAttacking())
		{
			pAttacker = pLoopUnit;
		}

		if (pLoopUnit->getTeam() == getTeam() && !(pLoopUnit->isAttacking()) && !(pLoopUnit->isSupporting()) && (pLoopUnit->canAttack()) && (pLoopUnit->isLongRangeSupporter()))
		{
			iLongRangeSupportPercent = pLoopUnit->longRangeSupportPercentTotal();
			// if pDefender == null - use the last config of maxCombatStr() where pAttacker == this, else - use the pDefender to find the best attacker
			if (pDefender != NULL)
			{
				int iTmpCurrDefenderCombatStr = pDefender->currCombatStr(NULL, pLoopUnit, NULL, true);
				iTmpCurrDefenderCombatStr -= ((iTmpCurrDefenderCombatStr * iLongRangeSupportPercent)/100);

				if (iTmpCurrDefenderCombatStr < iLowestCurrDefenderCombatStr)
				{
					iLowestCurrDefenderCombatStr = iTmpCurrDefenderCombatStr;
					pBestUnit = pLoopUnit;
				}
			}
			else
			{
				//TB Combat Mods begin
				int iTmpCurrCombatStr = pLoopUnit->currCombatStr(pPlot, pLoopUnit, NULL, true);
				iTmpCurrCombatStr = ((iTmpCurrCombatStr * iLongRangeSupportPercent)/100);
				//TB Combat Mods end

				if (iTmpCurrCombatStr > iBestCurrCombatStr)
				{
					iBestCurrCombatStr = iTmpCurrCombatStr;
					pBestUnit = pLoopUnit;
				}
			}
		}
	}

	if (pBestUnit != NULL)
	{
		pBestUnit->setSupportCount(1);
		pAttacker->setAttackerSecondLongRangeSupportingUnit(pBestUnit);
		iBestLongRangeSupport = (((pBestUnit->currCombatStr(pPlot, pLoopUnit, NULL, true))* pBestUnit->longRangeSupportPercentTotal())/100);
	}

	return iBestLongRangeSupport;
}

int CvUnit::getAttackerFirstFlankSupportValue(const CvPlot* aPlot, const CvPlot* pPlot, const CvUnit* pDefender) const
{
	PROFILE_FUNC();

	CvUnit* pBestUnit;
	CvUnit* pAttacker;

	int iBestCurrCombatStr = 0;
	int iLowestCurrDefenderCombatStr = 0;
	int iBestFlankSupport = 0;

	int iFlankSupportPercent = 0;

	foreach_(const CvUnit* pLoopUnit, aPlot->units())
	{
		if (pLoopUnit->isAttacking())
		{
			pAttacker = pLoopUnit;
		}

		if (pLoopUnit->getTeam() == getTeam() && !(pLoopUnit->isAttacking()) && !(pLoopUnit->isSupporting()) && (pLoopUnit->canAttack()) && (pLoopUnit->isFlankSupporter()))
		{
			iFlankSupportPercent = pLoopUnit->flankSupportPercentTotal();
			// if pDefender == null - use the last config of maxCombatStr() where pAttacker == this, else - use the pDefender to find the best attacker
			if (pDefender != NULL)
			{
				int iTmpCurrDefenderCombatStr = pDefender->currCombatStr(NULL, pLoopUnit, NULL, true);
				iTmpCurrDefenderCombatStr -= ((iTmpCurrDefenderCombatStr * iFlankSupportPercent)/100);

				if (iTmpCurrDefenderCombatStr < iLowestCurrDefenderCombatStr)
				{
					iLowestCurrDefenderCombatStr = iTmpCurrDefenderCombatStr;
					pBestUnit = pLoopUnit;
				}
			}
			else
			{
				//TB Combat Mods begin
				int iTmpCurrCombatStr = pLoopUnit->currCombatStr(pPlot, pLoopUnit, NULL, true);
				iTmpCurrCombatStr = ((iTmpCurrCombatStr * iFlankSupportPercent)/100);
				//TB Combat Mods end

				if (iTmpCurrCombatStr > iBestCurrCombatStr)
				{
					iBestCurrCombatStr = iTmpCurrCombatStr;
					pBestUnit = pLoopUnit;
				}
			}
		}
	}

	if (pBestUnit != NULL)
	{
		pBestUnit->setSupportCount(1);
		pAttacker->setAttackerFirstFlankSupportingUnit(pBestUnit);
		iBestFlankSupport = (((pBestUnit->currCombatStr(pPlot, pLoopUnit, NULL, true))* pBestUnit->flankSupportPercentTotal())/100);
	}

	return iBestFlankSupport;
}

int CvUnit::getAttackerSecondFlankSupportValue(const CvPlot* aPlot, const CvPlot* pPlot, const CvUnit* pDefender) const
{
	PROFILE_FUNC();

	CvUnit* pBestUnit;
	CvUnit* pAttacker;

	int iBestCurrCombatStr = 0;
	int iLowestCurrDefenderCombatStr = 0;
	int iBestFlankSupport = 0;

	int iFlankSupportPercent = 0;

	foreach_(const CvUnit* pLoopUnit, aPlot->units())
	{
		if (pLoopUnit->isAttacking())
		{
			pAttacker = pLoopUnit;
		}

		if (pLoopUnit->getTeam() == getTeam() && !(pLoopUnit->isAttacking()) && !(pLoopUnit->isSupporting()) && (pLoopUnit->canAttack()) && (pLoopUnit->isFlankSupporter()))
		{
			iFlankSupportPercent = pLoopUnit->flankSupportPercentTotal();
			// if pDefender == null - use the last config of maxCombatStr() where pAttacker == this, else - use the pDefender to find the best attacker
			if (pDefender != NULL)
			{
				int iTmpCurrDefenderCombatStr = pDefender->currCombatStr(NULL, pLoopUnit, NULL, true);
				iTmpCurrDefenderCombatStr -= ((iTmpCurrDefenderCombatStr * iFlankSupportPercent)/100);

				if (iTmpCurrDefenderCombatStr < iLowestCurrDefenderCombatStr)
				{
					iLowestCurrDefenderCombatStr = iTmpCurrDefenderCombatStr;
					pBestUnit = pLoopUnit;
				}
			}
			else
			{
				//TB Combat Mods begin
				int iTmpCurrCombatStr = pLoopUnit->currCombatStr(pPlot, pLoopUnit, NULL, true);
				iTmpCurrCombatStr = ((iTmpCurrCombatStr * iFlankSupportPercent)/100);
				//TB Combat Mods end

				if (iTmpCurrCombatStr > iBestCurrCombatStr)
				{
					iBestCurrCombatStr = iTmpCurrCombatStr;
					pBestUnit = pLoopUnit;
				}
			}
		}
	}

	if (pBestUnit != NULL)
	{
		pBestUnit->setSupportCount(1);
		pAttacker->setAttackerSecondFlankSupportingUnit(pBestUnit);
		iBestFlankSupport = (((pBestUnit->currCombatStr(pPlot, pLoopUnit, NULL, true))* pBestUnit->flankSupportPercentTotal())/100);
	}

	return iBestFlankSupport;
}

CvUnit* CvUnit::getAttackerFirstFrontSupportingUnit() const
{
	return getUnit(afIUnit);
}

CvUnit* CvUnit::getAttackerSecondFrontSupportingUnit() const
{
	return getUnit(afIIUnit);
}

CvUnit* CvUnit::getAttackerFirstShortRangeSupportingUnit() const
{
	return getUnit(asrIUnit);
}

CvUnit* CvUnit::getAttackerSecondShortRangeSupportingUnit() const
{
	return getUnit(asrIIUnit);
}

CvUnit* CvUnit::getAttackerFirstMediumRangeSupportingUnit() const
{
	return getUnit(amrIUnit);
}

CvUnit* CvUnit::getAttackerSecondMediumRangeSupportingUnit() const
{
	return getUnit(amrIIUnit);
}

CvUnit* CvUnit::getAttackerFirstLongRangeSupportingUnit() const
{
	return getUnit(alrIUnit);
}

CvUnit* CvUnit::getAttackerSecondLongRangeSupportingUnit() const
{
	return getUnit(alrIIUnit);
}

CvUnit* CvUnit::getAttackerFirstFlankSupportingUnit() const
{
	return getUnit(aflIUnit);
}

CvUnit* CvUnit::getAttackerSecondFlankSupportingUnit() const
{
	return getUnit(aflIIUnit);
}

void CvUnit::setAttackerFirstFrontSupportingUnit(CvUnit* pBestUnit)
{
	afIUnit = pBestUnit->getIDInfo();
}

void CvUnit::setAttackerSecondFrontSupportingUnit(CvUnit* pBestUnit)
{
	afIIUnit = pBestUnit->getIDInfo();
}

void CvUnit::setAttackerFirstShortRangeSupportingUnit(CvUnit* pBestUnit)
{
	asrIUnit = pBestUnit->getIDInfo();
}

void CvUnit::setAttackerSecondShortRangeSupportingUnit(CvUnit* pBestUnit)
{
	asrIIUnit = pBestUnit->getIDInfo();
}

void CvUnit::setAttackerFirstMediumRangeSupportingUnit(CvUnit* pBestUnit)
{
	amrIUnit = pBestUnit->getIDInfo();
}

void CvUnit::setAttackerSecondMediumRangeSupportingUnit(CvUnit* pBestUnit)
{
	amrIIUnit = pBestUnit->getIDInfo();
}

void CvUnit::setAttackerFirstLongRangeSupportingUnit(CvUnit* pBestUnit)
{
	alrIUnit = pBestUnit->getIDInfo();
}

void CvUnit::setAttackerSecondLongRangeSupportingUnit(CvUnit* pBestUnit)
{
	alrIIUnit = pBestUnit->getIDInfo();
}

void CvUnit::setAttackerFirstFlankSupportingUnit(CvUnit* pBestUnit)
{
	aflIUnit = pBestUnit->getIDInfo();
}

void CvUnit::setAttackerSecondFlankSupportingUnit(CvUnit* pBestUnit)
{
	aflIIUnit = pBestUnit->getIDInfo();
}

int CvUnit::getDefenderSupportValue(const CvUnit* pAttacker) const
{
	if (!GC.getGame().isOption(GAMEOPTION_STRENGTH_IN_NUMBERS))
	{
		return 0;
	}
	PROFILE_FUNC();

	CvPlot* pPlot = plot();

	int iTotalSupport = 0;
	iTotalSupport += getDefenderFirstFrontSupportValue(pAttacker, pPlot);
	iTotalSupport += getDefenderSecondFrontSupportValue(pAttacker, pPlot);
	iTotalSupport += getDefenderFirstShortRangeSupportValue(pAttacker, pPlot);
	iTotalSupport += getDefenderSecondShortRangeSupportValue(pAttacker, pPlot);
	iTotalSupport += getDefenderFirstMediumRangeSupportValue(pAttacker, pPlot);
	iTotalSupport += getDefenderSecondMediumRangeSupportValue(pAttacker, pPlot);
	iTotalSupport += getDefenderFirstLongRangeSupportValue(pAttacker, pPlot);
	iTotalSupport += getDefenderSecondLongRangeSupportValue(pAttacker, pPlot);
	iTotalSupport += getDefenderFirstFlankSupportValue(pAttacker, pPlot);
	iTotalSupport += getDefenderSecondFlankSupportValue(pAttacker, pPlot);

	return iTotalSupport;
}

int CvUnit::getDefenderFirstFrontSupportValue(const CvUnit* pAttacker, const CvPlot* pPlot) const
{
	PROFILE_FUNC();

	CvUnit* pBestUnit = NULL;
	CvUnit* pDefender = NULL;

	int iBestCurrCombatStr = 0;
	int iStrongestCurrCombatStr = 0;

	int iFrontSupportPercent = 0;

	foreach_(CvUnit* pLoopUnit, pPlot->units())
	{
		if (pLoopUnit->isDefending())
		{
			pDefender = pLoopUnit;
		}
		if (pLoopUnit->getTeam() == getTeam() && !(pLoopUnit->isDefending()) && !(pLoopUnit->isSupporting()) && (pLoopUnit->canDefend()) && (pLoopUnit->isFrontSupporter()))
		{
			iFrontSupportPercent = pLoopUnit->frontSupportPercentTotal();
			int iTmpCurrDefenderCombatStr = currCombatStr(pPlot, pAttacker, NULL, true);
			iTmpCurrDefenderCombatStr -= ((iTmpCurrDefenderCombatStr * iFrontSupportPercent)/100);

			if (iTmpCurrDefenderCombatStr > iStrongestCurrCombatStr)
			{
				iStrongestCurrCombatStr = iTmpCurrDefenderCombatStr;
				pBestUnit = pLoopUnit;
			}
		}
	}

	if (pBestUnit != NULL)
	{
		pBestUnit->setSupportCount(1);
		pDefender->setDefenderFirstFrontSupportingUnit(pBestUnit);
	}

	return iStrongestCurrCombatStr;
}

int CvUnit::getDefenderSecondFrontSupportValue(const CvUnit* pAttacker, const CvPlot* pPlot) const
{
	PROFILE_FUNC();

	CvUnit* pBestUnit = NULL;
	CvUnit* pDefender = NULL;

	int iBestCurrCombatStr = 0;
	int iStrongestCurrCombatStr = 0;

	int iFrontSupportPercent = 0;

	foreach_(CvUnit* pLoopUnit, pPlot->units())
	{
		if (pLoopUnit->isDefending())
		{
			pDefender = pLoopUnit;
		}

		if (pLoopUnit->getTeam() == getTeam() && !(pLoopUnit->isDefending()) && !(pLoopUnit->isSupporting()) && (pLoopUnit->canDefend()) && (pLoopUnit->isFrontSupporter()))
		{
			iFrontSupportPercent = pLoopUnit->frontSupportPercentTotal();
			int iTmpCurrDefenderCombatStr = currCombatStr(pPlot, pAttacker, NULL, true);
			iTmpCurrDefenderCombatStr -= ((iTmpCurrDefenderCombatStr * iFrontSupportPercent)/100);

			if (iTmpCurrDefenderCombatStr > iStrongestCurrCombatStr)
			{
				iStrongestCurrCombatStr = iTmpCurrDefenderCombatStr;
				pBestUnit = pLoopUnit;
			}
		}
	}

	if (pBestUnit != NULL)
	{
		pBestUnit->setSupportCount(1);
		pDefender->setDefenderSecondFrontSupportingUnit(pBestUnit);
	}

	return iStrongestCurrCombatStr;
}

int CvUnit::getDefenderFirstShortRangeSupportValue(const CvUnit* pAttacker, const CvPlot* pPlot) const
{
	PROFILE_FUNC();

	CvUnit* pBestUnit = NULL;
	CvUnit* pDefender = NULL;

	int iBestCurrCombatStr = 0;
	int iStrongestCurrCombatStr = 0;

	int iShortRangeSupportPercent = 0;

	foreach_(CvUnit* pLoopUnit, pPlot->units())
	{
		if (pLoopUnit->isDefending())
		{
			pDefender = pLoopUnit;
		}

		if (pLoopUnit->getTeam() == getTeam() && !(pLoopUnit->isDefending()) && !(pLoopUnit->isSupporting()) && (pLoopUnit->canDefend()) && (pLoopUnit->isShortRangeSupporter()))
		{
			iShortRangeSupportPercent = pLoopUnit->shortRangeSupportPercentTotal();
			int iTmpCurrDefenderCombatStr = currCombatStr(pPlot, pAttacker, NULL, true);
			iTmpCurrDefenderCombatStr -= ((iTmpCurrDefenderCombatStr * iShortRangeSupportPercent)/100);

			if (iTmpCurrDefenderCombatStr > iStrongestCurrCombatStr)
			{
				iStrongestCurrCombatStr = iTmpCurrDefenderCombatStr;
				pBestUnit = pLoopUnit;
			}
		}
	}

	if (pBestUnit != NULL)
	{
		pBestUnit->setSupportCount(1);
		pDefender->setDefenderFirstShortRangeSupportingUnit(pBestUnit);
	}

	return iStrongestCurrCombatStr;
}

int CvUnit::getDefenderSecondShortRangeSupportValue(const CvUnit* pAttacker, const CvPlot* pPlot) const
{
	PROFILE_FUNC();

	CvUnit* pBestUnit = NULL;
	CvUnit* pDefender = NULL;

	int iBestCurrCombatStr = 0;
	int iStrongestCurrCombatStr = 0;

	int iShortRangeSupportPercent = 0;

	foreach_(CvUnit* pLoopUnit, pPlot->units())
	{
		if (pLoopUnit->isDefending())
		{
			pDefender = pLoopUnit;
		}

		if (pLoopUnit->getTeam() == getTeam() && !(pLoopUnit->isDefending()) && !(pLoopUnit->isSupporting()) && (pLoopUnit->canDefend()) && (pLoopUnit->isShortRangeSupporter()))
		{
			iShortRangeSupportPercent = pLoopUnit->shortRangeSupportPercentTotal();
			int iTmpCurrDefenderCombatStr = currCombatStr(pPlot, pAttacker, NULL, true);
			iTmpCurrDefenderCombatStr -= ((iTmpCurrDefenderCombatStr * iShortRangeSupportPercent)/100);

			if (iTmpCurrDefenderCombatStr > iStrongestCurrCombatStr)
			{
				iStrongestCurrCombatStr = iTmpCurrDefenderCombatStr;
				pBestUnit = pLoopUnit;
			}
		}
	}

	if (pBestUnit != NULL)
	{
		pBestUnit->setSupportCount(1);
		pDefender->setDefenderSecondShortRangeSupportingUnit(pBestUnit);
	}

	return iStrongestCurrCombatStr;
}

int CvUnit::getDefenderFirstMediumRangeSupportValue(const CvUnit* pAttacker, const CvPlot* pPlot) const
{
	PROFILE_FUNC();

	CvUnit* pBestUnit = NULL;
	CvUnit* pDefender = NULL;

	int iBestCurrCombatStr = 0;
	int iStrongestCurrCombatStr = 0;

	int iMediumRangeSupportPercent = 0;

	foreach_(CvUnit* pLoopUnit, pPlot->units())
	{
		if (pLoopUnit->isDefending())
		{
			pDefender = pLoopUnit;
		}

		if (pLoopUnit->getTeam() == getTeam() && !(pLoopUnit->isDefending()) && !(pLoopUnit->isSupporting()) && (pLoopUnit->canDefend()) && (pLoopUnit->isMediumRangeSupporter()))
		{
			iMediumRangeSupportPercent = pLoopUnit->mediumRangeSupportPercentTotal();
			int iTmpCurrDefenderCombatStr = currCombatStr(pPlot, pAttacker, NULL, true);
			iTmpCurrDefenderCombatStr -= ((iTmpCurrDefenderCombatStr * iMediumRangeSupportPercent)/100);

			if (iTmpCurrDefenderCombatStr > iStrongestCurrCombatStr)
			{
				iStrongestCurrCombatStr = iTmpCurrDefenderCombatStr;
				pBestUnit = pLoopUnit;
			}
		}
	}

	if (pBestUnit != NULL)
	{
		pBestUnit->setSupportCount(1);
		pDefender->setDefenderFirstMediumRangeSupportingUnit(pBestUnit);
	}

	return iStrongestCurrCombatStr;
}

int CvUnit::getDefenderSecondMediumRangeSupportValue(const CvUnit* pAttacker, const CvPlot* pPlot) const
{
	PROFILE_FUNC();

	CvUnit* pBestUnit = NULL;
	CvUnit* pDefender = NULL;

	int iBestCurrCombatStr = 0;
	int iStrongestCurrCombatStr = 0;

	int iMediumRangeSupportPercent = 0;

	foreach_(CvUnit* pLoopUnit, pPlot->units())
	{
		if (pLoopUnit->isDefending())
		{
			pDefender = pLoopUnit;
		}

		if (pLoopUnit->getTeam() == getTeam() && !(pLoopUnit->isDefending()) && !(pLoopUnit->isSupporting()) && (pLoopUnit->canDefend()) && (pLoopUnit->isMediumRangeSupporter()))
		{
			iMediumRangeSupportPercent = pLoopUnit->mediumRangeSupportPercentTotal();
			int iTmpCurrDefenderCombatStr = currCombatStr(pPlot, pAttacker, NULL, true);
			iTmpCurrDefenderCombatStr -= ((iTmpCurrDefenderCombatStr * iMediumRangeSupportPercent)/100);

			if (iTmpCurrDefenderCombatStr > iStrongestCurrCombatStr)
			{
				iStrongestCurrCombatStr = iTmpCurrDefenderCombatStr;
				pBestUnit = pLoopUnit;
			}
		}
	}

	if (pBestUnit != NULL)
	{
		pBestUnit->setSupportCount(1);
		pDefender->setDefenderSecondMediumRangeSupportingUnit(pBestUnit);
	}

	return iStrongestCurrCombatStr;
}

int CvUnit::getDefenderFirstLongRangeSupportValue(const CvUnit* pAttacker, const CvPlot* pPlot) const
{
	PROFILE_FUNC();

	CvUnit* pBestUnit = NULL;
	CvUnit* pDefender = NULL;

	int iBestCurrCombatStr = 0;
	int iStrongestCurrCombatStr = 0;

	int iLongRangeSupportPercent = 0;

	foreach_(CvUnit* pLoopUnit, pPlot->units())
	{
		if (pLoopUnit->isDefending())
		{
			pDefender = pLoopUnit;
		}

		if (pLoopUnit->getTeam() == getTeam() && !(pLoopUnit->isDefending()) && !(pLoopUnit->isSupporting()) && (pLoopUnit->canDefend()) && (pLoopUnit->isLongRangeSupporter()))
		{
			iLongRangeSupportPercent = pLoopUnit->longRangeSupportPercentTotal();
			int iTmpCurrDefenderCombatStr = currCombatStr(pPlot, pAttacker, NULL, true);
			iTmpCurrDefenderCombatStr -= ((iTmpCurrDefenderCombatStr * iLongRangeSupportPercent)/100);

			if (iTmpCurrDefenderCombatStr > iStrongestCurrCombatStr)
			{
				iStrongestCurrCombatStr = iTmpCurrDefenderCombatStr;
				pBestUnit = pLoopUnit;
			}
		}
	}

	if (pBestUnit != NULL)
	{
		pBestUnit->setSupportCount(1);
		pDefender->setDefenderFirstLongRangeSupportingUnit(pBestUnit);
	}

	return iStrongestCurrCombatStr;
}

int CvUnit::getDefenderSecondLongRangeSupportValue(const CvUnit* pAttacker, const CvPlot* pPlot) const
{
	PROFILE_FUNC();

	CvUnit* pBestUnit = NULL;
	CvUnit* pDefender = NULL;

	int iBestCurrCombatStr = 0;
	int iStrongestCurrCombatStr = 0;

	int iLongRangeSupportPercent = 0;

	foreach_(CvUnit* pLoopUnit, pPlot->units())
	{
		if (pLoopUnit->isDefending())
		{
			pDefender = pLoopUnit;
		}

		if (pLoopUnit->getTeam() == getTeam() && !(pLoopUnit->isDefending()) && !(pLoopUnit->isSupporting()) && (pLoopUnit->canDefend()) && (pLoopUnit->isLongRangeSupporter()))
		{
			iLongRangeSupportPercent = pLoopUnit->longRangeSupportPercentTotal();
			int iTmpCurrDefenderCombatStr = currCombatStr(pPlot, pAttacker, NULL, true);
			iTmpCurrDefenderCombatStr -= ((iTmpCurrDefenderCombatStr * iLongRangeSupportPercent)/100);

			if (iTmpCurrDefenderCombatStr > iStrongestCurrCombatStr)
			{
				iStrongestCurrCombatStr = iTmpCurrDefenderCombatStr;
				pBestUnit = pLoopUnit;
			}
		}
	}

	if (pBestUnit != NULL)
	{
		pBestUnit->setSupportCount(1);
		pDefender->setDefenderSecondLongRangeSupportingUnit(pBestUnit);
	}

	return iStrongestCurrCombatStr;
}

int CvUnit::getDefenderFirstFlankSupportValue(const CvUnit* pAttacker, const CvPlot* pPlot) const
{
	PROFILE_FUNC();

	CvUnit* pBestUnit = NULL;
	CvUnit* pDefender = NULL;

	int iBestCurrCombatStr = 0;
	int iStrongestCurrCombatStr = 0;

	int iFlankSupportPercent = 0;

	foreach_(CvUnit* pLoopUnit, pPlot->units())
	{
		if (pLoopUnit->isDefending())
		{
			pDefender = pLoopUnit;
		}

		if (pLoopUnit->getTeam() == getTeam() && !(pLoopUnit->isDefending()) && !(pLoopUnit->isSupporting()) && (pLoopUnit->canDefend()) && (pLoopUnit->isFlankSupporter()))
		{
			iFlankSupportPercent = pLoopUnit->flankSupportPercentTotal();
			int iTmpCurrDefenderCombatStr = currCombatStr(pPlot, pAttacker, NULL, true);
			iTmpCurrDefenderCombatStr -= ((iTmpCurrDefenderCombatStr * iFlankSupportPercent)/100);

			if (iTmpCurrDefenderCombatStr > iStrongestCurrCombatStr)
			{
				iStrongestCurrCombatStr = iTmpCurrDefenderCombatStr;
				pBestUnit = pLoopUnit;
			}
		}
	}

	if (pBestUnit != NULL)
	{
		pBestUnit->setSupportCount(1);
		pDefender->setDefenderFirstFlankSupportingUnit(pBestUnit);
	}

	return iStrongestCurrCombatStr;
}

int CvUnit::getDefenderSecondFlankSupportValue(const CvUnit* pAttacker, const CvPlot* pPlot) const
{
	PROFILE_FUNC();

	CvUnit* pBestUnit = NULL;
	CvUnit* pDefender = NULL;

	int iBestCurrCombatStr = 0;
	int iStrongestCurrCombatStr = 0;

	int iFlankSupportPercent = 0;

	foreach_(CvUnit* pLoopUnit, pPlot->units())
	{
		if (pLoopUnit->isDefending())
		{
			pDefender = pLoopUnit;
		}

		if (pLoopUnit->getTeam() == getTeam() && !(pLoopUnit->isDefending()) && !(pLoopUnit->isSupporting()) && (pLoopUnit->canDefend()) && (pLoopUnit->isFlankSupporter()))
		{
			iFlankSupportPercent = pLoopUnit->flankSupportPercentTotal();
			int iTmpCurrDefenderCombatStr = currCombatStr(pPlot, pAttacker, NULL, true);
			iTmpCurrDefenderCombatStr -= ((iTmpCurrDefenderCombatStr * iFlankSupportPercent)/100);

			if (iTmpCurrDefenderCombatStr > iStrongestCurrCombatStr)
			{
				iStrongestCurrCombatStr = iTmpCurrDefenderCombatStr;
				pBestUnit = pLoopUnit;
			}
		}
	}

	if (pBestUnit != NULL)
	{
		pBestUnit->setSupportCount(1);
		pDefender->setDefenderSecondFlankSupportingUnit(pBestUnit);
	}

	return iStrongestCurrCombatStr;
}

CvUnit* CvUnit::getDefenderFirstFrontSupportingUnit() const
{
	return getUnit(dfIUnit);
}

CvUnit* CvUnit::getDefenderSecondFrontSupportingUnit() const
{
	return getUnit(dfIIUnit);
}

CvUnit* CvUnit::getDefenderFirstShortRangeSupportingUnit() const
{
	return getUnit(dsrIUnit);
}

CvUnit* CvUnit::getDefenderSecondShortRangeSupportingUnit() const
{
	return getUnit(dsrIIUnit);
}

CvUnit* CvUnit::getDefenderFirstMediumRangeSupportingUnit() const
{
	return getUnit(dmrIUnit);
}

CvUnit* CvUnit::getDefenderSecondMediumRangeSupportingUnit() const
{
	return getUnit(dmrIIUnit);
}

CvUnit* CvUnit::getDefenderFirstLongRangeSupportingUnit() const
{
	return getUnit(dlrIUnit);
}

CvUnit* CvUnit::getDefenderSecondLongRangeSupportingUnit() const
{
	return getUnit(dlrIIUnit);
}

CvUnit* CvUnit::getDefenderFirstFlankSupportingUnit() const
{
	return getUnit(dflIUnit);
}

CvUnit* CvUnit::getDefenderSecondFlankSupportingUnit() const
{
	return getUnit(dflIIUnit);
}

void CvUnit::setDefenderFirstFrontSupportingUnit(CvUnit* pBestUnit)
{
	dfIUnit = pBestUnit->getIDInfo();
}

void CvUnit::setDefenderSecondFrontSupportingUnit(CvUnit* pBestUnit)
{
	dfIIUnit = pBestUnit->getIDInfo();
}

void CvUnit::setDefenderFirstShortRangeSupportingUnit(CvUnit* pBestUnit)
{
	dsrIUnit = pBestUnit->getIDInfo();
}

void CvUnit::setDefenderSecondShortRangeSupportingUnit(CvUnit* pBestUnit)
{
	dsrIIUnit = pBestUnit->getIDInfo();
}

void CvUnit::setDefenderFirstMediumRangeSupportingUnit(CvUnit* pBestUnit)
{
	dmrIUnit = pBestUnit->getIDInfo();
}

void CvUnit::setDefenderSecondMediumRangeSupportingUnit(CvUnit* pBestUnit)
{
	dmrIIUnit = pBestUnit->getIDInfo();
}

void CvUnit::setDefenderFirstLongRangeSupportingUnit(CvUnit* pBestUnit)
{
	dlrIUnit = pBestUnit->getIDInfo();
}

void CvUnit::setDefenderSecondLongRangeSupportingUnit(CvUnit* pBestUnit)
{
	dlrIIUnit = pBestUnit->getIDInfo();
}

void CvUnit::setDefenderFirstFlankSupportingUnit(CvUnit* pBestUnit)
{
	dflIUnit = pBestUnit->getIDInfo();
}

void CvUnit::setDefenderSecondFlankSupportingUnit(CvUnit* pBestUnit)
{
	dflIIUnit = pBestUnit->getIDInfo();
}

bool CvUnit::isSupporting()
{
	return (m_iSupportCount > 0);
}

void CvUnit::setSupportCount(int iChange)
{
	m_iSupportCount = iChange;
}

void CvUnit::ClearSupports()
{
	CvUnit* AttackFrontOne = getAttackerFirstFrontSupportingUnit();
	if (AttackFrontOne != NULL)
	{
		AttackFrontOne->setSupportCount(0);
		afIUnit.reset();
	}
	CvUnit* AttackFrontTwo = getAttackerSecondFrontSupportingUnit();
	if (AttackFrontTwo != NULL)
	{
		AttackFrontTwo->setSupportCount(0);
		afIIUnit.reset();
	}
	CvUnit* AttackShortRangeOne = getAttackerFirstShortRangeSupportingUnit();
	if (AttackShortRangeOne != NULL)
	{
		AttackShortRangeOne->setSupportCount(0);
		asrIUnit.reset();
	}
	CvUnit* AttackShortRangeTwo = getAttackerSecondShortRangeSupportingUnit();
	if (AttackShortRangeTwo != NULL)
	{
		AttackShortRangeTwo->setSupportCount(0);
		asrIIUnit.reset();
	}
	CvUnit* AttackMediumRangeOne = getAttackerFirstMediumRangeSupportingUnit();
	if (AttackMediumRangeOne != NULL)
	{
		AttackMediumRangeOne->setSupportCount(0);
		amrIUnit.reset();
	}
	CvUnit* AttackMediumRangeTwo = getAttackerSecondMediumRangeSupportingUnit();
	if (AttackMediumRangeTwo != NULL)
	{
		AttackMediumRangeTwo->setSupportCount(0);
		amrIIUnit.reset();
	}
	CvUnit* AttackLongRangeOne = getAttackerFirstLongRangeSupportingUnit();
	if (AttackLongRangeOne != NULL)
	{
		AttackLongRangeOne->setSupportCount(0);
		alrIUnit.reset();
	}
	CvUnit* AttackLongRangeTwo = getAttackerSecondLongRangeSupportingUnit();
	if (AttackLongRangeTwo != NULL)
	{
		AttackLongRangeTwo->setSupportCount(0);
		alrIIUnit.reset();
	}
	CvUnit* AttackFlankOne = getAttackerFirstFlankSupportingUnit();
	if (AttackFlankOne != NULL)
	{
		AttackFlankOne->setSupportCount(0);
		aflIUnit.reset();
	}
	CvUnit* AttackFlankTwo = getAttackerSecondFlankSupportingUnit();
	if (AttackFlankTwo != NULL)
	{
		AttackFlankTwo->setSupportCount(0);
		aflIIUnit.reset();
	}
	CvUnit* DefendFrontOne = getDefenderFirstFrontSupportingUnit();
	if (DefendFrontOne != NULL)
	{
		DefendFrontOne->setSupportCount(0);
		dfIUnit.reset();
	}
	CvUnit* DefendFrontTwo = getDefenderSecondFrontSupportingUnit();
	if (DefendFrontTwo != NULL)
	{
		DefendFrontTwo->setSupportCount(0);
		dfIIUnit.reset();
	}
	CvUnit* DefendShortRangeOne = getDefenderFirstShortRangeSupportingUnit();
	if (DefendShortRangeOne != NULL)
	{
		DefendShortRangeOne->setSupportCount(0);
		dsrIUnit.reset();
	}
	CvUnit* DefendShortRangeTwo = getDefenderSecondShortRangeSupportingUnit();
	if (DefendShortRangeTwo != NULL)
	{
		DefendShortRangeTwo->setSupportCount(0);
		dsrIIUnit.reset();
	}
	CvUnit* DefendMediumRangeOne = getDefenderFirstMediumRangeSupportingUnit();
	if (DefendMediumRangeOne != NULL)
	{
		DefendMediumRangeOne->setSupportCount(0);
		dmrIUnit.reset();
	}
	CvUnit* DefendMediumRangeTwo = getDefenderSecondMediumRangeSupportingUnit();
	if (DefendMediumRangeTwo != NULL)
	{
		DefendMediumRangeTwo->setSupportCount(0);
		dmrIIUnit.reset();
	}
	CvUnit* DefendLongRangeOne = getDefenderFirstLongRangeSupportingUnit();
	if (DefendLongRangeOne != NULL)
	{
		DefendLongRangeOne->setSupportCount(0);
		dlrIUnit.reset();
	}
	CvUnit* DefendLongRangeTwo = getDefenderSecondLongRangeSupportingUnit();
	if (DefendLongRangeTwo != NULL)
	{
		DefendLongRangeTwo->setSupportCount(0);
		dlrIIUnit.reset();
	}
	CvUnit* DefendFlankOne = getDefenderFirstFlankSupportingUnit();
	if (DefendFlankOne != NULL)
	{
		DefendFlankOne->setSupportCount(0);
		dflIUnit.reset();
	}
	CvUnit* DefendFlankTwo = getDefenderSecondFlankSupportingUnit();
	if (DefendFlankTwo != NULL)
	{
		DefendFlankTwo->setSupportCount(0);
		dflIIUnit.reset();
	}
}

#endif // #ifdef STRENGTH_IN_NUMBERS

int CvUnit::getOngoingTrainingCount(UnitCombatTypes eUnitCombatType) const
{
	FASSERT_BOUNDS(0, GC.getNumUnitCombatInfos(), eUnitCombatType);

	const UnitCombatKeyedInfo* info = findUnitCombatKeyedInfo(eUnitCombatType);

	return info == NULL ? 0 : info->m_iOngoingTrainingCount;
}

void CvUnit::changeOngoingTrainingCount(UnitCombatTypes eUnitCombatType, int iChange)
{
	FASSERT_BOUNDS(0, GC.getNumUnitCombatInfos(), eUnitCombatType);

	if (iChange != 0)
	{
		UnitCombatKeyedInfo* info = findOrCreateUnitCombatKeyedInfo(eUnitCombatType);

		info->m_iOngoingTrainingCount += iChange;
	}
}

void CvUnit::setOngoingTrainingCount(UnitCombatTypes eUnitCombatType, int iChange)
{
	FASSERT_BOUNDS(0, GC.getNumUnitCombatInfos(), eUnitCombatType);

	UnitCombatKeyedInfo* info = findOrCreateUnitCombatKeyedInfo(eUnitCombatType, iChange != 0);

	if (info != NULL)
	{
		info->m_iOngoingTrainingCount = iChange;
	}
}

void CvUnit::checkPromotionObsoletion()
{
	PROFILE_FUNC();

	if (isCommander())
	{
		for (int iI = GC.getNumUnitCombatInfos() - 1; iI > -1; iI--)
		{
			const UnitCombatTypes eUnitCombatX = static_cast<UnitCombatTypes>(iI);
			if (
				isHasUnitCombat(eUnitCombatX)
			&&	(
					GC.getUnitCombatInfo(eUnitCombatX).getGroupBase() > -10
					||
					GC.getUnitCombatInfo(eUnitCombatX).getQualityBase() > -10
				)
			)
			{
				setHasUnitCombat(eUnitCombatX, false);
			}
		}
	}

	while (true)
	{
		bool bRemovalMade = false;
		for (int iI = GC.getNumPromotionInfos() - 1; iI > -1; iI--)
		{
			const PromotionTypes ePromotion = static_cast<PromotionTypes>(iI);
			const CvPromotionInfo& promotionInfo = GC.getPromotionInfo(ePromotion);
			bool bPromo =
			(
				!promotionInfo.isEquipment()
#ifdef OUTBREAKS_AND_AFFLICTIONS
				&& !promotionInfo.isAffliction()
#endif
			);
			bool bPromotionFree = isPromotionFree(ePromotion);

			if (isHasPromotion(ePromotion) && !canKeepPromotion(ePromotion, bPromotionFree, true))
			{
				if (bPromotionFree)
				{
					setHasPromotion(ePromotion, false, true);
					bRemovalMade = true;
				}
				else if (bPromo)
				{
					//	The retrain mechanism relies on knowing if a promotion was free or not, but in
					//	saves from older versions we don't have that information, and many promotions that
					//	actually were free will not be flagged as such.  In such cases you'll get to retrain
					//	things you really shouldn't, but we don't allow more total retrains than your level

					changeRetrainsAvailable(1);
					setHasPromotion(ePromotion, false, false);
					bRemovalMade = true;
				}
			}
		}
		if (!bRemovalMade)
		{
			break;
		}
	}
}

int CvUnit::getColdDamage() const
{
	return m_iColdDamage;
}

void CvUnit::changeColdDamage(int iChange)
{
	if (hasImmunitytoColdDamage())
	{
		m_iColdDamage = 0;
	}
	else
	{
		m_iColdDamage += iChange;
	}
}

void CvUnit::setColdDamage(int iChange)
{
	if (hasImmunitytoColdDamage())
	{
		m_iColdDamage = 0;
	}
	else
	{
	m_iColdDamage = iChange;
	}
}

int CvUnit::getCombatPowerShots() const
{
	return m_iCombatPowerShots;
}

void CvUnit::setCombatPowerShots(int iNewValue)
{
	m_iCombatPowerShots = iNewValue;
	FASSERT_NOT_NEGATIVE(getCombatPowerShots());
}

void CvUnit::changeCombatPowerShots(int iChange)
{
	setCombatPowerShots(m_iCombatPowerShots + iChange);
}

int CvUnit::getCombatKnockbacks() const
{
	return m_iCombatKnockbacks;
}

void CvUnit::setCombatKnockbacks(int iNewValue)
{
	m_iCombatKnockbacks = iNewValue;
	FASSERT_NOT_NEGATIVE(getCombatKnockbacks());
}

void CvUnit::changeCombatKnockbacks(int iChange)
{
	setCombatKnockbacks(m_iCombatKnockbacks + iChange);
}

int CvUnit::getCombatRepels() const
{
	if (noDefensiveBonus())
	{
		return 0;
	}
	return m_iCombatRepels;
}

void CvUnit::setCombatRepels(int iNewValue)
{
	m_iCombatRepels = iNewValue;
	FASSERT_NOT_NEGATIVE(getCombatRepels());
}

void CvUnit::changeCombatRepels(int iChange)
{
	setCombatRepels(m_iCombatRepels + iChange);
}

#ifdef OUTBREAKS_AND_AFFLICTIONS
void CvUnit::checkForCritical(int iDamage, CvUnit* pOpponent)
{
	PROFILE_FUNC();

	if (!GC.getGame().isOption(GAMEOPTION_OUTBREAKS_AND_AFFLICTIONS))
	{
		return;
	}
	int iCritChance = (iDamage * 10);
	int iCritChanceModifier = pOpponent->criticalVSOpponentProbTotal(this);
	if (pOpponent->getCombatPowerShots() > 0 )
	{
		iCritChanceModifier += pOpponent->powerShotCriticalModifierTotal();
	}
	iCritChance += ((iCritChance * iCritChanceModifier)/100);
	if (GC.getGame().getSorenRandNum(10000, "CriticalHitRoll") < iCritChance)
	{
		assignCritical(pOpponent);
	}
}

void CvUnit::assignCritical(CvUnit* pOpponent)
{
	std::vector<PromotionTypes> aAvailableCriticals;
	PromotionLineTypes eAfflictionLine = NO_PROMOTIONLINE;
	int iLinePriority = 0;
	int iLowestLinePriority = MAX_INT;
	PromotionTypes eCurrentAffliction = NO_PROMOTION;
	for (int iI = 0; iI < GC.getNumPromotionLineInfos(); iI++)	//loop through promotions
	{
		if (GC.getPromotionLineInfo((PromotionLineTypes)iI).isCritical())
		{
			eAfflictionLine = (PromotionLineTypes)iI;
			iLowestLinePriority = MAX_INT;
			eCurrentAffliction = NO_PROMOTION;
			for (int iJ = 0; iJ < GC.getPromotionLineInfo(eAfflictionLine).getNumPromotions(); iJ++)
			{
				PromotionTypes eAffliction = (PromotionTypes)GC.getPromotionLineInfo(eAfflictionLine).getPromotion(iJ);
				iLinePriority = GC.getPromotionInfo(eAffliction).getLinePriority();
				if (!isHasPromotion(eAffliction) && iLinePriority < iLowestLinePriority)
				{
					iLowestLinePriority = iLinePriority;
					eCurrentAffliction = eAffliction;
				}

				const CvPromotionInfo& kCritical = GC.getPromotionInfo(eCurrentAffliction);
				PromotionTypes eCritical = (eCurrentAffliction);
				if (kCritical.isAffliction() && kCritical.isCritical())
				{
					if (canAcquirePromotion(eCritical, PromotionRequirements::Afflict) && pOpponent->canInflictCritical(eCritical))
					{
						aAvailableCriticals.push_back(eCritical);
					}
				}
			}
		}
	}
	if (aAvailableCriticals.size() > 0)
	{
		int iCritRolled = GC.getGame().getSorenRandNum(aAvailableCriticals.size(), "CriticalSelectionRoll");
		PromotionTypes eCritical = aAvailableCriticals[iCritRolled];
		setHasPromotion(eCritical, true);
		eAfflictionLine = ((PromotionLineTypes)GC.getPromotionInfo(eCritical).getPromotionLine());
		if (!hasAfflictionLine(eAfflictionLine))
		{
			GET_PLAYER(getOwner()).changePlayerWideAfflictionCount(eAfflictionLine, 1);
		}

		const CvWString szBuffer = gDLL->getText("TXT_KEY_MISC_CRITICAL_SUFFERED", pOpponent->getNameKey(), getNameKey(), GC.getPromotionInfo(eCritical).getDescription());
		AddDLLMessage(getOwner(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_POSITIVE_DINK", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_RED(), getX(), getY());
		const CvWString szBuffer2 = gDLL->getText("TXT_KEY_MISC_CRITICAL_INFLICTED", pOpponent->getNameKey(), getNameKey(), GC.getPromotionInfo(eCritical).getDescription());
		AddDLLMessage(pOpponent->getOwner(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer2, "AS2D_POSITIVE_DINK", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_GREEN(), getX(), getY());
	}
}
#endif // OUTBREAKS_AND_AFFLICTIONS


bool CvUnit::canKeepPromotion(PromotionTypes ePromotion, bool bAssertFree, bool bMessageOnFalse) const
{
	PROFILE_FUNC();

	if (ePromotion == NO_PROMOTION)
	{
		FErrorMsg("Invalid promotion");
		return false;
	}
	bool bPromo = false;

	const CvPromotionInfo& promo = GC.getPromotionInfo(ePromotion);

#ifdef OUTBREAKS_AND_AFFLICTIONS
	const bool bAfflict = promo.isAffliction();
#endif
	if (promo.isEquipment()
#ifdef OUTBREAKS_AND_AFFLICTIONS
		|| bAfflict
#endif
		)
	{
		bPromo = false;
	}
	else
	{
		bPromo = true;
	}

	const bool bIsFreePromotion = (
		bAssertFree
		||
		isPromotionFree(ePromotion)
		||
		GET_PLAYER(getOwner()).isFreePromotion(getUnitCombatType(), ePromotion)
		||
		promo.isZeroesXP()
		||
		promo.isForOffset()
	);

	if (promo.isRBombardPrereq() && !canRBombard(true))
	{
		if (bMessageOnFalse)
		{
			if (bPromo && !bIsFreePromotion)
			{
				AddDLLMessage(
					getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
					gDLL->getText(
						"TXT_KEY_MISC_OBSOLETED_PROMOTION_RBOMBARD_CAN_RETRAIN",
						getNameKey(), promo.getDescription()
					),
					"AS2D_POSITIVE_DINK", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_GREEN(), getX(), getY()
				);
			}
			else
			{
				AddDLLMessage(
					getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
					gDLL->getText(
						"TXT_KEY_MISC_OBSOLETED_PROMOTION_RBOMBARD_NO_RETRAIN",
						getNameKey(), promo.getDescription()
					),
					"AS2D_POSITIVE_DINK", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_RED(), getX(), getY()
				);
			}
		}
		return false;
	}

	if (promo.isCargoPrereq() && !isCarrier())
	{
		if (bMessageOnFalse)
		{
			if (bPromo && !bIsFreePromotion)
			{
				AddDLLMessage(
					getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
					gDLL->getText(
						"TXT_KEY_MISC_OBSOLETED_PROMOTION_CARRIER_CAN_RETRAIN",
						getNameKey(), promo.getDescription()
					),
					"AS2D_POSITIVE_DINK", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_GREEN(), getX(), getY()
				);
			}
			else
			{
				AddDLLMessage(
					getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
					gDLL->getText(
						"TXT_KEY_MISC_OBSOLETED_PROMOTION_CARRIER_NO_RETRAIN",
						getNameKey(), promo.getDescription()
					),
					"AS2D_POSITIVE_DINK", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_RED(), getX(), getY()
				);
			}
		}
		return false;
	}

	if (promo.getObsoleteTech() != NO_TECH && GET_TEAM(getTeam()).isHasTech(promo.getObsoleteTech()))
	{
		if (bMessageOnFalse)
		{
			if (bPromo && !bIsFreePromotion)
			{
				AddDLLMessage(
					getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
					gDLL->getText(
						"TXT_KEY_MISC_OBSOLETED_PROMOTION_TECH_CAN_RETRAIN",
						getNameKey(), promo.getDescription()
					),
					"AS2D_POSITIVE_DINK", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_GREEN(), getX(), getY()
				);
			}
			else
			{
				AddDLLMessage(
					getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
					gDLL->getText(
						"TXT_KEY_MISC_OBSOLETED_PROMOTION_TECH_NO_RETRAIN",
						getNameKey(), promo.getDescription()
					),
					"AS2D_POSITIVE_DINK", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_RED(), getX(), getY()
				);
			}
		}
		return false;
	}

	if (promo.isNotOnDomainType(getDomainType())
	||  promo.getPromotionLine() != NO_PROMOTIONLINE
	&&  GC.getPromotionLineInfo(promo.getPromotionLine()).isNotOnDomainType(getDomainType()))
	{
		if (bMessageOnFalse)
		{
			if (bPromo && !bIsFreePromotion)
			{
				AddDLLMessage(
					getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
					gDLL->getText(
						"TXT_KEY_MISC_OBSOLETED_PROMOTION_DOMAIN_CAN_RETRAIN",
						getNameKey(), promo.getDescription()
					),
					"AS2D_POSITIVE_DINK", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_GREEN(), getX(), getY()
				);
			}
			else
			{
				AddDLLMessage(
					getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
					gDLL->getText(
						"TXT_KEY_MISC_OBSOLETED_PROMOTION_DOMAIN_NO_RETRAIN",
						getNameKey(), promo.getDescription()
					),
					"AS2D_POSITIVE_DINK", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_RED(), getX(), getY()
				);
			}
		}
		return false;
	}

	if (!promo.isPlotPrereqsKeepAfter())
	{
		bool bValid = true;
		{
			const TerrainTypes eTerrain = plot()->getTerrainType();

			for (int iI = 0; iI < promo.getNumPrereqTerrainTypes(); iI++)
			{
				const TerrainTypes ePrereqTerrain = (TerrainTypes)promo.getPrereqTerrainType(iI);
				if (ePrereqTerrain != NO_TERRAIN)
				{
					bValid = false;
					if (ePrereqTerrain == GC.getTERRAIN_PEAK())
					{
						if (plot()->isAsPeak())
						{
							bValid = true;
							break;
						}
					}
					else if (ePrereqTerrain == GC.getTERRAIN_HILL())
					{
						if (plot()->isHills())
						{
							bValid = true;
							break;
						}
					}
					else if (ePrereqTerrain == eTerrain)
					{
						bValid = true;
						break;
					}
				}
			}
			if (!bValid)
			{
				if (bMessageOnFalse)
				{
					if (bPromo && !bIsFreePromotion)
					{
						AddDLLMessage(
							getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
							gDLL->getText(
								"TXT_KEY_MISC_OBSOLETED_PROMOTION_TERRAIN_CAN_RETRAIN",
								getNameKey(), promo.getDescription()
							),
							"AS2D_POSITIVE_DINK", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_GREEN(), getX(), getY()
						);
					}
					else
					{
						AddDLLMessage(
							getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
							gDLL->getText(
								"TXT_KEY_MISC_OBSOLETED_PROMOTION_TERRAIN_NO_RETRAIN",
								getNameKey(), promo.getDescription()
							),
							"AS2D_POSITIVE_DINK", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_RED(), getX(), getY()
						);
					}
				}
				return false;
			}
		}
		{
			const FeatureTypes eFeature = plot()->getFeatureType();

			for (int iI = 0; iI < promo.getNumPrereqFeatureTypes(); iI++)
			{
				const FeatureTypes ePrereqFeature = (FeatureTypes)promo.getPrereqFeatureType(iI);

				if (ePrereqFeature != NO_FEATURE)
				{
					if (eFeature == ePrereqFeature)
					{
						bValid = true;
						break;
					}
					else bValid = false;
				}
			}
			if (!bValid)
			{
				if (bMessageOnFalse)
				{
					if (bPromo && !bIsFreePromotion)
					{
						AddDLLMessage(
							getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
							gDLL->getText(
								"TXT_KEY_MISC_OBSOLETED_PROMOTION_FEATURE_CAN_RETRAIN",
								getNameKey(), promo.getDescription()
							),
							"AS2D_POSITIVE_DINK", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_GREEN(), getX(), getY()
						);
					}
					else
					{
						AddDLLMessage(
							getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
							gDLL->getText(
								"TXT_KEY_MISC_OBSOLETED_PROMOTION_FEATURE_NO_RETRAIN",
								getNameKey(), promo.getDescription()
							),
							"AS2D_POSITIVE_DINK", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_RED(), getX(), getY()
						);
					}
				}
				return false;
			}
		}
		{
			const BonusTypes eBonus = plot()->getBonusType(getTeam());

			for (int iI = 0; iI < promo.getNumPrereqPlotBonusTypes(); iI++)
			{
				const BonusTypes ePrereqBonus = (BonusTypes)promo.getPrereqPlotBonusType(iI);
				if (ePrereqBonus != NO_BONUS)
				{
					bValid = false;
					if (eBonus == ePrereqBonus)
					{
						bValid = true;
						break;
					}
				}
			}
			if (!bValid)
			{
				if (bMessageOnFalse)
				{
					if (bPromo && !bIsFreePromotion)
					{
						AddDLLMessage(
							getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
							gDLL->getText(
								"TXT_KEY_MISC_OBSOLETED_PROMOTION_PLOT_BONUS_CAN_RETRAIN",
								getNameKey(), promo.getDescription()
							),
							"AS2D_POSITIVE_DINK", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_GREEN(), getX(), getY()
						);
					}
					else
					{
						AddDLLMessage(
							getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
							gDLL->getText(
								"TXT_KEY_MISC_OBSOLETED_PROMOTION_PLOT_BONUS_NO_RETRAIN",
								getNameKey(), promo.getDescription()
							),
							"AS2D_POSITIVE_DINK", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_RED(), getX(), getY()
						);
					}
				}
				return false;
			}
		}
		{
			//Improvements and buildings are OR statements between all of them.
			bValid = false;
			bool bRequire = false;
			const ImprovementTypes eImprovement = plot()->getImprovementType();

			for (int iI = 0; iI < promo.getNumPrereqImprovementTypes(); iI++)
			{
				const ImprovementTypes ePrereqImprovement = (ImprovementTypes)promo.getPrereqImprovementType(iI);

				if (ePrereqImprovement != NO_IMPROVEMENT)
				{
					bRequire = true;
					if (ePrereqImprovement == GC.getIMPROVEMENT_CITY())
					{
						if (plot()->isCity(true))
						{
							bValid = true;
							break;
						}
					}
					if (eImprovement == ePrereqImprovement)
					{
						bValid = true;
						break;
					}
				}
			}
			const int iNumPrereqLocalBuilding = promo.getNumPrereqLocalBuildingTypes();

			if (!bValid && iNumPrereqLocalBuilding > 0)
			{
				bRequire = true;
				for (int iI = 0; iI < iNumPrereqLocalBuilding; iI++)
				{
					if (plot()->isCity(false))
					{
						const CvCity* pCity = plot()->getPlotCity();
						if (pCity->getNumActiveBuilding((BuildingTypes)promo.getPrereqLocalBuildingType(iI)) > 0)
						{
							bValid = true;
							break;
						}
					}
				}
			}
			if (bRequire && !bValid)
			{
				if (bMessageOnFalse)
				{
					if (bPromo && !bIsFreePromotion)
					{
						AddDLLMessage(
							getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
							gDLL->getText(
								"TXT_KEY_MISC_OBSOLETED_PROMOTION_IMP_CITY_CAN_RETRAIN",
								getNameKey(), promo.getDescription()
							),
							"AS2D_POSITIVE_DINK", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_GREEN(), getX(), getY()
						);
					}
					else
					{
						AddDLLMessage(
							getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
							gDLL->getText(
								"TXT_KEY_MISC_OBSOLETED_PROMOTION_IMP_CITY_NO_RETRAIN",
								getNameKey(), promo.getDescription()
							),
							"AS2D_POSITIVE_DINK", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_RED(), getX(), getY()
						);
					}
				}
				return false;
			}
			//Improvements and buildings are OR statements between all of them.
		}
	}

	if (!bIsFreePromotion)
	{
#ifdef OUTBREAKS_AND_AFFLICTIONS
		if (!bAfflict)
#endif
		{
			const PromotionTypes ePromotionPrerequisite = (PromotionTypes)promo.getPrereqPromotion();
			const PromotionTypes ePromotionPrerequisite1 = (PromotionTypes)promo.getPrereqOrPromotion1();
			const PromotionTypes ePromotionPrerequisite2 = (PromotionTypes)promo.getPrereqOrPromotion2();

			if (ePromotionPrerequisite != NO_PROMOTION && !isHasPromotion(ePromotionPrerequisite)
			|| (ePromotionPrerequisite1 != NO_PROMOTION || ePromotionPrerequisite2 != NO_PROMOTION)
			&& (ePromotionPrerequisite1 == NO_PROMOTION || !isHasPromotion(ePromotionPrerequisite1))
			&& (ePromotionPrerequisite2 == NO_PROMOTION || !isHasPromotion(ePromotionPrerequisite2)))
			{
				if (bMessageOnFalse)
				{
					if (bPromo && !isPromotionFree(ePromotion))
					{
						AddDLLMessage(
							getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
							gDLL->getText(
								"TXT_KEY_MISC_OBSOLETED_PROMOTION_PROMOPREREQ_CAN_RETRAIN",
								getNameKey(), promo.getDescription()
							),
							"AS2D_POSITIVE_DINK", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_GREEN(), getX(), getY()
						);
					}
					else
					{
						AddDLLMessage(
							getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
							gDLL->getText(
								"TXT_KEY_MISC_OBSOLETED_PROMOTION_PROMOPREREQ_NO_RETRAIN",
								getNameKey(), promo.getDescription()
							),
							"AS2D_POSITIVE_DINK", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_RED(), getX(), getY()
						);
					}
				}
				return false;
			}
		}
	}

	if (!isPromotionValid(ePromotion, bIsFreePromotion, true))
	{
		if (bMessageOnFalse)
		{
			if (bPromo && !bIsFreePromotion)
			{
				AddDLLMessage(
					getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
					gDLL->getText(
						"TXT_KEY_MISC_OBSOLETED_PROMOTION_INVALIDATE_CAN_RETRAIN",
						getNameKey(), promo.getDescription()
					),
					"AS2D_POSITIVE_DINK", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_GREEN(), getX(), getY()
				);
			}
			else
			{
				AddDLLMessage(
					getOwner(), true, GC.getEVENT_MESSAGE_TIME(),
					gDLL->getText(
						"TXT_KEY_MISC_OBSOLETED_PROMOTION_INVALIDATE_NO_RETRAIN",
						getNameKey(), promo.getDescription()
					),
					"AS2D_POSITIVE_DINK", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_RED(), getX(), getY()
				);
			}
		}
		return false;
	}
	return true;
}

int CvUnit::getPromotionFreeCount(PromotionTypes ePromotion) const
{
	FASSERT_BOUNDS(0, GC.getNumPromotionInfos(), ePromotion);

	const PromotionKeyedInfo* info = findPromotionKeyedInfo(ePromotion);

	return info == NULL ? 0 : info->m_iPromotionFreeCount;
}

bool CvUnit::isPromotionFree(PromotionTypes ePromotion) const
{
	return getPromotionFreeCount(ePromotion) > 0;
}

void CvUnit::setPromotionFreeCount(PromotionTypes ePromotion, int iChange)
{
	FASSERT_BOUNDS(0, GC.getNumPromotionInfos(), ePromotion);

	PromotionKeyedInfo* info = findOrCreatePromotionKeyedInfo(ePromotion, iChange != 0);

	if (info != NULL)
	{
		info->m_iPromotionFreeCount = iChange;
	}
}

void CvUnit::checkFreetoCombatClass()
{
	for (int iI = GC.getNumUnitCombatInfos() -1; iI > -1; iI--)
	{
		if (isHasUnitCombat(static_cast<UnitCombatTypes>(iI)))
		{
			for (int iK = GC.getNumPromotionInfos() - 1; iK > -1; iK--)
			{
				const PromotionTypes ePromo = static_cast<PromotionTypes>(iK);
				const CvPromotionInfo& promoInfo = GC.getPromotionInfo(ePromo);

				if (promoInfo.isFreetoUnitCombat(iI))
				{
					PromotionRequirements::flags promoFlags = PromotionRequirements::None;

					if (promoInfo.isEquipment()) promoFlags |= PromotionRequirements::Equip;
#ifdef OUTBREAKS_AND_AFFLICTIONS
					if (promoInfo.isAffliction()) promoFlags |= PromotionRequirements::Afflict;
#endif
					if (promoFlags == PromotionRequirements::None) promoFlags = PromotionRequirements::Promote;

					if (canAcquirePromotion(ePromo, promoFlags))
					{
						setHasPromotion(ePromo, true, true);
					}
				}
			}
		}
	}
}
//TB Combat Mods end

bool CvUnit::meetsUnitSelectionCriteria(const CvUnitSelectionCriteria* criteria) const
{
	if (criteria != NULL)
	{
		if (criteria->m_eUnitAI != NO_UNITAI && AI_getUnitAIType() != criteria->m_eUnitAI)
		{
			return false;
		}

		if ((criteria->m_bNoNegativeProperties || criteria->m_bPropertyBeneficial)
		&& AI_beneficialPropertyValueToCity(NULL, NO_PROPERTY) < 0)
		{
			return false;
		}

		if (criteria->m_eProperty != NO_PROPERTY)
		{
			const int iPropertyDelta = AI_beneficialPropertyValueToCity(NULL, criteria->m_eProperty);

			if (iPropertyDelta == 0)
			{
				return false;
			}
			if (iPropertyDelta > 0)
			{
				if (!criteria->m_bPropertyBeneficial)
				{
					return false;
				}
			}
			else if (criteria->m_bPropertyBeneficial)
			{
				return false;
			}
		}

		if (criteria->m_bIsHealer)
		{
			if (criteria->m_eHealUnitCombat == NO_UNITCOMBAT && ( getSameTileHeal() == 0 && getAdjacentTileHeal() == 0 ))
			{
				return false;
			}
			if (getBestHealingTypeConst() != criteria->m_eHealUnitCombat || getNumHealSupportTotal() < 1)
			{
				return false;
			}
		}

		if (criteria->m_bIsCommander && !isCommander())
		{
			return false;
		}
	}

	return true;
}

bool CvUnit::shouldUseWithdrawalOddsCap() const
{
    static bool bCached = false;
    static bool bCachedResult;

    if ( bCached )
    {
        return bCachedResult;
    }

    bCachedResult = isPursuitinUse();
    bCached = true;

    return bCachedResult;
}

bool CvUnit::isPursuitinUse() const
{
	bool bInUse = false;
	int iI;

	for (iI = 0; iI < GC.getNumUnitInfos(); iI++)
	{
		if (GC.getUnitInfo((UnitTypes)iI).getPursuit() > 0)
		{
			bInUse = true;
		}
	}
	if (!bInUse)
	{
		for (iI = 0; iI < GC.getNumPromotionInfos(); iI++)
		{
			if (GC.getPromotionInfo((PromotionTypes)iI).getPursuitChange() > 0)
			{
				bInUse = true;
			}
		}
	}
	return bInUse;
}

bool CvUnit::canSwitchEquipment(PromotionTypes eEquipment) const
{
	PROFILE_FUNC();

	FASSERT_BOUNDS(NO_PROMOTION, GC.getNumPromotionInfos(), eEquipment);

	if (eEquipment == NO_PROMOTION
	|| getUnitCombatType() == NO_UNITCOMBAT
	|| isHasPromotion(eEquipment))
	{
		return false;
	}

	if (!isPromotionValid(eEquipment))
	{
		return false;
	}
	const CvPromotionInfo& equipment = GC.getPromotionInfo(eEquipment);

	if (!equipment.isEquipment())
	{
		return false;
	}
	CvCity* pCity = plot()->getPlotCity();

	if (!pCity->isFreePromotion(eEquipment))
	{
		return false;
	}

	if (equipment.getPromotionLine() != NO_PROMOTIONLINE)
	{
		bool bValid = false;
		for (int iI = 0; iI < GC.getNumPromotionInfos(); iI++)
		{
			const PromotionTypes ePromoToReplace = static_cast<PromotionTypes>(iI);
			const CvPromotionInfo& promoX = GC.getPromotionInfo(ePromoToReplace);

			if (promoX.isEquipment()
			&&  promoX.getPromotionLine() == equipment.getPromotionLine()
			&&  isHasPromotion(ePromoToReplace)
			&&  equipment.getLinePriority() >= promoX.getLinePriority())
			{
				bValid = true;
				break;
			}
		}
		if (!bValid)
		{
			return false;
		}
	}

	{
		const PromotionTypes ePromotionPrerequisite = (PromotionTypes)equipment.getPrereqPromotion();

		if (ePromotionPrerequisite != NO_PROMOTION && !isHasPromotion(ePromotionPrerequisite))
		{
			return false;
		}
	}
	{
		const PromotionTypes ePromotionPrerequisite1 = (PromotionTypes)equipment.getPrereqOrPromotion1();
		const PromotionTypes ePromotionPrerequisite2 = (PromotionTypes)equipment.getPrereqOrPromotion2();

		if ((ePromotionPrerequisite1 != NO_PROMOTION || ePromotionPrerequisite2 != NO_PROMOTION)
		&&  (ePromotionPrerequisite1 == NO_PROMOTION || !isHasPromotion(ePromotionPrerequisite1))
		&&  (ePromotionPrerequisite2 == NO_PROMOTION || !isHasPromotion(ePromotionPrerequisite2)))
		{
			return false;
		}
	}

	foreach_(const BonusTypes ePrereqBonus, equipment.getPrereqBonuses())
	{
		if (ePrereqBonus != NO_BONUS && !pCity->hasBonus(ePrereqBonus))
		{
			return false;
		}
	}

	if (equipment.isNotOnDomainType(getDomainType())
	||  equipment.getPromotionLine() != NO_PROMOTIONLINE
	&&  GC.getPromotionLineInfo(equipment.getPromotionLine()).isNotOnDomainType(getDomainType()))
	{
		return false;
	}

	if (equipment.getStateReligionPrereq() != NO_RELIGION
	&& GET_PLAYER(getOwner()).getStateReligion() != equipment.getStateReligionPrereq())
	{
		return false;
	}

	return true;
}

void CvUnit::reEquip(PromotionTypes eEquipment)
{
	bool bReplaced = false;

	for (int iI = 0; iI < GC.getNumPromotionInfos() && !bReplaced; iI++)
	{
		if (GC.getPromotionInfo((PromotionTypes)iI).isEquipment())
		{
			const PromotionTypes ePromoToReplace = ((PromotionTypes)iI);
			if (isHasPromotion(ePromoToReplace) && GC.getPromotionInfo(ePromoToReplace).getPromotionLine() == GC.getPromotionInfo(eEquipment).getPromotionLine())
			{
				if (GC.getPromotionInfo(ePromoToReplace).getLinePriority() == GC.getPromotionInfo(eEquipment).getLinePriority())
				{
					setHasPromotion(ePromoToReplace, false);
					bReplaced = true;
				}
			}
		}
	}
	setHasPromotion(eEquipment, true);
	//	Koshling - testing promotion readiness here is uneccessary since CvUnit::doTurn
	//	will do it.  It is alo now dangerous to do it here (or indeed anywhere but controlled
	//	places) becaue it is not thread-safe and needs to run strictly on the main thread
	//testPromotionReady();

	if (IsSelected())
	{
		gDLL->getInterfaceIFace()->playGeneralSound(GC.getPromotionInfo(eEquipment).getSound());

		gDLL->getInterfaceIFace()->setDirty(UnitInfo_DIRTY_BIT, true);

// BUG - Update Plot List - start
		gDLL->getInterfaceIFace()->setDirty(PlotListButtons_DIRTY_BIT, true);
// BUG - Update Plot List - end
	}
	else
	{
		setInfoBarDirty(true);
	}

	CvEventReporter::getInstance().unitPromoted(this, eEquipment);
}

void CvUnit::statusUpdate(PromotionTypes eStatus)
{
	bool bReplaced = false;

	for (int iI = 0; iI < GC.getNumPromotionInfos() && !bReplaced; iI++)
	{
		if (GC.getPromotionInfo((PromotionTypes)iI).isStatus())
		{
			const PromotionTypes ePromoToReplace = ((PromotionTypes)iI);
			if (isHasPromotion(ePromoToReplace) && GC.getPromotionInfo(ePromoToReplace).getPromotionLine() == GC.getPromotionInfo(eStatus).getPromotionLine())
			{
				if (GC.getPromotionInfo(ePromoToReplace).getLinePriority() != GC.getPromotionInfo(eStatus).getLinePriority())
				{
					setHasPromotion(ePromoToReplace, false, true);
					bReplaced = true;
				}
			}
		}
	}
	setHasPromotion(eStatus, true, true);
	//	Koshling - testing promotion readiness here is uneccessary since CvUnit::doTurn
	//	will do it.  It is alo now dangerous to do it here (or indeed anywhere but controlled
	//	places) becaue it is not thread-safe and needs to run strictly on the main thread
	//testPromotionReady();

	if (IsSelected())
	{
		gDLL->getInterfaceIFace()->playGeneralSound(GC.getPromotionInfo(eStatus).getSound());

		gDLL->getInterfaceIFace()->setDirty(UnitInfo_DIRTY_BIT, true);

// BUG - Update Plot List - start
		gDLL->getInterfaceIFace()->setDirty(PlotListButtons_DIRTY_BIT, true);
// BUG - Update Plot List - end
	}
	else
	{
		setInfoBarDirty(true);
	}

	//CvEventReporter::getInstance().unitPromoted(this, eStatus);
}

int CvUnit::flankingStrengthbyUnitCombatTotal(UnitCombatTypes eCombatType) const
{
	int iFStr = m_pUnitInfo->getFlankingStrengthbyUnitCombatType(eCombatType);

	iFStr += getExtraFlankingStrengthbyUnitCombatType(eCombatType);

	return std::max(0,iFStr);
}

int CvUnit::getExtraFlankingStrengthbyUnitCombatType(UnitCombatTypes eIndex) const
{
	FASSERT_BOUNDS(0, GC.getNumUnitCombatInfos(), eIndex);

	const UnitCombatKeyedInfo* info = findUnitCombatKeyedInfo(eIndex);

	const int iBaseAmount = (info == NULL ? 0 : info->m_iExtraFlankingStrengthbyUnitCombatType);

	if (!isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander != NULL)
			return iBaseAmount + pCommander->getExtraFlankingStrengthbyUnitCombatType(eIndex);
	}
	return iBaseAmount;
}


void CvUnit::changeExtraFlankingStrengthbyUnitCombatType(UnitCombatTypes eIndex, int iChange)
{
	FASSERT_BOUNDS(0, GC.getNumUnitCombatInfos(), eIndex);

	if (iChange != 0)
	{
		UnitCombatKeyedInfo* info = findOrCreateUnitCombatKeyedInfo(eIndex);

		info->m_iExtraFlankingStrengthbyUnitCombatType += iChange;
	}
}

bool CvUnit::hasExtraFlankingStrikebyUnitCombatType(UnitCombatTypes eIndex) const
{
	return (getExtraFlankingStrengthbyUnitCombatType(eIndex) != 0);
}

int CvUnit::withdrawOnTerrainTotal(TerrainTypes eTerrainType) const
{
	int iAmount = m_pUnitInfo->getWithdrawOnTerrainType(eTerrainType);

	iAmount += getExtraWithdrawOnTerrainType(eTerrainType);

	int iTotalAmount = std::max(0, iAmount);
	return iTotalAmount;
}

int CvUnit::getExtraWithdrawOnTerrainType(TerrainTypes eIndex) const
{
	FASSERT_BOUNDS(0, GC.getNumTerrainInfos(), eIndex);

	const TerrainKeyedInfo* info = findTerrainKeyedInfo(eIndex);

	const int iBaseAmount = (info == NULL ? 0 : info->m_iExtraWithdrawOnTerrainType);

	if (!isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander != NULL)
			return iBaseAmount + pCommander->getExtraWithdrawOnTerrainType(eIndex);
	}
	return iBaseAmount;
}


void CvUnit::changeExtraWithdrawOnTerrainType(TerrainTypes eIndex, int iChange)
{
	FASSERT_BOUNDS(0, GC.getNumTerrainInfos(), eIndex);

	if (iChange != 0)
	{
		TerrainKeyedInfo* info = findOrCreateTerrainKeyedInfo(eIndex);

		info->m_iExtraWithdrawOnTerrainType += iChange;
	}
}

bool CvUnit::hasExtraWithdrawOnTerrainType(TerrainTypes eIndex) const
{
	return (getExtraWithdrawOnTerrainType(eIndex) != 0);
}

int CvUnit::withdrawOnFeatureTotal(FeatureTypes eFeatureType) const
{
	int iAmount = m_pUnitInfo->getWithdrawOnFeatureType(eFeatureType);

	iAmount += getExtraWithdrawOnFeatureType(eFeatureType);

	const int iTotalAmount = std::max(0, iAmount);
	return iTotalAmount;
}

int CvUnit::getExtraWithdrawOnFeatureType(FeatureTypes eIndex) const
{
	FASSERT_BOUNDS(0, GC.getNumFeatureInfos(), eIndex);

	const FeatureKeyedInfo* info = findFeatureKeyedInfo(eIndex);

	const int iBaseAmount = (info == NULL ? 0 : info->m_iExtraWithdrawOnFeatureType);

	if (!isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander != NULL)
			return iBaseAmount + pCommander->getExtraWithdrawOnFeatureType(eIndex);
	}
	return iBaseAmount;
}


void CvUnit::changeExtraWithdrawOnFeatureType(FeatureTypes eIndex, int iChange)
{
	FASSERT_BOUNDS(0, GC.getNumFeatureInfos(), eIndex);

	if (iChange != 0)
	{
		FeatureKeyedInfo* info = findOrCreateFeatureKeyedInfo(eIndex);

		info->m_iExtraWithdrawOnFeatureType += iChange;
	}
}

bool CvUnit::hasExtraWithdrawOnFeatureType(FeatureTypes eIndex) const
{
	return (getExtraWithdrawOnFeatureType(eIndex) != 0);
}

int CvUnit::withdrawVSUnitCombatTotal(UnitCombatTypes eCombatType) const
{
	int iAmount = m_pUnitInfo->getWithdrawVSUnitCombatType(eCombatType);

	iAmount += getExtraWithdrawVSUnitCombatType(eCombatType);

	return std::max(0,iAmount);
}

int CvUnit::getExtraWithdrawVSUnitCombatType(UnitCombatTypes eIndex) const
{
	FASSERT_BOUNDS(0, GC.getNumUnitCombatInfos(), eIndex);

	const UnitCombatKeyedInfo* info = findUnitCombatKeyedInfo(eIndex);

	const int iBaseAmount = (info == NULL ? 0 : info->m_iExtraWithdrawVSUnitCombatType);

	if (!isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander != NULL)
			return iBaseAmount + pCommander->getExtraWithdrawVSUnitCombatType(eIndex);
	}
	return iBaseAmount;
}


void CvUnit::changeExtraWithdrawVSUnitCombatType(UnitCombatTypes eIndex, int iChange)
{
	FASSERT_BOUNDS(0, GC.getNumUnitCombatInfos(), eIndex);

	if (iChange != 0)
	{
		UnitCombatKeyedInfo* info = findOrCreateUnitCombatKeyedInfo(eIndex);

		info->m_iExtraWithdrawVSUnitCombatType += iChange;
	}
}

bool CvUnit::hasExtraWithdrawVSUnitCombatType(UnitCombatTypes eIndex) const
{
	return (getExtraWithdrawVSUnitCombatType(eIndex) != 0);
}

int CvUnit::pursuitVSUnitCombatTotal(UnitCombatTypes eCombatType) const
{
	int iAmount = m_pUnitInfo->getPursuitVSUnitCombatType(eCombatType);

	iAmount += getExtraPursuitVSUnitCombatType(eCombatType);

	return std::max(0,iAmount);
}

int CvUnit::getExtraPursuitVSUnitCombatType(UnitCombatTypes eIndex) const
{
	FASSERT_BOUNDS(0, GC.getNumUnitCombatInfos(), eIndex);

	const UnitCombatKeyedInfo* info = findUnitCombatKeyedInfo(eIndex);

	const int iBaseAmount = (info == NULL ? 0 : info->m_iExtraPursuitVSUnitCombatType);

	if (!isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander != NULL)
			return iBaseAmount + pCommander->getExtraPursuitVSUnitCombatType(eIndex);
	}
	return iBaseAmount;
}


void CvUnit::changeExtraPursuitVSUnitCombatType(UnitCombatTypes eIndex, int iChange)
{
	FASSERT_BOUNDS(0, GC.getNumUnitCombatInfos(), eIndex);

	if (iChange != 0)
	{
		UnitCombatKeyedInfo* info = findOrCreateUnitCombatKeyedInfo(eIndex);

		info->m_iExtraPursuitVSUnitCombatType += iChange;
	}
}

bool CvUnit::hasExtraPursuitVSUnitCombatType(UnitCombatTypes eIndex) const
{
	return (getExtraPursuitVSUnitCombatType(eIndex) != 0);
}

int CvUnit::repelVSUnitCombatTotal(UnitCombatTypes eCombatType) const
{
	if (noDefensiveBonus())
	{
		return 0;
	}
	int iAmount = m_pUnitInfo->getRepelVSUnitCombatType(eCombatType);

	iAmount += getExtraRepelVSUnitCombatType(eCombatType);

	return std::max(0,iAmount);
}

int CvUnit::getExtraRepelVSUnitCombatType(UnitCombatTypes eIndex) const
{
	if (noDefensiveBonus())
	{
		return 0;
	}
	FASSERT_BOUNDS(0, GC.getNumUnitCombatInfos(), eIndex);

	const UnitCombatKeyedInfo* info = findUnitCombatKeyedInfo(eIndex);

	const int iBaseAmount = (info == NULL ? 0 : info->m_iExtraRepelVSUnitCombatType);

	if (!isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander != NULL)
			return iBaseAmount + pCommander->getExtraRepelVSUnitCombatType(eIndex);
	}
	return iBaseAmount;
}


void CvUnit::changeExtraRepelVSUnitCombatType(UnitCombatTypes eIndex, int iChange)
{
	FASSERT_BOUNDS(0, GC.getNumUnitCombatInfos(), eIndex);

	if (iChange != 0)
	{
		UnitCombatKeyedInfo* info = findOrCreateUnitCombatKeyedInfo(eIndex);

		info->m_iExtraRepelVSUnitCombatType += iChange;
	}
}

bool CvUnit::hasExtraRepelVSUnitCombatType(UnitCombatTypes eIndex) const
{
	if (noDefensiveBonus())
	{
		return false;
	}
	return (getExtraRepelVSUnitCombatType(eIndex) != 0);
}

int CvUnit::knockbackVSUnitCombatTotal(UnitCombatTypes eCombatType) const
{
	int iAmount = m_pUnitInfo->getKnockbackVSUnitCombatType(eCombatType);

	iAmount += getExtraKnockbackVSUnitCombatType(eCombatType);

	return std::max(0, iAmount);
}

int CvUnit::getExtraKnockbackVSUnitCombatType(UnitCombatTypes eIndex) const
{
	FASSERT_BOUNDS(0, GC.getNumUnitCombatInfos(), eIndex);

	const UnitCombatKeyedInfo* info = findUnitCombatKeyedInfo(eIndex);

	const int iBaseAmount = (info == NULL ? 0 : info->m_iExtraKnockbackVSUnitCombatType);

	if (!isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander != NULL)
			return iBaseAmount + pCommander->getExtraKnockbackVSUnitCombatType(eIndex);
	}
	return iBaseAmount;
}


void CvUnit::changeExtraKnockbackVSUnitCombatType(UnitCombatTypes eIndex, int iChange)
{
	FASSERT_BOUNDS(0, GC.getNumUnitCombatInfos(), eIndex);

	if (iChange != 0)
	{
		UnitCombatKeyedInfo* info = findOrCreateUnitCombatKeyedInfo(eIndex);

		info->m_iExtraKnockbackVSUnitCombatType += iChange;
	}
}

bool CvUnit::hasExtraKnockbackVSUnitCombatType(UnitCombatTypes eIndex) const
{
	return (getExtraKnockbackVSUnitCombatType(eIndex) != 0);
}

int CvUnit::punctureVSUnitCombatTotal(UnitCombatTypes eCombatType) const
{
	int iAmount = m_pUnitInfo->getPunctureVSUnitCombatType(eCombatType);

	iAmount += getExtraPunctureVSUnitCombatType(eCombatType);

	return std::max(0,iAmount);
}

int CvUnit::getExtraPunctureVSUnitCombatType(UnitCombatTypes eIndex) const
{
	FASSERT_BOUNDS(0, GC.getNumUnitCombatInfos(), eIndex);

	const UnitCombatKeyedInfo* info = findUnitCombatKeyedInfo(eIndex);

	const int iBaseAmount = (info == NULL ? 0 : info->m_iExtraPunctureVSUnitCombatType);

	if (!isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander != NULL)
			return iBaseAmount + pCommander->getExtraPunctureVSUnitCombatType(eIndex);
	}
	return iBaseAmount;
}


void CvUnit::changeExtraPunctureVSUnitCombatType(UnitCombatTypes eIndex, int iChange)
{
	FASSERT_BOUNDS(0, GC.getNumUnitCombatInfos(), eIndex);

	if (iChange != 0)
	{
		UnitCombatKeyedInfo* info = findOrCreateUnitCombatKeyedInfo(eIndex);

		info->m_iExtraPunctureVSUnitCombatType += iChange;
	}
}

bool CvUnit::hasExtraPunctureVSUnitCombatType(UnitCombatTypes eIndex) const
{
	return (getExtraPunctureVSUnitCombatType(eIndex) != 0);
}

int CvUnit::armorVSUnitCombatTotal(UnitCombatTypes eCombatType) const
{
	int iAmount = m_pUnitInfo->getArmorVSUnitCombatType(eCombatType);

	iAmount += getExtraArmorVSUnitCombatType(eCombatType);

	return std::max(0,iAmount);
}

int CvUnit::getExtraArmorVSUnitCombatType(UnitCombatTypes eIndex) const
{
	FASSERT_BOUNDS(0, GC.getNumUnitCombatInfos(), eIndex);

	const UnitCombatKeyedInfo* info = findUnitCombatKeyedInfo(eIndex);

	const int iBaseAmount = (info == NULL ? 0 : info->m_iExtraArmorVSUnitCombatType);

	if (!isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander != NULL)
			return iBaseAmount + pCommander->getExtraArmorVSUnitCombatType(eIndex);
	}
	return iBaseAmount;
}


void CvUnit::changeExtraArmorVSUnitCombatType(UnitCombatTypes eIndex, int iChange)
{
	FASSERT_BOUNDS(0, GC.getNumUnitCombatInfos(), eIndex);

	if (iChange != 0)
	{
		UnitCombatKeyedInfo* info = findOrCreateUnitCombatKeyedInfo(eIndex);

		info->m_iExtraArmorVSUnitCombatType += iChange;
	}
}

bool CvUnit::hasExtraArmorVSUnitCombatType(UnitCombatTypes eIndex) const
{
	return (getExtraArmorVSUnitCombatType(eIndex) != 0);
}

int CvUnit::dodgeVSUnitCombatTotal(UnitCombatTypes eCombatType) const
{
	int iAmount = m_pUnitInfo->getDodgeVSUnitCombatType(eCombatType);

	iAmount += getExtraDodgeVSUnitCombatType(eCombatType);

	return std::max(0, iAmount);
}

int CvUnit::getExtraDodgeVSUnitCombatType(UnitCombatTypes eIndex) const
{
	FASSERT_BOUNDS(0, GC.getNumUnitCombatInfos(), eIndex);

	const UnitCombatKeyedInfo* info = findUnitCombatKeyedInfo(eIndex);

	const int iBaseAmount = (info == NULL ? 0 : info->m_iExtraDodgeVSUnitCombatType);

	if (!isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander != NULL)
			return iBaseAmount + pCommander->getExtraDodgeVSUnitCombatType(eIndex);
	}
	return iBaseAmount;
}


void CvUnit::changeExtraDodgeVSUnitCombatType(UnitCombatTypes eIndex, int iChange)
{
	FASSERT_BOUNDS(0, GC.getNumUnitCombatInfos(), eIndex);

	if (iChange != 0)
	{
		UnitCombatKeyedInfo* info = findOrCreateUnitCombatKeyedInfo(eIndex);

		info->m_iExtraDodgeVSUnitCombatType += iChange;
	}
}

bool CvUnit::hasExtraDodgeVSUnitCombatType(UnitCombatTypes eIndex) const
{
	return (getExtraDodgeVSUnitCombatType(eIndex) != 0);
}

int CvUnit::precisionVSUnitCombatTotal(UnitCombatTypes eCombatType) const
{
	int iAmount = m_pUnitInfo->getPrecisionVSUnitCombatType(eCombatType);

	iAmount += getExtraPrecisionVSUnitCombatType(eCombatType);

	return std::max(0, iAmount);
}

int CvUnit::getExtraPrecisionVSUnitCombatType(UnitCombatTypes eIndex) const
{
	FASSERT_BOUNDS(0, GC.getNumUnitCombatInfos(), eIndex);

	const UnitCombatKeyedInfo* info = findUnitCombatKeyedInfo(eIndex);

	const int iBaseAmount = (info == NULL ? 0 : info->m_iExtraPrecisionVSUnitCombatType);

	if (!isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander != NULL)
			return iBaseAmount + pCommander->getExtraPrecisionVSUnitCombatType(eIndex);
	}
	return iBaseAmount;
}

void CvUnit::changeExtraPrecisionVSUnitCombatType(UnitCombatTypes eIndex, int iChange)
{
	FASSERT_BOUNDS(0, GC.getNumUnitCombatInfos(), eIndex);

	if (iChange != 0)
	{
		UnitCombatKeyedInfo* info = findOrCreateUnitCombatKeyedInfo(eIndex);

		info->m_iExtraPrecisionVSUnitCombatType += iChange;
	}
}

bool CvUnit::hasExtraPrecisionVSUnitCombatType(UnitCombatTypes eIndex) const
{
	return (getExtraPrecisionVSUnitCombatType(eIndex) != 0);
}

int CvUnit::criticalVSUnitCombatTotal(UnitCombatTypes eCombatType) const
{
	int iAmount = m_pUnitInfo->getCriticalVSUnitCombatType(eCombatType);

	iAmount += getExtraCriticalVSUnitCombatType(eCombatType);

	return std::max(0,iAmount);
}

int CvUnit::getExtraCriticalVSUnitCombatType(UnitCombatTypes eIndex) const
{
	FASSERT_BOUNDS(0, GC.getNumUnitCombatInfos(), eIndex);

	const UnitCombatKeyedInfo* info = findUnitCombatKeyedInfo(eIndex);

	const int iBaseAmount = (info == NULL ? 0 : info->m_iExtraCriticalVSUnitCombatType);

	if (!isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander != NULL)
			return iBaseAmount + pCommander->getExtraCriticalVSUnitCombatType(eIndex);
	}
	return iBaseAmount;
}

void CvUnit::changeExtraCriticalVSUnitCombatType(UnitCombatTypes eIndex, int iChange)
{
	FASSERT_BOUNDS(0, GC.getNumUnitCombatInfos(), eIndex);

	if (iChange != 0)
	{
		UnitCombatKeyedInfo* info = findOrCreateUnitCombatKeyedInfo(eIndex);

		info->m_iExtraCriticalVSUnitCombatType += iChange;
	}
}

bool CvUnit::hasExtraCriticalVSUnitCombatType(UnitCombatTypes eIndex) const
{
	return (getExtraCriticalVSUnitCombatType(eIndex) != 0);
}

int CvUnit::roundStunVSUnitCombatTotal(UnitCombatTypes eCombatType) const
{
	int iAmount = m_pUnitInfo->getRoundStunVSUnitCombatType(eCombatType);

	iAmount += getExtraRoundStunVSUnitCombatType(eCombatType);

	return std::max(0, iAmount);
}

int CvUnit::getExtraRoundStunVSUnitCombatType(UnitCombatTypes eIndex) const
{
	FASSERT_BOUNDS(0, GC.getNumUnitCombatInfos(), eIndex);

	const UnitCombatKeyedInfo* info = findUnitCombatKeyedInfo(eIndex);

	const int iBaseAmount = (info == NULL ? 0 : info->m_iExtraRoundStunVSUnitCombatType);

	if (!isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander != NULL)
			return iBaseAmount + pCommander->getExtraRoundStunVSUnitCombatType(eIndex);
	}
	return iBaseAmount;
}

void CvUnit::changeExtraRoundStunVSUnitCombatType(UnitCombatTypes eIndex, int iChange)
{
	FASSERT_BOUNDS(0, GC.getNumUnitCombatInfos(), eIndex);

	if (iChange != 0)
	{
		UnitCombatKeyedInfo* info = findOrCreateUnitCombatKeyedInfo(eIndex);

		info->m_iExtraRoundStunVSUnitCombatType += iChange;
	}
}

bool CvUnit::hasExtraRoundStunVSUnitCombatType(UnitCombatTypes eIndex) const
{
	return (getExtraRoundStunVSUnitCombatType(eIndex) != 0);
}

int CvUnit::getExtraRoundStunProb(bool bIgnoreCommanders) const
{
	if (!bIgnoreCommanders && !isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander != NULL)
		{
			return m_iExtraRoundStunProb + pCommander->m_iExtraRoundStunProb;
		}
	}
	return m_iExtraRoundStunProb;
}

void CvUnit::changeExtraRoundStunProb(int iChange)
{
	m_iExtraRoundStunProb +=iChange;
	FASSERT_NOT_NEGATIVE(getExtraRoundStunProb());
}

int CvUnit::roundStunProbTotal() const
{
	const int iRoundStun = m_pUnitInfo->getRoundStunProb() + getExtraRoundStunProb();
	const int iRoundStunProbTotal = std::max(0, iRoundStun);

	return (iRoundStunProbTotal);
}

int CvUnit::roundStunVSOpponentProbTotal(CvUnit* pOpponent) const
{
	int iRoundStunBase = roundStunProbTotal();

	for (std::map<UnitCombatTypes, UnitCombatKeyedInfo>::const_iterator it = pOpponent->m_unitCombatKeyedInfo.begin(), end = pOpponent->m_unitCombatKeyedInfo.end(); it != end; ++it)
	{
		if (it->second.m_bHasUnitCombat)
		{
			iRoundStunBase += roundStunVSUnitCombatTotal(it->first);
		}
	}

	int iRoundStunTotal = std::max(0, iRoundStunBase);

	return iRoundStunTotal;
}

int CvUnit::getCombatStuns() const
{
	return m_iCombatStuns;
}

void CvUnit::setCombatStuns(int iNewValue)
{
	m_iCombatStuns = iNewValue;
	FASSERT_NOT_NEGATIVE(getCombatStuns());
}

void CvUnit::changeCombatStuns(int iChange)
{
	setCombatStuns(getCombatStuns() + iChange);
}

void CvUnit::checkForStun(int iDamage, CvUnit* pOpponent)
{
	PROFILE_FUNC();

	int iStunChancefromDamage = (iDamage * 100);
	int iStunChanceModifier = pOpponent->roundStunVSOpponentProbTotal(this);
	int iStunCriticalModifier = pOpponent->criticalVSOpponentProbTotal(this);
	int iStunResistance = enduranceTotal()*10;
	int iStunChanceTotal = 0;
	int iStunVolume = 0;

	if (iStunChanceModifier > 0) //|| pOpponent->dealsElectricalDamage())
	{
		if (pOpponent->getCombatPowerShots() > 0 )
		{
			iStunCriticalModifier += pOpponent->powerShotCriticalModifierTotal();
		}
		iStunChanceModifier += iStunCriticalModifier;
		//if (pOpponent->dealsElectricalDamage())
		//{
		//	iStunChanceModifier += 100;
		//}
		iStunChanceModifier -= iStunResistance;

		iStunChanceTotal = std::min(((iStunChancefromDamage * iStunChanceModifier)/100), 9500);
	}
	if (iStunChanceTotal > 0)
	{
		if (GC.getGame().getSorenRandNum(10000, "StunRoll") < iStunChanceTotal)
		{
			changeCombatStuns(1);
			iStunVolume += 1;
			if (GC.getGame().getSorenRandNum(100000, "StunRoll2") <iStunChanceTotal)
			{
				changeCombatStuns(1);
				iStunVolume += 1;
				if (GC.getGame().getSorenRandNum(1000000, "StunRoll3") <iStunChanceTotal)
				{
					changeCombatStuns(1);
					iStunVolume += 1;
				}
			}
		}
	}
	if (iStunVolume > 0)
	{

		const CvWString szBuffer = gDLL->getText("TXT_KEY_MISC_STUN_SUFFERED", pOpponent->getNameKey(), getNameKey(), iStunVolume);
		AddDLLMessage(getOwner(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_POSITIVE_DINK", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_RED(), getX(), getY());
		const CvWString szBuffer2 = gDLL->getText("TXT_KEY_MISC_STUN_INFLICTED", pOpponent->getNameKey(), getNameKey(), iStunVolume);
		AddDLLMessage(pOpponent->getOwner(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer2, "AS2D_POSITIVE_DINK", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_GREEN(), getX(), getY());
	}
}

int CvUnit::withdrawVSOpponentProbTotal(const CvUnit* pOpponent, const CvPlot* pPlot) const
{
	PROFILE_FUNC();

	TerrainTypes eTerrain = pPlot->getTerrainType();
	FeatureTypes eFeature = pPlot->getFeatureType();
	bool bHill = pPlot->isHills();
	bool bPeak = pPlot->isAsPeak();

	int iBase = withdrawalProbability();
	for (std::map<UnitCombatTypes, UnitCombatKeyedInfo>::const_iterator it = pOpponent->m_unitCombatKeyedInfo.begin(), end = pOpponent->m_unitCombatKeyedInfo.end(); it != end; ++it)
	{
		if (it->second.m_bHasUnitCombat)
		{
			iBase += withdrawVSUnitCombatTotal(it->first);
		}
	}

	for (int iI = 0; iI < GC.getNumTerrainInfos(); iI++)
	{
		if (eTerrain == (TerrainTypes)iI ||
			(bPeak && (TerrainTypes)iI == GC.getTERRAIN_PEAK()) ||
			(bHill && (TerrainTypes)iI == GC.getTERRAIN_HILL()))
		{
			iBase += withdrawOnTerrainTotal((TerrainTypes)iI);
		}
	}

	for (int iI = 0; iI < GC.getNumFeatureInfos(); iI++)
	{
		if (eFeature == (FeatureTypes)iI)
		{
			iBase += withdrawOnFeatureTotal((FeatureTypes)iI);
		}
	}

	int iTotal = std::max(0, iBase);

	if (GC.getGame().isOption(GAMEOPTION_FIGHT_OR_FLIGHT))
	{
		return iTotal;
	}

	int iGrandTotal = getDiminishingReturn(iTotal);

	return iGrandTotal;
}

int CvUnit::pursuitVSOpponentProbTotal(const CvUnit* pOpponent) const
{
	PROFILE_FUNC();

	if (!isPursuitPossible(pOpponent))
	{
		return 0;
	}

	int iBase = pursuitProbability();

	for (std::map<UnitCombatTypes, UnitCombatKeyedInfo>::const_iterator it = pOpponent->m_unitCombatKeyedInfo.begin(), end = pOpponent->m_unitCombatKeyedInfo.end(); it != end; ++it)
	{
		if (it->second.m_bHasUnitCombat)
		{
			iBase += pursuitVSUnitCombatTotal(it->first);
		}
	}
	int iTotal = std::max(0, iBase);

	return iTotal;
}

int CvUnit::repelVSOpponentProbTotal(const CvUnit* pOpponent) const
{
	if (noDefensiveBonus())
	{
		return 0;
	}
	const CvCity* pCity = plot()->getPlotCity();

	int iBase = repelTotal();

	for (std::map<UnitCombatTypes, UnitCombatKeyedInfo>::const_iterator it = pOpponent->m_unitCombatKeyedInfo.begin(), end = pOpponent->m_unitCombatKeyedInfo.end(); it != end; ++it)
	{
		if (it->second.m_bHasUnitCombat)
		{
			iBase += repelVSUnitCombatTotal(it->first);
		}

		if (plot()->isCity(false, getTeam()))
		{
			iBase += pCity->getUnitCombatRepelAgainstModifierTotal(it->first);
		}
	}

	int iTotal = std::max(0, iBase);

	return iTotal;
}

int CvUnit::knockbackVSOpponentProbTotal(const CvUnit* pOpponent) const
{
	int iBase = knockbackTotal();
	for (std::map<UnitCombatTypes, UnitCombatKeyedInfo>::const_iterator it = pOpponent->m_unitCombatKeyedInfo.begin(), end = pOpponent->m_unitCombatKeyedInfo.end(); it != end; ++it)
	{
		if (it->second.m_bHasUnitCombat)
		{
			iBase += knockbackVSUnitCombatTotal(it->first);
		}
	}
	int iTotal = std::max(0, iBase);

	return iTotal;
}

int CvUnit::punctureVSOpponentProbTotal(const CvUnit* pOpponent) const
{
	int iBase = punctureTotal();
	for (std::map<UnitCombatTypes, UnitCombatKeyedInfo>::const_iterator it = pOpponent->m_unitCombatKeyedInfo.begin(), end = pOpponent->m_unitCombatKeyedInfo.end(); it != end; ++it)
	{
		if (it->second.m_bHasUnitCombat)
		{
			iBase += punctureVSUnitCombatTotal(it->first);
		}
	}
	int iTotal = std::max(0, iBase);

	return iTotal;
}

int CvUnit::armorVSOpponentProbTotal(const CvUnit* pOpponent) const
{
	int iBase = armorTotal();
	for (std::map<UnitCombatTypes, UnitCombatKeyedInfo>::const_iterator it = pOpponent->m_unitCombatKeyedInfo.begin(), end = pOpponent->m_unitCombatKeyedInfo.end(); it != end; ++it)
	{
		if (it->second.m_bHasUnitCombat)
		{
			iBase += armorVSUnitCombatTotal(it->first);
		}
	}
	int iTotal = std::max(0, iBase);

	return iTotal;
}

int CvUnit::dodgeVSOpponentProbTotal(const CvUnit* pOpponent) const
{
	int iBase = dodgeTotal();
	for (std::map<UnitCombatTypes, UnitCombatKeyedInfo>::const_iterator it = pOpponent->m_unitCombatKeyedInfo.begin(), end = pOpponent->m_unitCombatKeyedInfo.end(); it != end; ++it)
	{
		if (it->second.m_bHasUnitCombat)
		{
			iBase += dodgeVSUnitCombatTotal(it->first);
		}
	}
	int iTotal = std::max(0, iBase);

	return iTotal;
}

int CvUnit::precisionVSOpponentProbTotal(const CvUnit* pOpponent) const
{
	int iBase = precisionTotal();
	for (std::map<UnitCombatTypes, UnitCombatKeyedInfo>::const_iterator it = pOpponent->m_unitCombatKeyedInfo.begin(), end = pOpponent->m_unitCombatKeyedInfo.end(); it != end; ++it)
	{
		if (it->second.m_bHasUnitCombat)
		{
			iBase += precisionVSUnitCombatTotal(it->first);
		}
	}
	int iTotal = std::max(0, iBase);

	return iTotal;
}

int CvUnit::criticalVSOpponentProbTotal(const CvUnit* pOpponent) const
{
	int iBase = criticalModifierTotal();
	for (std::map<UnitCombatTypes, UnitCombatKeyedInfo>::const_iterator it = pOpponent->m_unitCombatKeyedInfo.begin(), end = pOpponent->m_unitCombatKeyedInfo.end(); it != end; ++it)
	{
		if (it->second.m_bHasUnitCombat)
		{
			iBase += criticalVSUnitCombatTotal(it->first);
		}
	}
	int iTotal = std::max(0, iBase);

	return iTotal;
}

bool CvUnit::canInflictCritical(PromotionTypes eCritical) const
{
	if (GC.getPromotionLineInfo((PromotionLineTypes)GC.getPromotionInfo(eCritical).getPromotionLine()).getNumCriticalOriginCombatClassTypes() > 0)
	{
		for (int iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
		{
			if (isHasUnitCombat((UnitCombatTypes)iI) && GC.getPromotionLineInfo((PromotionLineTypes)GC.getPromotionInfo(eCritical).getPromotionLine()).isCriticalOriginCombatClassType(iI))
			{
				return true;
			}
		}
	}
	else
	{
		return true;
	}
	return false;
}

#ifdef OUTBREAKS_AND_AFFLICTIONS
int CvUnit::getAfflictionLineCount(PromotionLineTypes ePromotionLineType) const
{
	FASSERT_BOUNDS(0, GC.getNumPromotionLineInfos(), ePromotionLineType);

	const PromotionLineKeyedInfo* info = findPromotionLineKeyedInfo(ePromotionLineType);

	return info == NULL ? 0 : info->m_iAfflictionLineCount;
}

bool CvUnit::hasAfflictionLine(PromotionLineTypes ePromotionLineType) const
{
	FASSERT_BOUNDS(0, GC.getNumPromotionLineInfos(), ePromotionLineType);
	return (getAfflictionLineCount(ePromotionLineType) > 0);
}

void CvUnit::changeAfflictionLineCount(PromotionLineTypes ePromotionLineType, int iChange)
{
	FASSERT_BOUNDS(0, GC.getNumPromotionLineInfos(), ePromotionLineType);

	if (iChange != 0)
	{
		PromotionLineKeyedInfo* info = findOrCreatePromotionLineKeyedInfo(ePromotionLineType);

		info->m_iAfflictionLineCount += iChange;
	}
}

void CvUnit::afflict(PromotionLineTypes eAfflictionLine, bool bPoisoned, CvUnit* pOpponent, bool bTrap, int iTrapDmg)
{
	int iI;
	CvWString szBuffer;
	PromotionTypes eAfflictionHad = NO_PROMOTION;
	PromotionTypes eAfflictionGained = NO_PROMOTION;
	bool bAfflicted = false;
	for (iI = 0; iI < GC.getPromotionLineInfo(eAfflictionLine).getNumPromotions(); iI++)
	{
		const PromotionTypes eAffliction = (PromotionTypes)GC.getPromotionLineInfo(eAfflictionLine).getPromotion(iI);
		if (GC.getPromotionInfo(eAffliction).getLinePriority() == getAfflictionLineCount(eAfflictionLine))
		{
			eAfflictionHad = eAffliction;
		}
		if (GC.getPromotionInfo(eAffliction).getLinePriority() == (getAfflictionLineCount(eAfflictionLine)+1))
		{
			eAfflictionGained = eAffliction;
			bAfflicted = true;
		}
	}
	if (bAfflicted)
	{
		changeAfflictionLineCount(eAfflictionLine, 1);
		setHasPromotion(eAfflictionGained, true, true, false);
		{
			if (getAfflictionLineCount(eAfflictionLine) == 1)
			{
				GET_PLAYER(getOwner()).changePlayerWideAfflictionCount(eAfflictionLine, 1);
				if (!bTrap)
				{
					if (pOpponent != NULL)
					{
						if (bPoisoned)
						{
							//messages that introduce the affliction from battle as a poisoning

							const CvWString szBuffer = gDLL->getText("TXT_KEY_MISC_AFFLICT_SUFFERED_POISON_BATTLE_FIRST", getNameKey(), pOpponent->getNameKey(), GC.getPromotionInfo(eAfflictionGained).getTextKeyWide());
							AddDLLMessage(getOwner(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_POSITIVE_DINK", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_RED(), getX(), getY());
							const CvWString szBuffer2 = gDLL->getText("TXT_KEY_MISC_AFFLICT_DELIVERED_POISON_BATTLE_FIRST", getNameKey(), pOpponent->getNameKey(), GC.getPromotionInfo(eAfflictionGained).getTextKeyWide());
							AddDLLMessage(pOpponent->getOwner(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer2, "AS2D_POSITIVE_DINK", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_GREEN(), getX(), getY());
						}
						else
						{
							//messages that introduce the affliction from battle as a disease

							const CvWString szBuffer = gDLL->getText("TXT_KEY_MISC_AFFLICT_SUFFERED_DISEASE_BATTLE_FIRST", getNameKey(), GC.getPromotionInfo(eAfflictionGained).getTextKeyWide(), pOpponent->getNameKey());
							AddDLLMessage(getOwner(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_POSITIVE_DINK", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_RED(), getX(), getY());
							const CvWString szBuffer2 = gDLL->getText("TXT_KEY_MISC_AFFLICT_DELIVERED_DISEASE_BATTLE_FIRST", pOpponent->getNameKey(), GC.getPromotionInfo(eAfflictionGained).getTextKeyWide(), getNameKey());
							AddDLLMessage(pOpponent->getOwner(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer2, "AS2D_POSITIVE_DINK", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_GREEN(), getX(), getY());
						}
					}
					else
					{
						//message that introduces the disease affliction to the unit (only to the owner)

						const CvWString szBuffer = gDLL->getText("TXT_KEY_MISC_AFFLICT_SUFFERED_DISEASE_FIRST", getNameKey(), GC.getPromotionInfo(eAfflictionGained).getTextKeyWide());
						AddDLLMessage(getOwner(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_POSITIVE_DINK", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_RED(), getX(), getY());
					}
				}
			}
			else
			{
				if (!bTrap)
				{
					if (pOpponent != NULL)
					{
						if (bPoisoned)
						{
							//messages that worsen the affliction from battle as a poisoning

							const CvWString szBuffer = gDLL->getText("TXT_KEY_MISC_AFFLICT_SUFFERED_POISON_BATTLE_ADDITIONAL", getNameKey(), pOpponent->getNameKey(), GC.getPromotionInfo(eAfflictionGained).getTextKeyWide());
							AddDLLMessage(getOwner(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_POSITIVE_DINK", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_RED(), getX(), getY());
							const CvWString szBuffer2 = gDLL->getText("TXT_KEY_MISC_AFFLICT_DELIVERED_POISON_BATTLE_ADDITIONAL", getNameKey(), pOpponent->getNameKey(), GC.getPromotionInfo(eAfflictionGained).getTextKeyWide());
							AddDLLMessage(pOpponent->getOwner(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer2, "AS2D_POSITIVE_DINK", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_GREEN(), getX(), getY());
						}
						else
						{
							//messages that worsen the affliction from battle as a disease

							const CvWString szBuffer = gDLL->getText("TXT_KEY_MISC_AFFLICT_SUFFERED_DISEASE_BATTLE_ADDITIONAL", getNameKey(), GC.getPromotionInfo(eAfflictionGained).getTextKeyWide(), pOpponent->getNameKey());
							AddDLLMessage(getOwner(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_POSITIVE_DINK", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_RED(), getX(), getY());
							const CvWString szBuffer2 = gDLL->getText("TXT_KEY_MISC_AFFLICT_DELIVERED_DISEASE_BATTLE_ADDITIONAL", pOpponent->getNameKey(), GC.getPromotionInfo(eAfflictionGained).getTextKeyWide(), getNameKey());
							AddDLLMessage(pOpponent->getOwner(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer2, "AS2D_POSITIVE_DINK", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_GREEN(), getX(), getY());
						}
					}
					else
					{
						//message that states the affliction to the unit has worsened (only to the owner)

						const CvWString szBuffer = gDLL->getText("TXT_KEY_MISC_AFFLICT_SUFFERED_DISEASE_ADDITIONAL", getNameKey(), GC.getPromotionInfo(eAfflictionHad).getTextKeyWide(), GC.getPromotionInfo(eAfflictionGained).getTextKeyWide());
						AddDLLMessage(getOwner(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_POSITIVE_DINK", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_RED(), getX(), getY());
					}
				}
			}
			if (bTrap)
			{
				if (iTrapDmg > 0)
				{

					const CvWString szBuffer = gDLL->getText("TXT_KEY_MISC_TRAP_TRIGGERED_ALSO_AFFLICTION_SUFFERED", getNameKey(), GC.getPromotionInfo(eAfflictionGained).getTextKeyWide(), pOpponent->getNameKey());
					AddDLLMessage(getOwner(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_POSITIVE_DINK", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_RED(), getX(), getY());
					const CvWString szBuffer2 = gDLL->getText("TXT_KEY_MISC_TRAP_TRIGGERED_ALSO_AFFLICTION_INFLICTED", getNameKey(), GC.getPromotionInfo(eAfflictionGained).getTextKeyWide(), pOpponent->getNameKey());
					AddDLLMessage(pOpponent->getOwner(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer2, "AS2D_POSITIVE_DINK", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_GREEN(), getX(), getY());
				}
				else
				{

					const CvWString szBuffer = gDLL->getText("TXT_KEY_MISC_TRAP_TRIGGERED_AFFLICTION_SUFFERED", getNameKey(), GC.getPromotionInfo(eAfflictionGained).getTextKeyWide(), pOpponent->getNameKey());
					AddDLLMessage(getOwner(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_POSITIVE_DINK", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_RED(), getX(), getY());
					const CvWString szBuffer2 = gDLL->getText("TXT_KEY_MISC_TRAP_TRIGGERED_AFFLICTION_INFLICTED", getNameKey(), GC.getPromotionInfo(eAfflictionGained).getTextKeyWide(), pOpponent->getNameKey());
					AddDLLMessage(pOpponent->getOwner(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer2, "AS2D_POSITIVE_DINK", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_GREEN(), getX(), getY());
				}
			}
		}
	}
}

void CvUnit::recover(PromotionLineTypes eAfflictionLine)
{
	int iI;
	CvWString szBuffer;
	PromotionTypes eAfflictionHad = NO_PROMOTION;
	PromotionTypes eAfflictionGained = NO_PROMOTION;
	for (iI = 0; iI < GC.getPromotionLineInfo(eAfflictionLine).getNumPromotions(); iI++)
	{
		const PromotionTypes eAffliction = (PromotionTypes)GC.getPromotionLineInfo(eAfflictionLine).getPromotion(iI);
		if (GC.getPromotionInfo(eAffliction).getLinePriority() == (getAfflictionLineCount(eAfflictionLine)))
		{
			eAfflictionHad = eAffliction;
			changeAfflictionLineCount(eAfflictionLine, -1);
			setHasPromotion(eAffliction, false, true, false);
			break;
		}
	}
	if (getAfflictionLineCount(eAfflictionLine) > 0)
	{
		for (iI = 0; iI < GC.getPromotionLineInfo(eAfflictionLine).getNumPromotions(); iI++)
		{
			const PromotionTypes eAffliction = (PromotionTypes)GC.getPromotionLineInfo(eAfflictionLine).getPromotion(iI);
			if (GC.getPromotionInfo(eAffliction).getLinePriority() == (getAfflictionLineCount(eAfflictionLine)))
			{
				eAfflictionGained = eAffliction;
				setHasPromotion(eAffliction, true, true, false);


				const CvWString szBuffer = gDLL->getText("TXT_KEY_MISC_OVERCOME_IMPROVE", getNameKey(), eAfflictionHad, eAfflictionGained);
				AddDLLMessage(getOwner(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_POSITIVE_DINK", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_RED(), getX(), getY());
				break;
			}
		}
	}
	else
	{
		GET_PLAYER(getOwner()).changePlayerWideAfflictionCount(eAfflictionLine, -1);

		const CvWString szBuffer = gDLL->getText("TXT_KEY_MISC_OVERCOME_COMPLETE", getNameKey(), eAfflictionHad);
		AddDLLMessage(getOwner(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_POSITIVE_DINK", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_RED(), getX(), getY());
	}
}

int CvUnit::getAfflictOnAttackTypeProbability(PromotionLineTypes ePromotionLineType) const
{
	FASSERT_BOUNDS(0, GC.getNumPromotionLineInfos(), ePromotionLineType);

	const PromotionLineKeyedInfo* info = findPromotionLineKeyedInfo(ePromotionLineType);

	int iEvaluation = (info == NULL ? 0 : info->m_iAfflictOnAttackTypeProbability);
	const int iNum = m_pUnitInfo->getNumAfflictOnAttackTypes();

	for (int iI = 0; iI < iNum; iI++)
	{
		const PromotionLineTypes eAfflictionLine = m_pUnitInfo->getAfflictOnAttackType(iI).eAfflictionLine;
		if (eAfflictionLine == ePromotionLineType)
		{
			iEvaluation += m_pUnitInfo->getAfflictOnAttackType(iI).iProbability;
		}
	}
	if (GC.getPromotionLineInfo(ePromotionLineType).isPoison())
	{
		iEvaluation += poisonProbabilityModifierTotal();
	}
	return std::max(0, iEvaluation);
}

void CvUnit::changeAfflictOnAttackTypeProbability(PromotionLineTypes ePromotionLineType, int iChange)
{
	FASSERT_BOUNDS(0, GC.getNumPromotionLineInfos(), ePromotionLineType);

	if (iChange != 0)
	{
		PromotionLineKeyedInfo* info = findOrCreatePromotionLineKeyedInfo(ePromotionLineType);

		info->m_iAfflictOnAttackTypeProbability += iChange;
	}
}

void CvUnit::setAfflictOnAttackTypeProbability(PromotionLineTypes ePromotionLineType, int iChange)
{
	FASSERT_BOUNDS(0, GC.getNumPromotionLineInfos(), ePromotionLineType);

	PromotionLineKeyedInfo* info = findOrCreatePromotionLineKeyedInfo(ePromotionLineType, iChange != 0);

	if (info != NULL)
	{
		info->m_iAfflictOnAttackTypeProbability = iChange;
	}
}

bool CvUnit::hasAfflictOnAttackType(PromotionLineTypes ePromotionLineType) const
{
	FASSERT_BOUNDS(0, GC.getNumPromotionLineInfos(), ePromotionLineType);

	const PromotionLineKeyedInfo* info = findPromotionLineKeyedInfo(ePromotionLineType);

	int iEvaluation = (info == NULL ? 0 : info->m_iAfflictOnAttackTypeCount);
	const int iNum = m_pUnitInfo->getNumAfflictOnAttackTypes();

	for (int iI = 0; iI < iNum; iI++)
	{
		const PromotionLineTypes eAfflictionLine = m_pUnitInfo->getAfflictOnAttackType(iI).eAfflictionLine;
		if (eAfflictionLine == ePromotionLineType)
		{
			iEvaluation += 1;
		}
	}
	return (iEvaluation > 0);
}

int CvUnit::getAfflictOnAttackTypeCount(PromotionLineTypes ePromotionLineType) const
{
	FASSERT_BOUNDS(0, GC.getNumPromotionLineInfos(), ePromotionLineType);

	const PromotionLineKeyedInfo* info = findPromotionLineKeyedInfo(ePromotionLineType);

	return info == NULL ? 0 : info->m_iAfflictOnAttackTypeCount;
}

void CvUnit::changeAfflictOnAttackTypeCount(PromotionLineTypes ePromotionLineType, int iChange)
{
	FASSERT_BOUNDS(0, GC.getNumPromotionLineInfos(), ePromotionLineType);

	if (iChange != 0)
	{
		PromotionLineKeyedInfo* info = findOrCreatePromotionLineKeyedInfo(ePromotionLineType);

		info->m_iAfflictOnAttackTypeCount += iChange;
	}

}

void CvUnit::setAfflictOnAttackTypeCount(PromotionLineTypes ePromotionLineType, int iChange)
{
	FASSERT_BOUNDS(0, GC.getNumPromotionLineInfos(), ePromotionLineType);

	PromotionLineKeyedInfo* info = findOrCreatePromotionLineKeyedInfo(ePromotionLineType, iChange != 0);

	if (info != NULL)
	{
		info->m_iAfflictOnAttackTypeCount = iChange;
	}
}

int CvUnit::getAfflictOnAttackTypeImmediateCount(PromotionLineTypes ePromotionLineType) const//
{
	FASSERT_BOUNDS(0, GC.getNumPromotionLineInfos(), ePromotionLineType);

	const PromotionLineKeyedInfo* info = findPromotionLineKeyedInfo(ePromotionLineType);

	return info == NULL ? 0 : info->m_iAfflictOnAttackTypeImmediateCount;
}

bool CvUnit::isAfflictOnAttackTypeImmediate(PromotionLineTypes ePromotionLineType) const
{
	FASSERT_BOUNDS(0, GC.getNumPromotionLineInfos(), ePromotionLineType);

	const PromotionLineKeyedInfo* info = findPromotionLineKeyedInfo(ePromotionLineType);

	int iEvaluation = (info == NULL ? 0 : info->m_iAfflictOnAttackTypeImmediateCount);
	const int iNum = m_pUnitInfo->getNumAfflictOnAttackTypes();

	for (int iI = 0; iI < iNum; iI++)
	{
		const PromotionLineTypes eAfflictionLine = m_pUnitInfo->getAfflictOnAttackType(iI).eAfflictionLine;
		if (eAfflictionLine == ePromotionLineType)
		{
			iEvaluation += m_pUnitInfo->getAfflictOnAttackType(iI).iImmediate;
			break;
		}
	}
	return (iEvaluation > 0);
}

void CvUnit::changeAfflictOnAttackTypeImmediateCount(PromotionLineTypes ePromotionLineType, int iChange)
{
	FASSERT_BOUNDS(0, GC.getNumPromotionLineInfos(), ePromotionLineType);

	if (iChange != 0)
	{
		PromotionLineKeyedInfo* info = findOrCreatePromotionLineKeyedInfo(ePromotionLineType);

		info->m_iAfflictOnAttackTypeImmediateCount += iChange;
	}
}

void CvUnit::setAfflictOnAttackTypeImmediateCount(PromotionLineTypes ePromotionLineType, int iChange)
{
	FASSERT_BOUNDS(0, GC.getNumPromotionLineInfos(), ePromotionLineType);

	PromotionLineKeyedInfo* info = findOrCreatePromotionLineKeyedInfo(ePromotionLineType, iChange != 0);

	if (info != NULL)
	{
		info->m_iAfflictOnAttackTypeImmediateCount = iChange;
	}
}

int CvUnit::getAfflictOnAttackTypeMeleeCount(PromotionLineTypes ePromotionLineType) const//
{
	FASSERT_BOUNDS(0, GC.getNumPromotionLineInfos(), ePromotionLineType);

	const PromotionLineKeyedInfo* info = findPromotionLineKeyedInfo(ePromotionLineType);

	return info == NULL ? 0 : info->m_iAfflictOnAttackTypeMeleeCount;
}

bool CvUnit::isAfflictOnAttackTypeMelee(PromotionLineTypes ePromotionLineType) const
{
	FASSERT_BOUNDS(0, GC.getNumPromotionLineInfos(), ePromotionLineType);

	const PromotionLineKeyedInfo* info = findPromotionLineKeyedInfo(ePromotionLineType);

	int iEvaluation = (info == NULL ? 0 : info->m_iAfflictOnAttackTypeMeleeCount);
	const int iNum = m_pUnitInfo->getNumAfflictOnAttackTypes();

	for (int iI = 0; iI < iNum; iI++)
	{
		const PromotionLineTypes eAfflictionLine = m_pUnitInfo->getAfflictOnAttackType(iI).eAfflictionLine;
		if (eAfflictionLine == ePromotionLineType)
		{
			iEvaluation += m_pUnitInfo->getAfflictOnAttackType(iI).iMelee;
			break;
		}
	}
	return (iEvaluation > 0);
}

void CvUnit::changeAfflictOnAttackTypeMeleeCount(PromotionLineTypes ePromotionLineType, int iChange)
{
	FASSERT_BOUNDS(0, GC.getNumPromotionLineInfos(), ePromotionLineType);

	if (iChange != 0)
	{
		PromotionLineKeyedInfo* info = findOrCreatePromotionLineKeyedInfo(ePromotionLineType);

		info->m_iAfflictOnAttackTypeMeleeCount += iChange;
	}
}

void CvUnit::setAfflictOnAttackTypeMeleeCount(PromotionLineTypes ePromotionLineType, int iChange)
{
	FASSERT_BOUNDS(0, GC.getNumPromotionLineInfos(), ePromotionLineType);

	PromotionLineKeyedInfo* info = findOrCreatePromotionLineKeyedInfo(ePromotionLineType, iChange != 0);

	if (info != NULL)
	{
		info->m_iAfflictOnAttackTypeMeleeCount = iChange;
	}
}

int CvUnit::getAfflictOnAttackTypeDistanceCount(PromotionLineTypes ePromotionLineType) const//
{
	FASSERT_BOUNDS(0, GC.getNumPromotionLineInfos(), ePromotionLineType);

	const PromotionLineKeyedInfo* info = findPromotionLineKeyedInfo(ePromotionLineType);

	return info == NULL ? 0 : info->m_iAfflictOnAttackTypeDistanceCount;
}

bool CvUnit::isAfflictOnAttackTypeDistance(PromotionLineTypes ePromotionLineType) const
{
	FASSERT_BOUNDS(0, GC.getNumPromotionLineInfos(), ePromotionLineType);

	const PromotionLineKeyedInfo* info = findPromotionLineKeyedInfo(ePromotionLineType);

	int iEvaluation = (info == NULL ? 0 : info->m_iAfflictOnAttackTypeDistanceCount);
	const int iNum = m_pUnitInfo->getNumAfflictOnAttackTypes();

	for (int iI = 0; iI < iNum; iI++)
	{
		const PromotionLineTypes eAfflictionLine = m_pUnitInfo->getAfflictOnAttackType(iI).eAfflictionLine;
		if (eAfflictionLine == ePromotionLineType)
		{
			iEvaluation += m_pUnitInfo->getAfflictOnAttackType(iI).iDistance;
			break;
		}
	}
	return (iEvaluation > 0);
}

void CvUnit::changeAfflictOnAttackTypeDistanceCount(PromotionLineTypes ePromotionLineType, int iChange)
{
	FASSERT_BOUNDS(0, GC.getNumPromotionLineInfos(), ePromotionLineType);

	if (iChange != 0)
	{
		PromotionLineKeyedInfo* info = findOrCreatePromotionLineKeyedInfo(ePromotionLineType);

		info->m_iAfflictOnAttackTypeDistanceCount += iChange;
	}
}

void CvUnit::setAfflictOnAttackTypeDistanceCount(PromotionLineTypes ePromotionLineType, int iChange)
{
	FASSERT_BOUNDS(0, GC.getNumPromotionLineInfos(), ePromotionLineType);

	PromotionLineKeyedInfo* info = findOrCreatePromotionLineKeyedInfo(ePromotionLineType, iChange!= 0);

	if (info != 0)
	{
		info->m_iAfflictOnAttackTypeDistanceCount = iChange;
	}
}
//
int CvUnit::getAfflictOnAttackTypeAttemptedCount(PromotionLineTypes ePromotionLineType) const
{
	FASSERT_BOUNDS(0, GC.getNumPromotionLineInfos(), ePromotionLineType);

	const PromotionLineKeyedInfo* info = findPromotionLineKeyedInfo(ePromotionLineType);

	return info == NULL ? 0 : info->m_iAfflictOnAttackTypeAttemptedCount;
}

bool CvUnit::isAfflictOnAttackTypeAttempted(PromotionLineTypes ePromotionLineType) const
{
	FASSERT_BOUNDS(0, GC.getNumPromotionLineInfos(), ePromotionLineType);
	const PromotionLineKeyedInfo* info = findPromotionLineKeyedInfo(ePromotionLineType);

	return info ? info->m_iAfflictOnAttackTypeAttemptedCount > 0 : false;
}

void CvUnit::changeAfflictOnAttackTypeAttemptedCount(PromotionLineTypes ePromotionLineType, int iChange)
{
	FASSERT_BOUNDS(0, GC.getNumPromotionLineInfos(), ePromotionLineType);

	if (iChange != 0)
	{
		PromotionLineKeyedInfo* info = findOrCreatePromotionLineKeyedInfo(ePromotionLineType);

		info->m_iAfflictOnAttackTypeAttemptedCount += iChange;
	}
}

void CvUnit::setAfflictOnAttackTypeAttemptedCount(PromotionLineTypes ePromotionLineType, int iChange)
{
	FASSERT_BOUNDS(0, GC.getNumPromotionLineInfos(), ePromotionLineType);

	PromotionLineKeyedInfo* info = findOrCreatePromotionLineKeyedInfo(ePromotionLineType, iChange != 0);

	if (info != NULL)
	{
		info->m_iAfflictOnAttackTypeAttemptedCount = iChange;
	}
}

int CvUnit::worsenedProbabilitytoAfflict(PromotionLineTypes eAfflictionLine) const
{
	const int iLinePriority = getAfflictionLineCount(eAfflictionLine) - 1;
	const int iProbabilityMultiplier = GC.getPromotionLineInfo(eAfflictionLine).getWorsenedCommunicabilityIncrementModifier();
	return (iLinePriority * iProbabilityMultiplier);
}
#endif // OUTBREAKS_AND_AFFLICTIONS

bool CvUnit::hasHealUnitCombat() const
{
	return (m_iHealUnitCombatCount > 0);
}

int CvUnit:: getHealUnitCombatCount() const
{
	return m_iHealUnitCombatCount;
}

void CvUnit::setHealUnitCombatCount()
{
	m_iHealUnitCombatCount = 0;
	int iTotal = 0;
	for (int iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
	{
		iTotal = getHealUnitCombatTypeTotal((UnitCombatTypes)iI);
		iTotal += getHealUnitCombatTypeAdjacentTotal((UnitCombatTypes)iI);
		if (iTotal > 0)
		{
			m_iHealUnitCombatCount += iTotal;
		}
	}
}

int CvUnit::getHealUnitCombatTypeTotal(UnitCombatTypes eUnitCombatType) const
{
	FASSERT_BOUNDS(0, GC.getNumUnitCombatInfos(), eUnitCombatType);

	const UnitCombatKeyedInfo* info = findUnitCombatKeyedInfo(eUnitCombatType);

	int iEvaluation = (info == NULL ? 0 : info->m_iHealUnitCombatTypeVolume);
	const int iNum = m_pUnitInfo->getNumHealUnitCombatTypes();

	for (int iI = 0; iI < iNum; iI++)
	{
		const UnitCombatTypes eUnitCombat = m_pUnitInfo->getHealUnitCombatType(iI).eUnitCombat;
		if (eUnitCombat == eUnitCombatType)
		{
			iEvaluation += m_pUnitInfo->getHealUnitCombatType(iI).iHeal;
		}
	}

	return std::max(0, iEvaluation);
}

void CvUnit::changeHealUnitCombatTypeVolume(UnitCombatTypes eUnitCombatType, int iChange)
{
	FASSERT_BOUNDS(0, GC.getNumUnitCombatInfos(), eUnitCombatType);

	if (iChange != 0)
	{
		UnitCombatKeyedInfo* info = findOrCreateUnitCombatKeyedInfo(eUnitCombatType);

		setHealUnitCombatCount();

		info->m_iHealUnitCombatTypeVolume += iChange;
	}
}

void CvUnit::setHealUnitCombatTypeVolume(UnitCombatTypes eUnitCombatType, int iChange)
{
	FASSERT_BOUNDS(0, GC.getNumUnitCombatInfos(), eUnitCombatType);

	UnitCombatKeyedInfo* info = findOrCreateUnitCombatKeyedInfo(eUnitCombatType, iChange != 0);

	if (info != NULL)
	{
		setHealUnitCombatCount();

		info->m_iHealUnitCombatTypeVolume = iChange;
	}
}

int CvUnit::getHealUnitCombatTypeAdjacentTotal(UnitCombatTypes eUnitCombatType) const
{
	FASSERT_BOUNDS(0, GC.getNumUnitCombatInfos(), eUnitCombatType);

	const UnitCombatKeyedInfo* info = findUnitCombatKeyedInfo(eUnitCombatType);

	int iEvaluation = (info == NULL ? 0 : info->m_iHealUnitCombatTypeAdjacentVolume);
	const int iNum = m_pUnitInfo->getNumHealUnitCombatTypes();

	for (int iI = 0; iI < iNum; iI++)
	{
		const UnitCombatTypes eUnitCombat = m_pUnitInfo->getHealUnitCombatType(iI).eUnitCombat;
		if (eUnitCombat == eUnitCombatType)
		{
			iEvaluation += m_pUnitInfo->getHealUnitCombatType(iI).iAdjacentHeal;
		}
	}

	return std::max(0, iEvaluation);
}

void CvUnit::changeHealUnitCombatTypeAdjacentVolume(UnitCombatTypes eUnitCombatType, int iChange)
{
	FASSERT_BOUNDS(0, GC.getNumUnitCombatInfos(), eUnitCombatType);

	if (iChange != 0)
	{
		UnitCombatKeyedInfo* info = findOrCreateUnitCombatKeyedInfo(eUnitCombatType);

		setHealUnitCombatCount();

		info->m_iHealUnitCombatTypeAdjacentVolume += iChange;
	}
}

void CvUnit::setHealUnitCombatTypeAdjacentVolume(UnitCombatTypes eUnitCombatType, int iChange)
{
	FASSERT_BOUNDS(0, GC.getNumUnitCombatInfos(), eUnitCombatType);

	UnitCombatKeyedInfo* info = findOrCreateUnitCombatKeyedInfo(eUnitCombatType, iChange != 0);

	if (info != NULL)
	{
		setHealUnitCombatCount();

		info->m_iHealUnitCombatTypeAdjacentVolume = iChange;
	}
}

void CvUnit::doSetUnitCombats()
{
	bool bUpdated = false;
	if (getUnitCombatType() != NO_UNITCOMBAT)
	{
		setHasUnitCombat(getUnitCombatType(), true);

		foreach_(const UnitCombatTypes eSubCombat, m_pUnitInfo->getSubCombatTypes())
		{
			setHasUnitCombat(eSubCombat, true);
			bUpdated = true;
		}
	}

	const TechTypes ePrereq = (TechTypes)m_pUnitInfo->getPrereqAndTech();

	EraTypes eEra = NO_ERA;

	if (ePrereq == NO_TECH)
	{
		eEra = GC.getGame().getCurrentEra();
	}
	else
	{
		eEra = (EraTypes)GC.getTechInfo(ePrereq).getEra();
	}

	for (int iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
	{
		if (GC.getUnitCombatInfo((UnitCombatTypes)iI).getEra() == eEra)
		{
			setHasUnitCombat((UnitCombatTypes)iI, true, false);
			break;
		}
	}
	if (bUpdated && GC.getGame().isOption(GAMEOPTION_SIZE_MATTERS))
	{
		setSMValues();
	}
}

void CvUnit::setFreePromotion(PromotionTypes ePromotion, bool bAdding, TraitTypes eTrait)
{
	const CvPlayer& pPlayer = GET_PLAYER(getOwner());

	if (bAdding && !isHasPromotion(ePromotion))
	{
		if (m_pUnitInfo->getFreePromotions((int)ePromotion)
		|| (NO_UNIT != getUnitType() && pPlayer.isFreePromotion(getUnitType(), ePromotion)))
		{
			setHasPromotion(ePromotion, true, true);
			return;
		}

		for (std::map<UnitCombatTypes, UnitCombatKeyedInfo>::const_iterator it = m_unitCombatKeyedInfo.begin(), end = m_unitCombatKeyedInfo.end(); it != end; ++it)
		{
			if (it->second.m_bHasUnitCombat)
			{
				if (pPlayer.isFreePromotion(it->first, ePromotion))
				{
					setHasPromotion(ePromotion, true, true);
					return;
				}

				if (eTrait == NO_TRAIT)
				{
					for (int iK = GC.getNumTraitInfos() - 1; iK > -1; iK--)
					{
						if (pPlayer.hasTrait((TraitTypes)iK) && GC.getTraitInfo((TraitTypes)iK).isFreePromotionUnitCombats(ePromotion, it->first))
						{
							setHasPromotion(ePromotion, true, true, false, false, true);
							return;
						}
					}
				}
				else if (GC.getTraitInfo(eTrait).isFreePromotionUnitCombats(ePromotion, it->first))
				{
					setHasPromotion(ePromotion, true, true, false, false, true);
					return;
				}
			}
		}
	}
	//Remove trait derived promotions if trait has been removed
	if (!bAdding && isPromotionFromTrait(ePromotion) && isHasPromotion(ePromotion))
	{
		for (std::map<UnitCombatTypes, UnitCombatKeyedInfo>::const_iterator it = m_unitCombatKeyedInfo.begin(), end = m_unitCombatKeyedInfo.end(); it != end; ++it)
		{
			if (it->second.m_bHasUnitCombat)
			{
				if (eTrait == NO_TRAIT)
				{
					for (int iK = GC.getNumTraitInfos() - 1; iK > -1; iK--)
					{
						if (!pPlayer.hasTrait((TraitTypes)iK) && GC.getTraitInfo((TraitTypes)iK).isFreePromotionUnitCombats((int)ePromotion, it->first))
						{
							setHasPromotion(ePromotion, false, true, false, false, true);
							return;
						}
					}
				}
				else if (GC.getTraitInfo(eTrait).isFreePromotionUnitCombats((int)ePromotion, it->first))
				{
					setHasPromotion(ePromotion, false, true, false, false, true);
					return;
				}
			}
		}
	}
}

void CvUnit::doSetFreePromotions(bool bAdding, TraitTypes eTrait)
{
	for (int iI = GC.getNumPromotionInfos() - 1; iI > -1; iI--)
	{
		setFreePromotion(static_cast<PromotionTypes>(iI), bAdding, eTrait);
	}
	if (bAdding)
	{
		checkFreetoCombatClass();
	}
}

int CvUnit::getRetrainsAvailable() const
{
	return m_iRetrainsAvailable;
}

void CvUnit::setRetrainsAvailable(int iNewValue)
{
	m_iRetrainsAvailable = iNewValue;
	FASSERT_NOT_NEGATIVE(getRetrainsAvailable());
}

void CvUnit::changeRetrainsAvailable(int iChange)
{
	setRetrainsAvailable(getRetrainsAvailable() + iChange);
}

int CvUnit::getExperiencefromWithdrawal(const int iWithdrawalProbability) const
{
	const int iInversePercentage = 100 - iWithdrawalProbability;

	const int iExperienceTotal = (GC.getEXPERIENCE_FROM_WITHDRAWL() * iInversePercentage)/100;

	return (std::max(1, iExperienceTotal));
}

//Team Project (3)
int CvUnit::getExtraCaptureProbabilityModifier(bool bIgnoreCommanders) const
{
	if (!bIgnoreCommanders && !isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander != NULL)
		{
			return m_iExtraCaptureProbabilityModifier + pCommander->m_iExtraCaptureProbabilityModifier;
		}
	}
	return m_iExtraCaptureProbabilityModifier;
}

void CvUnit::changeExtraCaptureProbabilityModifier(int iChange)
{
	m_iExtraCaptureProbabilityModifier +=iChange;
}

int CvUnit::captureProbabilityTotal() const
{
	int iData = m_pUnitInfo->getCaptureProbabilityModifier();
	iData += getExtraCaptureProbabilityModifier();
	iData += GET_PLAYER(getOwner()).getExtraNationalCaptureProbabilityModifier();

	if (plot()->isCity(false, getTeam()))
	{
		iData += plot()->getPlotCity()->getExtraLocalCaptureProbabilityModifier();
	}

	return std::max(0, iData);
}

int CvUnit::getExtraCaptureResistanceModifier(bool bIgnoreCommanders) const
{
	if (!bIgnoreCommanders && !isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander != NULL)
		{
			return m_iExtraCaptureResistanceModifier + pCommander->m_iExtraCaptureResistanceModifier;
		}
	}
	return m_iExtraCaptureResistanceModifier;
}

void CvUnit::changeExtraCaptureResistanceModifier(int iChange)
{
	m_iExtraCaptureResistanceModifier +=iChange;
}

int CvUnit::captureResistanceTotal() const
{
	int iData = m_pUnitInfo->getCaptureResistanceModifier();
	iData += getExtraCaptureResistanceModifier();
	iData += GET_PLAYER(getOwner()).getExtraNationalCaptureResistanceModifier();

	if (plot()->isCity(false, getTeam()))
	{
		iData += plot()->getPlotCity()->getExtraLocalCaptureResistanceModifier();
	}

	return std::max(0, iData);
}

//
int CvUnit::getExtraBreakdownChance(bool bIgnoreCommanders) const
{
	if (!bIgnoreCommanders && !isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander != NULL)
		{
			return m_iExtraBreakdownChance + pCommander->m_iExtraBreakdownChance;
		}
	}
	return m_iExtraBreakdownChance;
}

void CvUnit::changeExtraBreakdownChance(int iChange)
{
	m_iExtraBreakdownChance +=iChange;
}

int CvUnit::breakdownChanceTotal() const
{
	int iData = m_pUnitInfo->getBreakdownChance();
	iData += getExtraBreakdownChance();
	return std::max(0, iData);
}

int CvUnit::getExtraBreakdownDamage(bool bIgnoreCommanders) const
{
	if (!bIgnoreCommanders && !isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander != NULL)
		{
			return m_iExtraBreakdownDamage + pCommander->m_iExtraBreakdownDamage;
		}
	}
	return m_iExtraBreakdownDamage;
}

void CvUnit::changeExtraBreakdownDamage(int iChange)
{
	m_iExtraBreakdownDamage +=iChange;
}

int CvUnit::breakdownDamageTotal() const
{
	int iData = m_pUnitInfo->getBreakdownDamage();
	iData += getExtraBreakdownDamage();
	return std::max(0, iData);
}

int CvUnit::getExtraTaunt() const
{
	return std::max(0, m_iExtraTaunt);
}

void CvUnit::changeExtraTaunt(int iChange)
{
	m_iExtraTaunt += iChange;
}

void CvUnit::setExtraTaunt(int iChange)
{
	m_iExtraTaunt = iChange;
}

int CvUnit::tauntTotal() const
{
	int iData = m_pUnitInfo->getTaunt();
	iData += getExtraTaunt();
	return std::max(0, iData);
}

int CvUnit::getExtraCombatModifierPerSizeMore() const
{
	return std::max(0, m_iExtraCombatModifierPerSizeMore);
}

void CvUnit::changeExtraCombatModifierPerSizeMore(int iChange)
{
	m_iExtraCombatModifierPerSizeMore += iChange;
}

void CvUnit::setExtraCombatModifierPerSizeMore(int iChange)
{
	m_iExtraCombatModifierPerSizeMore = iChange;
}

int CvUnit::combatModifierPerSizeMoreTotal() const
{
	int iData = m_pUnitInfo->getCombatModifierPerSizeMore();
	iData += getExtraCombatModifierPerSizeMore();
	return iData;
}

int CvUnit::getExtraCombatModifierPerSizeLess() const
{
	return std::max(0, m_iExtraCombatModifierPerSizeLess);
}

void CvUnit::changeExtraCombatModifierPerSizeLess(int iChange)
{
	m_iExtraCombatModifierPerSizeLess += iChange;
}

void CvUnit::setExtraCombatModifierPerSizeLess(int iChange)
{
	m_iExtraCombatModifierPerSizeLess = iChange;
}

int CvUnit::combatModifierPerSizeLessTotal() const
{
	int iData = m_pUnitInfo->getCombatModifierPerSizeLess();
	iData += getExtraCombatModifierPerSizeLess();
	return iData;
}

int CvUnit::getExtraCombatModifierPerVolumeMore() const
{
	return std::max(0, m_iExtraCombatModifierPerVolumeMore);
}

void CvUnit::changeExtraCombatModifierPerVolumeMore(int iChange)
{
	m_iExtraCombatModifierPerVolumeMore += iChange;
}

void CvUnit::setExtraCombatModifierPerVolumeMore(int iChange)
{
	m_iExtraCombatModifierPerVolumeMore = iChange;
}

int CvUnit::combatModifierPerVolumeMoreTotal() const
{
	int iData = m_pUnitInfo->getCombatModifierPerVolumeMore();
	iData += getExtraCombatModifierPerVolumeMore();
	return iData;
}

int CvUnit::getExtraCombatModifierPerVolumeLess() const
{
	return std::max(0, m_iExtraCombatModifierPerVolumeLess);
}

void CvUnit::changeExtraCombatModifierPerVolumeLess(int iChange)
{
	m_iExtraCombatModifierPerVolumeLess += iChange;
}

void CvUnit::setExtraCombatModifierPerVolumeLess(int iChange)
{
	m_iExtraCombatModifierPerVolumeLess = iChange;
}

int CvUnit::combatModifierPerVolumeLessTotal() const
{
	int iData = m_pUnitInfo->getCombatModifierPerVolumeLess();
	iData += getExtraCombatModifierPerVolumeLess();
	return iData;
}

int CvUnit::getExtraStrengthModifier() const
{
	return m_iExtraStrengthModifier;
}

void CvUnit::changeExtraStrengthModifier(int iChange)
{
	m_iExtraStrengthModifier += iChange;
}

void CvUnit::setExtraStrengthModifier(int iChange)
{
	m_iExtraStrengthModifier = iChange;
}

void CvUnit::checkCityAttackDefensesDamage(CvCity* pCity, const std::vector<UnitCombatTypes>& kDamagableUnitCombatTypes)
{
	//Here we cycle through each active building in the city that's triggering the fact that it can possibly damage the attacking unit here and make a check
	//using the building's % chance to damage - Dodge.  Then if it hits, deals DamageToAttacker modified by the unit's Armor.
	//Then battle would proceed as normal.

	int iBuildingAttackRoll = 0;
	int iBuildingAttackChanceBase = 0;
	int iUnitDodge = dodgeTotal() - 100;
	int iBuildingAttackChanceTotal = 0;
	int iBuildingAttackDamageBase = 0;
	int iUnitArmor = armorTotal();
	int iBuildingAttackDamageTotal = 0;
	CvWString szBuffer;

	for (int iI = 0; iI < GC.getNumBuildingInfos(); iI++)
	{
		const BuildingTypes eBuilding = (BuildingTypes)iI;
		if (GC.getBuildingInfo(eBuilding).isDamageAttackerCapable())
		{
			for(unsigned int iJ = 0; iJ < kDamagableUnitCombatTypes.size(); iJ++)
			{
				const UnitCombatTypes eUnitCombat = kDamagableUnitCombatTypes[iJ];

				if (GC.getBuildingInfo(eBuilding).isMayDamageAttackingUnitCombatType(eUnitCombat) || GC.getBuildingInfo(eBuilding).isDamageAllAttackers())
				{
					if (pCity->getNumActiveBuilding(eBuilding) > 0)
					{
						//1st random generation to see if the building hits with its 'attack'.
						iBuildingAttackRoll = GC.getGame().getSorenRandNum(100, "BuildingAttackRoll");
						iBuildingAttackChanceBase = GC.getBuildingInfo(eBuilding).getDamageAttackerChance();
						iBuildingAttackChanceTotal = iBuildingAttackChanceBase - iUnitDodge;
						if (iBuildingAttackRoll < iBuildingAttackChanceTotal)
						{
							iBuildingAttackDamageBase = GC.getBuildingInfo(eBuilding).getDamageToAttacker();
							if (!GC.getBuildingInfo(eBuilding).isDamageToAttackerIgnoresArmor())
							{
								iBuildingAttackDamageBase -= iUnitArmor;
							}
							iBuildingAttackDamageTotal = std::max(0, iBuildingAttackDamageBase);

							if (iBuildingAttackDamageTotal > 0)
							{
								changeDamage(iBuildingAttackDamageTotal, getOwner());

								if (isHuman())
								{

									szBuffer = gDLL->getText("TXT_KEY_MISC_ATTACKER_SUFFERS_BUILDING_DAMAGE", getNameKey(), pCity->getNameKey(), GC.getBuildingInfo(eBuilding).getTextKeyWide(), iBuildingAttackDamageTotal);
									AddDLLMessage(getOwner(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_COMBAT", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_RED(), pCity->getX(), pCity->getY());
								}

								if (GET_PLAYER(pCity->getOwner()).isHuman())
								{

									szBuffer = gDLL->getText("TXT_KEY_MISC_BUILDING_DAMAGED_ATTACKER", getNameKey(), pCity->getNameKey(), GC.getBuildingInfo(eBuilding).getTextKeyWide(), iBuildingAttackDamageTotal);
									AddDLLMessage(pCity->getOwner(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_POSITIVE_DINK", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_GREEN(), pCity->getX(), pCity->getY());
								}

								//	Don't continue over the other combat types for this building - any one building
								//	can only do its damage once
								break;
							}
						}
					}
				}
			}
		}
	}
}

bool CvUnit::isBreakdownCombat(const CvPlot* pPlot, bool bSamePlot) const
{
	//only if attacking unit has the ability and is not currently engaged in a distance counterattack as it approaches.
	if (breakdownChanceTotal() > 0 && breakdownDamageTotal() > 0 && !bSamePlot)
	{
		if (pPlot->isCity(false))
		{
			const CvCity* pCity = pPlot->getPlotCity();
			//Only if the city still has some defenses left to damage.
			if (pCity->isBombardable(this))
			{
				return true;
			}
		}
	}
	return false;
}

void CvUnit::resolveBreakdownAttack(const CvPlot* pPlot, const int AdjustedRepel)
{
	if (!pPlot->isCity(false))
	{
		return;
	}

	CvCity* pCity = pPlot->getPlotCity();

	FAssertMsg(pCity != NULL, "Breakdown Target City is not assigned a valid value");

	const int iNormalDamage = breakdownDamageTotal();
	int iTrueDamage = iNormalDamage + iNormalDamage * std::max(0, 100 - pCity->getBuildingBombardDefense()) / 100;

	if (iNormalDamage > 0)
	{
		iTrueDamage = std::max(1, iTrueDamage);
	}

	if (std::max(5, breakdownChanceTotal() - AdjustedRepel) > GC.getGame().getSorenRandNum(100, "BreakdownAttackRoll"))
	{
		pCity->changeDefenseModifier(-iTrueDamage);

		CvWString szBuffer = gDLL->getText("TXT_KEY_MISC_DEFENSES_IN_CITY_REDUCED_TO", pCity->getNameKey(), pCity->getDefenseModifier(false), GET_PLAYER(getOwner()).getNameKey());
		AddDLLMessage(pCity->getOwner(), false, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_BOMBARDED", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_RED(), pCity->getX(), pCity->getY(), true, true);

		szBuffer = gDLL->getText("TXT_KEY_MISC_YOU_REDUCE_CITY_DEFENSES", getNameKey(), pCity->getNameKey(), pCity->getDefenseModifier(false));
		AddDLLMessage(getOwner(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_BOMBARD", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_GREEN(), pCity->getX(), pCity->getY());
	}
}

int CvUnit::getDiminishingReturn(int i) const
{
	if (i < 51)
	{
		return i;
	}
	int iA = 0;
	int iB = 100;

	for (int iC = i; iC > 0; iC /= 2)
	{
		iB /= 2;
		iA += iB;
		i -= iB;
		i /= 2;
		if (i < iB/2 + 1)
		{
			i += iA;
			return i;
		}
	}
	return 0;
}

int CvUnit::getApproaching0Return(int i) const
{
	if (i > 10)
	{
		return i;
	}
	if (i > 0)
	{
		return 9;
	}
	if (i > -10)
	{
		return 8;
	}
	if (i > -20)
	{
		return 7;
	}
	if (i > -40)
	{
		return 6;
	}
	if (i > -80)
	{
		return 5;
	}
	if (i > -160)
	{
		return 4;
	}
	if (i > -320)
	{
		return 3;
	}
	if (i > -640)
	{
		return 2;
	}
	return 1;
}

bool CvUnit::isPursuitPossible(const CvUnit* pOpponent) const
{
	bool bAnswer = true;
	if (GC.getGame().isOption(GAMEOPTION_FIGHT_OR_FLIGHT) && GC.getGame().isOption(GAMEOPTION_SIZE_MATTERS))
	{
		if (pOpponent->canFliesToMove() && !canFliesToMove())
		{
			bAnswer = false;
		}
	}
	return bAnswer;
}

bool CvUnit::hasCannotMergeSplit() const
{
	return getCannotMergeSplitCount() > 0;
}

int CvUnit::getCannotMergeSplitCount() const
{
	return m_iCannotMergeSplitCount;
}

void CvUnit::changeCannotMergeSplitCount(int iNewValue)
{
	m_iCannotMergeSplitCount += iNewValue;
}

int CvUnit::getQualityBaseTotal() const
{
	return m_iQualityBaseTotal;
}

void CvUnit::setQualityBaseTotal(int iNewValue)
{
	m_iQualityBaseTotal = iNewValue;
}

int CvUnit::getGroupBaseTotal() const
{
	return m_iGroupBaseTotal;
}

void CvUnit::setGroupBaseTotal(int iNewValue)
{
	m_iGroupBaseTotal = iNewValue;
}

int CvUnit::getSizeBaseTotal() const
{
	return m_iSizeBaseTotal;
}

void CvUnit::setSizeBaseTotal(int iNewValue)
{
	m_iSizeBaseTotal = iNewValue;
}

int CvUnit::getExtraQuality() const
{
	return m_iExtraQuality;
}

void CvUnit::changeExtraQuality(int iChange)
{
	m_iExtraQuality += iChange;
}

int CvUnit::getExtraGroup() const
{
	return m_iExtraGroup;
}

void CvUnit::changeExtraGroup(int iChange)
{
	GET_PLAYER(getOwner()).changeUnitCountSM(m_eUnitType, -intPow(3, groupRank()-1));
	m_iExtraGroup += iChange;
	GET_PLAYER(getOwner()).changeUnitCountSM(m_eUnitType, intPow(3, groupRank()-1));
}

int CvUnit::getExtraSize() const
{
	return m_iExtraSize;
}

void CvUnit::changeExtraSize(int iChange)
{
	m_iExtraSize += iChange;
}

int CvUnit::qualityRank() const
{
	FASSERT_NOT_NEGATIVE(getQualityBaseTotal());
	return (getQualityBaseTotal() + getExtraQuality());
}

int CvUnit::groupRank() const
{
	FASSERT_NOT_NEGATIVE(getGroupBaseTotal());
	return (getGroupBaseTotal() + getExtraGroup());
}

int CvUnit::sizeRank() const
{
	FASSERT_NOT_NEGATIVE(getSizeBaseTotal());
	return (getSizeBaseTotal() + getExtraSize());
}

// (bAutocheck = true) check will be ordering a 4th potentially mergable unit to
// split instead during it's check processing.
// The thinking behind this method is that when we merge 3 units we want a 4th one that
// was capable of it to be present and to split so that the unit count remains the same
// and for the alternative strategy of splitting to be equally expressed.
// For defense this means you create fodder flak to hold off minimalist unit count
// armies, buying time, and a strong lead defender to make a tough stand
// For attack you have a strong lead attacker to bust through stiff opposition and some
// smaller units to wipe up defenders weakened by collateral (or splitting strategies
// to delay the capture of the city or position.)
// After a few round of such merging among particular types in the same location will
// create a nice gradient of unit group sizes.  Should be interesting to see its effect in play.
// TBSPLIT
bool CvUnit::canMerge(bool bAutocheck) const
{
	FAssertMsg(plot(), "canMerge expects unit plot to be valid");


	if (!GC.getGame().isOption(GAMEOPTION_SIZE_MATTERS))
	{
		return false;
	}

	if (isHuman() && getGroup()->getNumUnits() > 1)
	{
		return false;
	}

	if (isHurt()
		|| isDead()
		|| isFighting()
		|| isCargo()
		|| hasCargo()
		|| isDelayedDeath()
		|| isSpy()
		|| hasMoved()
		|| groupRank() >= eraGroupMergeLimit()
		|| isInhibitMerge())
	{
		return false;
	}

	if (hasCannotMergeSplit())
	{
		return false;
	}

	if (baseWorkRate() > 0)
	{
		return false;
	}

	CvPlot* pPlot = plot();
	int iValidUnitCount = 0;
	foreach_(const CvUnit* pLoopUnit, pPlot->units())
	{
		if (pLoopUnit->getOwner() == getOwner() && pLoopUnit->getID() != getID()

			&& pLoopUnit->getUnitType() == getUnitType()
			&& pLoopUnit->groupRank() == groupRank()
			&& pLoopUnit->qualityRank() == qualityRank()

			&& !pLoopUnit->isHurt()
			&& !pLoopUnit->isDead()
			&& !pLoopUnit->isFighting()
			&& !pLoopUnit->isCargo()
			&& !pLoopUnit->hasCargo()
			&& !pLoopUnit->isDelayedDeath()
			&& !pLoopUnit->isSpy()
			&& !pLoopUnit->hasMoved()
			&& pLoopUnit->baseWorkRate() < 1
			&& pLoopUnit->groupRank() < pLoopUnit->eraGroupMergeLimit()

			&& !pLoopUnit->hasCannotMergeSplit()
			)
		{
			if (!bAutocheck)
			{
				iValidUnitCount++;
			}
			else if (pLoopUnit->AI_getUnitAIType() == AI_getUnitAIType())
			{
				iValidUnitCount++;
			}
			if (bAutocheck)
			{
				if (iValidUnitCount == 3)
				{
					//if (pLoopUnit->canSplit())
					//{
					//	GET_PLAYER(getOwner()).setSplittingUnit(pLoopUnit->getID());
					//}
					//else
					//{
					//	GET_PLAYER(getOwner()).setSplittingUnit(NO_UNIT);
					//}
					return true;
				}
			}
		}
	}
	if (iValidUnitCount >= 2)
	{
		return true;
	}

	return false;
}


bool CvUnit::canSplit() const
{

	if (!GC.getGame().isOption(GAMEOPTION_SIZE_MATTERS))
	{
		return false;
	}

	if (isHurt() || isDead() || isFighting() || isCargo() || hasCargo() || isDelayedDeath() || isSpy() || hasMoved() || isInhibitSplit() )
	{
		return false;
	}

	if (hasCannotMergeSplit())
	{
		return false;
	}

	if (baseWorkRate() > 0)
	{
		return false;
	}

	if (groupRank() <= eraGroupSplitLimit())
	{
		return false;
	}
	return true;
}

// Helpers
bool CvUnit::isGroupUpgradePromotion(PromotionTypes promotion) const
{
	return GC.getPromotionInfo(promotion).getGroupChange() > 0 &&
		(canAcquirePromotion(promotion, PromotionRequirements::Promote | PromotionRequirements::ForOffset) || canAcquirePromotion(promotion));
}

bool CvUnit::isGroupDowngradePromotion(PromotionTypes promotion) const
{
	return GC.getPromotionInfo(promotion).getGroupChange() < 0 &&
		(canAcquirePromotion(promotion, PromotionRequirements::Promote | PromotionRequirements::ForOffset) || canAcquirePromotion(promotion));
}

bool CvUnit::isQualityUpgradePromotion(PromotionTypes promotion) const
{
	return GC.getPromotionInfo(promotion).getQualityChange() > 0 &&
		(canAcquirePromotion(promotion, PromotionRequirements::Promote | PromotionRequirements::ForOffset) || canAcquirePromotion(promotion));
}

bool CvUnit::isQualityDowngradePromotion(PromotionTypes promotion) const
{
	return GC.getPromotionInfo(promotion).getQualityChange() < 0 &&
		(canAcquirePromotion(promotion, PromotionRequirements::Promote | PromotionRequirements::ForOffset) || canAcquirePromotion(promotion));
}


void CvUnit::doMerge()
{
	FAssertMsg(plot() != NULL, "doMerge requires CvUnit plot to be valid");
	GET_PLAYER(getOwner()).setBaseMergeSelectionUnit(getID());
	if (isHuman())
	{
		CvPopupInfo* pInfo = new CvPopupInfo(BUTTONPOPUP_CHOOSE_MERGE_UNIT);
		pInfo->setData1(getID());
		pInfo->setData2(getX());
		pInfo->setData3(getY());
		gDLL->getInterfaceIFace()->addPopup(pInfo, getOwner(), true);
	}
	else
	{
		CvPlot* pPlot = plot();
		CvUnit* pUnit1 = GET_PLAYER(getOwner()).getUnit(GET_PLAYER(getOwner()).getBaseMergeSelectionUnit());
		CvSelectionGroup* pMergingGroup = pUnit1->getGroup();

		foreach_(const CvUnit* pLoopUnit, pPlot->units())
		{
			if (pLoopUnit->getOwner() == getOwner()
				&& pLoopUnit->getID() != pUnit1->getID()

				&& pLoopUnit->getUnitType() == pUnit1->getUnitType()
				&& pLoopUnit->groupRank() == pUnit1->groupRank()
				&& pLoopUnit->qualityRank() == pUnit1->qualityRank()
				&& pLoopUnit->AI_getUnitAIType() == pUnit1->AI_getUnitAIType()

				&& !pLoopUnit->isHurt()
				&& !pLoopUnit->isDead()
				&& !pLoopUnit->isFighting()
				&& !pLoopUnit->isCargo()
				&& !pLoopUnit->hasCargo()
				&& !pLoopUnit->isDelayedDeath()
				&& !pLoopUnit->isSpy()
				&& !pLoopUnit->hasMoved()
				)
			{
				if (GET_PLAYER(getOwner()).getFirstMergeSelectionUnit() == FFreeList::INVALID_INDEX)
				{
					GET_PLAYER(getOwner()).setFirstMergeSelectionUnit(pLoopUnit->getID());
				}
				else if (GET_PLAYER(getOwner()).getSecondMergeSelectionUnit() == FFreeList::INVALID_INDEX)
				{
					GET_PLAYER(getOwner()).setSecondMergeSelectionUnit(pLoopUnit->getID());
					break;
				}
			}
		}

		CvUnit* pUnit2 = GET_PLAYER(getOwner()).getUnit(GET_PLAYER(getOwner()).getFirstMergeSelectionUnit());
		CvUnit* pUnit3 = GET_PLAYER(getOwner()).getUnit(GET_PLAYER(getOwner()).getSecondMergeSelectionUnit());
		UnitTypes eUnitType = pUnit1->getUnitType();

		CvUnit* pkMergedUnit = GET_PLAYER(getOwner()).initUnit(eUnitType, pPlot->getX(), pPlot->getY(), NO_UNITAI, NO_DIRECTION, GC.getGame().getSorenRandNum(10000, "AI Unit Birthmark"));
		/*PROFILE_FUNC();*/
		pUnit1->setFortifyTurns(0);
		pUnit2->setFortifyTurns(0);
		pUnit3->setFortifyTurns(0);

		int iTotalGroupOffset = 1;
		int iTotalQualityOffset = 0;
		for (int iI = 0; iI < GC.getNumPromotionInfos(); iI++)
		{
			PromotionTypes ePromotion = ((PromotionTypes)iI);
			if (GC.getPromotionInfo(ePromotion).getGroupChange() == 0 && GC.getPromotionInfo(ePromotion).getQualityChange() == 0)
			{
				if (pUnit1->isHasPromotion(ePromotion) || pUnit2->isHasPromotion(ePromotion) || pUnit3->isHasPromotion(ePromotion))
				{
					if (GC.getPromotionInfo(ePromotion).isLeader())
					{
						pkMergedUnit->setHasPromotion(ePromotion, true, true);
					}
#ifdef OUTBREAKS_AND_AFFLICTIONS
					else if (GC.getPromotionInfo(ePromotion).getPromotionLine() != NO_PROMOTIONLINE && GC.getPromotionLineInfo(GC.getPromotionInfo(ePromotion).getPromotionLine()).isAffliction())
					{
						if (GC.getGame().isOption(GAMEOPTION_OUTBREAKS_AND_AFFLICTIONS))
						{
							pkMergedUnit->afflict(GC.getPromotionInfo(ePromotion).getPromotionLine());
						}
					}
#endif
					else if (pUnit1->isPromotionFree(ePromotion) || pUnit2->isPromotionFree((PromotionTypes)iI) || pUnit3->isPromotionFree((PromotionTypes)iI))
					{
						pkMergedUnit->setHasPromotion(ePromotion, true, true);
					}
					else if (pUnit1->isHasPromotion(ePromotion) && pUnit2->isHasPromotion(ePromotion) && pUnit3->isHasPromotion(ePromotion))
					{
						pkMergedUnit->setHasPromotion(ePromotion, true, false);
						pkMergedUnit->changeLevel(1);
					}
				}
				if (pUnit1->isHasPromotion(ePromotion))
				{
					if (GC.getPromotionInfo(ePromotion).isEquipment())
					{
						pkMergedUnit->setHasPromotion(ePromotion, true, true);
					}
				}
				// Must include an adjustment here when equipments are able to be inventoried - Shouldn't just lose the 2nd and 3rd unit's equipment.
			}
			else if (GC.getPromotionInfo(ePromotion).getQualityChange() != 0)
			{
				if (pUnit1->isHasPromotion(ePromotion) || pUnit2->isHasPromotion(ePromotion) || pUnit3->isHasPromotion(ePromotion))
				{
					iTotalQualityOffset += GC.getPromotionInfo((PromotionTypes)iI).getQualityChange();
				}
			}
			else if (GC.getPromotionInfo(ePromotion).getGroupChange() != 0)
			{
				if (pUnit1->isHasPromotion(ePromotion) || pUnit2->isHasPromotion(ePromotion) || pUnit3->isHasPromotion(ePromotion))
				{
					iTotalGroupOffset += GC.getPromotionInfo((PromotionTypes)iI).getGroupChange();
				}
			}
		}

		bool bNormalizedGroup = CvUnit::normalizeUnitPromotions(pkMergedUnit, iTotalGroupOffset,
			bind(&CvUnit::isGroupUpgradePromotion, pkMergedUnit, _2),
			bind(&CvUnit::isGroupDowngradePromotion, pkMergedUnit, _2)
		);
		FAssertMsg(bNormalizedGroup, "Could not apply required number of group promotions on merged units");

		bool bNormalizedQuality = CvUnit::normalizeUnitPromotions(pkMergedUnit, iTotalQualityOffset,
			bind(&CvUnit::isQualityUpgradePromotion, pkMergedUnit, _2),
			bind(&CvUnit::isQualityDowngradePromotion, pkMergedUnit, _2)
		);
		FAssertMsg(bNormalizedQuality, "Could not apply required number of quality promotions on merged units");

		//Set New Experience
		int iXP1 = pUnit1->getExperience100();
		int iXP2 = pUnit2->getExperience100();
		int iXP3 = pUnit3->getExperience100();
		int iXP = iXP1 + iXP2 + iXP3;
		if (iXP != 0)
		{
			iXP /= 3;
		}
		pkMergedUnit->setExperience100(iXP);

		pkMergedUnit->checkFreetoCombatClass();
		pkMergedUnit->setGameTurnCreated(pUnit1->getGameTurnCreated());
		pkMergedUnit->m_eOriginalOwner = pUnit1->getOriginalOwner();
		pkMergedUnit->setAutoPromoting(pUnit1->isAutoPromoting());
		pkMergedUnit->testPromotionReady();
		pkMergedUnit->setName(pUnit1->getNameNoDesc());

		if (pUnit1->getLeaderUnitType() != NO_UNIT)
		{
			pkMergedUnit->setLeaderUnitType(pUnit1->getLeaderUnitType());
		}
		if (pUnit2->getLeaderUnitType() != NO_UNIT && pkMergedUnit->getLeaderUnitType() == NO_UNIT)
		{
			pkMergedUnit->setLeaderUnitType(pUnit2->getLeaderUnitType());
		}
		if (pUnit3->getLeaderUnitType() != NO_UNIT && pkMergedUnit->getLeaderUnitType() == NO_UNIT)
		{
			pkMergedUnit->setLeaderUnitType(pUnit3->getLeaderUnitType());
		}
		pkMergedUnit->setInhibitSplit(true);
		pkMergedUnit->joinGroup(pMergingGroup);

		GET_PLAYER(getOwner()).setBaseMergeSelectionUnit(FFreeList::INVALID_INDEX);
		GET_PLAYER(getOwner()).setFirstMergeSelectionUnit(FFreeList::INVALID_INDEX);
		GET_PLAYER(getOwner()).setSecondMergeSelectionUnit(FFreeList::INVALID_INDEX);

		pUnit1->joinGroup(NULL);
		pUnit2->joinGroup(NULL);
		pUnit3->joinGroup(NULL);

		//CvSelectionGroup* dGroup = pUnit1->getGroup();

		pUnit1->getGroup()->AI_setMissionAI(MISSIONAI_DELIBERATE_KILL, NULL, NULL);
		pUnit1->kill(true, NO_PLAYER, true);
		pUnit2->getGroup()->AI_setMissionAI(MISSIONAI_DELIBERATE_KILL, NULL, NULL);
		pUnit2->kill(true, NO_PLAYER, true);
		pUnit3->getGroup()->AI_setMissionAI(MISSIONAI_DELIBERATE_KILL, NULL, NULL);
		pUnit3->kill(true, NO_PLAYER, true);
		//if ( dGroup->getNumUnits() == 0 )
		//{
		//	dGroup->kill();
		//}
	}
}

void CvUnit::doSplit()
{
	GET_PLAYER(getOwner()).setSplittingUnit(getID());
	if (isHuman())
	{
		CvPopupInfo* pInfo = new CvPopupInfo(BUTTONPOPUP_CONFIRM_SPLIT_UNIT);
		pInfo->setData1(getID());
		pInfo->setData2(getX());
		pInfo->setData3(getY());
		gDLL->getInterfaceIFace()->addPopup(pInfo, getOwner(), true);
	}
	else
	{
		CvUnit* pUnit0 = GET_PLAYER(getOwner()).getUnit(GET_PLAYER(getOwner()).getSplittingUnit());
		const UnitTypes eUnitType = pUnit0->getUnitType();
		CvUnit* pUnit1 = GET_PLAYER(getOwner()).initUnit(eUnitType, pUnit0->getX(), pUnit0->getY(), NO_UNITAI, NO_DIRECTION, GC.getGame().getSorenRandNum(10000, "AI Unit Birthmark"));
		CvUnit* pUnit2 = GET_PLAYER(getOwner()).initUnit(eUnitType, pUnit0->getX(), pUnit0->getY(), NO_UNITAI, NO_DIRECTION, GC.getGame().getSorenRandNum(10000, "AI Unit Birthmark"));
		CvUnit* pUnit3 = GET_PLAYER(getOwner()).initUnit(eUnitType, pUnit0->getX(), pUnit0->getY(), NO_UNITAI, NO_DIRECTION, GC.getGame().getSorenRandNum(10000, "AI Unit Birthmark"));

		PROFILE_FUNC();

		// Toffer - Remove any potential buildup promotions
		pUnit0->setFortifyTurns(0);

		int iTotalGroupOffset = -1;
		int iTotalQualityOffset = 0;

		for (int iI = GC.getNumPromotionInfos() -1; iI > -1; iI--)
		{
			const PromotionTypes ePromoX = static_cast<PromotionTypes>(iI);

			if (!pUnit0->isHasPromotion(ePromoX) || pUnit1->isHasPromotion(ePromoX))
			{
				// Toffer - If pUnit1 has it then pUnit2 and 3 should also have it at this point.
				continue;
			}

			if (GC.getPromotionInfo(ePromoX).getQualityChange() != 0)
			{
				iTotalQualityOffset += GC.getPromotionInfo((PromotionTypes)iI).getQualityChange();
			}
			else if (GC.getPromotionInfo(ePromoX).getGroupChange() != 0)
			{
				iTotalGroupOffset += GC.getPromotionInfo((PromotionTypes)iI).getGroupChange();
			}
			else if (GC.getPromotionInfo(ePromoX).isLeader())
			{
				pUnit1->setHasPromotion(ePromoX, true, true);
			}
#ifdef OUTBREAKS_AND_AFFLICTIONS
			else if (GC.getGame().isOption(GAMEOPTION_OUTBREAKS_AND_AFFLICTIONS))
			{
				const PromotionLineTypes ePromoLine = GC.getPromotionInfo(ePromoX).getPromotionLine();

				if (ePromoLine != NO_PROMOTIONLINE && GC.getPromotionLineInfo(ePromoLine).isAffliction())
				{
					pUnit1->afflict(ePromoLine);
					pUnit2->afflict(ePromoLine);
					pUnit3->afflict(ePromoLine);
				}
			}
#endif
			else if (GC.getPromotionInfo(ePromoX).isEquipment())
			{
				pUnit1->setHasPromotion(ePromoX, true, true);
				pUnit2->setHasPromotion(ePromoX, true, true);
				pUnit3->setHasPromotion(ePromoX, true, true);
			}
			else if (pUnit0->isPromotionFree(ePromoX))
			{
				pUnit1->setHasPromotion(ePromoX, true, true);
			}
			else
			{
				pUnit1->setHasPromotion(ePromoX, true, false);
				pUnit2->setHasPromotion(ePromoX, true, false);
				pUnit3->setHasPromotion(ePromoX, true, false);
			}
		}

		std::vector<CvUnit*> newUnits;
		newUnits.push_back(pUnit1);
		newUnits.push_back(pUnit2);
		newUnits.push_back(pUnit3);

		const bool bNormalizedGroup = CvUnit::normalizeUnitPromotions(newUnits, iTotalGroupOffset,
			bind(isGroupUpgradePromotion, pUnit1, _2),
			bind(isGroupDowngradePromotion, pUnit1, _2)
		);
		FAssertMsg(bNormalizedGroup, "Could not apply required number of group promotions on split units");

		const bool bNormalizedQuality = CvUnit::normalizeUnitPromotions(newUnits, iTotalQualityOffset,
			bind(isQualityUpgradePromotion, pUnit1, _2),
			bind(isQualityDowngradePromotion, pUnit1, _2)
		);
		FAssertMsg(bNormalizedQuality, "Could not apply required number of quality promotions on split units");

		if (pUnit0->getLeaderUnitType() != NO_UNIT)
		{
			pUnit1->setLeaderUnitType(pUnit0->getLeaderUnitType());
		}
		CvSelectionGroup* pSplittingGroup = pUnit0->getGroup();

		foreach_(CvUnit* unit, newUnits)
		{
			unit->setInhibitMerge(true);
			//Set New Experience
			unit->setExperience100(pUnit0->getExperience100());
			unit->setLevel(pUnit0->getLevel());
			unit->setGameTurnCreated(pUnit0->getGameTurnCreated());
			unit->m_eOriginalOwner = pUnit0->getOriginalOwner();
			unit->setAutoPromoting(pUnit0->isAutoPromoting());
			unit->setName(pUnit0->getNameNoDesc());
			unit->joinGroup(pSplittingGroup);
		}

		GET_PLAYER(getOwner()).setSplittingUnit(FFreeList::INVALID_INDEX);

		pUnit0->kill(true, NO_PLAYER, true);
	}
}

void CvUnit::setGGExperienceEarnedTowardsType()
{
	//TB notes: This has been setup to allow the UnitCombat tag to take multiple entries but has not been setup to manage this in CvUnit.
	//It paves the way for future potential but leaves the design where it is for now where only the first definition the unit finds will be established.
	//(No examples of setting up a singular text reference on a delayed resolution was part of the motivation here)
	//But it could also lead to a deepening of this system later.
	//ONLY the Primary Category UnitCombats should define what type of general pts are generated by that unit.
	//OR Alternatively, subselections of a given Primary Category (for example: UNITCOMBAT_CIVILIAN) could give its sub-selections designations instead (like UNITCOMBAT_LAW_ENFORCEMENT and UNITCOMBAT_HEALER)
	//In this case, we'd probably want a Great Citizen to give pts to UNITCOMBAT_CIVILIAN when settled in the city BUT such a unit would come more from the GP mechanism instead.

	for (int iI = GC.getNumUnitCombatInfos() - 1; iI > -1; iI--)
	{
		const UnitCombatTypes eType = static_cast<UnitCombatTypes>(iI);

		if (isHasUnitCombat(eType))
		{
			for (int iJ = GC.getUnitCombatInfo(eType).getNumGGptsforUnitTypes() - 1; iJ > -1; iJ--)
			{
				if (GC.getUnitCombatInfo(eType).getGGptsforUnitType(iJ) > -1)
				{
					m_eGGExperienceEarnedTowardsType = static_cast<UnitTypes>(GC.getUnitCombatInfo(eType).getGGptsforUnitType(iJ));
					return;
				}
			}
		}
	}
	m_eGGExperienceEarnedTowardsType = GC.getUNIT_GREAT_GENERAL();
}

UnitTypes CvUnit::getGGExperienceEarnedTowardsType() const
{
	return m_eGGExperienceEarnedTowardsType;
}

int CvUnit::eraGroupMergeLimit() const
{
	return m_pUnitInfo->getBaseGroupRank() + GET_PLAYER(getOwner()).getCurrentEra() + 1;
}

int CvUnit::eraGroupSplitLimit() const
{
	return std::max(1, m_pUnitInfo->getBaseGroupRank() - GET_PLAYER(getOwner()).getCurrentEra() - 1);
}

DomainTypes CvUnit::getDomainCargo() const
{
	if (m_eNewDomainCargo != NO_DOMAIN)
	{
		return m_eNewDomainCargo;
	}
	return (DomainTypes)m_pUnitInfo->getDomainCargo();
}

void CvUnit::setNewDomainCargo(DomainTypes eDomain)
{
	m_eNewDomainCargo = eDomain;
}

SpecialUnitTypes CvUnit::getSpecialCargo() const
{
	if (m_eNewSpecialCargo != NO_SPECIALUNIT)
	{
		return m_eNewSpecialCargo;
	}
	return (SpecialUnitTypes)m_pUnitInfo->getSpecialCargo();
}

void CvUnit::setNewSpecialCargo(SpecialUnitTypes eSpecialUnit)
{
	m_eNewSpecialCargo = eSpecialUnit;
}

SpecialUnitTypes CvUnit::getSMSpecialCargo() const
{
	if (m_eNewSMSpecialCargo != NO_SPECIALUNIT)
	{
		return m_eNewSMSpecialCargo;
	}
	return (SpecialUnitTypes)m_pUnitInfo->getSMSpecialCargo();
}

void CvUnit::setNewSMSpecialCargo(SpecialUnitTypes eSpecialUnit)
{
	if (m_eNewSMSpecialCargo == NO_SPECIALUNIT)
	{
		m_eNewSMSpecialCargo = eSpecialUnit;
	}
}

SpecialUnitTypes CvUnit::getSMNotSpecialCargo() const
{
	if (m_eNewSMNotSpecialCargo != NO_SPECIALUNIT)
	{
		return m_eNewSMNotSpecialCargo;
	}
	return (SpecialUnitTypes)m_pUnitInfo->getSMNotSpecialCargo();
}

void CvUnit::setNewSMNotSpecialCargo(SpecialUnitTypes eSpecialUnit)
{
	m_eNewSMNotSpecialCargo = eSpecialUnit;
}
//
void CvUnit::changeSMCargoSpace(int iChange)
{
	if (iChange != 0)
	{
		m_iSMCargoCapacity += iChange;
		FASSERT_NOT_NEGATIVE(m_iSMCargoCapacity);
		setInfoBarDirty(true);
	}
}

int CvUnit::SMcargoSpace() const
{
	if (!GC.getGame().isOption(GAMEOPTION_SIZE_MATTERS))
	{
		return 0;
	}
	int iCargoCapacity = SMcargoSpaceFilter();

	if (GC.getGame().isOption(GAMEOPTION_SIZE_MATTERS))
	{
		if (getDomainType() == DOMAIN_SEA)
		{
			iCargoCapacity += applySMRank(GET_PLAYER(getOwner()).getNationalNavalCargoSpaceChange(),
				getSizeMattersSpacialOffsetValue(),
				GC.getSIZE_MATTERS_MOST_VOLUMETRIC_MULTIPLIER());
		}
		const SpecialUnitTypes eMissile = (SpecialUnitTypes)GC.getInfoTypeForString("SPECIALUNIT_MISSILE");
		if (SMspecialCargo() == eMissile)
		{
			iCargoCapacity += applySMRank(GET_PLAYER(getOwner()).getNationalMissileCargoSpaceChange(),
				getSizeMattersSpacialOffsetValue(),
				GC.getSIZE_MATTERS_MOST_VOLUMETRIC_MULTIPLIER());
		}
	}
	else
	{
		if (getDomainType() == DOMAIN_SEA)
		{
			iCargoCapacity += GET_PLAYER(getOwner()).getNationalNavalCargoSpaceChange();
		}
		const SpecialUnitTypes eMissile = (SpecialUnitTypes)GC.getInfoTypeForString("SPECIALUNIT_MISSILE");
		if (SMspecialCargo() == eMissile)
		{
			iCargoCapacity += GET_PLAYER(getOwner()).getNationalMissileCargoSpaceChange();
		}
	}
	return iCargoCapacity;
}

int CvUnit::SMcargoSpaceFilter() const
{
	if (getSMCargoCapacity() == 0)
	{
		return SMcargoCapacityPreCheck();
	}
	return getSMCargoCapacity();
}

int CvUnit::SMcargoCapacityPreCheck() const
{
	if (isCarrier())
	{
		return std::max(1, 100 + getCargoCapacitybyType(100));
	}
	return 0;
}

int CvUnit::getSMCargoCapacity() const
{
	return m_iSMCargoCapacity;
}

void CvUnit::setSMCargoCapacity()
{
	m_iSMCargoCapacity = applySMRank(
		SMcargoCapacityPreCheck(), getSizeMattersSpacialOffsetValue(), GC.getSIZE_MATTERS_MOST_VOLUMETRIC_MULTIPLIER()
		);
	FASSERT_NOT_NEGATIVE(m_iSMCargoCapacity);
}

int CvUnit::getExtraMaxHP() const
{
	return m_iExtraMaxHP;
}

void CvUnit::changeExtraMaxHP(int iChange)
{
	m_iExtraMaxHP += iChange;
}

void CvUnit::setExtraMaxHP(int iChange)
{
	m_iExtraMaxHP = iChange;
}

int CvUnit::getMaxHP() const
{
	int iMaxHP = 0;
	if (!GC.getGame().isOption(GAMEOPTION_SIZE_MATTERS) || getSMHPValue() == 0)
	{
		iMaxHP = HPValueTotalPreCheck();
	}
	else
	{
		iMaxHP = getSMHPValue();
	}
	return std::max(1, iMaxHP);
}

int CvUnit::HPValueTotalPreCheck() const
{
	if (GC.getGame().isOption(GAMEOPTION_SIZE_MATTERS))
	{
		return std::max(1, m_pUnitInfo->getMaxHP() + getExtraMaxHP());
	}
	return getApproaching0Return(m_pUnitInfo->getMaxHP() + getExtraMaxHP());
}

int CvUnit::getSMHPValue() const
{
	return m_iSMHPValue;
}

void CvUnit::setSMHPValue()
{
	m_iSMHPValue =
	(
		applySMRank(
			HPValueTotalPreCheck(),
			getSizeMattersOffsetValue(),
			GC.getSIZE_MATTERS_MOST_MULTIPLIER()
		)
	);
	FASSERT_NOT_NEGATIVE(m_iSMHPValue);
}

int CvUnit::getPowerValueTotal() const
{
	return GC.getGame().isOption(GAMEOPTION_SIZE_MATTERS) ? m_iSMPowerValue : m_pUnitInfo->getPowerValue();
}

void CvUnit::setSMPowerValue(bool bForLoad)
{
	const int oldSMPowerValue = m_iSMPowerValue;
	const int m_iSMPowerValue = applySMRank(m_pUnitInfo->getPowerValue(), getSizeMattersOffsetValue(), GC.getSIZE_MATTERS_MOST_MULTIPLIER());
	FASSERT_NOT_NEGATIVE(m_iSMPowerValue);
	if (!bForLoad)
	{
		const int iChange = m_iSMPowerValue - oldSMPowerValue;
		GET_PLAYER(getOwner()).changeUnitPower(iChange);
	}
}

int CvUnit::assetValueTotal() const
{
	return GC.getGame().isOption(GAMEOPTION_SIZE_MATTERS) ? m_iSMAssetValue : m_pUnitInfo->getAssetValue();
}

void CvUnit::setSMAssetValue(bool bForLoad)
{
	const int offsetValue = getSizeMattersOffsetValue();
	if (offsetValue != -15) // Special Case for size cat undefined units
	{
		const int oldSMAssetValue = m_iSMAssetValue;
		m_iSMAssetValue = applySMRank(m_pUnitInfo->getAssetValue(), offsetValue, GC.getSIZE_MATTERS_MOST_MULTIPLIER());
		if (!bForLoad)
		{
			const int iChange = m_iSMAssetValue - oldSMAssetValue;
			GET_PLAYER(getOwner()).changeAssets(iChange);
		}
		FAssertOptionRecalcMsg(GAMEOPTION_SIZE_MATTERS, m_iSMAssetValue >= 0, "Asset value fell below 0");
	}
}

int CvUnit::getCargoVolumeModifier() const
{
	return m_iSMCargoVolumeModifier;
}

void CvUnit::setCargoVolumeModifier(int iNewValue)
{
	m_iSMCargoVolumeModifier = iNewValue;
}

void CvUnit::changeCargoVolumeModifier(int iChange)
{
	setCargoVolumeModifier(getCargoVolumeModifier() + iChange);
}

int CvUnit::getCargoVolume() const
{
	return m_iSMCargoVolume;
}

void CvUnit::setCargoVolume(int iNewValue)
{
	m_iSMCargoVolume = iNewValue;
}

void CvUnit::changeCargoVolume(int iChange)
{
	setCargoVolume(getCargoVolume() + iChange);
}

int CvUnit::getExtraCargoVolume() const
{
	return m_iSMExtraCargoVolume;
}

void CvUnit::setExtraCargoVolume(int iNewValue)
{
	m_iSMExtraCargoVolume = iNewValue;
	if (GC.getGame().isOption(GAMEOPTION_SIZE_MATTERS))
	{
		setSMCargoVolume();
	}
}

void CvUnit::changeExtraCargoVolume(int iChange)
{
	setExtraCargoVolume(getExtraCargoVolume() + iChange);
}

int CvUnit::getSMCargoVolumeBase() const
{
	return std::max(0, 100 + getExtraCargoVolume());
}

int CvUnit::SMCargoVolume() const
{
	if (!GC.getGame().isOption(GAMEOPTION_SIZE_MATTERS))
		return 0;

	return std::max(1, getCargoVolume() == 0 ? getSMCargoVolumeBase() : getCargoVolume()) + isCarrier() * SMgetCargo();
}

void CvUnit::setSMCargoVolume()
{
	m_iSMCargoVolume =
	(
		std::max(
			1,
			applySMRank(
				getSMCargoVolumeBase(),
				getSizeMattersSpacialOffsetValue(),
				GC.getSIZE_MATTERS_MOST_VOLUMETRIC_MULTIPLIER()
			)
		)
	);
}

int CvUnit::getSizeMattersOffsetValue() const
{
	return qualityRank() + groupRank() + sizeRank() - 15;
}

int CvUnit::getSizeMattersSpacialOffsetValue() const
{
	return groupRank() + sizeRank() - 10;
}

int CvUnit::getCargoCapacitybyType(int iValue) const
{
	const SpecialUnitTypes eSpecialUnitDefined = getSMSpecialCargo();
	const SpecialUnitTypes eSpecialUnitDefinedNot = getSMNotSpecialCargo();

	int rankChange = 0;
	if (eSpecialUnitDefined == GC.getSPECIALUNIT_PEOPLE()
	|| eSpecialUnitDefined == GC.getSPECIALUNIT_MISSILE())
	{
		rankChange = -3;
	}
	else if (eSpecialUnitDefined == GC.getSPECIALUNIT_FIGHTER()
		|| eSpecialUnitDefined == GC.getSPECIALUNIT_SEAPLANE()
		|| eSpecialUnitDefinedNot == GC.getSPECIALUNIT_MISSILE())
	{
		rankChange = -1;
	}
	return applySMRank(iValue, rankChange, GC.getSIZE_MATTERS_MOST_VOLUMETRIC_MULTIPLIER());
}

bool CvUnit::isCarrier() const
{
	return
	(
		getSpecialCargo() != NO_SPECIALUNIT
		||
		getSMSpecialCargo() != NO_SPECIALUNIT
		||
		getDomainCargo() != NO_DOMAIN
	);
}

bool CvUnit::isUnitAtBaseGroup() const
{
	return m_pUnitInfo->getBaseGroupRank() == groupRank();
}

bool CvUnit::isUnitAboveBaseGroup() const
{
	return groupRank() > m_pUnitInfo->getBaseGroupRank();
}

bool CvUnit::isUnitBelowBaseGroup() const
{
	return groupRank() < m_pUnitInfo->getBaseGroupRank();
}

//Model of how to use Size Matters Most Multiplicative plug in.
//optional - if there is a flat +/- modifier it plugs in here in the Extra functions
//Confusingly, this is often already in place and is sometimes not well named but is convenient to keep as was.
//Often needs to be moved next to those functions below.
int CvUnit::getExtraBombardRate() const
{
	if (!isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander != NULL)
		{
			return m_iExtraBombardRate + pCommander->m_iExtraBombardRate;
		}
	}
	return m_iExtraBombardRate;
}

void CvUnit::changeExtraBombardRate(int iChange)
{
	m_iExtraBombardRate += iChange;
	if (GC.getGame().isOption(GAMEOPTION_SIZE_MATTERS))
	{
		setSMBombardRate();
	}
	FASSERT_NOT_NEGATIVE(getExtraBombardRate());
}

void CvUnit::setExtraBombardRate(int iChange)
{
	m_iExtraBombardRate = iChange;
	if (GC.getGame().isOption(GAMEOPTION_SIZE_MATTERS))
	{
		setSMBombardRate();
	}
}

// The call that plugs into the rest of the code (final value) - this can be plugged into the existing final - or even be renamed to the existing final (though experience has shown me this causes me tremendous confusion!)
int CvUnit::getBombardRate() const
{
	if (!GC.getGame().isOption(GAMEOPTION_SIZE_MATTERS)
	// if the current final result of the SMM multiplicative mechanism is nothing but an empty shell
	// then this is the first time it's being run so we take from the base value to start.
	// Either that or the base is 0 anyhow.
	|| getSMBombardRate() == 0)
	{
		return std::max(0, getSMBombardRateTotalBase());
	}
	return std::max(0, getSMBombardRate());
}

// The total before the Size Matters multiplicative method adjusts for the final value.
int CvUnit::getSMBombardRateTotalBase() const
{
	// If there is a flat base not defined on the unit itself then it needs to plug in here.
	// The following lines can vary depending on if you want an approaching 0 return, diminishing return, max or whatever
	// size matters most won't need a diminishing return and in fact would be harmed by it as it needs true values to work with
	// In THIS case, units can easily have NO bombard rate (there's a check above to make sure it's not less than 0 as that would be an odd situation.)
	// If this value starts going less than 0 then perhaps a min needs to be established.
	return m_pUnitInfo->getBombardRate() + getExtraBombardRate();
}

int CvUnit::getSMBombardRate() const//The final result of the Multiplicative adjustment
{
	return m_iSMBombardRate;//A separate (likely new) data storage to track the multiplicated value.
}

////The active call to establish the current proper adjusted value.
////This is the core multiplicative method being utilized.
void CvUnit::setSMBombardRate()
{
	m_iSMBombardRate = applySMRank(getSMBombardRateTotalBase(),
		getSizeMattersOffsetValue(),
		GC.getSIZE_MATTERS_MOST_MULTIPLIER());

	// optional but most of these should be above or equal to 0.
	FASSERT_NOT_NEGATIVE(m_iSMBombardRate);
	m_iSMBombardRate = std::max(0, m_iSMBombardRate);
}


int CvUnit::getAirBombCurrRate() const
{
	return getAirBombBaseRate() * getHP() / getMaxHP();
}

int CvUnit::getAirBombBaseRate() const//The call that plugs into the rest of the code (final value) - this can be plugged into the existing final - or even be renamed to the existing final (though experience has shown me this causes me tremendous confusion!)
{
	if (!GC.getGame().isOption(GAMEOPTION_SIZE_MATTERS)
	//if the current final result of the SMM multiplicative mechanism is nothing but an empty shell
	//then this is the first time it's being run so we take from the base value to start.
	//Either that or the base is 0 anyhow.
	|| getSMAirBombBaseRate() == 0)
	{
		return getSMAirBombBaseRateTotalBase();
	}
	return getSMAirBombBaseRate();
}

int CvUnit::getSMAirBombBaseRateTotalBase() const//The total before the Size Matters multiplicative method adjusts for the final value.
{
	return m_pUnitInfo->getBombRate();//Unit base.
}

int CvUnit::getSMAirBombBaseRate() const//The final result of the Multiplicative adjustment
{
	return m_iSMAirBombBaseRate;//A separate (likely new) data storage to track the multiplicated value.
}

//The active call to establish the current proper adjusted value.
//This is the core multiplicative method being utilized.
void CvUnit::setSMAirBombBaseRate()
{
	m_iSMAirBombBaseRate =
	(
		applySMRank
		(
			getSMAirBombBaseRateTotalBase(),
			getSizeMattersOffsetValue(),
			GC.getSIZE_MATTERS_MOST_MULTIPLIER()
		)
	);
	//optional but most of these should be above or equal to 0.
	FASSERT_NOT_NEGATIVE(m_iSMAirBombBaseRate);
	m_iSMAirBombBaseRate = std::max(0, m_iSMAirBombBaseRate);
}

int CvUnit::workRate(bool bMax) const
{
	if (!bMax && !canMove())
	{
		return 0;
	}
	int iRate = baseWorkRate();

	if (iRate == 0)
	{
		return 0;
	}
	int iWorkMod = getWorkModifier() + GET_PLAYER(getOwner()).getWorkerSpeedModifier();

	const CvPlot* pPlot = plot();
	for (int iI = 0; iI < GC.getNumFeatureInfos(); iI++)
	{
		if (pPlot->getFeatureType() == (FeatureTypes)iI)
		{
			iWorkMod += featureWorkPercent((FeatureTypes)iI);
		}
	}
	iWorkMod += terrainWorkPercent(pPlot->getTerrainType());
	{
		const BuildTypes eBuild = getBuildType();

		if (eBuild != NO_BUILD)
		{
			iWorkMod += buildWorkPercent(eBuild);
		}
	}

	if (pPlot->isHills())
	{
		iWorkMod += hillsWorkModifier();
	}
	else if (pPlot->isAsPeak())
	{
		iWorkMod += peaksWorkModifier();
	}

	if (GET_PLAYER(getOwner()).isNormalAI())
	{
		iWorkMod += (
			GC.getHandicapInfo(GC.getGame().getHandicapType()).getAIWorkRateModifier()
			-
			GC.getHandicapInfo(GC.getGame().getHandicapType()).getAIPerEraModifier() * GET_PLAYER(getOwner()).getCurrentEra()
		);
	}
	return getModifiedIntValue(iRate, iWorkMod);
}

// The call that plugs into the rest of the code (final value)
// This can be plugged into the existing final, or even be renamed to the existing final (though experience has shown me this causes me tremendous confusion!)
int CvUnit::baseWorkRate() const
{
	if (!GC.getGame().isOption(GAMEOPTION_SIZE_MATTERS)
	//if the current final result of the SMM multiplicative mechanism is nothing but an empty shell
	//then this is the first time it's being run so we take from the base value to start.
	//Either that or the base is 0 anyhow.
	|| getSMBaseWorkRate() == 0)
	{
		return std::max(0, baseWorkRatePreCheck());
	}
	return std::max(0, getSMBaseWorkRate());
}

int CvUnit::baseWorkRatePreCheck() const//The total before the Size Matters multiplicative method adjusts for the final value.
{
	return std::max(0, m_pUnitInfo->getWorkRate());
}

int CvUnit::getSMBaseWorkRate() const//The final result of the Multiplicative adjustment
{
	return m_iSMBaseWorkRate;//A separate (likely new) data storage to track the multiplicated value.
}

//The active call to establish the current proper adjusted value.
//This is the core multiplicative method being utilized.
void CvUnit::setSMBaseWorkRate()
{
	m_iSMBaseWorkRate =
	(
		applySMRank
		(
			baseWorkRatePreCheck(),
			getSizeMattersSpacialOffsetValue(),
			GC.getSIZE_MATTERS_MOST_VOLUMETRIC_MULTIPLIER()
		)
	);
	//optional but most of these should be above or equal to 0.
	FASSERT_NOT_NEGATIVE(m_iSMBaseWorkRate);
	m_iSMBaseWorkRate = std::max(0, m_iSMBaseWorkRate);
}

int CvUnit::getRevoltProtection() const
{
	return m_pUnitInfo->getCultureGarrisonValue() + m_iRevoltProtection;
}

void CvUnit::changeRevoltProtection(int iChange)
{
	if (iChange != 0)
	{
		m_iRevoltProtection += iChange;

		if (GC.getGame().isOption(GAMEOPTION_SIZE_MATTERS))
		{
			setSMRevoltProtection();
		}
		setInfoBarDirty(true);
	}
}

//need to change references to getRevoltProtection to the following:
int CvUnit::revoltProtectionTotal() const
{
	// The call that plugs into the rest of the code (final value).
	// This can be plugged into the existing final, or even be renamed to the existing final (though experience has shown me this causes me tremendous confusion!).

	if (!GC.getGame().isOption(GAMEOPTION_SIZE_MATTERS)
	// if the current final result of the SMM multiplicative mechanism is nothing but an empty shell
	// then this is the first time it's being run so we take from the base value to start.
	// Either that or the base is 0 anyhow.
	|| getSMRevoltProtection() == 0)
	{
		return std::max(0, revoltProtectionTotalPreCheck());
	}
	return std::max(0, getSMRevoltProtection());
}

int CvUnit::revoltProtectionTotalPreCheck() const//The total before the Size Matters multiplicative method adjusts for the final value.
{
	// Unless we WANT some units to have a negative revolt protection (more likely to revolt when unit is present)
	// which could be useful for criminal mentality afflictions, then this really should be a min of 0.
	return std::max(0, getRevoltProtection());
}

int CvUnit::getSMRevoltProtection() const//The final result of the Multiplicative adjustment
{
	return m_iSMRevoltProtection;//A separate (likely new) data storage to track the multiplicated value.
}

//The active call to establish the current proper adjusted value.
//This is the core multiplicative method being utilized.
void CvUnit::setSMRevoltProtection()
{
	m_iSMRevoltProtection =
	(
		applySMRank
		(
			revoltProtectionTotalPreCheck(),
			getSizeMattersOffsetValue(),
			GC.getSIZE_MATTERS_MOST_MULTIPLIER()
		)
	);
	// optional but most of these should be above or equal to 0.
	FASSERT_NOT_NEGATIVE(m_iSMRevoltProtection);
	m_iSMRevoltProtection = std::max(0, m_iSMRevoltProtection);
}

bool CvUnit::canPerformActionSM() const
{
	return GC.getGame().isOption(GAMEOPTION_SIZE_MATTERS) ? isUnitAtBaseGroup() : true;
}

void CvUnit::setSMValues(bool bForLoad)
{
	CvUnit* pTransportUnit = NULL;

	if (!bForLoad && isCargo())
	{
		pTransportUnit = getTransportUnit();
		setTransportUnit(NULL);
	}
	setSMStrength();
	setSMHPValue();
	setSMAssetValue(bForLoad);
	setSMPowerValue(bForLoad);
	setSMCargoCapacity();
	setSMCargoVolume();
	setSMBombardRate();
	setSMAirBombBaseRate();
	setSMBaseWorkRate();
	setSMRevoltProtection();
	//many missions may require the unit be at base unit defined group size.
		//construct or force a building - code adjusted.
		//
	//property modifiers - huge issues here since they don't compile and become a part of the unit data
		//perhaps if we changed the way that worked they could be modified at the actual unit level.
		//for now property modifying unit types as defined by their general CC categories will have to remain unmergable/unsplittable.
	if (!bForLoad && pTransportUnit != NULL)
	{
		setTransportUnit(pTransportUnit);
	}
}

int CvUnit::rBombardDamage() const
{
	return std::max(0, m_pUnitInfo->getRBombardDamage() + getBaseRBombardDamage() + getExtraRBombardDamage());
}

int CvUnit::getExtraRBombardDamage() const
{
	if (!isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander != NULL)
		{
			return m_iExtraRBombardDamage + pCommander->m_iExtraRBombardDamage;
		}
	}
	return m_iExtraRBombardDamage;
}

void CvUnit::changeExtraRBombardDamage(int iChange)
{
	m_iExtraRBombardDamage += iChange;
	FASSERT_NOT_NEGATIVE(getExtraRBombardDamage());
}

int CvUnit::getBaseRBombardDamage() const
{
	return m_iBaseRBombardDamage;
}

void CvUnit::changeBaseRBombardDamage(int iChange, bool bAdding, UnitCombatTypes eUnitCombat)
{
	if (bAdding && iChange > m_iBaseRBombardDamage)
	{
		m_iBaseRBombardDamage = iChange;
	}
	int iBestValue = 0;
	if (!bAdding && iChange == m_iBaseRBombardDamage)
	{
		for (int iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
		{
			if ((UnitCombatTypes)iI != eUnitCombat && isHasUnitCombat((UnitCombatTypes)iI))
			{
				const int iValue = GC.getUnitCombatInfo((UnitCombatTypes)iI).getRBombardDamageBase();

				if (iValue > iBestValue)
				{
					iBestValue = iValue;
				}
			}
		}
		m_iBaseRBombardDamage = iBestValue;
	}
	FASSERT_NOT_NEGATIVE(getBaseRBombardDamage());
}

int CvUnit::rBombardDamageLimit() const
{
	return
	(
		std::max
		(
			0,
			(
				m_pUnitInfo->getRBombardDamageLimit()
				+ getBaseRBombardDamageLimit()
				+ getExtraRBombardDamageLimit()
			)
			* GC.getMAX_HIT_POINTS() / 100
		)
	);
}

int CvUnit::getExtraRBombardDamageLimit() const
{
	if (!isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander != NULL)
		{
			return m_iExtraRBombardDamageLimit + pCommander->m_iExtraRBombardDamageLimit;
		}
	}
	return m_iExtraRBombardDamageLimit;
}

void CvUnit::changeExtraRBombardDamageLimit(int iChange)
{
	m_iExtraRBombardDamageLimit += iChange;
	FASSERT_NOT_NEGATIVE(getExtraRBombardDamageLimit());
}

int CvUnit::getBaseRBombardDamageLimit() const
{
	return m_iBaseRBombardDamageLimit;
}

void CvUnit::changeBaseRBombardDamageLimit(int iChange, bool bAdding, UnitCombatTypes eUnitCombat)
{
	if (bAdding && iChange > m_iBaseRBombardDamageLimit)
	{
		m_iBaseRBombardDamageLimit = iChange;
	}
	int iBestValue = 0;
	if (!bAdding && iChange == m_iBaseRBombardDamageLimit)
	{
		for (int iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
		{
			if ((UnitCombatTypes)iI != eUnitCombat && isHasUnitCombat((UnitCombatTypes)iI))
			{
				const int iValue = GC.getUnitCombatInfo((UnitCombatTypes)iI).getRBombardDamageLimitBase();

				if (iValue > iBestValue)
				{
					iBestValue = iValue;
				}
			}
		}
		m_iBaseRBombardDamageLimit = iBestValue;
	}
	FASSERT_NOT_NEGATIVE(getBaseRBombardDamageLimit());
}

int CvUnit::rBombardDamageMaxUnits() const
{
	return
	(
		std::max
		(
			0,
			m_pUnitInfo->getRBombardDamageMaxUnits()
			+ getBaseRBombardDamageMaxUnits()
			+ getExtraRBombardDamageMaxUnits()
		)
	);
}

int CvUnit::getExtraRBombardDamageMaxUnits() const
{
	if (!isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander != NULL)
		{
			return m_iExtraRBombardDamageMaxUnits + pCommander->m_iExtraRBombardDamageMaxUnits;
		}
	}
	return m_iExtraRBombardDamageMaxUnits;
}

void CvUnit::changeExtraRBombardDamageMaxUnits(int iChange)
{
	m_iExtraRBombardDamageMaxUnits += iChange;
	FASSERT_NOT_NEGATIVE(getExtraRBombardDamageMaxUnits());
}

int CvUnit::getBaseRBombardDamageMaxUnits() const
{
	return m_iBaseRBombardDamageMaxUnits;
}

void CvUnit::changeBaseRBombardDamageMaxUnits(int iChange, bool bAdding, UnitCombatTypes eUnitCombat)
{
	if (bAdding && iChange > m_iBaseRBombardDamageMaxUnits)
	{
		m_iBaseRBombardDamageMaxUnits = iChange;
	}
	int iBestValue = 0;
	if (!bAdding && iChange == m_iBaseRBombardDamageMaxUnits)
	{
		for (int iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
		{
			if ((UnitCombatTypes)iI != eUnitCombat && isHasUnitCombat((UnitCombatTypes)iI))
			{
				const int iValue = GC.getUnitCombatInfo((UnitCombatTypes)iI).getRBombardDamageMaxUnitsBase();

				if (iValue > iBestValue)
				{
					iBestValue = iValue;
				}
			}
		}
		m_iBaseRBombardDamageMaxUnits = iBestValue;
	}
	FASSERT_NOT_NEGATIVE(getBaseRBombardDamageMaxUnits());
}

int CvUnit::getDCMBombRange() const
{
	return std::max(0, m_pUnitInfo->getDCMBombRange() + getBaseDCMBombRange() + getExtraDCMBombRange());
}

int CvUnit::getExtraDCMBombRange() const
{
	if (!isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander != NULL)
		{
			return m_iExtraDCMBombRange + pCommander->m_iExtraDCMBombRange;
		}
	}
	return m_iExtraDCMBombRange;
}

void CvUnit::changeExtraDCMBombRange(int iChange)
{
	m_iExtraDCMBombRange += iChange;
}

int CvUnit::getBaseDCMBombRange() const
{
	return m_iBaseDCMBombRange;
}

void CvUnit::changeBaseDCMBombRange(int iChange, bool bAdding, UnitCombatTypes eUnitCombat)
{
	if (bAdding && iChange > m_iBaseDCMBombRange)
	{
		m_iBaseDCMBombRange = iChange;
	}
	int iBestValue = 0;
	if (!bAdding && iChange == m_iBaseDCMBombRange)
	{
		for (int iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
		{
			if ((UnitCombatTypes)iI != eUnitCombat && isHasUnitCombat((UnitCombatTypes)iI))
			{
				const int iValue = GC.getUnitCombatInfo((UnitCombatTypes)iI).getDCMBombRangeBase();

				if (iValue > iBestValue)
				{
					iBestValue = iValue;
				}
			}
		}
		m_iBaseDCMBombRange = iBestValue;
	}
	FASSERT_NOT_NEGATIVE(getBaseDCMBombRange());
}

int CvUnit::getDCMBombAccuracy() const
{
	return std::max(0, m_pUnitInfo->getDCMBombAccuracy() + getBaseDCMBombAccuracy() + getExtraDCMBombAccuracy());
}

int CvUnit::getExtraDCMBombAccuracy() const
{
	if (!isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander != NULL)
		{
			return m_iExtraDCMBombAccuracy + pCommander->m_iExtraDCMBombAccuracy;
		}
	}
	return m_iExtraDCMBombAccuracy;
}

void CvUnit::changeExtraDCMBombAccuracy(int iChange)
{
	m_iExtraDCMBombAccuracy += iChange;
}

int CvUnit::getBaseDCMBombAccuracy() const
{
	return m_iBaseDCMBombAccuracy;
}

void CvUnit::changeBaseDCMBombAccuracy(int iChange, bool bAdding, UnitCombatTypes eUnitCombat)
{
	if (bAdding && iChange > m_iBaseDCMBombAccuracy)
	{
		m_iBaseDCMBombAccuracy = iChange;
	}
	int iBestValue = 0;
	if (!bAdding && iChange == m_iBaseDCMBombAccuracy)
	{
		for (int iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
		{
			if ((UnitCombatTypes)iI != eUnitCombat && isHasUnitCombat((UnitCombatTypes)iI))
			{
				const int iValue = GC.getUnitCombatInfo((UnitCombatTypes)iI).getDCMBombAccuracyBase();

				if (iValue > iBestValue)
				{
					iBestValue = iValue;
				}
			}
		}
		m_iBaseDCMBombAccuracy = iBestValue;
	}
	FASSERT_NOT_NEGATIVE(getBaseDCMBombAccuracy());
}

bool CvUnit::isRBombardDirect() const
{
	return m_iBombardDirectCount > 0;
}

void CvUnit::changeBombardDirectCount(int iChange)
{
	m_iBombardDirectCount += iChange;
}

// Applies rank scaling to a value, with overflow protection.
// rankMultiplier should be scaled up by 100 (e.g. 300 instead of 3).
// rankChange can be positive or negative.
// Equation demonstrated here: https://www.desmos.com/calculator/wivft5kfcc
int CvUnit::applySMRank(int value, int rankChange, int rankMultiplier)
{
	FAssertMsg(rankMultiplier > 0, "rankMultiplier must be greater than 0");
	int64_t lvalue = 100 * value;
	if (rankChange > 0)
	{
		for (int iI = 0; iI < rankChange; iI++)
		{
			lvalue *= rankMultiplier;
			lvalue /= 100;
		}
	}
	else
	{
		for (int iI = 0; iI < -rankChange; iI++)
		{
			lvalue *= 100;
			lvalue /= rankMultiplier;
		}
	}
	return static_cast<int>(std::min<int64_t>(MAX_INT, lvalue / 100));
}

int64_t CvUnit::applySMRank64(int64_t value, int rankChange, int rankMultiplier, bool bScaleUp)
{
	FAssertMsg(rankMultiplier > 0, "rankMultiplier must be greater than 0");
	if (bScaleUp) value *= 100;

	if (rankChange > 0)
	{
		for (int iI = 0; iI < rankChange; iI++)
		{
			value *= rankMultiplier;
			value /= 100;
		}
	}
	else
	{
		for (int iI = 0; iI < -rankChange; iI++)
		{
			value *= 100;
			value /= rankMultiplier;
		}
	}
	if (bScaleUp)
	{
		return value / 100;
	}
	return value;
}


int CvUnit::getNoSelfHealCount() const
{
	return m_iNoSelfHealCount;
}

bool CvUnit::hasNoSelfHeal() const
{
	return getNoSelfHealCount() + m_pUnitInfo->isNoSelfHeal() > 0;
}

void CvUnit::changeNoSelfHealCount(int iChange)
{
	m_iNoSelfHealCount += iChange;
	FASSERT_NOT_NEGATIVE(getNoSelfHealCount());
}

int CvUnit::getSelfHealModifierTotal() const
{
	return m_pUnitInfo->getSelfHealModifier() + m_iExtraSelfHealModifier;
}

void CvUnit::changeExtraSelfHealModifier(int iChange)
{
	m_iExtraSelfHealModifier += iChange;
}

int CvUnit::getNumHealSupportTotal() const
{
	return std::max(0, m_pUnitInfo->getNumHealSupport() + m_iExtraNumHealSupport);
}

void CvUnit::changeExtraNumHealSupport(int iChange)
{
	m_iExtraNumHealSupport += iChange;
}

int CvUnit::getHealSupportUsedTotal() const
{
	return m_iHealSupportUsed;
}

void CvUnit::changeHealSupportUsed(int iChange)
{
	m_iHealSupportUsed += iChange;
}

void CvUnit::setHealSupportUsed(int iChange)
{
	m_iHealSupportUsed = iChange;
}

int CvUnit::getHealSupportRemaining() const
{
	return std::max(0, getNumHealSupportTotal() - getHealSupportUsedTotal());
}

bool CvUnit::hasHealSupportRemaining() const
{
	return getHealSupportRemaining() > 0;
}

MissionTypes CvUnit::getSleepType() const
{
	return m_eSleepType;
}

void CvUnit::setSleepType(MissionTypes eSleepType)
{
	m_eSleepType = eSleepType;
}

void CvUnit::establishBuildups()
{
	m_bHasBuildUp = false;

	for (std::map<PromotionLineTypes, PromotionLineKeyedInfo>::iterator it = m_promotionLineKeyedInfo.begin(), end = m_promotionLineKeyedInfo.end(); it != end; ++it)
	{
		it->second.m_bValidBuildUp = false;
	}

	for (int iI = GC.getNumPromotionLineInfos() - 1; iI > -1; iI--)
	{
		const PromotionLineTypes ePromotionLine = static_cast<PromotionLineTypes>(iI);
		const CvPromotionLineInfo& kPromotionLine = GC.getPromotionLineInfo(ePromotionLine);
		if (kPromotionLine.isBuildUp())
		{
			for (int iJ = 0; iJ < kPromotionLine.getNumPromotions(); iJ++)
			{
				const PromotionTypes ePromotion = (PromotionTypes)kPromotionLine.getPromotion(iJ);
				if (GC.getPromotionInfo(ePromotion).getLinePriority() == 1
				&& canAcquirePromotion(ePromotion, PromotionRequirements::IgnoreHas | PromotionRequirements::ForFree | PromotionRequirements::ForBuildUp))
				{
					PromotionLineKeyedInfo* info = findOrCreatePromotionLineKeyedInfo(ePromotionLine);

					info->m_bValidBuildUp = true;
					m_bHasBuildUp = true;
					break;
				}
			}
		}
	}
}

PromotionLineTypes CvUnit::getBuildUpType() const
{
	return m_eCurrentBuildUpType;
}

void CvUnit::setBuildUpType(PromotionLineTypes ePromotionLine, MissionTypes eSleepType)
{
	if (isHuman())
	{
		// Buildup chosen
		if (ePromotionLine != NO_PROMOTIONLINE)
		{
			if (m_eCurrentBuildUpType != ePromotionLine)
			{
				if (m_iBuildUpTurns > 0)
				{
					clearBuildups();
				}
				m_bIsBuildUp = true;
				m_eCurrentBuildUpType = ePromotionLine;
			}
			return;
		}
		// Choose buildup popup
		if (eSleepType != MISSION_AUTO_BUILDUP && eSleepType != MISSION_HEAL_BUILDUP)
		{
			CvPopupInfo* pInfo = new CvPopupInfo(BUTTONPOPUP_CHOOSE_BUILDUP);
			pInfo->setData1(getID());
			gDLL->getInterfaceIFace()->addPopup(pInfo, getOwner());
			return;
		}
	}

	// AI buildup evaluation
	const bool bCanHeal = hasHealUnitCombat() || getSameTileHeal() > 0 || getAdjacentTileHeal() > 0;
	const bool bMustHeal = getDamage() > 0;
	int iBestValue = 0;

	if (isHuman() && eSleepType == MISSION_HEAL_BUILDUP && (bMustHeal || bCanHeal))
	{
		PromotionLineTypes eAssignPromotionLine = NO_PROMOTIONLINE;

		for (std::map<PromotionLineTypes, PromotionLineKeyedInfo>::const_iterator it = m_promotionLineKeyedInfo.begin(), end = m_promotionLineKeyedInfo.end(); it != end; ++it)
		{
			if (it->second.m_bValidBuildUp)
			{
				const PromotionLineTypes ePotentialPromotionLine = it->first;
				const CvPromotionLineInfo& kPotentialPromotionLine = GC.getPromotionLineInfo(ePotentialPromotionLine);

				for (int iI = 0; iI < kPotentialPromotionLine.getNumPromotions(); iI++)
				{
					const PromotionTypes ePromotion = (PromotionTypes)kPotentialPromotionLine.getPromotion(iI);
					const CvPromotionInfo& kPromotion = GC.getPromotionInfo(ePromotion);

					if (kPromotion.getLinePriority() == 1
					&& canAcquirePromotion(ePromotion, PromotionRequirements::IgnoreHas | PromotionRequirements::ForFree | PromotionRequirements::ForBuildUp))
					{
						int iValue = 0;
						if (bCanHeal)
						{
							for (int iJ = 0; iJ < kPromotion.getNumHealUnitCombatChangeTypes(); iJ++)
							{
								iValue += kPromotion.getHealUnitCombatChangeType(iJ).iHeal * getHealUnitCombatTypeTotal((UnitCombatTypes)kPromotion.getHealUnitCombatChangeType(iJ).eUnitCombat);
								iValue += kPromotion.getHealUnitCombatChangeType(iJ).iAdjacentHeal * getHealUnitCombatTypeAdjacentTotal((UnitCombatTypes)kPromotion.getHealUnitCombatChangeType(iJ).eUnitCombat);
							}
							iValue += kPromotion.getSameTileHealChange() * 100;
							iValue += kPromotion.getAdjacentTileHealChange() * 10;
						}
						if (bMustHeal)
						{
							iValue += kPromotion.getSelfHealModifier() * 100;
						}
						if (iValue > iBestValue)
						{
							iBestValue = iValue;
							eAssignPromotionLine = ePotentialPromotionLine;
						}
					}
				}
			}
		}
		if (eAssignPromotionLine == NO_PROMOTIONLINE && isBuildUpable())
		{
			FErrorMsg("This shouldn't happen");
			// Try again
			establishBuildups();

			if (isBuildUpable())
			{
				setBuildUpType(NO_PROMOTIONLINE, MISSION_AUTO_BUILDUP);
			}
			return;
		}

		if (eAssignPromotionLine != m_eCurrentBuildUpType)
		{
			if (m_iBuildUpTurns > 0)
			{
				clearBuildups();
			}
			m_eCurrentBuildUpType = eAssignPromotionLine;

			if (m_eCurrentBuildUpType != NO_PROMOTIONLINE)
			{
				m_bIsBuildUp = true;
			}
		}
		return;
	}
	// Here is were we can implement some AI selection methodology.
	PromotionLineTypes eAssignPromotionLine = NO_PROMOTIONLINE;

	for (std::map<PromotionLineTypes, PromotionLineKeyedInfo>::const_iterator it = m_promotionLineKeyedInfo.begin(), end = m_promotionLineKeyedInfo.end(); it != end; ++it)
	{
		if (it->second.m_bValidBuildUp)
		{
			const PromotionLineTypes ePotentialPromotionLine = it->first;
			const CvPromotionLineInfo& kPotentialPromotionLine = GC.getPromotionLineInfo(ePotentialPromotionLine);
			for (int iI = 0; iI < kPotentialPromotionLine.getNumPromotions(); iI++)
			{
				const PromotionTypes ePromotion = (PromotionTypes)kPotentialPromotionLine.getPromotion(iI);
				if (GC.getPromotionInfo(ePromotion).getLinePriority() == 1
				&& canAcquirePromotion(ePromotion, PromotionRequirements::IgnoreHas | PromotionRequirements::ForFree | PromotionRequirements::ForBuildUp))
				{
					const int iValue = std::max(1, GET_PLAYER(getOwner()).AI_promotionValue(ePromotion, getUnitType(), this, AI_getUnitAIType(), true));

					if (iValue > iBestValue)
					{
						iBestValue = iValue;
						eAssignPromotionLine = ePotentialPromotionLine;
					}
				}
			}
		}
	}
	if (eAssignPromotionLine == NO_PROMOTIONLINE && isBuildUpable())
	{
		FErrorMsg("This shouldn't happen");
		// Try again
		establishBuildups();

		if (isBuildUpable())
		{
			setBuildUpType(NO_PROMOTIONLINE, MISSION_AUTO_BUILDUP);
		}
		return;
	}

	if (eAssignPromotionLine != m_eCurrentBuildUpType)
	{
		if (m_iBuildUpTurns > 0)
		{
			clearBuildups();
		}
		m_eCurrentBuildUpType = eAssignPromotionLine;

		if (m_eCurrentBuildUpType != NO_PROMOTIONLINE)
		{
			m_bIsBuildUp = true;
		}
	}
}

void CvUnit::clearBuildups()
{
	for (int iJ = 0; iJ < GC.getNumPromotionLineInfos(); iJ++)
	{
		if (GC.getPromotionLineInfo((PromotionLineTypes)iJ).isBuildUp())
		{
			const PromotionLineTypes ePromotionLine = ((PromotionLineTypes)iJ);
			for (int iI = 0; iI < GC.getPromotionLineInfo(ePromotionLine).getNumPromotions(); iI++)
			{
				const PromotionTypes ePromotion = (PromotionTypes)GC.getPromotionLineInfo(ePromotionLine).getPromotion(iI);
				if (isHasPromotion(ePromotion))
				{
					setHasPromotion(ePromotion, false, true, false, false);
				}
			}
		}
	}
	m_iBuildUpTurns = 0;
	m_eCurrentBuildUpType = NO_PROMOTIONLINE;
	setSleepType(NO_MISSION);
	m_bIsBuildUp = false;
	setInfoBarDirty(true);
}

void CvUnit::incrementBuildUp()
{
	if (getBuildUpType() == NO_PROMOTIONLINE)
	{
		FErrorMsg("Units build up status corrupted")
		clearBuildups();
		getGroup()->setActivityType(ACTIVITY_AWAKE);
		return;
	}
	m_iBuildUpTurns++;

	const PromotionLineTypes ePromotionLine = getBuildUpType();

	// AI units will reconsider its buildup on regular intervals.
	if (!isHuman() && 0 == (m_iBuildUpTurns % 11))
	{
		for (int iI = 0; iI < GC.getPromotionLineInfo(ePromotionLine).getNumPromotions(); iI++)
		{
			const PromotionTypes ePromotion = (PromotionTypes)GC.getPromotionLineInfo(ePromotionLine).getPromotion(iI);

			if (GC.getPromotionInfo(ePromotion).getLinePriority() == 1
			&& GET_PLAYER(getOwner()).AI_promotionValue(ePromotion, getUnitType(), this, AI_getUnitAIType(), true) < 10)
			{
				clearBuildups();
				getGroup()->setActivityType(ACTIVITY_AWAKE);
				return;
			}
		}
	}

	for (int iI = 0; iI < GC.getPromotionLineInfo(ePromotionLine).getNumPromotions(); iI++)
	{
		const PromotionTypes ePromotion = (PromotionTypes)GC.getPromotionLineInfo(ePromotionLine).getPromotion(iI);

		if (!isHasPromotion(ePromotion)
		&& GC.getPromotionInfo(ePromotion).getLinePriority() <= m_iBuildUpTurns
		&& canAcquirePromotion(ePromotion, PromotionRequirements::ForFree | PromotionRequirements::ForBuildUp))
		{
			setHasPromotion(ePromotion, true, true, false, false);
		}
	}
}

bool CvUnit::isInhibitMerge() const
{
	return m_bInhibitMerge;
}

void CvUnit::setInhibitMerge(bool bNewValue)
{
	m_bInhibitMerge = bNewValue;
}

bool CvUnit::isInhibitSplit() const
{
	return m_bInhibitSplit;
}

void CvUnit::setInhibitSplit(bool bNewValue)
{
	m_bInhibitSplit = bNewValue;
}

bool CvUnit::isBuildUp() const
{
	return m_bIsBuildUp;
}

void CvUnit::setSpecialUnit(bool bChange, SpecialUnitTypes eSpecialUnit)
{
	m_eSpecialUnit = bChange ? eSpecialUnit : (SpecialUnitTypes)m_pUnitInfo->getSpecialUnitType();
}

bool CvUnit::isHiddenNationality() const
{
	return 0 < getHiddenNationalityCount() + m_pUnitInfo->isHiddenNationality();
}

void CvUnit::doHNCapture()
{
	for (int iI = 0; iI < GC.getNumPromotionInfos(); iI++)
	{
		if (GC.getPromotionInfo((PromotionTypes)iI).isSetOnHNCapture()
		&& canAcquirePromotion((PromotionTypes)iI, PromotionRequirements::ForFree))
		{
			setHasPromotion((PromotionTypes)iI, true, true, false, false);
			m_bHasHNCapturePromotion = true;
			return;
		}
	}
}

void CvUnit::removeHNCapturePromotion()
{
	for (int iI = 0; iI < GC.getNumPromotionInfos(); iI++)
	{
		if (GC.getPromotionInfo((PromotionTypes)iI).isSetOnHNCapture() && isHasPromotion((PromotionTypes)iI))
		{
			setHasPromotion((PromotionTypes)iI, false, true, false, false);
			m_bHasHNCapturePromotion = false;
			return;
		}
	}
}

void CvUnit::processLoadedSpecialUnit(bool bChange, SpecialUnitTypes eSpecialUnit)
{
	const CvSpecialUnitInfo& kSpecialUnit = GC.getSpecialUnitInfo(eSpecialUnit);
	const int iChange = (bChange ? 1 : -1);

	changeExtraCombatPercent(kSpecialUnit.getCombatPercent() * iChange);
	changeExtraWithdrawal(kSpecialUnit.getWithdrawalChange() * iChange);
	changeExtraPursuit(kSpecialUnit.getPursuitChange() * iChange);
}

bool CvUnit::hasBuild(BuildTypes eBuild) const
{
	return isWorker() && (m_pUnitInfo->hasBuild(eBuild) || m_worker->hasExtraBuild(eBuild));
}

void CvUnit::changeExtraBuildType(bool bChange, BuildTypes eBuild)
{
	if (eBuild != NO_BUILD)
	{
		if (bChange)
		{
			if (!isWorker())
			{
				m_worker = new UnitCompWorker();
			}
			m_worker->setExtraBuild(eBuild, true);
		}
		else if (isWorker())
		{
			m_worker->setExtraBuild(eBuild, false);

			if (m_pUnitInfo->getNumBuilds() == 0 && m_worker->getExtraBuilds().size() == 0)
			{
				delete m_worker;
				m_worker = NULL;
			}
		}
	}
}

bool CvUnit::isExcile() const
{
	int iCount = m_iExcileCount;
	if (m_pUnitInfo->isExcile())
	{
		iCount++;
	}
	return (iCount > 0);
}

void CvUnit::changeExcileCount(int iChange)
{
	m_iExcileCount += iChange;
}

bool CvUnit::isPassage() const
{
	int iCount = m_iPassageCount;
	if (m_pUnitInfo->isPassage())
	{
		iCount++;
	}
	return (iCount > 0);
}

void CvUnit::changePassageCount(int iChange)
{
	m_iPassageCount += iChange;
}

bool CvUnit::isNoNonOwnedCityEntry() const
{
	int iCount = m_iNoNonOwnedCityEntryCount;
	if (m_pUnitInfo->isNoNonOwnedCityEntry())
	{
		iCount++;
	}
	return (iCount > 0);
}

void CvUnit::changeNoNonOwnedCityEntryCount(int iChange)
{
	m_iNoNonOwnedCityEntryCount += iChange;
}

bool CvUnit::isBarbCoExist() const
{
	int iCount = m_iBarbCoExistCount;
	if (m_pUnitInfo->isBarbCoExist())
	{
		iCount++;
	}
	return (iCount > 0);
}

void CvUnit::changeBarbCoExistCount(int iChange)
{
	m_iBarbCoExistCount += iChange;
}

bool CvUnit::isBlendIntoCity() const
{
	int iCount = m_iBlendIntoCityCount;
	if (m_pUnitInfo->isBlendIntoCity())
	{
		iCount++;
	}
	return (iCount > 0 || (isAnimal() && canAnimalIgnoresCities()));
}

void CvUnit::changeBlendIntoCityCount(int iChange)
{
	m_iBlendIntoCityCount += iChange;
}

bool CvUnit::isUpgradeAnywhere() const
{
	int iCount = m_iUpgradeAnywhereCount;
	if (m_pUnitInfo->isUpgradeAnywhere())
	{
		iCount++;
	}
	return (iCount > 0);
}

void CvUnit::changeUpgradeAnywhereCount(int iChange)
{
	m_iUpgradeAnywhereCount += iChange;
}

// Only used when unit spot stats change, not when the sight area of this unit change.
void CvUnit::updateSpotIntensity(const InvisibleTypes eInvisibleType, const bool bSameTile)
{
	if (!GC.getGame().isOption(GAMEOPTION_HIDE_AND_SEEK))
	{
		return;
	}
	std::vector<InvisibleTypes> aSeeInvisibleTypes;

	if (eInvisibleType == NO_INVISIBLE)
	{
		for (int iI = GC.getNumInvisibleInfos() - 1; iI > -1; iI--)
		{
			aSeeInvisibleTypes.push_back(static_cast<InvisibleTypes>(iI));
		}
	}
	else aSeeInvisibleTypes.push_back(eInvisibleType);

	const bool bAerial = getDomainType() == DOMAIN_AIR;

	const int iRange = bSameTile ? 0 : visibilityRange(plot());

	for (int i = aSeeInvisibleTypes.size() - 1; i > -1; i--)
	{
		const InvisibleTypes eInvisible = aSeeInvisibleTypes[i];

		for (int dx = -iRange; dx <= iRange; dx++)
		{
			for (int dy = -iRange; dy <= iRange; dy++)
			{
				if (bAerial || plot()->canSeeDisplacementPlot(getTeam(), dx, dy, dx, dy, true, abs(dx) == iRange || abs(dy) == iRange))
				{
					CvPlot* pPlot = plotXY(getX(), getY(), dx, dy);

					if (NULL != pPlot)
					{
						const int iDistance = std::max(abs(dx), abs(dy));

						if (iDistance > 0)
						{
							pPlot->setSpotIntensity(
								getTeam(), eInvisible, getID(),
								visibilityIntensityTotal(eInvisible) - std::max(0, iDistance - visibilityIntensityRangeTotal(eInvisible))
							);
						}
						else
						{
							pPlot->setSpotIntensity(
								getTeam(), eInvisible, getID(),
								visibilityIntensityTotal(eInvisible) + visibilityIntensitySameTileTotal(eInvisible)
							);
						}
					}
				}
			}
		}
	}
}

int CvUnit::visibilityIntensityTotal(InvisibleTypes eInvisibleType) const
{
	int iAmount = (
		m_pUnitInfo->getVisibilityIntensityType(eInvisibleType)
		+ getExtraVisibilityIntensityType(eInvisibleType)
		+ extraVisibleTerrain(eInvisibleType, plot()->getTerrainType())
	);

	if (plot()->isAsPeak())
	{
		iAmount += extraVisibleTerrain(eInvisibleType, GC.getTERRAIN_PEAK());
	}
	else if (plot()->isHills())
	{
		iAmount += extraVisibleTerrain(eInvisibleType, GC.getTERRAIN_HILL());
	}
	const FeatureTypes eFeature = plot()->getFeatureType();
	if (eFeature != NO_FEATURE)
	{
		iAmount += extraVisibleFeature(eInvisibleType, eFeature);
	}
	const ImprovementTypes eImprovement = plot()->getImprovementType();
	if (eImprovement != NO_IMPROVEMENT)
	{
		iAmount += extraVisibleImprovement(eInvisibleType, eImprovement);
	}
	if (plot()->isCity(true))
	{
		iAmount += extraVisibleImprovement(eInvisibleType, GC.getIMPROVEMENT_CITY());
	}
	return iAmount;
}

int CvUnit::getExtraVisibilityIntensityType(InvisibleTypes eIndex) const
{
	FASSERT_BOUNDS(0, GC.getNumInvisibleInfos(), eIndex);

	if (!isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander != NULL)
		{
			return m_aiExtraVisibilityIntensity[eIndex] + pCommander->m_aiExtraVisibilityIntensity[eIndex];
		}
	}
	return m_aiExtraVisibilityIntensity[eIndex];
}


void CvUnit::changeExtraVisibilityIntensityType(InvisibleTypes eIndex, int iChange)
{
	FASSERT_BOUNDS(0, GC.getNumInvisibleInfos(), eIndex);
	if (iChange != 0)
	{
		m_aiExtraVisibilityIntensity[eIndex] += iChange;
		updateSpotIntensity(eIndex);
	}
}

bool CvUnit::hasInvisibilityType(InvisibleTypes eInvisibleType) const
{
	return !isNegatesInvisible(eInvisibleType) && !m_pUnitInfo->isNoInvisibility() && getNoInvisibilityCount() < 1;
}

int CvUnit::invisibilityIntensityTotal(InvisibleTypes eType) const
{
	int iAmount = (
		m_pUnitInfo->getInvisibilityIntensityType(eType)
		+ getExtraInvisibilityIntensityType(eType)
		+ extraInvisibleTerrain(eType, plot()->getTerrainType())
	);

	if (plot()->isAsPeak())
	{
		iAmount += extraInvisibleTerrain(eType, GC.getTERRAIN_PEAK());
	}
	else if (plot()->isHills())
	{
		iAmount += extraInvisibleTerrain(eType, GC.getTERRAIN_HILL());
	}
	const FeatureTypes eFeature = plot()->getFeatureType();
	if (eFeature != NO_FEATURE)
	{
		iAmount += extraInvisibleFeature(eType, eFeature);
	}
	const ImprovementTypes eImprovement = plot()->getImprovementType();
	if (eImprovement != NO_IMPROVEMENT)
	{
		iAmount += extraInvisibleImprovement(eType, eImprovement);
	}
	if (plot()->isCity(true))
	{
		iAmount += extraInvisibleImprovement(eType, GC.getIMPROVEMENT_CITY());
	}
	return iAmount;
}

int CvUnit::getExtraInvisibilityIntensityType(InvisibleTypes eIndex) const
{
	FASSERT_BOUNDS(0, GC.getNumInvisibleInfos(), eIndex);

	if (!isCommander())
	{
		const CvUnit* pCommander = getCommander();
		if (pCommander != NULL)
		{
			return m_aiExtraInvisibilityIntensity[eIndex] + pCommander->m_aiExtraInvisibilityIntensity[eIndex];
		}
	}
	return m_aiExtraInvisibilityIntensity[eIndex];
}


void CvUnit::changeExtraInvisibilityIntensityType(InvisibleTypes eIndex, int iChange)
{
	FASSERT_BOUNDS(0, GC.getNumInvisibleInfos(), eIndex);
	m_aiExtraInvisibilityIntensity[eIndex] += iChange;
}

bool CvUnit::hasAnyInvisibilityType() const
{
	return m_bHasAnyInvisibility;
}

void CvUnit::setHasAnyInvisibility()
{
	if (m_pUnitInfo->isNoInvisibility() || getNoInvisibilityCount() > 0)
	{
		m_bHasAnyInvisibility = false;
		return;
	}
	for (int iI = GC.getNumInvisibleInfos() - 1; iI > -1; iI--)
	{
		if (!isNegatesInvisible((InvisibleTypes)iI))
		{
			m_bHasAnyInvisibility = true;
			return;
		}
	}
	m_bHasAnyInvisibility = false;
}

int CvUnit::visibilityIntensityRangeTotal(InvisibleTypes eInvisibleType) const
{
	int iAmount = (
		m_pUnitInfo->getVisibilityIntensityRangeType(eInvisibleType)
		+ getExtraVisibilityIntensityRangeType(eInvisibleType)
		+ extraVisibleTerrainRange(eInvisibleType, plot()->getTerrainType())
	);

	if (plot()->isAsPeak())
	{
		iAmount += extraVisibleTerrainRange(eInvisibleType, GC.getTERRAIN_PEAK());
	}
	else if (plot()->isHills())
	{
		iAmount += extraVisibleTerrainRange(eInvisibleType, GC.getTERRAIN_HILL());
	}
	const FeatureTypes eFeature = plot()->getFeatureType();
	if (eFeature != NO_FEATURE)
	{
		iAmount += extraVisibleFeatureRange(eInvisibleType, eFeature);
	}
	const ImprovementTypes eImprovement = plot()->getImprovementType();
	if (eImprovement != NO_IMPROVEMENT)
	{
		iAmount += extraVisibleImprovementRange(eInvisibleType, eImprovement);
	}
	if (plot()->isCity(true))
	{
		iAmount += extraVisibleImprovementRange(eInvisibleType, GC.getIMPROVEMENT_CITY());
	}
	return std::max(0, iAmount);
}

int CvUnit::getExtraVisibilityIntensityRangeType(InvisibleTypes eIndex) const
{
	FASSERT_BOUNDS(0, GC.getNumInvisibleInfos(), eIndex);
	return m_aiExtraVisibilityIntensityRange[eIndex];
}


void CvUnit::changeExtraVisibilityIntensityRangeType(InvisibleTypes eIndex, int iChange)
{
	FASSERT_BOUNDS(0, GC.getNumInvisibleInfos(), eIndex);
	if (iChange != 0)
	{
		m_aiExtraVisibilityIntensityRange[eIndex] += iChange;
		updateSpotIntensity(eIndex);
	}
}

int CvUnit::visibilityIntensitySameTileTotal(InvisibleTypes eType) const
{
	FASSERT_BOUNDS(0, GC.getNumInvisibleInfos(), eType);
	return m_aiExtraVisibilityIntensitySameTile[eType];
}


void CvUnit::changeExtraVisibilityIntensitySameTileType(InvisibleTypes eIndex, int iChange)
{
	FASSERT_BOUNDS(0, GC.getNumInvisibleInfos(), eIndex);
	if (iChange != 0)
	{
		m_aiExtraVisibilityIntensitySameTile[eIndex] += iChange;
		updateSpotIntensity(eIndex, true);
	}
}

int CvUnit::getNumExtraInvisibleTerrains() const
{
	return (int)m_aExtraInvisibleTerrains.size();
}

InvisibleTerrainChanges& CvUnit::getExtraInvisibleTerrain(int iIndex)
{
	return m_aExtraInvisibleTerrains[iIndex];
}

void CvUnit::changeExtraInvisibleTerrain(InvisibleTypes eInvisible, TerrainTypes eTerrain, int iChange)
{
	bool bFound = false;
	int iSize = getNumExtraInvisibleTerrains();
	for (int iI = 0; iI < iSize; iI++)
	{
		if (m_aExtraInvisibleTerrains[iI].eInvisible == eInvisible && m_aExtraInvisibleTerrains[iI].eTerrain == eTerrain)
		{
			m_aExtraInvisibleTerrains[iI].iIntensity += iChange;
			if (m_aExtraInvisibleTerrains[iI].iIntensity == 0)
			{
				m_aExtraInvisibleTerrains.erase(m_aExtraInvisibleTerrains.begin()+iI);
			}
			bFound = true;
			break;
		}
	}
	if (!bFound)
	{
		const int iISize = iSize;
		iSize++;
		m_aExtraInvisibleTerrains.resize(iSize);
		m_aExtraInvisibleTerrains[iISize].eInvisible = eInvisible;
		m_aExtraInvisibleTerrains[iISize].eTerrain = eTerrain;
		m_aExtraInvisibleTerrains[iISize].iIntensity = iChange;
	}
}

int CvUnit::extraInvisibleTerrain(InvisibleTypes eInvisible, TerrainTypes eTerrain) const
{
	for (int iI = 0; iI < getNumExtraInvisibleTerrains(); iI++)
	{
		if (m_aExtraInvisibleTerrains[iI].eInvisible == eInvisible && m_aExtraInvisibleTerrains[iI].eTerrain == eTerrain)
		{
			return m_aExtraInvisibleTerrains[iI].iIntensity;
		}
	}
	return 0;
}

int CvUnit::getNumExtraInvisibleFeatures() const
{
	return (int)m_aExtraInvisibleFeatures.size();
}

InvisibleFeatureChanges& CvUnit::getExtraInvisibleFeature(int iIndex)
{
	return m_aExtraInvisibleFeatures[iIndex];
}

void CvUnit::changeExtraInvisibleFeature(InvisibleTypes eInvisible, FeatureTypes eFeature, int iChange)
{
	bool bFound = false;
	int iSize = getNumExtraInvisibleFeatures();
	for (int iI = 0; iI < iSize; iI++)
	{
		if (m_aExtraInvisibleFeatures[iI].eInvisible == eInvisible && m_aExtraInvisibleFeatures[iI].eFeature == eFeature)
		{
			m_aExtraInvisibleFeatures[iI].iIntensity += iChange;
			if (m_aExtraInvisibleFeatures[iI].iIntensity == 0)
			{
				m_aExtraInvisibleFeatures.erase(m_aExtraInvisibleFeatures.begin()+iI);
			}
			bFound = true;
			break;
		}
	}
	if (!bFound)
	{
		const int iISize = iSize;
		iSize++;
		m_aExtraInvisibleFeatures.resize(iSize);
		m_aExtraInvisibleFeatures[iISize].eInvisible = eInvisible;
		m_aExtraInvisibleFeatures[iISize].eFeature = eFeature;
		m_aExtraInvisibleFeatures[iISize].iIntensity = iChange;
	}
}

int CvUnit::extraInvisibleFeature(InvisibleTypes eInvisible, FeatureTypes eFeature) const
{
	for (int iI = 0; iI < getNumExtraInvisibleFeatures(); iI++)
	{
		if (m_aExtraInvisibleFeatures[iI].eInvisible == eInvisible && m_aExtraInvisibleFeatures[iI].eFeature == eFeature)
		{
			return m_aExtraInvisibleFeatures[iI].iIntensity;
		}
	}
	return 0;
}

int CvUnit::getNumExtraInvisibleImprovements() const
{
	return (int)m_aExtraInvisibleImprovements.size();
}

InvisibleImprovementChanges& CvUnit::getExtraInvisibleImprovement(int iIndex)
{
	return m_aExtraInvisibleImprovements[iIndex];
}

void CvUnit::changeExtraInvisibleImprovement(InvisibleTypes eInvisible, ImprovementTypes eImprovement, int iChange)
{
	bool bFound = false;
	int iSize = getNumExtraInvisibleImprovements();
	for (int iI = 0; iI < iSize; iI++)
	{
		if (m_aExtraInvisibleImprovements[iI].eInvisible == eInvisible && m_aExtraInvisibleImprovements[iI].eImprovement == eImprovement)
		{
			m_aExtraInvisibleImprovements[iI].iIntensity += iChange;
			if (m_aExtraInvisibleImprovements[iI].iIntensity == 0)
			{
				m_aExtraInvisibleImprovements.erase(m_aExtraInvisibleImprovements.begin()+iI);
			}
			bFound = true;
			break;
		}
	}
	if (!bFound)
	{
		const int iISize = iSize;
		iSize++;
		m_aExtraInvisibleImprovements.resize(iSize);
		m_aExtraInvisibleImprovements[iISize].eInvisible = eInvisible;
		m_aExtraInvisibleImprovements[iISize].eImprovement = eImprovement;
		m_aExtraInvisibleImprovements[iISize].iIntensity = iChange;
	}
}

int CvUnit::extraInvisibleImprovement(InvisibleTypes eInvisible, ImprovementTypes eImprovement) const
{
	for (int iI = 0; iI < getNumExtraInvisibleImprovements(); iI++)
	{
		if (m_aExtraInvisibleImprovements[iI].eInvisible == eInvisible && m_aExtraInvisibleImprovements[iI].eImprovement == eImprovement)
		{
			return m_aExtraInvisibleImprovements[iI].iIntensity;
		}
	}
	return 0;
}

int CvUnit::getNumExtraVisibleTerrains() const
{
	return (int)m_aExtraVisibleTerrains.size();
}

InvisibleTerrainChanges& CvUnit::getExtraVisibleTerrain(int iIndex)
{
	return m_aExtraVisibleTerrains[iIndex];
}

void CvUnit::changeExtraVisibleTerrain(InvisibleTypes eInvisible, TerrainTypes eTerrain, int iChange)
{
	if (iChange == 0)
	{
		return;
	}
	bool bFound = false;
	const int iSize = getNumExtraVisibleTerrains();
	for (int iI = 0; iI < iSize; iI++)
	{
		if (m_aExtraVisibleTerrains[iI].eInvisible == eInvisible && m_aExtraVisibleTerrains[iI].eTerrain == eTerrain)
		{
			m_aExtraVisibleTerrains[iI].iIntensity += iChange;
			if (m_aExtraVisibleTerrains[iI].iIntensity == 0)
			{
				m_aExtraVisibleTerrains.erase(m_aExtraVisibleTerrains.begin()+iI);
			}
			bFound = true;
			break;
		}
	}
	if (!bFound)
	{
		m_aExtraVisibleTerrains.resize(iSize + 1);
		m_aExtraVisibleTerrains[iSize].eInvisible = eInvisible;
		m_aExtraVisibleTerrains[iSize].eTerrain = eTerrain;
		m_aExtraVisibleTerrains[iSize].iIntensity = iChange;
	}
	updateSpotIntensity(eInvisible);
}

int CvUnit::extraVisibleTerrain(InvisibleTypes eInvisible, TerrainTypes eTerrain) const
{
	for (int iI = 0; iI < getNumExtraVisibleTerrains(); iI++)
	{
		if (m_aExtraVisibleTerrains[iI].eInvisible == eInvisible && m_aExtraVisibleTerrains[iI].eTerrain == eTerrain)
		{
			return m_aExtraVisibleTerrains[iI].iIntensity;
		}
	}
	return 0;
}

int CvUnit::getNumExtraVisibleFeatures() const
{
	return (int)m_aExtraVisibleFeatures.size();
}

InvisibleFeatureChanges& CvUnit::getExtraVisibleFeature(int iIndex)
{
	return m_aExtraVisibleFeatures[iIndex];
}

void CvUnit::changeExtraVisibleFeature(InvisibleTypes eInvisible, FeatureTypes eFeature, int iChange)
{
	if (iChange == 0)
	{
		return;
	}
	const int iSize = getNumExtraVisibleFeatures();
	bool bFound = false;
	for (int iI = 0; iI < iSize; iI++)
	{
		if (m_aExtraVisibleFeatures[iI].eInvisible == eInvisible && m_aExtraVisibleFeatures[iI].eFeature == eFeature)
		{
			m_aExtraVisibleFeatures[iI].iIntensity += iChange;
			if (m_aExtraVisibleFeatures[iI].iIntensity == 0)
			{
				m_aExtraVisibleFeatures.erase(m_aExtraVisibleFeatures.begin()+iI);
			}
			bFound = true;
			break;
		}
	}
	if (!bFound)
	{
		m_aExtraVisibleFeatures.resize(iSize + 1);
		m_aExtraVisibleFeatures[iSize].eInvisible = eInvisible;
		m_aExtraVisibleFeatures[iSize].eFeature = eFeature;
		m_aExtraVisibleFeatures[iSize].iIntensity = iChange;
	}
	updateSpotIntensity(eInvisible);
}

int CvUnit::extraVisibleFeature(InvisibleTypes eInvisible, FeatureTypes eFeature) const
{
	for (int iI = 0; iI < getNumExtraVisibleFeatures(); iI++)
	{
		if (m_aExtraVisibleFeatures[iI].eInvisible == eInvisible && m_aExtraVisibleFeatures[iI].eFeature == eFeature)
		{
			return m_aExtraVisibleFeatures[iI].iIntensity;
		}
	}
	return 0;
}

int CvUnit::getNumExtraVisibleImprovements() const
{
	return (int)m_aExtraVisibleImprovements.size();
}

InvisibleImprovementChanges& CvUnit::getExtraVisibleImprovement(int iIndex)
{
	return m_aExtraVisibleImprovements[iIndex];
}

void CvUnit::changeExtraVisibleImprovement(InvisibleTypes eInvisible, ImprovementTypes eImprovement, int iChange)
{
	if (iChange == 0)
	{
		return;
	}
	const int iSize = getNumExtraVisibleImprovements();
	bool bFound = false;
	for (int iI = 0; iI < iSize; iI++)
	{
		if (m_aExtraVisibleImprovements[iI].eInvisible == eInvisible && m_aExtraVisibleImprovements[iI].eImprovement == eImprovement)
		{
			m_aExtraVisibleImprovements[iI].iIntensity += iChange;
			if (m_aExtraVisibleImprovements[iI].iIntensity == 0)
			{
				m_aExtraVisibleImprovements.erase(m_aExtraVisibleImprovements.begin()+iI);
			}
			bFound = true;
			break;
		}
	}
	if (!bFound)
	{
		m_aExtraVisibleImprovements.resize(iSize + 1);
		m_aExtraVisibleImprovements[iSize].eInvisible = eInvisible;
		m_aExtraVisibleImprovements[iSize].eImprovement = eImprovement;
		m_aExtraVisibleImprovements[iSize].iIntensity = iChange;
	}
	updateSpotIntensity(eInvisible);
}

int CvUnit::extraVisibleImprovement(InvisibleTypes eInvisible, ImprovementTypes eImprovement) const
{
	for (int iI = 0; iI < getNumExtraVisibleImprovements(); iI++)
	{
		if (m_aExtraVisibleImprovements[iI].eInvisible == eInvisible && m_aExtraVisibleImprovements[iI].eImprovement == eImprovement)
		{
			return m_aExtraVisibleImprovements[iI].iIntensity;
		}
	}
	return 0;
}

int CvUnit::getNumExtraVisibleTerrainRanges() const
{
	return (int)m_aExtraVisibleTerrainRanges.size();
}

InvisibleTerrainChanges& CvUnit::getExtraVisibleTerrainRange(int iIndex)
{
	return m_aExtraVisibleTerrainRanges[iIndex];
}

void CvUnit::changeExtraVisibleTerrainRange(InvisibleTypes eInvisible, TerrainTypes eTerrain, int iChange)
{
	if (iChange == 0)
	{
		return;
	}
	const int iSize = getNumExtraVisibleTerrainRanges();
	bool bFound = false;
	for (int iI = 0; iI < iSize; iI++)
	{
		if (m_aExtraVisibleTerrainRanges[iI].eInvisible == eInvisible && m_aExtraVisibleTerrainRanges[iI].eTerrain == eTerrain)
		{
			m_aExtraVisibleTerrainRanges[iI].iIntensity += iChange;
			if (m_aExtraVisibleTerrainRanges[iI].iIntensity == 0)
			{
				m_aExtraVisibleTerrainRanges.erase(m_aExtraVisibleTerrainRanges.begin()+iI);
			}
			bFound = true;
			break;
		}
	}
	if (!bFound)
	{
		m_aExtraVisibleTerrainRanges.resize(iSize + 1);
		m_aExtraVisibleTerrainRanges[iSize].eInvisible = eInvisible;
		m_aExtraVisibleTerrainRanges[iSize].eTerrain = eTerrain;
		m_aExtraVisibleTerrainRanges[iSize].iIntensity = iChange;
	}
	updateSpotIntensity(eInvisible);
}

int CvUnit::extraVisibleTerrainRange(InvisibleTypes eInvisible, TerrainTypes eTerrain) const
{
	for (int iI = 0; iI < getNumExtraVisibleTerrainRanges(); iI++)
	{
		if (m_aExtraVisibleTerrainRanges[iI].eInvisible == eInvisible && m_aExtraVisibleTerrainRanges[iI].eTerrain == eTerrain)
		{
			return m_aExtraVisibleTerrainRanges[iI].iIntensity;
		}
	}
	return 0;
}

int CvUnit::getNumExtraVisibleFeatureRanges() const
{
	return (int)m_aExtraVisibleFeatureRanges.size();
}

InvisibleFeatureChanges& CvUnit::getExtraVisibleFeatureRange(int iIndex)
{
	return m_aExtraVisibleFeatureRanges[iIndex];
}

void CvUnit::changeExtraVisibleFeatureRange(InvisibleTypes eInvisible, FeatureTypes eFeature, int iChange)
{
	if (iChange == 0)
	{
		return;
	}
	const int iSize = getNumExtraVisibleFeatureRanges();
	bool bFound = false;
	for (int iI = 0; iI < iSize; iI++)
	{
		if (m_aExtraVisibleFeatureRanges[iI].eInvisible == eInvisible && m_aExtraVisibleFeatureRanges[iI].eFeature == eFeature)
		{
			m_aExtraVisibleFeatureRanges[iI].iIntensity += iChange;
			if (m_aExtraVisibleFeatureRanges[iI].iIntensity == 0)
			{
				m_aExtraVisibleFeatureRanges.erase(m_aExtraVisibleFeatureRanges.begin()+iI);
			}
			bFound = true;
			break;
		}
	}
	if (!bFound)
	{
		m_aExtraVisibleFeatureRanges.resize(iSize + 1);
		m_aExtraVisibleFeatureRanges[iSize].eInvisible = eInvisible;
		m_aExtraVisibleFeatureRanges[iSize].eFeature = eFeature;
		m_aExtraVisibleFeatureRanges[iSize].iIntensity = iChange;
	}
	updateSpotIntensity(eInvisible);
}

int CvUnit::extraVisibleFeatureRange(InvisibleTypes eInvisible, FeatureTypes eFeature) const
{
	for (int iI = 0; iI < getNumExtraVisibleFeatureRanges(); iI++)
	{
		if (m_aExtraVisibleFeatureRanges[iI].eInvisible == eInvisible && m_aExtraVisibleFeatureRanges[iI].eFeature == eFeature)
		{
			return m_aExtraVisibleFeatureRanges[iI].iIntensity;
		}
	}
	return 0;
}

int CvUnit::getNumExtraVisibleImprovementRanges() const
{
	return (int)m_aExtraVisibleImprovementRanges.size();
}

InvisibleImprovementChanges& CvUnit::getExtraVisibleImprovementRange(int iIndex)
{
	return m_aExtraVisibleImprovementRanges[iIndex];
}

void CvUnit::changeExtraVisibleImprovementRange(InvisibleTypes eInvisible, ImprovementTypes eImprovement, int iChange)
{
	if (iChange == 0)
	{
		return;
	}
	const int iSize = getNumExtraVisibleImprovementRanges();
	bool bFound = false;
	for (int iI = 0; iI < iSize; iI++)
	{
		if (m_aExtraVisibleImprovementRanges[iI].eInvisible == eInvisible && m_aExtraVisibleImprovementRanges[iI].eImprovement == eImprovement)
		{
			m_aExtraVisibleImprovementRanges[iI].iIntensity += iChange;
			if (m_aExtraVisibleImprovementRanges[iI].iIntensity == 0)
			{
				m_aExtraVisibleImprovementRanges.erase(m_aExtraVisibleImprovementRanges.begin()+iI);
			}
			bFound = true;
			break;
		}
	}
	if (!bFound)
	{
		m_aExtraVisibleImprovementRanges.resize(iSize + 1);
		m_aExtraVisibleImprovementRanges[iSize].eInvisible = eInvisible;
		m_aExtraVisibleImprovementRanges[iSize].eImprovement = eImprovement;
		m_aExtraVisibleImprovementRanges[iSize].iIntensity = iChange;
	}
	updateSpotIntensity(eInvisible);
}

int CvUnit::extraVisibleImprovementRange(InvisibleTypes eInvisible, ImprovementTypes eImprovement) const
{
	for (int iI = 0; iI < getNumExtraVisibleImprovementRanges(); iI++)
	{
		if (m_aExtraVisibleImprovementRanges[iI].eInvisible == eInvisible && m_aExtraVisibleImprovementRanges[iI].eImprovement == eImprovement)
		{
			return m_aExtraVisibleImprovementRanges[iI].iIntensity;
		}
	}
	return 0;
}

#ifdef OUTBREAKS_AND_AFFLICTIONS
int CvUnit::getNumExtraAidChanges() const
{
	return (int)m_aExtraAidChanges.size();
}

AidStruct& CvUnit::getExtraAidChange(int iIndex)
{
	return m_aExtraAidChanges[iIndex];
}

void CvUnit::changeExtraAidChange(PropertyTypes eProperty, int iChange)
{
	if (iChange == 0)
		return;

	bool bFound = false;
	int iSize = getNumExtraAidChanges();
	for (int iI = 0; iI < iSize; iI++)
	{
		if (m_aExtraAidChanges[iI].eProperty == eProperty)
		{
			m_aExtraAidChanges[iI].iChange += iChange;
			if (m_aExtraAidChanges[iI].iChange == 0)
			{
				m_aExtraAidChanges.erase(m_aExtraAidChanges.begin()+iI);
			}
			bFound = true;
			break;
		}
	}
	if (!bFound)
	{
		const int iISize = iSize;
		iSize++;
		m_aExtraAidChanges.resize(iSize);
		m_aExtraAidChanges[iISize].eProperty = eProperty;
		m_aExtraAidChanges[iISize].iChange = iChange;
	}
}

int CvUnit::extraAidChange(PropertyTypes eProperty) const
{
	for (int iI = 0; iI < getNumExtraAidChanges(); iI++)
	{
		if (m_aExtraAidChanges[iI].eProperty == eProperty)
		{
			return m_aExtraAidChanges[iI].iChange;
		}
	}
	return 0;
}
#endif

bool CvUnit::isNegatesInvisible(InvisibleTypes eInvisible) const
{
	FASSERT_BOUNDS(0, GC.getNumInvisibleInfos(), eInvisible);
	return (getNegatesInvisibleCount(eInvisible) > 0 || isRevealed());
}
int CvUnit::getNegatesInvisibleCount(InvisibleTypes eInvisible) const
{
	FASSERT_BOUNDS(0, GC.getNumInvisibleInfos(), eInvisible);
	return m_aiNegatesInvisibleCount[eInvisible];
}
void CvUnit::changeNegatesInvisibleCount(InvisibleTypes eInvisible, int iChange)
{
	FASSERT_BOUNDS(0, GC.getNumInvisibleInfos(), eInvisible);
	m_aiNegatesInvisibleCount[eInvisible] += iChange;
	setHasAnyInvisibility();
}

bool CvUnit::hasInvisibleAbility() const
{
	if (GC.getGame().isOption(GAMEOPTION_HIDE_AND_SEEK))
	{
		return hasAnyInvisibilityType();
	}

	if ((InvisibleTypes)m_pUnitInfo->getInvisibleType() != NO_INVISIBLE)
	{
		return true;
	}

	return false;
}

bool CvUnit::isCriminal() const
{
	return getInsidiousnessTotal(true) > 0;
}

int CvUnit::getInsidiousnessTotal(bool bCriminalCheck) const
{
	int iTotal = m_pUnitInfo->getInsidiousness();
	iTotal += m_iExtraInsidiousness;
	if (!bCriminalCheck && iTotal > 0)
	{
		if (plot() != NULL)
		{
			const CvCity* pCity = plot()->getPlotCity();
			if (pCity != NULL)
			{
				iTotal += pCity->getExtraInsidiousness();
				iTotal += pCity->getSpecialistInsidiousness();
			}
		}
	}
	return iTotal;
}

void CvUnit::changeExtraInsidiousness(int iChange)
{
	m_iExtraInsidiousness += iChange;
}

int CvUnit::getInvestigationTotal() const
{
	int iTotal = m_pUnitInfo->getInvestigation();
	iTotal += m_iExtraInvestigation;
	return iTotal;
}

void CvUnit::changeExtraInvestigation(int iChange)
{
	m_iExtraInvestigation += iChange;
}

bool CvUnit::criminalSuccessCheck()
{
	int iDice = 1000;
	int iInsidious = getInsidiousnessTotal();
	int iInvestigate = 0;
	int iChance = 0;
	int iRoll = 0;

	if (plot() == NULL)
	{
		return false;
	}

	CvCity* pCity = plot()->getPlotCity();
	bool bSuccess = true;
	if (pCity != NULL)
	{
		iInvestigate = pCity->getInvestigationTotal(true);
		iChance = std::max(0, iInvestigate - iInsidious);
		iRoll = GC.getGame().getSorenRandNum(iDice, "InvestigationRoll");
		if (iRoll < iChance)
		{
			makeWanted(pCity);
			bSuccess = false;
		}
		else
		{
			//Avoided being Investigated
			changeExperience100(5);
		}
	}
	return bSuccess;
}

void CvUnit::doInsidiousnessVSInvestigationCheck()
{
	int iDice = 1000;
	int iInsidious = getInsidiousnessTotal();
	int iInvestigate = 0;
	int iChance = 0;
	int iRoll = 0;

	if (plot() == NULL)
	{
		return;
	}

	CvCity* pCity = plot()->getPlotCity();

	if (pCity != NULL)
	{
		iInvestigate = pCity->getInvestigationTotal(true);
		iChance = std::max(0, iInvestigate - iInsidious);
		iRoll = GC.getGame().getSorenRandNum(iDice, "InvestigationRoll");
		if (iRoll < iChance)
		{
			makeWanted(pCity);
		}
		else
		{
			//Avoided being Investigated
			changeExperience100(5);
		}
	}
}

void CvUnit::doRemoveInvestigatedPromotionCheck()
{
	if (plot() != NULL &&
		(!plot()->isVisible(GET_PLAYER(m_pPlayerInvestigated).getTeam(), false) ||
		(plot()->getOwner() != m_pPlayerInvestigated && (isInvisible(GET_PLAYER(m_pPlayerInvestigated).getTeam(), false, false) || m_pPlayerInvestigated == getOwner()))))
	{
		int iI = 0;
		for (iI = 0; iI < GC.getNumPromotionInfos(); iI++)
		{
			if (GC.getPromotionInfo((PromotionTypes)iI).isSetOnInvestigated() && isHasPromotion((PromotionTypes)iI) )
			{
				PromotionTypes ePromotion = ((PromotionTypes)iI);
				setHasPromotion(ePromotion, false, true, false, false);
				m_pPlayerInvestigated = NO_PLAYER;
			}
		}
	}
}

bool CvUnit::isWantedbyPlayer(PlayerTypes ePlayer) const
{
	return (m_pPlayerInvestigated == ePlayer);
}

bool CvUnit::isWanted() const
{
	return (m_pPlayerInvestigated != NO_PLAYER);
}


void CvUnit::attackSamePlotSpecifiedUnit(CvUnit* pSelectedDefender)
{
	PROFILE_FUNC();

	FAssert(getCombatTimer() == 0);
	m_combatResult.iTurnCount = 0;
	//TB Note: No Strength in numbers possible on such a same plot attack.
	CvPlot* pPlot = plot();
	setAttackPlot(pPlot, false);

	updateCombat(true, pSelectedDefender, true);
}

bool CvUnit::canArrest() const
{
	//is Law Enforcement? - does not check city modifiers, only base
	if (getInvestigationTotal() > 0)
	{
		if (isCargo())
		{
			return false;
		}
		const CvPlot* pPlot = plot();
		if (canMove() && canAttack() && !isDead() && !isFighting() && !isCargo() && !isDelayedDeath() && getGroup()->getNumUnits() == 1)
		{
			if (pPlot != NULL)
			{
				if (!(pPlot->isValidDomainForAction(*this)))
				{
					return false;
				}
				if (pPlot->getNumVisibleWantedCriminals(getOwner()) > 0)
				{
					return true;
				}
			}
		}
	}
	return false;
}

void CvUnit::doArrest()
{
	GET_PLAYER(getOwner()).setArrestingUnit(getID());
	if (isHuman())
	{
		CvPopupInfo* pInfo = new CvPopupInfo(BUTTONPOPUP_CHOOSE_ARREST_UNIT);
		pInfo->setData1(getID());
		pInfo->setData2(getX());
		pInfo->setData3(getY());
		gDLL->getInterfaceIFace()->addPopup(pInfo, getOwner(), true);
	}
	else
	{
		const CvPlot* pPlot = plot();
		if (pPlot != NULL)
		{
			int iBestOdds = 0;
			CvUnit* pBestUnit = NULL;
			foreach_(CvUnit* pLoopUnit, pPlot->units())
			{
				if (pLoopUnit->isWanted())
				{
					if (GET_PLAYER(pLoopUnit->getOwner()).getArrestingUnit() != pLoopUnit->getID())
					{
						if (!pLoopUnit->isInvisible(GET_PLAYER(getOwner()).getTeam(), false) && !pLoopUnit->isDead() && !pLoopUnit->isFighting() && !pLoopUnit->isDelayedDeath() && !pLoopUnit->isSpy())
						{
							const int iOdds = getCombatOdds(this, pLoopUnit);
							if (iOdds > 50 && iOdds > iBestOdds)
							{
								iBestOdds = iOdds;
								pBestUnit = pLoopUnit;
							}
						}
					}
				}
			}
			if (pBestUnit != NULL)
			{
				attackSamePlotSpecifiedUnit(pBestUnit);
			}
		}

		GET_PLAYER(getOwner()).setArrestingUnit(FFreeList::INVALID_INDEX);
	}
}

bool CvUnit::canAmbush(const CvPlot* pPlot, bool bAssassinate) const
{
	if (!GC.getGame().isOption(GAMEOPTION_WITHOUT_WARNING))
	{
		return false;
	}

	if (pPlot == NULL)
	{
		return false;
	}

	if (!canAttack())
	{
		return false;
	}

	if (isCargo())
	{
		return false;
	}

	if (!(pPlot->isValidDomainForAction(*this)))
	{
		return false;
	}

	if (bAssassinate && !isAssassin())
	{
		return false;
	}

	if (!bAssassinate && pPlot->isCity(true))
	{
		return false;
	}

	if (isBlitz() || !isMadeAttack())
	{
		const CvUnit* pDefender = pPlot->getBestDefender(NO_PLAYER, getOwner(), this, true, true, false, bAssassinate);
		if (pDefender != NULL)
		{
			return true;
		}
		//if (pPlot->isVisiblePotentialEnemyDefender(this) || pPlot->isVisiblePotentialEnemyDefenderless(this))
		//{
		//	foreach_(CvUnit* pLoopUnit, pPlot->units())
		//	{
		//		if (bAssassinate && !pLoopUnit->isTargetOf(*this))
		//		{
		//			continue;
		//		}
		//		if (canAttack(*pLoopUnit))
		//		{
		//			return true;
		//		}
		//	}
		//}
	}
	return false;
}

bool CvUnit::doAmbush(bool bAssassinate)
{
	if (!canAmbush(plot(), bAssassinate))
	{
		return false;
	}
	if (bAssassinate && !isAssassin())
	{
		return false;
	}
	if (bAssassinate && plot()->isCity(true))
	{
		doInsidiousnessVSInvestigationCheck();
	}
	if (GET_PLAYER(getOwner()).getAmbushingUnit() == FFreeList::INVALID_INDEX)
	{
		//Get best attacker from selected and send it to be the one selected to attack by setting it as the ambushing unit.
		if (isHuman())
		{
			GET_PLAYER(getOwner()).setAmbushingUnit(getID(), bAssassinate);
			CvPopupInfo* pInfo = new CvPopupInfo(BUTTONPOPUP_CONFIRM_AMBUSH);
			pInfo->setData1(getID());
			pInfo->setData2(getX());
			pInfo->setData3(getY());
			gDLL->getInterfaceIFace()->addPopup(pInfo, getOwner(), true);
		}
		else
		{
			GET_PLAYER(getOwner()).setAmbushingUnit(getID());
			CvPlot* pPlot = plot();
			if (pPlot != NULL)
			{
				CvUnit* pDefender = pPlot->getBestDefender(NO_PLAYER, getOwner(), this, true, true, false, bAssassinate);
				if (pDefender != NULL)
				{
					attackSamePlotSpecifiedUnit(pDefender);
				}
			}
			GET_PLAYER(getOwner()).setAmbushingUnit(FFreeList::INVALID_INDEX);
		}
	}
	return true;
}

void CvUnit::enactAmbush(bool bAssassinate)
{
	CvPlot* pPlot = plot();
	CvUnit* pDefender = pPlot->getBestDefender(NO_PLAYER, getOwner(), this, !gDLL->altKey(), NO_TEAM == getDeclareWarMove(pPlot), false, bAssassinate);
	if (pDefender != NULL)
	{
		attackSamePlotSpecifiedUnit(pDefender);
	}
}

void CvUnit::changeDebugCount(int iChange)
{
	//TB: disabled while recalculating vision every round.
	m_iDebugCount += iChange;
	//assert disabled until I need to run a new test
	/*FAssert(m_iDebugCount >= 0 && m_iDebugCount <= 1);*/
}

void CvUnit::setDebugCount(int iValue)
{
	//TB: disabled while recalculating vision every round.
	m_iDebugCount = iValue;
	FAssert(m_iDebugCount >= 0 && m_iDebugCount <= 1);
}

bool CvUnit::isAssassin() const
{
	int iCount = getAssassinCount();
	if (m_pUnitInfo->isAssassin())
	{
		iCount++;
	}
	return (iCount > 0);
}

int CvUnit::getAssassinCount() const
{
	return m_iAssassinCount;
}

void CvUnit::changeAssassinCount(int iChange)
{
	m_iAssassinCount += iChange;
}

int CvUnit::stealthStrikesTotal() const
{
	if (!GC.getGame().isOption(GAMEOPTION_WITHOUT_WARNING))
	{
		return 0;
	}
	int iAnswer = m_pUnitInfo->getStealthStrikes();
	iAnswer += getExtraStealthStrikes();

	return iAnswer;
}

int CvUnit::getExtraStealthStrikes() const
{
	if (!GC.getGame().isOption(GAMEOPTION_WITHOUT_WARNING))
	{
		return 0;
	}
	return m_iExtraStealthStrikes;
}

void CvUnit::changeExtraStealthStrikes(int iChange)
{
	m_iExtraStealthStrikes += iChange;
}

int CvUnit::stealthCombatModifierTotal() const
{
	if (!GC.getGame().isOption(GAMEOPTION_WITHOUT_WARNING))
	{
		return 0;
	}
	int iAnswer = m_pUnitInfo->getStealthCombatModifier();
	iAnswer += getExtraStealthCombatModifier();

	return iAnswer;
}

int CvUnit::getExtraStealthCombatModifier() const
{
	if (!GC.getGame().isOption(GAMEOPTION_WITHOUT_WARNING))
	{
		return 0;
	}
	return m_iExtraStealthCombatModifier;
}

void CvUnit::changeExtraStealthCombatModifier(int iChange)
{
	m_iExtraStealthCombatModifier += iChange;
}

bool CvUnit::hasStealthDefense() const
{
	if (!GC.getGame().isOption(GAMEOPTION_WITHOUT_WARNING))
	{
		return false;
	}
	int iCount = getStealthDefenseCount();
	if (m_pUnitInfo->isStealthDefense())
	{
		iCount++;
	}
	return (iCount > 0);
}

int CvUnit::getStealthDefenseCount() const
{
	return m_iStealthDefenseCount;
}

void CvUnit::changeStealthDefenseCount(int iChange)
{
	m_iStealthDefenseCount += iChange;
}

void CvUnit::reveal()
{
	m_bRevealed = true;
}

bool CvUnit::isRevealed() const
{
	return m_bRevealed;
}

void CvUnit::changeOnlyDefensiveCount(int iChange)
{
	m_iOnlyDefensiveCount += iChange;
}

void CvUnit::doSetDefaultStatuses()
{
	std::vector<int> m_iDefaultStatusTypes;
	m_iDefaultStatusTypes.clear();
	//Step 1: Assign all statuses from defaults into a local vector to create a singular list
	for (int iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
	{
		if (isHasUnitCombat((UnitCombatTypes)iI))
		{
			const UnitCombatTypes eUnitCombat = ((UnitCombatTypes)iI);
			for (int iJ = 0; iJ < GC.getUnitCombatInfo(eUnitCombat).getNumDefaultStatusTypes(); iJ++)
			{
				m_iDefaultStatusTypes.push_back(GC.getUnitCombatInfo(eUnitCombat).getDefaultStatusType(iJ));
			}
		}
	}
	//Step 2: Compare all statuses in the list to all other statuses in the list to check for the same promotionline.
	//If one of them has the iLinePriority 1 promo in that set, this is supposed to indicate NO status from this group.
	//Let it take default by erasing out of the list any other default statuses in this status group (promotionline).
	for (int iI = 0; iI < (int)m_iDefaultStatusTypes.size(); iI++)
	{
		const PromotionTypes ePromotion = (PromotionTypes)m_iDefaultStatusTypes[iI];
		const PromotionLineTypes ePromotionLine = GC.getPromotionInfo(ePromotion).getPromotionLine();
		for (int iJ = 0; iJ < (int)m_iDefaultStatusTypes.size(); iJ++)
		{
			const PromotionTypes pPromotion = (PromotionTypes)m_iDefaultStatusTypes[iJ];
			const PromotionLineTypes pPromotionLine = GC.getPromotionInfo(pPromotion).getPromotionLine();
			if (pPromotionLine == ePromotionLine && ePromotion != pPromotion)
			{
				if (GC.getPromotionInfo(ePromotion).getLinePriority() == 1)
				{
					m_iDefaultStatusTypes.erase(m_iDefaultStatusTypes.begin()+iJ);
				}
				else if (GC.getPromotionInfo(pPromotion).getLinePriority() == 1)
				{
					m_iDefaultStatusTypes.erase(m_iDefaultStatusTypes.begin()+iI);
				}
			}
		}
	}
	//Step 3: Assign default statuses.
	//The order now doesn't matter so if there are differing statuses in the same group then the last to be set takes precedence.
	for (int iI = 0; iI < (int)m_iDefaultStatusTypes.size(); iI++)
	{
		const PromotionTypes ePromotion = (PromotionTypes)m_iDefaultStatusTypes[iI];
		if (canAcquirePromotion(ePromotion, PromotionRequirements::ForStatus))
		{
			statusUpdate(ePromotion);
		}
	}
}

int CvUnit::trapDamageMaxTotal() const
{
	int iAnswer = m_pUnitInfo->getTrapDamageMax();
	iAnswer += getExtraTrapDamageMax();

	return iAnswer;
}

int CvUnit::getExtraTrapDamageMax() const
{
	return m_iExtraTrapDamageMax;
}

void CvUnit::changeExtraTrapDamageMax(int iChange)
{
	m_iExtraTrapDamageMax += iChange;
}

int CvUnit::trapDamageMinTotal() const
{
	int iAnswer = m_pUnitInfo->getTrapDamageMin();
	iAnswer += getExtraTrapDamageMin();

	return iAnswer;
}

int CvUnit::getExtraTrapDamageMin() const
{
	return m_iExtraTrapDamageMin;
}

void CvUnit::changeExtraTrapDamageMin(int iChange)
{
	m_iExtraTrapDamageMin += iChange;
}

int CvUnit::trapComplexityTotal() const
{
	int iAnswer = m_pUnitInfo->getTrapComplexity();
	iAnswer += getExtraTrapComplexity();

	return iAnswer;
}

int CvUnit::getExtraTrapComplexity() const
{
	return m_iExtraTrapComplexity;
}

void CvUnit::changeExtraTrapComplexity(int iChange)
{
	m_iExtraTrapComplexity += iChange;
}

int CvUnit::trapNumTriggers() const
{
	int iAnswer = m_pUnitInfo->getNumTriggers();
	iAnswer += getExtraNumTriggers();

	return iAnswer;
}

int CvUnit::getExtraNumTriggers() const
{
	return m_iExtraNumTriggers;
}

void CvUnit::changeExtraNumTriggers(int iChange)
{
	m_iExtraNumTriggers += iChange;
}

int CvUnit::trapNumTriggersRemaining() const
{
	int iAnswer = trapNumTriggers();
	iAnswer -= getNumTimesTriggered();

	return iAnswer;
}

int CvUnit::getNumTimesTriggered() const
{
	return m_iNumTimesTriggered;
}

void CvUnit::changeNumTimesTriggered(int iChange)
{
	m_iNumTimesTriggered += iChange;
}

bool CvUnit::isTriggerBeforeAttack() const
{
	int iAnswer = 0;
	if (m_pUnitInfo->isTriggerBeforeAttack())
	{
		iAnswer++;
	}
	iAnswer += getTriggerBeforeAttackCount();

	return (iAnswer > 0);
}

int CvUnit::getTriggerBeforeAttackCount() const
{
	return m_iTriggerBeforeAttackCount;
}

void CvUnit::changeTriggerBeforeAttackCount(int iChange)
{
	m_iTriggerBeforeAttackCount += iChange;
}

int CvUnit::getTrapSetWithPromotionCount(PromotionTypes ePromotion) const
{
	FASSERT_BOUNDS(0, GC.getNumPromotionInfos(), ePromotion);

	const PromotionKeyedInfo* info = findPromotionKeyedInfo(ePromotion);

	return info == NULL ? 0 : info->m_iTrapSetWithPromotionCount;
}

bool CvUnit::hasTrapSetWithPromotion(PromotionTypes ePromotion) const
{
	FASSERT_BOUNDS(0, GC.getNumPromotionInfos(), ePromotion);
	return (getTrapSetWithPromotionCount(ePromotion) > 0);
}

void CvUnit::changeTrapSetWithPromotionCount(PromotionTypes ePromotion, int iChange)
{
	FASSERT_BOUNDS(0, GC.getNumPromotionInfos(), ePromotion);

	if (iChange != 0)
	{
		PromotionKeyedInfo* info = findOrCreatePromotionKeyedInfo(ePromotion);

		info->m_iTrapSetWithPromotionCount += iChange;
	}
}
//

int CvUnit::getTrapImmunityUnitCombatCount(UnitCombatTypes eUnitCombat) const
{
	FASSERT_BOUNDS(0, GC.getNumUnitCombatInfos(), eUnitCombat);

	const UnitCombatKeyedInfo* info = findUnitCombatKeyedInfo(eUnitCombat);

	return info == NULL ? 0 : info->m_iTrapImmunityUnitCombatCount;
}

bool CvUnit::hasTrapImmunityUnitCombat(UnitCombatTypes eUnitCombat) const
{
	FASSERT_BOUNDS(0, GC.getNumUnitCombatInfos(), eUnitCombat);
	return (getTrapImmunityUnitCombatCount(eUnitCombat) > 0);
}

void CvUnit::changeTrapImmunityUnitCombatCount(UnitCombatTypes eUnitCombat, int iChange)
{
	FASSERT_BOUNDS(0, GC.getNumUnitCombatInfos(), eUnitCombat);

	if (iChange != 0)
	{
		UnitCombatKeyedInfo* info = findOrCreateUnitCombatKeyedInfo(eUnitCombat);

		info->m_iTrapImmunityUnitCombatCount += iChange;
	}
}

int CvUnit::getTargetUnitCombatCount(UnitCombatTypes eUnitCombat) const
{
	FASSERT_BOUNDS(0, GC.getNumUnitCombatInfos(), eUnitCombat);

	const UnitCombatKeyedInfo* info = findUnitCombatKeyedInfo(eUnitCombat);

	return info == NULL ? 0 : info->m_iTargetUnitCombatCount;
}

bool CvUnit::hasTargetUnitCombat(UnitCombatTypes eUnitCombat) const
{
	FASSERT_BOUNDS(0, GC.getNumUnitCombatInfos(), eUnitCombat);
	return (getTargetUnitCombatCount(eUnitCombat) > 0);
}

void CvUnit::changeTargetUnitCombatCount(UnitCombatTypes eUnitCombat, int iChange)
{
	FASSERT_BOUNDS(0, GC.getNumUnitCombatInfos(), eUnitCombat);

	if (iChange != 0)
	{
		UnitCombatKeyedInfo* info = findOrCreateUnitCombatKeyedInfo(eUnitCombat);

		info->m_iTargetUnitCombatCount += iChange;
	}
}

int CvUnit::trapDisableUnitCombatTotal(UnitCombatTypes eCombatType) const
{
	int iAmount = m_pUnitInfo->getTrapDisableUnitCombatType(eCombatType);

	iAmount += getExtraTrapDisableUnitCombatType(eCombatType);

	return std::max(0,iAmount);
}

int CvUnit::getExtraTrapDisableUnitCombatType(UnitCombatTypes eIndex) const
{
	FASSERT_BOUNDS(0, GC.getNumUnitCombatInfos(), eIndex);

	const UnitCombatKeyedInfo* info = findUnitCombatKeyedInfo(eIndex);

	return (info == NULL ? 0 : info->m_iExtraTrapDisableUnitCombatType);
}

void CvUnit::changeExtraTrapDisableUnitCombatType(UnitCombatTypes eIndex, int iChange)
{
	FASSERT_BOUNDS(0, GC.getNumUnitCombatInfos(), eIndex);

	if (iChange != 0)
	{
		UnitCombatKeyedInfo* info = findOrCreateUnitCombatKeyedInfo(eIndex);

		info->m_iExtraTrapDisableUnitCombatType += iChange;
	}
}

bool CvUnit::hasExtraTrapDisableUnitCombatType(UnitCombatTypes eIndex) const
{
	return (getExtraTrapDisableUnitCombatType(eIndex) != 0);
}
//

int CvUnit::trapAvoidanceUnitCombatTotal(UnitCombatTypes eCombatType) const
{
	int iAmount = m_pUnitInfo->getTrapAvoidanceUnitCombatType(eCombatType);

	iAmount += getExtraTrapAvoidanceUnitCombatType(eCombatType);

	return std::max(0,iAmount);
}

int CvUnit::getExtraTrapAvoidanceUnitCombatType(UnitCombatTypes eIndex) const
{
	FASSERT_BOUNDS(0, GC.getNumUnitCombatInfos(), eIndex);

	const UnitCombatKeyedInfo* info = findUnitCombatKeyedInfo(eIndex);

	return  (info == NULL ? 0 : info->m_iExtraTrapAvoidanceUnitCombatType);
}

void CvUnit::changeExtraTrapAvoidanceUnitCombatType(UnitCombatTypes eIndex, int iChange)
{
	FASSERT_BOUNDS(0, GC.getNumUnitCombatInfos(), eIndex);

	if (iChange != 0)
	{
		UnitCombatKeyedInfo* info = findOrCreateUnitCombatKeyedInfo(eIndex);

		info->m_iExtraTrapAvoidanceUnitCombatType += iChange;
	}
}

bool CvUnit::hasExtraTrapAvoidanceUnitCombatType(UnitCombatTypes eIndex) const
{
	return (getExtraTrapAvoidanceUnitCombatType(eIndex) != 0);
}

int CvUnit::trapTriggerUnitCombatTotal(UnitCombatTypes eCombatType) const
{
	int iAmount = m_pUnitInfo->getTrapTriggerUnitCombatType(eCombatType);

	iAmount += getExtraTrapTriggerUnitCombatType(eCombatType);

	return std::max(0,iAmount);
}

int CvUnit::getExtraTrapTriggerUnitCombatType(UnitCombatTypes eIndex) const
{
	FASSERT_BOUNDS(0, GC.getNumUnitCombatInfos(), eIndex);

	const UnitCombatKeyedInfo* info = findUnitCombatKeyedInfo(eIndex);

	return (info == NULL ? 0 : info->m_iExtraTrapTriggerUnitCombatType);
}

void CvUnit::changeExtraTrapTriggerUnitCombatType(UnitCombatTypes eIndex, int iChange)
{
	FASSERT_BOUNDS(0, GC.getNumUnitCombatInfos(), eIndex);

	if (iChange != 0)
	{
		UnitCombatKeyedInfo* info = findOrCreateUnitCombatKeyedInfo(eIndex);

		info->m_iExtraTrapTriggerUnitCombatType += iChange;
	}
}

bool CvUnit::hasExtraTrapTriggerUnitCombatType(UnitCombatTypes eIndex) const
{
	return (getExtraTrapTriggerUnitCombatType(eIndex) != 0);
}

bool CvUnit::isTrap() const
{
	return (trapNumTriggers() > 0);
}

bool CvUnit::isArmedTrap() const
{
	return (isTrap() && isArmed());
}

void CvUnit::setTrap(CvUnit* pUnit)
{
	//pUnit is the unit setting the trap
	m_bIsArmed = true;
	for (int iI = 0; iI < GC.getNumPromotionInfos(); iI++)
	{
		if (pUnit->hasTrapSetWithPromotion((PromotionTypes)iI))
		{
			if (canAcquirePromotion((PromotionTypes)iI, PromotionRequirements::ForFree))
			{
				setHasPromotion((PromotionTypes)iI, true, true, false, false);
			}
		}
	}
}

bool CvUnit::isArmed() const
{
	return (m_bIsArmed || getImmobileTimer() > 0);
}

void CvUnit::doTrap(CvUnit* pUnit)
{
	//pUnit is the unit moving onto the trap
	if (!isArmed())
	{
		return;
	}

	//Establish Base Trigger Chance, Avoidance, Disable and Immunities.
	bool bImmune = false;
	int iTriggerPercent = 0;
	int iTrapAvoidance = 0;
	int iTrapDisable = 0;
	int iTrapComplexity = trapComplexityTotal();
	UnitCombatTypes eUnitCombat = NO_UNITCOMBAT;

	for (int iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
	{
		if (isHasUnitCombat((UnitCombatTypes)iI))
		{
			eUnitCombat = (UnitCombatTypes)iI;
			if (pUnit->hasTrapImmunityUnitCombat(eUnitCombat))
			{
				bImmune = true;
			}
			if (pUnit->trapAvoidanceUnitCombatTotal(eUnitCombat) > iTrapAvoidance)
			{
				iTrapAvoidance = pUnit->trapAvoidanceUnitCombatTotal(eUnitCombat);
			}
			if (pUnit->trapDisableUnitCombatTotal(eUnitCombat) > iTrapDisable)
			{
				iTrapDisable = pUnit->trapDisableUnitCombatTotal(eUnitCombat);
			}
		}
		if (pUnit->isHasUnitCombat((UnitCombatTypes)iI))
		{
			eUnitCombat = (UnitCombatTypes)iI;
			if (trapTriggerUnitCombatTotal(eUnitCombat) > 0)
			{
				//Cumulative so that multiple factors can come into play programmed on the trap itself (size/volume in addition to a base amount)
				iTriggerPercent += trapTriggerUnitCombatTotal(eUnitCombat);
			}
		}
	}
	//final trigger chance is reduced by the avoidance ability
	iTriggerPercent -= iTrapAvoidance;

	//Establish % chance to disable: Ability to disable this type of trap minus the complexity factor of the trap (which can be as low as 0 for very easily disabled traps)
	iTrapDisable -= iTrapComplexity;
	bool bTrapDisabled = false;
	if (!isInvisible(pUnit->getTeam(),false,false))
	{
		//Step 1: Disable check
		if (iTrapDisable > 0)
		{
			if (GC.getGame().getSorenRandNum(100, "Trap Disable Check") < iTrapDisable)
			{
				bTrapDisabled = doTrapDisable(pUnit);
			}
		}
	}
	if (!bTrapDisabled)
	{
		//Step 1: Trigger check
		if (iTriggerPercent > 0)
		{
			if (GC.getGame().getSorenRandNum(100, "Trap Trigger Check") < iTriggerPercent)
			{
				doTrapTrigger(pUnit, bImmune);
			}
		}
	}
}

void CvUnit::doTrapTrigger(CvUnit* pUnit, bool bImmune)
{
	CvWString szBuffer;
	int iTrapDmgMin = trapDamageMinTotal();
	int iTrapDmgMax = trapDamageMaxTotal();
	int iTrapDmg = 0;
	int iTrapDmgRange = iTrapDmgMax - iTrapDmgMin;
	changeNumTimesTriggered(1);
	int iDodge = pUnit->dodgeVSOpponentProbTotal(this);
	int iPrecision = precisionVSOpponentProbTotal(pUnit);
	int iArmor = 100 - pUnit->armorVSOpponentProbTotal(this);
	int iChanceToDodge = iDodge - iPrecision;
	if (!bImmune && iChanceToDodge > GC.getGame().getSorenRandNum(100, "Trap Dodge Check"))
	{
		//Trap deals damage, inflicts affliction, and/or nuclear effect
		//damage
		if (iTrapDmgMax > 0)
		{
			iTrapDmg = GC.getGame().getSorenRandNum(iTrapDmgRange, "Trap Damage Check");
			iTrapDmg += iTrapDmgMin;
			iTrapDmg *= iArmor;
			iTrapDmg /= 100;
			if (iTrapDmg > 0)
			{
				pUnit->changeDamage(iTrapDmg, getOwner());
				//message

				const CvWString szBuffer = gDLL->getText("TXT_KEY_MISC_TRAP_TRIGGERED_DAMAGE_SUFFERED", pUnit->getNameKey(), getNameKey(), iTrapDmg);
				AddDLLMessage(pUnit->getOwner(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_POSITIVE_DINK", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_RED(), getX(), getY());
				const CvWString szBuffer2 = gDLL->getText("TXT_KEY_MISC_TRAP_TRIGGERED_DAMAGE_INFLICTED", getNameKey(), pUnit->getNameKey(), iTrapDmg);
				AddDLLMessage(getOwner(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer2, "AS2D_POSITIVE_DINK", MESSAGE_TYPE_INFO, NULL, GC.getCOLOR_GREEN(), getX(), getY());
			}
		}
#ifdef OUTBREAKS_AND_AFFLICTIONS
		//afflict
		if (GC.getGame().isOption(GAMEOPTION_OUTBREAKS_AND_AFFLICTIONS))
		{
			for (int iI = 0; iI < GC.getNumPromotionLineInfos(); iI++)
			{
				if (GC.getPromotionLineInfo((PromotionLineTypes)iI).isAffliction())
				{
					if (hasAfflictOnAttackType((PromotionLineTypes)iI) && isAfflictOnAttackTypeMelee((PromotionLineTypes)iI))
					{
						const PromotionLineTypes eAfflictionLine = ((PromotionLineTypes)iI);
						const int iAfflictChance = getAfflictOnAttackTypeProbability(eAfflictionLine) - pUnit->fortitudeTotal() - pUnit->getUnitAfflictionTolerance(eAfflictionLine);
						const int iAfflictCheckResult = GC.getGame().getSorenRandNum(100, "Trap Affliction Check");
						if (iAfflictCheckResult < iAfflictChance)
						{
							pUnit->afflict(eAfflictionLine, false, this, true, iTrapDmg);
						}
					}
				}
			}
		}
#endif
		//nuclear
		if (nukeRange() == 0 && plot() != NULL)
		{
			nuke(getX(), getY(), true);
		}
	}

	if (trapNumTriggersRemaining() <= 0)
	{
		kill(false, getOwner());
	}
}

bool CvUnit::doTrapDisable(CvUnit* pUnit)
{
	if (!pUnit->isNoCapture() && m_pUnitInfo->getUnitCaptureType() != NO_UNIT)
	{
		setCapturingPlayer(pUnit->getOwner());
		setCapturingUnit(pUnit);
	}

	kill(false, pUnit->getOwner(), true);
	return true;
}

void CvUnit::changeHiddenNationalityCount(int iValue)
{
	m_iHiddenNationalityCount += iValue;
}

int CvUnit::getHiddenNationalityCount() const
{
	return m_iHiddenNationalityCount;
}

int CvUnit::getNoCaptureCount() const
{
	return m_iNoCaptureCount;
}

void CvUnit::changeNoCaptureCount(int iChange)
{
	m_iNoCaptureCount += iChange;
}

void CvUnit::makeWanted(const CvCity* pCity)
{
	if (pCity == NULL)
	{
		return;
	}
	//Is now Wanted
	for (int iI = 0; iI < GC.getNumPromotionInfos(); iI++)
	{
		const PromotionTypes ePromotion = (PromotionTypes)iI;

		if (GC.getPromotionInfo(ePromotion).isSetOnInvestigated()
		&& canAcquirePromotion(ePromotion, PromotionRequirements::ForFree))
		{
			setHasPromotion(ePromotion, true, true, false, false);
			m_pPlayerInvestigated = pCity->getOwner();
			// This is something it has to manage on its own
			if (getGroup()->getNumUnits() > 1)
			{
				joinGroup(NULL);
			}
			//do message
			const CvWString szBuffer = gDLL->getText("TXT_KEY_MISC_INVESTIGATED_WANTED_RESULT", pCity->getNameKey());
			AddDLLMessage(pCity->getOwner(), false, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_POSITIVE_DINK", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_HIGHLIGHT_TEXT(), pCity->getX(), pCity->getY(), true, true);

			const CvWString szBuffer2 = gDLL->getText("TXT_KEY_MISC_INVESTIGATED_BECOME_WANTED", getNameKey(), pCity->getNameKey());
			AddDLLMessage(getOwner(), false, GC.getEVENT_MESSAGE_TIME(), szBuffer2, "AS2D_EXPOSED", MESSAGE_TYPE_INFO, getButton(), GC.getCOLOR_RED(), pCity->getX(), pCity->getY(), true, true);
			return;
		}
	}
}

#ifdef OUTBREAKS_AND_AFFLICTIONS
int CvUnit::getDistanceAttackCommunicability(PromotionLineTypes eAfflictionLine) const
{
	FASSERT_BOUNDS(0, GC.getNumPromotionLineInfos(), eAfflictionLine);

	const PromotionLineKeyedInfo* info = findPromotionLineKeyedInfo(eAfflictionLine);

	int iDistanceAttackCommunicability = (info == NULL ? 0 : info->m_iDistanceAttackCommunicability);

	for (int iI = 0; iI < m_pUnitInfo->getNumDistanceAttackCommunicabilityTypeChanges(); iI++)
	{
		if (m_pUnitInfo->getDistanceAttackCommunicabilityTypeChange(iI).eAfflictionLine == eAfflictionLine)
		{
			iDistanceAttackCommunicability += m_pUnitInfo->getDistanceAttackCommunicabilityTypeChange(iI).iChange;
		}
	}

	return iDistanceAttackCommunicability;
}

void CvUnit::changeDistanceAttackCommunicability(PromotionLineTypes eAfflictionLine, int iChange)
{
	FASSERT_BOUNDS(0, GC.getNumPromotionLineInfos(), eAfflictionLine);

	if (iChange != 0)
	{
		PromotionLineKeyedInfo* info = findOrCreatePromotionLineKeyedInfo(eAfflictionLine);

		info->m_iDistanceAttackCommunicability += iChange;
	}
}

void CvUnit::setDistanceAttackCommunicability(PromotionLineTypes eAfflictionLine, int iValue)
{
	FASSERT_BOUNDS(0, GC.getNumPromotionLineInfos(), eAfflictionLine);

	PromotionLineKeyedInfo* info = findOrCreatePromotionLineKeyedInfo(eAfflictionLine, iValue != 0);

	if (info != NULL)
	{
		info->m_iDistanceAttackCommunicability = iValue;
	}
}
#endif // OUTBREAKS_AND_AFFLICTIONS

void CvUnit::setCityOfOrigin(CvCity* pCity)
{
	m_iXOrigin = pCity->getX();
	m_iYOrigin = pCity->getY();

}

void CvUnit::clearCityOfOrigin()
{
	m_iXOrigin = INVALID_PLOT_COORD;
	m_iYOrigin = INVALID_PLOT_COORD;
}

CvCity* CvUnit::getCityOfOrigin() const
{
	const CvPlot* pPlot = GC.getMap().plotSorenINLINE(m_iXOrigin, m_iYOrigin);
	CvCity* pCity;
	if (pPlot != NULL)
	{
		pCity = pPlot->getPlotCity();
		if (pCity != NULL)
		{
			return pCity;
		}
	}
	return NULL;
}

bool CvUnit::isPromotionFromTrait(PromotionTypes ePromotion) const
{
	FASSERT_BOUNDS(0, GC.getNumPromotionInfos(), ePromotion);

	const PromotionKeyedInfo* info = findPromotionKeyedInfo(ePromotion);

	return info == NULL ? false : info->m_iPromotionFromTraitCount > 0;
}

void CvUnit::setPromotionFromTrait(PromotionTypes ePromotion, bool iChange)
{
	FASSERT_BOUNDS(0, GC.getNumPromotionInfos(), ePromotion);

	PromotionKeyedInfo* info = findOrCreatePromotionKeyedInfo(ePromotion, iChange != 0);

	if (info != NULL)
	{
		info->m_iPromotionFromTraitCount = iChange;
	}
}

bool CvUnit::isGatherHerd() const
{
	return (getGatherHerdCount() > 0);
}
int CvUnit::getGatherHerdCount() const
{
	int iTotal = getExtraGatherHerdCount();
	if (m_pUnitInfo->isGatherHerd())
	{
		iTotal++;
	}
	return iTotal;
}
int CvUnit::getExtraGatherHerdCount() const
{
	return m_iExtraGatherHerdCount;
}
void CvUnit::changeExtraGatherHerdCount(int iChange)
{
	m_iExtraGatherHerdCount += iChange;
}

void CvUnit::defineReligion()
{//call this when a unitcombat that has a religion is processed in and for all units when the state religion is changed.
	//Check for dedicated faith by unit type, assign it and let it not be changeable unless the unit type changes
	if (!m_bIsReligionLocked)//purely meaning the unit has an overriding religious unitcombat in its base definition (like a missionary, crusader or hellsmouth dog would)
	{
		if (m_eReligionType == NO_RELIGION)
		{
			UnitCombatTypes eUnitCombat;

			for (int iI = -1; iI < m_pUnitInfo->getNumSubCombatTypes(); iI++)
			{
				if (iI > -1)
				{
					eUnitCombat = (UnitCombatTypes)m_pUnitInfo->getSubCombatType(iI);
				}
				else
				{
					eUnitCombat = (UnitCombatTypes)m_pUnitInfo->getUnitCombatType();

					if (eUnitCombat == NO_UNITCOMBAT) continue;
				}
				const ReligionTypes eOriginalCombatReligion = GC.getUnitCombatInfo(eUnitCombat).getReligion();

				if (eOriginalCombatReligion != NO_RELIGION)
				{
					m_eReligionType = eOriginalCombatReligion;
					m_bIsReligionLocked = true;
					break;
				}
			}
		}
		if (m_eReligionType == NO_RELIGION)
		{
			//if not locked by innate type, after changes in unitcombat process function we'll call this function IF the unitcombat has a religion.
			//This function is also called if the state religion changes so if we find a unit combat has defined m_eReligionType then we'll not bother with switching to the state religion so check here first
			bool bFound = false;
			for (int iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
			{
				if (isHasUnitCombat((UnitCombatTypes)iI))
				{
					const ReligionTypes eUnitCombatReligion = GC.getUnitCombatInfo((UnitCombatTypes)iI).getReligion();
					if (eUnitCombatReligion != NO_RELIGION)
					{
						m_eReligionType = eUnitCombatReligion; //Let's assume there's only going to be one of these on a unit ever - it only ever comes up if the unit isn't locked with a pre-defined one anyhow
						//and unitcombats that assign a religion should be rare to assign unless we are more advanced into the Ideas project where the city will assign its religion type to all units that it produces.
						//There could be promos that assign overriding religious types but we'll cross that bridge when we get there.
						bFound = true;
						break;//thus we stop at the first one we find
					}
				}
			}
			if (!bFound)
			{
				m_eReligionType = GET_PLAYER(getOwner()).getStateReligion();//NO_RELIGION is a perfectly satisfactory answer here.
			}
		}
	}
	//else do nothing - if the religion is locked we're done here.
}

ReligionTypes CvUnit::getReligion() const
{
	return m_eReligionType;
}

bool CvUnit::isWorker() const
{
	return m_worker != NULL;
}
