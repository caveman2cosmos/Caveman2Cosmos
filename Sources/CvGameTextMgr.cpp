//---------------------------------------------------------------------------------------
//
//  *****************   Civilization IV   ********************
//
//  FILE:	CvGameTextMgr.cpp
//
//  PURPOSE: Interfaces with GameText XML Files to manage the paths of art files
//
//---------------------------------------------------------------------------------------
//  Copyright (c) 2004 Firaxis Games, Inc. All rights reserved.
//---------------------------------------------------------------------------------------

#include "CvBuildingInfo.h"
#include "CvGameCoreDLL.h"
#include "CounterSet.h"
#include "CvGameAI.h"
#include "CvDLLSymbolIFaceBase.h"
#include "CvGameTextMgr.h"
#include "CvPlayerAI.h"
#include "CvTeamAI.h"
#include "CvXMLLoadUtility.h"

int shortenID(int iId)
{
	return iId;
}

// For displaying Asserts and error messages
static char* szErrorMsg;

//	Structure to hold aggregate info about an instances of a unit type and owener
//	on a stacked plot
class PlayerUnitInfo
{
public:
	PlayerUnitInfo()
		: m_eOwner(NO_PLAYER)
		, m_eUnitType(NO_UNIT)
		, m_iTotalStrength(0)
		, m_iTotalMaxStrength(0)
		, m_iCount(0)
	{
	}

	PlayerTypes						m_eOwner;
	UnitTypes						m_eUnitType;
	int								m_iTotalStrength;
	int								m_iTotalMaxStrength;
	int								m_iCount;
	std::map<PromotionTypes,int>	m_promotions;
};

//	Hash to provide a key for maps indexed by unit type and owner
#define	PLAYER_UNIT_KEY(ePlayer,eUnitType)	(((ePlayer) << 16) + (eUnitType))

//----------------------------------------------------------------------------
//
//	FUNCTION:	GetInstance()
//
//	PURPOSE:	Get the instance of this class.
//
//----------------------------------------------------------------------------
CvGameTextMgr& CvGameTextMgr::GetInstance()
{
	static CvGameTextMgr gs_GameTextMgr;
	return gs_GameTextMgr;
}

//----------------------------------------------------------------------------
//
//	FUNCTION:	CvGameTextMgr()
//
//	PURPOSE:	Constructor
//
//----------------------------------------------------------------------------
CvGameTextMgr::CvGameTextMgr() : inspectUnitCombatCounters(NULL) { }

CvGameTextMgr::~CvGameTextMgr() { }

//----------------------------------------------------------------------------
//
//	FUNCTION:	Initialize()
//
//	PURPOSE:	Allocates memory
//
//----------------------------------------------------------------------------
void CvGameTextMgr::Initialize()
{
	inspectUnitCombatCounters = new CounterSet();
}

//----------------------------------------------------------------------------
//
//	FUNCTION:	DeInitialize()
//
//	PURPOSE:	Clears memory
//
//----------------------------------------------------------------------------
void CvGameTextMgr::DeInitialize()
{
	SAFE_DELETE(inspectUnitCombatCounters);
}

//----------------------------------------------------------------------------
//
//	FUNCTION:	Reset()
//
//	PURPOSE:	Accesses CvXMLLoadUtility to clean global text memory and
//				reload the XML files
//
//----------------------------------------------------------------------------
void CvGameTextMgr::Reset()
{
	CvXMLLoadUtility pXML;
	pXML.LoadGlobalText();
}


// Returns the current language
int CvGameTextMgr::getCurrentLanguage() const
{
	return gDLL->getCurrentLanguage();
}

void CvGameTextMgr::setYearStr(CvWString& szString, int iGameTurn, bool bSave, CalendarTypes eCalendar, int iStartYear, GameSpeedTypes eSpeed)
{
	int iTurnYear = getTurnYearForGame(iGameTurn, iStartYear, eCalendar, eSpeed);

	if (iTurnYear < 0)
	{
		if (bSave)
		{
			szString = gDLL->getText("TXT_KEY_TIME_BC_SAVE", CvWString::format(L"%04d", -iTurnYear).GetCString());
		}
		else
		{
			szString = gDLL->getText("TXT_KEY_TIME_BC", -(iTurnYear));
		}
	}
	else if (iTurnYear > 0)
	{
		if (bSave)
		{
			szString = gDLL->getText("TXT_KEY_TIME_AD_SAVE", CvWString::format(L"%04d", iTurnYear).GetCString());
		}
		else
		{
			szString = gDLL->getText("TXT_KEY_TIME_AD", iTurnYear);
		}
	}
	else
	{
		if (bSave)
		{
			szString = gDLL->getText("TXT_KEY_TIME_AD_SAVE", L"0000");
		}
		else
		{
			szString = gDLL->getText("TXT_KEY_TIME_AD", 0);
		}
	}
}


void CvGameTextMgr::setDateStr(CvWString& szString, int iGameTurn, bool bSave, CalendarTypes eCalendar, int iStartYear, GameSpeedTypes eSpeed)
{
	CvWString szYearBuffer;
	CvWString szWeekBuffer;
	CvDate date;
	CvDateIncrement inc;

	setYearStr(szYearBuffer, iGameTurn, bSave, eCalendar, iStartYear, eSpeed);

	const int numMonths = std::max(1, GC.getNumMonthInfos());
	const int numSeasons = std::max(1, GC.getNumSeasonInfos());
	const int weeksPerMonth = std::max(1, GC.getDefineINT("WEEKS_PER_MONTHS"));

	switch (eCalendar)
	{
	case CALENDAR_DEFAULT:
		if (GC.getGame().getGameTurn() == iGameTurn)
		{
			date = GC.getGame().getCurrentDate();
		}
		else
		{
			date = CvDate::getDate(iGameTurn, eSpeed);
		}
		inc = date.getIncrement(eSpeed);
		if (((0 == inc.m_iIncrementMonth % numMonths) && (inc.m_iIncrementMonth > 0)) || inc.m_iIncrementMonth >= 2 * numMonths)
		{
			// Years
			szString = szYearBuffer;
		}
		else if (inc.m_iIncrementMonth >= 3)
		{
			// Seasons
			if (bSave)
			{
				szString = (szYearBuffer + "-" + GC.getSeasonInfo(date.getSeason()).getDescription());
			}
			else
			{
				szString = (GC.getSeasonInfo(date.getSeason())).getDescription() + CvString(", ") + szYearBuffer;
			}
		}
		else if ((inc.m_iIncrementDay == 0) || (inc.m_iIncrementMonth >= 2))
		{
			// Months
			if (bSave)
			{
				szString = (szYearBuffer + "-" + GC.getMonthInfo((MonthTypes)date.getMonth()).getDescription());
			}
			else
			{
				szString = (GC.getMonthInfo((MonthTypes)date.getMonth()).getDescription() + CvString(", ") + szYearBuffer);
			}
		}
		else
		{
			// Exact date
			szString = gDLL->getText("TXT_KEY_TIME_DATE", szYearBuffer.GetCString(), GC.getMonthInfo((MonthTypes)date.getMonth()).getDescription(), date.getDay());
		}
		break;
	case CALENDAR_NO_SEASONS:
		if (GC.getGame().getGameTurn() == iGameTurn)
		{
			date = GC.getGame().getCurrentDate();
		}
		else
		{
			date = CvDate::getDate(iGameTurn, eSpeed);
		}
		inc = date.getIncrement(eSpeed);
		if (((0 == inc.m_iIncrementMonth % numMonths) && (inc.m_iIncrementMonth > 0)) || inc.m_iIncrementMonth >= 2 * numMonths)
		{
			// Years
			szString = szYearBuffer;
		}
		else if ((inc.m_iIncrementDay == 0) || (inc.m_iIncrementMonth >= 2))
		{
			// Months
			if (bSave)
			{
				szString = (szYearBuffer + "-" + GC.getMonthInfo((MonthTypes)date.getMonth()).getDescription());
			}
			else
			{
				szString = (GC.getMonthInfo((MonthTypes)date.getMonth()).getDescription() + CvString(", ") + szYearBuffer);
			}
		}
		else
		{
			// Exact date
			szString = gDLL->getText("TXT_KEY_TIME_DATE", szYearBuffer.GetCString(), GC.getMonthInfo((MonthTypes)date.getMonth()).getDescription(), date.getDay());
		}
		break;
	case CALENDAR_YEARS:
	case CALENDAR_BI_YEARLY:
		szString = szYearBuffer;
		break;

	case CALENDAR_TURNS:
		szString = gDLL->getText("TXT_KEY_TIME_TURN", (iGameTurn + 1));
		break;

	case CALENDAR_SEASONS:
		if (bSave)
		{
			szString = (szYearBuffer + "-" + GC.getSeasonInfo((SeasonTypes)(iGameTurn % numSeasons)).getDescription());
		}
		else
		{
			szString = (GC.getSeasonInfo((SeasonTypes)(iGameTurn % numSeasons)).getDescription() + CvString(", ") + szYearBuffer);
		}
		break;

	case CALENDAR_MONTHS:
		if (bSave)
		{
			szString = (szYearBuffer + "-" + GC.getMonthInfo((MonthTypes)(iGameTurn % numMonths)).getDescription());
		}
		else
		{
			szString = (GC.getMonthInfo((MonthTypes)(iGameTurn % numMonths)).getDescription() + CvString(", ") + szYearBuffer);
		}
		break;

	case CALENDAR_WEEKS:
		szWeekBuffer = gDLL->getText("TXT_KEY_TIME_WEEK", ((iGameTurn % weeksPerMonth) + 1));
		if (bSave)
		{
			szString = (szYearBuffer + "-" + GC.getMonthInfo((MonthTypes)((iGameTurn / weeksPerMonth) % numMonths)).getDescription() + "-" + szWeekBuffer);
		}
		else
		{
			szString = (szWeekBuffer + ", " + GC.getMonthInfo((MonthTypes)((iGameTurn / weeksPerMonth) % numMonths)).getDescription() + ", " + szYearBuffer);
		}
		break;

	default:
		FAssert(false);
	}
}


void CvGameTextMgr::setTimeStr(CvWString& szString, int iGameTurn, bool bSave)
{
	setDateStr(szString, iGameTurn, bSave, GC.getGame().getCalendar(), GC.getGame().getStartYear(), GC.getGame().getGameSpeedType());
}


void CvGameTextMgr::setInterfaceTime(CvWString& szString, PlayerTypes ePlayer)
{
	CvWString szTempBuffer;

	if (GET_PLAYER(ePlayer).isGoldenAge())
	{
		szString.Format(L"%c(%d) ", gDLL->getSymbolID(GOLDEN_AGE_CHAR), GET_PLAYER(ePlayer).getGoldenAgeTurns());
	}
	else
	{
		szString.clear();
	}
	setTimeStr(szTempBuffer, GC.getGame().getGameTurn(), false);
	szString += CvWString(szTempBuffer);
}


void CvGameTextMgr::setGoldStr(CvWString& szString, PlayerTypes ePlayer)
{
	if (GET_PLAYER(ePlayer).getGold() < 0)
	{
		szString.Format(L"%c: " SETCOLR L"%d" SETCOLR, GC.getCommerceInfo(COMMERCE_GOLD).getChar(), TEXT_COLOR("COLOR_NEGATIVE_TEXT"), GET_PLAYER(ePlayer).getGold());
	}
	else
	{
		szString.Format(L"%c: %d", GC.getCommerceInfo(COMMERCE_GOLD).getChar(), GET_PLAYER(ePlayer).getGold());
	}

	const int iGoldRate = GET_PLAYER(ePlayer).calculateGoldRate();
	if (iGoldRate < 0)
	{
		szString += gDLL->getText("TXT_KEY_MISC_NEG_GOLD_PER_TURN", iGoldRate);
	}
	else if (iGoldRate > 0)
	{
		szString += gDLL->getText("TXT_KEY_MISC_POS_GOLD_PER_TURN", iGoldRate);
	}

	if (GET_PLAYER(ePlayer).isStrike())
	{
		szString += gDLL->getText("TXT_KEY_MISC_STRIKE");
	}
}


void CvGameTextMgr::setResearchStr(CvWString& szString, PlayerTypes ePlayer)
{
	CvWString szTempBuffer;

	szString = gDLL->getText("TXT_KEY_MISC_RESEARCH_STRING", GC.getTechInfo(GET_PLAYER(ePlayer).getCurrentResearch()).getTextKeyWide());

	if (GET_TEAM(GET_PLAYER(ePlayer).getTeam()).getTechCount(GET_PLAYER(ePlayer).getCurrentResearch()) > 0)
	{
		szTempBuffer.Format(L" %d", (GET_TEAM(GET_PLAYER(ePlayer).getTeam()).getTechCount(GET_PLAYER(ePlayer).getCurrentResearch()) + 1));
		szString+=szTempBuffer;
	}

	szTempBuffer.Format(L" (%d)", GET_PLAYER(ePlayer).getResearchTurnsLeft(GET_PLAYER(ePlayer).getCurrentResearch(), true));
	szString+=szTempBuffer;
}


void CvGameTextMgr::setOOSSeeds(CvWString& szString, PlayerTypes ePlayer)
{
	if (GET_PLAYER(ePlayer).isHuman())
	{
		int iNetID = GET_PLAYER(ePlayer).getNetID();
		if (gDLL->isConnected(iNetID))
		{
			szString = gDLL->getText("TXT_KEY_PLAYER_OOS", gDLL->GetSyncOOS(iNetID), gDLL->GetOptionsOOS(iNetID));
		}
	}
}

void CvGameTextMgr::setNetStats(CvWString& szString, PlayerTypes ePlayer)
{
	if (ePlayer != GC.getGame().getActivePlayer())
	{
		if (GET_PLAYER(ePlayer).isHuman())
		{
			if (gDLL->getInterfaceIFace()->isNetStatsVisible())
			{
				int iNetID = GET_PLAYER(ePlayer).getNetID();
				if (gDLL->isConnected(iNetID))
				{
					szString = gDLL->getText("TXT_KEY_MISC_NUM_MS", gDLL->GetLastPing(iNetID));
				}
				else
				{
					szString = gDLL->getText("TXT_KEY_MISC_DISCONNECTED");
				}
			}
		}
		else
		{
			szString = gDLL->getText("TXT_KEY_MISC_AI");
		}
	}
}


void CvGameTextMgr::setMinimizePopupHelp(CvWString& szString, const CvPopupInfo & info)
{
	CvCity* pCity;
	UnitTypes eTrainUnit;
	BuildingTypes eConstructBuilding;
	ProjectTypes eCreateProject;
	ReligionTypes eReligion;
	CivicTypes eCivic;

	switch (info.getButtonPopupType())
	{
	case BUTTONPOPUP_CHOOSEPRODUCTION:
		pCity = GET_PLAYER(GC.getGame().getActivePlayer()).getCity(info.getData1());
		if (pCity != NULL)
		{
			eTrainUnit = NO_UNIT;
			eConstructBuilding = NO_BUILDING;
			eCreateProject = NO_PROJECT;

			switch (info.getData2())
			{
			case (ORDER_TRAIN):
				eTrainUnit = (UnitTypes)info.getData3();
				break;
			case (ORDER_CONSTRUCT):
				eConstructBuilding = (BuildingTypes)info.getData3();
				break;
			case (ORDER_CREATE):
				eCreateProject = (ProjectTypes)info.getData3();
				break;
			default:
				break;
			}

			if (eTrainUnit != NO_UNIT)
			{
				szString += gDLL->getText("TXT_KEY_MINIMIZED_CHOOSE_PRODUCTION_UNIT", GC.getUnitInfo(eTrainUnit).getTextKeyWide(), pCity->getNameKey());
			}
			else if (eConstructBuilding != NO_BUILDING)
			{
				szString += gDLL->getText("TXT_KEY_MINIMIZED_CHOOSE_PRODUCTION_BUILDING", GC.getBuildingInfo(eConstructBuilding).getTextKeyWide(), pCity->getNameKey());
			}
			else if (eCreateProject != NO_PROJECT)
			{
				szString += gDLL->getText("TXT_KEY_MINIMIZED_CHOOSE_PRODUCTION_PROJECT", GC.getProjectInfo(eCreateProject).getTextKeyWide(), pCity->getNameKey());
			}
			else
			{
				szString += gDLL->getText("TXT_KEY_MINIMIZED_CHOOSE_PRODUCTION", pCity->getNameKey());
			}
		}
		break;

	case BUTTONPOPUP_CHANGERELIGION:
		eReligion = ((ReligionTypes)(info.getData1()));
		if (eReligion != NO_RELIGION)
		{
			szString += gDLL->getText("TXT_KEY_MINIMIZED_CHANGE_RELIGION", GC.getReligionInfo(eReligion).getTextKeyWide());
		}
		break;

	case BUTTONPOPUP_CHOOSETECH:
		if (info.getData1() > 0)
		{
			szString += gDLL->getText("TXT_KEY_MINIMIZED_CHOOSE_TECH_FREE");
		}
		else
		{
			szString += gDLL->getText("TXT_KEY_MINIMIZED_CHOOSE_TECH");
		}
		break;

	case BUTTONPOPUP_CHANGECIVIC:
		eCivic = ((CivicTypes)(info.getData2()));
		if (eCivic != NO_CIVIC)
		{
			szString += gDLL->getText("TXT_KEY_MINIMIZED_CHANGE_CIVIC", GC.getCivicInfo(eCivic).getTextKeyWide());
		}
		break;
	}
}

void CvGameTextMgr::setEspionageMissionHelp(CvWStringBuffer &szBuffer, const CvUnit* pUnit)
{
	if (pUnit->isSpy())
	{
		const PlayerTypes eOwner =  pUnit->plot()->getOwner();
		if (NO_PLAYER != eOwner && GET_PLAYER(eOwner).getTeam() != pUnit->getTeam())
		{
			if (!pUnit->canEspionage(pUnit->plot()))
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_NO_ESPIONAGE"));

				if (pUnit->hasMoved() || pUnit->isMadeAttack())
				{
					szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_NO_ESPIONAGE_REASON_MOVED"));
				}
				else if (!pUnit->isInvisible(GET_PLAYER(eOwner).getTeam(), false))
				{
					szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_NO_ESPIONAGE_REASON_VISIBLE", GET_PLAYER(eOwner).getNameKey()));
				}
			}
			else if (pUnit->getFortifyTurns() > 0)
			{
				int iModifier = -(pUnit->getFortifyTurns() * GC.getDefineINT("ESPIONAGE_EACH_TURN_UNIT_COST_DECREASE"));
				if (0 != iModifier)
				{
					szBuffer.append(NEWLINE);
					szBuffer.append(gDLL->getText("TXT_KEY_ESPIONAGE_COST", iModifier));
				}
			}
		}
	}
}


void CvGameTextMgr::setUnitHelp(CvWStringBuffer &szString, const CvUnit* pUnit, bool bOneLine, bool bShort)
{
	PROFILE_FUNC();

	CvWString szTempBuffer;
	int iI;
	bool bFirst;
	const bool bShift = gDLL->shiftKey();
	const bool bCtrl = gDLL->ctrlKey();
	const bool bAlt = gDLL->altKey();

	//In this case, these views mean, in addition to debugging info displays from bShift and bAlt:
	// bShift = Combat Class Modifiers - will need to disable ones that don't have anything to display.
	// bCtrl = On unit base help: Prerequisite and Production Info, Here on Compiled Units: CombatInfo (Prereq and Production info should be standardly available, thus normal view)
	// bAlt = On unit base help: Long List Infos - Civil Info - should be changed from long list to civil info on the base too)
	// bNormalView = default to show but replaced by any of the above - includes unit limit counts
	bool bNormalView = (!bCtrl && !bAlt && !bShift);

	szTempBuffer.Format(SETCOLR L"%s" ENDCOLR, TEXT_COLOR("COLOR_UNIT_TEXT"), pUnit->getName().GetCString());
	szString.append(szTempBuffer);

	szString.append(L", ");

	if (pUnit->getDomainType() == DOMAIN_AIR)
	{
		if (pUnit->airBaseCombatStr() > 0)
		{
			if (GC.getGame().isOption(GAMEOPTION_SIZE_MATTERS))
			{
				float fBase = (float)pUnit->airBaseCombatStr();
				fBase /= 100;

				if (pUnit->isFighting())
				{
					szTempBuffer.Format(L"?/%.2f%c, ", fBase, gDLL->getSymbolID(STRENGTH_CHAR));
				}
				else if (pUnit->isHurt())
				{
					szTempBuffer.Format(L"%.2f/%.2f%c, ", (((float)(fBase * pUnit->currHitPoints())) / ((float)(pUnit->maxHitPoints()))), fBase, gDLL->getSymbolID(STRENGTH_CHAR));
				}
				else
				{
					szTempBuffer.Format(L"%.2f%c, ", fBase, gDLL->getSymbolID(STRENGTH_CHAR));
				}
				szString.append(szTempBuffer);
			}
			else
			{
				if (pUnit->isFighting())
				{
					szTempBuffer.Format(L"?/%d%c, ", pUnit->airBaseCombatStr(), gDLL->getSymbolID(STRENGTH_CHAR));
				}
				else if (pUnit->isHurt())
				{
					szTempBuffer.Format(L"%.2f/%d%c, ", (((float)(pUnit->airBaseCombatStr() * pUnit->currHitPoints())) / ((float)(pUnit->maxHitPoints()))), pUnit->airBaseCombatStr(), gDLL->getSymbolID(STRENGTH_CHAR));
				}
				else
				{
					szTempBuffer.Format(L"%d%c, ", pUnit->airBaseCombatStr(), gDLL->getSymbolID(STRENGTH_CHAR));
				}
				szString.append(szTempBuffer);
			}
		}
	}
	else if (pUnit->canFight())
	{
		if (GC.getGame().isOption(GAMEOPTION_SIZE_MATTERS))
		{
			float fBase = (float)pUnit->baseCombatStr();
			fBase /= 100;

			if (pUnit->isFighting())
			{
				szTempBuffer.Format(L"?/%.2f%c, ", fBase, gDLL->getSymbolID(STRENGTH_CHAR));
			}
			else if (pUnit->isHurt())
			{
				szTempBuffer.Format(L"%.2f/%.2f%c, ", (((float)(fBase * pUnit->currHitPoints())) / ((float)(pUnit->maxHitPoints()))), fBase, gDLL->getSymbolID(STRENGTH_CHAR));
			}
			else
			{
				szTempBuffer.Format(L"%.2f%c, ", fBase, gDLL->getSymbolID(STRENGTH_CHAR));
			}
			szString.append(szTempBuffer);
		}
		else
		{
			if (pUnit->isFighting())
			{
				szTempBuffer.Format(L"?/%d%c, ", pUnit->baseCombatStr(), gDLL->getSymbolID(STRENGTH_CHAR));
			}
			else if (pUnit->isHurt())
			{
				szTempBuffer.Format(L"%.2f/%d%c, ", (((float)(pUnit->baseCombatStr() * pUnit->currHitPoints())) / ((float)(pUnit->maxHitPoints()))), pUnit->baseCombatStr(), gDLL->getSymbolID(STRENGTH_CHAR));
			}
			else
			{
				szTempBuffer.Format(L"%d%c, ", pUnit->baseCombatStr(), gDLL->getSymbolID(STRENGTH_CHAR));
			}
			szString.append(szTempBuffer);
		}
	}

	const int iCurrMoves = pUnit->movesLeft() / GC.getMOVE_DENOMINATOR() + (pUnit->movesLeft() % GC.getMOVE_DENOMINATOR() > 0 ? 1 : 0);
	if (pUnit->baseMoves() == iCurrMoves || pUnit->getTeam() != GC.getGame().getActiveTeam())
	{
		szTempBuffer.Format(L"%d%c", pUnit->baseMoves(), gDLL->getSymbolID(MOVES_CHAR));
	}
	else
	{
		szTempBuffer.Format(L"%d/%d%c", iCurrMoves, pUnit->baseMoves(), gDLL->getSymbolID(MOVES_CHAR));
	}
	szString.append(szTempBuffer);

	if (pUnit->airRange() > 0)
	{
		szString.append(gDLL->getText("TXT_KEY_UNITHELP_AIR_RANGE", pUnit->airRange()));
	}

	if (pUnit->getBuildType() != NO_BUILD)
	{
		szString.append(L", ");
		szTempBuffer.Format(L"%s (%d)", GC.getBuildInfo(pUnit->getBuildType()).getDescription(), pUnit->plot()->getBuildTurnsLeft(pUnit->getBuildType(), 0, 0));
		szString.append(szTempBuffer);
	}

	if (pUnit->getImmobileTimer() > 0)
	{
		szString.append(L", ");
		szString.append(gDLL->getText("TXT_KEY_UNITHELP_IMMOBILE", pUnit->getImmobileTimer()));
	}

	if (GC.getGame().isDebugMode() && bShift)
	{
		FAssertMsg(pUnit->AI_getUnitAIType() != NO_UNITAI, "pUnit's AI type expected to != NO_UNITAI");
		CvWString unitAIType = GC.getUnitAIInfo(pUnit->AI_getUnitAIType()).getType();
		szTempBuffer.Format(L" (%s)", unitAIType.GetCString());
		szString.append(szTempBuffer);
	}

	if ((pUnit->getTeam() == GC.getGame().getActiveTeam() || GC.getGame().isDebugMode()) && pUnit->getExperience100() > 0 && !pUnit->isFighting())
	{
		float fValue = (float)pUnit->getExperience100();
		if (fmod(fValue, 100) == 0)
		{
			szTempBuffer.Format(L"%.0f", fValue/100);
		}
		else if (fmod(fValue, 10) == 0)
		{
			szTempBuffer.Format(L"%.1f", fValue/100);
		}
		else
		{
			szTempBuffer.Format(L"%.2f", fValue/100);
		}
		szString.append(gDLL->getText("TXT_KEY_UNITHELP_XP", szTempBuffer.GetCString(), pUnit->experienceNeeded()));
	}

	if (pUnit->isCommander())
	{
		szString.append(gDLL->getText("TXT_KEY_UNITHELP_COMMAND_RANGE", pUnit->commandRange()));
		szString.append(gDLL->getText("TXT_KEY_UNITHELP_COMMAND_POINTS", pUnit->controlPointsLeft(), pUnit->controlPoints()));
	}

	if (pUnit->getOwner() != GC.getGame().getActivePlayer() && !pUnit->isAnimal() && !pUnit->isHiddenNationality())
	{
		szString.append(L", ");

		// For minor civs, display civ name instead of player name ... to differentiate
		// and help human recognize why they can't contact that player
		const CvPlayer& kPlayer = GET_PLAYER(pUnit->getOwner());
		if (kPlayer.isMinorCiv())
			szTempBuffer.Format(SETCOLR L"%s" ENDCOLR, kPlayer.getPlayerTextColorR(), kPlayer.getPlayerTextColorG(), kPlayer.getPlayerTextColorB(), kPlayer.getPlayerTextColorA(), kPlayer.getCivilizationDescription());
		else
			szTempBuffer.Format(SETCOLR L"%s" ENDCOLR, kPlayer.getPlayerTextColorR(), kPlayer.getPlayerTextColorG(), kPlayer.getPlayerTextColorB(), kPlayer.getPlayerTextColorA(), kPlayer.getName());

		szString.append(szTempBuffer);
	}


	//TB Temp
	//if (pUnit->maxHPTotal() != 0)
	//{
	//	szString.append(NEWLINE);
	//	szString.append(gDLL->getText("TXT_KEY_TEMP_HP", pUnit->maxHPTotal()));
	//}
	//if (pUnit->assetValueTotal() != 0)
	//{
	//	szString.append(NEWLINE);
	//	szString.append(gDLL->getText("TXT_KEY_TEMP_ASSET", pUnit->assetValueTotal()));
	//}
	//if (pUnit->powerValueTotal() != 0)
	//{
	//	szString.append(NEWLINE);
	//	szString.append(gDLL->getText("TXT_KEY_TEMP_POWER", pUnit->powerValueTotal()));
	//}
	//if (pUnit->SMcargoSpace() != 0)
	//{
	//	szString.append(NEWLINE);
	//	szString.append(gDLL->getText("TXT_KEY_TEMP_CARGO_SPACE", pUnit->SMcargoSpace()));
	//}
	//if (pUnit->SMCargoVolume() != 0)
	//{
	//	szString.append(NEWLINE);
	//	szString.append(gDLL->getText("TXT_KEY_TEMP_CARGO_VOLUME", pUnit->SMCargoVolume()));
	//}
	//if (pUnit->bombardRate() != 0)
	//{
	//	szString.append(NEWLINE);
	//	szString.append(gDLL->getText("TXT_KEY_TEMP_BOMBARD_RATE", pUnit->bombardRate()));
	//}
	//if (pUnit->airBombCurrRate() != 0)
	//{
	//	szString.append(NEWLINE);
	//	szString.append(gDLL->getText("TXT_KEY_TEMP_AIR_BOMBARD_RATE", pUnit->airBombCurrRate()));
	//}
	//TB SubCombat Mod begin

	for (iI = 0; iI < GC.getNumPromotionInfos(); ++iI)
	{
		if (pUnit->isHasPromotion((PromotionTypes)iI) && !pUnit->isPromotionOverriden((PromotionTypes)iI))
		{
			szTempBuffer.Format(L"<img=%S size=16 />", GC.getPromotionInfo((PromotionTypes)iI).getButton());
			szString.append(szTempBuffer);
		}
	}
	if (bAlt && gDLL->getChtLvl() > 0)
	{
		CvSelectionGroup* eGroup = pUnit->getGroup();
		if (eGroup != NULL)
		{
			if (pUnit->isGroupHead())
			{
				szString.append(CvWString::format(L"\nLeading "));
			}
			else szString.append(L"\n");

			szTempBuffer.Format(L"Group(%d), %d units", eGroup->getID(), eGroup->getNumUnits());
			szString.append(szTempBuffer);
		}
	}

	if (!bOneLine)
	{
		if (bShift)
		{
			bFirst = true;
			for (iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
			{
				if (pUnit->isHasUnitCombat((UnitCombatTypes)iI))
				{
					const UnitCombatTypes eUnitCombatType = ((UnitCombatTypes)iI);
					if (bFirst)
					{
						szTempBuffer.Format(L"(%s", GC.getUnitCombatInfo(eUnitCombatType).getDescription());
						szString.append(szTempBuffer);
						bFirst = false;
					}
					else
					{
						szString.append(NEWLINE);
						szTempBuffer.Format(L"%s", GC.getUnitCombatInfo(eUnitCombatType).getDescription());
						szString.append(szTempBuffer);
					}
				}
			}
			if (!bFirst)
			{
				szTempBuffer.Format(L")");
				szString.append(szTempBuffer);
			}
		}
		//Setup Combat Value Displays
		if (bCtrl)
		{

			if (pUnit->hasStealthDefense() && GC.getGame().isOption(GAMEOPTION_WITHOUT_WARNING))
			{
				szString.append(NEWLINE);
				szString.append(gDLL->getText("TXT_KEY_UNITHELP_STEALTH_DEFEND"));
			}

			if (pUnit->noDefensiveBonus())
			{
				szString.append(NEWLINE);
				szString.append(gDLL->getText("TXT_KEY_UNIT_NO_DEFENSE_BONUSES"));
			}

			if (pUnit->fortRepelTotal() > 0)
			{
				if (bShort)
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNIT_FORT_REPEL_TOTAL_SHORT", pUnit->fortRepelTotal()));
				}
				else
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNIT_FORT_REPEL_TOTAL_MODIFIER", pUnit->fortRepelTotal()));
				}
			}

			if (pUnit->overrunTotal() > 0)
			{
				if (bShort)
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNIT_OVERRUN_TOTAL_SHORT", pUnit->overrunTotal()));
				}
				else
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNIT_OVERRUN_TOTAL_MODIFIER", pUnit->overrunTotal()));
				}
			}

			//Basic Combat Modifiers
			if (pUnit->getExtraCombatPercent() != 0)
			{
				szString.append(NEWLINE);
				szString.append(gDLL->getText("TXT_KEY_PROMOTION_STRENGTH_TEXT", pUnit->getExtraCombatPercent()));
			}

			if (pUnit->stealthCombatModifierTotal() != 0 && GC.getGame().isOption(GAMEOPTION_WITHOUT_WARNING))
			{
				szString.append(NEWLINE);
				szString.append(gDLL->getText("TXT_KEY_PROMOTION_STEALTH_COMBAT_MODIFIER_TEXT", pUnit->stealthCombatModifierTotal()));
			}

			if (pUnit->attackCombatModifierTotal() != 0)
			{
				if (bShort)
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNIT_ATTACK_MODIFIER_SHORT", pUnit->attackCombatModifierTotal()));
				}
				else
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNIT_ATTACK_MODIFIER", pUnit->attackCombatModifierTotal()));
				}
			}

			if (pUnit->defenseCombatModifierTotal() != 0)
			{
				if (bShort)
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNIT_DEFENSE_MODIFIER_SHORT", pUnit->defenseCombatModifierTotal()));
				}
				else
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNIT_DEFENSE_MODIFIER", pUnit->defenseCombatModifierTotal()));
				}
			}

			if (pUnit->cityAttackModifier() == pUnit->cityDefenseModifier())
			{
				if (pUnit->cityAttackModifier() != 0)
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNIT_CITY_STRENGTH_MOD", pUnit->cityAttackModifier()));
				}
			}
			else
			{
				if (pUnit->cityAttackModifier() != 0)
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_PROMOTION_CITY_ATTACK_TEXT", pUnit->cityAttackModifier()));
				}

				if (pUnit->cityDefenseModifier() != 0)
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_PROMOTION_CITY_DEFENSE_TEXT", pUnit->cityDefenseModifier()));
				}
			}

			if (pUnit->animalCombatModifier() != 0)
			{
				szString.append(NEWLINE);
				szString.append(gDLL->getText("TXT_KEY_UNIT_ANIMAL_COMBAT_MOD", pUnit->animalCombatModifier()));
			}

			if (pUnit->combatModifierPerSizeMoreTotal() != 0)
			{
				szString.append(NEWLINE);
				szString.append(gDLL->getText("TXT_KEY_UNIT_COMBAT_MOD_PER_SIZE_MORE", pUnit->combatModifierPerSizeMoreTotal()));
			}

			if (pUnit->combatModifierPerSizeLessTotal() != 0)
			{
				szString.append(NEWLINE);
				szString.append(gDLL->getText("TXT_KEY_UNIT_COMBAT_MOD_PER_SIZE_LESS", pUnit->combatModifierPerSizeLessTotal()));
			}

			if (pUnit->combatModifierPerVolumeMoreTotal() != 0)
			{
				szString.append(NEWLINE);
				szString.append(gDLL->getText("TXT_KEY_UNIT_COMBAT_MOD_PER_VOLUME_MORE", pUnit->combatModifierPerVolumeMoreTotal()));
			}

			if (pUnit->combatModifierPerVolumeLessTotal() != 0)
			{
				szString.append(NEWLINE);
				szString.append(gDLL->getText("TXT_KEY_UNIT_COMBAT_MOD_PER_VOLUME_LESS", pUnit->combatModifierPerVolumeLessTotal()));
			}

			if (pUnit->vsBarbsModifier() > 0)
			{
				if (bShort)
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNIT_VSBARBS_MODIFIER_SHORT", pUnit->vsBarbsModifier()));
				}
				else
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNIT_VSBARBS_MODIFIER", pUnit->vsBarbsModifier()));
				}
			}

			if (pUnit->religiousCombatModifierTotal(NO_RELIGION, true) != 0)
			{
				if (bShort)
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNIT_RELIGIOUS_COMBAT_MODIFIER_SHORT", pUnit->religiousCombatModifierTotal(NO_RELIGION, true)));
				}
				else
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNIT_RELIGIOUS_COMBAT_MODIFIER", pUnit->religiousCombatModifierTotal(NO_RELIGION, true)));
				}
			}

			if (pUnit->hillsAttackModifier() == pUnit->hillsDefenseModifier())
			{
				if (pUnit->hillsAttackModifier() != 0)
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNIT_HILLS_STRENGTH", pUnit->hillsAttackModifier()));
				}
			}
			else
			{
				if (pUnit->hillsAttackModifier() != 0)
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNIT_HILLS_ATTACK", pUnit->hillsAttackModifier()));
				}

				if (pUnit->hillsDefenseModifier() != 0)
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNIT_HILLS_DEFENSE", pUnit->hillsDefenseModifier()));
				}
			}
			bFirst = true;
			for (iI = 0; iI < GC.getNumTerrainInfos(); ++iI)
			{
				if (pUnit->terrainAttackModifier((TerrainTypes)iI) == pUnit->terrainDefenseModifier((TerrainTypes)iI))
				{
					if (pUnit->terrainAttackModifier((TerrainTypes)iI) != 0)
					{
						if (!bFirst)
						{
							szString.append(gDLL->getText("TXT_KEY_COMMA"));
						}
						if (bFirst)
						{
							szString.append(NEWLINE);
							bFirst = false;
						}
						szString.append(gDLL->getText("TXT_KEY_UNIT_STRENGTH", pUnit->terrainAttackModifier((TerrainTypes)iI), GC.getTerrainInfo((TerrainTypes) iI).getTextKeyWide()));
					}
				}
				else
				{
					if (pUnit->terrainAttackModifier((TerrainTypes)iI) != 0)
					{
						if (!bFirst)
						{
							szString.append(gDLL->getText("TXT_KEY_COMMA"));
						}
						if (bFirst)
						{
							szString.append(NEWLINE);
							bFirst = false;
						}
						szString.append(gDLL->getText("TXT_KEY_UNIT_ATTACK", pUnit->terrainAttackModifier((TerrainTypes)iI), GC.getTerrainInfo((TerrainTypes) iI).getTextKeyWide()));
					}

					if (pUnit->terrainDefenseModifier((TerrainTypes)iI) != 0)
					{
						if (!bFirst)
						{
							szString.append(gDLL->getText("TXT_KEY_COMMA"));
						}
						if (bFirst)
						{
							szString.append(NEWLINE);
							bFirst = false;
						}
						szString.append(gDLL->getText("TXT_KEY_UNIT_DEFENSE", pUnit->terrainDefenseModifier((TerrainTypes)iI), GC.getTerrainInfo((TerrainTypes) iI).getTextKeyWide()));
					}
				}
			}

			bFirst = true;
			for (iI = 0; iI < GC.getNumFeatureInfos(); ++iI)
			{
				if (pUnit->featureAttackModifier((FeatureTypes)iI) == pUnit->featureDefenseModifier((FeatureTypes)iI))
				{
					if (pUnit->featureAttackModifier((FeatureTypes)iI) != 0)
					{
						if (!bFirst)
						{
							szString.append(gDLL->getText("TXT_KEY_COMMA"));
						}
						if (bFirst)
						{
							szString.append(NEWLINE);
							bFirst = false;
						}
						szString.append(gDLL->getText("TXT_KEY_UNIT_STRENGTH", pUnit->featureAttackModifier((FeatureTypes)iI), GC.getFeatureInfo((FeatureTypes) iI).getTextKeyWide()));
					}
				}
				else
				{
					if (pUnit->featureAttackModifier((FeatureTypes)iI) != 0)
					{
						if (!bFirst)
						{
							szString.append(gDLL->getText("TXT_KEY_COMMA"));
						}
						if (bFirst)
						{
							szString.append(NEWLINE);
							bFirst = false;
						}
						szString.append(gDLL->getText("TXT_KEY_UNIT_ATTACK", pUnit->featureAttackModifier((FeatureTypes)iI), GC.getFeatureInfo((FeatureTypes) iI).getTextKeyWide()));
					}

					if (pUnit->featureDefenseModifier((FeatureTypes)iI) != 0)
					{
						if (!bFirst)
						{
							szString.append(gDLL->getText("TXT_KEY_COMMA"));
						}
						if (bFirst)
						{
							szString.append(NEWLINE);
							bFirst = false;
						}
						szString.append(gDLL->getText("TXT_KEY_UNIT_DEFENSE", pUnit->featureDefenseModifier((FeatureTypes)iI), GC.getFeatureInfo((FeatureTypes) iI).getTextKeyWide()));
					}
				}
			}

			for (iI = 0; iI < NUM_DOMAIN_TYPES; ++iI)
			{
				if (pUnit->domainModifier((DomainTypes)iI) != 0)
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNIT_MOD_VS_TYPE", pUnit->domainModifier((DomainTypes)iI), CvWString(GC.getDomainInfo((DomainTypes)iI).getType()).GetCString(), GC.getDomainInfo((DomainTypes)iI).getTextKeyWide()));
				}
			}

			bFirst = true;
			for (iI = 0; iI < GC.getNumUnitInfos(); ++iI)
			{
				if (pUnit->getUnitInfo().getUnitAttackModifier(iI) == GC.getUnitInfo(pUnit->getUnitType()).getUnitDefenseModifier(iI))
				{
					if (pUnit->getUnitInfo().getUnitAttackModifier(iI) != 0)
					{
						if (!bFirst)
						{
							szString.append(gDLL->getText("TXT_KEY_COMMA"));
						}
						if (bFirst)
						{
							szString.append(NEWLINE);
							bFirst = false;
						}
						szString.append(gDLL->getText("TXT_KEY_UNIT_MOD_VS_TYPE", pUnit->getUnitInfo().getUnitAttackModifier(iI),
							CvWString(GC.getUnitInfo((UnitTypes)iI).getType()).GetCString(), GC.getUnitInfo((UnitTypes)iI).getTextKeyWide()));
					}
				}
				else
				{
					if (pUnit->getUnitInfo().getUnitAttackModifier(iI) != 0)
					{
						if (!bFirst)
						{
							szString.append(gDLL->getText("TXT_KEY_COMMA"));
						}
						if (bFirst)
						{
							szString.append(NEWLINE);
							bFirst = false;
						}
						szString.append(gDLL->getText("TXT_KEY_UNIT_ATTACK_MOD_VS_CLASS", pUnit->getUnitInfo().getUnitAttackModifier(iI),
							CvWString(GC.getUnitInfo((UnitTypes)iI).getType()).GetCString(), GC.getUnitInfo((UnitTypes)iI).getTextKeyWide()));
					}

					if (pUnit->getUnitInfo().getUnitDefenseModifier(iI) != 0)
					{
						if (!bFirst)
						{
							szString.append(gDLL->getText("TXT_KEY_COMMA"));
						}
						if (bFirst)
						{
							szString.append(NEWLINE);
							bFirst = false;
						}
						szString.append(gDLL->getText("TXT_KEY_UNIT_DEFENSE_MOD_VS_CLASS", pUnit->getUnitInfo().getUnitDefenseModifier(iI),
							CvWString(GC.getUnitInfo((UnitTypes) iI).getType()).GetCString(), GC.getUnitInfo((UnitTypes) iI).getTextKeyWide()));
					}
				}
			}

			bFirst = true;
			for (iI = 0; iI < GC.getNumUnitCombatInfos(); ++iI)
			{
				if (pUnit->unitCombatModifier((UnitCombatTypes)iI) != 0)
				{
					if (!bFirst)
					{
						szString.append(gDLL->getText("TXT_KEY_COMMA"));
					}
					if (bFirst)
					{
						szString.append(NEWLINE);
						bFirst = false;
					}
					szString.append(gDLL->getText("TXT_KEY_UNIT_MOD_VS_TYPE", pUnit->unitCombatModifier((UnitCombatTypes)iI), CvWString(GC.getUnitCombatInfo((UnitCombatTypes) iI).getType()).GetCString(), GC.getUnitCombatInfo((UnitCombatTypes) iI).getTextKeyWide()));
				}
			}

			//Advanced Combat Modifiers
			//Armor
			if (pUnit->armorTotal() > 0)
			{
				if (bShort)
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNIT_ARMOR_TOTAL_SHORT", pUnit->armorTotal()));
				}
				else
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNIT_ARMOR_TOTAL_MODIFIER", pUnit->armorTotal()));
				}
			}

			bFirst = true;
			for (iI = 0; iI < GC.getNumUnitCombatInfos(); ++iI)
			{
				if (pUnit->armorVSUnitCombatTotal((UnitCombatTypes)iI) != 0)
				{
					if (!bFirst)
					{
						szString.append(gDLL->getText("TXT_KEY_COMMA"));
					}
					if (bFirst)
					{
						szString.append(NEWLINE);
						bFirst = false;
					}
					szString.append(gDLL->getText("TXT_KEY_PROMOTION_ARMOR_VERSUS_TEXT", pUnit->armorVSUnitCombatTotal((UnitCombatTypes)iI), CvWString(GC.getUnitCombatInfo((UnitCombatTypes) iI).getType()).GetCString(), GC.getUnitCombatInfo((UnitCombatTypes) iI).getTextKeyWide()));
				}
			}

			//puncture
			if (pUnit->punctureTotal() > 0)
			{
				if (bShort)
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNIT_PUNCTURE_TOTAL_SHORT", pUnit->punctureTotal()));
				}
				else
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNIT_PUNCTURE_TOTAL_MODIFIER", pUnit->punctureTotal()));
				}
			}

			bFirst = true;
			for (iI = 0; iI < GC.getNumUnitCombatInfos(); ++iI)
			{
				if (pUnit->punctureVSUnitCombatTotal((UnitCombatTypes)iI) != 0)
				{
					if (!bFirst)
					{
						szString.append(gDLL->getText("TXT_KEY_COMMA"));
					}
					if (bFirst)
					{
						szString.append(NEWLINE);
						bFirst = false;
					}
					szString.append(gDLL->getText("TXT_KEY_PROMOTION_PUNCTURE_VERSUS_TEXT", pUnit->punctureVSUnitCombatTotal((UnitCombatTypes)iI), CvWString(GC.getUnitCombatInfo((UnitCombatTypes) iI).getType()).GetCString(), GC.getUnitCombatInfo((UnitCombatTypes) iI).getTextKeyWide()));
				}
			}

			//damage
			if (pUnit->damageModifierTotal() != 0)
			{
				if (bShort)
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNIT_DAMAGE_MODIFIER_TOTAL_SHORT", pUnit->damageModifierTotal()));
				}
				else
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNIT_DAMAGE_MODIFIER_TOTAL_MODIFIER", pUnit->damageModifierTotal()));
				}
			}

			//dodge
			int idodge = (pUnit->dodgeTotal() - 100);
			if (idodge != 0)
			{
				if (bShort)
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNIT_DODGE_TOTAL_SHORT", idodge));
				}
				else
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNIT_DODGE_TOTAL_MODIFIER", idodge));
				}
			}

			bFirst = true;
			for (iI = 0; iI < GC.getNumUnitCombatInfos(); ++iI)
			{
				if (pUnit->dodgeVSUnitCombatTotal((UnitCombatTypes)iI) != 0)
				{
					if (!bFirst)
					{
						szString.append(gDLL->getText("TXT_KEY_COMMA"));
					}
					if (bFirst)
					{
						szString.append(NEWLINE);
						bFirst = false;
					}
					szString.append(gDLL->getText("TXT_KEY_PROMOTION_DODGE_VERSUS_TEXT", pUnit->dodgeVSUnitCombatTotal((UnitCombatTypes)iI), CvWString(GC.getUnitCombatInfo((UnitCombatTypes) iI).getType()).GetCString(), GC.getUnitCombatInfo((UnitCombatTypes) iI).getTextKeyWide()));
				}
			}

			//precision
			int iprecision = (pUnit->precisionTotal() - 100);
			if (iprecision != 0)
			{
				if (bShort)
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNIT_PRECISION_TOTAL_SHORT", iprecision));
				}
				else
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNIT_PRECISION_TOTAL_MODIFIER", iprecision));
				}
			}

			bFirst = true;
			for (iI = 0; iI < GC.getNumUnitCombatInfos(); ++iI)
			{
				if (pUnit->precisionVSUnitCombatTotal((UnitCombatTypes)iI) != 0)
				{
					if (!bFirst)
					{
						szString.append(gDLL->getText("TXT_KEY_COMMA"));
					}
					if (bFirst)
					{
						szString.append(NEWLINE);
						bFirst = false;
					}
					szString.append(gDLL->getText("TXT_KEY_PROMOTION_PRECISION_VERSUS_TEXT", pUnit->precisionVSUnitCombatTotal((UnitCombatTypes)iI), CvWString(GC.getUnitCombatInfo((UnitCombatTypes) iI).getType()).GetCString(), GC.getUnitCombatInfo((UnitCombatTypes) iI).getTextKeyWide()));
				}
			}

			//Withdrawal
			if (pUnit->combatLimit() < GC.getMAX_HIT_POINTS() && pUnit->canAttack())
			{
				szString.append(NEWLINE);
				szString.append(gDLL->getText("TXT_KEY_UNIT_COMBAT_LIMIT", (100 * pUnit->combatLimit()) / GC.getMAX_HIT_POINTS()));
			}

			if (pUnit->withdrawalProbability() > 0)
			{
				if(pUnit->isSpy())
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNIT_ESCAPE_SPY", pUnit->withdrawalProbability()));
				}
				else
				{
					if (bShort)
					{
						szString.append(NEWLINE);
						szString.append(gDLL->getText("TXT_KEY_UNIT_WITHDRAWL_PROBABILITY_SHORT", pUnit->withdrawalProbability()));
					}
					else
					{
						szString.append(NEWLINE);
						szString.append(gDLL->getText("TXT_KEY_UNIT_WITHDRAWL_PROBABILITY", pUnit->withdrawalProbability()));
					}
				}
			}

			if (pUnit->earlyWithdrawTotal() > 0)
			{
				if (bShort)
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNIT_EARLY_WITHDRAW_TOTAL_SHORT", pUnit->earlyWithdrawTotal()));
				}
				else
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNIT_EARLY_WITHDRAW_TOTAL", pUnit->earlyWithdrawTotal()));
				}
			}

			if (pUnit->withdrawAdjperAttTotal() > 0)
			{
				if (bShort)
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNIT_REFLEXES_TOTAL_SHORT", pUnit->withdrawAdjperAttTotal()));
				}
				else
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNIT_REFLEXES_TOTAL", pUnit->withdrawAdjperAttTotal()));
				}
			}

			if (pUnit->withdrawAdjperAttTotal() < 0)
			{
				if (bShort)
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNIT_FRAYS_TOTAL_SHORT", pUnit->withdrawAdjperAttTotal()));
				}
				else
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNIT_FRAYS_TOTAL", pUnit->withdrawAdjperAttTotal()));
				}
			}

			bFirst = true;
			for (iI = 0; iI < GC.getNumUnitCombatInfos(); ++iI)
			{
				if (pUnit->withdrawVSUnitCombatTotal((UnitCombatTypes)iI) != 0)
				{
					if (!bFirst)
					{
						szString.append(gDLL->getText("TXT_KEY_COMMA"));
					}
					if (bFirst)
					{
						szString.append(NEWLINE);
						bFirst = false;
					}
					szString.append(gDLL->getText("TXT_KEY_PROMOTION_WITHDRAW_VERSUS_TEXT", pUnit->withdrawVSUnitCombatTotal((UnitCombatTypes)iI), CvWString(GC.getUnitCombatInfo((UnitCombatTypes) iI).getType()).GetCString(), GC.getUnitCombatInfo((UnitCombatTypes) iI).getTextKeyWide()));
				}
			}

			bFirst = true;
			for (iI = 0; iI < GC.getNumTerrainInfos(); ++iI)
			{
				if (pUnit->withdrawOnTerrainTotal((TerrainTypes)iI) != 0)
				{
					if (!bFirst)
					{
						szString.append(gDLL->getText("TXT_KEY_COMMA"));
					}
					if (bFirst)
					{
						szString.append(NEWLINE);
						bFirst = false;
					}
					szString.append(gDLL->getText("TXT_KEY_PROMOTION_WITHDRAW_ON_TEXT", pUnit->withdrawOnTerrainTotal((TerrainTypes)iI), CvWString(GC.getTerrainInfo((TerrainTypes) iI).getType()).GetCString(), GC.getTerrainInfo((TerrainTypes) iI).getTextKeyWide()));
				}
			}

			bFirst = true;
			for (iI = 0; iI < GC.getNumFeatureInfos(); ++iI)
			{
				if (pUnit->withdrawOnFeatureTotal((FeatureTypes)iI) != 0)
				{
					if (!bFirst)
					{
						szString.append(gDLL->getText("TXT_KEY_COMMA"));
					}
					if (bFirst)
					{
						szString.append(NEWLINE);
						bFirst = false;
					}
					szString.append(gDLL->getText("TXT_KEY_PROMOTION_WITHDRAW_ON_TEXT", pUnit->withdrawOnFeatureTotal((FeatureTypes)iI), CvWString(GC.getFeatureInfo((FeatureTypes) iI).getType()).GetCString(), GC.getFeatureInfo((FeatureTypes) iI).getTextKeyWide()));
				}
			}
/*
			//Escape
			if (pUnit->escapeModifier() != 0)
			{
				szString.append(NEWLINE);
				szString.append(gDLL->getText("TXT_KEY_UNITHELP_ESCAPE_PLAN_MOD", pUnit->escapeModifier()));
			}
*/
			//Pursuit
			if (pUnit->pursuitProbability() > 0)
			{
				if (bShort)
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNIT_PURSUIT_PROBABILITY_SHORT", pUnit->pursuitProbability()));
				}
				else
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNIT_PURSUIT_PROBABILITY", pUnit->pursuitProbability()));
				}
			}

			bFirst = true;
			for (iI = 0; iI < GC.getNumUnitCombatInfos(); ++iI)
			{
				if (pUnit->pursuitVSUnitCombatTotal((UnitCombatTypes)iI) != 0)
				{
					if (!bFirst)
					{
						szString.append(gDLL->getText("TXT_KEY_COMMA"));
					}
					if (bFirst)
					{
						szString.append(NEWLINE);
						bFirst = false;
					}
					szString.append(gDLL->getText("TXT_KEY_PROMOTION_PURSUIT_VERSUS_TEXT", pUnit->pursuitVSUnitCombatTotal((UnitCombatTypes)iI), CvWString(GC.getUnitCombatInfo((UnitCombatTypes) iI).getType()).GetCString(), GC.getUnitCombatInfo((UnitCombatTypes) iI).getTextKeyWide()));
				}
			}

			//Repel
			if (pUnit->repelTotal() > 0)
			{
				if (bShort)
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNIT_REPEL_TOTAL_SHORT", pUnit->repelTotal()));
				}
				else
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNIT_REPEL_TOTAL_MODIFIER", pUnit->repelTotal()));
				}
			}

			bFirst = true;
			for (iI = 0; iI < GC.getNumUnitCombatInfos(); ++iI)
			{
				if (pUnit->repelVSUnitCombatTotal((UnitCombatTypes)iI) != 0)
				{
					if (!bFirst)
					{
						szString.append(gDLL->getText("TXT_KEY_COMMA"));
					}
					if (bFirst)
					{
						szString.append(NEWLINE);
						bFirst = false;
					}
					szString.append(gDLL->getText("TXT_KEY_UNIT_MOD_VS_TYPE", pUnit->repelVSUnitCombatTotal((UnitCombatTypes)iI), CvWString(GC.getUnitCombatInfo((UnitCombatTypes) iI).getType()).GetCString(), GC.getUnitCombatInfo((UnitCombatTypes) iI).getTextKeyWide()));
				}
			}

			if (pUnit->repelRetriesTotal() > 0)
			{
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNIT_REPEL_RETRIES_TOTAL", pUnit->repelRetriesTotal()));
				}
			}

			//Knockback
			if (pUnit->knockbackTotal() > 0)
			{
				if (bShort)
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNIT_KNOCKBACK_TOTAL_SHORT", pUnit->knockbackTotal()));
				}
				else
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNIT_KNOCKBACK_TOTAL_MODIFIER", pUnit->knockbackTotal()));
				}
			}

			bFirst = true;
			for (iI = 0; iI < GC.getNumUnitCombatInfos(); ++iI)
			{
				if (pUnit->knockbackVSUnitCombatTotal((UnitCombatTypes)iI) != 0)
				{
					if (!bFirst)
					{
						szString.append(gDLL->getText("TXT_KEY_COMMA"));
					}
					if (bFirst)
					{
						szString.append(NEWLINE);
						bFirst = false;
					}
					szString.append(gDLL->getText("TXT_KEY_PROMOTION_KNOCKBACK_VERSUS_TEXT", pUnit->knockbackVSUnitCombatTotal((UnitCombatTypes)iI), CvWString(GC.getUnitCombatInfo((UnitCombatTypes) iI).getType()).GetCString(), GC.getUnitCombatInfo((UnitCombatTypes) iI).getTextKeyWide()));
				}
			}

			if (pUnit->knockbackRetriesTotal() > 0)
			{
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNIT_KNOCKBACK_RETRIES_TOTAL", pUnit->knockbackRetriesTotal()));
				}
			}

			//Unyielding
			if (pUnit->unyieldingTotal() > 0)
			{
				if (bShort)
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNIT_UNYIELDING_TOTAL_SHORT", pUnit->unyieldingTotal()));
				}
				else
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNIT_UNYIELDING_TOTAL_MODIFIER", pUnit->unyieldingTotal()));
				}
			}

			//Movement pertaining to Combat
			//Blitz
			if (pUnit->isBlitz())
			{
				szString.append(NEWLINE);
				szString.append(gDLL->getText("TXT_KEY_PROMOTION_BLITZ_TEXT"));
			}

			//Stampede
			if (pUnit->canStampede())
			{
				if (bShort)
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNIT_STAMPEDE_SHORT"));
				}
				else
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNIT_STAMPEDE_LONG"));
				}
			}

			//Onslaught
			if (pUnit->canOnslaught())
			{
				if (bShort)
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNIT_ONSLAUGHT_SHORT"));
				}
				else
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNIT_ONSLAUGHT_LONG"));
				}
			}

			//Amphibious
			if (pUnit->isAmphib())
			{
				if(pUnit->isSpy())
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_PROMOTION_RADIATION_TEXT_SPY"));
				}
				else
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_PROMOTION_AMPHIB_TEXT"));
				}
			}

			//River
			if (pUnit->isRiver())
			{
				szString.append(NEWLINE);
				szString.append(gDLL->getText("TXT_KEY_PROMOTION_RIVER_ATTACK_TEXT"));
			}

			//First Strikes
			if (pUnit->maxFirstStrikes() > 0)
			{
				if (pUnit->firstStrikes() == pUnit->maxFirstStrikes())
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNITHELP_FIRST_STRIKES", pUnit->firstStrikes()));
				}
				else
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNITHELP_FIRST_STRIKE_CHANCES", pUnit->firstStrikes(), pUnit->maxFirstStrikes()));
				}
			}

			if (pUnit->stealthStrikesTotal() > 0 && GC.getGame().isOption(GAMEOPTION_WITHOUT_WARNING))
			{
				szString.append(NEWLINE);
				szString.append(gDLL->getText("TXT_KEY_UNITHELP_STEALTH_STRIKES", pUnit->stealthStrikesTotal()));
			}

			//Immunity to First Strikes
			if (pUnit->immuneToFirstStrikes())
			{
				szString.append(NEWLINE);
				szString.append(gDLL->getText("TXT_KEY_UNITHELP_FIRST_STRIKES_IMMUNE"));
			}

			//Siege
			if (pUnit->breakdownChanceTotal() > 0)
			{
				szString.append(NEWLINE);
				szString.append(gDLL->getText("TXT_KEY_UNITHELP_BREAKDOWN_CHANCE", pUnit->breakdownChanceTotal()));
			}
			if (pUnit->breakdownDamageTotal() > 0)
			{
				szString.append(NEWLINE);
				szString.append(gDLL->getText("TXT_KEY_UNITHELP_BREAKDOWN_DAMAGE", pUnit->breakdownDamageTotal()));
			}
			if (pUnit->canAttackOnlyCities())
			{
				szString.append(NEWLINE);
				szString.append(gDLL->getText("TXT_KEY_UNITHELP_CAN_ONLY_ATTACK_CITIES"));
			}
			if (pUnit->canIgnoreNoEntryLevel())
			{
				szString.append(NEWLINE);
				szString.append(gDLL->getText("TXT_KEY_UNITHELP_CAN_ALWAYS_ATTACK_CITIES"));
			}

			//Bombard
			if(GC.isDCM_RANGE_BOMBARD())
			{
				if (pUnit->getDCMBombRange() > 0 || pUnit->getDCMBombAccuracy() > 0)
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_IS_DCM_BOMBARD"));
				}
				if (pUnit->getDCMBombRange() > 0)
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_IS_RANGE_BOMBARD", pUnit->getDCMBombRange()));
				}
				if (pUnit->getDCMBombAccuracy() > 0)
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_IS_ACCURACY_BOMBARD", pUnit->getDCMBombAccuracy()));
				}
				if (pUnit->rBombardDamage() > 0)
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_RANGED_BOMBARD_DAMAGE", pUnit->rBombardDamage()));
				}
				if (pUnit->rBombardDamageLimit() > 0)
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_RANGED_BOMBARD_DAMAGE_LIMIT", pUnit->rBombardDamageLimit()));
				}
				if (pUnit->rBombardDamageMaxUnits() > 0)
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_RANGED_BOMBARD_DAMAGE_MAX_UNITS", pUnit->rBombardDamageMaxUnits()));
				}
			}

			if (pUnit->getBombardRate() > 0)
			{
				if (bShort)
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNIT_BOMBARD_RATE_SHORT", ((pUnit->getBombardRate() * 100) / GC.getMAX_CITY_DEFENSE_DAMAGE())));
				}
				else
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNIT_BOMBARD_RATE", ((pUnit->getBombardRate() * 100) / GC.getMAX_CITY_DEFENSE_DAMAGE())));
				}
			}

			//Collateral
			if (pUnit->collateralDamage() > 0)
			{
				szString.append(NEWLINE);
				if (pUnit->getExtraCollateralDamage() == 0)
				{
					szString.append(gDLL->getText("TXT_KEY_UNIT_COLLATERAL_DAMAGE_REVDCM", 100 * pUnit->getUnitInfo().getCollateralDamageLimit() / GC.getMAX_HIT_POINTS(), pUnit->getUnitInfo().getCollateralDamageMaxUnits()));
				}
				else
				{
					szString.append(gDLL->getText("TXT_KEY_UNIT_COLLATERAL_DAMAGE_EXTRA", pUnit->getExtraCollateralDamage()));
				}
			}

			//Flanking
			bFirst = true;
			int iFlank = 0;
			for (iI = 0; iI < GC.getNumUnitInfos(); ++iI)
			{
				iFlank = pUnit->getUnitInfo().getFlankingStrikeUnit(iI);
				if (iFlank > 0)
				{
					if (bFirst)
					{
						szString.append(NEWLINE);
						bFirst = false;
					}
					else
					{
						szString.append(L", ");
					}

					szString.append(gDLL->getText("TXT_KEY_UNIT_COMBAT_FLANKING_STRIKES", iFlank, GC.getUnitInfo((UnitTypes)iI).getDescription()));
				}
			}

			iFlank = 0;
			for (iI = 0; iI < GC.getNumUnitCombatInfos(); ++iI)
			{
				iFlank = pUnit->flankingStrengthbyUnitCombatTotal((UnitCombatTypes)iI);
				if (iFlank > 0)
				{
					if (bFirst)
					{
						szString.append(NEWLINE);
						bFirst = false;
					}
					else
					{
						szString.append(L", ");
					}

					szString.append(gDLL->getText("TXT_KEY_UNIT_COMBAT_FLANKING_STRIKES", iFlank, GC.getUnitCombatInfo((UnitCombatTypes)iI).getDescription()));
				}
			}

			//Interception and Evasion
			if (pUnit->currInterceptionProbability() > 0)
			{
				if(pUnit->isSpy())
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNIT_INTERCEPT_AIRCRAFT_SPY", pUnit->currInterceptionProbability()));
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNIT_INTERCEPT_AIRCRAFT_SPY_COUNTER", pUnit->currInterceptionProbability() * 5));
				}
				else
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNIT_INTERCEPT_AIRCRAFT", pUnit->currInterceptionProbability()));
				}
			}

			if (pUnit->evasionProbability() > 0)
			{
				if(pUnit->isSpy())
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNIT_EVADE_INTERCEPTION_SPY", pUnit->evasionProbability()));
				}
				else
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNIT_EVADE_INTERCEPTION", pUnit->evasionProbability()));
				}
			}

			if (GC.isDCM_FIGHTER_ENGAGE())
			{
				if (GC.getUnitInfo(pUnit->getUnitType()).getDCMFighterEngage())
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_IS_FIGHTER_ENGAGE"));
				}
			}

			//Surround and Destroy
			if (GC.getGame().isOption(GAMEOPTION_SAD))
			{
				if (pUnit->unnerveTotal() > 0)
				{
					if (bShort)
					{
						szString.append(NEWLINE);
						szString.append(gDLL->getText("TXT_KEY_UNIT_UNNERVE_TOTAL_SHORT", pUnit->unnerveTotal()));
					}
					else
					{
						szString.append(NEWLINE);
						szString.append(gDLL->getText("TXT_KEY_UNIT_UNNERVE_TOTAL", pUnit->unnerveTotal()));
					}
				}

				if (pUnit->encloseTotal() > 0)
				{
					if (bShort)
					{
						szString.append(NEWLINE);
						szString.append(gDLL->getText("TXT_KEY_UNIT_ENCLOSE_TOTAL_SHORT", pUnit->encloseTotal()));
					}
					else
					{
						szString.append(NEWLINE);
						szString.append(gDLL->getText("TXT_KEY_UNIT_ENCLOSE_TOTAL", pUnit->encloseTotal()));
					}
				}
				if (pUnit->lungeTotal() > 0)
				{
					if (bShort)
					{
						szString.append(NEWLINE);
						szString.append(gDLL->getText("TXT_KEY_UNIT_LUNGE_TOTAL_SHORT", pUnit->lungeTotal()));
					}
					else
					{
						szString.append(NEWLINE);
						szString.append(gDLL->getText("TXT_KEY_UNIT_LUNGE_TOTAL", pUnit->lungeTotal()));
					}
				}
				if (pUnit->dynamicDefenseTotal() > 0)
				{
					if (bShort)
					{
						szString.append(NEWLINE);
						szString.append(gDLL->getText("TXT_KEY_UNIT_DYNAMIC_DEFENSE_TOTAL_SHORT", pUnit->dynamicDefenseTotal()));
					}
					else
					{
						szString.append(NEWLINE);
						szString.append(gDLL->getText("TXT_KEY_UNIT_DYNAMIC_DEFENSE_TOTAL", pUnit->dynamicDefenseTotal()));
					}
				}
			}

			//Power Shots
			if (pUnit->powerShotsTotal() > 0)
			{
				if (bShort)
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNIT_POWER_SHOTS_TOTAL_SHORT", pUnit->powerShotsTotal()));
				}
				else
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNIT_POWER_SHOTS_TOTAL_MODIFIER", pUnit->powerShotsTotal()));
				}
			}

			if (pUnit->powerShotCombatModifierTotal() != 0)
			{
				if (bShort)
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNIT_POWER_SHOT_COMBAT_MODIFIER_TOTAL_SHORT", pUnit->powerShotCombatModifierTotal()));
				}
				else
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNIT_POWER_SHOT_COMBAT_MODIFIER_TOTAL_MODIFIER", pUnit->powerShotCombatModifierTotal()));
				}
			}

			if (pUnit->powerShotPunctureModifierTotal() != 0)
			{
				if (bShort)
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNIT_POWER_SHOT_PUNCTURE_MODIFIER_TOTAL_SHORT", pUnit->powerShotPunctureModifierTotal()));
				}
				else
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNIT_POWER_SHOT_PUNCTURE_MODIFIER_TOTAL_MODIFIER", pUnit->powerShotPunctureModifierTotal()));
				}
			}

			if (pUnit->powerShotPrecisionModifierTotal() != 0)
			{
				if (bShort)
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNIT_POWER_SHOT_PRECISION_MODIFIER_TOTAL_SHORT", pUnit->powerShotPrecisionModifierTotal()));
				}
				else
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNIT_POWER_SHOT_PRECISION_MODIFIER_TOTAL_MODIFIER", pUnit->powerShotPrecisionModifierTotal()));
				}
			}

			if (pUnit->powerShotCriticalModifierTotal() != 0)
			{
				if (bShort)
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNIT_POWER_SHOT_CRITICAL_MODIFIER_TOTAL_SHORT", pUnit->powerShotCriticalModifierTotal()));
				}
				else
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNIT_POWER_SHOT_CRITICAL_MODIFIER_TOTAL_MODIFIER", pUnit->powerShotCriticalModifierTotal()));
				}
			}

			//Stuns and afflictions
				//Critical
			if (pUnit->criticalModifierTotal() != 0)
			{
				if (bShort)
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNIT_CRITICAL_MODIFIER_TOTAL_SHORT", pUnit->criticalModifierTotal()));
				}
				else
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNIT_CRITICAL_MODIFIER_TOTAL_MODIFIER", pUnit->criticalModifierTotal()));
				}
			}

			bFirst = true;
			for (iI = 0; iI < GC.getNumUnitCombatInfos(); ++iI)
			{
				if (pUnit->criticalVSUnitCombatTotal((UnitCombatTypes)iI) != 0)
				{
					if (!bFirst)
					{
						szString.append(gDLL->getText("TXT_KEY_COMMA"));
					}
					if (bFirst)
					{
						szString.append(NEWLINE);
						bFirst = false;
					}
					szString.append(gDLL->getText("TXT_KEY_PROMOTION_CRITICAL_VERSUS_TEXT", pUnit->criticalVSUnitCombatTotal((UnitCombatTypes)iI), CvWString(GC.getUnitCombatInfo((UnitCombatTypes)iI).getType()).GetCString(), GC.getUnitCombatInfo((UnitCombatTypes) iI).getTextKeyWide()));
				}
			}
				//Stun
			if (pUnit->roundStunProbTotal() != 0)
			{
				if (bShort)
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNIT_ROUND_STUN_TOTAL_MODIFIER_SHORT", pUnit->roundStunProbTotal()));
				}
				else
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNIT_ROUND_STUN_TOTAL_MODIFIER", pUnit->roundStunProbTotal()));
				}
			}

			bFirst = true;
			for (iI = 0; iI < GC.getNumUnitCombatInfos(); ++iI)
			{
				if (pUnit->roundStunVSUnitCombatTotal((UnitCombatTypes)iI) != 0)
				{
					if (!bFirst)
					{
						szString.append(gDLL->getText("TXT_KEY_COMMA"));
					}
					if (bFirst)
					{
						szString.append(NEWLINE);
						bFirst = false;
					}
					szString.append(gDLL->getText("TXT_KEY_PROMOTION_ROUND_STUN_VERSUS_TEXT", pUnit->roundStunVSUnitCombatTotal((UnitCombatTypes)iI), CvWString(GC.getUnitCombatInfo((UnitCombatTypes)iI).getType()).GetCString(), GC.getUnitCombatInfo((UnitCombatTypes) iI).getTextKeyWide()));
				}
			}
			//Traps

			int iValue = 0;
			bFirst = true;
			for (iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
			{
				UnitCombatTypes eTrapUnitCombat = (UnitCombatTypes)iI;
				iValue = pUnit->trapDisableUnitCombatTotal(eTrapUnitCombat);
				if (iValue != 0)
				{
					if (!bFirst)
					{
						szString.append(gDLL->getText("TXT_KEY_COMMA"));
					}
					if (bFirst)
					{
						szString.append(NEWLINE);
						bFirst = false;
					}
					szString.append(gDLL->getText("TXT_KEY_UNIT_TRAP_DISABLE_TYPE", iValue, CvWString(GC.getUnitCombatInfo(eTrapUnitCombat).getType()).GetCString(), GC.getUnitCombatInfo(eTrapUnitCombat).getTextKeyWide()));
				}
			}
			iValue = 0;
			bFirst = true;
			for (iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
			{
				UnitCombatTypes eTrapUnitCombat = (UnitCombatTypes)iI;
				iValue = pUnit->trapAvoidanceUnitCombatTotal(eTrapUnitCombat);
				if (iValue != 0)
				{
					if (!bFirst)
					{
						szString.append(gDLL->getText("TXT_KEY_COMMA"));
					}
					if (bFirst)
					{
						szString.append(NEWLINE);
						bFirst = false;
					}
					szString.append(gDLL->getText("TXT_KEY_UNIT_TRAP_AVOID_TYPE", iValue, CvWString(GC.getUnitCombatInfo(eTrapUnitCombat).getType()).GetCString(), GC.getUnitCombatInfo(eTrapUnitCombat).getTextKeyWide()));
				}
			}
			iValue = 0;
			bFirst = true;
			for (iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
			{
				UnitCombatTypes eTrapUnitCombat = (UnitCombatTypes)iI;
				iValue = pUnit->trapTriggerUnitCombatTotal(eTrapUnitCombat);
				if (iValue != 0)
				{
					if (!bFirst)
					{
						szString.append(gDLL->getText("TXT_KEY_COMMA"));
					}
					if (bFirst)
					{
						szString.append(NEWLINE);
						bFirst = false;
					}
					szString.append(gDLL->getText("TXT_KEY_UNIT_TRAP_TRIGGER_TYPE", iValue, CvWString(GC.getUnitCombatInfo(eTrapUnitCombat).getType()).GetCString(), GC.getUnitCombatInfo(eTrapUnitCombat).getTextKeyWide()));
				}
			}
			bFirst = true;
			for (iI = 0; iI < GC.getNumPromotionInfos(); iI++)
			{
				PromotionTypes eTrapPromo = (PromotionTypes)iI;
				if (pUnit->hasTrapSetWithPromotion(eTrapPromo))
				{
					if (iValue != 0)
					{
						if (!bFirst)
						{
							szString.append(gDLL->getText("TXT_KEY_COMMA"));
						}
						if (bFirst)
						{
							szString.append(NEWLINE);
							bFirst = false;
						}
						szString.append(gDLL->getText("TXT_KEY_UNIT_TRAP_PROMOTION_TYPE", GC.getPromotionInfo(eTrapPromo).getTextKeyWide()));
					}
				}
			}
			bFirst = true;
			for (iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
			{
				UnitCombatTypes eTrapUnitCombat = (UnitCombatTypes)iI;
				if (pUnit->hasTrapImmunityUnitCombat(eTrapUnitCombat))
				{
					if (iValue != 0)
					{
						if (!bFirst)
						{
							szString.append(gDLL->getText("TXT_KEY_COMMA"));
						}
						if (bFirst)
						{
							szString.append(NEWLINE);
							bFirst = false;
						}
						szString.append(gDLL->getText("TXT_KEY_UNIT_TRAP_IMMUNE_TYPE", GC.getUnitCombatInfo(eTrapUnitCombat).getTextKeyWide()));
					}
				}
			}
			int iTrapMin = pUnit->trapDamageMinTotal();
			int iTrapMax = pUnit->trapDamageMaxTotal();
			if (iTrapMax > 0)
			{
				szString.append(NEWLINE);
				szString.append(gDLL->getText("TXT_KEY_UNIT_TRAP_DAMAGE", iTrapMin, iTrapMax));
			}

			int iNumTriggers = pUnit->trapNumTriggers();
			int iNumTriggersRemaining = pUnit->trapNumTriggersRemaining();
			if (iNumTriggers > 0 && iNumTriggersRemaining > 0)
			{
				szString.append(NEWLINE);
				szString.append(gDLL->getText("TXT_KEY_UNIT_TRAP_NUM_ACTIVE_TRIGGERS", iNumTriggers, iNumTriggersRemaining));
			}

			if (pUnit->isTriggerBeforeAttack())
			{
				szString.append(NEWLINE);
				szString.append(gDLL->getText("TXT_KEY_UNIT_TRAP_TRIGGER_BEFORE_ATTACK"));
			}

			int iComplexity = pUnit->trapComplexityTotal();
			if (iComplexity > 0)
			{
				szString.append(NEWLINE);
				szString.append(gDLL->getText("TXT_KEY_UNIT_TRAP_COMPLEXITY", iComplexity));
			}

				//Afflict On Attack
			for (iI = 0; iI < GC.getNumPromotionLineInfos(); ++iI)
			{
				if (pUnit->hasAfflictOnAttackType((PromotionLineTypes)iI))
				{
					int iProbability = pUnit->getAfflictOnAttackTypeProbability((PromotionLineTypes)iI);
					if (pUnit->isAfflictOnAttackTypeImmediate((PromotionLineTypes)iI))
					{
						szString.append(NEWLINE);
						szString.append(gDLL->getText("TXT_KEY_AFFLICT_ON_ATTACK_IMMEDIATE_TEXT", iProbability, GC.getPromotionLineInfo((PromotionLineTypes) iI).getDescription()));
					}
					else
					{
						szString.append(NEWLINE);
						szString.append(gDLL->getText("TXT_KEY_AFFLICT_ON_ATTACK_TEXT", iProbability, GC.getPromotionLineInfo((PromotionLineTypes) iI).getDescription()));
					}
				}
			}

			if (pUnit->poisonProbabilityModifierTotal() > 0)
			{
				if (bShort)
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNIT_POISON_PROB_MOD_TOTAL_MODIFIER_SHORT", pUnit->poisonProbabilityModifierTotal()));
				}
				else
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNIT_POISON_PROB_MOD_TOTAL_MODIFIER", pUnit->poisonProbabilityModifierTotal()));
				}
			}

			if (pUnit->poisonProbabilityModifierTotal() < 0)
			{
				if (bShort)
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNIT_POISON_PROB_NEG_TOTAL_MODIFIER_SHORT", pUnit->poisonProbabilityModifierTotal()));
				}
				else
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNIT_POISON_PROB_NEG_TOTAL_MODIFIER", pUnit->poisonProbabilityModifierTotal()));
				}
			}
			//Cold Dmg
			if (pUnit->dealsColdDamage())
			{
				if (bShort)
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNIT_DEALS_COLD_DAMAGE_SHORT"));
				}
				else
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNIT_DEALS_COLD_DAMAGE_TOTAL"));
				}
			}

			//Str Per
			if (pUnit->strAdjperRndTotal() > 0)
			{
				if (bShort)
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNIT_RAGE_TOTAL_SHORT", pUnit->strAdjperRndTotal()));
				}
				else
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNIT_RAGE_TOTAL", pUnit->strAdjperRndTotal()));
				}
			}

			if (pUnit->strAdjperRndTotal() < 0)
			{
				if (bShort)
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNIT_FATIGUE_TOTAL_SHORT", pUnit->strAdjperRndTotal()));
				}
				else
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNIT_FATIGUE_TOTAL", pUnit->strAdjperRndTotal()));
				}
			}

			if (pUnit->strAdjperAttTotal() > 0)
			{
				if (bShort)
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNIT_RAMPAGE_TOTAL_SHORT", pUnit->strAdjperAttTotal()));
				}
				else
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNIT_RAMPAGE_TOTAL", pUnit->strAdjperAttTotal()));
				}
			}

			if (pUnit->strAdjperAttTotal() < 0)
			{
				if (bShort)
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNIT_TIRING_TOTAL_SHORT", pUnit->strAdjperAttTotal()));
				}
				else
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNIT_TIRING_TOTAL", pUnit->strAdjperAttTotal()));
				}
			}

			if (pUnit->strAdjperDefTotal() > 0)
			{
				if (bShort)
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNIT_DETERMINATION_TOTAL_SHORT", pUnit->strAdjperDefTotal()));
				}
				else
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNIT_DETERMINATION_TOTAL", pUnit->strAdjperDefTotal()));
				}
			}

			if (pUnit->strAdjperDefTotal() < 0)
			{
				if (bShort)
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNIT_DEMORALIZATION_TOTAL_SHORT", pUnit->strAdjperDefTotal()));
				}
				else
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNIT_DEMORALIZATION_TOTAL", pUnit->strAdjperDefTotal()));
				}
			}
		}

		//Setup Civil Displays
		if (bAlt)
		{
			if (pUnit->workRate(true) != 0)
			{
				szString.append(NEWLINE);
				szString.append(gDLL->getText("TXT_KEY_TEMP_WORK_RATE", pUnit->workRate(true)));
			}
			if (pUnit->revoltProtectionTotal() != 0)
			{
				szString.append(NEWLINE);
				szString.append(gDLL->getText("TXT_KEY_TEMP_REVOLT_PROTECTION", pUnit->revoltProtectionTotal()));
			}
			//Cargo
			if (GC.getGame().isOption(GAMEOPTION_SIZE_MATTERS))
			{
				if (pUnit->SMcargoSpace() > 0)
				{
					if (pUnit->getTeam() == GC.getGame().getActiveTeam())
					{
						szTempBuffer = NEWLINE + gDLL->getText("TXT_KEY_UNITHELP_CARGO_SPACE", pUnit->SMgetCargo(), pUnit->SMcargoSpace());
					}
					else
					{
						szTempBuffer = NEWLINE + gDLL->getText("TXT_KEY_UNITHELP_CARGO_SPACE_FOREIGN", pUnit->SMcargoSpace());
					}
					szString.append(szTempBuffer);

					if (pUnit->specialCargo() != NO_SPECIALUNIT)
					{
						szString.append(gDLL->getText("TXT_KEY_UNITHELP_CARRIES", GC.getSpecialUnitInfo(pUnit->specialCargo()).getTextKeyWide()));
					}
				}
				szString.append(NEWLINE);
				szString.append(gDLL->getText("TXT_KEY_UNITHELP_CARGO_SIZE_MATTERS", pUnit->SMCargoVolume()));
			}
			else if (pUnit->cargoSpace() > 0)
			{
				if (pUnit->getTeam() == GC.getGame().getActiveTeam())
				{
					szTempBuffer = NEWLINE + gDLL->getText("TXT_KEY_UNITHELP_CARGO_SPACE", pUnit->getCargo(), pUnit->cargoSpace());
				}
				else
				{
					szTempBuffer = NEWLINE + gDLL->getText("TXT_KEY_UNITHELP_CARGO_SPACE_FOREIGN", pUnit->cargoSpace());
				}
				szString.append(szTempBuffer);

				if (pUnit->specialCargo() != NO_SPECIALUNIT)
				{
					szString.append(gDLL->getText("TXT_KEY_UNITHELP_CARRIES", GC.getSpecialUnitInfo(pUnit->specialCargo()).getTextKeyWide()));
				}
			}
			//Healing
			if (pUnit->hasNoSelfHeal())
			{
				szString.append(NEWLINE);
				szString.append(gDLL->getText("TXT_KEY_UNITHELP_SELF_HEAL_NONE"));
			}

			if (pUnit->isAlwaysHeal())
			{
				//TSHEEP Display Spy Messages Differently
				if(pUnit->isSpy())
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_PROMOTION_LOYALTY_TEXT_SPY"));
				}
				else
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_PROMOTION_ALWAYS_HEAL_TEXT"));
				}
			}

			if (pUnit->getSelfHealModifierTotal() != 0)
			{
				szString.append(NEWLINE);
				szString.append(gDLL->getText("TXT_KEY_UNITHELP_SELF_HEAL", pUnit->getSelfHealModifierTotal()));
			}

			if (pUnit->getExtraEnemyHeal() != 0)
			{
				if(pUnit->isSpy())
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_PROMOTION_INSTIGATE_TEXT_SPY", pUnit->getExtraEnemyHeal()));
				}
				else
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_PROMOTION_HEALS_EXTRA_TEXT", pUnit->getExtraEnemyHeal()) + gDLL->getText("TXT_KEY_PROMOTION_ENEMY_LANDS_TEXT"));
				}
			}

			if (pUnit->getExtraNeutralHeal() != 0)
			{
				if(pUnit->isSpy())
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_PROMOTION_INSTIGATE2_TEXT_SPY", pUnit->getExtraNeutralHeal()));
				}
				else
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_PROMOTION_HEALS_EXTRA_TEXT", pUnit->getExtraNeutralHeal()) + gDLL->getText("TXT_KEY_PROMOTION_NEUTRAL_LANDS_TEXT"));
				}
			}

			if (pUnit->getExtraFriendlyHeal() != 0)
			{
				if(pUnit->isSpy())
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_PROMOTION_POISON_TEXT_SPY", pUnit->getExtraFriendlyHeal()));
				}
				else
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_PROMOTION_HEALS_EXTRA_TEXT", pUnit->getExtraFriendlyHeal()) + gDLL->getText("TXT_KEY_PROMOTION_FRIENDLY_LANDS_TEXT"));
				}
			}

			int iNumHealSupp = pUnit->getNumHealSupportTotal();
			if (iNumHealSupp > 0)
			{
				szString.append(NEWLINE);
				szString.append(gDLL->getText("TXT_KEY_UNIT_NUM_HEAL_SUPPORT", iNumHealSupp, pUnit->getHealSupportUsedTotal(), pUnit->getHealSupportRemaining()));
			}

			if (pUnit->getSameTileHeal() != 0)
			{
				szString.append(NEWLINE);
				szString.append(gDLL->getText("TXT_KEY_PROMOTION_HEALS_SAME_TEXT", pUnit->getSameTileHeal()) + gDLL->getText("TXT_KEY_PROMOTION_DAMAGE_TURN_TEXT"));
			}

			if (pUnit->hasHealUnitCombat())
			{
				int iVolume = 0;
				for (iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
				{
					iVolume = pUnit->getHealUnitCombatTypeTotal((UnitCombatTypes)iI);
					if (iVolume > 0)
					{
						szString.append(NEWLINE);
						szString.append(gDLL->getText("TXT_KEY_PROMOTION_HEALS_UNITCOMBAT_SAME_TEXT", GC.getUnitCombatInfo((UnitCombatTypes)iI).getTextKeyWide(), iVolume) + gDLL->getText("TXT_KEY_PROMOTION_DAMAGE_TURN_TEXT"));
					}
				}
			}

			if (pUnit->getAdjacentTileHeal() != 0)
			{
				szString.append(NEWLINE);
				szString.append(gDLL->getText("TXT_KEY_PROMOTION_HEALS_ADJACENT_TEXT", pUnit->getAdjacentTileHeal()) + gDLL->getText("TXT_KEY_PROMOTION_DAMAGE_TURN_TEXT"));
			}

			if (pUnit->hasHealUnitCombat())
			{
				int iVolume = 0;
				for (iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
				{
					iVolume = pUnit->getHealUnitCombatTypeAdjacentTotal((UnitCombatTypes)iI);
					if (iVolume > 0)
					{
						szString.append(NEWLINE);
						szString.append(gDLL->getText("TXT_KEY_PROMOTION_HEALS_UNITCOMBAT_ADJACENT_TEXT", GC.getUnitCombatInfo((UnitCombatTypes)iI).getTextKeyWide(), iVolume) + gDLL->getText("TXT_KEY_PROMOTION_DAMAGE_TURN_TEXT"));
					}
				}
			}
/*
			//Establish
			if (pUnit->establishModifier() != 0)
			{
				szString.append(NEWLINE);
				szString.append(gDLL->getText("TXT_KEY_UNITHELP_HEALING_HQ_MOD", pUnit->establishModifier()));
			}
*/
			if (pUnit->getVictoryAdjacentHeal() != 0)
			{
				szString.append(NEWLINE);
				szString.append(gDLL->getText("TXT_KEY_UNIT_VICTORY_ADJACENT_TEXT", pUnit->getVictoryHeal(), pUnit->getVictoryStackHeal(), pUnit->getVictoryAdjacentHeal()));
			}

			if ((pUnit->getVictoryStackHeal() != 0) && (pUnit->getVictoryAdjacentHeal() == 0))
			{
				szString.append(NEWLINE);
				szString.append(gDLL->getText("TXT_KEY_UNIT_VICTORY_STACK_TEXT", pUnit->getVictoryHeal(), pUnit->getVictoryStackHeal()));
			}

			if ((pUnit->getVictoryHeal() != 0) && (pUnit->getVictoryStackHeal() == 0))
			{
				szString.append(NEWLINE);
				szString.append(gDLL->getText("TXT_KEY_PROMOTION_VICTORY_HEAL_TEXT", pUnit->getVictoryHeal()));
			}

			//Curing, resisting and overcoming afflictions
			for (iI = 0; iI <GC.getNumPromotionLineInfos(); iI++)
			{
				PromotionLineTypes eAfflictionLine = ((PromotionLineTypes)iI);
				if (pUnit->getUnitAfflictionTolerance(eAfflictionLine) > 0)
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNIT_AFFLICTION_TOLERANCE_POSITIVE_TEXT", pUnit->getUnitAfflictionTolerance(eAfflictionLine), GC.getPromotionLineInfo(eAfflictionLine).getDescription()));
				}

				if (pUnit->getUnitAfflictionTolerance(eAfflictionLine) < 0)
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNIT_AFFLICTION_TOLERANCE_NEGATIVE_TEXT", pUnit->getUnitAfflictionTolerance(eAfflictionLine), GC.getPromotionLineInfo(eAfflictionLine).getDescription()));
				}

				if (pUnit->getFortitudeModifierTypeAmount(eAfflictionLine) > 0)
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNIT_FORTITUDE_MODIFIER_POSITIVE_TEXT", pUnit->getFortitudeModifierTypeAmount(eAfflictionLine), GC.getPromotionLineInfo(eAfflictionLine).getDescription()));
				}

				if (pUnit->getFortitudeModifierTypeAmount(eAfflictionLine) < 0)
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNIT_FORTITUDE_MODIFIER_NEGATIVE_TEXT", pUnit->getFortitudeModifierTypeAmount(eAfflictionLine), GC.getPromotionLineInfo(eAfflictionLine).getDescription()));
				}

				if (pUnit->hasAfflictionLine(eAfflictionLine))
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNIT_CHANCE_TO_OVERCOME", GC.getPromotionLineInfo(eAfflictionLine).getDescription(), pUnit->getChancetoOvercome(eAfflictionLine)));
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNIT_CHANCE_OF_WORSENING", GC.getPromotionLineInfo(eAfflictionLine).getDescription(), pUnit->getChancetoContract(eAfflictionLine)));
				}
			}

			for (iI = 0; iI < GC.getNumPropertyInfos(); iI++)
			{
				PropertyTypes eProperty = ((PropertyTypes)iI);
				int iAidTotal = pUnit->aidTotal(eProperty);
				if (iAidTotal > 0)
				{
					if (bShort)
					{
						szString.append(NEWLINE);
						szString.append(gDLL->getText("TXT_KEY_UNIT_AID_TOTAL_SHORT", GC.getPropertyInfo(eProperty).getDescription(), iAidTotal));
					}
					else
					{
						szString.append(NEWLINE);
						szString.append(gDLL->getText("TXT_KEY_UNIT_AID_TOTAL_MODIFIER", GC.getPropertyInfo(eProperty).getDescription(), iAidTotal));
					}
				}
			}

			for (iI = 0; iI < GC.getNumPromotionLineInfos(); ++iI)
			{
				if (pUnit->hasCureAfflictionType((PromotionLineTypes)iI))
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_CURE_AFFLICTION_TEXT", GC.getPromotionLineInfo((PromotionLineTypes) iI).getDescription()));
				}
			}

			//Extra Lives
			if (pUnit->isOneUp())
			{
				szString.append(NEWLINE);
				szString.append(gDLL->getText("TXT_KEY_UNIT_ONEUP_TEXT", pUnit->getOneUpCount()));
			}

			if (pUnit->getSurvivorChance() != 0)
			{
				szString.append(NEWLINE);
				szString.append(gDLL->getText("TXT_KEY_PROMOTION_SURVIVOR_TEXT", pUnit->getSurvivorChance()));
			}

			//Resistances
				//Fortitude
			if (pUnit->fortitudeTotal() > 0)
			{
				if (bShort)
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNIT_FORTITUDE_TOTAL_SHORT", pUnit->fortitudeTotal()));
				}
				else
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNIT_FORTITUDE_TOTAL_MODIFIER", pUnit->fortitudeTotal()));
				}
			}
				//Endurance
			if (pUnit->enduranceTotal() != 0)
			{
				if (bShort)
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNIT_ENDURANCE_TOTAL_SHORT", pUnit->enduranceTotal()));
				}
				else
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNIT_ENDURANCE_TOTAL_MODIFIER", pUnit->enduranceTotal()));
				}
			}
				//Immunity to Cold
			if (pUnit->hasImmunitytoColdDamage())
			{
				szString.append(NEWLINE);
				szString.append(gDLL->getText("TXT_KEY_UNIT_IMMUNITY_TO_COLD_DAMAGE"));
			}
				//Collateral Resistance
			for (iI = 0; iI < GC.getNumUnitCombatInfos(); ++iI)
			{
				if (pUnit->getUnitInfo().getUnitCombatCollateralImmune(iI))
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNIT_COLLATERAL_IMMUNE", CvWString(GC.getUnitCombatInfo((UnitCombatTypes)iI).getType()).GetCString(), GC.getUnitCombatInfo((UnitCombatTypes)iI).getTextKeyWide()));
				}
			}

			if (pUnit->getCollateralDamageProtection() > 0)
			{
				szString.append(NEWLINE);
				szString.append(gDLL->getText("TXT_KEY_PROMOTION_COLLATERAL_PROTECTION_TEXT", pUnit->getCollateralDamageProtection()));
			}

			//Map Interaction Mods
			if (pUnit->isUpgradeAnywhere())
			{
				szString.append(NEWLINE);
				szString.append(gDLL->getText("TXT_KEY_UPGRADE_ANYWHERE_TEXT"));
			}

			if (pUnit->isExcile())
			{
				szString.append(NEWLINE);
				szString.append(gDLL->getText("TXT_KEY_EXCILE_TEXT"));
			}

			if (pUnit->isPassage())
			{
				szString.append(NEWLINE);
				szString.append(gDLL->getText("TXT_KEY_PASSAGE_TEXT"));
			}

			if (pUnit->isNoNonOwnedCityEntry())
			{
				szString.append(NEWLINE);
				szString.append(gDLL->getText("TXT_KEY_NO_NON_OWNED_CITY_TEXT"));
			}

			if (pUnit->isBarbCoExist())
			{
				szString.append(NEWLINE);
				szString.append(gDLL->getText("TXT_KEY_BARB_COEXIST_TEXT"));
			}

			if (pUnit->isBlendIntoCity())
			{
				szString.append(NEWLINE);
				szString.append(gDLL->getText("TXT_KEY_BLEND_INTO_CITY_TEXT"));
			}

			if (pUnit->isNoCapture())
			{
				szString.append(NEWLINE);
				szString.append(gDLL->getText("TXT_KEY_UNIT_CANNOT_CAPTURE"));
			}

			//Capture interactions
			if (pUnit->captureProbabilityTotal() > 0)
			{
				szString.append(NEWLINE);
				szString.append(gDLL->getText("TXT_KEY_UNIT_CAPTURE_PROBABILITY_MODIFIER", pUnit->captureProbabilityTotal()));
			}

			if (pUnit->captureResistanceTotal() > 0)
			{
				szString.append(NEWLINE);
				szString.append(gDLL->getText("TXT_KEY_UNIT_CAPTURE_RESISTANCE_MODIFIER", pUnit->captureResistanceTotal()));
			}

			if (pUnit->isAssassin())
			{
				szString.append(NEWLINE);
				szString.append(gDLL->getText("TXT_KEY_ASSASSIN_TEXT"));
			}

			//Taunt
			if (pUnit->tauntTotal() > 0)
			{
				szString.append(NEWLINE);
				szString.append(gDLL->getText("TXT_KEY_UNIT_TAUNT", pUnit->tauntTotal()));
			}

			if (pUnit->getInsidiousnessTotal() != 0)
			{
				szString.append(NEWLINE);
				float fValue = (float)pUnit->getInsidiousnessTotal();
				{
					szTempBuffer.Format(L"%.1f", fValue/10);
				}
				szString.append(gDLL->getText("TXT_KEY_INSIDIOUSNESS_TEXT", szTempBuffer.GetCString()));
			}

			if (pUnit->getInvestigationTotal() != 0)
			{
				szString.append(NEWLINE);
				float fValue = (float)pUnit->getInvestigationTotal();
				{
					szTempBuffer.Format(L"%.1f", fValue/10);
				}
				szString.append(gDLL->getText("TXT_KEY_INVESTIGATION_TEXT", szTempBuffer.GetCString()));
			}

			//Targeting and Defending vs types
			szTempBuffer.clear();
			bFirst = true;
			for (iI = 0; iI < pUnit->getUnitInfo().getNumTargetUnits(); ++iI)
			{
				const UnitTypes eUnitX = (UnitTypes) pUnit->getUnitInfo().getTargetUnit(iI);

				if (bFirst)
				{
					bFirst = false;
				}
				else
				{
					szTempBuffer += L", ";
				}

				szTempBuffer += CvWString::format(L"<link=%s>%s</link>", CvWString(GC.getUnitInfo(eUnitX).getType()).GetCString(), GC.getUnitInfo(eUnitX).getDescription());
			}

			if (!bFirst)
			{
				szString.append(NEWLINE);
				szString.append(gDLL->getText("TXT_KEY_UNIT_TARGETS_UNIT_FIRST", szTempBuffer.GetCString()));
			}

			szTempBuffer.clear();
			bFirst = true;
			for (iI = 0; iI < pUnit->getUnitInfo().getNumDefendAgainstUnits(); ++iI)
			{
				const UnitTypes eUnitX = (UnitTypes)pUnit->getUnitInfo().getDefendAgainstUnit(iI);
				if (bFirst)
				{
					bFirst = false;
				}
				else
				{
					szTempBuffer += L", ";
				}
				szTempBuffer += CvWString::format(L"<link=%s>%s</link>", CvWString(GC.getUnitInfo(eUnitX).getType()).GetCString(), GC.getUnitInfo(eUnitX).getDescription());
			}

			if (!bFirst)
			{
				szString.append(NEWLINE);
				szString.append(gDLL->getText("TXT_KEY_UNIT_DEFENDS_UNIT_FIRST", szTempBuffer.GetCString()));
			}

			szTempBuffer.clear();
			bFirst = true;
			for (iI = 0; iI < GC.getNumUnitCombatInfos(); ++iI)
			{
				if (pUnit->getUnitInfo().getTargetUnitCombat(iI) || pUnit->hasTargetUnitCombat((UnitCombatTypes)iI))
				{
					if (bFirst)
					{
						bFirst = false;
					}
					else
					{
						szTempBuffer += L", ";
					}

					szTempBuffer += CvWString::format(L"<link=%s>%s</link>", CvWString(GC.getUnitCombatInfo((UnitCombatTypes)iI).getType()).GetCString(), GC.getUnitCombatInfo((UnitCombatTypes)iI).getDescription());
				}
			}

			if (!bFirst)
			{
				szString.append(NEWLINE);
				szString.append(gDLL->getText("TXT_KEY_UNIT_TARGETS_UNIT_FIRST", szTempBuffer.GetCString()));
			}

			szTempBuffer.clear();
			bFirst = true;
			for (iI = 0; iI < GC.getNumUnitCombatInfos(); ++iI)
			{
				if (pUnit->getUnitInfo().getDefenderUnitCombat(iI))
				{
					if (bFirst)
					{
						bFirst = false;
					}
					else
					{
						szTempBuffer += L", ";
					}

					szTempBuffer += CvWString::format(L"<link=%s>%s</link>", CvWString(GC.getUnitCombatInfo((UnitCombatTypes)iI).getType()).GetCString(), GC.getUnitCombatInfo((UnitCombatTypes)iI).getDescription());
				}
			}

			if (!bFirst)
			{
				szString.append(NEWLINE);
				szString.append(gDLL->getText("TXT_KEY_UNIT_DEFENDS_UNIT_FIRST", szTempBuffer.GetCString()));
			}

			//Pillaging
			if (pUnit->isPillageResearch())
			{
				szString.append(NEWLINE);
				szString.append(gDLL->getText("TXT_KEY_PROMOTION_RESEARCH_PILLAGE_TEXT"));
			}

			if (pUnit->isPillageCulture())
			{
				szString.append(NEWLINE);
				szString.append(gDLL->getText("TXT_KEY_PROMOTION_CULTURE_PILLAGE_TEXT"));
			}

			if (pUnit->isPillageEspionage())
			{
				szString.append(NEWLINE);
				szString.append(gDLL->getText("TXT_KEY_PROMOTION_ESPIONAGE_PILLAGE_TEXT"));
			}

			if (pUnit->isPillageMarauder())
			{
				szString.append(NEWLINE);
				szString.append(gDLL->getText("TXT_KEY_PROMOTION_MARAUDER_PILLAGE_TEXT"));
			}

			if (pUnit->isPillageOnMove())
			{
				szString.append(NEWLINE);
				szString.append(gDLL->getText("TXT_KEY_PROMOTION_MOVING_PILLAGE_TEXT"));
			}

			if (pUnit->isPillageOnVictory())
			{
				szString.append(NEWLINE);
				szString.append(gDLL->getText("TXT_KEY_PROMOTION_VICTORY_PILLAGE_TEXT"));
			}

			//Celebrity
			if (pUnit->getCelebrityHappy() != 0)
			{
				szString.append(NEWLINE);
				szString.append(gDLL->getText("TXT_KEY_PROMOTION_CELEBRITY_TEXT", pUnit->getCelebrityHappy()));
			}

			//Worker details
			for (iI = 0; iI < GC.getNumTerrainInfos(); iI++)
			{
				if (pUnit->terrainWorkPercent((TerrainTypes)iI) > 0)
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_PROMOTION_WORK_TEXT", pUnit->terrainWorkPercent((TerrainTypes)iI), GC.getTerrainInfo((TerrainTypes)iI).getTextKeyWide()));
				}
			}
			for (iI = 0; iI < GC.getNumFeatureInfos(); iI++)
			{
				if (pUnit->featureWorkPercent((FeatureTypes)iI) > 0)
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_PROMOTION_WORK_TEXT", pUnit->featureWorkPercent((FeatureTypes)iI), GC.getFeatureInfo((FeatureTypes)iI).getTextKeyWide()));
				}
			}
			for (iI = 0; iI < GC.getNumBuildInfos(); iI++)
			{
				if (pUnit->buildWorkPercent((BuildTypes)iI) > 0)
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_PROMOTION_WORK_TEXT", pUnit->buildWorkPercent((BuildTypes)iI), GC.getBuildInfo((BuildTypes)iI).getTextKeyWide()));
				}
			}

			if (pUnit->hillsWorkModifier() > 0)
			{
				szString.append(NEWLINE);
				szString.append(gDLL->getText("TXT_KEY_PROMOTION_HILLS_WORK_TEXT", pUnit->hillsWorkModifier()));
			}

			if (pUnit->peaksWorkModifier() > 0)
			{
				szString.append(NEWLINE);
				szString.append(gDLL->getText("TXT_KEY_PROMOTION_PEAKS_WORK_TEXT", pUnit->peaksWorkModifier()));
			}

			//Strength in Numbers offered support
#ifdef STRENGTH_IN_NUMBERS
			if (GC.getGame().isOption(GAMEOPTION_STRENGTH_IN_NUMBERS))
			{
				if (pUnit->frontSupportPercentTotal() > 0)
				{
					if (bShort)
					{
						szString.append(NEWLINE);
						szString.append(gDLL->getText("TXT_KEY_UNIT_FRONT_SUPPORT_PERCENT_TOTAL_SHORT", pUnit->frontSupportPercentTotal()));
					}
					else
					{
						szString.append(NEWLINE);
						szString.append(gDLL->getText("TXT_KEY_UNIT_FRONT_SUPPORT_PERCENT_TOTAL", pUnit->frontSupportPercentTotal()));
					}
				}
				if (pUnit->shortRangeSupportPercentTotal() > 0)
				{
					if (bShort)
					{
						szString.append(NEWLINE);
						szString.append(gDLL->getText("TXT_KEY_UNIT_SHORT_RANGE_SUPPORT_PERCENT_TOTAL_SHORT", pUnit->shortRangeSupportPercentTotal()));
					}
					else
					{
						szString.append(NEWLINE);
						szString.append(gDLL->getText("TXT_KEY_UNIT_SHORT_RANGE_SUPPORT_PERCENT_TOTAL", pUnit->shortRangeSupportPercentTotal()));
					}
				}
				if (pUnit->mediumRangeSupportPercentTotal() > 0)
				{
					if (bShort)
					{
						szString.append(NEWLINE);
						szString.append(gDLL->getText("TXT_KEY_UNIT_MEDIUM_RANGE_SUPPORT_PERCENT_TOTAL_SHORT", pUnit->mediumRangeSupportPercentTotal()));
					}
					else
					{
						szString.append(NEWLINE);
						szString.append(gDLL->getText("TXT_KEY_UNIT_MEDIUM_RANGE_SUPPORT_PERCENT_TOTAL", pUnit->mediumRangeSupportPercentTotal()));
					}
				}
				if (pUnit->longRangeSupportPercentTotal() > 0)
				{
					if (bShort)
					{
						szString.append(NEWLINE);
						szString.append(gDLL->getText("TXT_KEY_UNIT_LONG_RANGE_SUPPORT_PERCENT_TOTAL_SHORT", pUnit->longRangeSupportPercentTotal()));
					}
					else
					{
						szString.append(NEWLINE);
						szString.append(gDLL->getText("TXT_KEY_UNIT_LONG_RANGE_SUPPORT_PERCENT_TOTAL", pUnit->longRangeSupportPercentTotal()));
					}
				}
				if (pUnit->flankSupportPercentTotal() > 0)
				{
					if (bShort)
					{
						szString.append(NEWLINE);
						szString.append(gDLL->getText("TXT_KEY_UNIT_FLANK_SUPPORT_PERCENT_TOTAL_SHORT", pUnit->flankSupportPercentTotal()));
					}
					else
					{
						szString.append(NEWLINE);
						szString.append(gDLL->getText("TXT_KEY_UNIT_FLANK_SUPPORT_PERCENT_TOTAL", pUnit->flankSupportPercentTotal()));
					}
				}
			}
#endif // STRENGTH_IN_NUMBERS

			//Property Manipulators
			pUnit->getPropertiesConst()->buildDisplayString(szString);
			pUnit->getUnitInfo().getPropertyManipulators()->buildDisplayString(szString);
			for (iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
			{
				if (pUnit->isHasUnitCombat((UnitCombatTypes)iI))
				{
					if (GC.getUnitCombatInfo((UnitCombatTypes)iI).getPropertyManipulators()->getNumInteractions() > 0
						|| GC.getUnitCombatInfo((UnitCombatTypes)iI).getPropertyManipulators()->getNumPropagators() > 0
						|| GC.getUnitCombatInfo((UnitCombatTypes)iI).getPropertyManipulators()->getNumSources() > 0)
					{
						szString.append(NEWLINE);
						szString.append(gDLL->getText("TXT_KEY_UNIT_MODIFIER_PROPERTY_MANIP", GC.getUnitCombatInfo((UnitCombatTypes)iI).getDescription()));
						GC.getUnitCombatInfo((UnitCombatTypes)iI).getPropertyManipulators()->buildDisplayString(szString);
					}
				}
			}
			for (iI = 0; iI < GC.getNumPromotionInfos(); iI++)
			{
				if (pUnit->isHasPromotion((PromotionTypes)iI))
				{
					if (GC.getPromotionInfo((PromotionTypes)iI).getPropertyManipulators()->getNumInteractions() > 0
						|| GC.getPromotionInfo((PromotionTypes)iI).getPropertyManipulators()->getNumPropagators() > 0
						|| GC.getPromotionInfo((PromotionTypes)iI).getPropertyManipulators()->getNumSources() > 0)
					{
						szString.append(NEWLINE);
						szString.append(gDLL->getText("TXT_KEY_UNIT_MODIFIER_PROPERTY_MANIP", GC.getPromotionInfo((PromotionTypes)iI).getDescription()));
						GC.getPromotionInfo((PromotionTypes)iI).getPropertyManipulators()->buildDisplayString(szString);
					}
				}
			}


			//Costs
			if (pUnit->costModifierTotal() > 0)
			{
				if (bShort)
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNIT_COST_MODIFIER_TOTAL_SHORT", pUnit->costModifierTotal()));
				}
				else
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNIT_COST_MODIFIER_TOTAL_MODIFIER", pUnit->costModifierTotal()));
				}
			}
		}

		//Setup Miscellaneous Pertinent displays
		if (bNormalView)
		{
			//Max HP
			if (pUnit->canFight())
			{
				if (pUnit->maxHPTotal() != 100)
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNIT_MAX_HP", pUnit->maxHPTotal()));
				}
				if (pUnit->isHurt())
				{
					const int iNumHealAsTypes = GC.getUnitInfo(pUnit->getUnitType()).getNumHealAsTypes();
					for (iI = 0; iI < iNumHealAsTypes; iI++)
					{
						const UnitCombatTypes eHealAsTypes = (UnitCombatTypes)GC.getUnitInfo(pUnit->getUnitType()).getHealAsType(iI);
						const int iHealAsDamage = pUnit->getHealAsDamage((UnitCombatTypes)GC.getUnitInfo(pUnit->getUnitType()).getHealAsType(iI));
						if (iHealAsDamage > 0)
						{
							szString.append(NEWLINE);
							szString.append(gDLL->getText("TXT_KEY_UNITHELP_DAMAGE_BY_UNITCOMBAT",
								GC.getUnitCombatInfo(eHealAsTypes).getTextKeyWide(), iHealAsDamage, pUnit->healTurnsAsType(pUnit->plot(), eHealAsTypes)));
						}
					}
				}
			}
			//Fortification
			if (pUnit->fortifyModifier() != 0)
			{
				szString.append(NEWLINE);
				szString.append(gDLL->getText("TXT_KEY_UNITHELP_FORTIFIED", pUnit->fortifyModifier()));
			}

			if (pUnit->isMilitaryBranch())
			{
				szString.append(NEWLINE);
				szString.append(gDLL->getText("TXT_KEY_UNITHELP_BRANCH_MILITARY"));
			}
			else
			{
				szString.append(NEWLINE);
				szString.append(gDLL->getText("TXT_KEY_UNITHELP_BRANCH_CIVILIAN"));
			}

			if (pUnit->getUpkeep100() > 0)
			{
				szTempBuffer = CvWString::format(L"%.2f", pUnit->getUpkeep100() / 100.0);
				szString.append(NEWLINE);
				szString.append(gDLL->getText("TXT_KEY_UNITHELP_UPKEEP", szTempBuffer.GetCString()));
			}

			setEspionageMissionHelp(szString, pUnit);

			//Current Cold Damage
			if (pUnit->getColdDamage() > 0)
			{
				if (bShort)
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNIT_COLD_DAMAGE_SHORT", pUnit->getColdDamage()));
				}
				else
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNIT_COLD_DAMAGE_TOTAL", pUnit->getColdDamage()));
				}
			}
			// isSpy
			if (pUnit->isSpy())
			{
				szString.append(NEWLINE);
				szString.append(gDLL->getText("TXT_KEY_UNIT_IS_SPY"));
			}
			if (!bShort)
			{
				//Nuclear
				if (pUnit->nukeRange() >= 0)
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNIT_CAN_NUKE"));
				}

				if(pUnit->isMADEnabled() && pUnit->getMADTargetPlot() != NULL)
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_NUKE_TARGET_CITY", pUnit->getMADTargetPlot()->getPlotCity()->getNameKey()));
				}

				//Invisibility/Visibility
				if (pUnit->alwaysInvisible())
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNIT_INVISIBLE_ALL"));
				}

				if (!GC.getGame().isOption(GAMEOPTION_HIDE_AND_SEEK))
				{
					if (pUnit->getInvisibleType() != NO_INVISIBLE)
					{
						szString.append(NEWLINE);
						szString.append(gDLL->getText("TXT_KEY_UNIT_INVISIBLE_MOST"));
					}

					for (iI = 0; iI < pUnit->getNumSeeInvisibleTypes(); iI++)
					{
						if (pUnit->getSeeInvisibleType(iI) != pUnit->getInvisibleType())
						{
							szString.append(NEWLINE);
							szString.append(gDLL->getText("TXT_KEY_UNIT_SEE_INVISIBLE", GC.getInvisibleInfo(pUnit->getSeeInvisibleType(iI)).getChar()));
						}
					}
				}
				else
				{
					bFirst = true;
					for (iI = 0; iI < GC.getNumInvisibleInfos(); iI++)
					{
						if (pUnit->visibilityIntensityTotal((InvisibleTypes)iI) != 0)
						{
							if (!bFirst)
							{
								szString.append(gDLL->getText("TXT_KEY_COMMA"));
							}
							if (bFirst)
							{
								szString.append(NEWLINE);
								bFirst = false;
							}
							szString.append(gDLL->getText("TXT_KEY_UNITHELP_INVISIBILITY_SPOT_VALUE", pUnit->visibilityIntensityTotal((InvisibleTypes)iI), GC.getInvisibleInfo((InvisibleTypes) iI).getChar()));
						}
					}
					bFirst = true;
					for (iI = 0; iI < GC.getNumInvisibleInfos(); iI++)
					{
						if (pUnit->visibilityIntensityRangeTotal((InvisibleTypes)iI) != 0)
						{
							if (!bFirst)
							{
								szString.append(gDLL->getText("TXT_KEY_COMMA"));
							}
							if (bFirst)
							{
								szString.append(NEWLINE);
								bFirst = false;
							}
							szString.append(gDLL->getText("TXT_KEY_UNITHELP_INVISIBILITY_SPOT_RANGE_VALUE", pUnit->visibilityIntensityRangeTotal((InvisibleTypes)iI), GC.getInvisibleInfo((InvisibleTypes) iI).getChar()));
						}
					}
					bFirst = true;
					for (iI = 0; iI < GC.getNumInvisibleInfos(); iI++)
					{
						if (pUnit->visibilityIntensitySameTileTotal((InvisibleTypes)iI) != 0)
						{
							if (!bFirst)
							{
								szString.append(gDLL->getText("TXT_KEY_COMMA"));
							}
							if (bFirst)
							{
								szString.append(NEWLINE);
								bFirst = false;
							}
							szString.append(gDLL->getText("TXT_KEY_UNITHELP_INVISIBILITY_SPOT_SAME_TILE_VALUE", pUnit->visibilityIntensitySameTileTotal((InvisibleTypes)iI), GC.getInvisibleInfo((InvisibleTypes) iI).getChar()));
						}
					}
					bFirst = true;
					for (iI = 0; iI < GC.getNumInvisibleInfos(); iI++)
					{
						if (!pUnit->isNegatesInvisible((InvisibleTypes)iI))
						{
							if (pUnit->invisibilityIntensityTotal((InvisibleTypes)iI) != 0 && !pUnit->isNeverInvisible())
							{
								if (!bFirst)
								{
									szString.append(gDLL->getText("TXT_KEY_COMMA"));
								}
								if (bFirst)
								{
									szString.append(NEWLINE);
									bFirst = false;
								}
								szString.append(gDLL->getText("TXT_KEY_UNITHELP_INVISIBILITY_VEIL_VALUE", pUnit->invisibilityIntensityTotal((InvisibleTypes)iI), GC.getInvisibleInfo((InvisibleTypes) iI).getChar()));
							}
						}
						else
						{
							szString.append(NEWLINE);
							szString.append(gDLL->getText("TXT_KEY_UNITHELP_INVISIBILITY_VEIL_NEGATED", CvWString(GC.getInvisibleInfo((InvisibleTypes)iI).getType()).GetCString(), GC.getInvisibleInfo((InvisibleTypes) iI).getChar()));
						}
					}
					/*bFirst = true;
					for (iI = 0; iI < GC.getNumInvisibleInfos(); iI++)
					{
						if (!pUnit->isNegatesInvisible((InvisibleTypes)iI))
						{
							for (int iJ = 0; iJ < GC.getNumTerrainInfos(); iJ++)
							{
								if (pUnit->extraInvisibleTerrain((InvisibleTypes)iI, (TerrainTypes)iJ) != 0)
								{
									if (!bFirst)
									{
										szString.append(gDLL->getText("TXT_KEY_COMMA"));
									}
									if (bFirst)
									{
										szString.append(NEWLINE);
										bFirst = false;
									}
									szString.append(gDLL->getText("TXT_KEY_UNITHELP_INVISIBILITY_VEIL_PLOT_VALUE_ADJ", GC.getInvisibleInfo((InvisibleTypes)iI).getTextKeyWide(), pUnit->extraInvisibleTerrain((InvisibleTypes)iI, (TerrainTypes)iJ), GC.getTerrainInfo((TerrainTypes)iJ).getTextKeyWide()));
								}
							}
						}
					}
					bFirst = true;
					for (iI = 0; iI < GC.getNumInvisibleInfos(); iI++)
					{
						if (!pUnit->isNegatesInvisible((InvisibleTypes)iI))
						{
							for (int iJ = 0; iJ < GC.getNumFeatureInfos(); iJ++)
							{
								if (pUnit->extraInvisibleFeature((InvisibleTypes)iI, (FeatureTypes)iJ) != 0)
								{
									if (!bFirst)
									{
										szString.append(gDLL->getText("TXT_KEY_COMMA"));
									}
									if (bFirst)
									{
										szString.append(NEWLINE);
										bFirst = false;
									}
									szString.append(gDLL->getText("TXT_KEY_UNITHELP_INVISIBILITY_VEIL_PLOT_VALUE_ADJ", GC.getInvisibleInfo((InvisibleTypes)iI).getTextKeyWide(), pUnit->extraInvisibleFeature((InvisibleTypes)iI, (FeatureTypes)iJ), GC.getFeatureInfo((FeatureTypes)iJ).getTextKeyWide()));
								}
							}
						}
					}
					bFirst = true;
					for (iI = 0; iI < GC.getNumInvisibleInfos(); iI++)
					{
						if (!pUnit->isNegatesInvisible((InvisibleTypes)iI))
						{
							for (int iJ = 0; iJ < GC.getNumImprovementInfos(); iJ++)
							{
								if (pUnit->extraInvisibleImprovement((InvisibleTypes)iI, (ImprovementTypes)iJ) != 0)
								{
									if (!bFirst)
									{
										szString.append(gDLL->getText("TXT_KEY_COMMA"));
									}
									if (bFirst)
									{
										szString.append(NEWLINE);
										bFirst = false;
									}
									szString.append(gDLL->getText("TXT_KEY_UNITHELP_INVISIBILITY_VEIL_PLOT_VALUE_ADJ", GC.getInvisibleInfo((InvisibleTypes)iI).getTextKeyWide(), pUnit->extraInvisibleImprovement((InvisibleTypes)iI, (ImprovementTypes)iJ), GC.getImprovementInfo((ImprovementTypes)iJ).getTextKeyWide()));
								}
							}
						}
					}
					bFirst = true;
					for (iI = 0; iI < GC.getNumInvisibleInfos(); iI++)
					{
						for (int iJ = 0; iJ < GC.getNumTerrainInfos(); iJ++)
						{
							if (pUnit->extraVisibleTerrain((InvisibleTypes)iI, (TerrainTypes)iJ) != 0)
							{
								if (!bFirst)
								{
									szString.append(gDLL->getText("TXT_KEY_COMMA"));
								}
								if (bFirst)
								{
									szString.append(NEWLINE);
									bFirst = false;
								}
								szString.append(gDLL->getText("TXT_KEY_UNITHELP_INVISIBILITY_SPOT_PLOT_VALUE_ADJ", GC.getInvisibleInfo((InvisibleTypes)iI).getTextKeyWide(), pUnit->extraVisibleTerrain((InvisibleTypes)iI, (TerrainTypes)iJ), GC.getTerrainInfo((TerrainTypes)iJ).getTextKeyWide()));
							}
						}
					}
					bFirst = true;
					for (iI = 0; iI < GC.getNumInvisibleInfos(); iI++)
					{
						for (int iJ = 0; iJ < GC.getNumFeatureInfos(); iJ++)
						{
							if (pUnit->extraVisibleFeature((InvisibleTypes)iI, (FeatureTypes)iJ) != 0)
							{
								if (!bFirst)
								{
									szString.append(gDLL->getText("TXT_KEY_COMMA"));
								}
								if (bFirst)
								{
									szString.append(NEWLINE);
									bFirst = false;
								}
								szString.append(gDLL->getText("TXT_KEY_UNITHELP_INVISIBILITY_SPOT_PLOT_VALUE_ADJ", GC.getInvisibleInfo((InvisibleTypes)iI).getTextKeyWide(), pUnit->extraVisibleFeature((InvisibleTypes)iI, (FeatureTypes)iJ), GC.getFeatureInfo((FeatureTypes)iJ).getTextKeyWide()));
							}
						}
					}
					bFirst = true;
					for (iI = 0; iI < GC.getNumInvisibleInfos(); iI++)
					{
						for (int iJ = 0; iJ < GC.getNumImprovementInfos(); iJ++)
						{
							if (pUnit->extraVisibleImprovement((InvisibleTypes)iI, (ImprovementTypes)iJ) != 0)
							{
								if (!bFirst)
								{
									szString.append(gDLL->getText("TXT_KEY_COMMA"));
								}
								if (bFirst)
								{
									szString.append(NEWLINE);
									bFirst = false;
								}
								szString.append(gDLL->getText("TXT_KEY_UNITHELP_INVISIBILITY_SPOT_PLOT_VALUE_ADJ", GC.getInvisibleInfo((InvisibleTypes)iI).getTextKeyWide(), pUnit->extraVisibleImprovement((InvisibleTypes)iI, (ImprovementTypes)iJ), GC.getImprovementInfo((ImprovementTypes)iJ).getTextKeyWide()));
							}
						}
					}
					bFirst = true;
					for (iI = 0; iI < GC.getNumInvisibleInfos(); iI++)
					{
						for (int iJ = 0; iJ < GC.getNumTerrainInfos(); iJ++)
						{
							if (pUnit->extraVisibleTerrainRange((InvisibleTypes)iI, (TerrainTypes)iJ) != 0)
							{
								if (!bFirst)
								{
									szString.append(gDLL->getText("TXT_KEY_COMMA"));
								}
								if (bFirst)
								{
									szString.append(NEWLINE);
									bFirst = false;
								}
								szString.append(gDLL->getText("TXT_KEY_UNITHELP_INVISIBILITY_SPOT_PLOT_RANGE_VALUE_ADJ", GC.getInvisibleInfo((InvisibleTypes)iI).getTextKeyWide(), pUnit->extraVisibleTerrainRange((InvisibleTypes)iI, (TerrainTypes)iJ), GC.getTerrainInfo((TerrainTypes)iJ).getTextKeyWide()));
							}
						}
					}
					bFirst = true;
					for (iI = 0; iI < GC.getNumInvisibleInfos(); iI++)
					{
						for (int iJ = 0; iJ < GC.getNumFeatureInfos(); iJ++)
						{
							if (pUnit->extraVisibleFeatureRange((InvisibleTypes)iI, (FeatureTypes)iJ) != 0)
							{
								if (!bFirst)
								{
									szString.append(gDLL->getText("TXT_KEY_COMMA"));
								}
								if (bFirst)
								{
									szString.append(NEWLINE);
									bFirst = false;
								}
								szString.append(gDLL->getText("TXT_KEY_UNITHELP_INVISIBILITY_SPOT_PLOT_RANGE_VALUE_ADJ", GC.getInvisibleInfo((InvisibleTypes)iI).getTextKeyWide(), pUnit->extraVisibleFeatureRange((InvisibleTypes)iI, (FeatureTypes)iJ), GC.getFeatureInfo((FeatureTypes)iJ).getTextKeyWide()));
							}
						}
					}
					bFirst = true;
					for (iI = 0; iI < GC.getNumInvisibleInfos(); iI++)
					{
						for (int iJ = 0; iJ < GC.getNumImprovementInfos(); iJ++)
						{
							if (pUnit->extraVisibleImprovementRange((InvisibleTypes)iI, (ImprovementTypes)iJ) != 0)
							{
								if (!bFirst)
								{
									szString.append(gDLL->getText("TXT_KEY_COMMA"));
								}
								if (bFirst)
								{
									szString.append(NEWLINE);
									bFirst = false;
								}
								szString.append(gDLL->getText("TXT_KEY_UNITHELP_INVISIBILITY_SPOT_PLOT_RANGE_VALUE_ADJ", GC.getInvisibleInfo((InvisibleTypes)iI).getTextKeyWide(), pUnit->extraVisibleImprovementRange((InvisibleTypes)iI, (ImprovementTypes)iJ), GC.getImprovementInfo((ImprovementTypes)iJ).getTextKeyWide()));
							}
						}
					}*/
					if (pUnit->isNeverInvisible())
					{
						szString.append(NEWLINE);
						szString.append(gDLL->getText("TXT_KEY_NO_INVISIBILITY_TEXT"));
					}
				}

				if (pUnit->getExtraVisibilityRange() != 0)
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_PROMOTION_VISIBILITY_TEXT", pUnit->getExtraVisibilityRange()));
				}

				//Movement
				if (pUnit->canMoveImpassable())
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNIT_CAN_MOVE_IMPASSABLE"));
				}

				if (pUnit->flatMovementCost())
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNIT_FLAT_MOVEMENT"));
				}

				if (pUnit->ignoreTerrainCost())
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNIT_IGNORE_TERRAIN"));
				}

				if (pUnit->isEnemyRoute())
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_PROMOTION_ENEMY_ROADS_TEXT"));
				}

				if (pUnit->isHillsDoubleMove())
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_PROMOTION_HILLS_MOVE_TEXT"));
				}

				if (pUnit->isCanMovePeaks())
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_PROMOTION_CAN_MOVE_PEAKS_TEXT"));
				}

				if (pUnit->isCanLeadThroughPeaks())
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_PROMOTION_CAN_LEAD_THROUGH_PEAKS_TEXT"));
				}

				for (iI = 0; iI < GC.getNumTerrainInfos(); ++iI)
				{
					if (pUnit->isTerrainDoubleMove((TerrainTypes)iI))
					{
						szString.append(NEWLINE);
						szString.append(gDLL->getText("TXT_KEY_PROMOTION_DOUBLE_MOVE_TEXT", GC.getTerrainInfo((TerrainTypes) iI).getTextKeyWide()));
					}
				}

				for (iI = 0; iI < GC.getNumFeatureInfos(); ++iI)
				{
					if (pUnit->isFeatureDoubleMove((FeatureTypes)iI))
					{
						szString.append(NEWLINE);
						szString.append(gDLL->getText("TXT_KEY_PROMOTION_DOUBLE_MOVE_TEXT", GC.getFeatureInfo((FeatureTypes) iI).getTextKeyWide()));
					}
				}

				if (pUnit->getExtraMoveDiscount() != 0)
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_PROMOTION_MOVE_DISCOUNT_TEXT", -(pUnit->getExtraMoveDiscount())));
				}

				szTempBuffer.clear();
				szTempBuffer.Format(L"%s%s ", NEWLINE, gDLL->getText("TXT_KEY_UNIT_CAN_ONLY_TRAVERSE").GetCString());
				for (iI = 0; iI < GC.getNumRouteInfos(); ++iI)
				{
					if (pUnit->getUnitInfo().getPassableRouteNeeded(iI))
					{
						CvWString szRoute;
						szRoute.Format(L"<link=%s>%s</link>", CvWString(GC.getRouteInfo((RouteTypes)iI).getType()).GetCString(), GC.getRouteInfo((RouteTypes)iI).getDescription());
						setListHelp(szString, szTempBuffer, szRoute, L", ", bFirst);
						bFirst = false;
					}
				}

				if (pUnit->isDefensiveVictoryMove())
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_PROMOTION_DV_MOVE_TEXT"));
				}

				if (pUnit->isOffensiveVictoryMove())
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_PROMOTION_OV_MOVE_TEXT"));
				}

				if (pUnit->canIgnoreZoneofControl())
				{
					if (bShort)
					{
						szString.append(NEWLINE);
						szString.append(gDLL->getText("TXT_KEY_UNIT_IGNORE_ZONE_OF_CONTROL_SHORT"));
					}
					else
					{
						szString.append(NEWLINE);
						szString.append(gDLL->getText("TXT_KEY_UNIT_IGNORE_ZONE_OF_CONTROL_LONG"));
					}
				}

				if (pUnit->canFliesToMove())
				{
					if (bShort)
					{
						szString.append(NEWLINE);
						szString.append(gDLL->getText("TXT_KEY_UNIT_FLIES_TO_MOVE_SHORT"));
					}
					else
					{
						szString.append(NEWLINE);
						szString.append(gDLL->getText("TXT_KEY_UNIT_FLIES_TO_MOVE_LONG"));
					}
				}

				if (pUnit->canAnimalIgnoresBorders() && !GC.getGame().isOption(GAMEOPTION_ANIMALS_STAY_OUT))
				{
					if (bShort)
					{
						szString.append(NEWLINE);
						szString.append(gDLL->getText("TXT_KEY_UNIT_ANIMAL_IGNORES_BORDERS_SHORT"));
					}
					else
					{
						szString.append(NEWLINE);
						szString.append(gDLL->getText("TXT_KEY_UNIT_ANIMAL_IGNORES_BORDERS_LONG"));
					}
				}

				if (pUnit->getUnitInfo().isNoRevealMap())
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNIT_VISIBILITY_MOVE_RANGE"));
				}

				//Paradrop
				if (pUnit->getDropRange() > 0)
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNIT_PARADROP_RANGE", pUnit->getDropRange()));
				}

				if (pUnit->isFreeDrop() && !pUnit->hasCannotMergeSplit())
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_PROMOTION_FREE_DROP_TEXT"));

					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_PROMOTION_DROP_SIGHT_UNSEEN_TEXT"));
				}

				//Experience
				if (pUnit->getExperiencePercent() != 0)
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_EXPERIENCE_PERCENT_TEXT", pUnit->getExperiencePercent()));
				}

				//Misc
				if (!CvWString(pUnit->getUnitInfo().getHelp()).empty())
				{
					szString.append(NEWLINE);
					szString.append(pUnit->getUnitInfo().getHelp());
				}
			}
			for (iI = 0; iI < pUnit->getUnitInfo().getNumMapCategoryTypes(); iI++)
			{
				szString.append(NEWLINE);
				szString.append(gDLL->getText("TXT_KEY_MAP_CATEGORY_PREREQUISITE", GC.getMapCategoryInfo((MapCategoryTypes)pUnit->getUnitInfo().getMapCategoryType(iI)).getTextKeyWide()));
			}

		}

		if (bShift && (gDLL->getChtLvl() > 0))
		{
			CvWString unitAIType = GC.getUnitAIInfo(pUnit->AI_getUnitAIType()).getType();
			szTempBuffer.Format(L"\nUnitAI Type = %s.", unitAIType.GetCString());
			szString.append(szTempBuffer);
			szTempBuffer.Format(L"\nSacrifice Value = %d.", pUnit->AI_sacrificeValue(NULL));
			szString.append(szTempBuffer);
		}
	}
	if (bNormalView)
	{
		//Outcome Missions
		CvOutcomeListMerged mergedList;
		mergedList.addOutcomeList(pUnit->getUnitInfo().getKillOutcomeList());

		for (int iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
		{
			if (pUnit->isHasUnitCombat((UnitCombatTypes)iI))
			{
				UnitCombatTypes eCombat = (UnitCombatTypes)iI;
				mergedList.addOutcomeList(GC.getUnitCombatInfo(eCombat).getKillOutcomeList());
			}
		}

		if (!mergedList.isEmpty())
		{
			if (gDLL->getInterfaceIFace()->headSelectionListNode())
			{
				CvUnit* pSelectedUnit = ::getUnit(gDLL->getInterfaceIFace()->headSelectionListNode()->m_data);
				if (pSelectedUnit)
				{
					if (mergedList.isPossible(*pSelectedUnit))
					{
						szString.append(NEWLINE);
						szString.append(gDLL->getText("TXT_KEY_UNIT_ANIMAL_ON_KILL"));
						szString.append(":");
						mergedList.buildDisplayString(szString, *pSelectedUnit);
					}
				}
			}
		}
	}

	if (!bShort && !bOneLine)
	{
		if (!bCtrl)
		{
			szString.append(NEWLINE);
			szTempBuffer.Format( SETCOLR L"%s" ENDCOLR, TEXT_COLOR("COLOR_UNIT_TEXT"), gDLL->getText("TXT_TB_UNIT_VIEW_1").c_str());
			szString.append(szTempBuffer);
		}
		if (!bAlt)
		{
			szString.append(NEWLINE);
			szTempBuffer.Format( SETCOLR L"%s" ENDCOLR, TEXT_COLOR("COLOR_UNIT_TEXT"), gDLL->getText("TXT_TB_UNIT_VIEW_2").c_str());
			szString.append(szTempBuffer);
		}
		if (!bShift)
		{
			szString.append(NEWLINE);
			szTempBuffer.Format( SETCOLR L"%s" ENDCOLR, TEXT_COLOR("COLOR_UNIT_TEXT"), gDLL->getText("TXT_TB_UNIT_VIEW_3").c_str());
			szString.append(szTempBuffer);
		}
	}
}


void CvGameTextMgr::setPlotListHelp(CvWStringBuffer &szString, CvPlot* pPlot, bool bOneLine, bool bShort)
{
	PROFILE_FUNC();

	int numPromotionInfos = GC.getNumPromotionInfos();

	// if cheatmode and ctrl, display grouping info instead
	if ((gDLL->getChtLvl() > 0) && gDLL->ctrlKey())
	{
		if (pPlot->isVisible(GC.getGame().getActiveTeam(), GC.getGame().isDebugMode()))
		{
			CvWString szTempString;

			CLLNode<IDInfo>* pUnitNode = pPlot->headUnitNode();
			while(pUnitNode != NULL)
			{
				CvUnit* pHeadUnit = ::getUnit(pUnitNode->m_data);
				pUnitNode = pPlot->nextUnitNode(pUnitNode);

				// is this unit the head of a group, not cargo, and visible?
				if (pHeadUnit && pHeadUnit->isGroupHead() && !pHeadUnit->isCargo() && !pHeadUnit->isInvisible(GC.getGame().getActiveTeam(), GC.getGame().isDebugMode()))
				{
					// head unit name and unitai
					szString.append(CvWString::format(SETCOLR L"%s" ENDCOLR, 255,190,0,255, pHeadUnit->getName().GetCString()));
					szString.append(CvWString::format(L" (%d)", shortenID(pHeadUnit->getID())));
					getUnitAIString(szTempString, pHeadUnit->AI_getUnitAIType());
					szString.append(CvWString::format(SETCOLR L" %s " ENDCOLR, GET_PLAYER(pHeadUnit->getOwner()).getPlayerTextColorR(), GET_PLAYER(pHeadUnit->getOwner()).getPlayerTextColorG(), GET_PLAYER(pHeadUnit->getOwner()).getPlayerTextColorB(), GET_PLAYER(pHeadUnit->getOwner()).getPlayerTextColorA(), szTempString.GetCString()));

					//TB Removing promotions from plot list display - they are overwhelming and it's cooler to have to send in an invisible unit to get to see the promos on another stack
					// promotion icons
					//for (int iPromotionIndex = 0; iPromotionIndex < numPromotionInfos; iPromotionIndex++)
					//{
					//	PromotionTypes ePromotion = (PromotionTypes)iPromotionIndex;
					//	if (pHeadUnit->isHasPromotion(ePromotion))
					//	{
					//		szString.append(CvWString::format(L"<img=%S size=16 />", GC.getPromotionInfo(ePromotion).getButton()));
					//	}
					//}

					// group
					CvSelectionGroup* pHeadGroup = pHeadUnit->getGroup();
					FAssertMsg(pHeadGroup != NULL, "unit has NULL group");
					szString.append(CvWString::format(L"\nGroup:%d [%d units", shortenID(pHeadGroup->getID()), pHeadGroup->getNumUnits()));
					if (pHeadGroup->getNumUnits() > 1)
					{
						if( pHeadGroup->getCargo() > 0 )
						{
							szString.append(CvWString::format(L" + %d cargo", pHeadGroup->getCargo()));
						}
						szString.append(CvWString::format(L"]"));

						// get average damage
						int iAverageDamage = 0;
						CLLNode<IDInfo>* pUnitNode = pHeadGroup->headUnitNode();
						while (pUnitNode != NULL)
						{
							CvUnit* pLoopUnit = ::getUnit(pUnitNode->m_data);
							pUnitNode = pHeadGroup->nextUnitNode(pUnitNode);

							iAverageDamage += (pLoopUnit->getDamage() * 100) / pLoopUnit->maxHitPoints();
						}
						iAverageDamage /= pHeadGroup->getNumUnits();
						if (iAverageDamage > 0)
						{
							szString.append(CvWString::format(L" %d%%", 100 - iAverageDamage));
						}
					}

					if( pHeadGroup->isStranded() )
					{
						szString.append(CvWString::format(SETCOLR L"\n***STRANDED***" ENDCOLR, TEXT_COLOR("COLOR_RED")));
					}

					if( !gDLL->altKey() )
					{
						// mission ai
						MissionAITypes eMissionAI = pHeadGroup->AI_getMissionAIType();
						if (eMissionAI != NO_MISSIONAI)
						{
							getMissionAIString(szTempString, eMissionAI);
							szString.append(CvWString::format(SETCOLR L"\n%s" ENDCOLR, TEXT_COLOR("COLOR_HIGHLIGHT_TEXT"), szTempString.GetCString()));
						}

						// mission
						MissionTypes eMissionType = (MissionTypes) pHeadGroup->getMissionType(0);
						if (eMissionType != NO_MISSION)
						{
							getMissionTypeString(szTempString, eMissionType);
							szString.append(CvWString::format(SETCOLR L"\n%s" ENDCOLR, TEXT_COLOR("COLOR_HIGHLIGHT_TEXT"), szTempString.GetCString()));
						}

						// mission unit
						CvUnit* pMissionUnit = pHeadGroup->AI_getMissionAIUnit();
						if (pMissionUnit != NULL && (eMissionAI != NO_MISSIONAI || eMissionType != NO_MISSION))
						{
							// mission unit
							szString.append(L"\n to ");
							szString.append(CvWString::format(SETCOLR L"%s" ENDCOLR, GET_PLAYER(pMissionUnit->getOwner()).getPlayerTextColorR(), GET_PLAYER(pMissionUnit->getOwner()).getPlayerTextColorG(), GET_PLAYER(pMissionUnit->getOwner()).getPlayerTextColorB(), GET_PLAYER(pMissionUnit->getOwner()).getPlayerTextColorA(), pMissionUnit->getName().GetCString()));
							szString.append(CvWString::format(L"(%d) G:%d", shortenID(pMissionUnit->getID()), shortenID(pMissionUnit->getGroupID())));
							getUnitAIString(szTempString, pMissionUnit->AI_getUnitAIType());
							szString.append(CvWString::format(SETCOLR L" %s" ENDCOLR, GET_PLAYER(pMissionUnit->getOwner()).getPlayerTextColorR(), GET_PLAYER(pMissionUnit->getOwner()).getPlayerTextColorG(), GET_PLAYER(pMissionUnit->getOwner()).getPlayerTextColorB(), GET_PLAYER(pMissionUnit->getOwner()).getPlayerTextColorA(), szTempString.GetCString()));
						}

						// mission plot
						if (eMissionAI != NO_MISSIONAI || eMissionType != NO_MISSION)
						{
							// first try the plot from the missionAI
							CvPlot* pMissionPlot = pHeadGroup->AI_getMissionAIPlot();

							// if MissionAI does not have a plot, get one from the mission itself
							if (pMissionPlot == NULL && eMissionType != NO_MISSION)
							{
								switch (eMissionType)
								{
								case MISSION_MOVE_TO:
								case MISSION_ROUTE_TO:
									pMissionPlot =  GC.getMap().plot(pHeadGroup->getMissionData1(0), pHeadGroup->getMissionData2(0));
									break;

								case MISSION_MOVE_TO_UNIT:
									if (pMissionUnit != NULL)
									{
										pMissionPlot = pMissionUnit->plot();
									}
									break;
								}
							}

							if (pMissionPlot != NULL)
							{
								szString.append(CvWString::format(L"\n [%d,%d]", pMissionPlot->getX(), pMissionPlot->getY()));

								CvCity* pCity = pMissionPlot->getWorkingCity();
								if (pCity != NULL)
								{
									szString.append(L" (");

									if (!pMissionPlot->isCity())
									{
										DirectionTypes eDirection = estimateDirection(dxWrap(pMissionPlot->getX() - pCity->getX()), dyWrap(pMissionPlot->getY() - pCity->getY()));

										getDirectionTypeString(szTempString, eDirection);
										szString.append(CvWString::format(L"%s of ", szTempString.GetCString()));
									}

									szString.append(CvWString::format(SETCOLR L"%s" ENDCOLR L")", GET_PLAYER(pCity->getOwner()).getPlayerTextColorR(), GET_PLAYER(pCity->getOwner()).getPlayerTextColorG(), GET_PLAYER(pCity->getOwner()).getPlayerTextColorB(), GET_PLAYER(pCity->getOwner()).getPlayerTextColorA(), pCity->getName().GetCString()));
								}
								else
								{
									if (pMissionPlot != pPlot)
									{
										DirectionTypes eDirection = estimateDirection(dxWrap(pMissionPlot->getX() - pPlot->getX()), dyWrap(pMissionPlot->getY() - pPlot->getY()));

										getDirectionTypeString(szTempString, eDirection);
										szString.append(CvWString::format(L" (%s)", szTempString.GetCString()));
									}

									PlayerTypes eMissionPlotOwner = pMissionPlot->getOwner();
									if (eMissionPlotOwner != NO_PLAYER)
									{
										szString.append(CvWString::format(L", " SETCOLR L"%s" ENDCOLR, GET_PLAYER(eMissionPlotOwner).getPlayerTextColorR(), GET_PLAYER(eMissionPlotOwner).getPlayerTextColorG(), GET_PLAYER(eMissionPlotOwner).getPlayerTextColorB(), GET_PLAYER(eMissionPlotOwner).getPlayerTextColorA(), GET_PLAYER(eMissionPlotOwner).getName()));
									}
								}
							}
						}

						// activity
						ActivityTypes eActivityType = (ActivityTypes) pHeadGroup->getActivityType();
						if (eActivityType != NO_ACTIVITY)
						{
							getActivityTypeString(szTempString, eActivityType);
							szString.append(CvWString::format(SETCOLR L"\n%s" ENDCOLR, TEXT_COLOR("COLOR_HIGHLIGHT_TEXT"), szTempString.GetCString()));
						}
					}

					if( !gDLL->altKey() && !gDLL->shiftKey() )
					{
						// display cargo for head unit
						std::vector<CvUnit*> aCargoUnits;
						pHeadUnit->getCargoUnits(aCargoUnits);
						for (uint i = 0; i < aCargoUnits.size(); i++)
						{
							CvUnit* pCargoUnit = aCargoUnits[i];
							if (!pCargoUnit->isInvisible(GC.getGame().getActiveTeam(), GC.getGame().isDebugMode()))
							{
								// name and unitai
								szString.append(CvWString::format(SETCOLR L"\n %s" ENDCOLR, TEXT_COLOR("COLOR_ALT_HIGHLIGHT_TEXT"), pCargoUnit->getName().GetCString()));
								szString.append(CvWString::format(L"(%d)", shortenID(pCargoUnit->getID())));
								getUnitAIString(szTempString, pCargoUnit->AI_getUnitAIType());
								szString.append(CvWString::format(SETCOLR L" %s " ENDCOLR, GET_PLAYER(pCargoUnit->getOwner()).getPlayerTextColorR(), GET_PLAYER(pCargoUnit->getOwner()).getPlayerTextColorG(), GET_PLAYER(pCargoUnit->getOwner()).getPlayerTextColorB(), GET_PLAYER(pCargoUnit->getOwner()).getPlayerTextColorA(), szTempString.GetCString()));

								// promotion icons
		/*						for (int iPromotionIndex = 0; iPromotionIndex < numPromotionInfos; iPromotionIndex++)
								{
									PromotionTypes ePromotion = (PromotionTypes)iPromotionIndex;
									if (pCargoUnit->isHasPromotion(ePromotion))
									{
										szString.append(CvWString::format(L"<img=%S size=16 />", GC.getPromotionInfo(ePromotion).getButton()));
									}
								}*/
							}
						}

						// display grouped units
						CLLNode<IDInfo>* pUnitNode3 = pPlot->headUnitNode();
						while(pUnitNode3 != NULL)
						{
							CvUnit* pUnit = ::getUnit(pUnitNode3->m_data);
							pUnitNode3 = pPlot->nextUnitNode(pUnitNode3);

							// is this unit not head, in head's group and visible?
							if (pUnit && (pUnit != pHeadUnit) && (pUnit->getGroupID() == pHeadUnit->getGroupID()) && !pUnit->isInvisible(GC.getGame().getActiveTeam(), GC.getGame().isDebugMode()))
							{
								FAssertMsg(!pUnit->isCargo(), "unit is cargo but head unit is not cargo");
								// name and unitai
								szString.append(CvWString::format(SETCOLR L"\n-%s" ENDCOLR, TEXT_COLOR("COLOR_UNIT_TEXT"), pUnit->getName().GetCString()));
								szString.append(CvWString::format(L" (%d)", shortenID(pUnit->getID())));
								getUnitAIString(szTempString, pUnit->AI_getUnitAIType());
								szString.append(CvWString::format(SETCOLR L" %s " ENDCOLR, GET_PLAYER(pUnit->getOwner()).getPlayerTextColorR(), GET_PLAYER(pUnit->getOwner()).getPlayerTextColorG(), GET_PLAYER(pUnit->getOwner()).getPlayerTextColorB(), GET_PLAYER(pUnit->getOwner()).getPlayerTextColorA(), szTempString.GetCString()));

								// promotion icons
		/*						for (int iPromotionIndex = 0; iPromotionIndex < numPromotionInfos; iPromotionIndex++)
								{
									PromotionTypes ePromotion = (PromotionTypes)iPromotionIndex;
									if (pUnit->isHasPromotion(ePromotion))
									{
										szString.append(CvWString::format(L"<img=%S size=16 />", GC.getPromotionInfo(ePromotion).getButton()));
									}
								}*/

								// display cargo for loop unit
								std::vector<CvUnit*> aLoopCargoUnits;
								pUnit->getCargoUnits(aLoopCargoUnits);
								for (uint i = 0; i < aLoopCargoUnits.size(); i++)
								{
									CvUnit* pCargoUnit = aLoopCargoUnits[i];
									if (!pCargoUnit->isInvisible(GC.getGame().getActiveTeam(), GC.getGame().isDebugMode()))
									{
										// name and unitai
										szString.append(CvWString::format(SETCOLR L"\n %s" ENDCOLR, TEXT_COLOR("COLOR_ALT_HIGHLIGHT_TEXT"), pCargoUnit->getName().GetCString()));
										szString.append(CvWString::format(L"(%d)", shortenID(pCargoUnit->getID())));
										getUnitAIString(szTempString, pCargoUnit->AI_getUnitAIType());
										szString.append(CvWString::format(SETCOLR L" %s " ENDCOLR, GET_PLAYER(pCargoUnit->getOwner()).getPlayerTextColorR(), GET_PLAYER(pCargoUnit->getOwner()).getPlayerTextColorG(), GET_PLAYER(pCargoUnit->getOwner()).getPlayerTextColorB(), GET_PLAYER(pCargoUnit->getOwner()).getPlayerTextColorA(), szTempString.GetCString()));

										// promotion icons
		/*								for (int iPromotionIndex = 0; iPromotionIndex < numPromotionInfos; iPromotionIndex++)
										{
											PromotionTypes ePromotion = (PromotionTypes)iPromotionIndex;
											if (pCargoUnit->isHasPromotion(ePromotion))
											{
												szString.append(CvWString::format(L"<img=%S size=16 />", GC.getPromotionInfo(ePromotion).getButton()));
											}
										}*/
									}
								}
							}
						}
					}

					if( !gDLL->altKey() )
					{
						if( pPlot->getTeam() == NO_TEAM || GET_TEAM(pHeadGroup->getTeam()).isAtWar(pPlot->getTeam()) )
						{
							szString.append(NEWLINE);
							CvWString szTempBuffer;

							//AI strategies
							if (GET_PLAYER(pHeadGroup->getOwner()).AI_isDoStrategy(AI_STRATEGY_DAGGER))
							{
								szTempBuffer.Format(L"Dagger, ");
								szString.append(szTempBuffer);
							}
							if (GET_PLAYER(pHeadGroup->getOwner()).AI_isDoStrategy(AI_STRATEGY_CRUSH))
							{
								szTempBuffer.Format(L"Crush, ");
								szString.append(szTempBuffer);
							}
							if (GET_PLAYER(pHeadGroup->getOwner()).AI_isDoStrategy(AI_STRATEGY_ALERT1))
							{
								szTempBuffer.Format(L"Alert1, ");
								szString.append(szTempBuffer);
							}
							if (GET_PLAYER(pHeadGroup->getOwner()).AI_isDoStrategy(AI_STRATEGY_ALERT2))
							{
								szTempBuffer.Format(L"Alert2, ");
								szString.append(szTempBuffer);
							}
							if (GET_PLAYER(pHeadGroup->getOwner()).AI_isDoStrategy(AI_STRATEGY_TURTLE))
							{
								szTempBuffer.Format(L"Turtle, ");
								szString.append(szTempBuffer);
							}
							if (GET_PLAYER(pHeadGroup->getOwner()).AI_isDoStrategy(AI_STRATEGY_LAST_STAND))
							{
								szTempBuffer.Format(L"Last Stand, ");
								szString.append(szTempBuffer);
							}
							if (GET_PLAYER(pHeadGroup->getOwner()).AI_isDoStrategy(AI_STRATEGY_FINAL_WAR))
							{
								szTempBuffer.Format(L"FinalWar, ");
								szString.append(szTempBuffer);
							}
							if (GET_PLAYER(pHeadGroup->getOwner()).AI_isDoStrategy(AI_STRATEGY_GET_BETTER_UNITS))
							{
								szTempBuffer.Format(L"GetBetterUnits, ");
								szString.append(szTempBuffer);
							}
							if (GET_PLAYER(pHeadGroup->getOwner()).AI_isDoStrategy(AI_STRATEGY_FASTMOVERS))
							{
								szTempBuffer.Format(L"FastMovers, ");
								szString.append(szTempBuffer);
							}
							if (GET_PLAYER(pHeadGroup->getOwner()).AI_isDoStrategy(AI_STRATEGY_LAND_BLITZ))
							{
								szTempBuffer.Format(L"LandBlitz, ");
								szString.append(szTempBuffer);
							}
							if (GET_PLAYER(pHeadGroup->getOwner()).AI_isDoStrategy(AI_STRATEGY_AIR_BLITZ))
							{
								szTempBuffer.Format(L"AirBlitz, ");
								szString.append(szTempBuffer);
							}
 							if (GET_PLAYER(pHeadGroup->getOwner()).AI_isDoStrategy(AI_STRATEGY_OWABWNW))
							{
								szTempBuffer.Format(L"OWABWNW, ");
								szString.append(szTempBuffer);
							}
							if (GET_PLAYER(pHeadGroup->getOwner()).AI_isDoStrategy(AI_STRATEGY_PRODUCTION))
							{
								szTempBuffer.Format(L"Production, ");
								szString.append(szTempBuffer);
							}
							if (GET_PLAYER(pHeadGroup->getOwner()).AI_isDoStrategy(AI_STRATEGY_MISSIONARY))
							{
								szTempBuffer.Format(L"Missionary, ");
								szString.append(szTempBuffer);
							}
							if (GET_PLAYER(pHeadGroup->getOwner()).AI_isDoStrategy(AI_STRATEGY_BIG_ESPIONAGE))
							{
								szTempBuffer.Format(L"BigEspionage, ");
								szString.append(szTempBuffer);
							}
							if (GET_PLAYER(pHeadGroup->getOwner()).isPushReligiousVictory())
							{
								szTempBuffer.Format(L"Religious Victory, ");
								szString.append(szTempBuffer);
							}
							else if (GET_PLAYER(pHeadGroup->getOwner()).isConsiderReligiousVictory())
							{
								szTempBuffer.Format(L"Considers Religious Victory, ");
								szString.append(szTempBuffer);
							}

							//Area battle plans.
							if (pPlot->area()->getAreaAIType(pHeadGroup->getTeam()) == AREAAI_OFFENSIVE)
							{
								szTempBuffer.Format(L"\n Area AI = OFFENSIVE");
							}
							else if (pPlot->area()->getAreaAIType(pHeadGroup->getTeam()) == AREAAI_DEFENSIVE)
							{
								szTempBuffer.Format(L"\n Area AI = DEFENSIVE");
							}
							else if (pPlot->area()->getAreaAIType(pHeadGroup->getTeam()) == AREAAI_MASSING)
							{
								szTempBuffer.Format(L"\n Area AI = MASSING");
							}
							else if (pPlot->area()->getAreaAIType(pHeadGroup->getTeam()) == AREAAI_ASSAULT)
							{
								szTempBuffer.Format(L"\n Area AI = ASSAULT");
							}
							else if (pPlot->area()->getAreaAIType(pHeadGroup->getTeam()) == AREAAI_ASSAULT_MASSING)
							{
								szTempBuffer.Format(L"\n Area AI = ASSAULT_MASSING");
							}
							else if (pPlot->area()->getAreaAIType(pHeadGroup->getTeam()) == AREAAI_NEUTRAL)
							{
								szTempBuffer.Format(L"\n Area AI = NEUTRAL");
							}

							CvCity* pTargetCity = pPlot->area()->getTargetCity(pHeadGroup->getOwner());
							if( pTargetCity )
							{
								szString.append(CvWString::format(L"\nTarget City: %s (%d)", pTargetCity->getName().c_str(), pTargetCity->getOwner()));
							}
							else
							{
								szString.append(CvWString::format(L"\nTarget City: None"));
							}

							if( gDLL->shiftKey() )
							{
								//int iBestTargetValue = (pTargetCity != NULL ? GET_PLAYER(pHeadGroup->getOwner()).AI_targetCityValue(pTargetCity,false,true) : 0);
								szString.append(CvWString::format(L"\n\nTarget City values:\n"));
								for( int iPlayer = 0; iPlayer < MAX_PLAYERS; iPlayer++ )
								{
									if( GET_TEAM(pHeadGroup->getTeam()).AI_getWarPlan(GET_PLAYER((PlayerTypes)iPlayer).getTeam()) != NO_WARPLAN )
									{
										if( pPlot->area()->getCitiesPerPlayer((PlayerTypes)iPlayer) > 0 )
										{
											foreach_(CvCity* pLoopCity, GET_PLAYER((PlayerTypes)iPlayer).cities()
											| filtered(CvCity::fn::area() == pPlot->area()))
											{
												if (GC.getMap().calculatePathDistance(pPlot, pLoopCity->plot()) < 20)
												{
													const int iTargetValue = GET_PLAYER(pHeadGroup->getOwner()).AI_targetCityValue(pLoopCity,false,true);
													szString.append(CvWString::format(L"\n%s : %d + rand %d", pLoopCity->getName().c_str(), iTargetValue, (pLoopCity->getPopulation() / 2)));
												}
											}
										}
									}
								}
							}
						}
					}
					// double space non-empty groups
					if (pHeadGroup->getNumUnits() > 1 || pHeadUnit->hasCargo())
					{
						szString.append(NEWLINE);
					}
					szString.append(NEWLINE);
				}
			}
		}
		return;
	}

	std::vector<CvUnit *> plotUnits;

	GC.getGame().getPlotUnits(pPlot, plotUnits);

	int iNumVisibleUnits = 0;
	if (pPlot->isVisible(GC.getGame().getActiveTeam(), GC.getGame().isDebugMode()))
	{
		CLLNode<IDInfo>* pUnitNode5 = pPlot->headUnitNode();
		while(pUnitNode5 != NULL)
		{
			CvUnit* pUnit = ::getUnit(pUnitNode5->m_data);
			pUnitNode5 = pPlot->nextUnitNode(pUnitNode5);

			if (pUnit && !pUnit->isInvisible(GC.getGame().getActiveTeam(), GC.getGame().isDebugMode()))
			{
				++iNumVisibleUnits;
			}
		}
	}


	if (iNumVisibleUnits > 0)
	{
		const CvUnit* centerUnit = pPlot->getCenterUnit();

		if (centerUnit)
		{
			setUnitHelp(szString, centerUnit, iNumVisibleUnits > 12, true);
		}

		if (iNumVisibleUnits > 1)
		{
			std::map<int,PlayerUnitInfo> a_units;
			int iCount = 0;
			for (int iI = 0; iI < iNumVisibleUnits && iI < (int) plotUnits.size(); iI++)
			{
				CvUnit* pLoopUnit = plotUnits[iI];

				if (pLoopUnit != NULL && pLoopUnit != centerUnit)
				{
					std::map<int,PlayerUnitInfo>::iterator itr = a_units.find(PLAYER_UNIT_KEY(pLoopUnit->getOwner(), pLoopUnit->getUnitType()));

					if ( itr == a_units.end() )
					{
						PlayerUnitInfo newInfo;

						itr = a_units.insert(std::make_pair(PLAYER_UNIT_KEY(pLoopUnit->getOwner(), pLoopUnit->getUnitType()), newInfo)).first;
						itr->second.m_eOwner = pLoopUnit->getOwner();
						itr->second.m_eUnitType = pLoopUnit->getUnitType();
					}

					if ( (itr->second.m_iCount)++ == 0 )
					{
						iCount++;
					}
					int iBase = (DOMAIN_AIR == pLoopUnit->getDomainType() ? pLoopUnit->airBaseCombatStr() : pLoopUnit->baseCombatStr());
					if (iBase > 0 && pLoopUnit->maxHitPoints() > 0)
					{
						itr->second.m_iTotalMaxStrength += 100 * iBase;
						itr->second.m_iTotalStrength += (100 * iBase * pLoopUnit->currHitPoints()) / pLoopUnit->maxHitPoints();
					}

					for (int iJ = 0; iJ < numPromotionInfos; iJ++)
					{
						if (pLoopUnit->isHasPromotion((PromotionTypes)iJ))
						{
							std::map<PromotionTypes,int>::iterator promoItr = itr->second.m_promotions.find((PromotionTypes)iJ);

							if ( promoItr == itr->second.m_promotions.end() )
							{
								itr->second.m_promotions.insert(std::make_pair((PromotionTypes)iJ,1));
							}
							else
							{
								(promoItr->second)++;
							}
						}
					}
				}
			}

			bool bFirst = true;
			for (std::map<int, PlayerUnitInfo>::const_iterator itr = a_units.begin(); itr != a_units.end(); ++itr)
			{
				const CvPlayer& kPlayer = GET_PLAYER(itr->second.m_eOwner);
				const CvUnitInfo& kUnit = GC.getUnitInfo(itr->second.m_eUnitType);

				if (iCount < 5 || bFirst)
				{
					szString.append(NEWLINE);
					bFirst = false;
				}
				else
				{
					szString.append(L", ");
				}
				CvWString szUnitName;

				szUnitName.clear();
				if (kPlayer.getCivilizationType() != NO_CIVILIZATION
				&& kUnit.getCivilizationName(kPlayer.getCivilizationType()) != NULL
				&& !CvWString(kUnit.getCivilizationName(kPlayer.getCivilizationType())).empty())
				{
					szUnitName = gDLL->getText(kUnit.getCivilizationName(kPlayer.getCivilizationType()));
				}
				if (szUnitName.empty())
				{
					szUnitName = kUnit.getDescription();
				}
				szString.append(CvWString::format(SETCOLR L"%s" ENDCOLR, TEXT_COLOR("COLOR_UNIT_TEXT"), szUnitName.c_str()));

				szString.append(CvWString::format(L" (%d)", itr->second.m_iCount));

				if (GC.getGame().isOption(GAMEOPTION_SIZE_MATTERS))
				{
					if (itr->second.m_iTotalMaxStrength > 0)
					{
						float iBase = ((float)itr->second.m_iTotalMaxStrength / (float)itr->second.m_iCount) / 10000;
						float iCurrent = ((float)itr->second.m_iTotalStrength / (float)itr->second.m_iCount) / 10000;
						if (iBase == iCurrent)
						{
							szString.append(CvWString::format(L" %.1f", iBase));
						}
						else
						{
							szString.append(CvWString::format(L" %.1f/%.1f", iCurrent, iBase));
						}
						szString.append(CvWString::format(L"%c", gDLL->getSymbolID(STRENGTH_CHAR)));
					}
				}
				else if (itr->second.m_iTotalMaxStrength > 0)
				{
					int iBase = (itr->second.m_iTotalMaxStrength / itr->second.m_iCount) / 100;
					int iCurrent = (itr->second.m_iTotalStrength / itr->second.m_iCount) / 100;
					int iCurrent100 = (itr->second.m_iTotalStrength / itr->second.m_iCount) % 100;

					if (0 != iCurrent100)
					{
						szString.append(CvWString::format(L" %d.%02d/%d", iCurrent, iCurrent100, iBase));
					}
					else if (iBase == iCurrent)
					{
						szString.append(CvWString::format(L" %d", iBase));
					}
					else
					{
						szString.append(CvWString::format(L" %d/%d", iCurrent, iBase));
					}
					szString.append(CvWString::format(L"%c", gDLL->getSymbolID(STRENGTH_CHAR)));
				}

				if (kPlayer.getID() != GC.getGame().getActivePlayer() && !kUnit.isHiddenNationality())
				{
					szString.append(L", ");

					// For minor civs, display civ name instead of player name ... to differentiate
					// and help human recognize why they can't contact that player
					if (kPlayer.isMinorCiv())
					{
						szString.append(CvWString::format(SETCOLR L"%s" ENDCOLR, kPlayer.getPlayerTextColorR(), kPlayer.getPlayerTextColorG(), kPlayer.getPlayerTextColorB(), kPlayer.getPlayerTextColorA(), kPlayer.getCivilizationDescription()));
					}
					else
					{
						szString.append(CvWString::format(SETCOLR L"%s" ENDCOLR, kPlayer.getPlayerTextColorR(), kPlayer.getPlayerTextColorG(), kPlayer.getPlayerTextColorB(), kPlayer.getPlayerTextColorA(), kPlayer.getName()));
					}
				}
			}
		}
	}
}

namespace {
	void addModifierIfValid(CvWStringBuffer& szString, int modifier, const char* const txt)
	{
		if (modifier != 0)
		{
			szString.append(NEWLINE);
			szString.append(gDLL->getText(txt, modifier));
		}
	}

	void addModifierWithInfoIfValid(CvWStringBuffer& szString, int modifier, const char* const txt, const CvInfoBase& info)
	{
		if (modifier != 0)
		{
			szString.append(NEWLINE);
			szString.append(gDLL->getText(txt, modifier, info.getTextKeyWide()));
		}
	}

	void addCombatModifierHint(CvWStringBuffer& szString, int base, int coeff, const char* const txt)
	{
		if (base != 0 && coeff > 0)
		{
			addModifierIfValid(szString, base * coeff, txt);
		}
	}

	typedef  int (CvUnit::* GetCombatModifierFn)(UnitCombatTypes combatType) const;

	void addCombatTypeModifierHints(CvWStringBuffer& szString, const CvUnit* defender, const CvUnit* attacker, GetCombatModifierFn modifierFn, const char* const txt)
	{
		for (int iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
		{
			UnitCombatTypes eUnitCombatType = static_cast<UnitCombatTypes>(iI);
			if (defender->isHasUnitCombat(eUnitCombatType))
			{
				int modifier = (attacker->*(modifierFn))(eUnitCombatType);
				if (modifier != 0)
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText(txt, modifier, GC.getUnitCombatInfo(eUnitCombatType).getTextKeyWide()));
				}
			}
		}
	}

}

// Returns true if help was given...
bool CvGameTextMgr::setCombatPlotHelp(CvWStringBuffer& szString, CvPlot* pPlot, bool bAssassinate)
{
	PROFILE_FUNC();

	if (gDLL->altKey() && (gDLL->getChtLvl() > 0))
	{
		setPlotHelp(szString, pPlot);
		return true;
	}

	//Note that due to the large amount of extra content added to this function (setCombatPlotHelp), this should never be used in any function that needs to be called repeatedly (e.g. hundreds of times) quickly.
	//It is fine for a human player mouse-over (which is what it is used for).

	bool ACO_enabled = getBugOptionBOOL("ACO__Enabled", true, "ACO_ENABLED");
	bool bShift = gDLL->shiftKey();
	int iView = bShift ? 2 : 1;
	if (getBugOptionBOOL("ACO__SwapViews", false, "ACO_SWAP_VIEWS"))
	{
		iView = 3 - iView; //swaps 1 and 2.
	}

	bool bTBView = gDLL->ctrlKey();
	bool bSINView = gDLL->altKey();

	CvWString szTempBuffer2;

	CvUnit* pAttacker;
	CvUnit* pDefender;
	CvWString szTempBuffer;
	CvWString szOffenseOdds;
	CvWString szDefenseOdds;
	int iModifier;

	UnitCombatTypes eUnitCombatType;
	int iI;

	if (gDLL->getInterfaceIFace()->getLengthSelectionList() == 0)
	{
		return false;
	}

	bool bValid = false;

	switch (gDLL->getInterfaceIFace()->getSelectionList()->getDomainType())
	{
	case DOMAIN_SEA:
		bValid = (pPlot->isWater() || gDLL->getInterfaceIFace()->getSelectionList()->canMoveAllTerrain());
		break;

	case DOMAIN_AIR:
		bValid = true;
		break;

	case DOMAIN_LAND:
		bValid = (!pPlot->isWater() || pPlot->isSeaTunnel() || gDLL->getInterfaceIFace()->getSelectionList()->canMoveAllTerrain());
		break;

	case DOMAIN_IMMOBILE:
		break;

	default:
		FAssert(false);
		break;
	}

	if (!bValid)
	{
		return false;
	}

	int iOdds;
	PlayerTypes eAmbushingPlayer = GC.getGame().getActivePlayer();
	CvPlayerAI& kAmbushingPlayer = GET_PLAYER(eAmbushingPlayer);
	CvUnit* pAmbusher = NULL;
	if (eAmbushingPlayer != NO_PLAYER)
	{
		pAmbusher = kAmbushingPlayer.getUnit(kAmbushingPlayer.getAmbushingUnit());
	}
	if (pAmbusher != NULL)
	{
		pAttacker = pAmbusher;
	}
	else
	{
		pAttacker = gDLL->getInterfaceIFace()->getSelectionList()->AI_getBestGroupAttacker(pPlot, false, iOdds, true, false, 0, bAssassinate);
	}

	bool bStealthAttack = false;
	bool bStealthDefense = false;
	bool bIsSamePlot = false;

	if (pAttacker != NULL)
	{

		pDefender = pPlot->getBestDefender(NO_PLAYER, pAttacker->getOwner(), pAttacker, !gDLL->altKey(), NO_TEAM == pAttacker->getDeclareWarMove(pPlot), false, bAssassinate);

		if (pDefender != NULL && pDefender != pAttacker && pDefender->canDefend(pPlot) && pAttacker->canAttack(*pDefender))
		{
			bool bAttackerInvisible = pAttacker->isInvisible(GET_PLAYER(pDefender->getOwner()).getTeam(), false, false);
			if (GC.getGame().isOption(GAMEOPTION_WITHOUT_WARNING))
			{
				if (bAttackerInvisible || bIsSamePlot)
				{
					bStealthAttack = true;
				}
				if (bStealthAttack && bIsSamePlot && !bAttackerInvisible)
				{
					bStealthDefense = true;
				}
			}

			if (pAttacker->getDomainType() != DOMAIN_AIR)
			{
				//TB Combat Mod begin
				CvPlot* aPlot = pAttacker->plot();
#ifdef STRENGTH_IN_NUMBERS
				CvUnit* paFIUnit = pAttacker->getAttackerFirstFrontSupportingUnit();
				CvUnit* paFIIUnit = pAttacker->getAttackerSecondFrontSupportingUnit();
				CvUnit* paSRIUnit = pAttacker->getAttackerFirstShortRangeSupportingUnit();
				CvUnit* paSRIIUnit = pAttacker->getAttackerSecondShortRangeSupportingUnit();
				CvUnit* paMRIUnit = pAttacker->getAttackerFirstMediumRangeSupportingUnit();
				CvUnit* paMRIIUnit = pAttacker->getAttackerSecondMediumRangeSupportingUnit();
				CvUnit* paLRIUnit = pAttacker->getAttackerFirstLongRangeSupportingUnit();
				CvUnit* paLRIIUnit = pAttacker->getAttackerSecondLongRangeSupportingUnit();
				CvUnit* paFLIUnit = pAttacker->getAttackerFirstFlankSupportingUnit();
				CvUnit* paFLIIUnit = pAttacker->getAttackerSecondFlankSupportingUnit();
				CvUnit* pdFIUnit = pDefender->getDefenderFirstFrontSupportingUnit();
				CvUnit* pdFIIUnit = pDefender->getDefenderSecondFrontSupportingUnit();
				CvUnit* pdSRIUnit = pDefender->getDefenderFirstShortRangeSupportingUnit();
				CvUnit* pdSRIIUnit = pDefender->getDefenderSecondShortRangeSupportingUnit();
				CvUnit* pdMRIUnit = pDefender->getDefenderFirstMediumRangeSupportingUnit();
				CvUnit* pdMRIIUnit = pDefender->getDefenderSecondMediumRangeSupportingUnit();
				CvUnit* pdLRIUnit = pDefender->getDefenderFirstLongRangeSupportingUnit();
				CvUnit* pdLRIIUnit = pDefender->getDefenderSecondLongRangeSupportingUnit();
				CvUnit* pdFLIUnit = pDefender->getDefenderFirstFlankSupportingUnit();
				CvUnit* pdFLIIUnit = pDefender->getDefenderSecondFlankSupportingUnit();
#endif // STRENGTH_IN_NUMBERS
				if (!bSINView)
				{
					if (pAttacker->isBreakdownCombat(pPlot))
					{

						CvCity* tCity = pPlot->getPlotCity();
						int iDefenderRepel = pDefender->repelVSOpponentProbTotal(pAttacker);
						int iAttackerUnyielding = pAttacker->unyieldingTotal();

						int AdjustedRepelstep1 = iDefenderRepel - iAttackerUnyielding;
						int AdjustedRepelstep2 = ((AdjustedRepelstep1 > 100) ? 100 : AdjustedRepelstep1);
						int AdjustedRepel = ((AdjustedRepelstep2 < 0) ? 0 : AdjustedRepelstep2);

						int iChance = pAttacker->breakdownChanceTotal();
						int iTrueChance = std::max(5, (iChance - AdjustedRepel));

						int iBombardDefMod = std::max(0, (100 - tCity->getBuildingBombardDefense()));
						int iNormalDamage = pAttacker->breakdownDamageTotal();
						int iTrueDamage = (iNormalDamage * iBombardDefMod) / 100;

						szTempBuffer.Format(SETCOLR L"%s %d%%" ENDCOLR,
							TEXT_COLOR("COLOR_RED"), gDLL->getText("TXT_KEY_COMBAT_BREAKDOWN_EFFECTS").c_str(), iTrueChance, iTrueDamage);
						szString.append(szTempBuffer.GetCString());
						szString.append(NEWLINE);
					}
				}

				if (!bSINView || !(GC.getGame().isOption(GAMEOPTION_STRENGTH_IN_NUMBERS)))
				{
					//TB Combat Mod end
					int iCombatOdds = getCombatOdds(pAttacker, pDefender);

					if (pAttacker->combatLimit(pDefender) >= pDefender->maxHPTotal())
					{
						if (iCombatOdds > 999)
						{
							szTempBuffer = L"&gt; 99.9";
						}
						else if (iCombatOdds < 1)
						{
							szTempBuffer = L"&lt; 0.1";
						}
						else
						{
							szTempBuffer.Format(L"%.1f", ((float)iCombatOdds) / 10.0f);
						}
						/*************************************************************************************************/
						/** ADVANCED COMBAT ODDS					  3/11/09						   PieceOfMind	  */
						/** BEGIN																	   v2.0			 */
						/*************************************************************************************************/
						/* Old Code */
						/*
						szString.append(gDLL->getText("TXT_KEY_COMBAT_PLOT_ODDS", szTempBuffer.GetCString()));
						*/
						/* New Code */
						if ((!ACO_enabled) || (getBugOptionBOOL("ACO__ForceOriginalOdds", false, "ACO_FORCE_ORIGINAL_ODDS")))
						{
							szString.append(gDLL->getText("TXT_KEY_COMBAT_PLOT_ODDS", szTempBuffer.GetCString()));
						}
						/*************************************************************************************************/
						/** ADVANCED COMBAT ODDS					  3/11/09						   PieceOfMind	  */
						/** END																		 v2.0			 */
						/*************************************************************************************************/
					}

					//TB Combat Mods Begin
					int iDefenderDodge = pDefender->dodgeVSOpponentProbTotal(pAttacker);
					int iDefenderPrecision = pDefender->precisionVSOpponentProbTotal(pAttacker);
					int iAttackerDodge = pAttacker->dodgeVSOpponentProbTotal(pDefender);
					int iAttackerPrecision = pAttacker->precisionVSOpponentProbTotal(pDefender);
					int iAttackerHitModifier = iAttackerPrecision - iDefenderDodge;
					int iDefenderHitModifier = iDefenderPrecision - iAttackerDodge;

					int iAttackArmorTotal = pAttacker->armorVSOpponentProbTotal(pDefender);
					int iDefendPunctureTotal = pDefender->punctureVSOpponentProbTotal(pAttacker);
					int iAttackPunctureTotal = pAttacker->punctureVSOpponentProbTotal(pDefender);
					int iDefendArmorTotal = pDefender->armorVSOpponentProbTotal(pAttacker);

					int iUnmodifiedDefenderArmor = (iDefendArmorTotal - iAttackPunctureTotal);
					int iUnmodifiedAttackerArmor = (iAttackArmorTotal - iDefendPunctureTotal);
					int iModifiedDefenderArmorZero = (iUnmodifiedDefenderArmor < 0 ? 0 : iUnmodifiedDefenderArmor);
					int iModifiedAttackerArmorZero = (iUnmodifiedAttackerArmor < 0 ? 0 : iUnmodifiedAttackerArmor);
					int iModifiedDefenderArmor = (iModifiedDefenderArmorZero > 95 ? 95 : iModifiedDefenderArmorZero);
					int iModifiedAttackerArmor = (iModifiedAttackerArmorZero > 95 ? 95 : iModifiedAttackerArmorZero);

					int iDefenderArmor = (100 - iModifiedDefenderArmor);
					int iAttackerArmor = (100 - iModifiedAttackerArmor);

					int iAttackerStrength = pAttacker->currCombatStr(NULL, NULL);
					int iAttackerFirepower = pAttacker->currFirepower(NULL, NULL);
					int iDefenderStrength = std::max(1, pDefender->currCombatStr(pPlot, pAttacker));
					int iDefenderFirepower = std::max(1, pDefender->currFirepower(pPlot, pAttacker));

					FAssert((iAttackerStrength + iDefenderStrength) * (iAttackerFirepower + iDefenderFirepower) > 0);

					int iStrengthFactor = ((iAttackerFirepower + iDefenderFirepower + 1) / 2);

					int iDefendDamageModifierTotal = pDefender->damageModifierTotal();
					int iAttackDamageModifierTotal = pAttacker->damageModifierTotal();

					int iDamageToAttackerBase = ((GC.getCOMBAT_DAMAGE() * (iDefenderFirepower + iStrengthFactor)) / std::max(1, (iAttackerFirepower + iStrengthFactor)));
					int iDamageToDefenderBase = ((GC.getCOMBAT_DAMAGE() * (iAttackerFirepower + iStrengthFactor)) / std::max(1, (iDefenderFirepower + iStrengthFactor)));
					int iDamageToAttackerModified = iDamageToAttackerBase + ((iDamageToAttackerBase * iDefendDamageModifierTotal) / 100);
					int iDamageToDefenderModified = iDamageToDefenderBase + ((iDamageToDefenderBase * iAttackDamageModifierTotal) / 100);
					int iDamageToAttackerArmor = (iDamageToAttackerModified * iAttackerArmor) / 100;
					int iDamageToDefenderArmor = (iDamageToDefenderModified * iDefenderArmor) / 100;
					int iDamageToAttacker = std::max(1, iDamageToAttackerArmor);
					int iDamageToDefender = std::max(1, iDamageToDefenderArmor);
					int iNeededRoundsAttacker = (pDefender->currHitPoints() - pDefender->maxHitPoints() + pAttacker->combatLimit(pDefender) - (((pAttacker->combatLimit(pDefender)) >= pDefender->maxHitPoints()) ? 1 : 0)) / iDamageToDefender + 1;

					int iAttackerBaseCriticalChance = pAttacker->criticalVSOpponentProbTotal(pDefender);
					int iDefenderBaseCriticalChance = pDefender->criticalVSOpponentProbTotal(pAttacker);
					int iAttackerCriticalChance = (((iDamageToDefender * 100) * iAttackerBaseCriticalChance) / 100);
					int iDefenderCriticalChance = (((iDamageToDefender * 100) * iAttackerBaseCriticalChance) / 100);
					int iAttackerEndurance = pAttacker->enduranceTotal();
					int iDefenderEndurance = pDefender->enduranceTotal();

					int iNeededRoundsDefender = (pAttacker->currHitPoints() + iDamageToAttacker - 1) / iDamageToAttacker;

					//  Determine Attack Withdraw odds
					int iAttackerWithdraw = pAttacker->withdrawVSOpponentProbTotal(pDefender, pPlot);
					int iDefenderPursuit = pDefender->pursuitVSOpponentProbTotal(pAttacker);
					int iAttackerEarly = pAttacker->earlyWithdrawTotal();
					int AdjustedAttWithdrawalstep1 = iAttackerWithdraw - iDefenderPursuit;
					int AdjustedAttWithdrawalstep2 = ((AdjustedAttWithdrawalstep1 > 100) ? 100 : AdjustedAttWithdrawalstep1);
					int AdjustedAttWithdrawal = ((AdjustedAttWithdrawalstep2 < 0) ? 0 : AdjustedAttWithdrawalstep2);

					int expectedrndcnt = iNeededRoundsDefender;
					int expectedrnds = ((expectedrndcnt * iAttackerEarly) / 100);

					int y = AdjustedAttWithdrawal;
					int z = AdjustedAttWithdrawal;
					int Time;
					for (Time = 0; Time < expectedrnds; ++Time)
					{
						z += ((AdjustedAttWithdrawal * y) / 100);
						y = ((AdjustedAttWithdrawal * y) / 100);
					}

					int EvaluatedAttWithdrawOdds = z;

					//  Determine Attack Knockback odds
					int iAttackerKnockback = pAttacker->knockbackVSOpponentProbTotal(pDefender);
					int iDefenderUnyielding = pDefender->unyieldingTotal();
					int iAttackerKnockbackTries = pAttacker->knockbackRetriesTotal() + 1;

					int AdjustedKnockbackstep1 = iAttackerKnockback - iDefenderUnyielding;
					int AdjustedKnockbackstep2 = ((AdjustedKnockbackstep1 > 100) ? 100 : AdjustedKnockbackstep1);
					int AdjustedKnockback = ((AdjustedKnockbackstep2 < 0) ? 0 : AdjustedKnockbackstep2);

					y = AdjustedKnockback;
					z = AdjustedKnockback;

					for (Time = 0; Time < iAttackerKnockbackTries; ++Time)
					{
						z += ((AdjustedKnockback * y) / 100);
						y = ((AdjustedKnockback * y) / 100);
					}

					int EvaluatedKnockbackOdds = z;

					//  Determine Defensive Withdrawal odds
					int iDefenderWithdraw = pDefender->withdrawVSOpponentProbTotal(pAttacker, pPlot);
					int iAttackerPursuit = pAttacker->pursuitVSOpponentProbTotal(pDefender);
					int iDefenderEarly = pDefender->earlyWithdrawTotal();
					int AdjustedDefWithdrawalstep1 = iDefenderWithdraw - iAttackerPursuit;
					int AdjustedDefWithdrawalstep2 = ((AdjustedDefWithdrawalstep1 > 100) ? 100 : AdjustedDefWithdrawalstep1);
					int AdjustedDefWithdrawal = ((AdjustedDefWithdrawalstep2 < 0) ? 0 : AdjustedDefWithdrawalstep2);

					expectedrndcnt = iNeededRoundsAttacker;
					expectedrnds = ((expectedrndcnt * iDefenderEarly) / 100);

					y = AdjustedDefWithdrawal;
					z = AdjustedDefWithdrawal;

					for (Time = 0; Time < expectedrnds; ++Time)
					{
						z += ((AdjustedDefWithdrawal * y) / 100);
						y = ((AdjustedDefWithdrawal * y) / 100);
					}

					int EvaluatedDefWithdrawalOdds = z;

					// Fortify, Repel Odds
					int iDefenderFortifyTotal = pDefender->fortifyModifier();
					int iDefenderRepel = pDefender->repelVSOpponentProbTotal(pAttacker);
					int iDefenderFortRepel = pDefender->fortifyRepelModifier();
					int iRepelAttempts = (pDefender->repelRetriesTotal() + 1);
					int iAttackerOverrun = pAttacker->overrunTotal();
					int iAttackerUnyielding = pAttacker->unyieldingTotal();
					int iFortRepellessOverrun = iDefenderFortRepel - iAttackerOverrun;
					int iFortRepelZero = (iFortRepellessOverrun < 0 ? 0 : iFortRepellessOverrun);
					int iFortRepelTotal = (iFortRepelZero > 100 ? 100 : iFortRepelZero);
					int iDefenderRepelwithFortRepel = iDefenderRepel + iFortRepelTotal;
					int iRepelwithUnyielding = iDefenderRepelwithFortRepel - iAttackerUnyielding;
					int iRepelZero = (iRepelwithUnyielding < 0 ? 0 : iRepelwithUnyielding);
					int iRepelTotal = (iRepelZero > 100 ? 100 : iRepelZero);
					int iFortifylessOverrun = iDefenderFortifyTotal - iAttackerOverrun;
					int iFortifyTotal = (iFortifylessOverrun < 0 ? 0 : iFortifylessOverrun);

					y = iRepelTotal;
					z = iRepelTotal;

					for (Time = 0; Time < iRepelAttempts; ++Time)
					{
						z += ((iRepelTotal * y) / 100);
						y = ((iRepelTotal * y) / 100);
					}

					int EvaluatedRepelOdds = z;

					int iWithdrawal = 0;
					// TB Combat Mod for combat limit withdrawal odds:
					if (pAttacker->combatLimit(pDefender) < pDefender->maxHitPoints())
					{
						iWithdrawal += (100 - iDefenderPursuit) * iCombatOdds;
					}
					// TB Combat Mod next line adjusted for approximate pursuit and early withdrawal

					iWithdrawal += std::min(100, EvaluatedAttWithdrawOdds) * (1000 - iCombatOdds);

					if (iWithdrawal > 0 || pAttacker->combatLimit(pDefender) < pDefender->maxHitPoints())
					{
						if (iWithdrawal > 99900)
						{
							szTempBuffer = L"&gt; 99.9";
						}
						else if (iWithdrawal < 100)
						{
							szTempBuffer = L"&lt; 0.1";
						}
						else
						{
							szTempBuffer.Format(L"%.1f", iWithdrawal / 1000.0f);
						}

						/*************************************************************************************************/
						/** ADVANCED COMBAT ODDS					  3/11/09						   PieceOfMind	  */
						/** BEGIN																	   v2.0			 */
						/*************************************************************************************************/
						/* Old Code */
						/*
											szString.append(NEWLINE);
											szString.append(gDLL->getText("TXT_KEY_COMBAT_PLOT_ODDS_RETREAT", szTempBuffer.GetCString()));
						*/
						/* New Code */
						szString.append(NEWLINE);
						szString.append(gDLL->getText("TXT_KEY_COMBAT_PLOT_ODDS_RETREAT", szTempBuffer.GetCString()));
						//if (ACO_enabled)
						//{
						//szString.append(NEWLINE);
						//}
/*************************************************************************************************/
/** ADVANCED COMBAT ODDS					  3/11/09						   PieceOfMind	  */
/** END																		 v2.0			 */
/*************************************************************************************************/
					}

					int iDefWithdrawal = 0;
					iDefWithdrawal += std::min(100, EvaluatedDefWithdrawalOdds) * (1000 - iCombatOdds);

					if (iDefWithdrawal > 0 && GC.getGame().isModderGameOption(MODDERGAMEOPTION_DEFENDER_WITHDRAW))
					{
						if (iDefWithdrawal > 99900)
						{
							szTempBuffer = L"&gt; 99.9";
						}
						else if (iDefWithdrawal < 100)
						{
							szTempBuffer = L"&lt; 0.1";
						}
						else
						{
							szTempBuffer.Format(L"%.1f", iDefWithdrawal / 1000.0f);
						}
						szString.append(NEWLINE);
						szString.append(gDLL->getText("TXT_KEY_COMBAT_PLOT_ODDS_DEFENDER_RETREAT", szTempBuffer.GetCString()));
					}

					int iRepelOdds = 0;
					iRepelOdds += std::min(100, EvaluatedRepelOdds) * (1000 - iCombatOdds);

					if (iRepelOdds > 0)
					{
						if (iRepelOdds > 99900)
						{
							szTempBuffer = L"&gt; 99.9";
						}
						else if (iRepelOdds < 100)
						{
							szTempBuffer = L"&lt; 0.1";
						}
						else
						{
							szTempBuffer.Format(L"%.1f", iRepelOdds / 1000.0f);
						}
						szString.append(NEWLINE);
						szString.append(gDLL->getText("TXT_KEY_COMBAT_PLOT_ODDS_REPEL", szTempBuffer.GetCString()));
					}

					int iKnockbackOdds = 0;
					iKnockbackOdds += std::min(100, EvaluatedKnockbackOdds) * (1000 - iCombatOdds);

					if (iKnockbackOdds > 0)
					{
						if (iKnockbackOdds > 99900)
						{
							szTempBuffer = L"&gt; 99.9";
						}
						else if (iKnockbackOdds < 100)
						{
							szTempBuffer = L"&lt; 0.1";
						}
						else
						{
							szTempBuffer.Format(L"%.1f", iKnockbackOdds / 1000.0f);
						}
						szString.append(NEWLINE);
						szString.append(gDLL->getText("TXT_KEY_COMBAT_PLOT_ODDS_KNOCKBACK", szTempBuffer.GetCString()));

					}
					szString.append(NEWLINE);

					//TB Display Mod Begin
					if (bTBView)
					{
						//TB Combat Mods (Armor Compare)
						//Defender's dodge is better than attacker's precision
						if (iAttackerHitModifier < 0)
						{
							if (iAttackerPrecision != 0)
							{
								szTempBuffer.Format(SETCOLR L"%s %d%%" ENDCOLR,
									TEXT_COLOR("COLOR_RED"), gDLL->getText("TXT_KEY_COMBAT_ARMOR_COMPARE_ATTACKER_PRECISION").c_str(), iAttackerPrecision);
								szString.append(NEWLINE);
								szString.append(szTempBuffer.GetCString());
							}
							if (iDefenderDodge != 0)
							{
								szTempBuffer.Format(SETCOLR L"- %s %d%%" ENDCOLR,
									TEXT_COLOR("COLOR_RED"), gDLL->getText("TXT_KEY_COMBAT_ARMOR_COMPARE_DEFENDER_DODGE").c_str(), iDefenderDodge);
								szString.append(NEWLINE);
								szString.append(szTempBuffer.GetCString());
							}
							szTempBuffer.Format(SETCOLR L"= %s %d%%" ENDCOLR,
								TEXT_COLOR("COLOR_RED"), gDLL->getText("TXT_KEY_COMBAT_ARMOR_COMPARE_ATTACKER_HIT_MODIFIER").c_str(), iAttackerHitModifier);
							szString.append(NEWLINE);
							szString.append(szTempBuffer.GetCString());
						}
						//Attacker's precision is higher than defender's dodge
						if (iAttackerHitModifier > 0)
						{
							if (iAttackerPrecision != 0)
							{
								szTempBuffer.Format(SETCOLR L"%s %d%%" ENDCOLR,
									TEXT_COLOR("COLOR_GREEN"), gDLL->getText("TXT_KEY_COMBAT_ARMOR_COMPARE_ATTACKER_PRECISION").c_str(), iAttackerPrecision);
								szString.append(NEWLINE);
								szString.append(szTempBuffer.GetCString());
							}
							if (iDefenderDodge != 0)
							{
								szTempBuffer.Format(SETCOLR L"- %s %d%%" ENDCOLR,
									TEXT_COLOR("COLOR_GREEN"), gDLL->getText("TXT_KEY_COMBAT_ARMOR_COMPARE_DEFENDER_DODGE").c_str(), iDefenderDodge);
								szString.append(NEWLINE);
								szString.append(szTempBuffer.GetCString());
							}
							szTempBuffer.Format(SETCOLR L"= +%s %d%%" ENDCOLR,
								TEXT_COLOR("COLOR_GREEN"), gDLL->getText("TXT_KEY_COMBAT_ARMOR_COMPARE_ATTACKER_HIT_MODIFIER").c_str(), iAttackerHitModifier);
							szString.append(NEWLINE);
							szString.append(szTempBuffer.GetCString());
						}
						//Defender's precision is higher than attacker's dodge
						if (iDefenderHitModifier > 0)
						{
							if (iDefenderPrecision != 0)
							{
								szTempBuffer.Format(SETCOLR L"%s %d%%" ENDCOLR,
									TEXT_COLOR("COLOR_RED"), gDLL->getText("TXT_KEY_COMBAT_ARMOR_COMPARE_DEFENDER_PRECISION").c_str(), iDefenderPrecision);
								szString.append(NEWLINE);
								szString.append(szTempBuffer.GetCString());
							}
							if (iAttackerDodge != 0)
							{
								szTempBuffer.Format(SETCOLR L"- %s %d%%" ENDCOLR,
									TEXT_COLOR("COLOR_RED"), gDLL->getText("TXT_KEY_COMBAT_ARMOR_COMPARE_ATTACKER_DODGE").c_str(), iAttackerDodge);
								szString.append(NEWLINE);
								szString.append(szTempBuffer.GetCString());
							}
							szTempBuffer.Format(SETCOLR L"= +%s %d%%" ENDCOLR,
								TEXT_COLOR("COLOR_RED"), gDLL->getText("TXT_KEY_COMBAT_ARMOR_COMPARE_DEFENDER_HIT_MODIFIER").c_str(), iDefenderHitModifier);
							szString.append(NEWLINE);
							szString.append(szTempBuffer.GetCString());
						}
						//Defender's precision is lower than attacker's dodge
						if (iDefenderHitModifier < 0)
						{
							if (iDefenderPrecision != 0)
							{
								szTempBuffer.Format(SETCOLR L"%s %d%%" ENDCOLR,
									TEXT_COLOR("COLOR_GREEN"), gDLL->getText("TXT_KEY_COMBAT_ARMOR_COMPARE_DEFENDER_PRECISION").c_str(), iDefenderPrecision);
								szString.append(NEWLINE);
								szString.append(szTempBuffer.GetCString());
							}
							if (iAttackerDodge != 0)
							{
								szTempBuffer.Format(SETCOLR L"- %s %d%%" ENDCOLR,
									TEXT_COLOR("COLOR_GREEN"), gDLL->getText("TXT_KEY_COMBAT_ARMOR_COMPARE_ATTACKER_DODGE").c_str(), iAttackerDodge);
								szString.append(NEWLINE);
								szString.append(szTempBuffer.GetCString());
							}
							szTempBuffer.Format(SETCOLR L"= -%s %d%%" ENDCOLR,
								TEXT_COLOR("COLOR_GREEN"), gDLL->getText("TXT_KEY_COMBAT_ARMOR_COMPARE_DEFENDER_HIT_MODIFIER").c_str(), iDefenderHitModifier);
							szString.append(NEWLINE);
							szString.append(szTempBuffer.GetCString());
						}

						if (iModifiedAttackerArmor > 0)
						{
							szTempBuffer.Format(SETCOLR L"%s %d%%" ENDCOLR,
								TEXT_COLOR("COLOR_GREEN"), gDLL->getText("TXT_KEY_COMBAT_ARMOR_COMPARE_ATTACKER_ARMOR").c_str(), iAttackArmorTotal);
							szString.append(NEWLINE);
							szString.append(szTempBuffer.GetCString());
							if (iDefendPunctureTotal > 0)
							{
								szTempBuffer.Format(SETCOLR L"%s %d" ENDCOLR,
									TEXT_COLOR("COLOR_GREEN"), gDLL->getText("TXT_KEY_COMBAT_ARMOR_COMPARE_DEFENDER_PUNCTURE").c_str(), iDefendPunctureTotal);
								szString.append(NEWLINE);
								szString.append(szTempBuffer.GetCString());
								szTempBuffer.Format(SETCOLR L"%s %d%%" ENDCOLR,
									TEXT_COLOR("COLOR_GREEN"), gDLL->getText("TXT_KEY_COMBAT_ARMOR_COMPARE_TOTAL_ATTACKER_ARMOR").c_str(), iModifiedAttackerArmor);
								szString.append(NEWLINE);
								szString.append(szTempBuffer.GetCString());
							}
						}

						if (iModifiedDefenderArmor > 0)
						{
							szTempBuffer.Format(SETCOLR L"%s %d%%" ENDCOLR,
								TEXT_COLOR("COLOR_RED"), gDLL->getText("TXT_KEY_COMBAT_ARMOR_COMPARE_DEFENDER_ARMOR").c_str(), iDefendArmorTotal);
							szString.append(NEWLINE);
							szString.append(szTempBuffer.GetCString());
							if (iAttackPunctureTotal > 0)
							{
								szTempBuffer.Format(SETCOLR L"%s %d" ENDCOLR,
									TEXT_COLOR("COLOR_RED"), gDLL->getText("TXT_KEY_COMBAT_ARMOR_COMPARE_ATTACKER_PUNCTURE").c_str(), iAttackPunctureTotal);
								szString.append(NEWLINE);
								szString.append(szTempBuffer.GetCString());
								szTempBuffer.Format(SETCOLR L"%s %d%%" ENDCOLR,
									TEXT_COLOR("COLOR_RED"), gDLL->getText("TXT_KEY_COMBAT_ARMOR_COMPARE_TOTAL_DEFENDER_ARMOR").c_str(), iModifiedDefenderArmor);
								szString.append(NEWLINE);
								szString.append(szTempBuffer.GetCString());
							}
						}

						if (iAttackDamageModifierTotal > 0)
						{
							szTempBuffer.Format(SETCOLR L"%s" ENDCOLR,
								TEXT_COLOR("COLOR_GREEN"), gDLL->getText("TXT_KEY_COMBAT_ATTACKER_DAMAGE_MODIFIER").c_str(), iAttackDamageModifierTotal);
							szString.append(NEWLINE);
							szString.append(szTempBuffer.GetCString());
						}

						if (iAttackDamageModifierTotal < 0)
						{
							szTempBuffer.Format(SETCOLR L"%s" ENDCOLR,
								TEXT_COLOR("COLOR_RED"), gDLL->getText("TXT_KEY_COMBAT_ATTACKER_DAMAGE_MODIFIER").c_str(), iAttackDamageModifierTotal);
							szString.append(NEWLINE);
							szString.append(szTempBuffer.GetCString());
						}

						if (iDefendDamageModifierTotal > 0)
						{
							szTempBuffer.Format(SETCOLR L"%s" ENDCOLR,
								TEXT_COLOR("COLOR_RED"), gDLL->getText("TXT_KEY_COMBAT_DEFENDER_DAMAGE_MODIFIER").c_str(), iDefendDamageModifierTotal);
							szString.append(NEWLINE);
							szString.append(szTempBuffer.GetCString());
						}

						if (iDefendDamageModifierTotal < 0)
						{
							szTempBuffer.Format(SETCOLR L"%s" ENDCOLR,
								TEXT_COLOR("COLOR_GREEN"), gDLL->getText("TXT_KEY_COMBAT_DEFENDER_DAMAGE_MODIFIER").c_str(), iDefendDamageModifierTotal);
							szString.append(NEWLINE);
							szString.append(szTempBuffer.GetCString());
						}
						//TB Combat Mods Withdraw odds

						if (EvaluatedAttWithdrawOdds > 0)
						{
							szTempBuffer.Format(SETCOLR L"%s %d%%" ENDCOLR,
								TEXT_COLOR("COLOR_GREEN"), gDLL->getText("TXT_KEY_COMBAT_WITHDRAW_ODDS_ATTACKER_WITHDRAWAL").c_str(), iAttackerWithdraw);
							szString.append(NEWLINE);
							szString.append(szTempBuffer.GetCString());

							if (pAttacker->currentWithdrawAdjperAttTotal() > 0)
							{
								szTempBuffer.Format(SETCOLR L"(%s +%d%%)" ENDCOLR,
									TEXT_COLOR("COLOR_GREEN"), gDLL->getText("TXT_KEY_COMBAT_WITHDRAW_ODDS_ATTACKER_REFLEXES").c_str(), pAttacker->currentWithdrawAdjperAttTotal());
								szString.append(NEWLINE);
								szString.append(szTempBuffer.GetCString());
							}

							if (pAttacker->currentWithdrawAdjperAttTotal() < 0)
							{
								szTempBuffer.Format(SETCOLR L"(%s -%d%%)" ENDCOLR,
									TEXT_COLOR("COLOR_RED"), gDLL->getText("TXT_KEY_COMBAT_WITHDRAW_ODDS_ATTACKER_FRAYED").c_str(), pAttacker->currentWithdrawAdjperAttTotal());
								szString.append(NEWLINE);
								szString.append(szTempBuffer.GetCString());
							}

							if (iDefenderPursuit > 0)
							{
								szTempBuffer.Format(SETCOLR L"%s -%d%%" ENDCOLR,
									TEXT_COLOR("COLOR_RED"), gDLL->getText("TXT_KEY_COMBAT_WITHDRAW_ODDS_DEFENDER_PURSUIT").c_str(), iDefenderPursuit);
								szString.append(NEWLINE);
								szString.append(szTempBuffer.GetCString());
								szTempBuffer.Format(SETCOLR L"%s %d%%" ENDCOLR,
									TEXT_COLOR("COLOR_GREEN"), gDLL->getText("TXT_KEY_COMBAT_WITHDRAW_ODDS_PER_ROUND_ATTEMPTED").c_str(), AdjustedAttWithdrawal);
								szString.append(NEWLINE);
								szString.append(szTempBuffer.GetCString());
							}
							if (iAttackerEarly > 0)
							{
								szTempBuffer.Format(SETCOLR L"%s %d%%" ENDCOLR,
									TEXT_COLOR("COLOR_GREEN"), gDLL->getText("TXT_KEY_COMBAT_WITHDRAW_ODDS_ATTACKER_EARLY_WITHDRAW").c_str(), iAttackerEarly);
								szString.append(NEWLINE);
								szString.append(szTempBuffer.GetCString());
							}
						}

						if (EvaluatedDefWithdrawalOdds > 0 && (GC.getGame().isModderGameOption(MODDERGAMEOPTION_DEFENDER_WITHDRAW)))
						{
							szTempBuffer.Format(SETCOLR L"%s %d%%" ENDCOLR,
								TEXT_COLOR("COLOR_RED"), gDLL->getText("TXT_KEY_COMBAT_WITHDRAW_ODDS_DEFENDER_WITHDRAWAL").c_str(), iDefenderWithdraw);
							szString.append(NEWLINE);
							szString.append(szTempBuffer.GetCString());
							if (iAttackerPursuit > 0)
							{
								szTempBuffer.Format(SETCOLR L"%s %d" ENDCOLR,
									TEXT_COLOR("COLOR_GREEN"), gDLL->getText("TXT_KEY_COMBAT_WITHDRAW_ODDS_ATTACKER_PURSUIT").c_str(), iAttackerPursuit);
								szString.append(NEWLINE);
								szString.append(szTempBuffer.GetCString());
								szTempBuffer.Format(SETCOLR L"%s %d%%" ENDCOLR,
									TEXT_COLOR("COLOR_RED"), gDLL->getText("TXT_KEY_COMBAT_WITHDRAW_ODDS_WITHDRAW_PER_ROUND").c_str(), AdjustedDefWithdrawal);
								szString.append(NEWLINE);
								szString.append(szTempBuffer.GetCString());
							}
							if (iDefenderEarly > 0)
							{
								szTempBuffer.Format(SETCOLR L"%s %d%" ENDCOLR,
									TEXT_COLOR("COLOR_RED"), gDLL->getText("TXT_KEY_COMBAT_WITHDRAW_ODDS_DEFENDER_EARLY_WITHDRAW").c_str(), iDefenderEarly);
								szString.append(NEWLINE);
								szString.append(szTempBuffer.GetCString());
							}
						}
						//TB Combat Mods (Fortification Compare)

						if (iDefenderFortifyTotal > 0)
						{
							szTempBuffer.Format(SETCOLR L"%s %d%%" ENDCOLR,
								TEXT_COLOR("COLOR_RED"), gDLL->getText("TXT_KEY_COMBAT_FORTIFICATION_COMPARE_DEFENDER_FORTIFICATION").c_str(), iDefenderFortifyTotal);
							szString.append(NEWLINE);
							szString.append(szTempBuffer.GetCString());

							if (iDefenderFortRepel > 0)
							{
								szTempBuffer.Format(SETCOLR L"%s %d%" ENDCOLR,
									TEXT_COLOR("COLOR_RED"), gDLL->getText("TXT_KEY_COMBAT_FORTIFICATION_COMPARE_FORTIFIED_REPEL").c_str(), iDefenderFortRepel);
								szString.append(NEWLINE);
								szString.append(szTempBuffer.GetCString());
							}

							if (iAttackerOverrun > 0)
							{
								szTempBuffer.Format(SETCOLR L"%s %d%" ENDCOLR,
									TEXT_COLOR("COLOR_GREEN"), gDLL->getText("TXT_KEY_COMBAT_FORTIFICATION_COMPARE_ATTACKER_OVERRUN").c_str(), iAttackerOverrun);
								szString.append(NEWLINE);
								szString.append(szTempBuffer.GetCString());
							}
						}
						if (iDefenderRepel > 0)
						{
							szTempBuffer.Format(SETCOLR L"%s %d%" ENDCOLR,
								TEXT_COLOR("COLOR_RED"), gDLL->getText("TXT_KEY_COMBAT_FORTIFICATION_COMPARE_DEFENDER_REPEL").c_str(), iDefenderRepel);
							szString.append(NEWLINE);
							szString.append(szTempBuffer.GetCString());
							if (iAttackerUnyielding > 0)
							{
								szTempBuffer.Format(SETCOLR L"%s %d" ENDCOLR,
									TEXT_COLOR("COLOR_GREEN"), gDLL->getText("TXT_KEY_COMBAT_FORTIFICATION_COMPARE_ATTACKER_UNYIELDING").c_str(), iAttackerUnyielding);
								szString.append(NEWLINE);
								szString.append(szTempBuffer.GetCString());
								szTempBuffer.Format(SETCOLR L"%s %d%" ENDCOLR,
									TEXT_COLOR("COLOR_RED"), gDLL->getText("TXT_KEY_COMBAT_FORTIFICATION_COMPARE_TOTAL_REPEL").c_str(), iRepelTotal);
								szString.append(NEWLINE);
								szString.append(szTempBuffer.GetCString());
							}
						}
						if ((iFortifyTotal) > 0 && (iAttackerOverrun > 0))
						{
							szTempBuffer.Format(SETCOLR L"%s %d%" ENDCOLR,
								TEXT_COLOR("COLOR_RED"), gDLL->getText("TXT_KEY_COMBAT_FORTIFICATION_COMPARE_TOTAL_FORTIFICATION").c_str(), iFortifyTotal);
							szString.append(NEWLINE);
							szString.append(szTempBuffer.GetCString());
						}

						//TB Combat Odds Knockback
						if (iAttackerKnockback > 0)
						{
							szTempBuffer.Format(SETCOLR L"%s %d%" ENDCOLR,
								TEXT_COLOR("COLOR_GREEN"), gDLL->getText("TXT_KEY_COMBAT_KNOCKBACK_ATTACKER_KNOCKBACK").c_str(), iAttackerKnockback);
							szString.append(NEWLINE);
							szString.append(szTempBuffer.GetCString());
							if (iDefenderUnyielding > 0)
							{
								szTempBuffer.Format(SETCOLR L"%s %d" ENDCOLR,
									TEXT_COLOR("COLOR_RED"), gDLL->getText("TXT_KEY_COMBAT_KNOCKBACK_DEFENDER_UNYIELDING").c_str(), iDefenderUnyielding);
								szString.append(NEWLINE);
								szString.append(szTempBuffer.GetCString());
								szTempBuffer.Format(SETCOLR L"%s %d%" ENDCOLR,
									TEXT_COLOR("COLOR_GREEN"), gDLL->getText("TXT_KEY_COMBAT_KNOCKBACK_TOTAL_KNOCKBACK").c_str(), AdjustedKnockback);
								szString.append(NEWLINE);
								szString.append(szTempBuffer.GetCString());
							}
						}

						//TB Combat Odds Round Stuns
						int iAttackerRoundStunProb = pAttacker->roundStunProbTotal();
						int iAttackerTotalAfterVS = pAttacker->roundStunVSOpponentProbTotal(pDefender);
						int iAttackerVSCombatClass = iAttackerTotalAfterVS - iAttackerRoundStunProb;
						int iElectricalMod = 0;
						if (iAttackerRoundStunProb > 0 /*|| bAttackerDealsElectricalDamage*/)
						{
							szTempBuffer.Format(SETCOLR L"%s" ENDCOLR,
								TEXT_COLOR("COLOR_BLUE"), gDLL->getText("TXT_KEY_COMBAT_ROUND_STUN_START").c_str());
							szString.append(NEWLINE);
							szString.append(szTempBuffer.GetCString());
							szTempBuffer.Format(SETCOLR L"%s %d%" ENDCOLR,
								TEXT_COLOR("COLOR_GREEN"), gDLL->getText("TXT_KEY_COMBAT_ROUND_STUN_TOTAL_ATTACKER_ROUND_STUN").c_str(), iAttackerRoundStunProb);
							szString.append(NEWLINE);
							szString.append(szTempBuffer.GetCString());
							if (iAttackerVSCombatClass != 0)
							{
								szTempBuffer.Format(SETCOLR L"%s %d" ENDCOLR,
									TEXT_COLOR("COLOR_GREEN"), gDLL->getText("TXT_KEY_COMBAT_ROUND_STUN_VS_DEFENDER_COMBAT_CLASS").c_str(), iAttackerVSCombatClass);
								szString.append(NEWLINE);
								szString.append(szTempBuffer.GetCString());
							}
							if (iAttackerCriticalChance != 0)
							{
								szTempBuffer.Format(SETCOLR L"%s %d%" ENDCOLR,
									TEXT_COLOR("COLOR_GREEN"), gDLL->getText("TXT_KEY_COMBAT_ROUND_STUN_PLUS_CRITICAL").c_str(), iAttackerCriticalChance);
								szString.append(NEWLINE);
								szString.append(szTempBuffer.GetCString());
							}
							//if (bAttackerDealsElectricalDamage)
							//{
							//iElectricalMod = 100;
							//szTempBuffer.Format(SETCOLR L"%s %d%" ENDCOLR,
							//				TEXT_COLOR("COLOR_GREEN"), gDLL->getText("TXT_KEY_COMBAT_ROUND_STUN_PLUS_ELECTRICAL").c_str(), iElectricalMod);
							//szString.append(NEWLINE);
						//	szString.append(szTempBuffer.GetCString());
							//}
							int iDefenderEnduranceModifier = iDefenderEndurance * 10;
							if (iDefenderEndurance != 0)
							{
								szTempBuffer.Format(SETCOLR L"%s %d%" ENDCOLR,
									TEXT_COLOR("COLOR_RED"), gDLL->getText("TXT_KEY_COMBAT_ROUND_STUN_ATTACKER_MINUS_DEFENDER_ENDURANCE").c_str(), iDefenderEnduranceModifier);
								szString.append(NEWLINE);
								szString.append(szTempBuffer.GetCString());
							}
							int iAttackerRoundStunTotal = iAttackerTotalAfterVS + iAttackerCriticalChance + iElectricalMod - iDefenderEnduranceModifier;
							szTempBuffer.Format(SETCOLR L"%s %d%" ENDCOLR,
								TEXT_COLOR("COLOR_RED"), gDLL->getText("TXT_KEY_COMBAT_ROUND_STUN_ATTACKER_GRAND_TOTAL").c_str(), iAttackerRoundStunTotal);
							szString.append(NEWLINE);
							szString.append(szTempBuffer.GetCString());
						}

						int iDefenderRoundStunProb = pDefender->roundStunProbTotal();
						int iDefenderTotalAfterVS = pDefender->roundStunVSOpponentProbTotal(pAttacker);
						int iDefenderVSCombatClass = iDefenderTotalAfterVS - iDefenderRoundStunProb;
						iElectricalMod = 0;
						if (iDefenderRoundStunProb > 0 /*|| bAttackerDealsElectricalDamage*/)
						{
							szTempBuffer.Format(SETCOLR L"%s" ENDCOLR,
								TEXT_COLOR("COLOR_BLUE"), gDLL->getText("TXT_KEY_COMBAT_ROUND_STUN_START").c_str());
							szString.append(NEWLINE);
							szString.append(szTempBuffer.GetCString());
							szTempBuffer.Format(SETCOLR L"%s %d%" ENDCOLR,
								TEXT_COLOR("COLOR_RED"), gDLL->getText("TXT_KEY_COMBAT_ROUND_STUN_TOTAL_DEFENDER_ROUND_STUN").c_str(), iDefenderRoundStunProb);
							szString.append(NEWLINE);
							szString.append(szTempBuffer.GetCString());
							if (iDefenderVSCombatClass != 0)
							{
								szTempBuffer.Format(SETCOLR L"%s %d" ENDCOLR,
									TEXT_COLOR("COLOR_RED"), gDLL->getText("TXT_KEY_COMBAT_ROUND_STUN_VS_ATTACKER_COMBAT_CLASS").c_str(), iDefenderVSCombatClass);
								szString.append(NEWLINE);
								szString.append(szTempBuffer.GetCString());
							}
							if (iDefenderCriticalChance != 0)
							{
								szTempBuffer.Format(SETCOLR L"%s %d%" ENDCOLR,
									TEXT_COLOR("COLOR_RED"), gDLL->getText("TXT_KEY_COMBAT_ROUND_STUN_PLUS_CRITICAL").c_str(), iDefenderCriticalChance);
								szString.append(NEWLINE);
								szString.append(szTempBuffer.GetCString());
							}
							//if (bDefenderDealsElectricalDamage)
							//{
							//iElectricalMod = 100;
							//szTempBuffer.Format(SETCOLR L"%s %d%" ENDCOLR,
							//				TEXT_COLOR("COLOR_RED"), gDLL->getText("TXT_KEY_COMBAT_ROUND_STUN_PLUS_ELECTRICAL").c_str(), iElectricalMod);
							//szString.append(NEWLINE);
						//	szString.append(szTempBuffer.GetCString());
							//}
							int iAttackerEnduranceModifier = iAttackerEndurance * 10;
							if (iAttackerEndurance != 0)
							{
								szTempBuffer.Format(SETCOLR L"%s %d%" ENDCOLR,
									TEXT_COLOR("COLOR_GREEN"), gDLL->getText("TXT_KEY_COMBAT_ROUND_STUN_DEFENDER_MINUS_ATTACKER_ENDURANCE").c_str(), iAttackerEnduranceModifier);
								szString.append(NEWLINE);
								szString.append(szTempBuffer.GetCString());
							}
							int iDefenderRoundStunTotal = iDefenderTotalAfterVS + iDefenderCriticalChance + iElectricalMod - iAttackerEnduranceModifier;
							szTempBuffer.Format(SETCOLR L"%s %d%" ENDCOLR,
								TEXT_COLOR("COLOR_RED"), gDLL->getText("TXT_KEY_COMBAT_ROUND_STUN_DEFENDER_GRAND_TOTAL").c_str(), iDefenderRoundStunTotal);
							szString.append(NEWLINE);
							szString.append(szTempBuffer.GetCString());
						}


						if (pAttacker->strAdjperRndTotal() > 0)
						{
							szTempBuffer.Format(SETCOLR L"%s +%d%%" ENDCOLR,
								TEXT_COLOR("COLOR_GREEN"), gDLL->getText("TXT_KEY_COMBAT_ADJUST_RAGE_PER_ROUND").c_str(), pAttacker->strAdjperRndTotal());
							szString.append(NEWLINE);
							szString.append(szTempBuffer.GetCString());
						}

						if (pAttacker->strAdjperRndTotal() < 0)
						{
							szTempBuffer.Format(SETCOLR L"%s -%d%%" ENDCOLR,
								TEXT_COLOR("COLOR_RED"), gDLL->getText("TXT_KEY_COMBAT_ADJUST_FATIGUE_PER_ROUND").c_str(), pAttacker->strAdjperRndTotal());
							szString.append(NEWLINE);
							szString.append(szTempBuffer.GetCString());
						}

						if (pAttacker->canStampede())
						{
							szTempBuffer.Format(SETCOLR L"%s" ENDCOLR,
								TEXT_COLOR("COLOR_BLUE"), gDLL->getText("TXT_KEY_COMBAT_FIGHT_TO_DEATH").c_str());
							szString.append(NEWLINE);
							szString.append(szTempBuffer.GetCString());
						}

						if (pAttacker->canOnslaught())
						{
							szTempBuffer.Format(SETCOLR L"%s" ENDCOLR,
								TEXT_COLOR("COLOR_BLUE"), gDLL->getText("TXT_KEY_COMBAT_ATTACK_UNTIL_DAMAGED").c_str());
							szString.append(NEWLINE);
							szString.append(szTempBuffer.GetCString());
						}

						if (pAttacker->dealsColdDamage())
						{
							szTempBuffer.Format(SETCOLR L"%s" ENDCOLR,
								TEXT_COLOR("COLOR_GREEN"), gDLL->getText("TXT_KEY_COMBAT_ATTACKER_COLD_DAMAGE").c_str());
							szString.append(NEWLINE);
							szString.append(szTempBuffer.GetCString());
						}

						if (pDefender->dealsColdDamage())
						{
							szTempBuffer.Format(SETCOLR L"%s" ENDCOLR,
								TEXT_COLOR("COLOR_RED"), gDLL->getText("TXT_KEY_COMBAT_DEFENDER_COLD_DAMAGE").c_str());
							szString.append(NEWLINE);
							szString.append(szTempBuffer.GetCString());
						}

						for (iI = 0; iI < GC.getNumPromotionLineInfos(); ++iI)
						{
							PromotionLineTypes ePoisonLine = (PromotionLineTypes)iI;
							if (pAttacker->hasAfflictOnAttackType(ePoisonLine))
							{
								int iAttackerPoisonProb = pAttacker->getAfflictOnAttackTypeProbability(ePoisonLine);
								bool iAttackerImmediate = pAttacker->isAfflictOnAttackTypeImmediate(ePoisonLine);
								int iDefenderFortitude = pDefender->fortitudeTotal();
								int iAttackerTotalPoisonProb = std::max(0, (iAttackerPoisonProb - iDefenderFortitude - pDefender->getUnitAfflictionTolerance(ePoisonLine)));
								szTempBuffer.Format(SETCOLR L"%s %s" ENDCOLR,
									TEXT_COLOR("COLOR_GREEN"), gDLL->getText("TXT_KEY_COMBAT_ATTACKER_MAY_AFFLICT").c_str(), GC.getPromotionInfo((PromotionTypes)iI).getDescription());
								szTempBuffer.Format(SETCOLR L"%d% %s" ENDCOLR,
									TEXT_COLOR("COLOR_GREEN"), iAttackerPoisonProb, gDLL->getText("TXT_KEY_COMBAT_MAY_AFFLICT2").c_str());
								if (pDefender->getUnitAfflictionTolerance(ePoisonLine) > 0)
								{
									szTempBuffer.Format(SETCOLR L"- %s %d%" ENDCOLR,
										TEXT_COLOR("COLOR_GREEN"), gDLL->getText("TXT_KEY_COMBAT_TOLERANCE").c_str(), pDefender->getUnitAfflictionTolerance(ePoisonLine));
									szString.append(szTempBuffer.GetCString());
								}
								if (iDefenderFortitude > 0)
								{
									szTempBuffer.Format(SETCOLR L"%d% %s" ENDCOLR,
										TEXT_COLOR("COLOR_GREEN"), iDefenderFortitude, gDLL->getText("TXT_KEY_COMBAT_MAY_AFFLICT3").c_str());
									szTempBuffer.Format(SETCOLR L"%d%" ENDCOLR,
										TEXT_COLOR("COLOR_GREEN"), iAttackerTotalPoisonProb);
								}
								szString.append(NEWLINE);
								if (iAttackerImmediate)
								{
									szTempBuffer.Format(SETCOLR L"%s" ENDCOLR,
										TEXT_COLOR("COLOR_GREEN"), gDLL->getText("TXT_KEY_COMBAT_MAY_AFFLICT_IMMEDIATE").c_str());
								}
								else
								{
									szTempBuffer.Format(SETCOLR L"%s" ENDCOLR,
										TEXT_COLOR("COLOR_GREEN"), gDLL->getText("TXT_KEY_COMBAT_MAY_AFFLICT_DELAYED").c_str());
								}

								szString.append(NEWLINE);
								szString.append(szTempBuffer.GetCString());
							}

							if (pDefender->hasAfflictOnAttackType(ePoisonLine))
							{
								int iDefenderPoisonProb = pDefender->getAfflictOnAttackTypeProbability(ePoisonLine);
								bool iDefenderImmediate = pDefender->isAfflictOnAttackTypeImmediate(ePoisonLine);
								int iAttackerFortitude = pAttacker->fortitudeTotal();
								int iDefenderTotalPoisonProb = std::max(0, (iDefenderPoisonProb - iAttackerFortitude - pAttacker->getUnitAfflictionTolerance(ePoisonLine)));
								szTempBuffer.Format(SETCOLR L"%s %s" ENDCOLR,
									TEXT_COLOR("COLOR_RED"), gDLL->getText("TXT_KEY_COMBAT_DEFENDER_MAY_AFFLICT").c_str(), GC.getPromotionInfo((PromotionTypes)iI).getDescription());
								szTempBuffer.Format(SETCOLR L"%d% %s" ENDCOLR,
									TEXT_COLOR("COLOR_RED"), iDefenderPoisonProb, gDLL->getText("TXT_KEY_COMBAT_MAY_AFFLICT2").c_str());
								if (pAttacker->getUnitAfflictionTolerance(ePoisonLine) > 0)
								{
									szTempBuffer.Format(SETCOLR L"- %s %d%" ENDCOLR,
										TEXT_COLOR("COLOR_RED"), gDLL->getText("TXT_KEY_COMBAT_TOLERANCE").c_str(), pAttacker->getUnitAfflictionTolerance(ePoisonLine));
									szString.append(szTempBuffer.GetCString());
								}
								if (iAttackerFortitude > 0)
								{
									szTempBuffer.Format(SETCOLR L"%d% %s" ENDCOLR,
										TEXT_COLOR("COLOR_RED"), iAttackerFortitude, gDLL->getText("TXT_KEY_COMBAT_MAY_AFFLICT3").c_str());
									szTempBuffer.Format(SETCOLR L"%d%" ENDCOLR,
										TEXT_COLOR("COLOR_RED"), iDefenderTotalPoisonProb);
								}
								szString.append(NEWLINE);
								if (iDefenderImmediate)
								{
									szTempBuffer.Format(SETCOLR L"%s" ENDCOLR,
										TEXT_COLOR("COLOR_RED"), gDLL->getText("TXT_KEY_COMBAT_MAY_AFFLICT_IMMEDIATE").c_str());
								}
								else
								{
									szTempBuffer.Format(SETCOLR L"%s" ENDCOLR,
										TEXT_COLOR("COLOR_RED"), gDLL->getText("TXT_KEY_COMBAT_MAY_AFFLICT_DELAYED").c_str());
								}

								szString.append(NEWLINE);
								szString.append(szTempBuffer.GetCString());
							}

							if (pAttacker->hasAfflictionLine(ePoisonLine) && GC.getPromotionLineInfo(ePoisonLine).getCommunicability() > 0 && !GC.getPromotionLineInfo(ePoisonLine).isNoSpreadonBattle())
							{
								szTempBuffer.Format(SETCOLR L"%s %s" ENDCOLR,
									TEXT_COLOR("COLOR_GREEN"), gDLL->getText("TXT_KEY_COMBAT_ATTACKER_MAY_AFFLICT").c_str(), GC.getPromotionLineInfo(ePoisonLine).getDescription());
								szString.append(NEWLINE);
								szString.append(szTempBuffer.GetCString());
								szTempBuffer.Format(SETCOLR L"%s %d%" ENDCOLR,
									TEXT_COLOR("COLOR_GREEN"), gDLL->getText("TXT_KEY_COMBAT_BASE_CHANCE").c_str(), GC.getPromotionLineInfo(ePoisonLine).getCommunicability());
								szString.append(szTempBuffer.GetCString());
								if (pDefender->fortitudeTotal() > 0)
								{
									szTempBuffer.Format(SETCOLR L"- %s %d%" ENDCOLR,
										TEXT_COLOR("COLOR_GREEN"), gDLL->getText("TXT_KEY_COMBAT_FORTITUDE").c_str(), pDefender->fortitudeTotal());
									szString.append(szTempBuffer.GetCString());
								}
								//if (pDefender->aidVolume(pDefender->plot()) > 0)
								//{
								//	szTempBuffer.Format(SETCOLR L"- %s %d%" ENDCOLR,
								//					TEXT_COLOR("COLOR_GREEN"), gDLL->getText("TXT_KEY_COMBAT_AID_PRESENT").c_str(), pDefender->aidVolume(pDefender->plot()));
								//	szString.append(szTempBuffer.GetCString());
								//}
								if (pDefender->getUnitAfflictionTolerance(ePoisonLine) > 0)
								{
									szTempBuffer.Format(SETCOLR L"- %s %d%" ENDCOLR,
										TEXT_COLOR("COLOR_GREEN"), gDLL->getText("TXT_KEY_COMBAT_TOLERANCE").c_str(), pDefender->getUnitAfflictionTolerance(ePoisonLine));
									szString.append(szTempBuffer.GetCString());
								}
								if (pDefender->getContractChanceChange(ePoisonLine) > 0)
								{
									int iDefenderMiscMods = pDefender->getFortitudeModifierTypeAmount(ePoisonLine) + pDefender->getContractChanceChange(ePoisonLine);
									szTempBuffer.Format(SETCOLR L"- %s %d%" ENDCOLR,
										TEXT_COLOR("COLOR_GREEN"), gDLL->getText("TXT_KEY_COMBAT_MISC_MODS").c_str(), iDefenderMiscMods);
									szString.append(szTempBuffer.GetCString());
								}
								if (pDefender->fortitudeTotal() > 0/* || pDefender->aidVolume(pDefender->plot()) > 0*/)
								{
									int iTotalCommunicabilityChance = GC.getPromotionLineInfo(ePoisonLine).getCommunicability() - pDefender->fortitudeTotal() /*- pDefender->aidVolume(pDefender->plot())*/;
									szTempBuffer.Format(SETCOLR L"= %d%" ENDCOLR,
										TEXT_COLOR("COLOR_GREEN"), iTotalCommunicabilityChance);
									szString.append(szTempBuffer.GetCString());
								}
								szString.append(NEWLINE);
							}

							if (pDefender->hasAfflictionLine(ePoisonLine) && GC.getPromotionLineInfo(ePoisonLine).getCommunicability() > 0 && !GC.getPromotionLineInfo(ePoisonLine).isNoSpreadonBattle())
							{
								szTempBuffer.Format(SETCOLR L"%s %s" ENDCOLR,
									TEXT_COLOR("COLOR_RED"), gDLL->getText("TXT_KEY_COMBAT_DEFENDER_MAY_AFFLICT").c_str(), GC.getPromotionLineInfo(ePoisonLine).getDescription());
								szString.append(NEWLINE);
								szString.append(szTempBuffer.GetCString());
								szTempBuffer.Format(SETCOLR L"%s %d%" ENDCOLR,
									TEXT_COLOR("COLOR_RED"), gDLL->getText("TXT_KEY_COMBAT_BASE_CHANCE").c_str(), GC.getPromotionLineInfo(ePoisonLine).getCommunicability());
								szString.append(szTempBuffer.GetCString());
								if (pAttacker->fortitudeTotal() > 0)
								{
									szTempBuffer.Format(SETCOLR L"- %s %d%" ENDCOLR,
										TEXT_COLOR("COLOR_RED"), gDLL->getText("TXT_KEY_COMBAT_FORTITUDE").c_str(), pAttacker->fortitudeTotal());
									szString.append(szTempBuffer.GetCString());
								}
								//if (pAttacker->aidVolume(pDefender->plot()) > 0)
								//{
								//	szTempBuffer.Format(SETCOLR L"- %s %d%" ENDCOLR,
								//					TEXT_COLOR("COLOR_RED"), gDLL->getText("TXT_KEY_COMBAT_AID_PRESENT").c_str(), pAttacker->aidVolume(pAttacker->plot()));
								//	szString.append(szTempBuffer.GetCString());
								//}
								if (pAttacker->getUnitAfflictionTolerance(ePoisonLine) > 0)
								{
									szTempBuffer.Format(SETCOLR L"- %s %d%" ENDCOLR,
										TEXT_COLOR("COLOR_RED"), gDLL->getText("TXT_KEY_COMBAT_TOLERANCE").c_str(), pAttacker->getUnitAfflictionTolerance(ePoisonLine));
									szString.append(szTempBuffer.GetCString());
								}
								if (pAttacker->getContractChanceChange(ePoisonLine) > 0)
								{
									int iAttackerMiscMods = pAttacker->getFortitudeModifierTypeAmount(ePoisonLine) + pAttacker->getContractChanceChange(ePoisonLine);
									szTempBuffer.Format(SETCOLR L"- %s %d%" ENDCOLR,
										TEXT_COLOR("COLOR_RED"), gDLL->getText("TXT_KEY_COMBAT_MISC_MODS").c_str(), iAttackerMiscMods);
									szString.append(szTempBuffer.GetCString());
								}
								if (pAttacker->fortitudeTotal() > 0 /*|| pAttacker->aidVolume(pAttacker->plot()) > 0*/)
								{
									int iTotalCommunicabilityChance = GC.getPromotionLineInfo(ePoisonLine).getCommunicability() - pAttacker->fortitudeTotal()/* - pAttacker->aidVolume(pAttacker->plot())*/;
									szTempBuffer.Format(SETCOLR L"= %d%" ENDCOLR,
										TEXT_COLOR("COLOR_RED"), iTotalCommunicabilityChance);
									szString.append(szTempBuffer.GetCString());
								}
								szString.append(NEWLINE);
							}
						}

						if (iAttackerCriticalChance > 0)
						{
							if (iAttackerBaseCriticalChance != 0)
							{
								szTempBuffer.Format(SETCOLR L"%s %d%%" ENDCOLR,
									TEXT_COLOR("COLOR_GREEN"), gDLL->getText("TXT_KEY_COMBAT_ATTACKER_CRITICAL_MODIFIER").c_str(), iAttackerBaseCriticalChance);
								szString.append(NEWLINE);
								szString.append(szTempBuffer.GetCString());

							}
							szTempBuffer.Format(SETCOLR L"%s %.1f%%" ENDCOLR,
								TEXT_COLOR("COLOR_GREEN"), gDLL->getText("TXT_KEY_COMBAT_ATTACKER_CHANCE_CRITICAL").c_str(), iAttackerCriticalChance / 10000.00f);
							szString.append(NEWLINE);
							szString.append(szTempBuffer.GetCString());
						}

						if (iDefenderCriticalChance > 0)
						{
							if (iDefenderBaseCriticalChance != 0)
							{
								szTempBuffer.Format(SETCOLR L"%s %d%%" ENDCOLR,
									TEXT_COLOR("COLOR_RED"), gDLL->getText("TXT_KEY_COMBAT_DEFENDER_CRITICAL_MODIFIER").c_str(), iDefenderBaseCriticalChance);
								szString.append(NEWLINE);
								szString.append(szTempBuffer.GetCString());
							}
							szTempBuffer.Format(SETCOLR L"%s %.1f%%" ENDCOLR,
								TEXT_COLOR("COLOR_RED"), gDLL->getText("TXT_KEY_COMBAT_DEFENDER_CHANCE_CRITICAL").c_str(), iDefenderCriticalChance / 10000.00f);
							szString.append(NEWLINE);
							szString.append(szTempBuffer.GetCString());
						}

						if (pAttacker->powerShotsTotal() > 0)
						{
							int iAttackerPowerShots = pAttacker->powerShotsTotal();
							int iAttackerPowerShotCombat = pAttacker->powerShotCombatModifierTotal();
							int iAttackerPowerShotPuncture = pAttacker->powerShotPunctureModifierTotal();
							int iAttackerPowerShotPrecision = pAttacker->powerShotPrecisionModifierTotal();
							int iAttackerPowerShotCritical = pAttacker->powerShotCriticalModifierTotal();
							szTempBuffer.Format(SETCOLR L"%s %d" ENDCOLR,
								TEXT_COLOR("COLOR_GREEN"), gDLL->getText("TXT_KEY_COMBAT_ATTACKER_POWER_SHOTS").c_str(), iAttackerPowerShots);
							szString.append(NEWLINE);
							szString.append(szTempBuffer.GetCString());

							if (iAttackerPowerShotCombat != 0)
							{
								szTempBuffer.Format(SETCOLR L"%s %d%%" ENDCOLR,
									TEXT_COLOR("COLOR_GREEN"), gDLL->getText("TXT_KEY_COMBAT_ATTACKER_POWER_SHOTS_COMBAT_MODIFIER").c_str(), iAttackerPowerShotCombat);
								szString.append(NEWLINE);
								szString.append(szTempBuffer.GetCString());

							}
							if (iAttackerPowerShotPuncture != 0)
							{
								szTempBuffer.Format(SETCOLR L"%s %d%%" ENDCOLR,
									TEXT_COLOR("COLOR_GREEN"), gDLL->getText("TXT_KEY_COMBAT_ATTACKER_POWER_SHOTS_PUNCTURE_MODIFIER").c_str(), iAttackerPowerShotPuncture);
								szString.append(NEWLINE);
								szString.append(szTempBuffer.GetCString());
							}
							if (iAttackerPowerShotPrecision != 0)
							{
								szTempBuffer.Format(SETCOLR L"%s %d%%" ENDCOLR,
									TEXT_COLOR("COLOR_GREEN"), gDLL->getText("TXT_KEY_COMBAT_ATTACKER_POWER_SHOTS_PRECISION_MODIFIER").c_str(), iAttackerPowerShotPrecision);
								szString.append(NEWLINE);
								szString.append(szTempBuffer.GetCString());
							}
							if (iAttackerPowerShotCritical != 0)
							{
								szTempBuffer.Format(SETCOLR L"%s %d%%" ENDCOLR,
									TEXT_COLOR("COLOR_GREEN"), gDLL->getText("TXT_KEY_COMBAT_ATTACKER_POWER_SHOTS_CRITICAL_MODIFIER").c_str(), iAttackerPowerShotCritical);
								szString.append(NEWLINE);
								szString.append(szTempBuffer.GetCString());

							}
						}
						if (pDefender->powerShotsTotal() > 0)
						{
							int iDefenderPowerShots = pDefender->powerShotsTotal();
							int iDefenderPowerShotCombat = pDefender->powerShotCombatModifierTotal();
							int iDefenderPowerShotPuncture = pDefender->powerShotPunctureModifierTotal();
							int iDefenderPowerShotPrecision = pDefender->powerShotPrecisionModifierTotal();
							int iDefenderPowerShotCritical = pDefender->powerShotCriticalModifierTotal();
							szTempBuffer.Format(SETCOLR L"%s %d" ENDCOLR,
								TEXT_COLOR("COLOR_RED"), gDLL->getText("TXT_KEY_COMBAT_DEFENDER_POWER_SHOTS").c_str(), iDefenderPowerShots);
							szString.append(NEWLINE);
							szString.append(szTempBuffer.GetCString());

							if (iDefenderPowerShotCombat != 0)
							{
								szTempBuffer.Format(SETCOLR L"%s %d%%" ENDCOLR,
									TEXT_COLOR("COLOR_RED"), gDLL->getText("TXT_KEY_COMBAT_DEFENDER_POWER_SHOTS_COMBAT_MODIFIER").c_str(), iDefenderPowerShotCombat);
								szString.append(NEWLINE);
								szString.append(szTempBuffer.GetCString());

							}
							if (iDefenderPowerShotPuncture != 0)
							{
								szTempBuffer.Format(SETCOLR L"%s %d%%" ENDCOLR,
									TEXT_COLOR("COLOR_RED"), gDLL->getText("TXT_KEY_COMBAT_DEFENDER_POWER_SHOTS_PUNCTURE_MODIFIER").c_str(), iDefenderPowerShotPuncture);
								szString.append(NEWLINE);
								szString.append(szTempBuffer.GetCString());

							}
							if (iDefenderPowerShotPrecision != 0)
							{
								szTempBuffer.Format(SETCOLR L"%s %d%%" ENDCOLR,
									TEXT_COLOR("COLOR_RED"), gDLL->getText("TXT_KEY_COMBAT_DEFENDER_POWER_SHOTS_PRECISION_MODIFIER").c_str(), iDefenderPowerShotPrecision);
								szString.append(NEWLINE);
								szString.append(szTempBuffer.GetCString());

							}
							if (iDefenderPowerShotCritical != 0)
							{
								szTempBuffer.Format(SETCOLR L"%s %d%%" ENDCOLR,
									TEXT_COLOR("COLOR_RED"), gDLL->getText("TXT_KEY_COMBAT_DEFENDER_POWER_SHOTS_CRITICAL_MODIFIER").c_str(), iDefenderPowerShotCritical);
								szString.append(NEWLINE);
								szString.append(szTempBuffer.GetCString());
							}
						}

#ifdef STRENGTH_IN_NUMBERS
						if (GC.getGame().isOption(GAMEOPTION_STRENGTH_IN_NUMBERS))
						{
							if (pAttacker->getAttackerSupportValue() > 0)
							{
								int iAttackerSupport = pAttacker->getAttackerSupportValue();
								szTempBuffer.Format(SETCOLR L"%s +%d" ENDCOLR,
									TEXT_COLOR("COLOR_GREEN"), gDLL->getText("TXT_KEY_COMBAT_TOTAL_ATTACKER_SUPPORT").c_str(), iAttackerSupport);
								szString.append(NEWLINE);
								szString.append(szTempBuffer.GetCString());
							}
							if (pDefender->getDefenderSupportValue(pAttacker) > 0)
							{
								int iDefenderSupport = pDefender->getDefenderSupportValue(pAttacker);
								szTempBuffer.Format(SETCOLR L"%s +%d" ENDCOLR,
									TEXT_COLOR("COLOR_RED"), gDLL->getText("TXT_KEY_COMBAT_TOTAL_DEFENDER_SUPPORT").c_str(), iDefenderSupport);
								szString.append(NEWLINE);
								szString.append(szTempBuffer.GetCString());
							}
						}
#endif // STRENGTH_IN_NUMBERS

						if (pAttacker->currentStrAdjperAttTotal() > 0)
						{
							iModifier = pAttacker->currentStrAdjperAttTotal();
							if (iModifier > 0)
							{
								szString.append(gDLL->getText("TXT_KEY_COLOR_POSITIVE"));
								szString.append(L' ');
								szString.append(NEWLINE);
								szString.append(gDLL->getText("TXT_KEY_COMBAT_RAMPAGE", iModifier));
							}
						}
						if (pAttacker->currentStrAdjperAttTotal() < 0)
						{
							iModifier = pAttacker->currentStrAdjperAttTotal();
							if (iModifier < 0)
							{
								szString.append(gDLL->getText("TXT_KEY_COLOR_NEGATIVE"));
								szString.append(L' ');
								szString.append(NEWLINE);
								szString.append(gDLL->getText("TXT_KEY_COMBAT_TIRES", iModifier));
							}
						}

						if (pAttacker->currentStrAdjperDefTotal() > 0)
						{
							iModifier = pAttacker->currentStrAdjperDefTotal();
							if (iModifier > 0)
							{
								szString.append(gDLL->getText("TXT_KEY_COLOR_POSITIVE"));
								szString.append(L' ');
								szString.append(NEWLINE);
								szString.append(gDLL->getText("TXT_KEY_COMBAT_DETERMINATION", iModifier));
							}
						}

						if (pAttacker->currentStrAdjperDefTotal() < 0)
						{
							iModifier = pAttacker->currentStrAdjperDefTotal();
							if (iModifier < 0)
							{
								szString.append(gDLL->getText("TXT_KEY_COLOR_NEGATIVE"));
								szString.append(L' ');
								szString.append(NEWLINE);
								szString.append(gDLL->getText("TXT_KEY_COMBAT_DEMORALIZATION", iModifier));
							}
						}
					}
					//TB Display Mod end
					//szTempBuffer.Format(L"AI odds: %d%%", iOdds);
					//szString += NEWLINE + szTempBuffer;
	/*************************************************************************************************/
	/** ADVANCED COMBAT ODDS					  3/11/09						   PieceOfMind	  */
	/** BEGIN																	   v2.0			 */
	/*************************************************************************************************/
	/* New Code */
					else if (ACO_enabled && !bTBView)
					{
						szString.append(NEWLINE);

						//Change this to true when you need to spot errors, particular in the expected hit points calculations
						bool ACO_debug = getBugOptionBOOL("ACO__Debug", false, "ACO_DEBUG");

						/** phungus sart **/
	//					bool bctrl; bctrl = gDLL->ctrlKey();
	//					if (bctrl)
	//					{//SWITCHAROO IS DISABLED IN V1.0.  Hopefully it will be available in the next version. At the moment is has issues when modifiers are present.
	//						CvUnit* swap = pAttacker;
	//						pAttacker = pDefender;
	//						pDefender = swap;
	//
	//						CvPlot* pAttackerPlot = pAttacker->plot();
	//						  CvPlot* pDefenderPlot = pDefender->plot();
	//					}
						int iAttackerExperienceModifier = 0;
						int iDefenderExperienceModifier = 0;
						for (int ePromotion = 0; ePromotion < GC.getNumPromotionInfos(); ++ePromotion)
						{
							if (pAttacker->isHasPromotion((PromotionTypes)ePromotion) && GC.getPromotionInfo((PromotionTypes)ePromotion).getExperiencePercent() != 0)
							{
								iAttackerExperienceModifier += GC.getPromotionInfo((PromotionTypes)ePromotion).getExperiencePercent();
							}
						}

						for (int ePromotion = 0; ePromotion < GC.getNumPromotionInfos(); ++ePromotion)
						{
							if (pDefender->isHasPromotion((PromotionTypes)ePromotion) && GC.getPromotionInfo((PromotionTypes)ePromotion).getExperiencePercent() != 0)
							{
								iDefenderExperienceModifier += GC.getPromotionInfo((PromotionTypes)ePromotion).getExperiencePercent();
							}
						}
						/** phungus end **/ //thanks to phungus420



						/** Many thanks to DanF5771 for some of these calculations! **/
						int iFlankAmount = iDamageToAttacker;
						//TB Combat Mods begin
						//originals
						//int iAttackerStrength  = pAttacker->currCombatStr(NULL, NULL);
						//int iAttackerFirepower = pAttacker->currFirepower(NULL, NULL);
						//int iDefenderStrength  = pDefender->currCombatStr(pPlot, pAttacker);
						//int iDefenderFirepower = pDefender->currFirepower(pPlot, pAttacker);
						//FAssert((iAttackerStrength + iDefenderStrength)*(iAttackerFirepower + iDefenderFirepower) > 0);
						//int iStrengthFactor	= ((iAttackerFirepower + iDefenderFirepower + 1) / 2);
						//  iDamageToAttacker = std::max(1,((GC.getDefineINT("COMBAT_DAMAGE") * (iDefenderFirepower + iStrengthFactor)) / (iAttackerFirepower + iStrengthFactor)));
						//  iDamageToDefender = std::max(1,((GC.getDefineINT("COMBAT_DAMAGE") * (iAttackerFirepower + iStrengthFactor)) / (iDefenderFirepower + iStrengthFactor)));
						//int iDamageToAttacker  = std::max(1, ((((GC.getDefineINT("COMBAT_DAMAGE") * (iDefenderFirepower + iStrengthFactor)) / (iAttackerFirepower + iStrengthFactor)) * iAttackerArmor)/100));
						//int iDamageToDefender  = std::max(1, ((((GC.getDefineINT("COMBAT_DAMAGE") * (iAttackerFirepower + iStrengthFactor)) / (iDefenderFirepower + iStrengthFactor)) * iDefenderArmor)/100));

						int iDefenderInitialOdds = ((GC.getCOMBAT_DIE_SIDES() * iDefenderStrength) / (iAttackerStrength + iDefenderStrength));
						int iDefenderHitOdds = std::max(5, iDefenderInitialOdds - ((iDefenderHitModifier * iDefenderInitialOdds) / 100));

						int iAttackerInitialOdds = GC.getCOMBAT_DIE_SIDES() - iDefenderInitialOdds;
						int iAttackerHitOdds = std::max(5, iAttackerInitialOdds - ((iAttackerHitModifier * iAttackerInitialOdds) / 100));

						int iDefenderOdds = ((iDefenderHitOdds - iAttackerHitOdds) + 1000) / 2;
						int iAttackerOdds = ((iAttackerHitOdds - iDefenderHitOdds) + 1000) / 2;
						//int iDefenderOdds = ((GC.getDefineINT("COMBAT_DIE_SIDES") * iDefenderStrength) / (iAttackerStrength + iDefenderStrength));
						//int iAttackerOdds = GC.getDefineINT("COMBAT_DIE_SIDES") - iDefenderOdds;
						//TB Combat Mods end

						// Barbarian related code.
						if (getBugOptionBOOL("ACO__IgnoreBarbFreeWins", false, "ACO_IGNORE_BARB_FREE_WINS"))//Are we not going to ignore barb free wins?  If not, skip this section...
						{
							if (pDefender->isHominid())
							{
								//defender is barbarian
								if (!GET_PLAYER(pAttacker->getOwner()).isHominid() && GET_PLAYER(pAttacker->getOwner()).getWinsVsBarbs() < GC.getHandicapInfo(GET_PLAYER(pAttacker->getOwner()).getHandicapType()).getFreeWinsVsBarbs())
								{
									//attacker is not barb and attacker player has free wins left
									//I have assumed in the following code only one of the units (attacker and defender) can be a barbarian
									iDefenderOdds = std::min((10 * GC.getCOMBAT_DIE_SIDES()) / 100, iDefenderOdds);
									iAttackerOdds = std::max((90 * GC.getCOMBAT_DIE_SIDES()) / 100, iAttackerOdds);
									szTempBuffer.Format(SETCOLR L"%d\n" ENDCOLR,
										TEXT_COLOR("COLOR_HIGHLIGHT_TEXT"), GC.getHandicapInfo(GET_PLAYER(pAttacker->getOwner()).getHandicapType()).getFreeWinsVsBarbs() - GET_PLAYER(pAttacker->getOwner()).getWinsVsBarbs());
									szString.append(gDLL->getText("TXT_ACO_BARBFREEWINSLEFT"));
									szString.append(szTempBuffer.GetCString());
								}
							}
							else
							{
								//defender is not barbarian
								if (pAttacker->isHominid())
								{
									//attacker is barbarian
									if (!GET_PLAYER(pDefender->getOwner()).isHominid() && GET_PLAYER(pDefender->getOwner()).getWinsVsBarbs() < GC.getHandicapInfo(GET_PLAYER(pDefender->getOwner()).getHandicapType()).getFreeWinsVsBarbs())
									{
										//defender is not barbarian and defender has free wins left and attacker is barbarian
										iAttackerOdds = std::min((10 * GC.getCOMBAT_DIE_SIDES()) / 100, iAttackerOdds);
										iDefenderOdds = std::max((90 * GC.getCOMBAT_DIE_SIDES()) / 100, iDefenderOdds);
										szTempBuffer.Format(SETCOLR L"%d\n" ENDCOLR,
											TEXT_COLOR("COLOR_HIGHLIGHT_TEXT"), GC.getHandicapInfo(GET_PLAYER(pDefender->getOwner()).getHandicapType()).getFreeWinsVsBarbs() - GET_PLAYER(pDefender->getOwner()).getWinsVsBarbs());
										szString.append(gDLL->getText("TXT_ACO_BARBFREEWINSLEFT"));
										szString.append(szTempBuffer.GetCString());
									}
								}
							}
						}


						//XP calculations

						int iExperience;
						int iWithdrawXP;//thanks to phungus420
						int iAttackerWithdrawalProbability = pAttacker->withdrawVSOpponentProbTotal(pDefender, pPlot) - pDefender->pursuitVSOpponentProbTotal(pAttacker);
						int iCombatLimitWithdrawalProbability = 100 - pDefender->pursuitVSOpponentProbTotal(pAttacker);
						iWithdrawXP = pAttacker->getExperiencefromWithdrawal(iAttackerWithdrawalProbability);//thanks to phungus420

						if (pAttacker->combatLimit() < 100)
						{
							iExperience = pAttacker->getExperiencefromWithdrawal(iCombatLimitWithdrawalProbability);
						}
						else
						{
							iExperience = (pAttacker->attackXPValue() * iDefenderStrength) / iAttackerStrength;
							iExperience = range(iExperience, GC.getMIN_EXPERIENCE_PER_COMBAT(), GC.getMAX_EXPERIENCE_PER_COMBAT());
						}

						int iDefExperienceKill;
						iDefExperienceKill = (pDefender->defenseXPValue() * iAttackerStrength) / iDefenderStrength;
						iDefExperienceKill = range(iDefExperienceKill, GC.getMIN_EXPERIENCE_PER_COMBAT(), GC.getMAX_EXPERIENCE_PER_COMBAT());

						int iBonusAttackerXP = (iExperience * iAttackerExperienceModifier) / 100;
						int iBonusDefenderXP = (iDefExperienceKill * iDefenderExperienceModifier) / 100;
						int iBonusWithdrawXP = (pAttacker->getExperiencefromWithdrawal(iAttackerWithdrawalProbability) * iAttackerExperienceModifier) / 100;

						//The following code adjusts the XP for barbarian encounters.  In standard game, barb and animal xp cap is 10,5 respectively.
						/**Thanks to phungus420 for the following block of code! **/
						if (pDefender->isAnimal())
						{
							//animal
							iExperience = range(iExperience, 0, GC.getANIMAL_MAX_XP_VALUE() - (pAttacker->getExperience()));
							if (iExperience < 0)
							{
								iExperience = 0;
							}
							iWithdrawXP = range(iWithdrawXP, 0, GC.getANIMAL_MAX_XP_VALUE() - (pAttacker->getExperience()));
							if (iWithdrawXP < 0)
							{
								iWithdrawXP = 0;
							}
							iBonusAttackerXP = range(iBonusAttackerXP, 0, GC.getANIMAL_MAX_XP_VALUE() - (pAttacker->getExperience() + iExperience));
							if (iBonusAttackerXP < 0)
							{
								iBonusAttackerXP = 0;
							}
							iBonusWithdrawXP = range(iBonusWithdrawXP, 0, GC.getANIMAL_MAX_XP_VALUE() - (pAttacker->getExperience() + iWithdrawXP));
							if (iBonusWithdrawXP < 0)
							{
								iBonusWithdrawXP = 0;
							}
						}
						if (pDefender->isHominid())
						{
							//normal barbarian
							iExperience = range(iExperience, 0, GC.getBARBARIAN_MAX_XP_VALUE() - pAttacker->getExperience());
							if (iExperience < 0)
							{
								iExperience = 0;
							}
							iWithdrawXP = range(iWithdrawXP, 0, GC.getBARBARIAN_MAX_XP_VALUE() - (pAttacker->getExperience()));
							if (iWithdrawXP < 0)
							{
								iWithdrawXP = 0;
							}
							iBonusAttackerXP = range(iBonusAttackerXP, 0, GC.getBARBARIAN_MAX_XP_VALUE() - (pAttacker->getExperience() + iExperience));
							if (iBonusAttackerXP < 0)
							{
								iBonusAttackerXP = 0;
							}
							iBonusWithdrawXP = range(iBonusWithdrawXP, 0, GC.getBARBARIAN_MAX_XP_VALUE() - (pAttacker->getExperience() + iWithdrawXP));
							if (iBonusWithdrawXP < 0)
							{
								iBonusWithdrawXP = 0;
							}
						}
						//int iNeededRoundsAttacker = (pDefender->currHitPoints() - pDefender->maxHitPoints() + pAttacker->combatLimit() - (((pAttacker->combatLimit())==pDefender->maxHitPoints())?1:0))/iDamageToDefender + 1;
						//The extra term introduced here was to account for the incorrect way it treated units that had combatLimits.
						//A catapult that deals 25HP per round, and has a combatLimit of 75HP must deal four successful hits before it kills the warrior -not 3.  This is proved in the way CvUnit::resolvecombat works
						// The old formula (with just a plain -1 instead of a conditional -1 or 0) was incorrectly saying three.

						// int iNeededRoundsDefender = (pAttacker->currHitPoints() + iDamageToAttacker - 1 ) / iDamageToAttacker;  //this is idential to the following line
						// int iNeededRoundsDefender = (pAttacker->currHitPoints() - 1)/iDamageToAttacker + 1;

						//szTempBuffer.Format(L"iNeededRoundsAttacker = %d\niNeededRoundsDefender = %d",iNeededRoundsAttacker,iNeededRoundsDefender);
						//szString.append(NEWLINE);szString.append(szTempBuffer.GetCString());
						//szTempBuffer.Format(L"pDefender->currHitPoints = %d\n-pDefender->maxHitPOints = %d\n + pAttacker->combatLimit = %d\n - 1 if\npAttackercomBatlimit equals pDefender->maxHitpoints\n=(%d == %d)\nall over iDamageToDefender = %d\n+1 = ...",
						//pDefender->currHitPoints(),pDefender->maxHitPoints(),pAttacker->combatLimit(),pAttacker->combatLimit(),pDefender->maxHitPoints(),iDamageToDefender);
						//szString.append(NEWLINE);szString.append(szTempBuffer.GetCString());

						int iDefenderHitLimit = pDefender->maxHitPoints() - pAttacker->combatLimit(pDefender);

						//NOW WE CALCULATE SOME INTERESTING STUFF :)

						float E_HP_Att = 0.0f;//expected damage dealt to attacker
						float E_HP_Def = 0.0f;
						float E_HP_Att_Withdraw; //Expected hitpoints for attacker if attacker withdraws (not the same as retreat)
						float E_HP_Att_Victory; //Expected hitpoints for attacker if attacker kills defender
						int E_HP_Att_Retreat = (pAttacker->currHitPoints()) - (iNeededRoundsDefender - 1) * iDamageToAttacker;//this one is predetermined easily
						float E_HP_Def_Withdraw;
						float E_HP_Def_Defeat; // if attacker dies
						//Note E_HP_Def is the same for if the attacker withdraws or dies

						float AttackerUnharmed;
						float DefenderUnharmed;

						AttackerUnharmed = getCombatOddsSpecific(pAttacker, pDefender, 0, iNeededRoundsAttacker);
						DefenderUnharmed = getCombatOddsSpecific(pAttacker, pDefender, iNeededRoundsDefender, 0);
						DefenderUnharmed += getCombatOddsSpecific(pAttacker, pDefender, iNeededRoundsDefender - 1, 0);//attacker withdraws or retreats

						float prob_bottom_Att_HP; // The probability the attacker exits combat with min HP
						float prob_bottom_Def_HP; // The probability the defender exits combat with min HP

						if (ACO_debug)
						{
							szTempBuffer.Format(L"E[HP ATTACKER]");
							//szString.append(NEWLINE);
							szString.append(szTempBuffer.GetCString());
						}
						// already covers both possibility of defender not being killed AND being killed
						for (int n_A = 0; n_A < iNeededRoundsDefender; n_A++)
						{
							//prob_attack[n_A] = getCombatOddsSpecific(pAttacker,pDefender,n_A,iNeededRoundsAttacker);
							E_HP_Att += ((pAttacker->currHitPoints()) - n_A * iDamageToAttacker) * getCombatOddsSpecific(pAttacker, pDefender, n_A, iNeededRoundsAttacker);

							if (ACO_debug)
							{
								szTempBuffer.Format(L"+%d * %.2f%%  (Def %d) (%d:%d)",
									((pAttacker->currHitPoints()) - n_A * iDamageToAttacker), 100.0f * getCombatOddsSpecific(pAttacker, pDefender, n_A, iNeededRoundsAttacker), iDefenderHitLimit, n_A, iNeededRoundsAttacker);
								szString.append(NEWLINE);
								szString.append(szTempBuffer.GetCString());
							}
						}
						E_HP_Att_Victory = E_HP_Att;//NOT YET NORMALISED
						E_HP_Att_Withdraw = E_HP_Att;//NOT YET NORMALIZED
						prob_bottom_Att_HP = getCombatOddsSpecific(pAttacker, pDefender, iNeededRoundsDefender - 1, iNeededRoundsAttacker);
						if ((pAttacker->withdrawVSOpponentProbTotal(pDefender, pPlot) - pDefender->pursuitVSOpponentProbTotal(pAttacker)) > 0)
						{
							// if withdraw odds involved
							if (ACO_debug)
							{
								szTempBuffer.Format(L"Attacker retreat odds");
								szString.append(NEWLINE);
								szString.append(szTempBuffer.GetCString());
							}
							for (int n_D = 0; n_D < iNeededRoundsAttacker; n_D++)
							{
								E_HP_Att += ((pAttacker->currHitPoints()) - (iNeededRoundsDefender - 1) * iDamageToAttacker) * getCombatOddsSpecific(pAttacker, pDefender, iNeededRoundsDefender - 1, n_D);
								prob_bottom_Att_HP += getCombatOddsSpecific(pAttacker, pDefender, iNeededRoundsDefender - 1, n_D);
								if (ACO_debug)
								{
									szTempBuffer.Format(L"+%d * %.2f%%  (Def %d) (%d:%d)",
										((pAttacker->currHitPoints()) - (iNeededRoundsDefender - 1) * iDamageToAttacker), 100.0f * getCombatOddsSpecific(pAttacker, pDefender, iNeededRoundsDefender - 1, n_D), (pDefender->currHitPoints()) - n_D * iDamageToDefender, iNeededRoundsDefender - 1, n_D);
									szString.append(NEWLINE);
									szString.append(szTempBuffer.GetCString());
								}
							}
						}
						// finished with the attacker HP I think.

						if (ACO_debug)
						{
							szTempBuffer.Format(L"E[HP DEFENDER]\nOdds that attacker dies or retreats");
							szString.append(NEWLINE);
							szString.append(szTempBuffer.GetCString());
						}
						for (int n_D = 0; n_D < iNeededRoundsAttacker; n_D++)
						{
							//prob_defend[n_D] = getCombatOddsSpecific(pAttacker,pDefender,iNeededRoundsDefender,n_D);//attacker dies
							//prob_defend[n_D] += getCombatOddsSpecific(pAttacker,pDefender,iNeededRoundsDefender-1,n_D);//attacker retreats
							E_HP_Def += ((pDefender->currHitPoints()) - n_D * iDamageToDefender) * (getCombatOddsSpecific(pAttacker, pDefender, iNeededRoundsDefender, n_D) + getCombatOddsSpecific(pAttacker, pDefender, iNeededRoundsDefender - 1, n_D));
							if (ACO_debug)
							{
								szTempBuffer.Format(L"+%d * %.2f%%  (Att 0 or %d) (%d:%d)",
									((pDefender->currHitPoints()) - n_D * iDamageToDefender), 100.0f * (getCombatOddsSpecific(pAttacker, pDefender, iNeededRoundsDefender, n_D) + getCombatOddsSpecific(pAttacker, pDefender, iNeededRoundsDefender - 1, n_D)), (pAttacker->currHitPoints()) - (iNeededRoundsDefender - 1) * iDamageToAttacker, iNeededRoundsDefender, n_D);
								szString.append(NEWLINE);
								szString.append(szTempBuffer.GetCString());
							}
						}
						prob_bottom_Def_HP = getCombatOddsSpecific(pAttacker, pDefender, iNeededRoundsDefender, iNeededRoundsAttacker - 1);
						//prob_bottom_Def_HP += getCombatOddsSpecific(pAttacker,pDefender,iNeededRoundsDefender-1,iNeededRoundsAttacker-1);
						E_HP_Def_Defeat = E_HP_Def;
						E_HP_Def_Withdraw = 0.0f;

						if (pAttacker->combatLimit(pDefender) < (pDefender->maxHitPoints()))//if attacker has a combatLimit (eg. catapult)
						{
							if (pAttacker->combatLimit(pDefender) == iDamageToDefender * (iNeededRoundsAttacker - 1))
							{
								//Then we have an odd situation because the last successful hit by an attacker will do 0 damage, and doing either iNeededRoundsAttacker or iNeededRoundsAttacker-1 will cause the same damage
								if (ACO_debug)
								{
									szTempBuffer.Format(L"Odds that attacker withdraws at combatLimit (abnormal)");
									szString.append(NEWLINE);
									szString.append(szTempBuffer.GetCString());
								}
								for (int n_A = 0; n_A < iNeededRoundsDefender; n_A++)
								{
									//prob_defend[iNeededRoundsAttacker-1] += getCombatOddsSpecific(pAttacker,pDefender,n_A,iNeededRoundsAttacker);//this is the defender at the combatLimit
									E_HP_Def += (float)iDefenderHitLimit * getCombatOddsSpecific(pAttacker, pDefender, n_A, iNeededRoundsAttacker);
									//should be the same as
									//E_HP_Def += ( (pDefender->currHitPoints()) - (iNeededRoundsAttacker-1)*iDamageToDefender) * getCombatOddsSpecific(pAttacker,pDefender,n_A,iNeededRoundsAttacker);
									E_HP_Def_Withdraw += (float)iDefenderHitLimit * getCombatOddsSpecific(pAttacker, pDefender, n_A, iNeededRoundsAttacker);
									prob_bottom_Def_HP += getCombatOddsSpecific(pAttacker, pDefender, n_A, iNeededRoundsAttacker);
									if (ACO_debug)
									{
										szTempBuffer.Format(L"+%d * %.2f%%  (Att %d) (%d:%d)",
											iDefenderHitLimit, 100.0f * getCombatOddsSpecific(pAttacker, pDefender, n_A, iNeededRoundsAttacker), 100 - n_A * iDamageToAttacker, n_A, iNeededRoundsAttacker);
										szString.append(NEWLINE);
										szString.append(szTempBuffer.GetCString());
									}
								}
							}
							else // normal situation
							{
								if (ACO_debug)
								{
									szTempBuffer.Format(L"Odds that attacker withdraws at combatLimit (normal)", pAttacker->combatLimit(pDefender));
									szString.append(NEWLINE);
									szString.append(szTempBuffer.GetCString());
								}

								for (int n_A = 0; n_A < iNeededRoundsDefender; n_A++)
								{

									E_HP_Def += (float)iDefenderHitLimit * getCombatOddsSpecific(pAttacker, pDefender, n_A, iNeededRoundsAttacker);
									E_HP_Def_Withdraw += (float)iDefenderHitLimit * getCombatOddsSpecific(pAttacker, pDefender, n_A, iNeededRoundsAttacker);
									prob_bottom_Def_HP += getCombatOddsSpecific(pAttacker, pDefender, n_A, iNeededRoundsAttacker);
									if (ACO_debug)
									{
										szTempBuffer.Format(L"+%d * %.2f%%  (Att %d) (%d:%d)",
											iDefenderHitLimit, 100.0f * getCombatOddsSpecific(pAttacker, pDefender, n_A, iNeededRoundsAttacker), GC.getMAX_HIT_POINTS() - n_A * iDamageToAttacker, n_A, iNeededRoundsAttacker);
										szString.append(NEWLINE);
										szString.append(szTempBuffer.GetCString());
									}
								}//for
							}//else
						}
						if (ACO_debug)
						{
							szString.append(NEWLINE);
						}

						float Scaling_Factor = 1.6f;//how many pixels per 1% of odds

						float AttackerKillOdds = 0.0f;
						float PullOutOdds = 0.0f;//Withdraw odds
						float RetreatOdds = 0.0f;
						float DefenderKillOdds = 0.0f;

						float CombatRatio = ((float)(pAttacker->currCombatStr(NULL, NULL))) / ((float)(pDefender->currCombatStr(pPlot, pAttacker)));
						// THE ALL-IMPORTANT COMBATRATIO

						float AttXP = (pAttacker->attackXPValue()) / CombatRatio;
						float DefXP = (pDefender->defenseXPValue()) * CombatRatio;// These two values are simply for the Unrounded XP display

						// General odds
						if (pAttacker->combatLimit(pDefender) >= (pDefender->maxHitPoints())) //ie. we can kill the defender... I hope this is the most general form
						{
							//float AttackerKillOdds = 0.0f;
							for (int n_A = 0; n_A < iNeededRoundsDefender; n_A++)
							{
								AttackerKillOdds += getCombatOddsSpecific(pAttacker, pDefender, n_A, iNeededRoundsAttacker);
							}//for
						}
						else
						{
							// else we cannot kill the defender (eg. catapults attacking)
							for (int n_A = 0; n_A < iNeededRoundsDefender; n_A++)
							{
								PullOutOdds += getCombatOddsSpecific(pAttacker, pDefender, n_A, iNeededRoundsAttacker);
							}//for
						}
						//TB Combat Mods - next line adjusted for pursuit
						if ((pAttacker->withdrawVSOpponentProbTotal(pDefender, pPlot) - pDefender->pursuitVSOpponentProbTotal(pAttacker)) > 0)
						{
							for (int n_D = 0; n_D < iNeededRoundsAttacker; n_D++)
							{
								RetreatOdds += getCombatOddsSpecific(pAttacker, pDefender, iNeededRoundsDefender - 1, n_D);
							}//for
						}
						for (int n_D = 0; n_D < iNeededRoundsAttacker; n_D++)
						{
							DefenderKillOdds += getCombatOddsSpecific(pAttacker, pDefender, iNeededRoundsDefender, n_D);
						}//for
						//DefenderKillOdds = 1.0f - (AttackerKillOdds + RetreatOdds + PullOutOdds);//this gives slight negative numbers sometimes, I think



						if (iView & getBugOptionINT("ACO__ShowSurvivalOdds", 3, "ACO_SHOW_SURVIVAL_ODDS"))
						{
							szTempBuffer.Format(L"%.2f%%", 100.0f * (AttackerKillOdds + RetreatOdds + PullOutOdds));
							szTempBuffer2.Format(L"%.2f%%", 100.0f * (RetreatOdds + PullOutOdds + DefenderKillOdds));
							szString.append(gDLL->getText("TXT_ACO_SURVIVALODDS"));
							szString.append(gDLL->getText("TXT_ACO_VS", szTempBuffer.GetCString(), szTempBuffer2.GetCString()));
							szString.append(NEWLINE);
						}
						//TB Combat Mods - next line adjusted for pursuit
						if ((pAttacker->withdrawVSOpponentProbTotal(pDefender, pPlot) - pDefender->pursuitVSOpponentProbTotal(pAttacker)) >= 100)
						{
							// a rare situation indeed (TB - not so unlikely now that withdrawal has become unlimited, held in check by pursuit

							szString.append(NEWLINE);
							szString.append(gDLL->getText("TXT_ACO_SURVIVALGUARANTEED"));
						}

						//CvWString szTempBuffer2; // moved to elsewhere in the code (earlier)
						//CvWString szBuffer; // duplicate

						float prob1 = 100.0f * (AttackerKillOdds + PullOutOdds);//up to win odds
						float prob2 = prob1 + 100.0f * RetreatOdds;//up to retreat odds

						float prob = 100.0f * (AttackerKillOdds + RetreatOdds + PullOutOdds);
						int pixels_left = 199;// 1 less than 200 to account for right end bar
						int pixels;
						int fullBlocks;
						int lastBlock;

						pixels = (2 * ((int)(prob1 + 0.5))) - 1;  // 1% per pixel // subtracting one to account for left end bar
						fullBlocks = pixels / 10;
						lastBlock = pixels % 10;

						szString.append(L"<img=Art/ACO/green_bar_left_end.dds>");
						for (int i = 0; i < fullBlocks; ++i)
						{
							szString.append(L"<img=Art/ACO/green_bar_10.dds>");
							pixels_left -= 10;
						}
						if (lastBlock > 0)
						{
							szTempBuffer2.Format(L"<img=Art/ACO/green_bar_%d.dds>", lastBlock);
							szString.append(szTempBuffer2);
							pixels_left -= lastBlock;
						}


						pixels = 2 * ((int)(prob2 + 0.5)) - (pixels + 1);//the number up to the next one...
						fullBlocks = pixels / 10;
						lastBlock = pixels % 10;
						for (int i = 0; i < fullBlocks; ++i)
						{
							szString.append(L"<img=Art/ACO/yellow_bar_10.dds>");
							pixels_left -= 10;
						}
						if (lastBlock > 0)
						{
							szTempBuffer2.Format(L"<img=Art/ACO/yellow_bar_%d.dds>", lastBlock);
							szString.append(szTempBuffer2);
							pixels_left -= lastBlock;
						}

						fullBlocks = pixels_left / 10;
						lastBlock = pixels_left % 10;
						for (int i = 0; i < fullBlocks; ++i)
						{
							szString.append(L"<img=Art/ACO/red_bar_10.dds>");
						}
						if (lastBlock > 0)
						{
							szTempBuffer2.Format(L"<img=Art/ACO/red_bar_%d.dds>", lastBlock);
							szString.append(szTempBuffer2);
						}

						szString.append(L"<img=Art/ACO/red_bar_right_end.dds> ");


						szString.append(NEWLINE);
						if (pAttacker->combatLimit(pDefender) >= (pDefender->maxHitPoints()))
						{
							int iWithdrawOdds = 100 - pDefender->pursuitVSOpponentProbTotal(pAttacker);
							szTempBuffer.Format(L": " SETCOLR L"%.2f%% " L"%d" ENDCOLR,
								TEXT_COLOR("COLOR_POSITIVE_TEXT"), 100.0f * AttackerKillOdds, iExperience);
							szString.append(gDLL->getText("TXT_ACO_VICTORY"));
							szString.append(szTempBuffer.GetCString());
							if (iAttackerExperienceModifier > 0)
							{
								szTempBuffer.Format(SETCOLR L"+%d" ENDCOLR, TEXT_COLOR("COLOR_HIGHLIGHT_TEXT"), iBonusAttackerXP);
								szString.append(szTempBuffer.GetCString());
							}

							szString.append(gDLL->getText("TXT_KEY_COLOR_POSITIVE"));
							szString.append(gDLL->getText("TXT_ACO_XP"));
							szString.append(gDLL->getText("TXT_KEY_COLOR_REVERT"));
							szString.append("  (");
							szString.append(gDLL->getText("TXT_KEY_COLOR_POSITIVE"));
							szTempBuffer.Format(L"%.1f",
								E_HP_Att_Victory / AttackerKillOdds);
							szString.append(szTempBuffer.GetCString());
							szString.append(gDLL->getText("TXT_ACO_HP"));
							szString.append(gDLL->getText("TXT_KEY_COLOR_REVERT"));
						}
						else
						{
							int iWithdr = pAttacker->withdrawVSOpponentProbTotal(pDefender, pPlot) - pDefender->pursuitVSOpponentProbTotal(pAttacker);
							szTempBuffer.Format(L": " SETCOLR L"%.2f%% " L"%d" ENDCOLR,
								TEXT_COLOR("COLOR_POSITIVE_TEXT"), 100.0f * PullOutOdds, pAttacker->getExperiencefromWithdrawal(iWithdr));
							//iExperience,TEXT_COLOR("COLOR_POSITIVE_TEXT"), E_HP_Att_Victory/AttackerKillOdds);
							szString.append(gDLL->getText("TXT_ACO_WITHDRAW"));
							szString.append(szTempBuffer.GetCString());
							if (iAttackerExperienceModifier > 0)
							{
								szTempBuffer.Format(SETCOLR L"+%d" ENDCOLR, TEXT_COLOR("COLOR_HIGHLIGHT_TEXT"), iBonusWithdrawXP);
								szString.append(szTempBuffer.GetCString());
							}

							szString.append(gDLL->getText("TXT_KEY_COLOR_POSITIVE"));
							szString.append(gDLL->getText("TXT_ACO_XP"));
							szString.append(gDLL->getText("TXT_KEY_COLOR_REVERT"));
							szString.append("  (");
							szString.append(gDLL->getText("TXT_KEY_COLOR_POSITIVE"));
							szTempBuffer.Format(L"%.1f", E_HP_Att_Withdraw / PullOutOdds);
							szString.append(szTempBuffer.GetCString());
							szString.append(gDLL->getText("TXT_ACO_HP"));
							szString.append(gDLL->getText("TXT_KEY_COLOR_REVERT"));
							szString.append(",");
							szString.append(gDLL->getText("TXT_KEY_COLOR_NEGATIVE"));
							szTempBuffer.Format(L"%d", iDefenderHitLimit);
							szString.append(szTempBuffer.GetCString());
							szString.append(gDLL->getText("TXT_ACO_HP"));
							szString.append(gDLL->getText("TXT_KEY_COLOR_REVERT"));
						}
						szString.append(")");

						if (iDefenderOdds == 0)
						{
							szString.append(gDLL->getText("TXT_ACO_GUARANTEEDNODEFENDERHIT"));
							DefenderKillOdds = 0.0f;
						}
						//TB Combat Mods - next line adjusted for pursuit
						if ((pAttacker->withdrawVSOpponentProbTotal(pDefender, pPlot) - pDefender->pursuitVSOpponentProbTotal(pAttacker)) > 0)//if there are retreat odds
						{
							int iWithdr = pAttacker->withdrawVSOpponentProbTotal(pDefender, pPlot) - pDefender->pursuitVSOpponentProbTotal(pAttacker);
							szString.append(NEWLINE);
							szTempBuffer.Format(L": " SETCOLR L"%.2f%% " ENDCOLR SETCOLR L"%d" ENDCOLR,
								TEXT_COLOR("COLOR_UNIT_TEXT"), 100.0f * RetreatOdds, TEXT_COLOR("COLOR_POSITIVE_TEXT"), pAttacker->getExperiencefromWithdrawal(iWithdr));
							szString.append(gDLL->getText("TXT_ACO_RETREAT"));
							szString.append(szTempBuffer.GetCString());
							if (iAttackerExperienceModifier > 0)
							{
								szTempBuffer.Format(SETCOLR L"+%d" ENDCOLR, TEXT_COLOR("COLOR_HIGHLIGHT_TEXT"), iBonusWithdrawXP);
								szString.append(szTempBuffer.GetCString());
							}
							szString.append(gDLL->getText("TXT_KEY_COLOR_POSITIVE"));
							szString.append(gDLL->getText("TXT_ACO_XP"));
							szString.append(gDLL->getText("TXT_KEY_COLOR_REVERT"));
							szString.append("  (");
							szTempBuffer.Format(SETCOLR L"%d" ENDCOLR,
								TEXT_COLOR("COLOR_UNIT_TEXT"), E_HP_Att_Retreat);
							szString.append(szTempBuffer.GetCString());
							szString.append(gDLL->getText("TXT_ACO_HP_NEUTRAL"));
							szString.append(")");
							//szString.append(gDLL->getText("TXT_KEY_COLOR_REVERT"));
						}

						szString.append(NEWLINE);
						szTempBuffer.Format(L": " SETCOLR L"%.2f%% " L"%d" ENDCOLR,
							TEXT_COLOR("COLOR_NEGATIVE_TEXT"), 100.0f * DefenderKillOdds, iDefExperienceKill);
						szString.append(gDLL->getText("TXT_ACO_DEFEAT"));
						szString.append(szTempBuffer.GetCString());
						if (iDefenderExperienceModifier > 0)
						{
							szTempBuffer.Format(SETCOLR L"+%d" ENDCOLR, TEXT_COLOR("COLOR_HIGHLIGHT_TEXT"), iBonusDefenderXP);
							szString.append(szTempBuffer.GetCString());
						}
						szString.append(gDLL->getText("TXT_KEY_COLOR_NEGATIVE"));
						szString.append(gDLL->getText("TXT_ACO_XP"));
						szString.append(gDLL->getText("TXT_KEY_COLOR_REVERT"));
						szString.append("  (");
						szString.append(gDLL->getText("TXT_KEY_COLOR_NEGATIVE"));
						szTempBuffer.Format(L"%.1f",
							(iDefenderOdds != 0 ? E_HP_Def_Defeat / (RetreatOdds + DefenderKillOdds) : 0.0));
						szString.append(szTempBuffer.GetCString());
						szString.append(gDLL->getText("TXT_ACO_HP"));
						szString.append(gDLL->getText("TXT_KEY_COLOR_REVERT"));
						szString.append(")");


						float HP_percent_cutoff = 0.5f; // Probabilities lower than this (in percent) will not be shown individually for the HP detail section.
						if (!getBugOptionBOOL("ACO__MergeShortBars", true, "ACO_MERGE_SHORT_BARS"))
						{
							HP_percent_cutoff = 0.0f;
						}
						int first_combined_HP_Att = 0;
						int first_combined_HP_Def = 0;
						int last_combined_HP;
						float combined_HP_sum = 0.0f;
						BOOL bIsCondensed = false;



						//START ATTACKER DETAIL HP HERE
						// Individual bars for each attacker HP outcome.
						if (iView & getBugOptionINT("ACO__ShowAttackerHealthBars", 2, "ACO_SHOW_ATTACKER_HEALTH_BARS"))
						{
							for (int n_A = 0; n_A < iNeededRoundsDefender - 1; n_A++)
							{
								float prob = 100.0f * getCombatOddsSpecific(pAttacker, pDefender, n_A, iNeededRoundsAttacker);
								if (prob > HP_percent_cutoff || n_A == 0)
								{
									if (bIsCondensed) // then we need to print the prev ones
									{
										int pixels = (int)(Scaling_Factor * combined_HP_sum + 0.5);  // 1% per pixel
										int fullBlocks = (pixels) / 10;
										int lastBlock = (pixels) % 10;
										//if(pixels>=2) {szString.append(L"<img=Art/ACO/green_bar_left_end.dds>");}
										szString.append(NEWLINE);
										szString.append(L"<img=Art/ACO/green_bar_left_end.dds>");
										for (int iI = 0; iI < fullBlocks; ++iI)
										{
											szString.append(L"<img=Art/ACO/green_bar_10.dds>");
										}
										if (lastBlock > 0)
										{
											szTempBuffer2.Format(L"<img=Art/ACO/green_bar_%d.dds>", lastBlock);
											szString.append(szTempBuffer2);
										}
										szString.append(L"<img=Art/ACO/green_bar_right_end.dds>");
										szString.append(L" ");

										szString.append(gDLL->getText("TXT_KEY_COLOR_POSITIVE"));
										if (last_combined_HP != first_combined_HP_Att)
										{
											szTempBuffer.Format(L"%d", last_combined_HP);
											szString.append(szTempBuffer.GetCString());
											szString.append(gDLL->getText("TXT_ACO_HP"));
											szString.append(gDLL->getText("-"));
										}

										szTempBuffer.Format(L"%d", first_combined_HP_Att);
										szString.append(szTempBuffer.GetCString());
										szString.append(gDLL->getText("TXT_ACO_HP"));
										szString.append(gDLL->getText("TXT_KEY_COLOR_REVERT"));
										szTempBuffer.Format(L" %.2f%%", combined_HP_sum);
										szString.append(szTempBuffer.GetCString());

										bIsCondensed = false;//resetting
										combined_HP_sum = 0.0f;//resetting this variable
										last_combined_HP = 0;
									}

									szString.append(NEWLINE);
									int pixels = (int)(Scaling_Factor * prob + 0.5);  // 1% per pixel
									int fullBlocks = (pixels) / 10;
									int lastBlock = (pixels) % 10;
									szString.append(L"<img=Art/ACO/green_bar_left_end.dds>");
									for (int iI = 0; iI < fullBlocks; ++iI)
									{
										szString.append(L"<img=Art/ACO/green_bar_10.dds>");
									}
									if (lastBlock > 0)
									{
										szTempBuffer2.Format(L"<img=Art/ACO/green_bar_%d.dds>", lastBlock);
										szString.append(szTempBuffer2);
									}
									szString.append(L"<img=Art/ACO/green_bar_right_end.dds>");
									szString.append(L" ");

									szString.append(gDLL->getText("TXT_KEY_COLOR_POSITIVE"));
									szTempBuffer.Format(L"%d",
										((pAttacker->currHitPoints()) - n_A * iDamageToAttacker));
									szString.append(szTempBuffer.GetCString());
									szString.append(gDLL->getText("TXT_ACO_HP"));
									szString.append(gDLL->getText("TXT_KEY_COLOR_REVERT"));
									szTempBuffer.Format(L" %.2f%%",
										prob);
									szString.append(szTempBuffer.GetCString());
								}
								else // we add to the condensed list
								{
									bIsCondensed = true;
									first_combined_HP_Att = std::max(first_combined_HP_Att, ((pAttacker->currHitPoints()) - n_A * iDamageToAttacker));
									last_combined_HP = ((pAttacker->currHitPoints()) - n_A * iDamageToAttacker);
									combined_HP_sum += prob;
								}
							}

							if (bIsCondensed) // then we need to print the prev ones
							{
								szString.append(NEWLINE);
								int pixels = (int)(Scaling_Factor * combined_HP_sum + 0.5);  // 1% per pixel
								int fullBlocks = (pixels) / 10;
								int lastBlock = (pixels) % 10;

								szString.append(L"<img=Art/ACO/green_bar_left_end.dds>");
								for (int iI = 0; iI < fullBlocks; ++iI)
								{
									szString.append(L"<img=Art/ACO/green_bar_10.dds>");
								}
								if (lastBlock > 0)
								{
									szTempBuffer2.Format(L"<img=Art/ACO/green_bar_%d.dds>", lastBlock);
									szString.append(szTempBuffer2);
								}

								szString.append(L"<img=Art/ACO/green_bar_right_end.dds>");
								szString.append(L" ");

								szString.append(gDLL->getText("TXT_KEY_COLOR_POSITIVE"));
								if (last_combined_HP != first_combined_HP_Att)
								{
									szTempBuffer.Format(L"%d", last_combined_HP);
									szString.append(szTempBuffer.GetCString());
									szString.append(gDLL->getText("TXT_ACO_HP"));
									szString.append(gDLL->getText("-"));
								}
								szTempBuffer.Format(L"%d", first_combined_HP_Att);
								szString.append(szTempBuffer.GetCString());
								szString.append(gDLL->getText("TXT_ACO_HP"));
								szString.append(gDLL->getText("TXT_KEY_COLOR_REVERT"));
								szTempBuffer.Format(L" %.2f%%", combined_HP_sum);
								szString.append(szTempBuffer.GetCString());

								bIsCondensed = false;//resetting
								combined_HP_sum = 0.0f;//resetting this variable
								last_combined_HP = 0;
							}
							// At the moment I am not allowing the lowest Attacker HP value to be condensed, as it would be confusing if it includes retreat odds
							// I may include this in the future though, but probably only if retreat odds are zero.

							float prob_victory = 100.0f * getCombatOddsSpecific(pAttacker, pDefender, iNeededRoundsDefender - 1, iNeededRoundsAttacker);
							float prob_retreat = 100.0f * RetreatOdds;

							szString.append(NEWLINE);
							int green_pixels = (int)(Scaling_Factor * prob_victory + 0.5);
							int yellow_pixels = (int)(Scaling_Factor * (prob_retreat + prob_victory) + 0.5) - green_pixels;//makes the total length of the bar more accurate - more important than the length of the pieces
							green_pixels += 1;//we put an extra 2 on every one of the bar pixel counts
							if (yellow_pixels >= 1)
							{
								yellow_pixels += 1;
							}
							else
							{
								green_pixels += 1;
							}
							szString.append(L"<img=Art/ACO/green_bar_left_end.dds>");
							green_pixels--;

							green_pixels--;//subtracting off the right end
							int fullBlocks = green_pixels / 10;
							int lastBlock = green_pixels % 10;
							for (int iI = 0; iI < fullBlocks; ++iI)
							{
								szString.append(L"<img=Art/ACO/green_bar_10.dds>");
							}//for
							if (lastBlock > 0)
							{
								szTempBuffer2.Format(L"<img=Art/ACO/green_bar_%d.dds>", lastBlock);
								szString.append(szTempBuffer2);
							}//if
							if (yellow_pixels >= 1)// then there will at least be a right end yellow pixel
							{
								yellow_pixels--;//subtracting off right end
								fullBlocks = yellow_pixels / 10;
								lastBlock = yellow_pixels % 10;
								for (int iI = 0; iI < fullBlocks; ++iI)
								{
									szString.append(L"<img=Art/ACO/yellow_bar_10.dds>");
								}//for
								if (lastBlock > 0)
								{
									szTempBuffer2.Format(L"<img=Art/ACO/yellow_bar_%d.dds>", lastBlock);
									szString.append(szTempBuffer2);
								}
								szString.append(L"<img=Art/ACO/yellow_bar_right_end.dds>");
								//finished
							}
							else
							{
								szString.append(L"<img=Art/ACO/green_bar_right_end.dds>");
								//finished
							}//else if

							szString.append(L" ");
							szString.append(gDLL->getText("TXT_KEY_COLOR_POSITIVE"));
							szTempBuffer.Format(L"%d", ((pAttacker->currHitPoints()) - (iNeededRoundsDefender - 1) * iDamageToAttacker));
							szString.append(szTempBuffer.GetCString());
							szString.append(gDLL->getText("TXT_ACO_HP"));
							szString.append(gDLL->getText("TXT_KEY_COLOR_REVERT"));
							szTempBuffer.Format(L" %.2f%%", prob_victory + prob_retreat);
							szString.append(szTempBuffer.GetCString());
						}
						//END ATTACKER DETAIL HP HERE



						//START DEFENDER DETAIL HP HERE
						first_combined_HP_Def = pDefender->currHitPoints();
						if (iView & getBugOptionINT("ACO__ShowDefenderHealthBars", 2, "ACO_SHOW_DEFENDER_HEALTH_BARS"))
						{
							float prob = 0.0f;
							int def_HP;
							for (int n_D = iNeededRoundsAttacker; n_D >= 1; n_D--)//
							{
								if (pAttacker->combatLimit(pDefender) >= pDefender->maxHitPoints())// a unit with a combat limit
								{
									if (n_D == iNeededRoundsAttacker)
									{
										n_D--;//we don't need to do HP for when the unit is dead.
									}
								}

								def_HP = std::max((pDefender->currHitPoints()) - n_D * iDamageToDefender, (pDefender->maxHitPoints() - pAttacker->combatLimit(pDefender)));

								if ((pDefender->maxHitPoints() - pAttacker->combatLimit(pDefender)) == pDefender->currHitPoints() - (n_D - 1) * iDamageToDefender)
								{
									// if abnormal
									if (n_D == iNeededRoundsAttacker)
									{
										n_D--;
										def_HP = (pDefender->maxHitPoints() - pAttacker->combatLimit(pDefender));
										prob += 100.0f * PullOutOdds;
										prob += 100.0f * (getCombatOddsSpecific(pAttacker, pDefender, iNeededRoundsDefender, n_D) + (getCombatOddsSpecific(pAttacker, pDefender, iNeededRoundsDefender - 1, n_D)));
									}
								}
								else
								{
									//not abnormal
									if (n_D == iNeededRoundsAttacker)
									{
										prob += 100.0f * PullOutOdds;
									}
									else
									{
										prob += 100.0f * (getCombatOddsSpecific(pAttacker, pDefender, iNeededRoundsDefender, n_D) + (getCombatOddsSpecific(pAttacker, pDefender, iNeededRoundsDefender - 1, n_D)));
									}
								}

								if (prob > HP_percent_cutoff || (pAttacker->combatLimit(pDefender) < pDefender->maxHitPoints() && (n_D == iNeededRoundsAttacker)))
								{
									if (bIsCondensed) // then we need to print the prev ones
									{
										szString.append(NEWLINE);

										int pixels = (int)(Scaling_Factor * combined_HP_sum + 0.5);  // 1% per pixel
										int fullBlocks = (pixels) / 10;
										int lastBlock = (pixels) % 10;
										szString.append(L"<img=Art/ACO/red_bar_left_end.dds>");
										for (int iI = 0; iI < fullBlocks; ++iI)
										{
											szString.append(L"<img=Art/ACO/red_bar_10.dds>");
										}
										if (lastBlock > 0)
										{
											szTempBuffer2.Format(L"<img=Art/ACO/red_bar_%d.dds>", lastBlock);
											szString.append(szTempBuffer2);
										}
										szString.append(L"<img=Art/ACO/red_bar_right_end.dds>");
										szString.append(L" ");
										szString.append(gDLL->getText("TXT_KEY_COLOR_NEGATIVE"));
										szTempBuffer.Format(L"%dHP", first_combined_HP_Def);
										szString.append(szTempBuffer.GetCString());
										szString.append(gDLL->getText("TXT_ACO_HP"));
										if (first_combined_HP_Def != last_combined_HP)
										{
											szString.append("-");
											szTempBuffer.Format(L"%d", last_combined_HP);
											szString.append(szTempBuffer.GetCString());
											szString.append(gDLL->getText("TXT_ACO_HP"));
										}
										szString.append(gDLL->getText("TXT_KEY_COLOR_REVERT"));
										szTempBuffer.Format(L" %.2f%%",
											combined_HP_sum);
										szString.append(szTempBuffer.GetCString());

										bIsCondensed = false;//resetting
										combined_HP_sum = 0.0f;//resetting this variable
									}

									szString.append(NEWLINE);
									int pixels = (int)(Scaling_Factor * prob + 0.5);  // 1% per pixel
									int fullBlocks = (pixels) / 10;
									int lastBlock = (pixels) % 10;
									//if(pixels>=2) // this is now guaranteed by the way we define number of pixels
									//{
									szString.append(L"<img=Art/ACO/red_bar_left_end.dds>");
									for (int iI = 0; iI < fullBlocks; ++iI)
									{
										szString.append(L"<img=Art/ACO/red_bar_10.dds>");
									}
									if (lastBlock > 0)
									{
										szTempBuffer2.Format(L"<img=Art/ACO/red_bar_%d.dds>", lastBlock);
										szString.append(szTempBuffer2);
									}
									szString.append(L"<img=Art/ACO/red_bar_right_end.dds>");
									//}
									szString.append(L" ");

									szTempBuffer.Format(SETCOLR L"%d" ENDCOLR,
										TEXT_COLOR("COLOR_NEGATIVE_TEXT"), def_HP);
									szString.append(szTempBuffer.GetCString());
									szString.append(gDLL->getText("TXT_KEY_COLOR_NEGATIVE"));
									szString.append(gDLL->getText("TXT_ACO_HP"));
									szString.append(gDLL->getText("TXT_KEY_COLOR_REVERT"));
									szTempBuffer.Format(L" %.2f%%", prob);
									szString.append(szTempBuffer.GetCString());
								}
								else
								{
									bIsCondensed = true;
									first_combined_HP_Def = (std::min(first_combined_HP_Def, def_HP));
									last_combined_HP = std::max(((pDefender->currHitPoints()) - n_D * iDamageToDefender), pDefender->maxHitPoints() - pAttacker->combatLimit(pDefender));
									combined_HP_sum += prob;
								}
								prob = 0.0f;
							}//for n_D


							if (bIsCondensed && iNeededRoundsAttacker > 1) // then we need to print the prev ones
								// the reason we need iNeededRoundsAttacker to be greater than 1 is that if it's equal to 1 then we end up with the defender detailed HP bar show up twice, because it will also get printed below
							{
								szString.append(NEWLINE);
								int pixels = (int)(Scaling_Factor * combined_HP_sum + 0.5);  // 1% per pixel
								int fullBlocks = (pixels) / 10;
								int lastBlock = (pixels) % 10;
								//if(pixels>=2) {szString.append(L"<img=Art/ACO/green_bar_left_end.dds>");}
								szString.append(L"<img=Art/ACO/red_bar_left_end.dds>");
								for (int iI = 0; iI < fullBlocks; ++iI)
								{
									szString.append(L"<img=Art/ACO/red_bar_10.dds>");
								}
								if (lastBlock > 0)
								{
									szTempBuffer2.Format(L"<img=Art/ACO/red_bar_%d.dds>", lastBlock);
									szString.append(szTempBuffer2);
								}
								szString.append(L"<img=Art/ACO/red_bar_right_end.dds>");
								szString.append(L" ");
								szString.append(gDLL->getText("TXT_KEY_COLOR_NEGATIVE"));
								szTempBuffer.Format(L"%d", first_combined_HP_Def);
								szString.append(szTempBuffer.GetCString());
								szString.append(gDLL->getText("TXT_ACO_HP"));
								if (first_combined_HP_Def != last_combined_HP)
								{
									szTempBuffer.Format(L"-%d", last_combined_HP);
									szString.append(szTempBuffer.GetCString());
									szString.append(gDLL->getText("TXT_ACO_HP"));
								}
								szString.append(gDLL->getText("TXT_KEY_COLOR_REVERT"));
								szTempBuffer.Format(L" %.2f%%", combined_HP_sum);
								szString.append(szTempBuffer.GetCString());

								bIsCondensed = false;//resetting
								combined_HP_sum = 0.0f;//resetting this variable
							}

							//print the unhurt value...always

							prob = 100.0f * (getCombatOddsSpecific(pAttacker, pDefender, iNeededRoundsDefender, 0) + (getCombatOddsSpecific(pAttacker, pDefender, iNeededRoundsDefender - 1, 0)));
							int pixels = (int)(Scaling_Factor * prob + 0.5);  // 1% per pixel
							int fullBlocks = (pixels) / 10;
							int lastBlock = (pixels) % 10;

							szString.append(NEWLINE);
							szString.append(L"<img=Art/ACO/red_bar_left_end.dds>");
							for (int iI = 0; iI < fullBlocks; ++iI)
							{
								szString.append(L"<img=Art/ACO/red_bar_10.dds>");
							}
							if (lastBlock > 0)
							{
								szTempBuffer2.Format(L"<img=Art/ACO/red_bar_%d.dds>", lastBlock);
								szString.append(szTempBuffer2);
							}
							szString.append(L"<img=Art/ACO/red_bar_right_end.dds>");
							szString.append(L" ");
							szString.append(gDLL->getText("TXT_KEY_COLOR_NEGATIVE"));
							szTempBuffer.Format(L"%d", pDefender->currHitPoints());
							szString.append(szTempBuffer.GetCString());
							szString.append(gDLL->getText("TXT_ACO_HP"));
							szString.append(gDLL->getText("TXT_KEY_COLOR_REVERT"));
							szTempBuffer.Format(L" %.2f%%", prob);
							szString.append(szTempBuffer.GetCString());
						}
						//END DEFENDER DETAIL HP HERE

						szString.append(NEWLINE);

						if (iView & getBugOptionINT("ACO__ShowBasicInfo", 3, "ACO_SHOW_BASIC_INFO"))
						{
							szTempBuffer.Format(SETCOLR L"%d" ENDCOLR L", " SETCOLR L"%d " ENDCOLR,
								TEXT_COLOR("COLOR_POSITIVE_TEXT"), iDamageToDefender, TEXT_COLOR("COLOR_NEGATIVE_TEXT"), iDamageToAttacker);
							szString.append(NEWLINE);
							szString.append(szTempBuffer.GetCString());
							szString.append(gDLL->getText("TXT_ACO_HP"));
							szString.append(" ");
							szString.append(gDLL->getText("TXT_ACO_MULTIPLY"));
							szTempBuffer.Format(L" " SETCOLR L"%d" ENDCOLR L", " SETCOLR L"%d " ENDCOLR,
								TEXT_COLOR("COLOR_POSITIVE_TEXT"), iNeededRoundsAttacker, TEXT_COLOR("COLOR_NEGATIVE_TEXT"),
								iNeededRoundsDefender);
							szString.append(szTempBuffer.GetCString());
							szString.append(gDLL->getText("TXT_ACO_HITSAT"));
							szTempBuffer.Format(SETCOLR L" %.1f%%" ENDCOLR,
								TEXT_COLOR("COLOR_POSITIVE_TEXT"), float(iAttackerOdds) * 100.0f / float(GC.getDefineINT("COMBAT_DIE_SIDES")));
							szString.append(szTempBuffer.GetCString());
						}
						if (!(iView & getBugOptionINT("ACO__ShowExperienceRange", 2, "ACO_SHOW_EXPERIENCE_RANGE")) || (pAttacker->combatLimit(pDefender) < (pDefender->maxHitPoints()))) //medium and high only
						{
							if (iView & getBugOptionINT("ACO__ShowBasicInfo", 3, "ACO_SHOW_BASIC_INFO"))
							{
								szTempBuffer.Format(L". R=" SETCOLR L"%.2f" ENDCOLR,
									TEXT_COLOR("COLOR_HIGHLIGHT_TEXT"), CombatRatio);
								szString.append(szTempBuffer.GetCString());
							}
						}
						else
						{
							//we do an XP range display
							//This should hopefully now work for any max and min XP values.

							if (pAttacker->combatLimit(pDefender) == (pDefender->maxHitPoints()))
							{
								FAssert(GC.getMAX_EXPERIENCE_PER_COMBAT() > GC.getMIN_EXPERIENCE_PER_COMBAT()); //ensuring the differences is at least 1
								int size = GC.getMAX_EXPERIENCE_PER_COMBAT() - GC.getMIN_EXPERIENCE_PER_COMBAT();
								float* CombatRatioThresholds = new float[size];

								for (int i = 0; i < size; i++) //setup the array
								{
									CombatRatioThresholds[i] = (float)pAttacker->attackXPValue() / (float)(GC.getMAX_EXPERIENCE_PER_COMBAT() - i);
									//For standard game, this is the list created:
									//  {4/10, 4/9, 4/8,
									//   4/7, 4/6, 4/5,
									//   4/4, 4/3, 4/2}
								}
								for (int i = size - 1; i >= 0; i--) // find which range we are in
								{
									//starting at i = 8, going through to i = 0
									if (CombatRatio > CombatRatioThresholds[i])
									{

										if (i == (size - 1))//highest XP value already
										{
											szString.append(NEWLINE);
											szTempBuffer.Format(L"(%.2f:%d",
												CombatRatioThresholds[i], GC.getMIN_EXPERIENCE_PER_COMBAT() + 1);
											szString.append(szTempBuffer.GetCString());
											szString.append(gDLL->getText("TXT_ACO_XP"));
											szTempBuffer.Format(L"), (R=" SETCOLR L"%.2f" ENDCOLR L":%d",
												TEXT_COLOR("COLOR_HIGHLIGHT_TEXT"), CombatRatio, iExperience);
											szString.append(szTempBuffer.GetCString());
											szString.append(gDLL->getText("TXT_ACO_XP"));
											szString.append(")");
										}
										else // normal situation
										{
											szString.append(NEWLINE);
											szTempBuffer.Format(L"(%.2f:%d",
												CombatRatioThresholds[i], GC.getMAX_EXPERIENCE_PER_COMBAT() - i);
											szString.append(szTempBuffer.GetCString());
											szString.append(gDLL->getText("TXT_ACO_XP"));
											szTempBuffer.Format(L"), (R=" SETCOLR L"%.2f" ENDCOLR L":%d",
												TEXT_COLOR("COLOR_HIGHLIGHT_TEXT"), CombatRatio, GC.getMAX_EXPERIENCE_PER_COMBAT() - (i + 1));
											szString.append(szTempBuffer.GetCString());
											szString.append(gDLL->getText("TXT_ACO_XP"));
											szTempBuffer.Format(L"), (>%.2f:%d",
												CombatRatioThresholds[i + 1], GC.getMAX_EXPERIENCE_PER_COMBAT() - (i + 2));
											szString.append(szTempBuffer.GetCString());
											szString.append(gDLL->getText("TXT_ACO_XP"));
											szString.append(")");
										}
										break;

									}
									else//very rare (ratio less than or equal to 0.4)
									{
										if (i == 0)//maximum XP
										{
											szString.append(NEWLINE);
											szTempBuffer.Format(L"(R=" SETCOLR L"%.2f" ENDCOLR L":%d",
												TEXT_COLOR("COLOR_POSITIVE_TEXT"), CombatRatio, GC.getMAX_EXPERIENCE_PER_COMBAT());
											szString.append(szTempBuffer.GetCString());

											szTempBuffer.Format(L"), (>%.2f:%d",
												CombatRatioThresholds[i], GC.getMAX_EXPERIENCE_PER_COMBAT() - 1);
											szString.append(szTempBuffer.GetCString());
											szString.append(gDLL->getText("TXT_ACO_XP"));
											szString.append(")");
											break;
										}//if
									}// else if
								}//for
								delete[] CombatRatioThresholds;
								//throw away the array
							}//if
						} // else if
						//Finished Showing XP range display


						if (iView & getBugOptionINT("ACO__ShowAverageHealth", 2, "ACO_SHOW_AVERAGE_HEALTH"))
						{
							szTempBuffer.Format(L"%.1f", E_HP_Att);
							szTempBuffer2.Format(L"%.1f", E_HP_Def);
							szString.append(gDLL->getText("TXT_ACO_AVERAGEHP"));
							szString.append(gDLL->getText("TXT_ACO_VS", szTempBuffer.GetCString(), szTempBuffer2.GetCString()));
						}

						if (iView & getBugOptionINT("ACO__ShowUnharmedOdds", 2, "ACO_SHOW_UNHARMED_ODDS"))
						{
							szTempBuffer.Format(L"%.2f%%", 100.0f * AttackerUnharmed);
							szTempBuffer2.Format(L"%.2f%%", 100.0f * DefenderUnharmed);
							szString.append(gDLL->getText("TXT_ACO_UNHARMED"));
							szString.append(gDLL->getText("TXT_ACO_VS", szTempBuffer.GetCString(), szTempBuffer2.GetCString()));
						}

						if (iView & getBugOptionINT("ACO__ShowUnroundedExperience", 0, "ACO_SHOW_UNROUNDED_EXPERIENCE"))
						{
							szTempBuffer.Format(L"%.2f", AttXP);
							szTempBuffer2.Format(L"%.2f", DefXP);
							szString.append(gDLL->getText("TXT_ACO_UNROUNDEDXP"));
							szString.append(gDLL->getText("TXT_ACO_VS", szTempBuffer.GetCString(), szTempBuffer2.GetCString()));
						}

						szString.append(NEWLINE);
						if (iView & getBugOptionINT("ACO__ShowShiftInstructions", 1, "ACO_SHOW_SHIFT_INSTRUCTIONS"))
						{
							szString.append(gDLL->getText("TXT_ACO_PRESSSHIFT"));
							szString.append(NEWLINE);
						}
						//TB Display Mod begin
						szString.append(gDLL->getText("TXT_TB_PRESSCTRL"));
						szString.append(NEWLINE);
						if (GC.getGame().isOption(GAMEOPTION_STRENGTH_IN_NUMBERS))
						{
							szString.append(gDLL->getText("TXT_TB_PRESSALT_STR"));
							szString.append(NEWLINE);
						}
						//TB Display Mod end

						szString.append(NEWLINE);

						szTempBuffer.Format(L"%.2f",
							((pAttacker->getDomainType() == DOMAIN_AIR) ? pAttacker->airCurrCombatStrFloat(pDefender) : pAttacker->currCombatStrFloat(NULL, NULL)));

						if (pAttacker->isHurt())
						{
							szTempBuffer.append(L" (");
							szTempBuffer.append(gDLL->getText("TXT_ACO_INJURED_HP",
								pAttacker->currHitPoints(),
								pAttacker->maxHitPoints()));
							szTempBuffer.append(L")");
						}


						szTempBuffer2.Format(L"%.2f",
							pDefender->currCombatStrFloat(pPlot, pAttacker)
						);

						if (pDefender->isHurt())
						{
							szTempBuffer2.append(L" (");
							szTempBuffer2.append(gDLL->getText("TXT_ACO_INJURED_HP",
								pDefender->currHitPoints(),
								pDefender->maxHitPoints()));
							szTempBuffer2.append(L")");
						}

						szString.append(gDLL->getText("TXT_ACO_VS", szTempBuffer.GetCString(), szTempBuffer2.GetCString()));

						if (((!(pDefender->immuneToFirstStrikes())) && (pAttacker->maxFirstStrikes() > 0)) || (pAttacker->maxCombatStr(NULL, NULL) != pAttacker->baseCombatStr() * 100))
						{
							//if attacker uninjured strength is not the same as base strength (i.e. modifiers are in effect) or first strikes exist, then
							if (getBugOptionBOOL("ACO__ShowModifierLabels", false, "ACO_SHOW_MODIFIER_LABELS"))
							{
								szString.append(gDLL->getText("TXT_ACO_ATTACKMODIFIERS"));
							}
						}//if

						if ((iView & getBugOptionINT("ACO__ShowAttackerInfo", 0, "ACO_SHOW_ATTACKER_INFO")))
						{
							szString.append(NEWLINE);
							setUnitHelp(szString, pAttacker, true, true);
						}



						szString.append(gDLL->getText("TXT_KEY_COLOR_POSITIVE"));
						szString.append(L' ');//XXX

						if (!bStealthAttack && !bStealthDefense && pAttacker->maxFirstStrikes() > 0 && !pDefender->immuneToFirstStrikes())
						{
							if (pAttacker->firstStrikes() == pAttacker->maxFirstStrikes())
							{
								szString.append(NEWLINE);
								szString.append(gDLL->getText("TXT_KEY_UNITHELP_FIRST_STRIKES", pAttacker->firstStrikes()));
							}
							else
							{
								szString.append(NEWLINE);
								szString.append(gDLL->getText("TXT_KEY_UNITHELP_FIRST_STRIKE_CHANCES", pAttacker->firstStrikes(), pAttacker->maxFirstStrikes()));
							}
						}
						if (bStealthAttack)
						{
							if (pAttacker->stealthStrikesTotal() > 0)
							{
								szString.append(NEWLINE);
								szString.append(gDLL->getText("TXT_KEY_UNIT_NUM_STEALTH_STRIKES_ATTACK", pAttacker->stealthStrikesTotal()));
							}
							if (pAttacker->stealthCombatModifierTotal() > 0)
							{
								szString.append(NEWLINE);
								szString.append(gDLL->getText("TXT_KEY_UNIT_STEALTH_COMBAT_ATTACK", pAttacker->stealthCombatModifierTotal()));
							}
						}


						iModifier = pAttacker->getExtraCombatPercent();

						if (iModifier != 0)
						{
							szString.append(NEWLINE);
							szString.append(gDLL->getText("TXT_KEY_COMBAT_PLOT_EXTRA_STRENGTH", iModifier));
						}

						szString.append(gDLL->getText("TXT_KEY_COLOR_REVERT"));
						szString.append(L' ');//XXX

						if (((!(pAttacker->immuneToFirstStrikes())) && (pDefender->maxFirstStrikes() > 0)) || (pDefender->maxCombatStr(pPlot, pAttacker) != pDefender->baseCombatStr() * 100) || bStealthDefense)
						{
							//if attacker uninjured strength is not the same as base strength (i.e. modifiers are in effect) or first strikes exist, then
							if (getBugOptionBOOL("ACO__ShowModifierLabels", false, "ACO_SHOW_MODIFIER_LABELS"))
							{
								szString.append(gDLL->getText("TXT_ACO_DEFENSEMODIFIERS"));
							}
						}

						if (iView & getBugOptionINT("ACO__ShowDefenderInfo", 3, "ACO_SHOW_DEFENDER_INFO"))
						{
							szString.append(NEWLINE);
							setUnitHelp(szString, pDefender, true, true);
						}

						if (iView & getBugOptionINT("ACO__ShowDefenseModifiers", 3, "ACO_SHOW_DEFENSE_MODIFIERS"))
						{
							//if defense modifiers are enabled - recommend leaving this on unless Total defense Modifier is enabled
							szString.append(gDLL->getText("TXT_KEY_COLOR_NEGATIVE"));

							szString.append(L' ');//XXX

							if (!bStealthAttack && !bStealthDefense && pDefender->maxFirstStrikes() > 0 && !pAttacker->immuneToFirstStrikes())
							{
								if (pDefender->firstStrikes() == pDefender->maxFirstStrikes())
								{
									szString.append(NEWLINE);
									szString.append(gDLL->getText("TXT_KEY_UNITHELP_FIRST_STRIKES", pDefender->firstStrikes()));
								}
								else
								{
									szString.append(NEWLINE);
									szString.append(gDLL->getText("TXT_KEY_UNITHELP_FIRST_STRIKE_CHANCES", pDefender->firstStrikes(), pDefender->maxFirstStrikes()));
								}
							}
							if (bStealthDefense)
							{
								if (pDefender->stealthStrikesTotal() > 0)
								{
									szString.append(NEWLINE);
									szString.append(gDLL->getText("TXT_KEY_UNIT_NUM_STEALTH_STRIKES_DEFENSE", pDefender->stealthStrikesTotal()));
								}
								if (pDefender->stealthCombatModifierTotal() > 0)
								{
									szString.append(NEWLINE);
									szString.append(gDLL->getText("TXT_KEY_UNIT_STEALTH_COMBAT_DEFENSE", pDefender->stealthCombatModifierTotal()));
								}
							}

							if (!(pAttacker->isRiver()))
							{
								if (pAttacker->plot()->isRiverCrossing(directionXY(pAttacker->plot(), pPlot)))
								{
									iModifier = GC.getRIVER_ATTACK_MODIFIER();

									if (iModifier != 0)
									{
										szString.append(NEWLINE);
										szString.append(gDLL->getText("TXT_KEY_COMBAT_PLOT_RIVER_MOD", -(iModifier)));
									}
								}
							}

							if (!(pAttacker->isAmphib()))
							{
								if (!(pPlot->isWater()) && pAttacker->plot()->isWater())
								{
									iModifier = GC.getAMPHIB_ATTACK_MODIFIER();

									if (iModifier != 0)
									{
										szString.append(NEWLINE);
										szString.append(gDLL->getText("TXT_KEY_COMBAT_PLOT_AMPHIB_MOD", -(iModifier)));
									}
								}
							}

							iModifier = pDefender->getExtraCombatPercent();

							if (iModifier != 0)
							{
								szString.append(NEWLINE);
								szString.append(gDLL->getText("TXT_KEY_COMBAT_PLOT_EXTRA_STRENGTH", iModifier));
							}
							//TB Combat Mods Begin
							if (pDefender->defenseCombatModifierTotal() != 0)
							{
								iModifier = pDefender->defenseCombatModifierTotal();

								if (iModifier != 0)
								{
									szString.append(NEWLINE);
									szString.append(gDLL->getText("TXT_KEY_COMBAT_DEFENSE_MODIFIER", iModifier));
								}
							}

							if (pDefender->isHominid())
							{
								iModifier = pAttacker->vsBarbsModifier();

								if (iModifier != 0)
								{
									szString.append(NEWLINE);
									szString.append(gDLL->getText("TXT_KEY_COMBAT_VSBARBS", iModifier));
								}
							}

							iModifier = pDefender->unitDefenseModifier(pAttacker->getUnitType());

							if (iModifier != 0)
							{
								szString.append(NEWLINE);
								szString.append(gDLL->getText("TXT_KEY_COMBAT_PLOT_MOD_VS_TYPE", iModifier, GC.getUnitInfo(pAttacker->getUnitType()).getTextKeyWide()));
							}

							for (iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
							{
								if (pAttacker->isHasUnitCombat((UnitCombatTypes)iI))
								{
									eUnitCombatType = ((UnitCombatTypes)iI);
									iModifier = pDefender->unitCombatModifier(eUnitCombatType);
									if (iModifier != 0)
									{
										szString.append(NEWLINE);
										szString.append(gDLL->getText("TXT_KEY_COMBAT_PLOT_MOD_VS_TYPE", iModifier, GC.getUnitCombatInfo(eUnitCombatType).getTextKeyWide()));
									}
								}
							}

							for (iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
							{
								if (pAttacker->isHasUnitCombat((UnitCombatTypes)iI))
								{
									eUnitCombatType = ((UnitCombatTypes)iI);
									iModifier = pDefender->withdrawVSUnitCombatTotal(eUnitCombatType);
									if (iModifier != 0)
									{
										szString.append(NEWLINE);
										szString.append(gDLL->getText("TXT_KEY_COMBAT_PLOT_WITHDRAW_VS_TYPE", iModifier, GC.getUnitCombatInfo(eUnitCombatType).getTextKeyWide()));
									}
								}
							}

							for (iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
							{
								if (pAttacker->isHasUnitCombat((UnitCombatTypes)iI))
								{
									eUnitCombatType = ((UnitCombatTypes)iI);
									iModifier = pDefender->pursuitVSUnitCombatTotal(eUnitCombatType);
									if (iModifier != 0)
									{
										szString.append(NEWLINE);
										szString.append(gDLL->getText("TXT_KEY_COMBAT_PLOT_PURSUIT_VS_TYPE", iModifier, GC.getUnitCombatInfo(eUnitCombatType).getTextKeyWide()));
									}
								}
							}

							for (iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
							{
								if (pAttacker->isHasUnitCombat((UnitCombatTypes)iI))
								{
									eUnitCombatType = ((UnitCombatTypes)iI);
									iModifier = pDefender->repelVSUnitCombatTotal(eUnitCombatType);
									if (iModifier != 0)
									{
										szString.append(NEWLINE);
										szString.append(gDLL->getText("TXT_KEY_COMBAT_PLOT_REPEL_VS_TYPE", iModifier, GC.getUnitCombatInfo(eUnitCombatType).getTextKeyWide()));
									}
								}
							}

							for (iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
							{
								if (pAttacker->isHasUnitCombat((UnitCombatTypes)iI))
								{
									eUnitCombatType = ((UnitCombatTypes)iI);
									iModifier = pDefender->knockbackVSUnitCombatTotal(eUnitCombatType);
									if (iModifier != 0)
									{
										szString.append(NEWLINE);
										szString.append(gDLL->getText("TXT_KEY_COMBAT_PLOT_KNOCKBACK_VS_TYPE", iModifier, GC.getUnitCombatInfo(eUnitCombatType).getTextKeyWide()));
									}
								}
							}

							for (iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
							{
								if (pAttacker->isHasUnitCombat((UnitCombatTypes)iI))
								{
									eUnitCombatType = ((UnitCombatTypes)iI);
									iModifier = pDefender->punctureVSUnitCombatTotal(eUnitCombatType);
									if (iModifier != 0)
									{
										szString.append(NEWLINE);
										szString.append(gDLL->getText("TXT_KEY_COMBAT_PLOT_PUNCTURE_VS_TYPE", iModifier, GC.getUnitCombatInfo(eUnitCombatType).getTextKeyWide()));
									}
								}
							}

							for (iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
							{
								if (pAttacker->isHasUnitCombat((UnitCombatTypes)iI))
								{
									eUnitCombatType = ((UnitCombatTypes)iI);
									iModifier = pDefender->armorVSUnitCombatTotal(eUnitCombatType);
									if (iModifier != 0)
									{
										szString.append(NEWLINE);
										szString.append(gDLL->getText("TXT_KEY_COMBAT_PLOT_ARMOR_VS_TYPE", iModifier, GC.getUnitCombatInfo(eUnitCombatType).getTextKeyWide()));
									}
								}
							}

							for (iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
							{
								if (pAttacker->isHasUnitCombat((UnitCombatTypes)iI))
								{
									eUnitCombatType = ((UnitCombatTypes)iI);
									iModifier = pDefender->dodgeVSUnitCombatTotal(eUnitCombatType);
									if (iModifier != 0)
									{
										szString.append(NEWLINE);
										szString.append(gDLL->getText("TXT_KEY_COMBAT_PLOT_DODGE_VS_TYPE", iModifier, GC.getUnitCombatInfo(eUnitCombatType).getTextKeyWide()));
									}
								}
							}

							for (iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
							{
								if (pAttacker->isHasUnitCombat((UnitCombatTypes)iI))
								{
									eUnitCombatType = ((UnitCombatTypes)iI);
									iModifier = pDefender->precisionVSUnitCombatTotal(eUnitCombatType);
									if (iModifier != 0)
									{
										szString.append(NEWLINE);
										szString.append(gDLL->getText("TXT_KEY_COMBAT_PLOT_PRECISION_VS_TYPE", iModifier, GC.getUnitCombatInfo(eUnitCombatType).getTextKeyWide()));
									}
								}
							}

							for (iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
							{
								if (pAttacker->isHasUnitCombat((UnitCombatTypes)iI))
								{
									eUnitCombatType = ((UnitCombatTypes)iI);
									iModifier = pDefender->criticalVSUnitCombatTotal(eUnitCombatType);
									if (iModifier != 0)
									{
										szString.append(NEWLINE);
										szString.append(gDLL->getText("TXT_KEY_COMBAT_PLOT_CRITICAL_VS_TYPE", iModifier, GC.getUnitCombatInfo(eUnitCombatType).getTextKeyWide()));
									}
								}
							}

							for (iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
							{
								if (pAttacker->isHasUnitCombat((UnitCombatTypes)iI))
								{
									eUnitCombatType = ((UnitCombatTypes)iI);
									iModifier = pDefender->roundStunVSUnitCombatTotal(eUnitCombatType);
									if (iModifier != 0)
									{
										szString.append(NEWLINE);
										szString.append(gDLL->getText("TXT_KEY_COMBAT_PLOT_ROUND_STUN_VS_TYPE", iModifier, GC.getUnitCombatInfo(eUnitCombatType).getTextKeyWide()));
									}
								}
							}

							//TB SubCombat Mod End
							iModifier = pDefender->domainModifier(pAttacker->getDomainType());

							if (iModifier != 0)
							{
								szString.append(NEWLINE);
								szString.append(gDLL->getText("TXT_KEY_COMBAT_PLOT_MOD_VS_TYPE", iModifier, GC.getDomainInfo(pAttacker->getDomainType()).getTextKeyWide()));
							}

							if (!(pDefender->noDefensiveBonus()))
							{
								iModifier = pPlot->defenseModifier(pDefender->getTeam(), (pAttacker != NULL) ? pAttacker->ignoreBuildingDefense() : true);

								if (iModifier != 0)
								{
									szString.append(NEWLINE);
									szString.append(gDLL->getText("TXT_KEY_COMBAT_PLOT_TILE_MOD", iModifier));
								}
							}
							//TB Combat Mods (Fortification) Originally iModifier = pDefender->fortifyModifier() only.
							int iFort = pDefender->fortifyModifier();
							int iOverrun = pAttacker->overrunTotal();
							int iOverrunHundred = (iOverrun > 100 ? 100 : iOverrun);
							int iOverrunTotal = 100 - (iOverrunHundred < 0 ? 0 : iOverrunHundred);
							int iFortModTotal = (iFort * iOverrunTotal) / 100;
							iModifier = iFortModTotal;
							//TB Display Mod Begin
							if (!bTBView && iModifier != 0)
							{
								szString.append(NEWLINE);
								szString.append(gDLL->getText("TXT_KEY_COMBAT_PLOT_FORTIFY_MOD", iModifier));
							}

							if (bTBView && iFort > 0)
							{
								szString.append(NEWLINE);
								szTempBuffer.Format(SETCOLR L"Fortification Mod: %d%" ENDCOLR,
									TEXT_COLOR("COLOR_RED"), iFort);
								szString.append(szTempBuffer.GetCString());
								if (iOverrun > 0)
								{
									szString.append(NEWLINE);
									szTempBuffer.Format(SETCOLR L"Attacker Overrun: %d" ENDCOLR,
										TEXT_COLOR("COLOR_RED"), iOverrun);
									szString.append(NEWLINE);
									szString.append(szTempBuffer.GetCString());
									szTempBuffer.Format(SETCOLR L"Total Fortification: %d%" ENDCOLR,
										TEXT_COLOR("COLOR_RED"), iModifier);
									szString.append(szTempBuffer.GetCString());
								}
							}
							//TB Display Mod end
							//TB Combat Mods end
							if (pPlot->isCity(true, pDefender->getTeam()) && pAttacker->plot() != pPlot)
							{
								iModifier = pDefender->cityDefenseModifier();

								if (iModifier != 0)
								{
									szString.append(NEWLINE);
									szString.append(gDLL->getText("TXT_KEY_COMBAT_PLOT_CITY_MOD", iModifier));
								}
							}

							if (pPlot->isHills())
							{
								iModifier = pDefender->hillsDefenseModifier();

								if (iModifier != 0)
								{
									szString.append(NEWLINE);
									szString.append(gDLL->getText("TXT_KEY_COMBAT_PLOT_HILLS_MOD", iModifier));
								}
							}

							if (pPlot->getFeatureType() != NO_FEATURE)
							{
								iModifier = pDefender->featureDefenseModifier(pPlot->getFeatureType());

								if (iModifier != 0)
								{
									szString.append(NEWLINE);
									szString.append(gDLL->getText("TXT_KEY_COMBAT_PLOT_UNIT_MOD", iModifier, GC.getFeatureInfo(pPlot->getFeatureType()).getTextKeyWide()));
								}
							}

							iModifier = pDefender->terrainDefenseModifier(pPlot->getTerrainType());

							if (iModifier != 0)
							{
								szString.append(NEWLINE);
								szString.append(gDLL->getText("TXT_KEY_COMBAT_PLOT_UNIT_MOD", iModifier, GC.getTerrainInfo(pPlot->getTerrainType()).getTextKeyWide()));
							}

							szString.append(gDLL->getText("TXT_KEY_COLOR_REVERT"));

							szString.append(L' ');//XXX

							szString.append(gDLL->getText("TXT_KEY_COLOR_POSITIVE"));

							szString.append(L' ');//XXX


							iModifier = pAttacker->unitAttackModifier(pDefender->getUnitType());

							if (iModifier != 0)
							{
								szString.append(NEWLINE);
								szString.append(gDLL->getText("TXT_KEY_COMBAT_PLOT_MOD_VS_TYPE", -iModifier, GC.getUnitInfo(pDefender->getUnitType()).getTextKeyWide()));
							}
							//TB Combat Mods Begin
							if (pAttacker->attackCombatModifierTotal() != 0)
							{
								iModifier = pAttacker->attackCombatModifierTotal();

								if (iModifier != 0)
								{
									szString.append(NEWLINE);
									szString.append(gDLL->getText("TXT_KEY_COMBAT_ATTACK_MODIFIER", iModifier));
								}
							}

							int iOffset = 0;
							int iPerTotal = 0;
							iOffset = pDefender->sizeRank() - pAttacker->sizeRank();
							if (pAttacker->combatModifierPerSizeMoreTotal() != 0 && iOffset > 0)
							{
								iPerTotal = pAttacker->combatModifierPerSizeMoreTotal() * iOffset;
								iModifier = -iPerTotal;

								if (iModifier != 0)
								{
									szString.append(NEWLINE);
									szString.append(gDLL->getText("TXT_KEY_COMBAT_ATTACK_FROM_SIZE_MODIFIER", iModifier));
								}
							}

							iOffset = 0;
							iPerTotal = 0;
							iOffset = pDefender->groupRank() - pAttacker->groupRank();
							if (pAttacker->combatModifierPerVolumeMoreTotal() != 0 && iOffset > 0)
							{
								iPerTotal = pAttacker->combatModifierPerVolumeMoreTotal() * iOffset;
								iModifier = -iPerTotal;

								if (iModifier != 0)
								{
									szString.append(NEWLINE);
									szString.append(gDLL->getText("TXT_KEY_COMBAT_ATTACK_FROM_VOLUME_MODIFIER", iModifier));
								}
							}

							iOffset = 0;
							iPerTotal = 0;
							iOffset = pDefender->sizeRank() - pAttacker->sizeRank();
							if (pAttacker->combatModifierPerSizeLessTotal() != 0 && iOffset < 0)
							{
								iPerTotal = pAttacker->combatModifierPerSizeLessTotal() * -iOffset;
								iModifier = -iPerTotal;

								if (iModifier != 0)
								{
									szString.append(NEWLINE);
									szString.append(gDLL->getText("TXT_KEY_COMBAT_ATTACK_FROM_SIZE_MODIFIER", iModifier));
								}
							}

							iOffset = 0;
							iPerTotal = 0;
							iOffset = pDefender->groupRank() - pAttacker->groupRank();
							if (pAttacker->combatModifierPerVolumeLessTotal() != 0 && iOffset < 0)
							{
								iPerTotal = pAttacker->combatModifierPerVolumeLessTotal() * -iOffset;
								iModifier = -iPerTotal;

								if (iModifier != 0)
								{
									szString.append(NEWLINE);
									szString.append(gDLL->getText("TXT_KEY_COMBAT_ATTACK_FROM_VOLUME_MODIFIER", iModifier));
								}
							}

							if (pAttacker->isHominid())
							{
								iModifier = pDefender->vsBarbsModifier();

								if (iModifier != 0)
								{
									szString.append(NEWLINE);
									szString.append(gDLL->getText("TXT_KEY_COMBAT_VSBARBS", iModifier));
								}
							}

							for (iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
							{
								if (pDefender->isHasUnitCombat((UnitCombatTypes)iI))
								{
									eUnitCombatType = ((UnitCombatTypes)iI);
									iModifier = pAttacker->unitCombatModifier(eUnitCombatType);
									if (iModifier != 0)
									{
										szString.append(NEWLINE);
										szString.append(gDLL->getText("TXT_KEY_COMBAT_PLOT_MOD_VS_TYPE", iModifier, GC.getUnitCombatInfo(eUnitCombatType).getTextKeyWide()));
									}
								}
							}

							for (iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
							{
								if (pDefender->isHasUnitCombat((UnitCombatTypes)iI))
								{
									eUnitCombatType = ((UnitCombatTypes)iI);
									iModifier = pAttacker->withdrawVSUnitCombatTotal(eUnitCombatType);
									if (iModifier != 0)
									{
										szString.append(NEWLINE);
										szString.append(gDLL->getText("TXT_KEY_COMBAT_PLOT_WITHDRAW_VS_TYPE", iModifier, GC.getUnitCombatInfo(eUnitCombatType).getTextKeyWide()));
									}
								}
							}

							for (iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
							{
								if (pDefender->isHasUnitCombat((UnitCombatTypes)iI))
								{
									eUnitCombatType = ((UnitCombatTypes)iI);
									iModifier = pAttacker->pursuitVSUnitCombatTotal(eUnitCombatType);
									if (iModifier != 0)
									{
										szString.append(NEWLINE);
										szString.append(gDLL->getText("TXT_KEY_COMBAT_PLOT_PURSUIT_VS_TYPE", iModifier, GC.getUnitCombatInfo(eUnitCombatType).getTextKeyWide()));
									}
								}
							}

							for (iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
							{
								if (pDefender->isHasUnitCombat((UnitCombatTypes)iI))
								{
									eUnitCombatType = ((UnitCombatTypes)iI);
									iModifier = pAttacker->repelVSUnitCombatTotal(eUnitCombatType);
									if (iModifier != 0)
									{
										szString.append(NEWLINE);
										szString.append(gDLL->getText("TXT_KEY_COMBAT_PLOT_REPEL_VS_TYPE", iModifier, GC.getUnitCombatInfo(eUnitCombatType).getTextKeyWide()));
									}
								}
							}

							for (iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
							{
								if (pDefender->isHasUnitCombat((UnitCombatTypes)iI))
								{
									eUnitCombatType = ((UnitCombatTypes)iI);
									iModifier = pAttacker->knockbackVSUnitCombatTotal(eUnitCombatType);
									if (iModifier != 0)
									{
										szString.append(NEWLINE);
										szString.append(gDLL->getText("TXT_KEY_COMBAT_PLOT_KNOCKBACK_VS_TYPE", iModifier, GC.getUnitCombatInfo(eUnitCombatType).getTextKeyWide()));
									}
								}
							}

							for (iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
							{
								if (pDefender->isHasUnitCombat((UnitCombatTypes)iI))
								{
									eUnitCombatType = ((UnitCombatTypes)iI);
									iModifier = pAttacker->punctureVSUnitCombatTotal(eUnitCombatType);
									if (iModifier != 0)
									{
										szString.append(NEWLINE);
										szString.append(gDLL->getText("TXT_KEY_COMBAT_PLOT_PUNCTURE_VS_TYPE", iModifier, GC.getUnitCombatInfo(eUnitCombatType).getTextKeyWide()));
									}
								}
							}

							for (iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
							{
								if (pDefender->isHasUnitCombat((UnitCombatTypes)iI))
								{
									eUnitCombatType = ((UnitCombatTypes)iI);
									iModifier = pAttacker->armorVSUnitCombatTotal(eUnitCombatType);
									if (iModifier != 0)
									{
										szString.append(NEWLINE);
										szString.append(gDLL->getText("TXT_KEY_COMBAT_PLOT_ARMOR_VS_TYPE", iModifier, GC.getUnitCombatInfo(eUnitCombatType).getTextKeyWide()));
									}
								}
							}

							for (iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
							{
								if (pDefender->isHasUnitCombat((UnitCombatTypes)iI))
								{
									eUnitCombatType = ((UnitCombatTypes)iI);
									iModifier = pAttacker->dodgeVSUnitCombatTotal(eUnitCombatType);
									if (iModifier != 0)
									{
										szString.append(NEWLINE);
										szString.append(gDLL->getText("TXT_KEY_COMBAT_PLOT_DODGE_VS_TYPE", iModifier, GC.getUnitCombatInfo(eUnitCombatType).getTextKeyWide()));
									}
								}
							}

							for (iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
							{
								if (pDefender->isHasUnitCombat((UnitCombatTypes)iI))
								{
									eUnitCombatType = ((UnitCombatTypes)iI);
									iModifier = pAttacker->precisionVSUnitCombatTotal(eUnitCombatType);
									if (iModifier != 0)
									{
										szString.append(NEWLINE);
										szString.append(gDLL->getText("TXT_KEY_COMBAT_PLOT_PRECISION_VS_TYPE", iModifier, GC.getUnitCombatInfo(eUnitCombatType).getTextKeyWide()));
									}
								}
							}

							for (iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
							{
								if (pDefender->isHasUnitCombat((UnitCombatTypes)iI))
								{
									eUnitCombatType = ((UnitCombatTypes)iI);
									iModifier = pAttacker->criticalVSUnitCombatTotal(eUnitCombatType);
									if (iModifier != 0)
									{
										szString.append(NEWLINE);
										szString.append(gDLL->getText("TXT_KEY_COMBAT_PLOT_CRITICAL_VS_TYPE", iModifier, GC.getUnitCombatInfo(eUnitCombatType).getTextKeyWide()));
									}
								}
							}

							for (iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
							{
								if (pDefender->isHasUnitCombat((UnitCombatTypes)iI))
								{
									eUnitCombatType = ((UnitCombatTypes)iI);
									iModifier = pAttacker->roundStunVSUnitCombatTotal(eUnitCombatType);
									if (iModifier != 0)
									{
										szString.append(NEWLINE);
										szString.append(gDLL->getText("TXT_KEY_COMBAT_PLOT_ROUND_STUN_VS_TYPE", iModifier, GC.getUnitCombatInfo(eUnitCombatType).getTextKeyWide()));
									}
								}
							}
							//TB SubCombat Mod End
							iModifier = pAttacker->domainModifier(pDefender->getDomainType());

							if (iModifier != 0)
							{
								szString.append(NEWLINE);
								szString.append(gDLL->getText("TXT_KEY_COMBAT_PLOT_MOD_VS_TYPE", -iModifier, GC.getDomainInfo(pDefender->getDomainType()).getTextKeyWide()));
							}

							if (pPlot->isCity(true, pDefender->getTeam()))
							{
								iModifier = pAttacker->cityAttackModifier();

								if (iModifier != 0)
								{
									szString.append(NEWLINE);
									szString.append(gDLL->getText("TXT_KEY_COMBAT_PLOT_CITY_MOD", -iModifier));
								}
							}

							if (pPlot->isHills())
							{
								iModifier = pAttacker->hillsAttackModifier();

								if (iModifier != 0)
								{
									szString.append(NEWLINE);
									szString.append(gDLL->getText("TXT_KEY_COMBAT_PLOT_HILLS_MOD", -iModifier));
								}
							}

							if (pPlot->getFeatureType() != NO_FEATURE)
							{
								iModifier = pAttacker->featureAttackModifier(pPlot->getFeatureType());

								if (iModifier != 0)
								{
									szString.append(NEWLINE);
									szString.append(gDLL->getText("TXT_KEY_COMBAT_PLOT_UNIT_MOD", -iModifier, GC.getFeatureInfo(pPlot->getFeatureType()).getTextKeyWide()));
								}
							}
							else
							{
								iModifier = pAttacker->terrainAttackModifier(pPlot->getTerrainType());

								if (iModifier != 0)
								{
									szString.append(NEWLINE);
									szString.append(gDLL->getText("TXT_KEY_COMBAT_PLOT_UNIT_MOD", -iModifier, GC.getTerrainInfo(pPlot->getTerrainType()).getTextKeyWide()));
								}
							}

							iModifier = pAttacker->getKamikazePercent();
							if (iModifier != 0)
							{
								szString.append(NEWLINE);
								szString.append(gDLL->getText("TXT_KEY_COMBAT_KAMIKAZE_MOD", -iModifier));
							}

							if (GC.getGame().isOption(GAMEOPTION_SAD))
							{
								//TB Combat Mods (S&D promos)
								int iSurround = pAttacker->surroundedDefenseModifier(pPlot, pDefender);
								int iDynamicDefense = pDefender->dynamicDefenseTotal();
								int iDynamicDefenseModifier = ((iSurround * iDynamicDefense) / 100);
								int iSurroundTotalstepone = iSurround - iDynamicDefenseModifier;
								int iSurroundTotal = (iSurroundTotalstepone < 0 ? 0 : iSurroundTotalstepone);

								iModifier = iSurroundTotal;
								if (iModifier != 0)
								{
									szString.append(NEWLINE);
									szString.append(gDLL->getText("TXT_KEY_COMBAT_SURROUNDED_DEFENSE_MOD", -iModifier));
								}
							}

							if (pDefender->isAnimal())
							{
								iModifier = -GC.getHandicapInfo(GC.getGame().getHandicapType()).getAnimalCombatModifier();

								iModifier += pAttacker->getUnitInfo().getAnimalCombatModifier();

								if (iModifier != 0)
								{
									szString.append(NEWLINE);
									szString.append(gDLL->getText("TXT_KEY_UNIT_ANIMAL_COMBAT_MOD", -iModifier));
								}
							}

							if (pDefender->isHominid())
							{
								iModifier = -GC.getHandicapInfo(GC.getGame().getHandicapType()).getBarbarianCombatModifier();

								if (iModifier != 0)
								{
									szString.append(NEWLINE);
									szString.append(gDLL->getText("TXT_KEY_UNIT_BARBARIAN_COMBAT_MOD", -iModifier));
								}
							}
						}//if

						szString.append(gDLL->getText("TXT_KEY_COLOR_REVERT"));

						szString.append(L' ');//XXX

						if (iView & getBugOptionINT("ACO__ShowTotalDefenseModifier", 2, "ACO_SHOW_TOTAL_DEFENSE_MODIFIER"))
						{
							//szString.append(L' ');//XXX
							if (pDefender->maxCombatStr(pPlot, pAttacker) > pDefender->baseCombatStr() * 100) // modifier is positive
							{
								szTempBuffer.Format(SETCOLR L"%d%%" ENDCOLR,
									TEXT_COLOR("COLOR_NEGATIVE_TEXT"), (((pDefender->maxCombatStr(pPlot, pAttacker))) / pDefender->baseCombatStr()) - 100);
							}
							else   // modifier is negative
							{
								szTempBuffer.Format(SETCOLR L"%d%%" ENDCOLR,
									TEXT_COLOR("COLOR_POSITIVE_TEXT"), (100 - ((pDefender->baseCombatStr() * 100) / (pDefender->maxCombatStr(pPlot, pAttacker)))));
							}

							szString.append(gDLL->getText("TXT_ACO_TOTALDEFENSEMODIFIER"));
							szString.append(szTempBuffer.GetCString());
						}
					}
					/** What follows in the "else" block, is the original code **/
					else
					{
						//ACO is not enabled
						szOffenseOdds.Format(L"%.2f", ((pAttacker->getDomainType() == DOMAIN_AIR) ? pAttacker->airCurrCombatStrFloat(pDefender) : pAttacker->currCombatStrFloat(NULL, NULL)));
						szDefenseOdds.Format(L"%.2f", pDefender->currCombatStrFloat(pPlot, pAttacker));
						szString.append(NEWLINE);
						szString.append(gDLL->getText("TXT_KEY_COMBAT_PLOT_ODDS_VS", szOffenseOdds.GetCString(), szDefenseOdds.GetCString()));

						szString.append(L' ');//XXX

						szString.append(gDLL->getText("TXT_KEY_COLOR_POSITIVE"));

						szString.append(L' ');//XXX

						addModifierIfValid(szString, pAttacker->getExtraCombatPercent(), "TXT_KEY_COMBAT_PLOT_EXTRA_STRENGTH");
						addModifierWithInfoIfValid(szString, pAttacker->unitAttackModifier(pDefender->getUnitType()), "TXT_KEY_COMBAT_PLOT_MOD_VS_TYPE", GC.getUnitInfo(pDefender->getUnitType()));

						//TB Combat Mods Begin
						addModifierIfValid(szString, pDefender->defenseCombatModifierTotal(), "TXT_KEY_COMBAT_DEFENSE_MODIFIER");
						addCombatModifierHint(szString, pDefender->combatModifierPerSizeMoreTotal(), pAttacker->sizeRank() - pDefender->sizeRank(), "TXT_KEY_COMBAT_ATTACK_FROM_SIZE_MODIFIER");
						addCombatModifierHint(szString, pDefender->combatModifierPerVolumeMoreTotal(), pAttacker->groupRank() - pDefender->groupRank(), "TXT_KEY_COMBAT_ATTACK_FROM_VOLUME_MODIFIER");
						addCombatModifierHint(szString, pDefender->combatModifierPerSizeLessTotal(), pDefender->sizeRank() - pAttacker->sizeRank(), "TXT_KEY_COMBAT_ATTACK_FROM_SIZE_MODIFIER");
						addCombatModifierHint(szString, pDefender->combatModifierPerVolumeLessTotal(), pDefender->groupRank() - pAttacker->groupRank(), "TXT_KEY_COMBAT_ATTACK_FROM_VOLUME_MODIFIER");
						if (pDefender->isHominid())
						{
							addModifierIfValid(szString, pAttacker->vsBarbsModifier(), "TXT_KEY_COMBAT_VSBARBS");
						}
						addCombatTypeModifierHints(szString, pDefender, pAttacker, &CvUnit::unitCombatModifier, "TXT_KEY_COMBAT_PLOT_MOD_VS_TYPE");
						addCombatTypeModifierHints(szString, pDefender, pAttacker, &CvUnit::withdrawVSUnitCombatTotal, "TXT_KEY_COMBAT_PLOT_WITHDRAW_VS_TYPE");
						addCombatTypeModifierHints(szString, pDefender, pAttacker, &CvUnit::pursuitVSUnitCombatTotal, "TXT_KEY_COMBAT_PLOT_PURSUIT_VS_TYPE");
						addCombatTypeModifierHints(szString, pDefender, pAttacker, &CvUnit::repelVSUnitCombatTotal, "TXT_KEY_COMBAT_PLOT_REPEL_VS_TYPE");
						addCombatTypeModifierHints(szString, pDefender, pAttacker, &CvUnit::knockbackVSUnitCombatTotal, "TXT_KEY_COMBAT_PLOT_KNOCKBACK_VS_TYPE");
						addCombatTypeModifierHints(szString, pDefender, pAttacker, &CvUnit::punctureVSUnitCombatTotal, "TXT_KEY_COMBAT_PLOT_PUNCTURE_VS_TYPE");
						addCombatTypeModifierHints(szString, pDefender, pAttacker, &CvUnit::armorVSUnitCombatTotal, "TXT_KEY_COMBAT_PLOT_ARMOR_VS_TYPE");
						addCombatTypeModifierHints(szString, pDefender, pAttacker, &CvUnit::dodgeVSUnitCombatTotal, "TXT_KEY_COMBAT_PLOT_DODGE_VS_TYPE");
						addCombatTypeModifierHints(szString, pDefender, pAttacker, &CvUnit::precisionVSUnitCombatTotal, "TXT_KEY_COMBAT_PLOT_PRECISION_VS_TYPE");
						addCombatTypeModifierHints(szString, pDefender, pAttacker, &CvUnit::criticalVSUnitCombatTotal, "TXT_KEY_COMBAT_PLOT_CRITICAL_VS_TYPE");
						addCombatTypeModifierHints(szString, pDefender, pAttacker, &CvUnit::roundStunVSUnitCombatTotal, "TXT_KEY_COMBAT_PLOT_ROUND_STUN_VS_TYPE");
						//TB SubCombat Mod End

						addModifierWithInfoIfValid(szString, pAttacker->domainModifier(pDefender->getDomainType()), "TXT_KEY_COMBAT_PLOT_MOD_VS_TYPE", GC.getDomainInfo(pDefender->getDomainType()));

						if (pPlot->isCity(true, pDefender->getTeam()))
						{
							addModifierIfValid(szString, pAttacker->cityAttackModifier(), "TXT_KEY_COMBAT_PLOT_CITY_MOD");
						}
						if (pPlot->isHills())
						{
							addModifierIfValid(szString, pAttacker->hillsAttackModifier(), "TXT_KEY_COMBAT_PLOT_HILLS_MOD");
						}
						if (pPlot->getFeatureType() != NO_FEATURE)
						{
							addModifierWithInfoIfValid(szString, pAttacker->featureAttackModifier(pPlot->getFeatureType()), "TXT_KEY_COMBAT_PLOT_UNIT_MOD", GC.getFeatureInfo(pPlot->getFeatureType()));
						}
						else
						{
							addModifierWithInfoIfValid(szString, pAttacker->terrainAttackModifier(pPlot->getTerrainType()), "TXT_KEY_COMBAT_PLOT_UNIT_MOD", GC.getTerrainInfo(pPlot->getTerrainType()));
						}

						addModifierIfValid(szString, pAttacker->getKamikazePercent(), "TXT_KEY_COMBAT_KAMIKAZE_MOD");

						if (GC.getGame().isOption(GAMEOPTION_SAD))
						{
							//TB Combat Mods (S&D promos)
							int iSurround = pAttacker->surroundedDefenseModifier(pPlot, pDefender);
							int iDynamicDefense = pDefender->dynamicDefenseTotal();
							int iDynamicDefenseModifier = ((iSurround * iDynamicDefense) / 100);
							int iSurroundTotalstepone = iSurround - iDynamicDefenseModifier;
							int iSurroundTotal = (iSurroundTotalstepone < 0 ? 0 : iSurroundTotalstepone);

							iModifier = iSurroundTotal;
							if (iModifier != 0)
							{
								szString.append(NEWLINE);
								szString.append(gDLL->getText("TXT_KEY_COMBAT_SURROUNDED_DEFENSE_MOD", iModifier));
							}
						}

						if (pDefender->isAnimal())
						{
							iModifier = -GC.getHandicapInfo(GC.getGame().getHandicapType()).getAnimalCombatModifier();

							iModifier += pAttacker->getUnitInfo().getAnimalCombatModifier();

							if (iModifier != 0)
							{
								szString.append(NEWLINE);
								szString.append(gDLL->getText("TXT_KEY_UNIT_ANIMAL_COMBAT_MOD", iModifier));
							}
						}

						if (pDefender->isHominid())
						{
							iModifier = -GC.getHandicapInfo(GC.getGame().getHandicapType()).getBarbarianCombatModifier();

							if (iModifier != 0)
							{
								szString.append(NEWLINE);
								szString.append(gDLL->getText("TXT_KEY_UNIT_BARBARIAN_COMBAT_MOD", iModifier));
							}
						}

						if (!pDefender->immuneToFirstStrikes() && pAttacker->maxFirstStrikes() > 0)
						{
							if (pAttacker->firstStrikes() == pAttacker->maxFirstStrikes())
							{
								szString.append(NEWLINE);
								szString.append(gDLL->getText("TXT_KEY_UNITHELP_FIRST_STRIKES", pAttacker->firstStrikes()));
							}
							else
							{
								szString.append(NEWLINE);
								szString.append(gDLL->getText("TXT_KEY_UNITHELP_FIRST_STRIKE_CHANCES", pAttacker->firstStrikes(), pAttacker->maxFirstStrikes()));
							}
						}

						if (pAttacker->isHurt())
						{
							szString.append(NEWLINE);
							szString.append(gDLL->getText("TXT_KEY_COMBAT_PLOT_HP", pAttacker->currHitPoints(), pAttacker->maxHitPoints()));
						}

						szString.append(gDLL->getText("TXT_KEY_COLOR_REVERT"));

						szString.append(L' ');//XXX

						szString.append(gDLL->getText("TXT_KEY_COLOR_NEGATIVE"));

						szString.append(L' ');//XXX

						if (!(pAttacker->isRiver()))
						{
							if (pAttacker->plot()->isRiverCrossing(directionXY(pAttacker->plot(), pPlot)))
							{
								iModifier = GC.getRIVER_ATTACK_MODIFIER();

								if (iModifier != 0)
								{
									szString.append(NEWLINE);
									szString.append(gDLL->getText("TXT_KEY_COMBAT_PLOT_RIVER_MOD", -(iModifier)));
								}
							}
						}

						if (!(pAttacker->isAmphib()))
						{
							if (!(pPlot->isWater()) && pAttacker->plot()->isWater())
							{
								iModifier = GC.getAMPHIB_ATTACK_MODIFIER();

								if (iModifier != 0)
								{
									szString.append(NEWLINE);
									szString.append(gDLL->getText("TXT_KEY_COMBAT_PLOT_AMPHIB_MOD", -(iModifier)));
								}
							}
						}

						iModifier = pDefender->getExtraCombatPercent();

						if (iModifier != 0)
						{
							szString.append(NEWLINE);
							szString.append(gDLL->getText("TXT_KEY_COMBAT_PLOT_EXTRA_STRENGTH", iModifier));
						}

						iModifier = pDefender->unitDefenseModifier(pAttacker->getUnitType());

						if (iModifier != 0)
						{
							szString.append(NEWLINE);
							szString.append(gDLL->getText("TXT_KEY_COMBAT_PLOT_MOD_VS_TYPE", iModifier, GC.getUnitInfo(pAttacker->getUnitType()).getTextKeyWide()));
						}
						//TB Combat Mods Begin

						if (pAttacker->attackCombatModifierTotal() != 0)
						{
							iModifier = pAttacker->attackCombatModifierTotal();

							if (iModifier != 0)
							{
								szString.append(NEWLINE);
								szString.append(gDLL->getText("TXT_KEY_COMBAT_DEFENSE_MODIFIER", iModifier));
							}
						}

						if (pAttacker->isHominid())
						{
							iModifier = pDefender->vsBarbsModifier();
							if (iModifier != 0)
							{
								szString.append(NEWLINE);
								szString.append(gDLL->getText("TXT_KEY_COMBAT_VSBARBS", iModifier));
							}
						}

						for (iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
						{
							if (pAttacker->isHasUnitCombat((UnitCombatTypes)iI))
							{
								eUnitCombatType = ((UnitCombatTypes)iI);
								iModifier = pDefender->unitCombatModifier(eUnitCombatType);
								if (iModifier != 0)
								{
									szString.append(NEWLINE);
									szString.append(gDLL->getText("TXT_KEY_COMBAT_PLOT_MOD_VS_TYPE", iModifier, GC.getUnitCombatInfo(eUnitCombatType).getTextKeyWide()));
								}
							}
						}

						for (iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
						{
							if (pAttacker->isHasUnitCombat((UnitCombatTypes)iI))
							{
								eUnitCombatType = ((UnitCombatTypes)iI);
								iModifier = pDefender->withdrawVSUnitCombatTotal(eUnitCombatType);
								if (iModifier != 0)
								{
									szString.append(NEWLINE);
									szString.append(gDLL->getText("TXT_KEY_COMBAT_PLOT_WITHDRAW_VS_TYPE", iModifier, GC.getUnitCombatInfo(eUnitCombatType).getTextKeyWide()));
								}
							}
						}

						for (iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
						{
							if (pAttacker->isHasUnitCombat((UnitCombatTypes)iI))
							{
								eUnitCombatType = ((UnitCombatTypes)iI);
								iModifier = pDefender->pursuitVSUnitCombatTotal(eUnitCombatType);
								if (iModifier != 0)
								{
									szString.append(NEWLINE);
									szString.append(gDLL->getText("TXT_KEY_COMBAT_PLOT_PURSUIT_VS_TYPE", iModifier, GC.getUnitCombatInfo(eUnitCombatType).getTextKeyWide()));
								}
							}
						}

						for (iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
						{
							if (pAttacker->isHasUnitCombat((UnitCombatTypes)iI))
							{
								eUnitCombatType = ((UnitCombatTypes)iI);
								iModifier = pDefender->repelVSUnitCombatTotal(eUnitCombatType);
								if (iModifier != 0)
								{
									szString.append(NEWLINE);
									szString.append(gDLL->getText("TXT_KEY_COMBAT_PLOT_REPEL_VS_TYPE", iModifier, GC.getUnitCombatInfo(eUnitCombatType).getTextKeyWide()));
								}
							}
						}

						for (iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
						{
							if (pAttacker->isHasUnitCombat((UnitCombatTypes)iI))
							{
								eUnitCombatType = ((UnitCombatTypes)iI);
								iModifier = pDefender->knockbackVSUnitCombatTotal(eUnitCombatType);
								if (iModifier != 0)
								{
									szString.append(NEWLINE);
									szString.append(gDLL->getText("TXT_KEY_COMBAT_PLOT_KNOCKBACK_VS_TYPE", iModifier, GC.getUnitCombatInfo(eUnitCombatType).getTextKeyWide()));
								}
							}
						}

						for (iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
						{
							if (pAttacker->isHasUnitCombat((UnitCombatTypes)iI))
							{
								eUnitCombatType = ((UnitCombatTypes)iI);
								iModifier = pDefender->punctureVSUnitCombatTotal(eUnitCombatType);
								if (iModifier != 0)
								{
									szString.append(NEWLINE);
									szString.append(gDLL->getText("TXT_KEY_COMBAT_PLOT_PUNCTURE_VS_TYPE", iModifier, GC.getUnitCombatInfo(eUnitCombatType).getTextKeyWide()));
								}
							}
						}

						for (iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
						{
							if (pAttacker->isHasUnitCombat((UnitCombatTypes)iI))
							{
								eUnitCombatType = ((UnitCombatTypes)iI);
								iModifier = pDefender->armorVSUnitCombatTotal(eUnitCombatType);
								if (iModifier != 0)
								{
									szString.append(NEWLINE);
									szString.append(gDLL->getText("TXT_KEY_COMBAT_PLOT_ARMOR_VS_TYPE", iModifier, GC.getUnitCombatInfo(eUnitCombatType).getTextKeyWide()));
								}
							}
						}

						for (iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
						{
							if (pAttacker->isHasUnitCombat((UnitCombatTypes)iI))
							{
								eUnitCombatType = ((UnitCombatTypes)iI);
								iModifier = pDefender->dodgeVSUnitCombatTotal(eUnitCombatType);
								if (iModifier != 0)
								{
									szString.append(NEWLINE);
									szString.append(gDLL->getText("TXT_KEY_COMBAT_PLOT_DODGE_VS_TYPE", iModifier, GC.getUnitCombatInfo(eUnitCombatType).getTextKeyWide()));
								}
							}
						}

						for (iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
						{
							if (pAttacker->isHasUnitCombat((UnitCombatTypes)iI))
							{
								eUnitCombatType = ((UnitCombatTypes)iI);
								iModifier = pDefender->precisionVSUnitCombatTotal(eUnitCombatType);
								if (iModifier != 0)
								{
									szString.append(NEWLINE);
									szString.append(gDLL->getText("TXT_KEY_COMBAT_PLOT_PRECISION_VS_TYPE", iModifier, GC.getUnitCombatInfo(eUnitCombatType).getTextKeyWide()));
								}
							}
						}

						for (iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
						{
							if (pAttacker->isHasUnitCombat((UnitCombatTypes)iI))
							{
								eUnitCombatType = ((UnitCombatTypes)iI);
								iModifier = pDefender->criticalVSUnitCombatTotal(eUnitCombatType);
								if (iModifier != 0)
								{
									szString.append(NEWLINE);
									szString.append(gDLL->getText("TXT_KEY_COMBAT_PLOT_CRITICAL_VS_TYPE", iModifier, GC.getUnitCombatInfo(eUnitCombatType).getTextKeyWide()));
								}
							}
						}

						for (iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
						{
							if (pAttacker->isHasUnitCombat((UnitCombatTypes)iI))
							{
								eUnitCombatType = ((UnitCombatTypes)iI);
								iModifier = pDefender->roundStunVSUnitCombatTotal(eUnitCombatType);
								if (iModifier != 0)
								{
									szString.append(NEWLINE);
									szString.append(gDLL->getText("TXT_KEY_COMBAT_PLOT_ROUND_STUN_VS_TYPE", iModifier, GC.getUnitCombatInfo(eUnitCombatType).getTextKeyWide()));
								}
							}
						}
						//TB SubCombat Mod End
						iModifier = pDefender->domainModifier(pAttacker->getDomainType());

						if (iModifier != 0)
						{
							szString.append(NEWLINE);
							szString.append(gDLL->getText("TXT_KEY_COMBAT_PLOT_MOD_VS_TYPE", iModifier, GC.getDomainInfo(pAttacker->getDomainType()).getTextKeyWide()));
						}

						if (!(pDefender->noDefensiveBonus()))
						{
							iModifier = pPlot->defenseModifier(pDefender->getTeam(), (pAttacker != NULL) ? pAttacker->ignoreBuildingDefense() : true);

							if (iModifier != 0)
							{
								szString.append(NEWLINE);
								szString.append(gDLL->getText("TXT_KEY_COMBAT_PLOT_TILE_MOD", iModifier));
							}
						}
						//TB Combat Mods (Fortification) Originally iModifier = pDefender->fortifyModifier() only.
						int iFort = pDefender->fortifyModifier();
						int iOverrun = pAttacker->overrunTotal();
						int iOverrunHundred = (iOverrun > 100 ? 100 : iOverrun);
						int iOverrunTotal = 100 - (iOverrunHundred < 0 ? 0 : iOverrunHundred);
						int iFortModTotal = (iFort * iOverrunTotal) / 100;
						iModifier = iFortModTotal;
						//TB Display Mod begin
						if (!bTBView && iModifier != 0)
						{
							szString.append(NEWLINE);
							szString.append(gDLL->getText("TXT_KEY_COMBAT_PLOT_FORTIFY_MOD", iModifier));
						}

						if (bTBView && iFort > 0)
						{
							szString.append(NEWLINE);
							szTempBuffer.Format(SETCOLR L"Fortification Mod: %d%" ENDCOLR,
								TEXT_COLOR("COLOR_RED"), iFort);
							szString.append(szTempBuffer.GetCString());
							if (iOverrun > 0)
							{
								szString.append(NEWLINE);
								szTempBuffer.Format(SETCOLR L"Attacker Overrun: %d" ENDCOLR,
									TEXT_COLOR("COLOR_RED"), iOverrun);
								szString.append(NEWLINE);
								szString.append(szTempBuffer.GetCString());
								szTempBuffer.Format(SETCOLR L"Total Fortification: %d%" ENDCOLR,
									TEXT_COLOR("COLOR_RED"), iModifier);
								szString.append(szTempBuffer.GetCString());
							}
						}
						//TB Display Mod end
						//TB Combat Mods end

						if (pPlot->isCity(true, pDefender->getTeam()) && pAttacker->plot() != pPlot)
						{
							iModifier = pDefender->cityDefenseModifier();

							if (iModifier != 0)
							{
								szString.append(NEWLINE);
								szString.append(gDLL->getText("TXT_KEY_COMBAT_PLOT_CITY_MOD", iModifier));
							}
						}

						if (pPlot->isHills())
						{
							iModifier = pDefender->hillsDefenseModifier();

							if (iModifier != 0)
							{
								szString.append(NEWLINE);
								szString.append(gDLL->getText("TXT_KEY_COMBAT_PLOT_HILLS_MOD", iModifier));
							}
						}

						if (pPlot->getFeatureType() != NO_FEATURE)
						{
							iModifier = pDefender->featureDefenseModifier(pPlot->getFeatureType());

							if (iModifier != 0)
							{
								szString.append(NEWLINE);
								szString.append(gDLL->getText("TXT_KEY_COMBAT_PLOT_UNIT_MOD", iModifier, GC.getFeatureInfo(pPlot->getFeatureType()).getTextKeyWide()));
							}
						}
						else
						{
							iModifier = pDefender->terrainDefenseModifier(pPlot->getTerrainType());

							if (iModifier != 0)
							{
								szString.append(NEWLINE);
								szString.append(gDLL->getText("TXT_KEY_COMBAT_PLOT_UNIT_MOD", iModifier, GC.getTerrainInfo(pPlot->getTerrainType()).getTextKeyWide()));
							}
						}

						if (!pAttacker->immuneToFirstStrikes() && pDefender->maxFirstStrikes() > 0)
						{
							if (pDefender->firstStrikes() == pDefender->maxFirstStrikes())
							{
								szString.append(NEWLINE);
								szString.append(gDLL->getText("TXT_KEY_UNITHELP_FIRST_STRIKES", pDefender->firstStrikes()));
							}
							else
							{
								szString.append(NEWLINE);
								szString.append(gDLL->getText("TXT_KEY_UNITHELP_FIRST_STRIKE_CHANCES", pDefender->firstStrikes(), pDefender->maxFirstStrikes()));
							}
						}

						if (pDefender->isHurt())
						{
							szString.append(NEWLINE);
							szString.append(gDLL->getText("TXT_KEY_COMBAT_PLOT_HP", pDefender->currHitPoints(), pDefender->maxHitPoints()));
						}
					}
					szString.append(gDLL->getText("TXT_KEY_COLOR_REVERT"));

					if (GC.getGame().isDebugMode())
					{
						szTempBuffer.Format(L"\nStack Compare Value = %d",
							gDLL->getInterfaceIFace()->getSelectionList()->AI_compareStacks(pPlot));
						szString.append(szTempBuffer);

						if (pPlot->getPlotCity() != NULL)
						{
							szTempBuffer.Format(L"\nBombard turns = %d",
								gDLL->getInterfaceIFace()->getSelectionList()->getBombardTurns(pPlot->getPlotCity()));
							szString.append(szTempBuffer);
						}

						int iOurStrengthDefense = GET_PLAYER(GC.getGame().getActivePlayer()).AI_getOurPlotStrength(pPlot, 1, true, false);
						int iOurStrengthOffense = GET_PLAYER(GC.getGame().getActivePlayer()).AI_getOurPlotStrength(pPlot, 1, false, false);
						szTempBuffer.Format(L"\nPlot Strength(Ours)= d%d, o%d", iOurStrengthDefense, iOurStrengthOffense);
						szString.append(szTempBuffer);
						int iEnemyStrengthDefense = GET_PLAYER(GC.getGame().getActivePlayer()).AI_getEnemyPlotStrength(pPlot, 1, true, false);
						int iEnemyStrengthOffense = GET_PLAYER(GC.getGame().getActivePlayer()).AI_getEnemyPlotStrength(pPlot, 1, false, false);
						szTempBuffer.Format(L"\nPlot Strength(Enemy)= d%d, o%d", iEnemyStrengthDefense, iEnemyStrengthOffense);
						szString.append(szTempBuffer);
					}
				}
#ifdef STRENGTH_IN_NUMBERS
				//Strength in Numbers extended alternative display
				else if (bSINView && GC.getGame().isOption(GAMEOPTION_STRENGTH_IN_NUMBERS))
				{
					CvPlot* aPlot = pAttacker->plot();
					CvUnit* paFIUnit = pAttacker->getAttackerFirstFrontSupportingUnit();
					CvUnit* paFIIUnit = pAttacker->getAttackerSecondFrontSupportingUnit();
					CvUnit* paSRIUnit = pAttacker->getAttackerFirstShortRangeSupportingUnit();
					CvUnit* paSRIIUnit = pAttacker->getAttackerSecondShortRangeSupportingUnit();
					CvUnit* paMRIUnit = pAttacker->getAttackerFirstMediumRangeSupportingUnit();
					CvUnit* paMRIIUnit = pAttacker->getAttackerSecondMediumRangeSupportingUnit();
					CvUnit* paLRIUnit = pAttacker->getAttackerFirstLongRangeSupportingUnit();
					CvUnit* paLRIIUnit = pAttacker->getAttackerSecondLongRangeSupportingUnit();
					CvUnit* paFLIUnit = pAttacker->getAttackerFirstFlankSupportingUnit();
					CvUnit* paFLIIUnit = pAttacker->getAttackerSecondFlankSupportingUnit();
					CvUnit* pdFIUnit = pDefender->getDefenderFirstFrontSupportingUnit();
					CvUnit* pdFIIUnit = pDefender->getDefenderSecondFrontSupportingUnit();
					CvUnit* pdSRIUnit = pDefender->getDefenderFirstShortRangeSupportingUnit();
					CvUnit* pdSRIIUnit = pDefender->getDefenderSecondShortRangeSupportingUnit();
					CvUnit* pdMRIUnit = pDefender->getDefenderFirstMediumRangeSupportingUnit();
					CvUnit* pdMRIIUnit = pDefender->getDefenderSecondMediumRangeSupportingUnit();
					CvUnit* pdLRIUnit = pDefender->getDefenderFirstLongRangeSupportingUnit();
					CvUnit* pdLRIIUnit = pDefender->getDefenderSecondLongRangeSupportingUnit();
					CvUnit* pdFLIUnit = pDefender->getDefenderFirstFlankSupportingUnit();
					CvUnit* pdFLIIUnit = pDefender->getDefenderSecondFlankSupportingUnit();
					//TB Combat Mod end
					if (pAttacker->getAttackerSupportValue() > 0)
					{
						if (pAttacker->getAttackerFirstFrontSupportValue(aPlot, pPlot, pDefender) > 0)
						{
							szString.append(NEWLINE);
							szString.append(gDLL->getText("TXT_KEY_FIRST_FRONT_SUPPORT", paFIUnit->getDescription().c_str(), pAttacker->getAttackerFirstFrontSupportValue(aPlot, pPlot, pDefender)));
						}
						if (pAttacker->getAttackerSecondFrontSupportValue(aPlot, pPlot, pDefender) > 0)
						{
							szString.append(NEWLINE);
							szString.append(gDLL->getText("TXT_KEY_SECOND_FRONT_SUPPORT", paFIIUnit->getDescription().c_str(), pAttacker->getAttackerSecondFrontSupportValue(aPlot, pPlot, pDefender)));
						}
						if (pAttacker->getAttackerFirstShortRangeSupportValue(aPlot, pPlot, pDefender) > 0)
						{
							szString.append(NEWLINE);
							szString.append(gDLL->getText("TXT_KEY_FIRST_SHORT_RANGE_SUPPORT", paSRIUnit->getDescription().c_str(), pAttacker->getAttackerFirstShortRangeSupportValue(aPlot, pPlot, pDefender)));
						}
						if (pAttacker->getAttackerSecondShortRangeSupportValue(aPlot, pPlot, pDefender) > 0)
						{
							szString.append(NEWLINE);
							szString.append(gDLL->getText("TXT_KEY_SECOND_SHORT_RANGE_SUPPORT", paSRIIUnit->getDescription().c_str(), pAttacker->getAttackerSecondShortRangeSupportValue(aPlot, pPlot, pDefender)));
						}
						if (pAttacker->getAttackerFirstMediumRangeSupportValue(aPlot, pPlot, pDefender) > 0)
						{
							szString.append(NEWLINE);
							szString.append(gDLL->getText("TXT_KEY_FIRST_MEDIUM_RANGE_SUPPORT", paMRIUnit->getDescription().c_str(), pAttacker->getAttackerFirstMediumRangeSupportValue(aPlot, pPlot, pDefender)));
						}
						if (pAttacker->getAttackerSecondMediumRangeSupportValue(aPlot, pPlot, pDefender) > 0)
						{
							szString.append(NEWLINE);
							szString.append(gDLL->getText("TXT_KEY_SECOND_MEDIUM_RANGE_SUPPORT", paMRIIUnit->getDescription().c_str(), pAttacker->getAttackerSecondMediumRangeSupportValue(aPlot, pPlot, pDefender)));
						}
						if (pAttacker->getAttackerFirstLongRangeSupportValue(aPlot, pPlot, pDefender) > 0)
						{
							szString.append(NEWLINE);
							szString.append(gDLL->getText("TXT_KEY_FIRST_LONG_RANGE_SUPPORT", paLRIUnit->getDescription().c_str(), pAttacker->getAttackerFirstLongRangeSupportValue(aPlot, pPlot, pDefender)));
						}
						if (pAttacker->getAttackerSecondLongRangeSupportValue(aPlot, pPlot, pDefender) > 0)
						{
							szString.append(NEWLINE);
							szString.append(gDLL->getText("TXT_KEY_SECOND_LONG_RANGE_SUPPORT", paLRIIUnit->getDescription().c_str(), pAttacker->getAttackerSecondLongRangeSupportValue(aPlot, pPlot, pDefender)));
						}
						if (pAttacker->getAttackerFirstFlankSupportValue(aPlot, pPlot, pDefender) > 0)
						{
							szString.append(NEWLINE);
							szString.append(gDLL->getText("TXT_KEY_FIRST_FLANK_SUPPORT", paFLIUnit->getDescription().c_str(), pAttacker->getAttackerFirstFlankSupportValue(aPlot, pPlot, pDefender)));
						}
						if (pAttacker->getAttackerSecondFlankSupportValue(aPlot, pPlot, pDefender) > 0)
						{
							szString.append(NEWLINE);
							szString.append(gDLL->getText("TXT_KEY_SECOND_FLANK_SUPPORT", paFLIIUnit->getDescription().c_str(), pAttacker->getAttackerSecondFlankSupportValue(aPlot, pPlot, pDefender)));
						}
						int iAttackerSupport = pAttacker->getAttackerSupportValue();
						szString.append(NEWLINE);
						szTempBuffer.Format(SETCOLR L"Total Attacker Support: +%d Strength" ENDCOLR,
							TEXT_COLOR("COLOR_GREEN"), iAttackerSupport);
						szString.append(NEWLINE);
						szString.append(szTempBuffer.GetCString());
					}

					if (pDefender->getDefenderSupportValue(pAttacker) > 0)
					{
						if (pDefender->getDefenderFirstFrontSupportValue(pAttacker, pPlot) > 0)
						{
							szString.append(NEWLINE);
							szString.append(gDLL->getText("TXT_KEY_FIRST_FRONT_SUPPORT", pdFIUnit->getDescription().c_str(), pDefender->getDefenderFirstFrontSupportValue(pAttacker, pPlot)));
						}
						if (pDefender->getDefenderSecondFrontSupportValue(pAttacker, pPlot) > 0)
						{
							szString.append(NEWLINE);
							szString.append(gDLL->getText("TXT_KEY_SECOND_FRONT_SUPPORT", pdFIIUnit->getDescription().c_str(), pDefender->getDefenderSecondFrontSupportValue(pAttacker, pPlot)));
						}
						if (pDefender->getDefenderFirstShortRangeSupportValue(pAttacker, pPlot) > 0)
						{
							szString.append(NEWLINE);
							szString.append(gDLL->getText("TXT_KEY_FIRST_SHORT_RANGE_SUPPORT", pdSRIUnit->getDescription().c_str(), pDefender->getDefenderFirstShortRangeSupportValue(pAttacker, pPlot)));
						}
						if (pDefender->getDefenderSecondShortRangeSupportValue(pAttacker, pPlot) > 0)
						{
							szString.append(NEWLINE);
							szString.append(gDLL->getText("TXT_KEY_SECOND_SHORT_RANGE_SUPPORT", pdSRIIUnit->getDescription().c_str(), pDefender->getDefenderSecondShortRangeSupportValue(pAttacker, pPlot)));
						}
						if (pDefender->getDefenderFirstMediumRangeSupportValue(pAttacker, pPlot) > 0)
						{
							szString.append(NEWLINE);
							szString.append(gDLL->getText("TXT_KEY_FIRST_MEDIUM_RANGE_SUPPORT", pdMRIUnit->getDescription().c_str(), pDefender->getDefenderFirstMediumRangeSupportValue(pAttacker, pPlot)));
						}
						if (pDefender->getDefenderSecondMediumRangeSupportValue(pAttacker, pPlot) > 0)
						{
							szString.append(NEWLINE);
							szString.append(gDLL->getText("TXT_KEY_SECOND_MEDIUM_RANGE_SUPPORT", pdMRIIUnit->getDescription().c_str(), pDefender->getDefenderSecondMediumRangeSupportValue(pAttacker, pPlot)));
						}
						if (pDefender->getDefenderFirstLongRangeSupportValue(pAttacker, pPlot) > 0)
						{
							szString.append(NEWLINE);
							szString.append(gDLL->getText("TXT_KEY_FIRST_LONG_RANGE_SUPPORT", pdLRIUnit->getDescription().c_str(), pDefender->getDefenderFirstLongRangeSupportValue(pAttacker, pPlot)));
						}
						if (pDefender->getDefenderSecondLongRangeSupportValue(pAttacker, pPlot) > 0)
						{
							szString.append(NEWLINE);
							szString.append(gDLL->getText("TXT_KEY_SECOND_LONG_RANGE_SUPPORT", pdLRIIUnit->getDescription().c_str(), pDefender->getDefenderSecondLongRangeSupportValue(pAttacker, pPlot)));
						}
						if (pDefender->getDefenderFirstFlankSupportValue(pAttacker, pPlot) > 0)
						{
							szString.append(NEWLINE);
							szString.append(gDLL->getText("TXT_KEY_FIRST_FLANK_SUPPORT", pdFLIUnit->getDescription().c_str(), pDefender->getDefenderFirstFlankSupportValue(pAttacker, pPlot)));
						}
						if (pDefender->getDefenderSecondFlankSupportValue(pAttacker, pPlot) > 0)
						{
							szString.append(NEWLINE);
							szString.append(gDLL->getText("TXT_KEY_SECOND_FLANK_SUPPORT", pdFLIIUnit->getDescription().c_str(), pDefender->getDefenderSecondFlankSupportValue(pAttacker, pPlot)));
						}
						int iDefenderSupport = pDefender->getDefenderSupportValue(pAttacker);
						szString.append(NEWLINE);
						szTempBuffer.Format(SETCOLR L"Total Defender Support: +%d Strength" ENDCOLR,
							TEXT_COLOR("COLOR_RED"), iDefenderSupport);
						szString.append(NEWLINE);
						szString.append(szTempBuffer.GetCString());
					}
				}
#endif // STRENGTH_IN_NUMBERS
			}
			return true;
		}
	}

	return false;
}

// DO NOT REMOVE - needed for font testing - Moose
void createTestFontString(CvWStringBuffer& szString)
{
	int iI;
	for (iI=0;iI<NUM_YIELD_TYPES;++iI)
		szString.append(CvWString::format(L"%c", GC.getYieldInfo((YieldTypes) iI).getChar()));

	szString.append(L"\n");
	for (iI=0;iI<NUM_COMMERCE_TYPES;++iI)
		szString.append(CvWString::format(L"%c", GC.getCommerceInfo((CommerceTypes) iI).getChar()));
	szString.append(L"\n");
	for (iI = 0; iI < GC.getNumReligionInfos(); ++iI)
	{
		szString.append(CvWString::format(L"%c", GC.getReligionInfo((ReligionTypes) iI).getChar()));
		szString.append(CvWString::format(L"%c", GC.getReligionInfo((ReligionTypes) iI).getHolyCityChar()));
	}
	szString.append(L"\n");
	for (iI = 0; iI < GC.getNumCorporationInfos(); ++iI)
	{
		szString.append(CvWString::format(L"%c%d", GC.getCorporationInfo((CorporationTypes) iI).getChar(), GC.getCorporationInfo((CorporationTypes) iI).getChar()));
		szString.append(CvWString::format(L"%c%d", GC.getCorporationInfo((CorporationTypes) iI).getHeadquarterChar(), GC.getCorporationInfo((CorporationTypes) iI).getHeadquarterChar()));
	}
	szString.append(L"\n");
	for (iI = 0; iI < GC.getNumPropertyInfos(); ++iI)
	{
		szString.append(CvWString::format(L"%c%d", GC.getPropertyInfo((PropertyTypes) iI).getChar(), GC.getPropertyInfo((PropertyTypes) iI).getChar()));
	}
	szString.append(L"\n");
	for (iI = 0; iI < GC.getNumBonusInfos(); ++iI)
		szString.append(CvWString::format(L"%c%d", GC.getBonusInfo((BonusTypes) iI).getChar(), GC.getBonusInfo((BonusTypes) iI).getChar()));
	szString.append(L"\n");
	for (iI=0; iI<MAX_NUM_SYMBOLS; ++iI)
		szString.append(CvWString::format(L"%c%d", gDLL->getSymbolID(iI), gDLL->getSymbolID(iI)));
}

void CvGameTextMgr::setPlotHelp(CvWStringBuffer& szString, CvPlot* pPlot)
{
	PROFILE_FUNC();

	if (GC.getDefineINT("TEST_GAMEFONTS"))
	{
		createTestFontString(szString);
		return;
	}
	CvWString szTempBuffer;
	ImprovementTypes eImprovement;
	BonusTypes eBonus;

	const bool bDebug = GC.getGame().isDebugMode();
	const bool bShift = gDLL->shiftKey();
	const bool bAlt = gDLL->altKey();
	const bool bCtrl = gDLL->ctrlKey();

	const TeamTypes eActiveTeam = GC.getGame().getActiveTeam();

	if (bCtrl && (gDLL->getChtLvl() > 0 || bDebug))
	{
		if (pPlot->getOwner() != NO_PLAYER)
		{
			const int iPlotDanger = GET_PLAYER(pPlot->getOwner()).AI_getPlotDanger(pPlot, 2);
			if (iPlotDanger > 0)
			{
				szString.append(CvWString::format(L"\nPlot Danger = %d", iPlotDanger));
			}
		}

		CvCity* pPlotCity = pPlot->getPlotCity();
		if (pPlotCity != NULL)
		{
			const PlayerTypes ePlayer = pPlot->getOwner();
			const CvPlayerAI& pPlayer = GET_PLAYER(ePlayer);
			const CvTeamAI& pTeam = GET_TEAM(pPlayer.getTeam());

			szString.append(CvWString::format(L"\n\nRevIndex:%d, ", pPlotCity->getRevolutionIndex()));
			szString.append(CvWString::format(L"Avg:%d, ", pPlotCity->getRevIndexAverage()));
			szString.append(CvWString::format(L"Local:%d, ", pPlotCity->getLocalRevIndex()));
			szString.append(CvWString::format(L"Reinf:%d", pPlotCity->getReinforcementCounter()));
			szString.append(CvWString::format(L"\nRevIdxAnger:%d, ", pPlotCity->getRevIndexPercentAnger()));
			szString.append(CvWString::format(L"ReqAnger:%d, ", pPlotCity->getRevRequestPercentAnger()));
			szString.append(CvWString::format(L"RevSucHappy:%d\n", pPlotCity->getRevSuccessHappiness()));

			const int iCityDefenders = pPlot->plotCount(PUF_canDefendGroupHead, -1, -1, NULL, ePlayer, NO_TEAM, PUF_isCityAIType);
			const int iAttackGroups = pPlot->plotCount(PUF_isUnitAIType, UNITAI_ATTACK, -1, NULL, ePlayer);
			szString.append(CvWString::format(L"\nDefenders [D+A]/N ([%d + %d] / %d)", iCityDefenders, iAttackGroups, pPlotCity->AI_neededDefenders()));

			szString.append(CvWString::format(L"\nFloating Defenders H/N (%d / %d)",
				pPlayer.AI_getTotalFloatingDefenders(pPlotCity->area()), pPlayer.AI_getTotalFloatingDefendersNeeded(pPlotCity->area())));

			szString.append(CvWString::format(L"\nAir Defenders H/N (%d / %d)",
				pPlotCity->plot()->plotCount(PUF_canAirDefend, -1, -1, NULL, pPlotCity->getOwner(), NO_TEAM, PUF_isDomainType, DOMAIN_AIR), pPlotCity->AI_neededAirDefenders()));

			szString.append(CvWString::format(L"\nThreat C/P (%d / %d)", pPlotCity->AI_cityThreat(), pPlayer.AI_getTotalAreaCityThreat(pPlotCity->area())));

			bool bFirst = true;
			for (int iI = 0; iI < MAX_PLAYERS; iI++)
			{
				if (iI == ePlayer) continue;

				if (!GET_PLAYER((PlayerTypes)iI).isAlive()) continue;

				const TeamTypes eTeamX = GET_PLAYER((PlayerTypes)iI).getTeam();

				if (pPlotCity->isCapital())
				{
					const int iPlayerCloseness = pPlayer.AI_playerCloseness((PlayerTypes)iI, DEFAULT_PLAYER_CLOSENESS);

					if (pTeam.isHasMet(eTeamX) || iPlayerCloseness != 0)
					{
						if (bFirst)
						{
							bFirst = false;

							szString.append(CvWString::format(L"\n\nCloseness + War: (in %d wars)", pTeam.getAtWarCount(true)));
						}
						szString.append(CvWString::format(L"\n%s(%d) : %d ", GET_PLAYER((PlayerTypes)iI).getName(), DEFAULT_PLAYER_CLOSENESS,
							pPlotCity->AI_playerCloseness((PlayerTypes)iI, DEFAULT_PLAYER_CLOSENESS)));

						szString.append(CvWString::format(L" [%d, ", iPlayerCloseness));

						if (pPlayer.getTeam() != eTeamX)
						{
							szString.append(CvWString::format(L"%d]", pTeam.AI_teamCloseness(eTeamX, DEFAULT_PLAYER_CLOSENESS)));

							if (pTeam.isHasMet(eTeamX) && pTeam.AI_getAttitude(eTeamX) != ATTITUDE_FRIENDLY)
							{
								const int iStartWarVal = pTeam.AI_startWarVal(eTeamX);

								if (pTeam.isAtWar(eTeamX))
								{
									szString.append(CvWString::format(L"\n   At War:   "));
								}
								else if (pTeam.AI_getWarPlan(eTeamX) != NO_WARPLAN)
								{
									szString.append(CvWString::format(L"\n   Plan. War:"));
								}
								else if (!pTeam.canDeclareWar(eTeamX))
								{
									szString.append(CvWString::format(L"\n   Can't War:"));
								}
								else
								{
									szString.append(CvWString::format(L"\n   No War:   "));
								}

								if (iStartWarVal > 1200)
								{
									szString.append(CvWString::format(SETCOLR L" %d" ENDCOLR, TEXT_COLOR("COLOR_RED"), iStartWarVal));
								}
								else if (iStartWarVal > 600)
								{
									szString.append(CvWString::format(SETCOLR L" %d" ENDCOLR, TEXT_COLOR("COLOR_YELLOW"), iStartWarVal));
								}
								else
								{
									szString.append(CvWString::format(L" %d", iStartWarVal));
								}
								szString.append(CvWString::format(L" (%d", pTeam.AI_calculatePlotWarValue(eTeamX)));
								szString.append(CvWString::format(L", %d", pTeam.AI_calculateBonusWarValue(eTeamX)));
								szString.append(CvWString::format(L", %d", pTeam.AI_calculateCapitalProximity(eTeamX)));
								szString.append(CvWString::format(L", %4s", GC.getAttitudeInfo(pTeam.AI_getAttitude(eTeamX)).getDescription(0)));
								szString.append(CvWString::format(L", %d%%)", 100-pTeam.AI_noWarAttitudeProb(pTeam.AI_getAttitude(eTeamX))));
							}
						}
						else
						{
							szString.append(CvWString::format(L"-]"));
						}
					}
				}
				else
				{
					const int iCloseness = pPlotCity->AI_playerCloseness((PlayerTypes)iI, DEFAULT_PLAYER_CLOSENESS);
					if (iCloseness != 0)
					{
						if (bFirst)
						{
							bFirst = false;

							szString.append(CvWString::format(L"\n\nCloseness:"));
						}
						szString.append(CvWString::format(L"\n%s(%d) : %d ", GET_PLAYER((PlayerTypes)iI).getName(), DEFAULT_PLAYER_CLOSENESS, iCloseness));
						szString.append(CvWString::format(L" [%d, ", pPlayer.AI_playerCloseness((PlayerTypes)iI, DEFAULT_PLAYER_CLOSENESS)));

						pPlayer.getTeam() != eTeamX ?
							szString.append(CvWString::format(L"%d]", pTeam.AI_teamCloseness(eTeamX, DEFAULT_PLAYER_CLOSENESS)))
							:
							szString.append(CvWString::format(L"-]"));
					}
				}
			}
			szString.append(CvWString::format(L"\n\nWorkers H/N (%d , %d)", pPlotCity->AI_getWorkersHave(), pPlotCity->AI_getWorkersNeeded()));
			szString.append(CvWString::format(L"\n\nWorkboats Needed = %d", pPlotCity->AI_neededSeaWorkers()));

			int iAreaSiteBestValue = 0;
			const int iNumAreaCitySites = pPlayer.AI_getNumAreaCitySites(pPlot->getArea(), iAreaSiteBestValue);
			int iOtherSiteBestValue = 0;
			const int iNumOtherCitySites = pPlot->waterArea() == NULL ? 0 : pPlayer.AI_getNumAdjacentAreaCitySites(pPlot->waterArea()->getID(), pPlot->getArea(), iOtherSiteBestValue);

			szString.append(CvWString::format(L"\n\nArea Sites = %d (%d)", iNumAreaCitySites, iAreaSiteBestValue));
			szString.append(CvWString::format(L"\nOther Sites = %d (%d)", iNumOtherCitySites, iOtherSiteBestValue));
		}
		else if (pPlot->getOwner() != NO_PLAYER)
		{
			if (bShift && !bAlt && pPlot->headUnitNode() == NULL)
			{
				const int iBonusClasses = GC.getNumBonusClassInfos();
				int* paiBonusClassRevealed = new int[iBonusClasses];
				int* paiBonusClassUnrevealed = new int[iBonusClasses];
				int* paiBonusClassHave = new int[iBonusClasses];

				for (int iI = 0; iI < iBonusClasses; iI++)
				{
					paiBonusClassRevealed[iI] = 0;
					paiBonusClassUnrevealed[iI] = 0;
					paiBonusClassHave[iI] = 0;
				}

				for (int iI = 0; iI < GC.getNumBonusInfos(); iI++)
				{
					if (GC.getBonusInfo((BonusTypes)iI).getTechReveal() != NO_TECH)
					{
						if (GET_TEAM(pPlot->getTeam()).isHasTech((TechTypes)GC.getBonusInfo((BonusTypes)iI).getTechReveal()))
						{
							paiBonusClassRevealed[(BonusClassTypes)GC.getBonusInfo((BonusTypes)iI).getBonusClassType()]++;
						}
						else
						{
							paiBonusClassUnrevealed[(BonusClassTypes)GC.getBonusInfo((BonusTypes)iI).getBonusClassType()]++;
						}

						if (GET_PLAYER(pPlot->getOwner()).getNumAvailableBonuses((BonusTypes)iI) > 0)
						{
							paiBonusClassHave[(BonusClassTypes)GC.getBonusInfo((BonusTypes)iI).getBonusClassType()]++;
						}
						else if (GET_PLAYER(pPlot->getOwner()).countOwnedBonuses((BonusTypes)iI) > 0)
						{
							paiBonusClassHave[(BonusClassTypes)GC.getBonusInfo((BonusTypes)iI).getBonusClassType()]++;
						}
					}
				}
				bool bFirst = true;
				for (int iI = 0; iI < GC.getNumTechInfos(); iI++)
				{
					if (GC.getTechInfo((TechTypes)iI).getEra() <= GET_PLAYER(pPlot->getOwner()).getCurrentEra() + 1)
					{
						const int iPathLength = GET_PLAYER(pPlot->getOwner()).findPathLength(((TechTypes)iI), false);

						if (iPathLength <= 3 && !GET_TEAM(pPlot->getTeam()).isHasTech((TechTypes)iI))
						{
							if (bFirst)
							{
								szString.append(CvWString::format(L"Name (TreePathLength) = Value (building, unit)"));
								bFirst = false;
							}
							bool bDummy;
							szString.append(CvWString::format(L"\n%s (%d) = %d (bld:%d, unt:%d)", GC.getTechInfo((TechTypes)iI).getDescription(), iPathLength,
								GET_PLAYER(pPlot->getOwner()).AI_techValue((TechTypes)iI, 1, false, false, paiBonusClassRevealed, paiBonusClassUnrevealed, paiBonusClassHave),
								GET_PLAYER(pPlot->getOwner()).AI_techBuildingValue((TechTypes)iI, 1, bDummy),
								GET_PLAYER(pPlot->getOwner()).AI_techUnitValue((TechTypes)iI, 1, bDummy)));
						}
					}
				}
			}
			else if (bAlt && !bShift)
			{
				if (pPlot->isHasPathToEnemyCity(pPlot->getTeam()))
				{
					szString.append(CvWString::format(L"\nCan reach an enemy city\n\n"));
				}
				else
				{
					szString.append(CvWString::format(L"\nNo reachable enemy cities\n\n"));
				}
				for (int iI = 0; iI < MAX_PLAYERS; iI++)
				{
					if (GET_PLAYER((PlayerTypes)iI).isAlive())
					{
						if (pPlot->isHasPathToPlayerCity(pPlot->getTeam(), (PlayerTypes) iI))
						{
							szString.append(CvWString::format(SETCOLR L"Can reach %s city" ENDCOLR, TEXT_COLOR("COLOR_GREEN"), GET_PLAYER((PlayerTypes)iI).getName()));
						}
						else
						{
							szString.append(CvWString::format(SETCOLR L"Cannot reach any %s city" ENDCOLR, TEXT_COLOR("COLOR_NEGATIVE_TEXT"), GET_PLAYER((PlayerTypes)iI).getName()));
						}

						if (GET_TEAM(pPlot->getTeam()).isAtWar(GET_PLAYER((PlayerTypes)iI).getTeam()))
						{
							szString.append(CvWString::format(L" (enemy)"));
						}
						szString.append(CvWString::format(L"\n"));
					}

				}
			}
			else if (bShift && bAlt)
			{
				szString.append(CvWString::format(SETCOLR L"\nStrategic values:" ENDCOLR, TEXT_COLOR("COLOR_UNIT_TEXT")));
				szString.append(CvWString::format(L"choke: %d, canal:%d", pPlot->getChokeValue(), pPlot->getCanalValue()));
				szString.append(NEWLINE);

				bool bFirst = true;
				for (int iI = 0; iI < MAX_PLAYERS; iI++)
				{
					PlayerTypes ePlayer = (PlayerTypes)iI;
					CvPlayerAI& kPlayer = GET_PLAYER(ePlayer);

					if (kPlayer.isAlive())
					{
						int iActualFoundValue = pPlot->getFoundValue(ePlayer);
						int iCalcFoundValue = kPlayer.AI_foundValue(pPlot->getX(), pPlot->getY(), -1, false);
						int iStartingFoundValue = kPlayer.AI_foundValue(pPlot->getX(), pPlot->getY(), -1, true);
						int iBestAreaFoundValue = pPlot->area()->getBestFoundValue(ePlayer);
						int iCitySiteBestValue;
						int iNumAreaCitySites = kPlayer.AI_getNumAreaCitySites(pPlot->getArea(), iCitySiteBestValue);

						if ((iActualFoundValue > 0 || iCalcFoundValue > 0 || iStartingFoundValue > 0)
							|| ((pPlot->getOwner() == iI) && (iBestAreaFoundValue > 0)))
						{
							if (bFirst)
							{
								szString.append(CvWString::format(SETCOLR L"\nFound Values:" ENDCOLR, TEXT_COLOR("COLOR_UNIT_TEXT")));
								bFirst = false;
							}

							szString.append(NEWLINE);

							bool bIsRevealed = pPlot->isRevealed(kPlayer.getTeam(), false);

							szString.append(CvWString::format(SETCOLR, TEXT_COLOR(bIsRevealed ? (((iActualFoundValue > 0) && (iActualFoundValue == iBestAreaFoundValue)) ? "COLOR_UNIT_TEXT" : "COLOR_ALT_HIGHLIGHT_TEXT") : "COLOR_HIGHLIGHT_TEXT")));

							if (!bIsRevealed)
							{
								szString.append(CvWString::format(L"("));
							}

							szString.append(CvWString::format(L"%s: %d", kPlayer.getName(), iActualFoundValue));

							if (!bIsRevealed)
							{
								szString.append(CvWString::format(L")"));
							}

							szString.append(CvWString::format(ENDCOLR));

							if (iCalcFoundValue > 0 || iStartingFoundValue > 0)
							{
								szTempBuffer.Format(L" (%d,%ds)", iCalcFoundValue, iStartingFoundValue);
								szString.append(szTempBuffer);
							}

							int iDeadlockCount = kPlayer.AI_countDeadlockedBonuses(pPlot);
							if (iDeadlockCount > 0)
							{
								szTempBuffer.Format(L", " SETCOLR L"d=%d" ENDCOLR, TEXT_COLOR("COLOR_NEGATIVE_TEXT"), iDeadlockCount);
								szString.append(szTempBuffer);
							}

							if (kPlayer.AI_isPlotCitySite(pPlot))
							{
								szTempBuffer.Format(L", " SETCOLR L"X" ENDCOLR, TEXT_COLOR("COLOR_UNIT_TEXT"));
								szString.append(szTempBuffer);
							}

							if ((iBestAreaFoundValue > 0) || (iNumAreaCitySites > 0))
							{
								int iBestFoundValue = kPlayer.findBestFoundValue();

								szTempBuffer.Format(L"\n  Area Best = %d, Best = %d, Sites = %d", iBestAreaFoundValue, iBestFoundValue, iNumAreaCitySites);
								szString.append(szTempBuffer);
							}
						}
					}
				}
			}
			else if( pPlot->headUnitNode() == NULL )
			{
				std::vector<UnitAITypes> vecUnitAIs;

				if( pPlot->getFeatureType() != NO_FEATURE )
				{
					szString.append(CvWString::format(L"Defense unit AIs:\n"));
					vecUnitAIs.push_back(UNITAI_CITY_DEFENSE);
					vecUnitAIs.push_back(UNITAI_COUNTER);
					vecUnitAIs.push_back(UNITAI_CITY_COUNTER);
				}
				else
				{
					szString.append(CvWString::format(L"Attack unit AIs:\n"));
					vecUnitAIs.push_back(UNITAI_ATTACK);
					vecUnitAIs.push_back(UNITAI_ATTACK_CITY);
					vecUnitAIs.push_back(UNITAI_COUNTER);
				}

				CvCity* pCloseCity = GC.getMap().findCity(pPlot->getX(), pPlot->getY(), pPlot->getOwner(), NO_TEAM, true);

				if( pCloseCity != NULL )
				{
					for (uint iI = 0; iI < vecUnitAIs.size(); iI++)
					{
						CvWString szTempString;
						getUnitAIString(szTempString, vecUnitAIs[iI]);
						szString.append(CvWString::format(L"\n  %s  ", szTempString.GetCString()));
						for (int iJ = 0; iJ < GC.getNumUnitInfos(); iJ++)
						{
							if (pCloseCity->canTrain((UnitTypes)iJ))
							{
								const int iValue = GET_PLAYER(pPlot->getOwner()).AI_unitValue((UnitTypes)iJ, vecUnitAIs[iI], pPlot->area());
								if (iValue > 0)
								{
									szString.append(CvWString::format(L"\n %s = %d", GC.getUnitInfo((UnitTypes)iJ).getDescription(), iValue));
								}
							}
						}
					}
				}
			}
		}
		if (bShift && bAlt)
		{
			szString.append(CvWString::format(SETCOLR L"\nStrategic values:" ENDCOLR, TEXT_COLOR("COLOR_UNIT_TEXT")));
			szString.append(CvWString::format(L" choke=%d, canal=%d", pPlot->getChokeValue(), pPlot->getCanalValue()));
			szString.append(NEWLINE);

			for (int iJ = 0; iJ < GC.getNumInvisibleInfos(); iJ++)
			{
				InvisibleTypes eInvisible = (InvisibleTypes)iJ;
				for (int iK = 0; iK < MAX_TEAMS; iK++)
				{
					TeamTypes eTeam = (TeamTypes)iK;
					const int iVisibilityIntensity = pPlot->getHighestPlotTeamVisibilityIntensity(eInvisible, eTeam);
					if (iVisibilityIntensity > 0)
					{
						szString.append(CvWString::format(L"InvisibleType: %s, TeamID:%d, Int:%d", GC.getInvisibleInfo(eInvisible).getTextKeyWide(), iK, iVisibilityIntensity));
						szString.append(NEWLINE);
					}
				}
			}
			szString.append(CvWString::format(L"X %d, Y %d", pPlot->getX(), pPlot->getY()));
			szString.append(NEWLINE);
		}
		return;
	}
	else if (bShift && !bAlt && (gDLL->getChtLvl() > 0 || bDebug))
	{
		szString.append(CvWString::format(L"\n%s - Lat %d, Long %d",
			GC.getTerrainInfo(pPlot->getTerrainType()).getDescription(), pPlot->getLatitude(), pPlot->getLongitude()));

		szString.append(CvWString::format(L"\nX %d, Y %d, Area %d", pPlot->getX(), pPlot->getY(), pPlot->getArea()));

		if (pPlot->getPlotGroup(GC.getGame().getActivePlayer()) != NULL)
		{
			szString.append(CvWString::format(L", plot group %d", pPlot->getPlotGroup(GC.getGame().getActivePlayer())->getID()));
		}
		CvCity* pWorkingCity = pPlot->getWorkingCity();

		if (bDebug && pWorkingCity == NULL && pPlot->getOwner() != NO_PLAYER)
		{
			const int iCulture = GC.getInfoTypeForString("BONUSCLASS_CULTURE");
			const int iProduce = GC.getInfoTypeForString("BONUSCLASS_MANUFACTURED");
			bool bFirst = true;
			for (int iI = 0; iI < GC.getNumBonusInfos(); ++iI)
			{
				if (pPlot->isPlotGroupConnectedBonus(pPlot->getOwner(), ((BonusTypes)iI))
				&& GC.getBonusInfo((BonusTypes)iI).getBonusClassType() != iCulture
				&& GC.getBonusInfo((BonusTypes)iI).getBonusClassType() != iProduce)
				{
					if (bFirst)
					{
						szString.append(CvWString::format(L"\nAI Bonus Value: %s=%d",
							GC.getBonusInfo((BonusTypes)iI).getDescription(), GET_PLAYER(pPlot->getOwner()).AI_bonusVal((BonusTypes)iI)));
						bFirst = false;
					}
					else
					{
						szString.append(CvWString::format(L", %s=%d",
							GC.getBonusInfo((BonusTypes)iI).getDescription(), GET_PLAYER(pPlot->getOwner()).AI_bonusVal((BonusTypes)iI)));
					}
				}
			}
		}
		bool bNS = true;
		if (pPlot->getRiverNSDirection() == CARDINALDIRECTION_NORTH)
		{
			szString.append(L"\nRiver Flow: N");
		}
		else if (pPlot->getRiverNSDirection() == CARDINALDIRECTION_SOUTH)
		{
			szString.append(L"\nRiver Flow: S");
		}
		else bNS = false;

		if (pPlot->getRiverWEDirection() == CARDINALDIRECTION_WEST)
		{
			if (bNS) szString.append(L"W");
			else szString.append(L"\nRiver Flow: W");
		}
		else if (pPlot->getRiverWEDirection() == CARDINALDIRECTION_EAST)
		{
			if (bNS) szString.append(L"E");
			else szString.append(L"\nRiver Flow: E");
		}

		if (pPlot->getRouteType() != NO_ROUTE)
		{
			szString.append(CvWString::format(L"\nRoute: %s", GC.getRouteInfo(pPlot->getRouteType()).getDescription()));

			if (pPlot->getRouteSymbol() != NULL)
			{
				szString.append(CvWString::format(L", Connections: %i", gDLL->getRouteIFace()->getConnectionMask(pPlot->getRouteSymbol())));
			}
		}
		else if (pPlot->getRouteSymbol() != NULL)
		{ // Don't think this can happen, but we probably want to know about it if it does.
			szString.append(CvWString::format(L"\nConnection: %i", gDLL->getRouteIFace()->getConnectionMask(pPlot->getRouteSymbol())));
		}

		for (int iI = 0; iI < MAX_PLAYERS; iI++)
		{
			if (GET_PLAYER((PlayerTypes)iI).isAlive() && pPlot->getDangerCount((PlayerTypes)iI) > 0)
			{
				szTempBuffer.Format(L"\n%s Danger: %d", GET_PLAYER((PlayerTypes)iI).getName(), pPlot->getDangerCount((PlayerTypes)iI));
				szString.append(szTempBuffer);
			}
		}
		PlayerTypes eActivePlayer = GC.getGame().getActivePlayer();
		int iActualFoundValue = pPlot->getFoundValue(eActivePlayer);
		int iCalcFoundValue = GET_PLAYER(eActivePlayer).AI_foundValue(pPlot->getX(), pPlot->getY(), -1, false);
		int iStartingFoundValue = GET_PLAYER(eActivePlayer).AI_foundValue(pPlot->getX(), pPlot->getY(), -1, true);

		szTempBuffer.Format(L"\nFound Value: %d, (%d, %d)", iActualFoundValue, iCalcFoundValue, iStartingFoundValue);
		szString.append(szTempBuffer);

		CvCity* pCity = GC.getMap().findCity(pPlot->getX(), pPlot->getY(), pPlot->getOwner(), NO_TEAM, false);
		if (pCity != NULL)
		{
			int iFoodMultiplier = 0;
			int iProductionMultiplier = 0;
			int iCommerceMultiplier = 0;
			int iDesiredFoodChange = 0;
			pCity->AI_getYieldMultipliers(iFoodMultiplier, iProductionMultiplier, iCommerceMultiplier, iDesiredFoodChange );

			szString.append(CvWString::format(L"\n\n%s yield multipliers:\n  * Food %d, Prod %d, Com %d\n  * Desired Food Change %d",
				pCity->getName().c_str(), iFoodMultiplier, iProductionMultiplier, iCommerceMultiplier, iDesiredFoodChange));

			if (pPlot->isImprovementUpgradable())
			{
				const ImprovementTypes eImprovement = pPlot->getImprovementType();
				szString.append(CvWString::format(L"\nCurrent improvement value: %d\n",
					pCity->AI_getImprovementValue(pPlot, eImprovement, iFoodMultiplier, iProductionMultiplier, iCommerceMultiplier, iDesiredFoodChange)));

				ImprovementTypes eUpgrade = (ImprovementTypes) GC.getImprovementInfo(eImprovement).getImprovementUpgrade();
				bool bValid = pPlot->canHaveImprovement(eUpgrade, pCity->getTeam(), false, true);

				szString.append(CvWString::format(L"AI improvement upgrade values:\nMain: %s%s = %d", GC.getImprovementInfo(eUpgrade).getDescription(), bValid ? L"" : L" (False)",
					pCity->AI_getImprovementValue(pPlot, eUpgrade, iFoodMultiplier, iProductionMultiplier, iCommerceMultiplier, iDesiredFoodChange)));

				for (int iI = 0; iI < GC.getImprovementInfo(eImprovement).getNumAlternativeImprovementUpgradeTypes(); ++iI)
				{
					eUpgrade = (ImprovementTypes)GC.getImprovementInfo(eImprovement).getAlternativeImprovementUpgradeType(iI);
					bool bValid = pPlot->canHaveImprovement(eUpgrade, pCity->getTeam(), false, true);
					szString.append(CvWString::format(L"\n  * %s%s = %d", GC.getImprovementInfo(eUpgrade).getDescription(), bValid ? L"" : L" (False)",
						pCity->AI_getImprovementValue(pPlot, eUpgrade, iFoodMultiplier, iProductionMultiplier, iCommerceMultiplier, iDesiredFoodChange)));
				}
			}
			if (NULL != pWorkingCity)
			{
				szString.append(NEWLINE);
				szTempBuffer.Format(L"\nTarget pop: %d, (%d good tiles)", pWorkingCity->AI_getTargetSize(), pWorkingCity->AI_getGoodTileCount() );
				szString.append(szTempBuffer);

				const int iPlotIndex = pWorkingCity->getCityPlotIndex(pPlot);
				BuildTypes eBestBuild = pWorkingCity->AI_getBestBuild(iPlotIndex);

				if (NO_BUILD != eBestBuild)
				{
					szString.append(CvWString::format(L"\nBest Build: %s (%d)", GC.getBuildInfo(eBestBuild).getDescription(), pWorkingCity->AI_getBestBuildValue(iPlotIndex)));
				}
			}
		}
		szTempBuffer.Format(L"\nStack Str: land=%d(%d), sea=%d(%d), air=%d(%d)",
			pPlot->AI_sumStrength(NO_PLAYER, NO_PLAYER, DOMAIN_LAND, StrengthFlags::None),
			pPlot->AI_sumStrength(NO_PLAYER, NO_PLAYER, DOMAIN_LAND, StrengthFlags::DefensiveBonuses),
			pPlot->AI_sumStrength(NO_PLAYER, NO_PLAYER, DOMAIN_SEA, StrengthFlags::None),
			pPlot->AI_sumStrength(NO_PLAYER, NO_PLAYER, DOMAIN_SEA, StrengthFlags::DefensiveBonuses),
			pPlot->AI_sumStrength(NO_PLAYER, NO_PLAYER, DOMAIN_AIR, StrengthFlags::None),
			pPlot->AI_sumStrength(NO_PLAYER, NO_PLAYER, DOMAIN_AIR, StrengthFlags::DefensiveBonuses));
		szString.append(szTempBuffer);
	}
	else if (!bShift && bAlt && (gDLL->getChtLvl() > 0 || bDebug))
	{
		if (pPlot->isOwned())
		{
			szTempBuffer.Format(L"\nThis player has %d area cities", pPlot->area()->getCitiesPerPlayer(pPlot->getOwner()));
			szString.append(szTempBuffer);
			for (int iI = 0; iI < GC.getNumReligionInfos(); ++iI)
			{
				int iNeededMissionaries = GET_PLAYER(pPlot->getOwner()).AI_neededMissionaries(pPlot->area(), ((ReligionTypes)iI));
				if (iNeededMissionaries > 0)
				{
					szTempBuffer.Format(L"\nNeeded %c missionaries = %d", GC.getReligionInfo((ReligionTypes)iI).getChar(), iNeededMissionaries);
					szString.append(szTempBuffer);
				}
			}

			int iNeededExplorers = GET_PLAYER(pPlot->getOwner()).AI_neededExplorers(pPlot->area());
			int iHasExplorers = GET_PLAYER(pPlot->getOwner()).AI_totalAreaUnitAIs(pPlot->area(), UNITAI_EXPLORE);
			if (iNeededExplorers > 0)
			{
				szTempBuffer.Format(L"\nNeeded explorers = %d (has %d)", iNeededExplorers, iHasExplorers);
				szString.append(szTempBuffer);
			}

			int iNeededHunters = GET_PLAYER(pPlot->getOwner()).AI_neededHunters(pPlot->area());
			int iHasHunters = GET_PLAYER(pPlot->getOwner()).AI_totalAreaUnitAIs(pPlot->area(), UNITAI_HUNTER);
			if (iNeededHunters > 0)
			{
				szTempBuffer.Format(L"\nNeeded hunters = %d (has %d)", iNeededHunters, iHasHunters);
				szString.append(szTempBuffer);
			}

			int iOurDefense = GET_PLAYER(pPlot->getOwner()).AI_getOurPlotStrength(pPlot, 0, true, false);
			int iEnemyOffense = GET_PLAYER(pPlot->getOwner()).AI_getEnemyPlotStrength(pPlot, 2, false, false);
			if (iEnemyOffense > 0)
			{
				szString.append(CvWString::format(SETCOLR L"\nDanger: %.2f (%d/%d)" ENDCOLR, TEXT_COLOR("COLOR_NEGATIVE_TEXT"),
					(iEnemyOffense * 1.0f) / std::max(1, iOurDefense), iEnemyOffense, iOurDefense));
			}

			CvCity* pCity = pPlot->getPlotCity();
			if (pCity != NULL)
			{
				szTempBuffer.Format(L"\n\nCulture Pressure Value = %d", pCity->AI_calculateCulturePressure());
				szString.append(szTempBuffer);

				szTempBuffer.Format(L"\nWater World Percent = %d", pCity->AI_calculateWaterWorldPercent());
				szString.append(szTempBuffer);

				CvPlayerAI& kPlayer = GET_PLAYER(pCity->getOwner());
				const int64_t iUnitUpkeep = kPlayer.getFinalUnitUpkeep();
				int64_t iTotalCosts = kPlayer.calculatePreInflatedCosts();
				int64_t iUnitCostPercentage = iUnitUpkeep * 100 / std::max<int64_t>(1, iTotalCosts);
				szString.append(CvWString::format(L"\nUnit cost percentage: %lld (%lld / %lld)", iUnitCostPercentage, iUnitUpkeep, iTotalCosts));

				szString.append(CvWString::format(L"\nUpgrade all units: %d gold", kPlayer.AI_goldToUpgradeAllUnits()));

				szString.append(CvWString::format(L"\n\nRanks:"));
				szString.append(CvWString::format(L"\nPopulation:%d", pCity->findPopulationRank()));

				szString.append(CvWString::format(L"\nFood:%d(%d), ", pCity->findYieldRateRank(YIELD_FOOD), pCity->findBaseYieldRateRank(YIELD_FOOD)));
				szString.append(CvWString::format(L"Prod:%d(%d), ", pCity->findYieldRateRank(YIELD_PRODUCTION), pCity->findBaseYieldRateRank(YIELD_PRODUCTION)));
				szString.append(CvWString::format(L"Commerce:%d(%d)", pCity->findYieldRateRank(YIELD_COMMERCE), pCity->findBaseYieldRateRank(YIELD_COMMERCE)));

				szString.append(CvWString::format(L"\nGold:%d, ", pCity->findCommerceRateRank(COMMERCE_GOLD)));
				szString.append(CvWString::format(L"Research:%d, ", pCity->findCommerceRateRank(COMMERCE_RESEARCH)));
				szString.append(CvWString::format(L"Culture:%d", pCity->findCommerceRateRank(COMMERCE_CULTURE)));

				szString.append(CvWString::format(L"\nMilitary Rank:%d", pCity->AI_getMilitaryProductionRateRank()));
				if (pCity->AI_isMilitaryProductionCity())
					szString.append(CvWString::format(L"\nIs Military Production City"));
				szString.append(CvWString::format(L"\nNaval Military Rank:%d", pCity->AI_getNavalMilitaryProductionRateRank()));
				if (pCity->AI_isNavalMilitaryProductionCity())
					szString.append(CvWString::format(L"\nIs Naval Military Production City"));
			}
			szString.append(NEWLINE);

			szTempBuffer.Format(L"Stability Index: %d, Trend: %d",GET_PLAYER(pPlot->getOwner()).getStabilityIndex(),GET_PLAYER(pPlot->getOwner()).getStabilityIndex()-GET_PLAYER(pPlot->getOwner()).getStabilityIndexAverage());
			szString.append(szTempBuffer);
			szString.append(NEWLINE);

			//AI strategies
			if (GET_PLAYER(pPlot->getOwner()).AI_isDoStrategy(AI_STRATEGY_DAGGER))
			{
				szTempBuffer.Format(L"Dagger, ");
				szString.append(szTempBuffer);
			}
			if (GET_PLAYER(pPlot->getOwner()).AI_isDoStrategy(AI_STRATEGY_CRUSH))
			{
				szTempBuffer.Format(L"Crush, ");
				szString.append(szTempBuffer);
			}
			if (GET_PLAYER(pPlot->getOwner()).AI_isDoStrategy(AI_STRATEGY_ALERT1))
			{
				szTempBuffer.Format(L"Alert1, ");
				szString.append(szTempBuffer);
			}
			if (GET_PLAYER(pPlot->getOwner()).AI_isDoStrategy(AI_STRATEGY_ALERT2))
			{
				szTempBuffer.Format(L"Alert2, ");
				szString.append(szTempBuffer);
			}
			if (GET_PLAYER(pPlot->getOwner()).AI_isDoStrategy(AI_STRATEGY_TURTLE))
			{
				szTempBuffer.Format(L"Turtle, ");
				szString.append(szTempBuffer);
			}
			if (GET_PLAYER(pPlot->getOwner()).AI_isDoStrategy(AI_STRATEGY_LAST_STAND))
			{
				szTempBuffer.Format(L"LastStand, ");
				szString.append(szTempBuffer);
			}
			if (GET_PLAYER(pPlot->getOwner()).AI_isDoStrategy(AI_STRATEGY_FINAL_WAR))
			{
				szTempBuffer.Format(L"FinalWar, ");
				szString.append(szTempBuffer);
			}
			if (GET_PLAYER(pPlot->getOwner()).AI_isDoStrategy(AI_STRATEGY_GET_BETTER_UNITS))
			{
				szTempBuffer.Format(L"GetBetterUnits, ");
				szString.append(szTempBuffer);
			}
			if (GET_PLAYER(pPlot->getOwner()).AI_isDoStrategy(AI_STRATEGY_FASTMOVERS))
			{
				szTempBuffer.Format(L"FastMovers, ");
				szString.append(szTempBuffer);
			}
			if (GET_PLAYER(pPlot->getOwner()).AI_isDoStrategy(AI_STRATEGY_LAND_BLITZ))
			{
				szTempBuffer.Format(L"LandBlitz, ");
				szString.append(szTempBuffer);
			}
			if (GET_PLAYER(pPlot->getOwner()).AI_isDoStrategy(AI_STRATEGY_AIR_BLITZ))
			{
				szTempBuffer.Format(L"AirBlitz, ");
				szString.append(szTempBuffer);
			}
 			if (GET_PLAYER(pPlot->getOwner()).AI_isDoStrategy(AI_STRATEGY_OWABWNW))
			{
				szTempBuffer.Format(L"OWABWNW, ");
				szString.append(szTempBuffer);
			}
			if (GET_PLAYER(pPlot->getOwner()).AI_isDoStrategy(AI_STRATEGY_PRODUCTION))
			{
				szTempBuffer.Format(L"Production, ");

				szString.append(szTempBuffer);
			}
			if (GET_PLAYER(pPlot->getOwner()).AI_isDoStrategy(AI_STRATEGY_MISSIONARY))
			{
				szTempBuffer.Format(L"Missionary, ");
				szString.append(szTempBuffer);
			}
			if (GET_PLAYER(pPlot->getOwner()).AI_isDoStrategy(AI_STRATEGY_BIG_ESPIONAGE))
			{
				szTempBuffer.Format(L"BigEspionage, ");
				szString.append(szTempBuffer);
			}

			//Area battle plans.
			if (pPlot->area()->getAreaAIType(pPlot->getTeam()) == AREAAI_OFFENSIVE)
			{
				szTempBuffer.Format(L"\n Area AI = OFFENSIVE");
			}
			else if (pPlot->area()->getAreaAIType(pPlot->getTeam()) == AREAAI_DEFENSIVE)
			{
				szTempBuffer.Format(L"\n Area AI = DEFENSIVE");
			}
			else if (pPlot->area()->getAreaAIType(pPlot->getTeam()) == AREAAI_MASSING)
			{
				szTempBuffer.Format(L"\n Area AI = MASSING");
			}
			else if (pPlot->area()->getAreaAIType(pPlot->getTeam()) == AREAAI_ASSAULT)
			{
				szTempBuffer.Format(L"\n Area AI = ASSAULT");
			}
			else if (pPlot->area()->getAreaAIType(pPlot->getTeam()) == AREAAI_ASSAULT_MASSING)
			{
				szTempBuffer.Format(L"\n Area AI = ASSAULT_MASSING");
			}
			else if (pPlot->area()->getAreaAIType(pPlot->getTeam()) == AREAAI_NEUTRAL)
			{
				szTempBuffer.Format(L"\n Area AI = NEUTRAL");
			}

			szString.append(szTempBuffer);
			szString.append(CvWString::format(L"\n\nNum Wars: %d + %d minor", GET_TEAM(pPlot->getTeam()).getAtWarCount(true), GET_TEAM(pPlot->getTeam()).getAtWarCount(false) - GET_TEAM(pPlot->getTeam()).getAtWarCount(true)));
			szString.append(CvWString::format(L"\nWarplans:"));
			for (int iI = 0; iI < MAX_TEAMS; ++iI)
			{
				TeamTypes eTeam = (TeamTypes)iI;

				if( GET_TEAM(eTeam).isAlive() || GET_TEAM(eTeam).isNPC() )
				{
					if( GET_TEAM(pPlot->getTeam()).AI_getWarPlan(eTeam) == WARPLAN_ATTACKED )
					{
						szString.append(CvWString::format(L"\n%s: ATTACKED", GET_TEAM(eTeam).getName().c_str()));
					}
					else if( GET_TEAM(pPlot->getTeam()).AI_getWarPlan(eTeam) == WARPLAN_ATTACKED_RECENT )
					{
						szString.append(CvWString::format(L"\n%s: ATTACKED_RECENT", GET_TEAM(eTeam).getName().c_str()));
					}
					else if( GET_TEAM(pPlot->getTeam()).AI_getWarPlan(eTeam) == WARPLAN_PREPARING_LIMITED )
					{
						szString.append(CvWString::format(L"\n%s: PREP_LIM", GET_TEAM(eTeam).getName().c_str()));
					}
					else if( GET_TEAM(pPlot->getTeam()).AI_getWarPlan(eTeam) == WARPLAN_PREPARING_TOTAL )
					{
						szString.append(CvWString::format(L"\n%s: PREP_TOTAL", GET_TEAM(eTeam).getName().c_str()));
					}
					else if( GET_TEAM(pPlot->getTeam()).AI_getWarPlan(eTeam) == WARPLAN_LIMITED )
					{
						szString.append(CvWString::format(L"\n%s: LIMITED", GET_TEAM(eTeam).getName().c_str()));
					}
					else if( GET_TEAM(pPlot->getTeam()).AI_getWarPlan(eTeam) == WARPLAN_TOTAL )
					{
						szString.append(CvWString::format(L"\n%s: TOTAL", GET_TEAM(eTeam).getName().c_str()));
					}
					else if( GET_TEAM(pPlot->getTeam()).AI_getWarPlan(eTeam) == WARPLAN_DOGPILE )
					{
						szString.append(CvWString::format(L"\n%s: DOGPILE", GET_TEAM(eTeam).getName().c_str()));
					}
					else if( GET_TEAM(pPlot->getTeam()).AI_getWarPlan(eTeam) == NO_WARPLAN )
					{
						if( GET_TEAM(pPlot->getTeam()).isAtWar(eTeam) )
						{
							szString.append(CvWString::format(SETCOLR L"\n%s: NO_WARPLAN!" ENDCOLR, TEXT_COLOR("COLOR_WARNING_TEXT"), GET_TEAM(eTeam).getName().c_str()));
						}
					}
				}

				if( GET_TEAM(pPlot->getTeam()).isMinorCiv() || GET_TEAM(pPlot->getTeam()).isNPC() )
				{
					if( pPlot->getTeam() != eTeam && !GET_TEAM(pPlot->getTeam()).isAtWar(eTeam) )
					{
						szString.append(CvWString::format(SETCOLR L"\n%s: minor/npc not at war!" ENDCOLR, TEXT_COLOR("COLOR_WARNING_TEXT"), GET_TEAM(eTeam).getName().c_str()));
					}
				}
			}

			CvCity* pTargetCity = pPlot->area()->getTargetCity(pPlot->getOwner());
			if( pTargetCity )
			{
				szString.append(CvWString::format(L"\nTarget City: %s", pTargetCity->getName().c_str()));
			}
			else
			{
				szString.append(CvWString::format(L"\nTarget City: None"));
			}
		}
	}
	else if (bShift && bAlt && (gDLL->getChtLvl() > 0 || bDebug))
	{
		CvCity*	pCity = pPlot->getWorkingCity();
		if (pCity != NULL)
		{
			// some functions we want to call are not in CvCity, worse some are protected, so made us a friend
			CvCityAI* pCityAI = static_cast<CvCityAI*>(pCity);

			bool bAvoidGrowth = pCity->AI_avoidGrowth();
			bool bIgnoreGrowth = pCityAI->AI_ignoreGrowth();

			// if we over the city, then do an array of all the plots
			if (pPlot->getPlotCity() != NULL)
			{
				szTempBuffer.Format(L"Max culture level = %d ", pCity->getMaxCultureLevelAmongPlayers());
				szString.append(szTempBuffer);
				szString.append(NEWLINE);
				szTempBuffer.Format(L"Occupation culture level = %d ", pCity->getOccupationCultureLevel());
				szString.append(szTempBuffer);
				szString.append(NEWLINE);

				// check avoid growth
				if (bAvoidGrowth || bIgnoreGrowth)
				{
					// red color
					szString.append(CvWString::format(SETCOLR, TEXT_COLOR("COLOR_NEGATIVE_TEXT")));

					if (bAvoidGrowth)
					{
						szString.append(CvWString::format(L"AvoidGrowth"));

						if (bIgnoreGrowth)
							szString.append(CvWString::format(L", "));
					}

					if (bIgnoreGrowth)
						szString.append(CvWString::format(L"IgnoreGrowth"));

					// end color
					szString.append(CvWString::format( ENDCOLR L"\n" ));
				}

				// if control key is down, ignore food
				bool bIgnoreFood = gDLL->ctrlKey();

				// line one is: blank, 20, 9, 10, blank
				setCityPlotYieldValueString(szString, pCity, -1, bAvoidGrowth, bIgnoreGrowth, bIgnoreFood);
				setCityPlotYieldValueString(szString, pCity, 20, bAvoidGrowth, bIgnoreGrowth, bIgnoreFood);
				setCityPlotYieldValueString(szString, pCity, 9, bAvoidGrowth, bIgnoreGrowth, bIgnoreFood);
				setCityPlotYieldValueString(szString, pCity, 10, bAvoidGrowth, bIgnoreGrowth, bIgnoreFood);
				szString.append(L"\n");

				// line two is: 19, 8, 1, 2, 11
				setCityPlotYieldValueString(szString, pCity, 19, bAvoidGrowth, bIgnoreGrowth, bIgnoreFood);
				setCityPlotYieldValueString(szString, pCity, 8, bAvoidGrowth, bIgnoreGrowth, bIgnoreFood);
				setCityPlotYieldValueString(szString, pCity, 1, bAvoidGrowth, bIgnoreGrowth, bIgnoreFood);
				setCityPlotYieldValueString(szString, pCity, 2, bAvoidGrowth, bIgnoreGrowth, bIgnoreFood);
				setCityPlotYieldValueString(szString, pCity, 11, bAvoidGrowth, bIgnoreGrowth, bIgnoreFood);
				szString.append(L"\n");

				// line three is: 18, 7, 0, 3, 12
				setCityPlotYieldValueString(szString, pCity, 18, bAvoidGrowth, bIgnoreGrowth, bIgnoreFood);
				setCityPlotYieldValueString(szString, pCity, 7, bAvoidGrowth, bIgnoreGrowth, bIgnoreFood);
				setCityPlotYieldValueString(szString, pCity, 0, bAvoidGrowth, bIgnoreGrowth, bIgnoreFood);
				setCityPlotYieldValueString(szString, pCity, 3, bAvoidGrowth, bIgnoreGrowth, bIgnoreFood);
				setCityPlotYieldValueString(szString, pCity, 12, bAvoidGrowth, bIgnoreGrowth, bIgnoreFood);
				szString.append(L"\n");

				// line four is: 17, 6, 5, 4, 13
				setCityPlotYieldValueString(szString, pCity, 17, bAvoidGrowth, bIgnoreGrowth, bIgnoreFood);
				setCityPlotYieldValueString(szString, pCity, 6, bAvoidGrowth, bIgnoreGrowth, bIgnoreFood);
				setCityPlotYieldValueString(szString, pCity, 5, bAvoidGrowth, bIgnoreGrowth, bIgnoreFood);
				setCityPlotYieldValueString(szString, pCity, 4, bAvoidGrowth, bIgnoreGrowth, bIgnoreFood);
				setCityPlotYieldValueString(szString, pCity, 13, bAvoidGrowth, bIgnoreGrowth, bIgnoreFood);
				szString.append(L"\n");

				// line five is: blank, 16, 15, 14, blank
				setCityPlotYieldValueString(szString, pCity, -1, bAvoidGrowth, bIgnoreGrowth, bIgnoreFood);
				setCityPlotYieldValueString(szString, pCity, 16, bAvoidGrowth, bIgnoreGrowth, bIgnoreFood);
				setCityPlotYieldValueString(szString, pCity, 15, bAvoidGrowth, bIgnoreGrowth, bIgnoreFood);
				setCityPlotYieldValueString(szString, pCity, 14, bAvoidGrowth, bIgnoreGrowth, bIgnoreFood);

				// show specialist values too
				for (int iI = 0; iI < GC.getNumSpecialistInfos(); ++iI)
				{
					int iMaxThisSpecialist = pCity->getMaxSpecialistCount((SpecialistTypes) iI);
					int iSpecialistCount = pCity->getSpecialistCount((SpecialistTypes) iI);
					bool bUsingSpecialist = (iSpecialistCount > 0);
					bool bIsDefaultSpecialist = (iI == GC.getDefineINT("DEFAULT_SPECIALIST"));

					// can this city have any of this specialist?
					if (iMaxThisSpecialist > 0 || bIsDefaultSpecialist)
					{
						// start color
						if (pCity->getForceSpecialistCount((SpecialistTypes) iI) > 0)
							szString.append(CvWString::format(L"\n" SETCOLR, TEXT_COLOR("COLOR_NEGATIVE_TEXT")));
						else if (bUsingSpecialist)
							szString.append(CvWString::format(L"\n" SETCOLR, TEXT_COLOR("COLOR_ALT_HIGHLIGHT_TEXT")));
						else
							szString.append(CvWString::format(L"\n" SETCOLR, TEXT_COLOR("COLOR_HIGHLIGHT_TEXT")));

						// add name
						szString.append(GC.getSpecialistInfo((SpecialistTypes) iI).getDescription());

						// end color
						szString.append(CvWString::format( ENDCOLR ));

						// add usage
						szString.append(CvWString::format(L": (%d/%d) ", iSpecialistCount, iMaxThisSpecialist));

						// add value
						int iValue = pCityAI->AI_specialistValue(((SpecialistTypes) iI), bAvoidGrowth, /*bRemove*/ bUsingSpecialist);
						setYieldValueString(szString, iValue, /*bActive*/ bUsingSpecialist);
					}
				}
				int iFood = GET_PLAYER(pCity->getOwner()).AI_averageYieldMultiplier(YIELD_FOOD);
				int iHammer = GET_PLAYER(pCity->getOwner()).AI_averageYieldMultiplier(YIELD_PRODUCTION);
				int iCommerce = GET_PLAYER(pCity->getOwner()).AI_averageYieldMultiplier(YIELD_COMMERCE);

				szString.append(CvWString::format(L"\nPlayer avg:	   (f%d, h%d, c%d)", iFood, iHammer, iCommerce));

				iFood = pCity->AI_yieldMultiplier(YIELD_FOOD);
				iHammer = pCity->AI_yieldMultiplier(YIELD_PRODUCTION);
				iCommerce = pCity->AI_yieldMultiplier(YIELD_COMMERCE);

				szString.append(CvWString::format(L"\nCity yield mults: (f%d, h%d, c%d)", iFood, iHammer, iCommerce));

				iFood = pCityAI->AI_specialYieldMultiplier(YIELD_FOOD);
				iHammer = pCityAI->AI_specialYieldMultiplier(YIELD_PRODUCTION);
				iCommerce = pCityAI->AI_specialYieldMultiplier(YIELD_COMMERCE);

				szString.append(CvWString::format(L"\nCity spec mults:  (f%d, h%d, c%d)", iFood, iHammer, iCommerce));

				szString.append(CvWString::format(L"\nExchange"));
				for (int iI = 0; iI < NUM_COMMERCE_TYPES; ++iI)
				{
					iCommerce = GET_PLAYER(pCity->getOwner()).AI_averageCommerceExchange((CommerceTypes)iI);
					szTempBuffer.Format(L", %d%c", iCommerce, GC.getCommerceInfo((CommerceTypes) iI).getChar());
					szString.append(szTempBuffer);
				}

				szString.append(CvWString::format(L"\nAvg mults"));
				for (int iI = 0; iI < NUM_COMMERCE_TYPES; ++iI)
				{
					iCommerce = GET_PLAYER(pCity->getOwner()).AI_averageCommerceMultiplier((CommerceTypes)iI);
					szTempBuffer.Format(L", %d%c", iCommerce, GC.getCommerceInfo((CommerceTypes) iI).getChar());
					szString.append(szTempBuffer);
				}

				if (GET_PLAYER(pCity->getOwner()).AI_isFinancialTrouble())
				{
					szTempBuffer.Format(L"$$$!!!");
					szString.append(szTempBuffer);
				}
			}
			else
			{
				bool bWorkingPlot = pCity->isWorkingPlot(pPlot);

				if (bWorkingPlot)
					szTempBuffer.Format( SETCOLR L"%s is working" ENDCOLR, TEXT_COLOR("COLOR_ALT_HIGHLIGHT_TEXT"), pCity->getName().GetCString());
				else
					szTempBuffer.Format( SETCOLR L"%s not working" ENDCOLR, TEXT_COLOR("COLOR_HIGHLIGHT_TEXT"), pCity->getName().GetCString());
				szString.append(szTempBuffer);

				int iValue = pCityAI->AI_plotValue(pPlot, bAvoidGrowth, /*bRemove*/ bWorkingPlot, /*bIgnoreFood*/ false, bIgnoreGrowth);
				int iJuggleValue = pCityAI->AI_plotValue(pPlot, bAvoidGrowth, /*bRemove*/ bWorkingPlot, false, bIgnoreGrowth, true);
				int iMagicValue = pCityAI->AI_getPlotMagicValue(pPlot, pCityAI->healthRate() == 0);

				szTempBuffer.Format(L"\nvalue = %d\njuggle value = %d\nmagic value = %d", iValue, iJuggleValue, iMagicValue);
				szString.append(szTempBuffer);
			}
		}

		// calc some bonus info
		if (bDebug)
			eBonus = pPlot->getBonusType();
		else eBonus = pPlot->getBonusType(eActiveTeam);

		if (eBonus != NO_BONUS)
		{
			szString.append(CvWString::format(L"\n%s values:", GC.getBonusInfo(eBonus).getDescription()));

			for (int iPlayerIndex = 0; iPlayerIndex < MAX_PLAYERS; iPlayerIndex++)
			{
				CvPlayerAI& kLoopPlayer = GET_PLAYER((PlayerTypes) iPlayerIndex);
				if (kLoopPlayer.isAlive())
				{
					BonusTypes eNonObsBonus = pPlot->getNonObsoleteBonusType(kLoopPlayer.getTeam());
					if (eNonObsBonus != NO_BONUS)
					{
						szString.append(CvWString::format(L"\n %s: %d", kLoopPlayer.getName(), kLoopPlayer.AI_bonusVal(eNonObsBonus)));
					}
					else
					{
						szString.append(CvWString::format(L"\n %s: unknown (%d)", kLoopPlayer.getName(), kLoopPlayer.AI_bonusVal(eBonus)));
					}
				}
			}
		}
	}
	else
	{
		const PlayerTypes eRevealOwner = pPlot->getRevealedOwner(eActiveTeam, true);

		if (eRevealOwner != NO_PLAYER)
		{
			const CvPlayer& pOwner = GET_PLAYER(eRevealOwner);
			if (pPlot->isActiveVisible(true))
			{
				szTempBuffer.Format(SETCOLR L"%s: %s" ENDCOLR,
					pOwner.getPlayerTextColorR(), pOwner.getPlayerTextColorG(), pOwner.getPlayerTextColorB(), pOwner.getPlayerTextColorA(),
					gDLL->getText("TXT_KEY_MISC_OWNER").GetCString(), pOwner.getCivilizationShortDescription());

				if (getBugOptionBOOL("MiscHover__PlotWorkingCity", true, "BUG_PLOT_HOVER_WORKING_CITY"))
				{
					CvCity* pWorkingCity = pPlot->getWorkingCity();

					if (pWorkingCity != NULL && pWorkingCity->getOwner() == GC.getGame().getActivePlayer())
					{
						szTempBuffer.append(L", ");

						if (pWorkingCity->isWorkingPlot(pPlot))
						{
							szTempBuffer.append(CvWString::format(SETCOLR L"%s" ENDCOLR, TEXT_COLOR("COLOR_HIGHLIGHT_TEXT"), pWorkingCity->getName().GetCString()));
						}
						else
						{
							szTempBuffer.append(CvWString::format(L"%s", pWorkingCity->getName().GetCString()));
						}
					}
				}
				szString.append(szTempBuffer);
				szString.append(CvWString::format(L"\n%d%% " SETCOLR L"%s" ENDCOLR L" (%d)\n", pPlot->calculateCulturePercent(eRevealOwner),
					pOwner.getPlayerTextColorR(), pOwner.getPlayerTextColorG(), pOwner.getPlayerTextColorB(), pOwner.getPlayerTextColorA(),
					pOwner.getCivilizationAdjective(), pPlot->getCulture(eRevealOwner)));

				for (int iI = 0; iI < MAX_PLAYERS; iI++)
				{
					if (iI != eRevealOwner && pPlot->getCulture((PlayerTypes)iI) > 0)
					{
						const CvPlayer& playerX = GET_PLAYER((PlayerTypes)iI);
						if (playerX.isAlive())
						{
							szString.append(CvWString::format(L"%d%% " SETCOLR L"%s" ENDCOLR L" (%d)\n", pPlot->calculateCulturePercent((PlayerTypes)iI),
								playerX.getPlayerTextColorR(), playerX.getPlayerTextColorG(), playerX.getPlayerTextColorB(), playerX.getPlayerTextColorA(),
								playerX.getCivilizationAdjective(), pPlot->getCulture((PlayerTypes)iI)));
						}
					}
				}
			}
			else
			{
				szTempBuffer.Format(SETCOLR L"%s" ENDCOLR, GET_PLAYER(eRevealOwner).getPlayerTextColorR(), GET_PLAYER(eRevealOwner).getPlayerTextColorG(), GET_PLAYER(eRevealOwner).getPlayerTextColorB(), GET_PLAYER(eRevealOwner).getPlayerTextColorA(), GET_PLAYER(eRevealOwner).getCivilizationDescription());
				szString.append(szTempBuffer);
				szString.append(NEWLINE);
			}
		}

		const int iDefenseModifier = pPlot->defenseModifier(eRevealOwner != NO_PLAYER ? GET_PLAYER(eRevealOwner).getTeam() : NO_TEAM, true, true);
		if (iDefenseModifier != 0)
		{
			szString.append(gDLL->getText("TXT_KEY_PLOT_BONUS", iDefenseModifier));
			szString.append(NEWLINE);
		}

		if (pPlot->getTerrainType() != NO_TERRAIN)
		{
			if (pPlot->isPeak())
			{
				szString.append(gDLL->getText("TXT_KEY_PLOT_PEAK"));
				szString.append(L"/");
			}
			else if (pPlot->isWater())
			{
				szTempBuffer.Format(SETCOLR, TEXT_COLOR("COLOR_WATER_TEXT"));
				szString.append(szTempBuffer);
			}
			else if (pPlot->isHills())
			{
				szString.append(gDLL->getText("TXT_KEY_PLOT_HILLS"));
			}

			if (pPlot->getFeatureType() != NO_FEATURE)
			{
				szTempBuffer.Format(L"%s/", GC.getFeatureInfo(pPlot->getFeatureType()).getDescription());
				szString.append(szTempBuffer);
			}

			szString.append(GC.getTerrainInfo(pPlot->getTerrainType()).getDescription());

			if (pPlot->isWater())
			{
				szString.append(ENDCOLR);
			}
		}

		if (pPlot->hasYield())
		{
			for (int iI = 0; iI < NUM_YIELD_TYPES; ++iI)
			{
				const int iYield = pPlot->calculateYield(((YieldTypes)iI), true);

				if (iYield != 0)
				{
					szTempBuffer.Format(L", %d%c", iYield, GC.getYieldInfo((YieldTypes) iI).getChar());
					szString.append(szTempBuffer);
				}
			}
		}

		if (pPlot->isFreshWater() && !pPlot->isWater())
		{
			szString.append(NEWLINE);
			szString.append(gDLL->getText("TXT_KEY_PLOT_FRESH_WATER"));
		}

		if (pPlot->isImpassable(eActiveTeam))
		{
			szString.append(NEWLINE);
			szString.append(gDLL->getText("TXT_KEY_PLOT_IMPASSABLE"));
		}
		else
		{
			int iMovementCost = GC.getTerrainInfo(pPlot->getTerrainType()).getMovementCost();

			if (pPlot->getFeatureType() != NO_FEATURE)
			{
				iMovementCost += GC.getFeatureInfo(pPlot->getFeatureType()).getMovementCost();
			}

			if (pPlot->isHills())
			{
				iMovementCost += GC.getHILLS_EXTRA_MOVEMENT();
			}

			if (pPlot->isPeak2(true))
			{
				if (!GET_TEAM(eActiveTeam).isMoveFastPeaks())
				{
					iMovementCost += GC.getPEAK_EXTRA_MOVEMENT();
				}
				else iMovementCost += 1;
			}

			if (iMovementCost != 0)
			{
				szString.append(gDLL->getText("TXT_KEY_PLOT_MOVEMENT_COST", iMovementCost));
			}
		}

		if (pPlot->getRevealedRouteType(eActiveTeam, true) != NO_ROUTE)
		{
			const RouteTypes eRouteType = pPlot->getRevealedRouteType(eActiveTeam, true);
			const CvRouteInfo& eRoute = GC.getRouteInfo(eRouteType);
			const int iRouteCost = eRoute.getMovementCost() + GET_TEAM(eActiveTeam).getRouteChange(eRouteType);

			szTempBuffer.clear();
			szTempBuffer.Format(L"%.2f%c ", (float)iRouteCost / GC.getMOVE_DENOMINATOR(), gDLL->getSymbolID(MOVES_CHAR));

			szString.append(gDLL->getText("TXT_KEY_PLOT_ROUTE_MOVEMENT_COST", szTempBuffer.GetCString(), eRoute.getDescription()));
		}

		if (bDebug)
			eBonus = pPlot->getBonusType();
		else eBonus = pPlot->getBonusType(eActiveTeam);

		if (eBonus != NO_BONUS)
		{
			const CvBonusInfo& bonus = GC.getBonusInfo(eBonus);

			szTempBuffer.Format(L"%c " SETCOLR L"%s" ENDCOLR, bonus.getChar(), TEXT_COLOR("COLOR_HIGHLIGHT_TEXT"), bonus.getDescription());
			szString.append(NEWLINE);
			szString.append(szTempBuffer);

			if (bonus.getHealth() != 0)
			{
				szTempBuffer.Format(L", +%d%c", abs(bonus.getHealth()), bonus.getHealth() > 0 ? gDLL->getSymbolID(HEALTHY_CHAR) : gDLL->getSymbolID(UNHEALTHY_CHAR));
				szString.append(szTempBuffer);
			}

			if (bonus.getHappiness() != 0)
			{
				szTempBuffer.Format(L", +%d%c", abs(bonus.getHappiness()), bonus.getHappiness() > 0 ? gDLL->getSymbolID(HAPPY_CHAR) : gDLL->getSymbolID(UNHAPPY_CHAR));
				szString.append(szTempBuffer);
			}

			if (!GET_TEAM(eActiveTeam).isHasTech((TechTypes)bonus.getTechCityTrade()))
			{
				szString.append(gDLL->getText("TXT_KEY_PLOT_RESEARCH", GC.getTechInfo((TechTypes)bonus.getTechCityTrade()).getTextKeyWide()));
			}

			if (pPlot->getOwner() == GC.getGame().getActivePlayer()
			&& (pPlot->getImprovementType() == NO_IMPROVEMENT || !GC.getImprovementInfo(pPlot->getImprovementType()).isImprovementBonusTrade(eBonus)))
			{
				bool bKnowsValid = false;
				TechTypes eMostRecentObsoletingTech = NO_TECH;
				int iMostRecentX = 0;
				TechTypes eClosestUnlockingTech = NO_TECH;
				int iClosestX = MAX_INT;

				for (int iJ = 0; iJ < GC.getNumImprovementInfos(); iJ++)
				{
					const CvImprovementInfo& improvement = GC.getImprovementInfo((ImprovementTypes)iJ);

					if (improvement.isImprovementBonusTrade(eBonus) && pPlot->canHaveImprovement((ImprovementTypes)iJ, eActiveTeam, true))
					{
						for (int iI = 0; iI < GC.getNumBuildInfos(); ++iI)
						{
							if (GC.getBuildInfo((BuildTypes) iI).getImprovement() == (ImprovementTypes)iJ)
							{
								const TechTypes eObsoleteTech = (TechTypes)GC.getBuildInfo((BuildTypes) iI).getObsoleteTech();

								if (eObsoleteTech != NO_TECH && GET_TEAM(eActiveTeam).isHasTech(eObsoleteTech))
								{
									if (GC.getTechInfo(eObsoleteTech).getGridX() > iMostRecentX)
									{
										iMostRecentX = GC.getTechInfo(eObsoleteTech).getGridX();
										eMostRecentObsoletingTech = eObsoleteTech;
									}
									continue;
								}
								const TechTypes eTechPrereq = (TechTypes)GC.getBuildInfo((BuildTypes) iI).getTechPrereq();

								if (eTechPrereq == NO_TECH || GET_TEAM(eActiveTeam).isHasTech(eTechPrereq))
								{
									if (!bKnowsValid)
									{
										szString.append(gDLL->getText("TXT_KEY_PLOT_REQUIRES", improvement.getTextKeyWide()));
										bKnowsValid = true;
									}
									else
									{
										szString.append(gDLL->getText("TXT_KEY_PLOT_REQUIRES_OR", improvement.getTextKeyWide()));
									}
									for (int iK = 0; iK < NUM_YIELD_TYPES; iK++)
									{
										const int iYieldChange = improvement.getImprovementBonusYield(eBonus, iK) + improvement.getYieldChange(iK);
										if (iYieldChange != 0)
										{
											iYieldChange > 0 ?
												szTempBuffer.Format(L"+%d%c", iYieldChange, GC.getYieldInfo((YieldTypes)iK).getChar())
												:
												szTempBuffer.Format(L"%d%c", iYieldChange, GC.getYieldInfo((YieldTypes)iK).getChar());

											setListHelp(szString, L"\n", szTempBuffer, L", ", true);
											szString.append(gDLL->getText("TXT_KEY_BONUS_WITH_IMPROVEMENT", improvement.getTextKeyWide()));
										}
									}
									break;
								}
								if (GET_PLAYER(GC.getGame().getActivePlayer()).canEverResearch(eTechPrereq) && iClosestX > GC.getTechInfo(eTechPrereq).getGridX())
								{
									iClosestX = GC.getTechInfo(eTechPrereq).getGridX();
									eClosestUnlockingTech = eTechPrereq;
								}
							}
						}
					}
				}
				if (!bKnowsValid)
				{
					if (eClosestUnlockingTech != NO_TECH)
					{
						szString.append(gDLL->getText("TXT_KEY_PLOT_RESEARCH", GC.getTechInfo(eClosestUnlockingTech).getTextKeyWide()));
					}
					else if (eMostRecentObsoletingTech != NO_TECH)
					{
						szString.append(gDLL->getText("TXT_KEY_BUILDING_OBSOLETE_WITH",
							CvWString(GC.getTechInfo(eMostRecentObsoletingTech).getType()).GetCString(), 
							GC.getTechInfo(eMostRecentObsoletingTech).getTextKeyWide()));
					}
				}
			}
			else if (!(pPlot->isBonusNetwork(eActiveTeam)))
			{
				szString.append(gDLL->getText("TXT_KEY_PLOT_REQUIRES_ROUTE"));
			}

			GC.getBonusInfo(eBonus).getPropertyManipulators()->buildDisplayString(szString);

			if (!CvWString(bonus.getHelp()).empty())
			{
				szString.append(NEWLINE);
				szString.append(bonus.getHelp());
			}
		}

		eImprovement = pPlot->getRevealedImprovementType(eActiveTeam, true);

		if (eImprovement != NO_IMPROVEMENT)
		{
			const CvImprovementInfo& impInfo = GC.getImprovementInfo(eImprovement);
			szString.append(NEWLINE);
			szString.append(impInfo.getDescription());

			for (int iI = 0; iI < NUM_YIELD_TYPES; ++iI)
			{
				if (impInfo.getIrrigatedYieldChange(iI) != 0)
				{
					(
						pPlot->isIrrigationAvailable()
						?
						szString.append(gDLL->getText("TXT_KEY_PLOT_IRRIGATED"))
						:
						szString.append(gDLL->getText("TXT_KEY_PLOT_NOT_IRRIGATED"))
					);
					break;
				}
			}
			const TeamTypes ePlotTeam = pPlot->getTeam();

			if (pPlot->isImprovementUpgradable()
			&& (ePlotTeam == eActiveTeam || bDebug && ePlotTeam != NO_TEAM))
			{
				bool bOpenParenthesis = false;
				bool bImpUpgList = false;
				szTempBuffer.clear();
				for (int iI = -1; iI < impInfo.getNumAlternativeImprovementUpgradeTypes(); iI++)
				{
					const ImprovementTypes eUpgradeX =
					(
						iI == -1 ? (ImprovementTypes)impInfo.getImprovementUpgrade()
						:
						(ImprovementTypes)impInfo.getAlternativeImprovementUpgradeType(iI)
					);
					if (pPlot->canHaveImprovement(eUpgradeX, ePlotTeam, false, true))
					{
						if (!bImpUpgList)
						{
							szTempBuffer.append(CvWString::format(L" (%s", GC.getImprovementInfo(eUpgradeX).getDescription()));
							bImpUpgList = true;
						}
						else
						{
							szTempBuffer.append(CvWString::format(L", %s", GC.getImprovementInfo(eUpgradeX).getDescription()));
						}
					}
				}
				if (pPlot->getImprovementUpgradeProgress() >= 100*GC.getGame().getImprovementUpgradeTime(eImprovement))
				{
					szString.append(gDLL->getText("TXT_KEY_IMPROVEMENT_UPGRADE_FROZEN"));
				}
				else if (!bImpUpgList)
				{
					szString.append(gDLL->getText("TXT_KEY_IMPROVEMENT_UPGRADE_BLOCKED"));
				}
				else
				{
					const bool bUpgrading = 
					(
						impInfo.isUpgradeRequiresFortify()
						?
						algo::any_of
						(
							pPlot->units(),
							CvUnit::fn::getFortifyTurns() > 0
							&&
							CvUnit::fn::getTeam() == ePlotTeam
							&&
							CvUnit::fn::canDefend()
						)
						:
						pPlot->isBeingWorked()
					);

					if (pPlot->getImprovementUpgradeProgress() > 0 || bUpgrading)
					{
						bOpenParenthesis = true;
						szString.append
						(
							gDLL->getText
							(
								"TXT_KEY_IMPROVEMENT_UPGRADE_TURNS",
								pPlot->getUpgradeTimeLeft(eImprovement, eRevealOwner)
							)
						);
					}
					if (!bUpgrading)
					{
						if (impInfo.isUpgradeRequiresFortify())
						{
							szString.append(gDLL->getText("TXT_KEY_IMPROVEMENT_UPGRADE_NEED_GARRISON"));
						}
						else if (pPlot->isWithinTeamCityRadius(ePlotTeam))
						{
							szString.append(gDLL->getText("TXT_KEY_IMPROVEMENT_UPGRADE_NEED_WORK"));
						}
					}
				}
				if (bImpUpgList)
				{
					szString.append(szTempBuffer.append(L")"));
					if (bOpenParenthesis) szString.append(L")");
				}
			}
		}

		if (bDebug || GET_TEAM(eActiveTeam).isMapCentering()
		&& getBugOptionBOOL("MiscHover__LatLongCoords", true, "BUG_PLOT_HOVER_LAT_LONG"))
		{
			bool bWest = false;
			int iLong = pPlot->getLongitudeMinutes();
			if (iLong < 0)
			{
				iLong = -iLong;
				bWest = true;
			}
			szString.append(NEWLINE);
			szString.append(gDLL->getText("TXT_KEY_LATLONG", iLong / 60, iLong % 60));
			(
				bWest
				?
				szString.append(gDLL->getText("TXT_KEY_LATLONG_WEST"))
				:
				szString.append(gDLL->getText("TXT_KEY_LATLONG_EAST"))
			);
			bool bSouth = false;
			int iLat = pPlot->getLatitudeMinutes();
			if (iLat < 0)
			{
				iLat = -iLat;
				bSouth = true;
			}
			szString.append(L", ");
			szString.append(gDLL->getText("TXT_KEY_LATLONG", iLat / 60, iLat % 60));
			(
				bSouth
				?
				szString.append(gDLL->getText("TXT_KEY_LATLONG_SOUTH"))
				:
				szString.append(gDLL->getText("TXT_KEY_LATLONG_NORTH"))
			);
		}

		if (pPlot->getLandmarkType() != NO_LANDMARK && GC.getGame().isOption(GAMEOPTION_PERSONALIZED_MAP))
		{
			szString.append(CvWString::format(SETCOLR, TEXT_COLOR("COLOR_HIGHLIGHT_TEXT")));
			szString.append(NEWLINE);
			szString.append(pPlot->getLandmarkMessage());
			szString.append(CvWString::format(ENDCOLR));
		}

/* Toffer - Text is missing...

		if (getBugOptionBOOL("MiscHover__PlotRecommendedBuild", true, "BUG_PLOT_HOVER_RECOMMENDED_BUILD"))
		{
			CvCity* pWorkingCity = pPlot->getWorkingCity();

			if (pWorkingCity != NULL && pWorkingCity->getOwner() == GC.getGame().getActivePlayer())
			{
				BuildTypes eBestBuild = pWorkingCity->AI_getBestBuild(pWorkingCity->getCityPlotIndex(pPlot));

				if (eBestBuild != NO_BUILD)
				{
					const CvBuildInfo& kBestBuild = GC.getBuildInfo(eBestBuild);

					if (pPlot->getImprovementType() != NO_IMPROVEMENT && pPlot->getImprovementType() == kBestBuild.getImprovement())
					{
						eBestBuild = NO_BUILD;
					}
					else if (kBestBuild.getRoute() != NO_ROUTE && (pPlot->isWater() || kBestBuild.getRoute() == pPlot->getRouteType()))
					{
						eBestBuild = NO_BUILD;
					}
					// Koshling - no need to test obsolete build here - AI_getBestBuild() only retruns things it can actually build
				}
				if (eBestBuild != NO_BUILD)
				{
					// Toffer - some text should be added here...
				}
			}
		}
*/

		if (pPlot->hasAnyBuildProgress() && getBugOptionBOOL("MiscHover__PartialBuilds", true, "BUG_PLOT_HOVER_PARTIAL_BUILDS"))
		{
			const PlayerTypes ePlayer = GC.getGame().getActivePlayer();

			for (int iI = 0; iI < GC.getNumBuildInfos(); iI++)
			{
				if (pPlot->getBuildProgress((BuildTypes)iI) > 0 && pPlot->canBuild((BuildTypes)iI, ePlayer))
				{
					const int iTurns = pPlot->getBuildTurnsLeft((BuildTypes)iI, GC.getGame().getActivePlayer());

					if (iTurns > 0 && iTurns < MAX_INT)
					{
						szString.append(NEWLINE);
						szString.append(GC.getBuildInfo((BuildTypes)iI).getDescription());
						szString.append(L": ");
						szString.append(gDLL->getText("TXT_KEY_ACTION_NUM_TURNS", iTurns));
					}
				}
			}
		}

		if (bDebug)
		{
			bool bFirst = true;
			for (int iI = 0; iI < MAX_TEAMS; ++iI)
			{
				if (pPlot->getBlockadedCount((TeamTypes)iI) > 0 && GET_TEAM((TeamTypes)iI).isAlive())
				{
					if (bFirst)
					{
						szString.append(CvWString::format(SETCOLR, TEXT_COLOR("COLOR_NEGATIVE_TEXT")));
						szString.append(NEWLINE);
						szString.append(gDLL->getText("TXT_KEY_PLOT_BLOCKADED"));
						szString.append(CvWString::format(ENDCOLR));

						szString.append(CvWString::format(L"Teams:"));
						bFirst = false;
					}
					szString.append(CvWString::format(L" %s,", GET_TEAM((TeamTypes)iI).getName().c_str()));
				}
			}
		}
		else if (pPlot->getBlockadedCount(eActiveTeam) > 0)
		{
			szString.append(CvWString::format(SETCOLR, TEXT_COLOR("COLOR_NEGATIVE_TEXT")));
			szString.append(NEWLINE);
			szString.append(gDLL->getText("TXT_KEY_PLOT_BLOCKADED"));
			szString.append(CvWString::format(ENDCOLR));
		}
	}

	const int iDamage = pPlot->getTotalTurnDamage();
	if (iDamage > 0)
	{
		szString.append(CvWString::format(SETCOLR, TEXT_COLOR("COLOR_NEGATIVE_TEXT")));
		szString.append(NEWLINE);
		szString.append(gDLL->getText("TXT_KEY_PLOT_DAMAGE", iDamage));
		// TB - Combat Mod
		if (GC.getTerrainInfo(pPlot->getTerrainType()).isColdDamage())
		{
			szString.append(gDLL->getText("TXT_KEY_PLOT_DAMAGE_IS_COLD"));
		}
		// ! TB
		szString.append(CvWString::format(ENDCOLR));
	}
	else if (iDamage < 0)
	{
		szString.append(CvWString::format(SETCOLR, TEXT_COLOR("COLOR_POSITIVE_TEXT")));
		szString.append(NEWLINE);
		szString.append(gDLL->getText("TXT_KEY_PLOT_DAMAGE", iDamage));
		szString.append(CvWString::format(ENDCOLR));
	}

	pPlot->getProperties()->buildDisplayString(szString);

	for (int iI = 0; iI < GC.getNumMapCategoryInfos(); iI++)
	{
		if (pPlot->isMapCategoryType((MapCategoryTypes)iI))
		{
			szString.append(NEWLINE);
			szString.append(gDLL->getText("TXT_KEY_MAP_CATEGORY_TERRAIN", GC.getMapCategoryInfo((MapCategoryTypes)iI).getTextKeyWide()));
		}
	}
}


void CvGameTextMgr::setCityPlotYieldValueString(CvWStringBuffer &szString, CvCity* pCity, int iIndex, bool bAvoidGrowth, bool bIgnoreGrowth, bool bIgnoreFood)
{
	PROFILE_FUNC();

	CvPlot* pPlot = NULL;

	if (iIndex >= 0 && iIndex < NUM_CITY_PLOTS)
		pPlot = pCity->getCityIndexPlot(iIndex);

	if (pPlot != NULL && pPlot->getWorkingCity() == pCity)
	{
		CvCityAI* pCityAI = static_cast<CvCityAI*>(pCity);
		bool bWorkingPlot = pCity->isWorkingPlot(iIndex);

		int iValue = pCityAI->AI_plotValue(pPlot, bAvoidGrowth, /*bRemove*/ bWorkingPlot, bIgnoreFood, bIgnoreGrowth);

		setYieldValueString(szString, iValue, /*bActive*/ bWorkingPlot);
	}
	else
		setYieldValueString(szString, 0, /*bActive*/ false, /*bMakeWhitespace*/ true);
}

void CvGameTextMgr::setYieldValueString(CvWStringBuffer &szString, int iValue, bool bActive, bool bMakeWhitespace)
{
	PROFILE_FUNC();

	static bool bUseFloats = false;

	if (bActive)
		szString.append(CvWString::format(SETCOLR, TEXT_COLOR("COLOR_ALT_HIGHLIGHT_TEXT")));
	else
		szString.append(CvWString::format(SETCOLR, TEXT_COLOR("COLOR_HIGHLIGHT_TEXT")));

	if (!bMakeWhitespace)
	{
		if (bUseFloats)
		{
			float fValue = ((float) iValue) / 10000;
			szString.append(CvWString::format(L"%2.3f " ENDCOLR, fValue));
		}
		else
			szString.append(CvWString::format(L"%05d  " ENDCOLR, iValue/10));
	}
	else
		szString.append(CvWString::format(L"		   " ENDCOLR));
}

void CvGameTextMgr::setCityBarHelp(CvWStringBuffer &szString, CvCity* pCity)
{
	PROFILE_FUNC();

	CvWString szTempBuffer;
	CvWString szTempBuffer2;
	CvWString szTempBuffer3;
	bool bFirst;
	int iFoodDifference;
	int iProductionDiffNoFood;
	int iProductionDiffJustFood;
	int iRate;
	int iI;
// BUG - Base Production and Commerce - start
	bool bBaseValues = (gDLL->ctrlKey() && getBugOptionBOOL("CityBar__BaseValues", true, "BUG_CITYBAR_BASE_VALUES"));
// BUG - Base Production and Commerce - end

	FAssert(pCity->isInViewport());

	iFoodDifference = pCity->foodDifference();

	szString.append(pCity->getName());

// BUG - Health - start
	if (getBugOptionBOOL("CityBar__Health", true, "BUG_CITYBAR_HEALTH"))
	{
		iRate = pCity->goodHealth() - pCity->badHealth();
		if (iRate > 0)
		{
			szTempBuffer.Format(L", %d %c", iRate, gDLL->getSymbolID(HEALTHY_CHAR));
			szString.append(szTempBuffer);
		}
		else if (iRate < 0)
		{
			szTempBuffer.Format(L", %d %c", -iRate, gDLL->getSymbolID(UNHEALTHY_CHAR));
			szString.append(szTempBuffer);
		}
	}
// BUG - Health - end

// BUG - Happiness - start
	if (getBugOptionBOOL("CityBar__Happiness", true, "BUG_CITYBAR_HAPPINESS"))
	{
		if (pCity->isDisorder())
		{
			int iAngryPop = pCity->angryPopulation();
			if (iAngryPop > 0)
			{
				szTempBuffer.Format(L", %d %c", iAngryPop, gDLL->getSymbolID(ANGRY_POP_CHAR));
				szString.append(szTempBuffer);
			}
		}
		else
		{
			iRate = pCity->happyLevel() - pCity->unhappyLevel();
			if (iRate > 0)
			{
				szTempBuffer.Format(L", %d %c", iRate, gDLL->getSymbolID(HAPPY_CHAR));
				szString.append(szTempBuffer);
			}
			else if (iRate < 0)
			{
				szTempBuffer.Format(L", %d %c", -iRate, gDLL->getSymbolID(UNHAPPY_CHAR));
				szString.append(szTempBuffer);
			}
		}
	}
// BUG - Happiness - end

// BUG - Hurry Anger Turns - start
	if (getBugOptionBOOL("CityBar__HurryAnger", true, "BUG_CITYBAR_HURRY_ANGER") && pCity->getOwner() == GC.getGame().getActivePlayer())
	{
		iRate = pCity->getHurryAngerTimer();
		if (iRate > 0)
		{
			int iPop = ((iRate - 1) / pCity->flatHurryAngerLength() + 1) * GC.getDefineINT("HURRY_POP_ANGER");
			szTempBuffer.Format(L" (%d %c %d)", iPop, gDLL->getSymbolID(ANGRY_POP_CHAR), iRate);
			szString.append(szTempBuffer);
		}
	}
// BUG - Anger Anger Turns - end

// BUG - Draft Anger Turns - start
	if (getBugOptionBOOL("CityBar__DraftAnger", true, "BUG_CITYBAR_DRAFT_ANGER") && pCity->getOwner() == GC.getGame().getActivePlayer())
	{
		iRate = pCity->getConscriptAngerTimer();
		if (iRate > 0)
		{
			int iPop = ((iRate - 1) / pCity->flatConscriptAngerLength() + 1) * GC.getDefineINT("CONSCRIPT_POP_ANGER");
			szTempBuffer.Format(L" (%d %c %d)", iPop, gDLL->getSymbolID(CITIZEN_CHAR), iRate);
			szString.append(szTempBuffer);
		}
	}
// BUG - Draft Anger Turns - end

// BUG - Food Assist - start
	if ((iFoodDifference != 0 || !pCity->isFoodProduction()) && getBugOptionBOOL("CityBar__FoodAssist", true, "BUG_CITYBAR_FOOD_ASSIST"))
	{
		if (iFoodDifference > 0)
		{
			szString.append(gDLL->getText("TXT_KEY_CITY_BAR_FOOD_GROW", iFoodDifference, pCity->getFood(), pCity->growthThreshold(), pCity->getFoodTurnsLeft()));
		}
		else if (iFoodDifference == 0)
		{
			szString.append(gDLL->getText("TXT_KEY_CITY_BAR_FOOD_STAGNATE", pCity->getFood(), pCity->growthThreshold()));
		}
		else if (pCity->getFood() + iFoodDifference >= 0)
		{
			int iTurnsToStarve = pCity->getFood() / -iFoodDifference + 1;
			szString.append(gDLL->getText("TXT_KEY_CITY_BAR_FOOD_SHRINK", iFoodDifference, pCity->getFood(), pCity->growthThreshold(), iTurnsToStarve));
		}
		else
		{
			szString.append(gDLL->getText("TXT_KEY_CITY_BAR_FOOD_STARVE", iFoodDifference, pCity->getFood(), pCity->growthThreshold()));
		}
	}
	else
	{
		// unchanged
		if (iFoodDifference <= 0)
		{
			szString.append(gDLL->getText("TXT_KEY_CITY_BAR_GROWTH", pCity->getFood(), pCity->growthThreshold()));
		}
		else
		{
			szString.append(gDLL->getText("TXT_KEY_CITY_BAR_FOOD_GROWTH", iFoodDifference, pCity->getFood(), pCity->growthThreshold(), pCity->getFoodTurnsLeft()));
		}
	}
// BUG - Food Assist - end

	if (pCity->getProductionNeeded() != MAX_INT)
	{
// BUG - Base Production - start
		int iBaseProductionDiffNoFood;
		if (bBaseValues)
		{
			//TB Traits begin
			iBaseProductionDiffNoFood = pCity->getModifiedBaseYieldRate(YIELD_PRODUCTION);
			//TB Traits end
		}
		else
		{
			iBaseProductionDiffNoFood = pCity->getCurrentProductionDifference(ProductionCalc::None);
		}
// BUG - Base Production - end

		iProductionDiffNoFood = pCity->getCurrentProductionDifference(ProductionCalc::Overflow);
		iProductionDiffJustFood = (pCity->getCurrentProductionDifference(ProductionCalc::FoodProduction | ProductionCalc::Overflow) - iProductionDiffNoFood);

		if (iProductionDiffJustFood > 0)
		{
// BUG - Base Production - start
			if ((iProductionDiffNoFood != iBaseProductionDiffNoFood) && getBugOptionBOOL("CityBar__BaseProduction", true, "BUG_CITYBAR_BASE_PRODUCTION"))
			{
				szString.append(gDLL->getText("TXT_KEY_CITY_BAR_FOOD_HAMMER_PRODUCTION_WITH_BASE", iProductionDiffJustFood, iProductionDiffNoFood, pCity->getProductionName(), pCity->getProduction(), pCity->getProductionNeeded(), pCity->getProductionTurnsLeft(), iBaseProductionDiffNoFood));
			}
			else
			{
				// unchanged
				szString.append(gDLL->getText("TXT_KEY_CITY_BAR_FOOD_HAMMER_PRODUCTION", iProductionDiffJustFood, iProductionDiffNoFood, pCity->getProductionName(), pCity->getProduction(), pCity->getProductionNeeded(), pCity->getProductionTurnsLeft()));
			}
// BUG - Base Production - end
		}
		else if (iProductionDiffNoFood > 0)
		{
// BUG - Base Production - start
			if ((iProductionDiffNoFood != iBaseProductionDiffNoFood) && getBugOptionBOOL("CityBar__BaseProduction", true, "BUG_CITYBAR_BASE_PRODUCTION"))
			{
				szString.append(gDLL->getText("TXT_KEY_CITY_BAR_HAMMER_PRODUCTION_WITH_BASE", iProductionDiffNoFood, pCity->getProductionName(), pCity->getProduction(), pCity->getProductionNeeded(), pCity->getProductionTurnsLeft(), iBaseProductionDiffNoFood));
			}
			else
			{
				// unchanged
				szString.append(gDLL->getText("TXT_KEY_CITY_BAR_HAMMER_PRODUCTION", iProductionDiffNoFood, pCity->getProductionName(), pCity->getProduction(), pCity->getProductionNeeded(), pCity->getProductionTurnsLeft()));
			}
// BUG - Base Production - end
		}
		else
		{
			szString.append(gDLL->getText("TXT_KEY_CITY_BAR_PRODUCTION", pCity->getProductionName(), pCity->getProduction(), pCity->getProductionNeeded()));
		}

// BUG - Building Actual Effects - start
		if (pCity->getOwner() == GC.getGame().getActivePlayer() && getBugOptionBOOL("CityBar__BuildingActualEffects", true, "BUG_CITYBAR_BUILDING_ACTUAL_EFFECTS"))
		{
			if (pCity->isProductionBuilding())
			{
				BuildingTypes eBuilding = pCity->getProductionBuilding();
				CvWString szStart;

				szStart.Format(NEWLINE L"<img=%S size=24></img>", GC.getBuildingInfo(eBuilding).getButton());
				setBuildingActualEffects(szString, szStart, eBuilding, pCity, false);
			}
		}
// BUG - Building Actual Effects - end
	}
// BUG - Base Production - start
	else if (getBugOptionBOOL("CityBar__BaseProduction", true, "BUG_CITYBAR_BASE_PRODUCTION"))
	{
		int iOverflow = pCity->getOverflowProduction();
		int iBaseProductionDiffNoFood;
		if (bBaseValues)
		{
			//TB Traits begin
			iBaseProductionDiffNoFood = pCity->getModifiedBaseYieldRate(YIELD_PRODUCTION);
			//TB Traits end
		}
		else
		{
			iBaseProductionDiffNoFood = pCity->getCurrentProductionDifference(ProductionCalc::Overflow);
		}
		if (iOverflow > 0 || iBaseProductionDiffNoFood > 0)
		{
			if (iOverflow > 0)
			{
				szString.append(gDLL->getText("TXT_KEY_CITY_BAR_BASE_PRODUCTION_WITH_OVERFLOW", iOverflow, iBaseProductionDiffNoFood));
			}
			else
			{
				szString.append(gDLL->getText("TXT_KEY_CITY_BAR_BASE_PRODUCTION", iBaseProductionDiffNoFood));
			}
		}
	}
// BUG - Base Production - end

// BUG - Hurry Assist - start
	if (getBugOptionBOOL("CityBar__HurryAssist", true, "BUG_CITYBAR_HURRY_ASSIST") && pCity->getOwner() == GC.getGame().getActivePlayer())
	{
		bool bFirstHurry = true;
		for (iI = 0; iI < GC.getNumHurryInfos(); iI++)
		{
			if (pCity->canHurry((HurryTypes)iI))
			{
				if (bFirstHurry)
				{
					szString.append(NEWLINE);
					szString.append("Hurry:");
					bFirstHurry = false;
				}
				bFirst = true;
				szString.append(L" (");
				int iPopulation = pCity->hurryPopulation((HurryTypes)iI);
				if (iPopulation > 0)
				{
					szTempBuffer.Format(L"%d %c", -iPopulation, gDLL->getSymbolID(CITIZEN_CHAR));
					setListHelp(szString, NULL, szTempBuffer, L", ", bFirst);
					bFirst = false;
				}
				int iGold = pCity->hurryGold((HurryTypes)iI);
				if (iGold > 0)
				{
					szTempBuffer.Format(L"%d %c", -iGold, GC.getCommerceInfo(COMMERCE_GOLD).getChar());
					setListHelp(szString, NULL, szTempBuffer, L", ", bFirst);
					bFirst = false;
				}
				int iOverflowProduction = 0;
				int iOverflowGold = 0;
				if (pCity->hurryOverflow((HurryTypes)iI, &iOverflowProduction, &iOverflowGold, getBugOptionBOOL("CityBar__HurryAssistIncludeCurrent", false, "BUG_CITYBAR_HURRY_ASSIST_INCLUDE_CURRENT")))
				{
					if (iOverflowProduction > 0)
					{
						szTempBuffer.Format(L"%d %c", iOverflowProduction, GC.getYieldInfo(YIELD_PRODUCTION).getChar());
						setListHelp(szString, NULL, szTempBuffer, L", ", bFirst);
						bFirst = false;
					}
					if (iOverflowGold > 0)
					{
						szTempBuffer.Format(L"%d %c", iOverflowGold, GC.getCommerceInfo(COMMERCE_GOLD).getChar());
						setListHelp(szString, NULL, szTempBuffer, L", ", bFirst);
						bFirst = false;
					}
				}
				szString.append(L")");
			}
		}
	}
// BUG - Hurry Assist - end

// BUG - Trade Detail - start
	if (getBugOptionBOOL("CityBar__TradeDetail", true, "BUG_CITYBAR_TRADE_DETAIL"))
	{
		int iTotalTrade = 0;
		int iDomesticTrade = 0;
		int iDomesticRoutes = 0;
		int iForeignTrade = 0;
		int iForeignRoutes = 0;

// BUG - Fractional Trade Routes - start
#ifdef _MOD_FRACTRADE
		bool bFractions = true;
#else
		bool bFractions = bBaseValues;
#endif
// BUG - Fractional Trade Routes - end

		pCity->calculateTradeTotals(YIELD_COMMERCE, iDomesticTrade, iDomesticRoutes, iForeignTrade, iForeignRoutes, NO_PLAYER, !bFractions, bBaseValues);
		iTotalTrade = iDomesticTrade + iForeignTrade;

		bFirst = true;
		if (iTotalTrade != 0)
		{
			if (bFractions)
			{
				szTempBuffer.Format(L"%c: %d.%02d %c", gDLL->getSymbolID(TRADE_CHAR), iTotalTrade / 100, iTotalTrade % 100, GC.getYieldInfo(YIELD_COMMERCE).getChar());
			}
			else
			{
				szTempBuffer.Format(L"%c: %d %c", gDLL->getSymbolID(TRADE_CHAR), iTotalTrade, GC.getYieldInfo(YIELD_COMMERCE).getChar());
			}
			setListHelp(szString, NEWLINE, szTempBuffer, L", ", bFirst);
			bFirst = false;
		}
		if (iDomesticTrade != 0)
		{
			if (bFractions)
			{
				szTempBuffer.Format(L"%c: %d.%02d %c", gDLL->getSymbolID(STAR_CHAR), iDomesticTrade / 100, iDomesticTrade % 100, GC.getYieldInfo(YIELD_COMMERCE).getChar());
			}
			else
			{
				szTempBuffer.Format(L"%c: %d %c", gDLL->getSymbolID(STAR_CHAR), iDomesticTrade, GC.getYieldInfo(YIELD_COMMERCE).getChar());
			}
			setListHelp(szString, NEWLINE, szTempBuffer, L", ", bFirst);
			bFirst = false;
		}
		if (iForeignTrade != 0)
		{
			if (bFractions)
			{
				szTempBuffer.Format(L"%c: %d.%02d %c", gDLL->getSymbolID(SILVER_STAR_CHAR), iForeignTrade / 100, iForeignTrade % 100, GC.getYieldInfo(YIELD_COMMERCE).getChar());
			}
			else
			{
				szTempBuffer.Format(L"%c: %d %c", gDLL->getSymbolID(SILVER_STAR_CHAR), iForeignTrade, GC.getYieldInfo(YIELD_COMMERCE).getChar());
			}
			setListHelp(szString, NEWLINE, szTempBuffer, L", ", bFirst);
			bFirst = false;
		}
	}
// BUG - Trade Detail - end

	bFirst = true;

// BUG - Commerce - start
	if (getBugOptionBOOL("CityBar__Commerce", true, "BUG_CITYBAR_COMMERCE"))
	{
		if (bBaseValues)
		{
			//TB Traits begin
			iRate = pCity->getModifiedBaseYieldRate(YIELD_COMMERCE);
			//TB Traits end
		}
		else
		{
			iRate = pCity->getYieldRate(YIELD_COMMERCE);
		}
		if (iRate != 0)
		{
			szTempBuffer.Format(L"%d %c", iRate, GC.getYieldInfo(YIELD_COMMERCE).getChar());
			setListHelp(szString, NEWLINE, szTempBuffer, L", ", bFirst);
			bFirst = false;
		}
	}
// BUG - Commerce - end

	for (iI = 0; iI < NUM_COMMERCE_TYPES; ++iI)
	{
// BUG - Base Values - start
		if (bBaseValues)
		{
			iRate = pCity->getBaseCommerceRateTimes100((CommerceTypes)iI);
		}
		else
		{
			// unchanged
			iRate = pCity->getCommerceRateTimes100((CommerceTypes)iI);
		}
// BUG - Base Values - end

		if (iRate != 0)
		{
			szTempBuffer.Format(L"%d.%02d %c", iRate/100, iRate%100, GC.getCommerceInfo((CommerceTypes)iI).getChar());
			setListHelp(szString, NEWLINE, szTempBuffer, L", ", bFirst);
			bFirst = false;
		}
	}

// BUG - Base Values - start
	if (bBaseValues)
	{
		iRate = pCity->getBaseGreatPeopleRate();
	}
	else
	{
		// unchanged
		iRate = pCity->getGreatPeopleRate();
	}
// BUG - Base Values - end

	if (iRate != 0)
	{
		szTempBuffer.Format(L"%d%c", iRate, gDLL->getSymbolID(GREAT_PEOPLE_CHAR));
		setListHelp(szString, NEWLINE, szTempBuffer, L", ", bFirst);
		bFirst = false;
	}

	if (!bFirst)
	{
		szString.append(gDLL->getText("TXT_KEY_PER_TURN"));
	}

	szString.append(NEWLINE);
	szString.append(gDLL->getText("INTERFACE_CITY_MAINTENANCE"));
// BUG - Base Values - start
	int iMaintenance;
	if (bBaseValues)
	{
		iMaintenance = pCity->calculateBaseMaintenanceTimes100();
	}
	else
	{
		// unchanged
		iMaintenance = pCity->getMaintenanceTimes100();
	}
// BUG - Base Values - end
	szString.append(CvWString::format(L" -%d.%02d %c", iMaintenance/100, iMaintenance%100, GC.getCommerceInfo(COMMERCE_GOLD).getChar()));

// BUG - Building Icons - start
// AIAndy: Changed to show only national and world wonders
	if (getBugOptionBOOL("CityBar__BuildingIcons", true, "BUG_CITYBAR_BUILDING_ICONS"))
	{
		bFirst = true;
		for (iI = 0; iI < GC.getNumBuildingInfos(); ++iI)
		{
			if (isWorldWonder((BuildingTypes)iI) || isNationalWonder((BuildingTypes)iI))
			{
				if (pCity->getNumRealBuilding((BuildingTypes)iI) > 0)
				{
					if (bFirst)
					{
						szString.append(NEWLINE);
						bFirst = false;
					}
					szTempBuffer.Format(L"<img=%S size=24></img>", GC.getBuildingInfo((BuildingTypes)iI).getButton());
					szString.append(szTempBuffer);
				}
			}
		}
	}
	else
	{
		// unchanged
		bFirst = true;
		for (iI = 0; iI < GC.getNumBuildingInfos(); ++iI)
		{
			if (isWorldWonder((BuildingTypes)iI) || isNationalWonder((BuildingTypes)iI))
			{
				if (pCity->getNumRealBuilding((BuildingTypes)iI) > 0)
				{
					setListHelp(szString, NEWLINE, GC.getBuildingInfo((BuildingTypes)iI).getDescription(), L", ", bFirst);
					bFirst = false;
				}
			}
		}
	}
// BUG - Building Icons - end

// BUG - Culture Turns - start
	int iCultureRate = pCity->getCommerceRateTimes100(COMMERCE_CULTURE);
	if (iCultureRate > 0 && getBugOptionBOOL("CityBar__CultureTurns", true, "BUG_CITYBAR_CULTURE_TURNS"))
	{
		if (pCity->getCultureLevel() != NO_CULTURELEVEL)
		{
			szString.append(gDLL->getText("TXT_KEY_CITY_BAR_CULTURE", pCity->getCulture(pCity->getOwner()), pCity->getCultureThreshold(), GC.getCultureLevelInfo(pCity->getCultureLevel()).getTextKeyWide()));
		}
		else
		{
			szString.append(gDLL->getText("TXT_KEY_CITY_BAR_CULTURE_NO_LEVEL", pCity->getCulture(pCity->getOwner()), pCity->getCultureThreshold()));
		}
		// all values are *100
		int iCulture = pCity->getCultureTimes100(pCity->getOwner());
		int iCultureLeft = 100 * pCity->getCultureThreshold() - iCulture;
		int iCultureTurns = (iCultureLeft + iCultureRate - 1) / iCultureRate;
		szString.append(L" ");
		szString.append(gDLL->getText("INTERFACE_CITY_TURNS", iCultureTurns));
	}
	else
	{
		// unchanged
		if (pCity->getCultureLevel() != NO_CULTURELEVEL)
		{
			szString.append(gDLL->getText("TXT_KEY_CITY_BAR_CULTURE", pCity->getCulture(pCity->getOwner()), pCity->getCultureThreshold(), GC.getCultureLevelInfo(pCity->getCultureLevel()).getTextKeyWide()));
		}
	}
// BUG - Culture Turns - end

// BUG - Great Person Turns - start
	int iGppRate = pCity->getGreatPeopleRate();
	if (iGppRate > 0 && getBugOptionBOOL("CityBar__GreatPersonTurns", true, "BUG_CITYBAR_GREAT_PERSON_TURNS"))
	{
		int iGpp = pCity->getGreatPeopleProgress();
		int iGppTotal = GET_PLAYER(pCity->getOwner()).greatPeopleThresholdNonMilitary();
		szString.append(gDLL->getText("TXT_KEY_CITY_BAR_GREAT_PEOPLE", iGpp, iGppTotal));
		int iGppLeft = iGppTotal - iGpp;
		int iGppTurns = (iGppLeft + iGppRate - 1) / iGppRate;
		szString.append(L" ");
		szString.append(gDLL->getText("INTERFACE_CITY_TURNS", iGppTurns));
	}
	else
	{
		// unchanged
		if (pCity->getGreatPeopleProgress() > 0)
		{
			szString.append(gDLL->getText("TXT_KEY_CITY_BAR_GREAT_PEOPLE", pCity->getGreatPeopleProgress(), GET_PLAYER(pCity->getOwner()).greatPeopleThresholdNonMilitary()));
		}
	}
// BUG - Great Person Turns - end

// BUG - Specialists - start
	if (getBugOptionBOOL("CityBar__Specialists", true, "BUG_CITYBAR_SPECIALISTS"))
	{
		// regular specialists
		bFirst = true;
		for (int iI = 0; iI < GC.getNumSpecialistInfos(); ++iI)
		{
			const int iCount = pCity->getSpecialistCount((SpecialistTypes)iI);
			if (iCount > 0)
			{
				if (bFirst)
				{
					szString.append(NEWLINE);
				}
				const CvSpecialistInfo& kSpecialistInfo = GC.getSpecialistInfo((SpecialistTypes)iI);
				//for (int iJ = 0; iJ < iCount; ++iJ)
				//{
				if (!bFirst)
				{
					szString.append(gDLL->getText("TXT_KEY_COMMA", iCount));
				}
				szTempBuffer.Format(L"<img=%S size=24></img>", kSpecialistInfo.getButton());
				szString.append(szTempBuffer);
				szString.append(gDLL->getText("TXT_KEY_INTERFACE_CITY_BAR_SPECIALIST_ADDENDUM", iCount));
				if (bFirst)
				{
					bFirst = false;
				}

				//}
			}
		}

		// free specialists (ToA, GL) and settled great people
		bFirst = true;
		for (int iI = 0; iI < GC.getNumSpecialistInfos(); ++iI)
		{
			const int iCount = pCity->getFreeSpecialistCount((SpecialistTypes)iI);
			if (iCount > 0)
			{
				if (bFirst)
				{
					szString.append(NEWLINE);
				}
				const CvSpecialistInfo& kSpecialistInfo = GC.getSpecialistInfo((SpecialistTypes)iI);
				//for (int iJ = 0; iJ < iCount; ++iJ)
				//{
				if (!bFirst)
				{
					szString.append(gDLL->getText("TXT_KEY_COMMA", iCount));
				}
				szTempBuffer.Format(L"<img=%S size=24></img>", kSpecialistInfo.getButton());
				szString.append(szTempBuffer);
				szString.append(gDLL->getText("TXT_KEY_INTERFACE_CITY_BAR_SPECIALIST_ADDENDUM", iCount));
				if (bFirst)
				{
					bFirst = false;
				}

				//}
			}
		}
	}
// BUG - Specialists - end

	int iNumUnits = pCity->plot()->countNumAirUnits(GC.getGame().getActiveTeam());
	if (GC.getGame().isOption(GAMEOPTION_SIZE_MATTERS))
	{
		iNumUnits = pCity->plot()->countNumAirUnitCargoVolume(GC.getGame().getActiveTeam());
		if (pCity->getSMAirUnitCapacity(GC.getGame().getActiveTeam()) > 0 && iNumUnits > 0)
		{
			szString.append(NEWLINE);
			szString.append(gDLL->getText("TXT_KEY_CITY_BAR_AIR_UNIT_CAPACITY", iNumUnits, pCity->getSMAirUnitCapacity(GC.getGame().getActiveTeam())));
		}
	}
	else if (pCity->getAirUnitCapacity(GC.getGame().getActiveTeam()) > 0 && iNumUnits > 0)
	{
		szString.append(NEWLINE);
		szString.append(gDLL->getText("TXT_KEY_CITY_BAR_AIR_UNIT_CAPACITY", iNumUnits, pCity->getAirUnitCapacity(GC.getGame().getActiveTeam())));
	}

// BUG - Revolt Chance - start
	if (getBugOptionBOOL("CityBar__RevoltChance", true, "BUG_CITYBAR_REVOLT_CHANCE"))
	{
		PlayerTypes eCulturalOwner = pCity->plot()->calculateCulturalOwner();

		if (eCulturalOwner != NO_PLAYER)
		{
			if (GET_PLAYER(eCulturalOwner).getTeam() != pCity->getTeam())
			{
				int iOriginal = 0;
				int iCityStrength = pCity->cultureStrength(eCulturalOwner, iOriginal);
				int iGarrison = pCity->cultureGarrison(eCulturalOwner);

				if (iCityStrength > 0)
				{
					szTempBuffer.Format(L"" SETCOLR L"%.2f" ENDCOLR,TEXT_COLOR("COLOR_HIGHLIGHT_TEXT"),(float)iCityStrength);
					szTempBuffer2.Format(L"" SETCOLR L"%.2f" ENDCOLR,TEXT_COLOR("COLOR_HIGHLIGHT_TEXT"),(float)iOriginal);
					szTempBuffer3.Format(L"" SETCOLR L"%.2f" ENDCOLR,TEXT_COLOR("COLOR_HIGHLIGHT_TEXT"),(float)iGarrison);
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_MISC_CHANCE_OF_REVOLT_C2C", szTempBuffer.GetCString(), szTempBuffer2.GetCString(), szTempBuffer3.GetCString()));
				}
			}
		}
	}
// BUG - Revolt Chance - end

	// Citybar revolution info
	if (GC.getGame().isOption(GAMEOPTION_REVOLUTION))
	{
		szString.append(NEWLINE);
		szString.append(L"<img=Art/Interface/Buttons/revbtn.dds size=23></img>");
		szString.append(CvWString::format(L":%d", pCity->getRevolutionIndex()));
		szString.append(NEWLINE);
	}

	if (pCity->getExtraYieldTurns() > 0)
	{
		szString.append(NEWLINE);
		szString.append(gDLL->getText("TXT_KEY_MISC_EXTRA_HAMMERS_TURNS", pCity->getExtraYieldTurns()));
	}
	else if (pCity->getExtraYieldTurns() < 0)
	{
		szString.append(NEWLINE);
		szString.append(gDLL->getText("TXT_KEY_MISC_EXTRA_FOOD_TURNS", -pCity->getExtraYieldTurns()));
	}
	pCity->getProperties()->buildDisplayString(szString);

// BUG - Hide UI Instructions - start
	if (!getBugOptionBOOL("CityBar__HideInstructions", true, "BUG_CITYBAR_HIDE_INSTRUCTIONS"))
	{
		if (getBugOptionBOOL("CityBar__BaseValues", true, "BUG_CITYBAR_BASE_VALUES"))
		{
			szString.append(gDLL->getText("TXT_KEY_CITY_BAR_CTRL_BASE_VALUES"));
		}
		// unchanged
		szString.append(gDLL->getText("TXT_KEY_CITY_BAR_SELECT", pCity->getNameKey()));
		szString.append(gDLL->getText("TXT_KEY_CITY_BAR_SELECT_CTRL"));
		szString.append(gDLL->getText("TXT_KEY_CITY_BAR_SELECT_ALT"));
	}
// BUG - Hide UI Instructions - end
}

void CvGameTextMgr::parseBuildUp(CvWStringBuffer &szHelpString, PromotionLineTypes ePromotionLine, CivilizationTypes eCivilization)
{
	// TB Traits
	PROFILE_FUNC();
	CvWString szTempBuffer;
	CvWString szText;

	// Trait Name
	szText = GC.getPromotionLineInfo(ePromotionLine).getDescription();
	szTempBuffer.Format(NEWLINE SETCOLR L"%s" ENDCOLR, TEXT_COLOR("COLOR_ALT_HIGHLIGHT_TEXT"), szText.GetCString());
	szHelpString.append(szTempBuffer);

	if (!CvWString(GC.getPromotionLineInfo(ePromotionLine).getHelp()).empty())
	{
		szHelpString.append(NEWLINE);
		szHelpString.append(GC.getPromotionLineInfo(ePromotionLine).getHelp());
	}
}

void CvGameTextMgr::parseTraits(CvWStringBuffer &szHelpString, TraitTypes eTrait, CivilizationTypes eCivilization, bool bDawnOfMan, bool bEffectsOnly)
{
	// TB Traits
	PROFILE_FUNC();

	CvWString szFirstBuffer;
	CvWString szTempBuffer;
	CvWString szImprovement;
	bool bHasBegun = false;
	TraitTypes eLoopTrait;
	int iLast;
	int iI, iJ;
	CvWString szText;
	int iCurrentModifier = 0;
	std::vector<int> iIterationValues;
	bool bFound = false;
	bool bFirst = true;

	// Trait Name
	szText = GC.getTraitInfo(eTrait).getDescription();
	if (bDawnOfMan)
	{
		szTempBuffer.Format(L"%s", szText.GetCString());
	}
	else
	{
		szTempBuffer.Format(SETCOLR L"%s" ENDCOLR, TEXT_COLOR("COLOR_ALT_HIGHLIGHT_TEXT"), szText.GetCString());
	}

	if (!bEffectsOnly)
		szHelpString.append(szTempBuffer);

	if (!bDawnOfMan)
	{
		if (!CvWString(GC.getTraitInfo(eTrait).getHelp()).empty())
		{
			szHelpString.append(GC.getTraitInfo(eTrait).getHelp());
		}
		//Negative Trait denotation
		if (GC.getTraitInfo(eTrait).isNegativeTrait())
		{
			szHelpString.append(NEWLINE);
			szHelpString.append(gDLL->getText("TXT_KEY_TRAIT_NEGATIVE"));
		}
		//Negative Trait denotation
		if (GC.getTraitInfo(eTrait).isCivilizationTrait())
		{
			szHelpString.append(NEWLINE);
			szHelpString.append(gDLL->getText("TXT_KEY_TRAIT_CIVILIZATION"));
		}
		//On Game Option denotation
		for (int i = 0; i < NUM_GAMEOPTION_TYPES; i++)
		{
			if (GC.getTraitInfo(eTrait).isOnGameOption(i))
			{
				szHelpString.append(NEWLINE);
				szHelpString.append(gDLL->getText("TXT_KEY_TRAIT_ON_GAME_OPTION", GC.getGameOptionInfo((GameOptionTypes)i).getDescription()));
			}
		}
		//Not On Game Option denotation
		for (int i = 0; i < NUM_GAMEOPTION_TYPES; i++)
		{
			if (GC.getTraitInfo(eTrait).isNotOnGameOption(i))
			{
				szHelpString.append(NEWLINE);
				szHelpString.append(gDLL->getText("TXT_KEY_TRAIT_NOT_ON_GAME_OPTION", GC.getGameOptionInfo((GameOptionTypes)i).getDescription()));
			}
		}

		//Leaderhead Levelup option prereq notations
		if (GC.getGame().isOption(GAMEOPTION_LEADERHEAD_LEVELUPS))
		{
			if (GC.getTraitInfo(eTrait).getPromotionLine() != NO_PROMOTIONLINE)
			{
				szHelpString.append(NEWLINE);
				szHelpString.append(gDLL->getText("TXT_KEY_PROMOTION_LINE_TEXT", GC.getPromotionLineInfo((PromotionLineTypes)GC.getTraitInfo(eTrait).getPromotionLine()).getDescription()));

				if (GC.getTraitInfo(eTrait).getLinePriority() > 0)
				{
					szHelpString.append(NEWLINE);
					szHelpString.append(gDLL->getText("TXT_KEY_PROMOTION_LINE_PRIORITY",GC.getTraitInfo(eTrait).getLinePriority()));
				}
			}
			if (GC.getGame().getActivePlayer() != NO_PLAYER)
			{
				for (iI = 0; iI < GC.getNumTraitInfos(); iI++)
				{
					eLoopTrait = ((TraitTypes)iI);
					if (!GET_PLAYER(GC.getGame().getActivePlayer()).canLearnTrait(eTrait))
					{
						if (GC.getTraitInfo(eLoopTrait).getPromotionLine() != NO_PROMOTIONLINE)
						{
							if (GC.getTraitInfo(eTrait).getLinePriority() > 1)
							{
								if (GC.getTraitInfo(eTrait).getPromotionLine() == GC.getTraitInfo(eLoopTrait).getPromotionLine() &&
									GC.getTraitInfo(eLoopTrait).getLinePriority() < GC.getTraitInfo(eTrait).getLinePriority() &&
									!GET_PLAYER(GC.getGame().getActivePlayer()).hasTrait(eLoopTrait) &&
									GC.getTraitInfo(eLoopTrait).getLinePriority() > 0)
								{
									if (!bHasBegun)
									{
										bHasBegun = true;
										szHelpString.append(NEWLINE);
										szHelpString.append(gDLL->getText("TXT_KEY_TRAIT_PREREQ_BEGIN", GC.getTraitInfo(eLoopTrait).getTextKeyWide()));
									}
									else
									{
										szHelpString.append(gDLL->getText("TXT_KEY_TRAIT_PREREQ_AND_ENTRY", GC.getTraitInfo(eLoopTrait).getTextKeyWide()));
									}
								}
							}
							else if (GC.getTraitInfo(eTrait).getLinePriority() < 1)
							{
								if (GC.getTraitInfo(eTrait).getPromotionLine() == GC.getTraitInfo(eLoopTrait).getPromotionLine() &&
									GC.getTraitInfo(eLoopTrait).getLinePriority() > GC.getTraitInfo(eTrait).getLinePriority() &&
									!GET_PLAYER(GC.getGame().getActivePlayer()).hasTrait(eLoopTrait) &&
									GC.getTraitInfo(eLoopTrait).getLinePriority() < 0)
								{
									if (!bHasBegun)
									{
										bHasBegun = true;
										szHelpString.append(NEWLINE);
										szHelpString.append(gDLL->getText("TXT_KEY_TRAIT_PREREQ_BEGIN", GC.getTraitInfo(eLoopTrait).getTextKeyWide()));
									}
									else
									{
										szHelpString.append(gDLL->getText("TXT_KEY_TRAIT_PREREQ_AND_ENTRY", GC.getTraitInfo(eLoopTrait).getTextKeyWide()));
									}
								}
							}
						}

						if (GC.getTraitInfo(eTrait).getPromotionLine() != GC.getTraitInfo(eLoopTrait).getPromotionLine())
						{
							if (GC.getTraitInfo(eTrait).getPrereqTrait() != NO_TRAIT)
							{
								if ((TraitTypes)GC.getTraitInfo(eTrait).getPrereqTrait() == eLoopTrait &&
									!GET_PLAYER(GC.getGame().getActivePlayer()).hasTrait(eLoopTrait))
								{
									if (!bHasBegun)
									{
										bHasBegun = true;
										szHelpString.append(NEWLINE);
										szHelpString.append(gDLL->getText("TXT_KEY_TRAIT_PREREQ_BEGIN", GC.getTraitInfo(eLoopTrait).getTextKeyWide()));
									}
									else
									{
										szHelpString.append(gDLL->getText("TXT_KEY_TRAIT_PREREQ_AND_ENTRY", GC.getTraitInfo(eLoopTrait).getTextKeyWide()));
									}
								}
								if (GC.getTraitInfo(eTrait).getPrereqOrTrait1() != NO_TRAIT)
								{
									if ((TraitTypes)GC.getTraitInfo(eTrait).getPrereqOrTrait1() == eLoopTrait &&
										!GET_PLAYER(GC.getGame().getActivePlayer()).hasTrait(eLoopTrait))
									{
										if (!bHasBegun)
										{
											bHasBegun = true;
											szHelpString.append(NEWLINE);
											szHelpString.append(gDLL->getText("TXT_KEY_TRAIT_PREREQ_BEGIN", GC.getTraitInfo(eLoopTrait).getTextKeyWide()));
										}
										else
										{
											szHelpString.append(gDLL->getText("TXT_KEY_TRAIT_PREREQ_AND_ENTRY", GC.getTraitInfo(eLoopTrait).getTextKeyWide()));
										}
									}
								}
							}
							if (GC.getTraitInfo(eTrait).getPrereqOrTrait2() != NO_TRAIT &&
								!GET_PLAYER(GC.getGame().getActivePlayer()).hasTrait((TraitTypes)GC.getTraitInfo(eTrait).getPrereqOrTrait1()))
							{
								if (GC.getTraitInfo(eTrait).getPrereqOrTrait1() != NO_TRAIT &&
									(TraitTypes)GC.getTraitInfo(eTrait).getPrereqOrTrait2() == eLoopTrait &&
									!GET_PLAYER(GC.getGame().getActivePlayer()).hasTrait(eLoopTrait))
								{
									szHelpString.append(gDLL->getText("TXT_KEY_TRAIT_PREREQ_OR_ENTRY", GC.getTraitInfo(eLoopTrait).getTextKeyWide(), GC.getTraitInfo((TraitTypes)GC.getTraitInfo(eTrait).getPrereqOrTrait1()).getTextKeyWide()));
								}
							}
						}
					}
				}
			}
			if (GC.getTraitInfo(eTrait).getLinePriority() == 0  && !GC.getTraitInfo(eTrait).isCivilizationTrait() && !GC.getTraitInfo(eTrait).isBarbarianSelectionOnly())
			{
				szHelpString.append(NEWLINE);
				szHelpString.append(gDLL->getText("TXT_KEY_TRAIT_DISABLED_ON"));
			}
		}
		else if (!GC.getGame().isOption(GAMEOPTION_LEADERHEAD_LEVELUPS) && GC.getTraitInfo(eTrait).getLinePriority() != 0)
		{
			szHelpString.append(NEWLINE);
			szHelpString.append(gDLL->getText("TXT_KEY_TRAIT_DISABLED_OFF"));
		}

		for (iI = 0; iI < GC.getTraitInfo(eTrait).getNumDisallowedTraitTypes(); iI++)
		{
			TraitTypes eDisallowedTrait = GC.getTraitInfo(eTrait).isDisallowedTraitType(iI).eTrait;
			if (eDisallowedTrait != NO_TRAIT)
			{
				szHelpString.append(NEWLINE);
				szHelpString.append(gDLL->getText("TXT_KEY_TRAIT_DISALLOWED", GC.getTraitInfo(eDisallowedTrait).getTextKeyWide()));
			}
		}

		if (GC.getTraitInfo(eTrait).getPromotionLine() != NO_PROMOTIONLINE && GC.getGame().getActiveTeam() != NO_TEAM)
		{
			if (GC.getPromotionLineInfo((PromotionLineTypes)GC.getTraitInfo(eTrait).getPromotionLine()).getPrereqTech() != NO_TECH)
			{
				if (!(GET_TEAM(GC.getGame().getActiveTeam()).isHasTech((TechTypes)(GC.getPromotionLineInfo((PromotionLineTypes)GC.getTraitInfo(eTrait).getPromotionLine()).getPrereqTech()))))
				{
					szHelpString.append(NEWLINE);
					szHelpString.append(gDLL->getText("TXT_KEY_TRAIT_TECH_PREREQ", GC.getTechInfo((TechTypes)GC.getPromotionLineInfo((PromotionLineTypes)GC.getTraitInfo(eTrait).getPromotionLine()).getPrereqTech()).getTextKeyWide()));
				}
			}
		}

		if (GC.getTraitInfo(eTrait).getPrereqTech() != NO_TECH && GC.getGame().getActiveTeam() != NO_TEAM)
		{
			if (!(GET_TEAM(GC.getGame().getActiveTeam()).isHasTech((TechTypes)GC.getTraitInfo(eTrait).getPrereqTech())))
			{
				szHelpString.append(NEWLINE);
				szHelpString.append(gDLL->getText("TXT_KEY_TRAIT_TECH_PREREQ", GC.getTechInfo((TechTypes)GC.getTraitInfo(eTrait).getPrereqTech()).getTextKeyWide()));
			}
		}

//HEALTH
		// iHealth
		if (GC.getTraitInfo(eTrait).getHealth() != 0)
		{
			int iHealth = GC.getTraitInfo(eTrait).getHealth();
			szHelpString.append(NEWLINE);
			szHelpString.append(gDLL->getText("TXT_KEY_BULLET"));
			szTempBuffer.Format(L" +%d%c", abs(iHealth), ((iHealth > 0) ? gDLL->getSymbolID(HEALTHY_CHAR): gDLL->getSymbolID(UNHEALTHY_CHAR)));
			szHelpString.append(szTempBuffer);
			szHelpString.append(gDLL->getText("TXT_KEY_PER_CITY"));
		}
//HAPPY
		// iHappiness
		if (GC.getTraitInfo(eTrait).getHappiness() != 0)
		{
			int iHappy = GC.getTraitInfo(eTrait).getHappiness();
			szHelpString.append(NEWLINE);
			szHelpString.append(gDLL->getText("TXT_KEY_BULLET"));
			szTempBuffer.Format(L" +%d%c", abs(iHappy), ((iHappy > 0) ? gDLL->getSymbolID(HAPPY_CHAR): gDLL->getSymbolID(UNHAPPY_CHAR)));
			szHelpString.append(szTempBuffer);
			szHelpString.append(gDLL->getText("TXT_KEY_PER_CITY"));
		}

		//	Largest City Happiness
		if (GC.getTraitInfo(eTrait).getLargestCityHappiness() != 0)
		{
			szHelpString.append(NEWLINE);
			// Use absolute value with unhappy face
			szHelpString.append(gDLL->getText("TXT_KEY_CIVIC_LARGEST_CITIES_HAPPINESS", abs(GC.getTraitInfo(eTrait).getLargestCityHappiness()), ((GC.getTraitInfo(eTrait).getLargestCityHappiness() > 0) ? gDLL->getSymbolID(HAPPY_CHAR) : gDLL->getSymbolID(UNHAPPY_CHAR)), GC.getWorldInfo(GC.getMap().getWorldSize()).getTargetNumCities()));
		}

		// State Religion Happiness
		if (GC.getTraitInfo(eTrait).getStateReligionHappiness() != 0)
		{
			szHelpString.append(NEWLINE);
			szHelpString.append(gDLL->getText("TXT_KEY_CIVIC_RELIGION_HAPPINESS", abs(GC.getTraitInfo(eTrait).getStateReligionHappiness()), ((GC.getTraitInfo(eTrait).getStateReligionHappiness() > 0) ? gDLL->getSymbolID(HAPPY_CHAR) : gDLL->getSymbolID(UNHAPPY_CHAR))));
		}

		// Every religion happiness
		if (GC.getTraitInfo(eTrait).getNonStateReligionHappiness() != 0)
		{
			szHelpString.append(NEWLINE);
			szHelpString.append(gDLL->getText("TXT_KEY_CIVIC_NON_STATE_REL_HAPPINESS_AMBIGUOUS", abs(GC.getTraitInfo(eTrait).getNonStateReligionHappiness()), ((GC.getTraitInfo(eTrait).getNonStateReligionHappiness() > 0) ? gDLL->getSymbolID(HAPPY_CHAR) : gDLL->getSymbolID(UNHAPPY_CHAR))));
		}

		//	Happiness per military unit
		if (GC.getTraitInfo(eTrait).getHappyPerMilitaryUnit() != 0)
		{
			szHelpString.append(NEWLINE);
			szHelpString.append(gDLL->getText("TXT_KEY_CIVIC_UNIT_HAPPINESS", abs(GC.getTraitInfo(eTrait).getHappyPerMilitaryUnit()), ((GC.getTraitInfo(eTrait).getHappyPerMilitaryUnit() > 0) ? gDLL->getSymbolID(HAPPY_CHAR) : gDLL->getSymbolID(UNHAPPY_CHAR))));
		}

		// Extra Happiness by Bonuses
		for (iI = 0; iI < GC.getTraitInfo(eTrait).getNumBonusHappinessChanges(); iI++)
		{
			iCurrentModifier = GC.getTraitInfo(eTrait).getBonusHappinessChange(iI).iModifier;
			if (iCurrentModifier != 0)
			{
				bFound = false;
				for (int iJ = 0; iJ < (int)iIterationValues.size(); iJ++)
				{
					if (iIterationValues[iJ] == iCurrentModifier)
					{
						bFound = true;
					}
				}
				if (!bFound)
				{
					iIterationValues.push_back(GC.getTraitInfo(eTrait).getBonusHappinessChange(iI).iModifier);
				}
			}
		}
		for (int iA = 0; iA < (int)iIterationValues.size(); iA++)
		{
			bFirst = true;
			for (iI = 0; iI < GC.getTraitInfo(eTrait).getNumBonusHappinessChanges(); iI++)
			{
				iCurrentModifier = GC.getTraitInfo(eTrait).getBonusHappinessChange(iI).iModifier;
				if (iCurrentModifier == iIterationValues[iA])
				{
					BonusTypes eTempBonus = GC.getTraitInfo(eTrait).getBonusHappinessChange(iI).eBonus;
					if (bFirst)
					{
						szHelpString.append(NEWLINE);
						szHelpString.append(gDLL->getText("TXT_KEY_TRAIT_BONUS_HAPPINESS_CHANGE_FIRST", iCurrentModifier, ((iCurrentModifier > 0) ? gDLL->getSymbolID(HAPPY_CHAR) : gDLL->getSymbolID(UNHAPPY_CHAR)), CvWString(GC.getBonusInfo(eTempBonus).getType()).GetCString(), GC.getBonusInfo(eTempBonus).getTextKeyWide()));
						bFirst = false;
					}
					else
					{
						szHelpString.append(gDLL->getText("TXT_KEY_TRAIT_BONUS_HAPPINESS_CHANGE_ADDITIONAL", CvWString(GC.getBonusInfo(eTempBonus).getType()).GetCString(), GC.getBonusInfo(eTempBonus).getTextKeyWide()));
					}
				}
			}
			szHelpString.append(gDLL->getText("TXT_KEY_TRAIT_BONUS_HAPPINESS_CHANGE_END"));
		}

		iCurrentModifier = 0;
		iIterationValues.clear();
		bFound = false;
		bFirst = true;
		//iLast = 0;
		//for (iI = 0; iI < GC.getNumBonusInfos(); ++iI)
		//{
		//	if (GC.getTraitInfo(eTrait).getBonusHappinessChanges(iI) != 0)
		//	{
		//		szFirstBuffer.Format(L"%s%s", NEWLINE, gDLL->getText("TXT_KEY_BUILDING_HEALTH_HAPPINESS_CHANGE", abs(GC.getTraitInfo(eTrait).getBonusHappinessChanges(iI)), ((GC.getTraitInfo(eTrait).getBonusHappinessChanges(iI) > 0) ? gDLL->getSymbolID(HAPPY_CHAR) : gDLL->getSymbolID(UNHAPPY_CHAR))).c_str());
		//		szTempBuffer.Format(L"<link=%s>%s</link>", CvWString(GC.getBonusInfo((BonusTypes)iI).getType()).GetCString(), GC.getBonusInfo((BonusTypes)iI).getDescription());
		//		setListHelp(szHelpString, szFirstBuffer, szTempBuffer, L", ", (GC.getTraitInfo(eTrait).getBonusHappinessChanges(iI) != iLast));
		//		iLast = GC.getTraitInfo(eTrait).getBonusHappinessChanges(iI);
		//	}
		//}

		//	War Weariness
		if (GC.getTraitInfo(eTrait).getWarWearinessAccumulationModifier() != 0)
		{
			//if (GC.getTraitInfo(eTrait).getWarWearinessAccumulationModifier() <= -100)
			//{
			//	szHelpString.append(NEWLINE);
			//	szHelpString.append(gDLL->getText("TXT_KEY_CIVIC_NO_WAR_WEARINESS"));
			//}
			//else
			//{
				szHelpString.append(NEWLINE);
				szHelpString.append(gDLL->getText("TXT_KEY_CIVIC_EXTRA_WAR_WEARINESS", GC.getTraitInfo(eTrait).getWarWearinessAccumulationModifier()));
			//}
		}

		if (GC.getTraitInfo(eTrait).getEnemyWarWearinessModifier() != 0)
		{
			szHelpString.append(NEWLINE);
			szHelpString.append(gDLL->getText("TXT_KEY_BUILDING_ENEMY_WAR_WEAR", GC.getTraitInfo(eTrait).getEnemyWarWearinessModifier()));
		}
//YIELD
		//	Yield % Modifiers
		setYieldChangeHelp(szHelpString, L"", L"", gDLL->getText("TXT_KEY_CIVIC_IN_ALL_CITIES").GetCString(), GC.getTraitInfo(eTrait).getYieldModifierArray(), true);

		// ExtraYieldThresholds
		for (iI = 0; iI < NUM_YIELD_TYPES; ++iI)
		{
			if (GC.getTraitInfo(eTrait).getExtraYieldThreshold(iI) > 0)
			{
				szHelpString.append(NEWLINE);
				szHelpString.append(gDLL->getText("TXT_KEY_TRAIT_EXTRA_YIELD_THRESHOLDS_C2C", GC.getYieldInfo((YieldTypes) iI).getChar(), GC.getTraitInfo(eTrait).getExtraYieldThreshold(iI), GC.getYieldInfo((YieldTypes) iI).getChar()));
			}
			if (GC.getTraitInfo(eTrait).getLessYieldThreshold(iI) > 0)
			{
				szHelpString.append(NEWLINE);
				szHelpString.append(gDLL->getText("TXT_KEY_TRAIT_LESS_YIELD_THRESHOLDS_C2C", GC.getYieldInfo((YieldTypes) iI).getChar(), GC.getTraitInfo(eTrait).getLessYieldThreshold(iI), GC.getYieldInfo((YieldTypes) iI).getChar()));
			}
			// Yield Base Change
			if (GC.getTraitInfo(eTrait).getYieldChange(iI) != 0)
			{
				szHelpString.append(NEWLINE);
				szHelpString.append(gDLL->getText("TXT_KEY_TRAIT_YIELD_CHANGES_C2C", GC.getTraitInfo(eTrait).getYieldChange(iI), GC.getYieldInfo((YieldTypes)iI).getChar(), "YIELD"));
			}
			// Trade Yield Modifiers
			if (GC.getTraitInfo(eTrait).getTradeYieldModifier(iI) != 0)
			{
				szHelpString.append(NEWLINE);
				szHelpString.append(gDLL->getText("TXT_KEY_TRAIT_TRADE_YIELD_MODIFIERS_C2C", GC.getTraitInfo(eTrait).getTradeYieldModifier(iI), GC.getYieldInfo((YieldTypes) iI).getChar(), "YIELD"));
			}
		}
		//SeaPlotYieldChanges
		setYieldChangeHelp(szHelpString, gDLL->getText("TXT_KEY_BUILDING_WATER_PLOTS_ALL_CITIES").GetCString(), L": ", L"", GC.getTraitInfo(eTrait).getSeaPlotYieldChangesArray(), false, true);

//Team Project (7)
		//GoldenAgeYieldChanges
		setYieldChangeHelp(szHelpString, gDLL->getText("TXT_KEY_GOLDEN_AGE_YIELD").GetCString(), L": ", L"", GC.getTraitInfo(eTrait).getGoldenAgeYieldChangesArray(), false, true);

		//	Specialist Base Yield
		setYieldChangeHelp(szHelpString, L"", L"", gDLL->getText("TXT_KEY_CIVIC_PER_SPECIALIST").GetCString(), GC.getTraitInfo(eTrait).getSpecialistExtraYieldArray(), false, true);

		//Individual Base specialist yield changes
		if (GC.getTraitInfo(eTrait).m_bAnySpecialistYieldChanges)
		{
			for (iI = 0; iI < GC.getNumSpecialistInfos(); ++iI)
			{
				szFirstBuffer = gDLL->getText("TXT_KEY_BUILDING_FROM_IN_ALL_CITIES", CvWString(GC.getSpecialistInfo((SpecialistTypes) iI).getType()).GetCString(), GC.getSpecialistInfo((SpecialistTypes) iI).getTextKeyWide());
				setYieldChangeHelp(szHelpString, L"", L"", szFirstBuffer, GC.getTraitInfo(eTrait).getSpecialistYieldChangeArray(iI), false, true);
			}
		}

		//	Capital % Yield Modifiers
		setYieldChangeHelp(szHelpString, L"", L"", gDLL->getText("TXT_KEY_CIVIC_IN_CAPITAL").GetCString(), GC.getTraitInfo(eTrait).getCapitalYieldModifierArray(), true, true);

		// Improvement Yield Changes
		for (iI = 0; iI < NUM_YIELD_TYPES; ++iI)
		{
			YieldTypes eYield = ((YieldTypes)iI);
			iLast = 0;

			for (int iJ = 0; iJ < GC.getNumImprovementInfos(); iJ++)
			{
				ImprovementTypes eImprovement = ((ImprovementTypes)iJ);
				if (GC.getTraitInfo(eTrait).getImprovementYieldChange(eImprovement,eYield) !=0)
				{
					szFirstBuffer.Format(L"%s%s", NEWLINE, gDLL->getText("TXT_KEY_CIVIC_IMPROVEMENT_YIELD_CHANGE", GC.getTraitInfo(eTrait).getImprovementYieldChange(eImprovement,eYield), GC.getYieldInfo(eYield).getChar()).c_str());
					szImprovement.Format(L"<link=%s>%s</link>", CvWString(GC.getImprovementInfo(eImprovement).getType()).GetCString(), GC.getImprovementInfo(eImprovement).getDescription());
					setListHelp(szHelpString, szFirstBuffer.GetCString(), szImprovement.GetCString(), L", ", (GC.getTraitInfo(eTrait).getImprovementYieldChange(eImprovement,eYield) != iLast));
					iLast = GC.getTraitInfo(eTrait).getImprovementYieldChange(eImprovement,eYield);
				}
				//if (GC.getImprovementInfo((ImprovementTypes)iJ).getTraitYieldChanges(eTrait, iI) != 0)
				//{
				//	szFirstBuffer.Format(L"%s%s", NEWLINE, gDLL->getText("TXT_KEY_CIVIC_IMPROVEMENT_YIELD_CHANGE", GC.getImprovementInfo((ImprovementTypes)iJ).getTraitYieldChanges(eTrait, iI), GC.getYieldInfo((YieldTypes)iI).getChar()).c_str());
				//	szImprovement.Format(L"<link=%s>%s</link>", CvWString(GC.getImprovementInfo((ImprovementTypes)iJ).getType()).GetCString(), GC.getImprovementInfo((ImprovementTypes)iJ).getDescription());
				//	setListHelp(szHelpString, szFirstBuffer.GetCString(), szImprovement.GetCString(), L", ", (GC.getImprovementInfo((ImprovementTypes)iJ).getTraitYieldChanges(eTrait, iI) != iLast));
				//	iLast = GC.getImprovementInfo((ImprovementTypes)iJ).getTraitYieldChanges(eTrait, iI);
				//}
			}
		}

//COMMERCE
		// CommerceChanges
		for (iI = 0; iI < NUM_COMMERCE_TYPES; ++iI)
		{
			// Commerce Base Change
			if (GC.getTraitInfo(eTrait).getCommerceChange(iI) != 0)
			{
				szHelpString.append(NEWLINE);
				szHelpString.append(gDLL->getText("TXT_KEY_TRAIT_COMMERCE_CHANGES_C2C", GC.getTraitInfo(eTrait).getCommerceChange(iI), GC.getCommerceInfo((CommerceTypes) iI).getChar(), "COMMERCE"));
			}

			if (GC.getTraitInfo(eTrait).getCommerceModifier(iI) != 0)
			{
				szHelpString.append(NEWLINE);
				szHelpString.append(gDLL->getText("TXT_KEY_TRAIT_COMMERCE_MODIFIERS_C2C", GC.getTraitInfo(eTrait).getCommerceModifier(iI), GC.getCommerceInfo((CommerceTypes) iI).getChar(), "COMMERCE"));
			}
		}

//Team Project (7)
		//	Golden Age Commerce
		setCommerceChangeHelp(szHelpString, gDLL->getText("TXT_KEY_GOLDEN_AGE_YIELD").GetCString(),L": ", L"", GC.getTraitInfo(eTrait).getGoldenAgeCommerceChangesArray(), false, true);

		//	Specialist Base Commerce
		setCommerceChangeHelp(szHelpString, L"", L"", gDLL->getText("TXT_KEY_CIVIC_PER_SPECIALIST").GetCString(), GC.getTraitInfo(eTrait).getSpecialistExtraCommerceArray(), false, true);

		//Individual Base specialist commerce changes
		if (GC.getTraitInfo(eTrait).m_bAnySpecialistCommerceChanges)
		{
			for (iI = 0; iI < GC.getNumSpecialistInfos(); ++iI)
			{
				szFirstBuffer = gDLL->getText("TXT_KEY_BUILDING_FROM_IN_ALL_CITIES", CvWString(GC.getSpecialistInfo((SpecialistTypes) iI).getType()).GetCString(), GC.getSpecialistInfo((SpecialistTypes) iI).getTextKeyWide());
				setCommerceChangeHelp(szHelpString, L"", L"", szFirstBuffer, GC.getTraitInfo(eTrait).getSpecialistCommerceChangeArray(iI), false, true);
			}
		}

		//	Capital % Commerce Modifiers
		setCommerceChangeHelp(szHelpString, L"", L"", gDLL->getText("TXT_KEY_CIVIC_IN_CAPITAL").GetCString(), GC.getTraitInfo(eTrait).getCapitalCommerceModifierArray(), true);

		// Non-State Religion Commerce
		if (GC.getTraitInfo(eTrait).isNonStateReligionCommerce() != 0)
		{
			szHelpString.append(NEWLINE);
			szHelpString.append(gDLL->getText("TXT_KEY_TRAIT_NONSTATE_RELIGIOUS_COMMERCE"));
		}

//SPECIALISTS && GP PTS
		//	Free specialists
		if (GC.getTraitInfo(eTrait).getFreeSpecialist() != 0)
		{
			szHelpString.append(NEWLINE);
			szHelpString.append(gDLL->getText("TXT_KEY_CIVIC_FREE_SPECIALISTS", GC.getTraitInfo(eTrait).getFreeSpecialist()));
		}

//Team Project (6)
		//	Era Advance Free specialists
		if (GC.getTraitInfo(eTrait).getEraAdvanceFreeSpecialistType() != NO_SPECIALIST)
		{
			szHelpString.append(NEWLINE);
			szHelpString.append(gDLL->getText("TXT_KEY_CIVIC_ERA_ADVANCE_FREE_SPECIALIST", GC.getSpecialistInfo((SpecialistTypes)GC.getTraitInfo(eTrait).getEraAdvanceFreeSpecialistType()).getTextKeyWide()));
		}

		//	State Religion Great People Modifier...
		if (GC.getTraitInfo(eTrait).getStateReligionGreatPeopleRateModifier() != 0)
		{
			szHelpString.append(NEWLINE);
			szHelpString.append(gDLL->getText("TXT_KEY_CIVIC_GREAT_PEOPLE_MOD_STATE_RELIGION", GC.getTraitInfo(eTrait).getStateReligionGreatPeopleRateModifier(), gDLL->getSymbolID(RELIGION_CHAR)));
		}

		// iGreatPeopleRateModifier
		if (GC.getTraitInfo(eTrait).getGreatPeopleRateModifier() != 0)
		{
			szHelpString.append(NEWLINE);
			szHelpString.append(gDLL->getText("TXT_KEY_TRAIT_GREAT_PEOPLE_MODIFIER_C2C", GC.getTraitInfo(eTrait).getGreatPeopleRateModifier()));
		}

		// iGreatGeneralRateModifier
		if (GC.getTraitInfo(eTrait).getGreatGeneralRateModifier() != 0)
		{
			szHelpString.append(NEWLINE);
			szHelpString.append(gDLL->getText("TXT_KEY_TRAIT_GREAT_GENERAL_MODIFIER_C2C", GC.getTraitInfo(eTrait).getGreatGeneralRateModifier()));
		}

		if (GC.getTraitInfo(eTrait).getDomesticGreatGeneralRateModifier() != 0)
		{
			szHelpString.append(NEWLINE);
			szHelpString.append(gDLL->getText("TXT_KEY_DOMESTIC_GREAT_GENERAL_MODIFIER_C2C", GC.getTraitInfo(eTrait).getDomesticGreatGeneralRateModifier()));
		}

		if (GC.getTraitInfo(eTrait).getGreatPeopleRateChange() != 0)
		{
			szHelpString.append(NEWLINE);
			szHelpString.append(gDLL->getText("TXT_KEY_BULLET"));
			szTempBuffer.Format(L"%s%d%c", ((GC.getTraitInfo(eTrait).getGreatPeopleRateChange() > 0) ? L"+" : L""), GC.getTraitInfo(eTrait).getGreatPeopleRateChange(), gDLL->getSymbolID(GREAT_PEOPLE_CHAR));
			szHelpString.append(szTempBuffer);

			const UnitTypes eGreatPeopleUnit = (UnitTypes)GC.getTraitInfo(eTrait).getGreatPeopleUnitType();

			if (eGreatPeopleUnit != NO_UNIT)
			{
				szTempBuffer.Format(L" (%s)", GC.getUnitInfo(eGreatPeopleUnit).getDescription());
				szHelpString.append(szTempBuffer);
			}
		}

//Team Project (6)
		// Free Specialists on Wonders
		if (GC.getTraitInfo(eTrait).isFreeSpecialistperNationalWonder())
		{
			szHelpString.append(NEWLINE);
			szHelpString.append(gDLL->getText("TXT_KEY_TRAIT_FREE_SPEC_NW"));
		}
		if (GC.getTraitInfo(eTrait).isFreeSpecialistperWorldWonder())
		{
			szHelpString.append(NEWLINE);
			szHelpString.append(gDLL->getText("TXT_KEY_TRAIT_FREE_SPEC_WW"));
		}
		if (GC.getTraitInfo(eTrait).isFreeSpecialistperTeamProject())
		{
			szHelpString.append(NEWLINE);
			szHelpString.append(gDLL->getText("TXT_KEY_TRAIT_FREE_SPEC_TP"));
		}


		if (GC.getTraitInfo(eTrait).getHurryCostModifier() != 0)
		{
			szHelpString.append(NEWLINE);
			szHelpString.append(gDLL->getText("TXT_KEY_BUILDING_HURRY_MOD", GC.getTraitInfo(eTrait).getHurryCostModifier()));
		}

		if (GC.getTraitInfo(eTrait).getHurryAngerModifier() != 0)
		{
			szHelpString.append(NEWLINE);
			szHelpString.append(gDLL->getText("TXT_KEY_BUILDING_HURRY_ANGER_MOD", GC.getTraitInfo(eTrait).getHurryAngerModifier()));
		}

		//	State Religion Building Production Modifier
		if (GC.getTraitInfo(eTrait).getStateReligionBuildingProductionModifier() != 0)
		{
			szHelpString.append(NEWLINE);
			szHelpString.append(gDLL->getText("TXT_KEY_CIVIC_STATE_REL_BUILDING", GC.getTraitInfo(eTrait).getStateReligionBuildingProductionModifier()));
		}

		// Wonder Production Effects
		if ((GC.getTraitInfo(eTrait).getMaxGlobalBuildingProductionModifier() != 0)
			|| (GC.getTraitInfo(eTrait).getMaxTeamBuildingProductionModifier() != 0)
			|| (GC.getTraitInfo(eTrait).getMaxPlayerBuildingProductionModifier() != 0))
		{
			if ((GC.getTraitInfo(eTrait).getMaxGlobalBuildingProductionModifier() == GC.getTraitInfo(eTrait).getMaxTeamBuildingProductionModifier())
				&& (GC.getTraitInfo(eTrait).getMaxGlobalBuildingProductionModifier() == GC.getTraitInfo(eTrait).getMaxPlayerBuildingProductionModifier()))
			{
				szHelpString.append(NEWLINE);
				szHelpString.append(gDLL->getText("TXT_KEY_TRAIT_WONDER_PRODUCTION_MODIFIER_C2C", GC.getTraitInfo(eTrait).getMaxGlobalBuildingProductionModifier()));
			}
			else
			{
				if (GC.getTraitInfo(eTrait).getMaxGlobalBuildingProductionModifier() != 0)
				{
					szHelpString.append(NEWLINE);
					szHelpString.append(gDLL->getText("TXT_KEY_TRAIT_WORLD_WONDER_PRODUCTION_MODIFIER_C2C", GC.getTraitInfo(eTrait).getMaxGlobalBuildingProductionModifier()));
				}

				if (GC.getTraitInfo(eTrait).getMaxTeamBuildingProductionModifier() != 0)
				{
					szHelpString.append(NEWLINE);
					szHelpString.append(gDLL->getText("TXT_KEY_TRAIT_TEAM_WONDER_PRODUCTION_MODIFIER_C2C", GC.getTraitInfo(eTrait).getMaxTeamBuildingProductionModifier()));
				}

				if (GC.getTraitInfo(eTrait).getMaxPlayerBuildingProductionModifier() != 0)
				{
					szHelpString.append(NEWLINE);
					szHelpString.append(gDLL->getText("TXT_KEY_TRAIT_NATIONAL_WONDER_PRODUCTION_MODIFIER_C2C", GC.getTraitInfo(eTrait).getMaxPlayerBuildingProductionModifier()));
				}
			}
		}

		// Free Civilian units upkeep
		if (GC.getTraitInfo(eTrait).getFreeUnitUpkeepCivilian() != 0)
		{
			szHelpString.append(NEWLINE);
			szHelpString.append(gDLL->getText("TXT_KEY_HELPTEXT_UNIT_UPKEEP_FREE_CIVILIAN", GC.getTraitInfo(eTrait).getFreeUnitUpkeepCivilian()));
		}
		if (GC.getTraitInfo(eTrait).getFreeUnitUpkeepCivilianPopPercent() != 0)
		{
			if (GC.getGame().getActivePlayer() != NO_PLAYER)
			{
				int iValue = 0;
				int iMod = GC.getTraitInfo(eTrait).getFreeUnitUpkeepCivilianPopPercent();
				if (iMod > 0)
				{
					iValue = GET_PLAYER(GC.getGame().getActivePlayer()).getTotalPopulation() * (100 + iMod);
				}
				else if (iMod < 0)
				{
					iValue =
						GET_PLAYER(GC.getGame().getActivePlayer()).getTotalPopulation() -
						GET_PLAYER(GC.getGame().getActivePlayer()).getTotalPopulation() * 100 / (100 - iMod);
				}
				szHelpString.append(NEWLINE);
				szHelpString.append(gDLL->getText("TXT_KEY_HELPTEXT_UNIT_UPKEEP_FREE_CIVILIAN_PER_POP",  iMod));
				szHelpString.append(gDLL->getText("TXT_KEY_HELPTEXT_UNIT_UPKEEP_FREE_PER_POP", CvWString::format(L"%.2f", iValue / 100.0).GetCString()));
			}
			else
			{
				szHelpString.append(NEWLINE);
				szHelpString.append(gDLL->getText("TXT_KEY_HELPTEXT_UNIT_UPKEEP_FREE_CIVILIAN_PER_POP_0", GC.getTraitInfo(eTrait).getFreeUnitUpkeepCivilianPopPercent()));
			}
		}
		// Free Military unit upkeep
		if (GC.getTraitInfo(eTrait).getFreeUnitUpkeepMilitary() != 0)
		{
			szHelpString.append(NEWLINE);
			szHelpString.append(gDLL->getText("TXT_KEY_HELPTEXT_UNIT_UPKEEP_FREE_MILITARY", GC.getTraitInfo(eTrait).getFreeUnitUpkeepMilitary()));
		}
		if (GC.getTraitInfo(eTrait).getFreeUnitUpkeepMilitaryPopPercent() != 0)
		{
			if (GC.getGame().getActivePlayer() != NO_PLAYER)
			{
				int iValue = 0;
				int iMod = GC.getTraitInfo(eTrait).getFreeUnitUpkeepMilitaryPopPercent();
				if (iMod > 0)
				{
					iValue = GET_PLAYER(GC.getGame().getActivePlayer()).getTotalPopulation() * (100 + iMod);
				}
				else if (iMod < 0)
				{
					iValue =
						GET_PLAYER(GC.getGame().getActivePlayer()).getTotalPopulation() -
						GET_PLAYER(GC.getGame().getActivePlayer()).getTotalPopulation() * 100 / (100 - iMod);
				}
				szHelpString.append(NEWLINE);
				szHelpString.append(gDLL->getText("TXT_KEY_HELPTEXT_UNIT_UPKEEP_FREE_MILITARY_PER_POP",  iMod));
				szHelpString.append(gDLL->getText("TXT_KEY_HELPTEXT_UNIT_UPKEEP_FREE_PER_POP", CvWString::format(L"%.2f", iValue / 100.0).GetCString()));
			}
			else
			{
				szHelpString.append(NEWLINE);
				szHelpString.append(gDLL->getText("TXT_KEY_HELPTEXT_UNIT_UPKEEP_FREE_MILITARY_PER_POP", GC.getTraitInfo(eTrait).getFreeUnitUpkeepMilitaryPopPercent()));
			}
		}

		//	Free military units base
		if (GC.getTraitInfo(eTrait).getFreeUnitUpkeepMilitary() != 0)
		{
			szHelpString.append(NEWLINE);
			szHelpString.append(gDLL->getText("TXT_KEY_HELPTEXT_UNIT_UPKEEP_FREE_MILITARY", GC.getTraitInfo(eTrait).getFreeUnitUpkeepMilitary()));
		}

		//	Free Military units population percent
		if (GC.getTraitInfo(eTrait).getFreeUnitUpkeepMilitaryPopPercent() != 0)
		{
			szHelpString.append(NEWLINE);
			szHelpString.append(gDLL->getText("TXT_KEY_TRAIT_FREE_UNIT_UPKEEP_MILITARY_PER_100_POP", GC.getTraitInfo(eTrait).getFreeUnitUpkeepMilitaryPopPercent()));
		}

		if (GC.getTraitInfo(eTrait).getCivilianUnitUpkeepMod() != 0)
		{
			szHelpString.append(NEWLINE);
			szHelpString.append(gDLL->getText("TXT_KEY_HELPTEXT_UNIT_UPKEEP_MOD_CIVILIAN", GC.getTraitInfo(eTrait).getCivilianUnitUpkeepMod()));
		}
		if (GC.getTraitInfo(eTrait).getMilitaryUnitUpkeepMod() != 0)
		{
			szHelpString.append(NEWLINE);
			szHelpString.append(gDLL->getText("TXT_KEY_HELPTEXT_UNIT_UPKEEP_MOD_MILITARY", GC.getTraitInfo(eTrait).getMilitaryUnitUpkeepMod()));
		}

		//  Unit Upgrade Cost modifier
		if (GC.getTraitInfo(eTrait).getUnitUpgradePriceModifier() != 0)
		{
			szHelpString.append(NEWLINE);
			szHelpString.append(gDLL->getText("TXT_KEY_BUILDING_UNIT_UPGRADE_COST_MOD", GC.getTraitInfo(eTrait).getUnitUpgradePriceModifier()));
		}

		//	Conscription
		if (GC.getTraitInfo(eTrait).getMaxConscript() != 0)
		{
			szHelpString.append(NEWLINE);
			szHelpString.append(gDLL->getText("TXT_KEY_CIVIC_CONSCRIPTION_CHANGE", GC.getTraitInfo(eTrait).getMaxConscript()));
		}

		//	Military units produced with food
		if (GC.getTraitInfo(eTrait).isMilitaryFoodProduction())
		{
			szHelpString.append(NEWLINE);
			szHelpString.append(gDLL->getText("TXT_KEY_CIVIC_MILITARY_FOOD"));
		}

		if (GC.getTraitInfo(eTrait).isUpgradeAnywhere() != 0)
		{
			szHelpString.append(NEWLINE);
			szHelpString.append(gDLL->getText("TXT_KEY_CAN_UPGRADE_ANYWHERE"));

		}

		if (GC.getGame().isOption(GAMEOPTION_INQUISITIONS))
		{
			if (GC.getTraitInfo(eTrait).isAllowsInquisitions())
			{
				szHelpString.append(NEWLINE);
				szHelpString.append(gDLL->getText("TXT_KEY_CIVIC_ALLOW_INQUISITONS"));
			}
		}

//Team Project (6)
		//Global Air Unit Capacity
		if (GC.getTraitInfo(eTrait).getGlobalAirUnitCapacity() != 0)
		{
			szHelpString.append(NEWLINE);
			szHelpString.append(gDLL->getText("TXT_KEY_TRAIT_AIR_UNIT_CAPACITY", GC.getTraitInfo(eTrait).getGlobalAirUnitCapacity()));
		}

		//Flight Range
		if (GC.getTraitInfo(eTrait).getFlightOperationRange() != 0)
		{
			szHelpString.append(NEWLINE);
			szHelpString.append(gDLL->getText("TXT_KEY_TRAIT_FLIGHT_RANGE", GC.getTraitInfo(eTrait).getFlightOperationRange()));
		}

		//Missile Cargo Space
		if (GC.getTraitInfo(eTrait).getMissileCargoSpace() != 0)
		{
			szHelpString.append(NEWLINE);
			szHelpString.append(gDLL->getText("TXT_KEY_TRAIT_MISSILE_CARGO_SPACE", GC.getTraitInfo(eTrait).getMissileCargoSpace()));
		}

		//Missile Range
		if (GC.getTraitInfo(eTrait).getMissileRange() != 0)
		{
			szHelpString.append(NEWLINE);
			szHelpString.append(gDLL->getText("TXT_KEY_TRAIT_MISSILE_RANGE", GC.getTraitInfo(eTrait).getMissileRange()));
		}

		//Naval Cargo Space
		if (GC.getTraitInfo(eTrait).getNavalCargoSpace() != 0)
		{
			szHelpString.append(NEWLINE);
			szHelpString.append(gDLL->getText("TXT_KEY_TRAIT_NAVAL_CARGO_SPACE", GC.getTraitInfo(eTrait).getNavalCargoSpace()));
		}

//Team Project (3)
		//Capture Probabilities
		if (GC.getTraitInfo(eTrait).getNationalCaptureProbabilityModifier() != 0)
		{
			szHelpString.append(NEWLINE);
			szHelpString.append(gDLL->getText("TXT_KEY_NATIONAL_CAPTURE_PROBABILITY_MODIFIER", GC.getTraitInfo(eTrait).getNationalCaptureProbabilityModifier()));
		}
		if (GC.getTraitInfo(eTrait).getNationalCaptureResistanceModifier() != 0)
		{
			szHelpString.append(NEWLINE);
			szHelpString.append(gDLL->getText("TXT_KEY_NATIONAL_CAPTURE_RESISTANCE_MODIFIER", GC.getTraitInfo(eTrait).getNationalCaptureResistanceModifier()));
		}

//Team Project (6)
		// Draft On Capture
		if (GC.getTraitInfo(eTrait).isDraftsOnCityCapture())
		{
			szHelpString.append(NEWLINE);
			szHelpString.append(gDLL->getText("TXT_KEY_TRAIT_DRAFT_ON_CAPTURE"));
		}

		// Extra Goody
		if (GC.getTraitInfo(eTrait).isExtraGoody())
		{
			szHelpString.append(NEWLINE);
			szHelpString.append(gDLL->getText("TXT_KEY_TRAIT_EXTRA_GOODY"));
		}


		//Free Promotions by UnitCombat
		for (iI = 0; iI < GC.getNumPromotionInfos(); ++iI)
		{
			for (iJ = 0; iJ < GC.getNumUnitCombatInfos(); iJ++)
			{
				if (GC.getTraitInfo(eTrait).isFreePromotionUnitCombats(iI, iJ))
				{
					szFirstBuffer.Format(L"%s%s", NEWLINE, gDLL->getText("TXT_KEY_TRAIT_FREE_PROMOTION_UNITCOMBAT", CvWString(GC.getPromotionInfo((PromotionTypes)iI).getType()).GetCString(), GC.getPromotionInfo((PromotionTypes)iI).getDescription()).c_str());
					szTempBuffer.Format(L"<link=%s>%s</link>", CvWString(GC.getUnitCombatInfo((UnitCombatTypes)iJ).getType()).GetCString(), GC.getUnitCombatInfo((UnitCombatTypes)iJ).getDescription());
					setListHelp(szHelpString, szFirstBuffer, szTempBuffer, L", ", iI != iLast);
					iLast = iI;
				}
			}
		}

//UNIT EXPERIENCE
		// iLevelExperienceModifier
		if (GC.getTraitInfo(eTrait).getLevelExperienceModifier() != 0)
		{
			szHelpString.append(NEWLINE);
			szHelpString.append(gDLL->getText("TXT_KEY_TRAIT_CIVIC_LEVEL_MODIFIER_C2C", GC.getTraitInfo(eTrait).getLevelExperienceModifier()));
		}

		//	Free Experience
		if (GC.getTraitInfo(eTrait).getFreeExperience() != 0)
		{
			szHelpString.append(NEWLINE);
			szHelpString.append(gDLL->getText("TXT_KEY_CIVIC_FREE_XP", GC.getTraitInfo(eTrait).getFreeExperience()));
		}

	// Free Experience by Unit Combat
		for (iI = 0; iI < GC.getTraitInfo(eTrait).getNumUnitCombatFreeExperiences(); iI++)
		{
			iCurrentModifier = GC.getTraitInfo(eTrait).getUnitCombatFreeExperience(iI).iModifier;
			if (iCurrentModifier != 0)
			{
				bFound = false;
				for (int iJ = 0; iJ < (int)iIterationValues.size(); iJ++)
				{
					if (iIterationValues[iJ] == iCurrentModifier)
					{
						bFound = true;
					}
				}
				if (!bFound)
				{
					iIterationValues.push_back(GC.getTraitInfo(eTrait).getUnitCombatFreeExperience(iI).iModifier);
				}
			}
		}
		for (int iA = 0; iA < (int)iIterationValues.size(); iA++)
		{
			bFirst = true;
			for (iI = 0; iI < GC.getTraitInfo(eTrait).getNumUnitCombatFreeExperiences(); iI++)
			{
				iCurrentModifier = GC.getTraitInfo(eTrait).getUnitCombatFreeExperience(iI).iModifier;
				if (iCurrentModifier == iIterationValues[iA])
				{
					UnitCombatTypes eTempUnitCombat = GC.getTraitInfo(eTrait).getUnitCombatFreeExperience(iI).eUnitCombat;
					if (bFirst)
					{
						szHelpString.append(NEWLINE);
						szHelpString.append(gDLL->getText("TXT_KEY_TRAIT_UNIT_COMBAT_FREE_XP_FIRST", iCurrentModifier, CvWString(GC.getUnitCombatInfo(eTempUnitCombat).getType()).GetCString(), GC.getUnitCombatInfo(eTempUnitCombat).getTextKeyWide()));
						bFirst = false;
					}
					else
					{
						szHelpString.append(gDLL->getText("TXT_KEY_TRAIT_UNIT_COMBAT_FREE_XP_ADDITIONAL", CvWString(GC.getUnitCombatInfo(eTempUnitCombat).getType()).GetCString(), GC.getUnitCombatInfo(eTempUnitCombat).getTextKeyWide()));
					}
				}
			}
			szHelpString.append(gDLL->getText("TXT_KEY_TRAIT_UNIT_COMBAT_FREE_XP_END"));
		}

		iCurrentModifier = 0;
		iIterationValues.clear();
		bFound = false;
		bFirst = true;

		//	State Religion Free Experience
		if (GC.getTraitInfo(eTrait).getStateReligionFreeExperience() != 0)
		{
			szHelpString.append(NEWLINE);
			szHelpString.append(gDLL->getText("TXT_KEY_CIVIC_STATE_REL_FREE_XP", GC.getTraitInfo(eTrait).getStateReligionFreeExperience()));
		}

		//	Experience in Borders
		if (0 != GC.getTraitInfo(eTrait).getExpInBorderModifier())
		{
			szHelpString.append(NEWLINE);
			szHelpString.append(gDLL->getText("TXT_KEY_CIVIC_EXPERIENCE_IN_BORDERS", GC.getTraitInfo(eTrait).getExpInBorderModifier()));
		}

		for (iI = 0; iI < GC.getTraitInfo(eTrait).getNumDomainFreeExperiences() ; ++iI)
		{
			if (GC.getTraitInfo(eTrait).getDomainFreeExperience(iI).iModifier != 0)
			{
				szHelpString.append(NEWLINE);
				szHelpString.append(gDLL->getText("TXT_KEY_BUILDING_FREE_XP", GC.getDomainInfo((DomainTypes)GC.getTraitInfo(eTrait).getDomainFreeExperience(iI).eDomain).getTextKeyWide(), GC.getTraitInfo(eTrait).getDomainFreeExperience(iI).iModifier));
			}
		}

//Team Project (6)
		//	Capital XP Modifier
		if (GC.getTraitInfo(eTrait).getCapitalXPModifier() != 0)
		{
			szHelpString.append(NEWLINE);
			szHelpString.append(gDLL->getText("TXT_KEY_TRAIT_CAPITAL_XP_MODIFIER", GC.getTraitInfo(eTrait).getCapitalXPModifier()));
		}

		//	Holy City of State Religion XP Modifier
		if (GC.getTraitInfo(eTrait).getHolyCityofStateReligionXPModifier() != 0)
		{
			szHelpString.append(NEWLINE);
			szHelpString.append(gDLL->getText("TXT_KEY_TRAIT_HOLY_CITY_STATE_REL_XP_MODIFIER", GC.getTraitInfo(eTrait).getHolyCityofStateReligionXPModifier()));
		}

		//	Holy City of Non State Religion XP Modifier
		if (GC.getTraitInfo(eTrait).getHolyCityofNonStateReligionXPModifier() != 0)
		{
			szHelpString.append(NEWLINE);
			szHelpString.append(gDLL->getText("TXT_KEY_TRAIT_HOLY_CITY_NON_STATE_REL_XP_MODIFIER", GC.getTraitInfo(eTrait).getHolyCityofNonStateReligionXPModifier()));
		}

		// Unit Class Production Mods
		iLast = 0;
		for (iI = 0; iI < GC.getNumUnitInfos(); ++iI)
		{
			if (!isWorldUnit((UnitTypes)iI))
			{
				for (int j = 0; j < GC.getTraitInfo(eTrait).getNumUnitProductionModifiers(); j++)
				{
					if ((UnitTypes)GC.getTraitInfo(eTrait).getUnitProductionModifier(j).eUnit == (UnitTypes)iI)
					{
						if (GC.getTraitInfo(eTrait).getUnitProductionModifier(j).iModifier != 0)
						{
							szText = gDLL->getText("TXT_KEY_TRAIT_PRODUCTION_MODIFIER_C2C", GC.getTraitInfo(eTrait).getUnitProductionModifier(j).iModifier);

							CvWString szUnit;

							szUnit.Format(L"<link=%s>%s</link>", CvWString(GC.getUnitInfo((UnitTypes)iI).getType()).GetCString(), GC.getUnitInfo((UnitTypes)iI).getDescription());
							setListHelp(szHelpString, szText.GetCString(), szUnit, L", ", (GC.getTraitInfo(eTrait).getUnitProductionModifier(j).iModifier != iLast));
							iLast = GC.getTraitInfo(eTrait).getUnitProductionModifier(j).iModifier;
						}
					}
				}
			}
		}

		// Increase SpecialUnit Production Speeds
		iLast = 0;
		for (iI = 0; iI < GC.getNumSpecialUnitInfos(); ++iI)
		{
			SpecialUnitTypes eSpecialUnit = ((SpecialUnitTypes)iI);
			for (int j = 0; j < GC.getTraitInfo(eTrait).getNumSpecialUnitProductionModifiers(); j++)
			{
				if ((SpecialUnitTypes)GC.getTraitInfo(eTrait).getSpecialUnitProductionModifier(j).eSpecialUnit == eSpecialUnit)
				{
					szText = gDLL->getText("TXT_KEY_TRAIT_PRODUCTION_MODIFIER_C2C", GC.getTraitInfo(eTrait).getSpecialUnitProductionModifier(j).iModifier);

					setListHelp(szHelpString, szText.GetCString(), GC.getSpecialUnitInfo(eSpecialUnit).getDescription(), L", ", (GC.getTraitInfo(eTrait).getSpecialUnitProductionModifier(j).iModifier != iLast));
					iLast = GC.getTraitInfo(eTrait).getSpecialUnitProductionModifier(j).iModifier;
				}
			}
		}

		//	Military unit production modifier
		if (GC.getTraitInfo(eTrait).getMilitaryProductionModifier() != 0)
		{
			szHelpString.append(NEWLINE);
			szHelpString.append(gDLL->getText("TXT_KEY_CIVIC_MILITARY_PRODUCTION", GC.getTraitInfo(eTrait).getMilitaryProductionModifier()));
		}

		// unit production modifier by Unit Combat
		for (iI = 0; iI < GC.getTraitInfo(eTrait).getNumUnitCombatProductionModifiers(); iI++)
		{
			iCurrentModifier = GC.getTraitInfo(eTrait).getUnitCombatProductionModifier(iI).iModifier;
			if (iCurrentModifier != 0)
			{
				bFound = false;
				for (int iJ = 0; iJ < (int)iIterationValues.size(); iJ++)
				{
					if (iIterationValues[iJ] == iCurrentModifier)
					{
						bFound = true;
					}
				}
				if (!bFound)
				{
					iIterationValues.push_back(GC.getTraitInfo(eTrait).getUnitCombatProductionModifier(iI).iModifier);
				}
			}
		}
		for (int iA = 0; iA < (int)iIterationValues.size(); iA++)
		{
			bFirst = true;
			for (iI = 0; iI < GC.getTraitInfo(eTrait).getNumUnitCombatProductionModifiers(); iI++)
			{
				iCurrentModifier = GC.getTraitInfo(eTrait).getUnitCombatProductionModifier(iI).iModifier;
				if (iCurrentModifier == iIterationValues[iA])
				{
					UnitCombatTypes eTempUnitCombat = GC.getTraitInfo(eTrait).getUnitCombatProductionModifier(iI).eUnitCombat;
					if (bFirst)
					{
						szHelpString.append(NEWLINE);
						szHelpString.append(gDLL->getText("TXT_KEY_TRAIT_UNIT_PRODUCTION_FIRST", iCurrentModifier, CvWString(GC.getUnitCombatInfo(eTempUnitCombat).getType()).GetCString(), GC.getUnitCombatInfo(eTempUnitCombat).getTextKeyWide()));
						bFirst = false;
					}
					else
					{
						szHelpString.append(gDLL->getText("TXT_KEY_TRAIT_UNIT_PRODUCTION_ADDITIONAL", CvWString(GC.getUnitCombatInfo(eTempUnitCombat).getType()).GetCString(), GC.getUnitCombatInfo(eTempUnitCombat).getTextKeyWide()));
					}
				}
			}
			szHelpString.append(gDLL->getText("TXT_KEY_TRAIT_UNIT_PRODUCTION_END"));
		}

		iCurrentModifier = 0;
		iIterationValues.clear();
		bFound = false;
		bFirst = true;

		for (iI = 0; iI < GC.getTraitInfo(eTrait).getNumDomainProductionModifiers(); ++iI)
		{
			if (GC.getTraitInfo(eTrait).getDomainProductionModifier(iI).iModifier != 0)
			{
				szHelpString.append(NEWLINE);
				szHelpString.append(gDLL->getText("TXT_KEY_BUILDING_BUILDS_FASTER_DOMAIN", GC.getDomainInfo((DomainTypes)GC.getTraitInfo(eTrait).getDomainProductionModifier(iI).eDomain).getTextKeyWide(), GC.getTraitInfo(eTrait).getDomainProductionModifier(iI).iModifier));
			}
		}

		//	State Religion Unit Production Modifier
		if (GC.getTraitInfo(eTrait).getStateReligionUnitProductionModifier() != 0)
		{
			szHelpString.append(NEWLINE);
			szHelpString.append(gDLL->getText("TXT_KEY_CIVIC_STATE_REL_TRAIN", GC.getTraitInfo(eTrait).getStateReligionUnitProductionModifier()));
		}

		//ANARCHY
				// iMaxAnarchy
		if (GC.getTraitInfo(eTrait).getMaxAnarchy() != -1)
		{
			if (GC.getTraitInfo(eTrait).getMaxAnarchy() == 0)
			{
				szHelpString.append(NEWLINE);
				szHelpString.append(gDLL->getText("TXT_KEY_TRAIT_NO_ANARCHY_C2C"));
			}
			else
			{
				szHelpString.append(NEWLINE);
				szHelpString.append(gDLL->getText("TXT_KEY_TRAIT_MAX_ANARCHY_C2C", GC.getTraitInfo(eTrait).getMaxAnarchy()));
			}
		}

		if (GC.getTraitInfo(eTrait).getMinAnarchy() > 1)
		{
			szHelpString.append(NEWLINE);
			szHelpString.append(gDLL->getText("TXT_KEY_TRAIT_MIN_ANARCHY_C2C", GC.getTraitInfo(eTrait).getMinAnarchy()));
		}

		if (GC.getTraitInfo(eTrait).getCivicAnarchyTimeModifier() != 0)
		{
			szHelpString.append(NEWLINE);
			szHelpString.append(gDLL->getText("TXT_KEY_CIVIC_ANARCHY_CHANGE", GC.getTraitInfo(eTrait).getCivicAnarchyTimeModifier()));
		}

		if (GC.getTraitInfo(eTrait).getReligiousAnarchyTimeModifier() != 0)
		{
			szHelpString.append(NEWLINE);
			szHelpString.append(gDLL->getText("TXT_KEY_RELIGIOUS_ANARCHY_CHANGE", GC.getTraitInfo(eTrait).getReligiousAnarchyTimeModifier()));
		}

//TRADE
		//	Trade routes
		if (GC.getTraitInfo(eTrait).getTradeRoutes() != 0)
		{
			szHelpString.append(NEWLINE);
			szHelpString.append(gDLL->getText("TXT_KEY_CIVIC_TRADE_ROUTES", GC.getTraitInfo(eTrait).getTradeRoutes()));
		}

		if (GC.getTraitInfo(eTrait).getCoastalTradeRoutes() != 0)
		{
			szHelpString.append(NEWLINE);
			szHelpString.append(gDLL->getText("TXT_KEY_BUILDING_COASTAL_TRADE_ROUTES", GC.getTraitInfo(eTrait).getCoastalTradeRoutes()));
		}

		//	Maximum Trade routes
		if (GC.getTraitInfo(eTrait).getMaxTradeRoutesChange() != 0)
		{
			szHelpString.append(NEWLINE);
			szHelpString.append(gDLL->getText("TXT_KEY_TRAIT_MAX_TRADE_ROUTES", GC.getTraitInfo(eTrait).getMaxTradeRoutesChange()));
		}

		if (GC.getTraitInfo(eTrait).getForeignTradeRouteModifier() != 0)
		{
			szHelpString.append(NEWLINE);
			szHelpString.append(gDLL->getText("TXT_KEY_CIVIC_FOREIGN_TRADE_ROUTE_MOD", GC.getTraitInfo(eTrait).getForeignTradeRouteModifier()));
		}

//CITY DEFENSE
		if (GC.getTraitInfo(eTrait).getCityDefenseBonus() != 0)
		{
			szHelpString.append(NEWLINE);
			szHelpString.append(gDLL->getText("TXT_KEY_CIVIC_CITY_DEFENSE_MOD", GC.getTraitInfo(eTrait).getCityDefenseBonus()));
		}

		if (GC.getTraitInfo(eTrait).getEspionageDefense() != 0)
		{
			szHelpString.append(NEWLINE);
			szHelpString.append(gDLL->getText("TXT_KEY_MISC_TRAIT_ESPIONAGE_DEFENSE", GC.getTraitInfo(eTrait).getEspionageDefense()));
		}

		if (GC.getTraitInfo(eTrait).getBombardDefense() != 0)
		{
			szHelpString.append(NEWLINE);
			szHelpString.append(gDLL->getText("TXT_KEY_TRAIT_BOMBARD_DEFENSE_MOD", -GC.getTraitInfo(eTrait).getBombardDefense()));
		}

		if (GC.getTraitInfo(eTrait).isFreedomFighter())
		{
			szHelpString.append(NEWLINE);
			szHelpString.append(gDLL->getText("TXT_KEY_FREEDOM_FIGHTER"));
		}

		if (GC.getTraitInfo(eTrait).getFreedomFighterChange() != 0)
		{
			szHelpString.append(NEWLINE);
			szHelpString.append(gDLL->getText("TXT_KEY_FREEDOM_FIGHTER_CHANGE", GC.getTraitInfo(eTrait).getFreedomFighterChange()));
		}

//DIPLOMACY
		//	Diplomatic Modifier
		if (GC.getTraitInfo(eTrait).getAttitudeModifier() > 0)
		{
			szHelpString.append(NEWLINE);
			szHelpString.append(gDLL->getText("TXT_KEY_TRAIT_ATTITUDE_MODIFIER_POSITIVE", GC.getTraitInfo(eTrait).getAttitudeModifier()));
		}

		if (GC.getTraitInfo(eTrait).getAttitudeModifier() < 0)
		{
			szHelpString.append(NEWLINE);
			szHelpString.append(gDLL->getText("TXT_KEY_TRAIT_ATTITUDE_MODIFIER_NEGATIVE", GC.getTraitInfo(eTrait).getAttitudeModifier()));
		}

//Team Project (6)
//RELIGION SPREADS
		if (GC.getTraitInfo(eTrait).getStateReligionSpreadProbabilityModifier() != 0)
		{
			szHelpString.append(NEWLINE);
			szHelpString.append(gDLL->getText("TXT_KEY_TRAIT_STATE_REL_SPREAD_MODIFIER", GC.getTraitInfo(eTrait).getStateReligionSpreadProbabilityModifier()));
		}

		if (GC.getTraitInfo(eTrait).getNonStateReligionSpreadProbabilityModifier() != 0)
		{
			szHelpString.append(NEWLINE);
			szHelpString.append(gDLL->getText("TXT_KEY_TRAIT_NON_STATE_REL_SPREAD_MODIFIER", GC.getTraitInfo(eTrait).getNonStateReligionSpreadProbabilityModifier()));
		}

//Team Project (5)
		if (GC.getGame().isOption(GAMEOPTION_RELIGIOUS_DISABLING))
		{
			// All Religions active
			if (GC.getTraitInfo(eTrait).isAllReligionsActive())
			{
				szHelpString.append(NEWLINE);
				szHelpString.append(gDLL->getText("TXT_KEY_ALL_RELIGIONS_ACTIVE"));
			}

			if (GC.getTraitInfo(eTrait).isBansNonStateReligions())
			{
				szHelpString.append(NEWLINE);
				szHelpString.append(gDLL->getText("TXT_KEY_BANS_NON_STATE_RELIGIONS"));
			}
		}

//GOLDEN AGE
		//	Golden Age Modifier
		if (GC.getTraitInfo(eTrait).getGoldenAgeDurationModifier() != 0)
		{
			szHelpString.append(NEWLINE);
			szHelpString.append(gDLL->getText("TXT_KEY_BUILDING_GOLDENAGE_MOD", GC.getTraitInfo(eTrait).getGoldenAgeDurationModifier()));
		}

//Team Project (6)
		//	Golden Age On Birth of GP
		if (GC.getTraitInfo(eTrait).getGoldenAgeonBirthofGreatPeopleType() != NO_UNIT)
		{
			szHelpString.append(NEWLINE);
			szHelpString.append(gDLL->getText("TXT_KEY_TRAIT_GOLDEN_AGE_ON_BIRTH_OF_GP_TYPE", GC.getUnitInfo((UnitTypes)GC.getTraitInfo(eTrait).getGoldenAgeonBirthofGreatPeopleType()).getTextKeyWide()));
		}

//POPULATION
		// Populationgrowthratepercentage
		if (GC.getTraitInfo(eTrait).getGlobalPopulationgrowthratepercentage() > 0)
		{
			szHelpString.append(NEWLINE);
			szHelpString.append(gDLL->getText("TXT_KEY_BUILDING_CITY_SLOW_GROWTH_SPEED", GC.getTraitInfo(eTrait).getGlobalPopulationgrowthratepercentage()));
		}
		else if (GC.getTraitInfo(eTrait).getGlobalPopulationgrowthratepercentage() < 0)
		{
			szHelpString.append(NEWLINE);
			szHelpString.append(gDLL->getText("TXT_KEY_BUILDING_CITY_FAST_GROWTH_SPEED", GC.getTraitInfo(eTrait).getGlobalPopulationgrowthratepercentage()));
		}

//CITY STARTS
		// City Start Population Bonus
		if (GC.getTraitInfo(eTrait).getBonusPopulationinNewCities() != 0)
		{
			szHelpString.append(NEWLINE);
			szHelpString.append(gDLL->getText("TXT_KEY_TRAIT_CITY_START_POPULATION", GC.getTraitInfo(eTrait).getBonusPopulationinNewCities()));
		}

		// City Start Culture
		if (GC.getTraitInfo(eTrait).getCityStartCulture() != 0)
		{
			szHelpString.append(NEWLINE);
			szHelpString.append(gDLL->getText("TXT_KEY_TRAIT_CITY_START_CULTURE", GC.getTraitInfo(eTrait).getCityStartCulture()));
		}

		// City Start State Religion
		if (GC.getTraitInfo(eTrait).isCitiesStartwithStateReligion())
		{
			szHelpString.append(NEWLINE);
			szHelpString.append(gDLL->getText("TXT_KEY_TRAIT_CITY_START_STATE_RELIGION"));
		}

//REVOLUTIONS

		if (GC.getGame().isOption(GAMEOPTION_REVOLUTION))
		{
			if (GC.getGame().getActivePlayer() != NO_PLAYER && GET_PLAYER(GC.getGame().getActivePlayer()).isModderOption(MODDEROPTION_SHOW_REV_EFFECTS))
			{
				//  Revolution Local Civic Index Modifiers
				if (0 != GC.getTraitInfo(eTrait).getRevIdxLocal())
				{
					if ( GC.getTraitInfo(eTrait).getRevIdxLocal() > 0 )
					{
						szHelpString.append(NEWLINE);
						szHelpString.append(gDLL->getText("TXT_KEY_CIVIC_REV_INDEX_LOCAL_PENALTY", GC.getTraitInfo(eTrait).getRevIdxLocal()));
					}
					if ( GC.getTraitInfo(eTrait).getRevIdxLocal() < 0 )
					{
						szHelpString.append(NEWLINE);
						szHelpString.append(gDLL->getText("TXT_KEY_CIVIC_REV_INDEX_LOCAL_BONUS", abs(GC.getTraitInfo(eTrait).getRevIdxLocal())));
					}
				}

				//  Revolution National Civic Index Modifiers
				if (0 != GC.getTraitInfo(eTrait).getRevIdxNational())
				{
					if ( GC.getTraitInfo(eTrait).getRevIdxNational() > 0 )
					{
						szHelpString.append(NEWLINE);
						szHelpString.append(gDLL->getText("TXT_KEY_CIVIC_REV_INDEX_NATIONAL_PENALTY", GC.getTraitInfo(eTrait).getRevIdxNational()));
					}
					if ( GC.getTraitInfo(eTrait).getRevIdxNational() < 0 )
					{
						szHelpString.append(NEWLINE);
						szHelpString.append(gDLL->getText("TXT_KEY_CIVIC_REV_INDEX_NATIONAL_BONUS", abs(GC.getTraitInfo(eTrait).getRevIdxNational())));
					}
				}

				//  Revolution Good Holy City Modifier
				if (0 != GC.getTraitInfo(eTrait).getRevIdxHolyCityGood())
				{
					szHelpString.append(NEWLINE);
					szHelpString.append(gDLL->getText("TXT_KEY_CIVIC_REV_GOOD_HOLY_CITY", GC.getTraitInfo(eTrait).getRevIdxHolyCityGood()));
				}

				//  Revolution Bad Holy City Modifier
				if (0 != GC.getTraitInfo(eTrait).getRevIdxHolyCityBad())
				{
					szHelpString.append(NEWLINE);
					szHelpString.append(gDLL->getText("TXT_KEY_CIVIC_REV_BAD_HOLY_CITY", GC.getTraitInfo(eTrait).getRevIdxHolyCityBad()));
				}

				//  Revolution Nationality Modifier
				if (0 != GC.getTraitInfo(eTrait).getRevIdxNationalityMod())
				{
					if ( GC.getTraitInfo(eTrait).getRevIdxNationalityMod() < 0)
					{
						szHelpString.append(NEWLINE);
						CvWString szTempBuffer;
						szTempBuffer.Format(L"%.0f", 100 * GC.getTraitInfo(eTrait).getRevIdxNationalityMod());
						szHelpString.append(gDLL->getText("TXT_KEY_CIVIC_REV_NATIONALITY_REDUCTION_MOD", szTempBuffer.GetCString()));
					}
					if ( GC.getTraitInfo(eTrait).getRevIdxNationalityMod() > 0)
					{
						szHelpString.append(NEWLINE);
						CvWString szTempBuffer;
						szTempBuffer.Format(L"%.0f", 100 * GC.getTraitInfo(eTrait).getRevIdxNationalityMod());
						szHelpString.append(gDLL->getText("TXT_KEY_CIVIC_REV_NATIONALITY_INCREASE_MOD", szTempBuffer.GetCString()));
					}
				}

				//  Revolution Bad Religion Modifier
				if (0 != GC.getTraitInfo(eTrait).getRevIdxBadReligionMod())
				{
					szHelpString.append(NEWLINE);
					CvWString szTempBuffer;
					szTempBuffer.Format(L"%.0f", 100 * GC.getTraitInfo(eTrait).getRevIdxBadReligionMod());
					szHelpString.append(gDLL->getText("TXT_KEY_CIVIC_REV_BAD_RELIGION_MOD", szTempBuffer.GetCString()));
				}

				//  Revolution Good Religion Modifier
				if (0 != GC.getTraitInfo(eTrait).getRevIdxGoodReligionMod())
				{
					szHelpString.append(NEWLINE);
					CvWString szTempBuffer;
					szTempBuffer.Format(L"%.0f", 100 * GC.getTraitInfo(eTrait).getRevIdxGoodReligionMod());
					szHelpString.append(gDLL->getText("TXT_KEY_CIVIC_REV_GOOD_RELIGION_MOD", szTempBuffer.GetCString()));
				}

				//  Revolution City Distance Modifier
				if (0 != GC.getTraitInfo(eTrait).getRevIdxDistanceModifier())
				{
					if ( GC.getTraitInfo(eTrait).getRevIdxDistanceModifier() < 0 )
					{
						szHelpString.append(NEWLINE);
						szHelpString.append(gDLL->getText("TXT_KEY_CIVIC_CITY_DISTANCE_GOOD_MOD", GC.getTraitInfo(eTrait).getRevIdxDistanceModifier()));
					}
					if ( GC.getTraitInfo(eTrait).getRevIdxDistanceModifier() > 0 )
					{
						szHelpString.append(NEWLINE);
						szHelpString.append(gDLL->getText("TXT_KEY_CIVIC_CITY_DISTANCE_BAD_MOD", abs(GC.getTraitInfo(eTrait).getRevIdxDistanceModifier())));
					}
				}
			}
			else
			{
				//All of these include the newline in their text
				if ( GC.getTraitInfo(eTrait).getRevIdxLocal() > 0 )
				{
					szHelpString.append(gDLL->getText("TXT_KEY_INCREASE_LOCAL_REBELS", GC.getTraitInfo(eTrait).getRevIdxLocal()));
				}
				else if (GC.getTraitInfo(eTrait).getRevIdxLocal() < 0 )
				{
					szHelpString.append(gDLL->getText("TXT_KEY_DECREASE_LOCAL_REBELS", GC.getTraitInfo(eTrait).getRevIdxLocal()));
				}
				if ( GC.getTraitInfo(eTrait).getRevIdxNational() > 0 )
				{
					szHelpString.append(gDLL->getText("TXT_KEY_INCREASE_NATIONAL_REBELS", GC.getTraitInfo(eTrait).getRevIdxNational()));
				}
				else if ( GC.getTraitInfo(eTrait).getRevIdxNational() < 0 )
				{
					szHelpString.append(gDLL->getText("TXT_KEY_DECREASE_NATIONAL_REBELS", GC.getTraitInfo(eTrait).getRevIdxNational()));
				}
				if ( GC.getTraitInfo(eTrait).getRevIdxHolyCityGood() > 0 )
				{
					szHelpString.append(gDLL->getText("TXT_KEY_STATE_RELIGION_WITH_HOLY_CITY", GC.getTraitInfo(eTrait).getRevIdxHolyCityGood()));
				}
				if ( GC.getTraitInfo(eTrait).getRevIdxHolyCityBad() > 0 )
				{
					szHelpString.append(gDLL->getText("TXT_KEY_STATE_RELIGION_WITHOUT_HOLY_CITY", GC.getTraitInfo(eTrait).getRevIdxHolyCityBad()));
				}
			}
		}

/*
		// Free Promotions
		bool bFoundPromotion = false;
		szTempBuffer.clear();
		for (iI = 0; iI < GC.getNumPromotionInfos(); ++iI)
		{
			if (GC.getTraitInfo(eTrait).isFreePromotion(iI))
			{
				if (bFoundPromotion)
				{
					szTempBuffer += L", ";
				}

				szTempBuffer += CvWString::format(L"<link=%s>%s</link>", CvWString(GC.getPromotionInfo((PromotionTypes) iI).getType()).GetCString(), GC.getPromotionInfo((PromotionTypes) iI).getDescription());
				bFoundPromotion = true;
			}
		}

		if (bFoundPromotion)
		{
			szHelpString.append(gDLL->getText("TXT_KEY_TRAIT_FREE_PROMOTIONS", szTempBuffer.GetCString()));

			for (iJ = 0; iJ < GC.getNumUnitCombatInfos(); iJ++)
			{
				if (GC.getTraitInfo(eTrait).isFreePromotionUnitCombat(iJ))
				{
					szTempBuffer.Format(L"\n		%c<link=%s>%s</link>", gDLL->getSymbolID(BULLET_CHAR), CvWString(GC.getUnitCombatInfo((UnitCombatTypes)iJ).getType()).GetCString(), GC.getUnitCombatInfo((UnitCombatTypes)iJ).getDescription());
					szHelpString.append(szTempBuffer);
				}
			}
		}
*/

// MAINTENANCE MODIFIERS
		// iUpkeepModifier
		if (GC.getTraitInfo(eTrait).getUpkeepModifier() != 0)
		{
			szHelpString.append(NEWLINE);
			szHelpString.append(gDLL->getText("TXT_KEY_TRAIT_CIVIC_UPKEEP_MODIFIER_C2C", GC.getTraitInfo(eTrait).getUpkeepModifier()));
		}

		// No Civic Maintenance
		for (iI = 0; iI < GC.getTraitInfo(eTrait).getNumCivicOptionNoUpkeepTypes(); iI++)
		{
			if ((CivicOptionTypes)GC.getTraitInfo(eTrait).isCivicOptionNoUpkeepType(iI).eCivicOption != NO_CIVICOPTION)
			{
				CivicOptionTypes eCivicOption = ((CivicOptionTypes)GC.getTraitInfo(eTrait).isCivicOptionNoUpkeepType(iI).eCivicOption);
				if(GC.getTraitInfo(eTrait).isCivicOptionNoUpkeepType(iI).bBool)
				{
					szHelpString.append(NEWLINE);
					szHelpString.append(gDLL->getText("TXT_KEY_TRAIT_NO_UPKEEP", GC.getCivicOptionInfo(eCivicOption).getTextKeyWide()));
				}
			}
		}

		//for (iI = 0; iI < GC.getNumCivicOptionInfos(); ++iI)
		//{
		//	if (GC.getCivicOptionInfo((CivicOptionTypes) iI).getTraitNoUpkeep(eTrait))
		//	{
		//		szHelpString.append(NEWLINE);
		//		szHelpString.append(gDLL->getText("TXT_KEY_TRAIT_NO_UPKEEP", GC.getCivicOptionInfo((CivicOptionTypes)iI).getTextKeyWide()));
		//	}
		//}

		//	Distance Maintenance Modifer...
		if (GC.getTraitInfo(eTrait).getDistanceMaintenanceModifier() != 0)
		{
			//if (GC.getTraitInfo(eTrait).getDistanceMaintenanceModifier() <= -100)
			//{
			//	szHelpString.append(NEWLINE);
			//	szHelpString.append(gDLL->getText("TXT_KEY_CIVIC_DISTANCE_MAINT"));
			//}
			//else
			//{
				szHelpString.append(NEWLINE);
				szHelpString.append(gDLL->getText("TXT_KEY_CIVIC_DISTANCE_MAINT_MOD", GC.getTraitInfo(eTrait).getDistanceMaintenanceModifier()));
			//}
		}

		//	Num Cities Maintenance Modifer...
		if (GC.getTraitInfo(eTrait).getNumCitiesMaintenanceModifier() != 0)
		{
			//if (GC.getTraitInfo(eTrait).getNumCitiesMaintenanceModifier() <= -100)
			//{
			//	szHelpString.append(NEWLINE);
			//	szHelpString.append(gDLL->getText("TXT_KEY_CIVIC_NO_MAINT_NUM_CITIES"));
			//}
			//else
			//{
				szHelpString.append(NEWLINE);
				szHelpString.append(gDLL->getText("TXT_KEY_CIVIC_NO_MAINT_NUM_CITIES_MOD", GC.getTraitInfo(eTrait).getNumCitiesMaintenanceModifier()));
			//}
		}
		//	Corporations Maintenance Modifer...
		if (GC.getTraitInfo(eTrait).getCorporationMaintenanceModifier() != 0)
		{
			//if (GC.getTraitInfo(eTrait).getCorporationMaintenanceModifier() <= -100)
			//{
			//	szHelpString.append(NEWLINE);
			//	szHelpString.append(gDLL->getText("TXT_KEY_CIVIC_NO_MAINT_CORPORATION"));
			//}
			//else
			//{
				szHelpString.append(NEWLINE);
				szHelpString.append(gDLL->getText("TXT_KEY_CIVIC_NO_MAINT_CORPORATION_MOD", GC.getTraitInfo(eTrait).getCorporationMaintenanceModifier()));
			//}
		}

		//	Worker speed modifier positive
		if (GC.getTraitInfo(eTrait).getWorkerSpeedModifier() > 0)
		{
			szHelpString.append(NEWLINE);
			szHelpString.append(gDLL->getText("TXT_KEY_TRAIT_WORKER_SPEED_POSITIVE", GC.getTraitInfo(eTrait).getWorkerSpeedModifier()));
		}

		//	Worker speed modifier negative
		if (GC.getTraitInfo(eTrait).getWorkerSpeedModifier() < 0)
		{
			szHelpString.append(NEWLINE);
			szHelpString.append(gDLL->getText("TXT_KEY_TRAIT_WORKER_SPEED_NEGATIVE", GC.getTraitInfo(eTrait).getWorkerSpeedModifier()));
		}

//IMPROVEMENT UPGRADE && WORKER SPEED MODS
		//	Improvement upgrade rate modifier
		if (GC.getTraitInfo(eTrait).getImprovementUpgradeRateModifier() != 0)
		{
			szHelpString.append(NEWLINE);
			szHelpString.append(gDLL->getText("TXT_KEY_IMPROVEMENT_UPGRADE_RATE_MODIFIER", GC.getTraitInfo(eTrait).getImprovementUpgradeRateModifier()));
		}

		for (iI = 0; iI < GC.getTraitInfo(eTrait).getNumImprovementUpgradeModifierTypes(); iI++)
		{
			iCurrentModifier = GC.getTraitInfo(eTrait).getImprovementUpgradeModifier(iI).iModifier;
			if (iCurrentModifier != 0)
			{
				bFound = false;
				for (int iJ = 0; iJ < (int)iIterationValues.size(); iJ++)
				{
					if (iIterationValues[iJ] == iCurrentModifier)
					{
						bFound = true;
					}
				}
				if (!bFound)
				{
					iIterationValues.push_back(GC.getTraitInfo(eTrait).getImprovementUpgradeModifier(iI).iModifier);
				}
			}
		}
		for (int iA = 0; iA < (int)iIterationValues.size(); iA++)
		{
			bFirst = true;
			for (iI = 0; iI < GC.getTraitInfo(eTrait).getNumImprovementUpgradeModifierTypes(); iI++)
			{
				iCurrentModifier = GC.getTraitInfo(eTrait).getImprovementUpgradeModifier(iI).iModifier;
				if (iCurrentModifier == iIterationValues[iA])
				{
					ImprovementTypes eTempImprovement = GC.getTraitInfo(eTrait).getImprovementUpgradeModifier(iI).eImprovement;
					if (bFirst)
					{
						szHelpString.append(NEWLINE);
						szHelpString.append(gDLL->getText("TXT_KEY_IMPROVEMENT_UPGRADE_RATE_MODIFIER_SPECIFIC", iCurrentModifier, CvWString(GC.getImprovementInfo(eTempImprovement).getType()).GetCString(), GC.getImprovementInfo(eTempImprovement).getTextKeyWide()));
						bFirst = false;
					}
					else
					{
						szHelpString.append(gDLL->getText("TXT_KEY_IMPROVEMENT_UPGRADE_RATE_MODIFIER_ADDITIONAL", CvWString(GC.getImprovementInfo(eTempImprovement).getType()).GetCString(), GC.getImprovementInfo(eTempImprovement).getTextKeyWide()));
					}
				}
			}
			szHelpString.append(gDLL->getText("TXT_KEY_IMPROVEMENT_UPGRADE_RATE_MODIFIER_END"));
		}

		iCurrentModifier = 0;
		iIterationValues.clear();
		bFound = false;
		bFirst = true;


		for (iI = 0; iI < GC.getTraitInfo(eTrait).getNumBuildWorkerSpeedModifierTypes(); iI++)
		{
			iCurrentModifier = GC.getTraitInfo(eTrait).getBuildWorkerSpeedModifier(iI).iModifier;
			if (iCurrentModifier != 0)
			{
				bFound = false;
				for (int iJ = 0; iJ < (int)iIterationValues.size(); iJ++)
				{
					if (iIterationValues[iJ] == iCurrentModifier)
					{
						bFound = true;
					}
				}
				if (!bFound)
				{
					iIterationValues.push_back(GC.getTraitInfo(eTrait).getBuildWorkerSpeedModifier(iI).iModifier);
				}
			}
		}
		for (int iA = 0; iA < (int)iIterationValues.size(); iA++)
		{
			bFirst = true;
			for (iI = 0; iI < GC.getTraitInfo(eTrait).getNumBuildWorkerSpeedModifierTypes(); iI++)
			{
				iCurrentModifier = GC.getTraitInfo(eTrait).getBuildWorkerSpeedModifier(iI).iModifier;
				if (iCurrentModifier == iIterationValues[iA])
				{
					BuildTypes eTempBuild = GC.getTraitInfo(eTrait).getBuildWorkerSpeedModifier(iI).eBuild;
					if (bFirst)
					{
						szHelpString.append(NEWLINE);
						szHelpString.append(gDLL->getText("TXT_KEY_BUILD_WORKER_SPEED_MODIFIER_SPECIFIC", iCurrentModifier, CvWString(GC.getBuildInfo(eTempBuild).getType()).GetCString(), GC.getBuildInfo(eTempBuild).getDescription()));
						bFirst = false;
					}
					else
					{
						szHelpString.append(gDLL->getText("TXT_KEY_BUILD_WORKER_SPEED_MODIFIER_ADDITIONAL", CvWString(GC.getBuildInfo(eTempBuild).getType()).GetCString(), GC.getBuildInfo(eTempBuild).getDescription()));
					}
				}
			}
		}

		iCurrentModifier = 0;
		iIterationValues.clear();
		bFound = false;
		bFirst = true;


		//RESEARCH MODIFIERS
				// Tech Research Modifier
		for (iI = 0; iI < GC.getTraitInfo(eTrait).getNumTechResearchModifiers(); iI++)
		{
			iCurrentModifier = GC.getTraitInfo(eTrait).getTechResearchModifier(iI).iModifier;
			if (iCurrentModifier != 0)
			{
				bFound = false;
				for (int iJ = 0; iJ < (int)iIterationValues.size(); iJ++)
				{
					if (iIterationValues[iJ] == iCurrentModifier)
					{
						bFound = true;
					}
				}
				if (!bFound)
				{
					iIterationValues.push_back(GC.getTraitInfo(eTrait).getTechResearchModifier(iI).iModifier);
				}
			}
		}
		for (int iA = 0; iA < (int)iIterationValues.size(); iA++)
		{
			bFirst = true;
			for (iI = 0; iI < GC.getTraitInfo(eTrait).getNumTechResearchModifiers(); iI++)
			{
				iCurrentModifier = GC.getTraitInfo(eTrait).getTechResearchModifier(iI).iModifier;
				if (iCurrentModifier == iIterationValues[iA])
				{
					TechTypes eTempTech = GC.getTraitInfo(eTrait).getTechResearchModifier(iI).eTech;
					if (bFirst)
					{
						szHelpString.append(NEWLINE);
						szHelpString.append(gDLL->getText("TXT_KEY_TRAIT_TECH_RESEARCH_MODIFIER_FIRST", iCurrentModifier, CvWString(GC.getTechInfo(eTempTech).getType()).GetCString(), GC.getTechInfo(eTempTech).getTextKeyWide()));
						bFirst = false;
					}
					else
					{
						szHelpString.append(gDLL->getText("TXT_KEY_TRAIT_TECH_RESEARCH_MODIFIER_ADDITIONAL", CvWString(GC.getTechInfo(eTempTech).getType()).GetCString(), GC.getTechInfo(eTempTech).getTextKeyWide()));
					}
				}
			}
			szHelpString.append(gDLL->getText("TXT_KEY_TRAIT_TECH_RESEARCH_MODIFIER_END"));
		}

		iCurrentModifier = 0;
		iIterationValues.clear();
		bFound = false;
		bFirst = true;

//BUILDING MODIFIERS

		// SpecialBuildings
		iLast = 0;
		for (iI = 0; iI < GC.getNumSpecialBuildingInfos(); ++iI)
		{
			SpecialBuildingTypes eSpecialBuilding = ((SpecialBuildingTypes)iI);

			for (int j = 0; j < GC.getTraitInfo(eTrait).getNumSpecialBuildingProductionModifiers(); j++)
			{
				if ((SpecialBuildingTypes)GC.getTraitInfo(eTrait).getSpecialBuildingProductionModifier(j).eSpecialBuilding == eSpecialBuilding)
				{
					if (GC.getTraitInfo(eTrait).getSpecialBuildingProductionModifier(j).iModifier !=0)
					{
						//if (GC.getTraitInfo(eTrait).getSpecialBuildingProductionModifier(j).iModifier == 100)
						//{
						//	szText = gDLL->getText("TXT_KEY_TRAIT_DOUBLE_SPEED_C2C");
						//}
						//else
						//{
							szText = gDLL->getText("TXT_KEY_TRAIT_PRODUCTION_MODIFIER_C2C", GC.getTraitInfo(eTrait).getSpecialBuildingProductionModifier(j).iModifier);
						//}
						setListHelp(szHelpString, szText.GetCString(), GC.getSpecialBuildingInfo(eSpecialBuilding).getDescription(), L", ", (GC.getTraitInfo(eTrait).getSpecialBuildingProductionModifier(j).iModifier != iLast));
						iLast = GC.getTraitInfo(eTrait).getSpecialBuildingProductionModifier(j).iModifier;
					}
				}
			}
		}

		// Buildings
		iLast = 0;
		for (iI = 0; iI < GC.getNumBuildingInfos(); ++iI)
		{
			const BuildingTypes eLoopBuilding = static_cast<BuildingTypes>(iI);

			if (!isWorldWonder(eLoopBuilding))
			{
				for (int j = 0; j < GC.getTraitInfo(eTrait).getNumBuildingProductionModifiers(); j++)
				{
					if ((BuildingTypes)GC.getTraitInfo(eTrait).getBuildingProductionModifier(j).eBuilding == eLoopBuilding)
					{
						if (GC.getTraitInfo(eTrait).getBuildingProductionModifier(j).iModifier != 0)
						{
							//if (GC.getTraitInfo(eTrait).getBuildingProductionModifier(j).iModifier == 100)
							//{
							//	szText = gDLL->getText("TXT_KEY_TRAIT_DOUBLE_SPEED_C2C");
							//}
							//else
							//{
								szText = gDLL->getText("TXT_KEY_TRAIT_PRODUCTION_MODIFIER_C2C", GC.getTraitInfo(eTrait).getBuildingProductionModifier(j).iModifier);
							//}

							CvWString szBuilding;
							szBuilding.Format(L"<link=%s>%s</link>", CvWString(GC.getBuildingInfo(eLoopBuilding).getType()).GetCString(), GC.getBuildingInfo(eLoopBuilding).getDescription());
							setListHelp(szHelpString, szText.GetCString(), szBuilding, L", ", (GC.getTraitInfo(eTrait).getBuildingProductionModifier(j).iModifier != iLast));
							iLast = GC.getTraitInfo(eTrait).getBuildingProductionModifier(j).iModifier;
						}
					}
				}
			}
		}

		// Buildings
		iLast = 0;
		for (iI = 0; iI < GC.getNumBuildingInfos(); ++iI)
		{
			const BuildingTypes eLoopBuilding = static_cast<BuildingTypes>(iI);

			if (!isWorldWonder(eLoopBuilding))
			{
				for (int j = 0; j < GC.getTraitInfo(eTrait).getNumBuildingHappinessModifiers(); j++)
				{
					if ((BuildingTypes)GC.getTraitInfo(eTrait).getBuildingHappinessModifier(j).eBuilding == eLoopBuilding)
					{
						const int iHappiness = GC.getTraitInfo(eTrait).getBuildingHappinessModifier(j).iModifier;
						if (iHappiness != 0)
						{
							if (iHappiness > 0)
							{
								szText = gDLL->getText("TXT_KEY_TRAIT_BUILDING_HAPPINESS_C2C", iHappiness, gDLL->getSymbolID(HAPPY_CHAR));
							}
							else
							{
								szText = gDLL->getText("TXT_KEY_TRAIT_BUILDING_HAPPINESS_C2C", -iHappiness, gDLL->getSymbolID(UNHAPPY_CHAR));
							}

							CvWString szBuilding;
							szBuilding.Format(L"<link=%s>%s</link>", CvWString(GC.getBuildingInfo(eLoopBuilding).getType()).GetCString(), GC.getBuildingInfo(eLoopBuilding).getDescription());
							setListHelp(szHelpString, szText.GetCString(), szBuilding, L", ", (iHappiness != iLast));
							iLast = iHappiness;
						}
					}
				}
			}
		}

		// Property manipulators
		const CvPropertyManipulators* pMani = GC.getTraitInfo(eTrait).getPropertyManipulators();
		if (pMani)
			pMani->buildDisplayString(szHelpString);
	}

//	return szHelpString;
}


//
// parseLeaderTraits - SimpleCivPicker							// LOCALIZATION READY
//
void CvGameTextMgr::parseLeaderTraits(CvWStringBuffer &szHelpString, LeaderHeadTypes eLeader, CivilizationTypes eCivilization, bool bDawnOfMan, bool bCivilopediaText)
{
	PROFILE_FUNC();


	//	Build help string
	if (eLeader != NO_LEADER)
	{
		if (!bDawnOfMan && !bCivilopediaText)
		{
			CvWString szTempBuffer;
			szTempBuffer.Format( SETCOLR L"%s" ENDCOLR , TEXT_COLOR("COLOR_HIGHLIGHT_TEXT"), GC.getLeaderHeadInfo(eLeader).getDescription());
			szHelpString.append(szTempBuffer);
		}

		FAssertMsg((GC.getNumTraitInfos() > 0), "GC.getNumTraitInfos() is less than or equal to zero but is expected to be larger than zero in CvSimpleCivPicker::setLeaderText");

		bool bFirst = true;

		for (int iI = 0; iI < GC.getNumTraitInfos(); ++iI)
		{
			TraitTypes eTrait = ((TraitTypes)iI);
			if (GC.getLeaderHeadInfo(eLeader).hasTrait(eTrait) && GC.getTraitInfo(eTrait).isValidTrait(true))
			{
				if (bDawnOfMan)
				{
					if (!bFirst) szHelpString.append(L", ");
					else bFirst = false;
				}
				parseTraits(szHelpString, ((TraitTypes)iI), eCivilization, bDawnOfMan);
			}
		}
	}
	else //	Random leader
	{
		CvWString szTempBuffer;
		szTempBuffer.Format( SETCOLR L"%s" ENDCOLR , TEXT_COLOR("COLOR_HIGHLIGHT_TEXT"), gDLL->getText("TXT_KEY_TRAIT_PLAYER_UNKNOWN").c_str());
		szHelpString.append(szTempBuffer);
	}
}

//
// parseLeaderTraits - SimpleCivPicker							// LOCALIZATION READY
//
void CvGameTextMgr::parseLeaderShortTraits(CvWStringBuffer &szHelpString, LeaderHeadTypes eLeader)
{
	PROFILE_FUNC();

	int iI;

	//	Build help string
	if (eLeader != NO_LEADER)
	{
		FAssertMsg((GC.getNumTraitInfos() > 0),
			"GC.getNumTraitInfos() is less than or equal to zero but is expected to be larger than zero in CvSimpleCivPicker::setLeaderText");

		bool bFirst = true;
		for (iI = 0; iI < GC.getNumTraitInfos(); ++iI)
		{
			TraitTypes eTrait = ((TraitTypes)iI);
			if (GC.getLeaderHeadInfo(eLeader).hasTrait(eTrait) && !(GC.getGame().isOption(GAMEOPTION_NO_NEGATIVE_TRAITS) && GC.getTraitInfo(eTrait).isNegativeTrait()) &&
				!(GC.getGame().isOption(GAMEOPTION_START_NO_POSITIVE_TRAITS) && !GC.getTraitInfo(eTrait).isNegativeTrait()) &&
				((GC.getGame().isOption(GAMEOPTION_LEADERHEAD_LEVELUPS) && (GC.getTraitInfo(eTrait).getLinePriority() != 0 || GC.getTraitInfo(eTrait).isCivilizationTrait())) ||
				(!GC.getGame().isOption(GAMEOPTION_LEADERHEAD_LEVELUPS) && GC.getTraitInfo(eTrait).getLinePriority() == 0)))
			{
				if (!bFirst)
				{
					szHelpString.append(L"/");
				}
				szHelpString.append(gDLL->getText(GC.getTraitInfo((TraitTypes)iI).getShortDescription()));
				bFirst = false;
			}
		}
	}
	else
	{
		//	Random leader
		szHelpString.append(CvWString("???/???"));
	}

	//	return szHelpString;
}

//
// Build Civilization Info Help Text
//
void CvGameTextMgr::parseCivInfos(CvWStringBuffer &szInfoText, CivilizationTypes eCivilization, bool bDawnOfMan, bool bLinks)
{
	PROFILE_FUNC();

	if (eCivilization == NO_CIVILIZATION)
	{//	This is a civless civ, let us know here...
		szInfoText.append(gDLL->getText("TXT_KEY_CIV_UNKNOWN"));
		return;
	}
	if (!bDawnOfMan)
	{
		CvWString szBuffer;
		CvWString szText;
		// Civ Name
		szBuffer.Format(SETCOLR L"%s" ENDCOLR , TEXT_COLOR("COLOR_HIGHLIGHT_TEXT"), GC.getCivilizationInfo(eCivilization).getDescription());
		szInfoText.append(szBuffer);

		// Free Techs
		szBuffer.Format(NEWLINE SETCOLR L"%s" ENDCOLR , TEXT_COLOR("COLOR_ALT_HIGHLIGHT_TEXT"), gDLL->getText("TXT_KEY_FREE_TECHS").GetCString());
		szInfoText.append(szBuffer);

		bool bFound = false;
		for (int iI = 0; iI < GC.getNumTechInfos(); ++iI)
		{
			if (GC.getCivilizationInfo(eCivilization).isCivilizationFreeTechs(iI))
			{
				bFound = true;
				// Add Tech
				szText.Format((bLinks ? L"<link=%s>%s</link>" : L"%s"), CvWString(GC.getTechInfo((TechTypes)iI).getType()).GetCString(), GC.getTechInfo((TechTypes)iI).getDescription());
				szBuffer.Format(L"%s  %c%s", NEWLINE, gDLL->getSymbolID(BULLET_CHAR), szText.GetCString());
				szInfoText.append(szBuffer);
			}
		}
		if (!bFound)
		{
			szBuffer.Format(L"%s  %s", NEWLINE, gDLL->getText("TXT_KEY_FREE_TECHS_NO").GetCString());
			szInfoText.append(szBuffer);
		}
	}
}


// BUG - Specialist Actual Effects - start
void CvGameTextMgr::parseSpecialistHelp(CvWStringBuffer &szHelpString, SpecialistTypes eSpecialist, CvCity* pCity, bool bCivilopediaText)
{
	parseSpecialistHelpActual(szHelpString, eSpecialist, pCity, bCivilopediaText, 0);
}

void CvGameTextMgr::parseSpecialistHelpActual(CvWStringBuffer &szHelpString, SpecialistTypes eSpecialist, CvCity* pCity, bool bCivilopediaText, int iChange)
// BUG - Specialist Actual Effects - end
{
	PROFILE_FUNC();

	CvWString szText;
	CvWString szTempBuffer;
	CvWString szFirstBuffer;
	int aiYields[NUM_YIELD_TYPES];
	int aiCommerces[NUM_COMMERCE_TYPES];
	int iI;

	if (eSpecialist != NO_SPECIALIST)
	{
		if (!bCivilopediaText)
		{
			szHelpString.append(GC.getSpecialistInfo(eSpecialist).getDescription());
		}

		for (iI = 0; iI < NUM_YIELD_TYPES; ++iI)
		{
			if (GC.getGame().getActivePlayer() == NO_PLAYER)
			{
				aiYields[iI] = GC.getSpecialistInfo(eSpecialist).getYieldChange(iI);
			}
			else
			{
				//Team Project (1)
				aiYields[iI] = ((pCity == NULL) ? GET_PLAYER(GC.getGame().getActivePlayer()).specialistYield(eSpecialist, ((YieldTypes)iI)) : pCity->specialistYield(eSpecialist, ((YieldTypes)iI)));
			}
		}

		setYieldChangeHelp(szHelpString, L"", L"", L"", aiYields);

		for (iI = 0; iI < NUM_COMMERCE_TYPES; ++iI)
		{
			if (GC.getGame().getActivePlayer() == NO_PLAYER)
			{
				aiCommerces[iI] = GC.getSpecialistInfo(eSpecialist).getCommerceChange(iI);
			}
			else
			{
				aiCommerces[iI] = ((pCity == NULL) ? GET_PLAYER(GC.getGame().getActivePlayer()).specialistCommerce(eSpecialist, ((CommerceTypes)iI)) : pCity->specialistCommerce(eSpecialist, ((CommerceTypes)iI)));
			}
		}

		setCommerceChangeHelp(szHelpString, L"", L"", L"", aiCommerces);

		if (GC.getSpecialistInfo(eSpecialist).getExperience() > 0)
		{
			szHelpString.append(NEWLINE);
			szHelpString.append(gDLL->getText("TXT_KEY_SPECIALIST_EXPERIENCE", GC.getSpecialistInfo(eSpecialist).getExperience()));
		}

		int iUnitCombatExperience = 0;
		for (iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
		{
			iUnitCombatExperience = 0;
			UnitCombatTypes eUnitCombat = ((UnitCombatTypes)iI);
			for (int iJ = 0; iJ < GC.getSpecialistInfo(eSpecialist).getNumUnitCombatExperienceTypes(); iJ++)
			{
				if (GC.getSpecialistInfo(eSpecialist).getUnitCombatExperienceType(iJ, false).eUnitCombat == eUnitCombat)
				{
					iUnitCombatExperience += GC.getSpecialistInfo(eSpecialist).getUnitCombatExperienceType(iJ, false).iModifier;
				}
			}
			if (iUnitCombatExperience > 0)
			{
				szHelpString.append(NEWLINE);
				szHelpString.append(gDLL->getText("TXT_KEY_SPECIALIST_UNIT_COMBAT_EXPERIENCE", iUnitCombatExperience, GC.getUnitCombatInfo(eUnitCombat).getTextKeyWide()));
			}
		}

		if (GC.getSpecialistInfo(eSpecialist).getGreatPeopleRateChange() != 0)
		{
			szHelpString.append(NEWLINE);
			szHelpString.append(gDLL->getText("TXT_KEY_SPECIALIST_BIRTH_RATE", GC.getSpecialistInfo(eSpecialist).getGreatPeopleRateChange()));
		}

		if (GC.getSpecialistInfo(eSpecialist).getInsidiousness() != 0)
		{
			szHelpString.append(NEWLINE);
			float fValue = (float)GC.getSpecialistInfo(eSpecialist).getInsidiousness();
			{
				szTempBuffer.Format(L"%.1f", fValue/10);
			}
			szHelpString.append(gDLL->getText("TXT_KEY_SPECIALIST_INSIDIOUSNESS", szTempBuffer.GetCString()));
		}

		if (GC.getSpecialistInfo(eSpecialist).getInvestigation() != 0)
		{
			szHelpString.append(NEWLINE);
			float fValue = (float)GC.getSpecialistInfo(eSpecialist).getInvestigation();
			{
				szTempBuffer.Format(L"%.1f", fValue/10);
			}
			szHelpString.append(gDLL->getText("TXT_KEY_SPECIALIST_INVESTIGATION", szTempBuffer.GetCString()));
			//szHelpString.append(NEWLINE);
			//szHelpString.append(gDLL->getText("TXT_KEY_SPECIALIST_INVESTIGATION", GC.getSpecialistInfo(eSpecialist).getInvestigation()));
		}

/************************************************************************************************/
/* Specialists Enhancements, by Supercheese 10/9/09											 */
/*																							  */
/*																							  */
/************************************************************************************************/
//Team Project (1)
		int iSpecialistHealth = 0;
		for (iI = 0; iI < GC.getNumTechInfos(); iI++)
		{
			iSpecialistHealth = 0;
			TechTypes eTech = ((TechTypes)iI);
			for (int iJ = 0; iJ < GC.getSpecialistInfo(eSpecialist).getNumTechHealthTypes(); iJ++)
			{
				if (GC.getSpecialistInfo(eSpecialist).getTechHealthType(iJ).eTech == eTech)
				{
					iSpecialistHealth += GC.getSpecialistInfo(eSpecialist).getTechHealthType(iJ).iModifier;
				}
			}
			if (GC.getGame().getActivePlayer() == NO_PLAYER && pCity != NULL)
			{
				iSpecialistHealth += pCity->getTechSpecialistHealth(eTech);
				iSpecialistHealth += pCity->getTechSpecialistHealthTypes(eTech, eSpecialist);
			}
			if (iSpecialistHealth > 0)
			{
				szHelpString.append(NEWLINE);
				if (GC.getGame().getActivePlayer() != NO_PLAYER && pCity != NULL && GET_TEAM(pCity->getTeam()).isHasTech(eTech))
				{
					szHelpString.append(gDLL->getText("TXT_KEY_SPECIALIST_TECH_HEALTH_TYPE_KNOWN", iSpecialistHealth, gDLL->getSymbolID(HEALTHY_CHAR), GC.getTechInfo(eTech).getTextKeyWide()));
				}
				else
				{
					szHelpString.append(gDLL->getText("TXT_KEY_SPECIALIST_TECH_HEALTH_TYPE", iSpecialistHealth, gDLL->getSymbolID(HEALTHY_CHAR), GC.getTechInfo(eTech).getTextKeyWide()));
				}
			}
			else if (iSpecialistHealth < 0)
			{
				szHelpString.append(NEWLINE);
				if (GC.getGame().getActivePlayer() != NO_PLAYER && pCity != NULL && GET_TEAM(pCity->getTeam()).isHasTech(eTech))
				{
					szHelpString.append(gDLL->getText("TXT_KEY_SPECIALIST_TECH_HEALTH_TYPE_KNOWN", -iSpecialistHealth, gDLL->getSymbolID(UNHEALTHY_CHAR), GC.getTechInfo(eTech).getTextKeyWide()));
				}
				else
				{
					szHelpString.append(gDLL->getText("TXT_KEY_SPECIALIST_TECH_HEALTH_TYPE", -iSpecialistHealth, gDLL->getSymbolID(UNHEALTHY_CHAR), GC.getTechInfo(eTech).getTextKeyWide()));
				}
			}
		}
		if (GC.getSpecialistInfo(eSpecialist).getHealthPercent() != 0)
		{
			float fValue = (float)abs(GC.getSpecialistInfo(eSpecialist).getHealthPercent());
			if (fmod(fValue,100) == 0)
			{
				szTempBuffer.Format(L"%.0f", fValue/100);
			}
			else if (fmod(fValue,10) == 0)
			{
				szTempBuffer.Format(L"%.1f", fValue/100);
			}
			else
			{
				szTempBuffer.Format(L"%.2f", fValue/100);
			}
			szFirstBuffer.Format(L"%s%s", NEWLINE, gDLL->getText("TXT_KEY_SPECIALIST_PERCENT", szTempBuffer.GetCString(), (GC.getSpecialistInfo(eSpecialist).getHealthPercent() > 0 ? gDLL->getSymbolID(HEALTHY_CHAR) : gDLL->getSymbolID(UNHEALTHY_CHAR))).c_str());
			szHelpString.append(szFirstBuffer);
		}
//Team Project (1)
		int iSpecialistHappiness = 0;
		for (iI = 0; iI < GC.getNumTechInfos(); iI++)
		{
			iSpecialistHappiness = 0;
			TechTypes eTech = ((TechTypes)iI);
			for (int iJ = 0; iJ < GC.getSpecialistInfo(eSpecialist).getNumTechHappinessTypes(); iJ++)
			{
				if (GC.getSpecialistInfo(eSpecialist).getTechHappinessType(iJ).eTech == eTech)
				{
					iSpecialistHappiness += GC.getSpecialistInfo(eSpecialist).getTechHappinessType(iJ).iModifier;
				}
			}
			if (GC.getGame().getActivePlayer() == NO_PLAYER && pCity != NULL)
			{
				iSpecialistHappiness += pCity->getTechSpecialistHappiness(eTech);
				iSpecialistHappiness += pCity->getTechSpecialistHappinessTypes(eTech, eSpecialist);
			}
			if (iSpecialistHappiness > 0)
			{
				szHelpString.append(NEWLINE);
				if (GC.getGame().getActivePlayer() != NO_PLAYER && pCity != NULL && GET_TEAM(pCity->getTeam()).isHasTech(eTech))
				{
					szHelpString.append(gDLL->getText("TXT_KEY_SPECIALIST_TECH_HAPPINESS_TYPE_KNOWN", iSpecialistHappiness, gDLL->getSymbolID(HAPPY_CHAR), GC.getTechInfo(eTech).getTextKeyWide()));
				}
				else
				{
					szHelpString.append(gDLL->getText("TXT_KEY_SPECIALIST_TECH_HAPPINESS_TYPE", iSpecialistHappiness, gDLL->getSymbolID(HAPPY_CHAR), GC.getTechInfo(eTech).getTextKeyWide()));
				}
			}
			else if (iSpecialistHappiness < 0)
			{
				szHelpString.append(NEWLINE);
				if (GC.getGame().getActivePlayer() != NO_PLAYER && pCity != NULL && GET_TEAM(pCity->getTeam()).isHasTech(eTech))
				{
					szHelpString.append(gDLL->getText("TXT_KEY_SPECIALIST_TECH_HAPPINESS_TYPE_KNOWN", -iSpecialistHappiness, gDLL->getSymbolID(UNHAPPY_CHAR), GC.getTechInfo(eTech).getTextKeyWide()));
				}
				else
				{
					szHelpString.append(gDLL->getText("TXT_KEY_SPECIALIST_TECH_HAPPINESS_TYPE", -iSpecialistHappiness, gDLL->getSymbolID(UNHAPPY_CHAR), GC.getTechInfo(eTech).getTextKeyWide()));
				}
			}
		}
		if (GC.getSpecialistInfo(eSpecialist).getHappinessPercent() != 0)
		{
			float fValue = (float)abs(GC.getSpecialistInfo(eSpecialist).getHappinessPercent());
			if (fmod(fValue,100) == 0)
			{
				szTempBuffer.Format(L"%.0f", fValue/100);
			}
			else if (fmod(fValue,10) == 0)
			{
				szTempBuffer.Format(L"%.1f", fValue/100);
			}
			else
			{
				szTempBuffer.Format(L"%.2f", fValue/100);
			}
			szFirstBuffer.Format(L"%s%s", NEWLINE, gDLL->getText("TXT_KEY_SPECIALIST_PERCENT", szTempBuffer.GetCString(), (GC.getSpecialistInfo(eSpecialist).getHappinessPercent() > 0 ? gDLL->getSymbolID(HAPPY_CHAR) : gDLL->getSymbolID(UNHAPPY_CHAR))).c_str());
			szHelpString.append(szFirstBuffer);
		}
/************************************************************************************************/
/* Specialists Enhancements						  END											  */
/************************************************************************************************/
// BUG - Specialist Actual Effects - start
		if (iChange != 0 && NULL != pCity && pCity->getOwner() == GC.getGame().getActivePlayer() && getBugOptionBOOL("MiscHover__SpecialistActualEffects", true, "BUG_MISC_SPECIALIST_HOVER_ACTUAL_EFFECTS"))
		{
			bool bStarted = false;
			CvWString szStart = gDLL->getText("TXT_KEY_ACTUAL_EFFECTS");

			// Yield
			int aiYields[NUM_YIELD_TYPES];
			for (int iI = 0; iI < NUM_YIELD_TYPES; ++iI)
			{
				aiYields[iI] = pCity->getAdditionalYieldBySpecialist((YieldTypes)iI, eSpecialist, iChange);
			}
			bStarted = setResumableYieldChangeHelp(szHelpString, szStart, L": ", L"", aiYields, false, true, bStarted);

			// Commerce
			int aiCommerces[NUM_COMMERCE_TYPES];
			for (int iI = 0; iI < NUM_COMMERCE_TYPES; ++iI)
			{
				aiCommerces[iI] = pCity->getAdditionalCommerceTimes100BySpecialist((CommerceTypes)iI, eSpecialist, iChange);
			}
			bStarted = setResumableCommerceTimes100ChangeHelp(szHelpString, szStart, L": ", L"", aiCommerces, true, bStarted);

			// Great People
			int iGreatPeopleRate = pCity->getAdditionalGreatPeopleRateBySpecialist(eSpecialist, iChange);
			bStarted = setResumableValueChangeHelp(szHelpString, szStart, L": ", L"", iGreatPeopleRate, gDLL->getSymbolID(GREAT_PEOPLE_CHAR), false, true, bStarted);

		}
// BUG - Specialist Actual Effects - end

		GC.getSpecialistInfo(eSpecialist).getPropertyManipulators()->buildDisplayString(szHelpString);

		if (!CvWString(GC.getSpecialistInfo(eSpecialist).getHelp()).empty() && !bCivilopediaText)
		{
			szHelpString.append(NEWLINE);
			szHelpString.append(GC.getSpecialistInfo(eSpecialist).getHelp());
		}
	}
}

void CvGameTextMgr::parseFreeSpecialistHelp(CvWStringBuffer &szHelpString, const CvCity& kCity)
{
	PROFILE_FUNC();

	for (int iLoopSpecialist = 0; iLoopSpecialist < GC.getNumSpecialistInfos(); iLoopSpecialist++)
	{
		SpecialistTypes eSpecialist = (SpecialistTypes)iLoopSpecialist;
		int iNumSpecialists = kCity.getFreeSpecialistCount(eSpecialist);

		if (iNumSpecialists > 0)
		{
			int aiYields[NUM_YIELD_TYPES];
			int aiCommerces[NUM_COMMERCE_TYPES];
			int iI;

			szHelpString.append(NEWLINE);
			szHelpString.append(CvWString::format(L"%s (%d): ", GC.getSpecialistInfo(eSpecialist).getDescription(), iNumSpecialists));

			for (iI = 0; iI < NUM_YIELD_TYPES; ++iI)
			{
//Team Project (1)
				aiYields[iI] = iNumSpecialists * kCity.specialistYield(eSpecialist, ((YieldTypes)iI));
			}

			CvWStringBuffer szYield;
			setYieldChangeHelp(szYield, L"", L"", L"", aiYields, false, false);
			szHelpString.append(szYield);

			for (iI = 0; iI < NUM_COMMERCE_TYPES; ++iI)
			{
				aiCommerces[iI] = iNumSpecialists * kCity.specialistCommerce(eSpecialist, ((CommerceTypes)iI));
			}

			CvWStringBuffer szCommerceString;
			setCommerceChangeHelp(szCommerceString, L"", L"", L"", aiCommerces, false, false);
			if (!szYield.isEmpty() && !szCommerceString.isEmpty())
			{
				szHelpString.append(L", ");
			}
			szHelpString.append(szCommerceString);

			if (GC.getSpecialistInfo(eSpecialist).getExperience() != 0)
			{
				if (!szYield.isEmpty() || !szCommerceString.isEmpty())
				{
					szHelpString.append(L", ");
				}
				szHelpString.append(gDLL->getText("TXT_KEY_SPECIALIST_EXPERIENCE_SHORT", iNumSpecialists * GC.getSpecialistInfo(eSpecialist).getExperience()));
			}

			int iUnitCombatExperience = 0;
			for (iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
			{
				iUnitCombatExperience = 0;
				UnitCombatTypes eUnitCombat = ((UnitCombatTypes)iI);
				for (int iJ = 0; iJ < GC.getSpecialistInfo(eSpecialist).getNumUnitCombatExperienceTypes(); iJ++)
				{
					if (GC.getSpecialistInfo(eSpecialist).getUnitCombatExperienceType(iJ, false).eUnitCombat == eUnitCombat)
					{
						iUnitCombatExperience += GC.getSpecialistInfo(eSpecialist).getUnitCombatExperienceType(iJ, false).iModifier;
					}
				}
				if (iUnitCombatExperience > 0)
				{
					if (!szYield.isEmpty() || !szCommerceString.isEmpty() || GC.getSpecialistInfo(eSpecialist).getExperience() != 0)
					{
						szHelpString.append(L", ");
					}
					szHelpString.append(gDLL->getText("TXT_KEY_SPECIALIST_UNIT_COMBAT_EXPERIENCE_SHORT", iUnitCombatExperience, GC.getUnitCombatInfo(eUnitCombat).getTextKeyWide()));
				}
			}

//Team Project (1)
			if (GC.getSpecialistInfo(eSpecialist).getGreatPeopleRateChange() != 0)
			{
				szHelpString.append(L", ");
				szHelpString.append(gDLL->getText("TXT_KEY_SPECIALIST_BIRTH_RATE", iNumSpecialists * GC.getSpecialistInfo(eSpecialist).getGreatPeopleRateChange()));
			}

	/************************************************************************************************/
	/* Specialists Enhancements, by Supercheese 10/9/09											 */
	/*																							  */
	/*																							  */
	/************************************************************************************************/
			int iSpecialistHealth = 0;
			for (iI = 0; iI < GC.getNumTechInfos(); iI++)
			{
				iSpecialistHealth = 0;
				TechTypes eTech = ((TechTypes)iI);
				for (int iJ = 0; iJ < GC.getSpecialistInfo(eSpecialist).getNumTechHealthTypes(); iJ++)
				{
					if (GC.getSpecialistInfo(eSpecialist).getTechHealthType(iJ).eTech == eTech)
					{
						iSpecialistHealth += GC.getSpecialistInfo(eSpecialist).getTechHealthType(iJ).iModifier;
					}
				}
				if (GC.getGame().getActivePlayer() == NO_PLAYER && GET_PLAYER(kCity.getOwner()).getID() != NO_PLAYER)
				{
					iSpecialistHealth += kCity.getTechSpecialistHealth(eTech);
					iSpecialistHealth += kCity.getTechSpecialistHealthTypes(eTech, eSpecialist);
				}
				if (iSpecialistHealth > 0)
				{
					szHelpString.append(L", ");
					if (GC.getGame().getActivePlayer() != NO_PLAYER && GET_PLAYER(kCity.getOwner()).getID() != NO_PLAYER && GET_TEAM(kCity.getTeam()).isHasTech(eTech))
					{
						szHelpString.append(gDLL->getText("TXT_KEY_SPECIALIST_TECH_HEALTH_TYPE_KNOWN", iNumSpecialists * iSpecialistHealth, gDLL->getSymbolID(HEALTHY_CHAR), GC.getTechInfo(eTech).getTextKeyWide()));
					}
					else
					{
						szHelpString.append(gDLL->getText("TXT_KEY_SPECIALIST_TECH_HEALTH_TYPE", iNumSpecialists * iSpecialistHealth, gDLL->getSymbolID(HEALTHY_CHAR), GC.getTechInfo(eTech).getTextKeyWide()));
					}
				}
				else if (iSpecialistHealth < 0)
				{
					szHelpString.append(L", ");
					if (GC.getGame().getActivePlayer() != NO_PLAYER && GET_PLAYER(kCity.getOwner()).getID() != NO_PLAYER && GET_TEAM(kCity.getTeam()).isHasTech(eTech))
					{
						szHelpString.append(gDLL->getText("TXT_KEY_SPECIALIST_TECH_HEALTH_TYPE_KNOWN", iNumSpecialists * -iSpecialistHealth, gDLL->getSymbolID(UNHEALTHY_CHAR), GC.getTechInfo(eTech).getTextKeyWide()));
					}
					else
					{
						szHelpString.append(gDLL->getText("TXT_KEY_SPECIALIST_TECH_HEALTH_TYPE", iNumSpecialists * -iSpecialistHealth, gDLL->getSymbolID(UNHEALTHY_CHAR), GC.getTechInfo(eTech).getTextKeyWide()));
					}
				}
			}
			CvWString szTempBuffer;
			CvWString szFirstBuffer;
			if (GC.getSpecialistInfo(eSpecialist).getHealthPercent() != 0)
			{
				float fValue = (float)abs(iNumSpecialists * GC.getSpecialistInfo(eSpecialist).getHealthPercent());
				if (fmod(fValue,100) == 0)
				{
					szTempBuffer.Format(L"%.0f", fValue/100);
				}
				else if (fmod(fValue,10) == 0)
				{
					szTempBuffer.Format(L"%.1f", fValue/100);
				}
				else
				{
					szTempBuffer.Format(L"%.2f", fValue/100);
				}
				szFirstBuffer.Format(L"%s%s, ", gDLL->getText("TXT_KEY_SPECIALIST_PERCENT", szTempBuffer.GetCString(), (GC.getSpecialistInfo(eSpecialist).getHealthPercent() > 0 ? gDLL->getSymbolID(HEALTHY_CHAR) : gDLL->getSymbolID(UNHEALTHY_CHAR))).c_str());
				szHelpString.append(szFirstBuffer);
			}

			int iSpecialistHappiness = 0;
			for (iI = 0; iI < GC.getNumTechInfos(); iI++)
			{
				iSpecialistHappiness = 0;
				TechTypes eTech = ((TechTypes)iI);
				for (int iJ = 0; iJ < GC.getSpecialistInfo(eSpecialist).getNumTechHappinessTypes(); iJ++)
				{
					if (GC.getSpecialistInfo(eSpecialist).getTechHappinessType(iJ).eTech == eTech)
					{
						iSpecialistHappiness += GC.getSpecialistInfo(eSpecialist).getTechHappinessType(iJ).iModifier;
					}
				}
				if (GC.getGame().getActivePlayer() == NO_PLAYER && GET_PLAYER(kCity.getOwner()).getID() != NO_PLAYER)
				{
					iSpecialistHappiness += kCity.getTechSpecialistHappiness(eTech);
					iSpecialistHappiness += kCity.getTechSpecialistHappinessTypes(eTech, eSpecialist);
				}
				if (iSpecialistHappiness > 0)
				{
					szHelpString.append(L", ");
					if (GC.getGame().getActivePlayer() != NO_PLAYER && GET_PLAYER(kCity.getOwner()).getID() != NO_PLAYER && GET_TEAM(kCity.getTeam()).isHasTech(eTech))
					{
						szHelpString.append(gDLL->getText("TXT_KEY_SPECIALIST_TECH_HAPPINESS_TYPE_KNOWN", iNumSpecialists * iSpecialistHappiness, gDLL->getSymbolID(HAPPY_CHAR), GC.getTechInfo(eTech).getTextKeyWide()));
					}
					else
					{
						szHelpString.append(gDLL->getText("TXT_KEY_SPECIALIST_TECH_HAPPINESS_TYPE", iNumSpecialists * iSpecialistHappiness, gDLL->getSymbolID(HAPPY_CHAR), GC.getTechInfo(eTech).getTextKeyWide()));
					}
				}
				else if (iSpecialistHappiness < 0)
				{
					szHelpString.append(L", ");
					if (GC.getGame().getActivePlayer() != NO_PLAYER && GET_PLAYER(kCity.getOwner()).getID() != NO_PLAYER && GET_TEAM(kCity.getTeam()).isHasTech(eTech))
					{
						szHelpString.append(gDLL->getText("TXT_KEY_SPECIALIST_TECH_HAPPINESS_TYPE_KNOWN", iNumSpecialists * -iSpecialistHappiness, gDLL->getSymbolID(UNHAPPY_CHAR), GC.getTechInfo(eTech).getTextKeyWide()));
					}
					else
					{
						szHelpString.append(gDLL->getText("TXT_KEY_SPECIALIST_TECH_HAPPINESS_TYPE", iNumSpecialists * -iSpecialistHappiness, gDLL->getSymbolID(UNHAPPY_CHAR), GC.getTechInfo(eTech).getTextKeyWide()));
					}
				}
			}
			if (GC.getSpecialistInfo(eSpecialist).getHappinessPercent() != 0)
			{
				float fValue = (float)abs(iNumSpecialists * GC.getSpecialistInfo(eSpecialist).getHappinessPercent());
				if (fmod(fValue,100) == 0)
				{
					szTempBuffer.Format(L"%.0f", fValue/100);
				}
				else if (fmod(fValue,10) == 0)
				{
					szTempBuffer.Format(L"%.1f", fValue/100);
				}
				else
				{
					szTempBuffer.Format(L"%.2f", fValue/100);
				}
				szFirstBuffer.Format(L"%s%s, ", gDLL->getText("TXT_KEY_SPECIALIST_PERCENT", szTempBuffer.GetCString(), (GC.getSpecialistInfo(eSpecialist).getHappinessPercent() > 0 ? gDLL->getSymbolID(HAPPY_CHAR) : gDLL->getSymbolID(UNHAPPY_CHAR))).c_str());
				szHelpString.append(szFirstBuffer);
			}
		}
	}
}


//
// Promotion Help
//
void CvGameTextMgr::parsePromotionHelp(CvWStringBuffer &szBuffer, PromotionTypes ePromotion, const wchar_t* pcNewline)
{
	parsePromotionHelpInternal(szBuffer, ePromotion, pcNewline, true);
}

void CvGameTextMgr::parsePromotionHelpInternal(CvWStringBuffer &szBuffer, PromotionTypes ePromotion, const wchar_t* pcNewline, bool bAccrueLines)
{
	PROFILE_FUNC();

	CvWString szText, szText2;
	CvWString szTempBuffer;
	int iI, iJ, iK;

	if (NO_PROMOTION == ePromotion)
	{
		return;
	}
	CvPromotionInfo &kPromotion = GC.getPromotionInfo(ePromotion);

	//for (iI = 0; iI < kPromotion.getNumAIWeightbyUnitCombatTypes(); iI++)
	//{
	//	if (kPromotion.getAIWeightbyUnitCombatType(iI).iModifier != 0)
	//	{
	//		szBuffer.append(pcNewline);
	//		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_TEMP_UCAIWEIGHT_TEXT", GC.getUnitCombatInfo(kPromotion.getAIWeightbyUnitCombatType(iI).eUnitCombat).getText(), kPromotion.getAIWeightbyUnitCombatType(iI).iModifier));
	//	}
	//}
	std::vector<PromotionTypes>	linePromotionsOwned;

	//	If this is not the display for the hover help on the actual promotion action button
	//	then we want to accrue stats from all implied promotions earlier in the same line into
	//	the help text
	linePromotionsOwned.push_back(ePromotion);
	if ( bAccrueLines )
	{
		//	Afflication, equipment and status promos don't accrue values from lower elements of the same line
		if ( GC.getPromotionInfo(ePromotion).getPromotionLine() != NO_PROMOTIONLINE &&
			 !GC.getPromotionInfo(ePromotion).isEquipment() &&
			 !GC.getPromotionInfo(ePromotion).isAffliction() &&
			 !GC.getPromotionInfo(ePromotion).isStatus())
		{
			for( iI = 0; iI < GC.getNumPromotionInfos(); iI++ )
			{
				if ( GC.getPromotionInfo((PromotionTypes)iI).getPromotionLine() == GC.getPromotionInfo(ePromotion).getPromotionLine() &&
					 GC.getPromotionInfo((PromotionTypes)iI).getLinePriority() < GC.getPromotionInfo(ePromotion).getLinePriority() )
				{
					linePromotionsOwned.push_back((PromotionTypes)iI);
				}
			}
		}
	}

	//TB Promotion Line Mod begin
	if (GC.getPromotionInfo(ePromotion).getPromotionLine() != NO_PROMOTIONLINE)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_LINE_TEXT", GC.getPromotionLineInfo((PromotionLineTypes)kPromotion.getPromotionLine()).getDescription()));
	}

	if (GC.getPromotionInfo(ePromotion).getLinePriority() > 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_LINE_PRIORITY",kPromotion.getLinePriority()));
	}

	//bools
	bool	bIsBlitz = false;
	bool	bIsAmphib = false;
	bool	bIsRiver = false;
	bool	bIsEnemyRoute = false;
	bool	bIsStatus = false;
	bool	bIsPrereqNormInvisible = false;
	bool	bIsNoSelfHeal = false;
	bool	bIsAlwaysHeal = false;
	bool	bIsHillsDoubleMove = false;
	bool	bIsCanMovePeaks = false;
	bool	bIsCanLeadThroughPeaks = false;
	bool	bIsAttackOnlyCitiesAdd = false;
	bool	bIsAttackOnlyCitiesSubtract = false;
	bool	bIsIgnoreNoEntryLevelAdd = false;
	bool	bIsIgnoreNoEntryLevelSubtract = false;
	bool	bIsIgnoreZoneofControlAdd = false;
	bool	bIsIgnoreZoneofControlSubtract = false;
	bool	bIsFliesToMoveAdd = false;
	bool	bIsFliesToMoveSubtract = false;
	bool	bIsZoneOfControl = false;
	bool	bIsImmuneToFirstStrikes = false;
	bool	bIsStampedeChange = false;
	bool	bIsRemoveStampede = false;
	bool	bIsOnslaughtChange = false;
	bool	bIsParalyze = false;
	bool	bIsNoSpreadonBattle = false;
	bool	bIsNoSpreadUnitProximity = false;
	bool	bIsNoSpreadUnittoCity = false;
	bool	bIsNoSpreadCitytoUnit = false;
	bool	bIsMakesDamageCold = false;
	bool	bIsMakesDamageNotCold = false;
	bool	bIsAddsColdImmunity = false;
	bool	bIsRemovesColdImmunity = false;
	bool	bIsCritical = false;
	bool	bIsDefensiveVictoryMove = false;
	bool	bIsFreeDrop = false;
	bool	bIsOffensiveVictoryMove = false;
	bool	bIsOneUp = false;
	bool	bIsPillageCulture = false;
	bool	bIsPillageEspionage = false;
	bool	bIsPillageMarauder = false;
	bool	bIsPillageOnMove = false;
	bool	bIsPillageOnVictory = false;
	bool	bIsPillageResearch = false;

	for( iI = 0; iI < (int)linePromotionsOwned.size(); iI++ )
	{
		if ( GC.getPromotionInfo(linePromotionsOwned[iI]).isBlitz() )
		{
			bIsBlitz = true;
		}
		if ( GC.getPromotionInfo(linePromotionsOwned[iI]).isAmphib() )
		{
			bIsAmphib = true;
		}
		if ( GC.getPromotionInfo(linePromotionsOwned[iI]).isRiver() )
		{
			bIsRiver = true;
		}
		if ( GC.getPromotionInfo(linePromotionsOwned[iI]).isEnemyRoute() )
		{
			bIsEnemyRoute = true;
		}
		if ( GC.getPromotionInfo(linePromotionsOwned[iI]).isStatus() )
		{
			bIsStatus = true;
		}
		if (GC.getPromotionInfo(linePromotionsOwned[iI]).isPrereqNormInvisible())
		{
			bIsPrereqNormInvisible = true;
		}
		if ( GC.getPromotionInfo(linePromotionsOwned[iI]).isNoSelfHeal() )
		{
			bIsNoSelfHeal = true;
		}
		if ( GC.getPromotionInfo(linePromotionsOwned[iI]).isAlwaysHeal() )
		{
			bIsAlwaysHeal = true;
		}
		if ( GC.getPromotionInfo(linePromotionsOwned[iI]).isHillsDoubleMove() )
		{
			bIsHillsDoubleMove = true;
		}
		if ( GC.getPromotionInfo(linePromotionsOwned[iI]).isCanMovePeaks() )
		{
			bIsCanMovePeaks = true;
		}
		if ( GC.getPromotionInfo(linePromotionsOwned[iI]).isCanLeadThroughPeaks() )
		{
			bIsCanLeadThroughPeaks = true;
		}
		if ( GC.getPromotionInfo(linePromotionsOwned[iI]).isAttackOnlyCitiesAdd() )
		{
			bIsAttackOnlyCitiesAdd = true;
		}
		if ( GC.getPromotionInfo(linePromotionsOwned[iI]).isAttackOnlyCitiesSubtract() )
		{
			bIsAttackOnlyCitiesSubtract = true;
		}
		if ( GC.getPromotionInfo(linePromotionsOwned[iI]).isIgnoreNoEntryLevelAdd() )
		{
			bIsIgnoreNoEntryLevelAdd = true;
		}
		if ( GC.getPromotionInfo(linePromotionsOwned[iI]).isIgnoreNoEntryLevelSubtract() )
		{
			bIsIgnoreNoEntryLevelSubtract = true;
		}
		if (GC.getGame().isOption(GAMEOPTION_ZONE_OF_CONTROL))
		{
			if (GC.getPromotionInfo(linePromotionsOwned[iI]).isIgnoreZoneofControlAdd())
			{
				bIsIgnoreZoneofControlAdd = true;
			}
			if (GC.getPromotionInfo(linePromotionsOwned[iI]).isIgnoreZoneofControlSubtract())
			{
				bIsIgnoreZoneofControlSubtract = true;
			}
			if (GC.getPromotionInfo(linePromotionsOwned[iI]).isZoneOfControl())
			{
				bIsZoneOfControl = true;
			}
		}
		if ( GC.getPromotionInfo(linePromotionsOwned[iI]).isFliesToMoveAdd() )
		{
			bIsFliesToMoveAdd = true;
		}
		if ( GC.getPromotionInfo(linePromotionsOwned[iI]).isFliesToMoveSubtract() )
		{
			bIsFliesToMoveSubtract = true;
		}
		if ( GC.getPromotionInfo(linePromotionsOwned[iI]).isImmuneToFirstStrikes() )
		{
			bIsImmuneToFirstStrikes = true;
		}
		if ( GC.getPromotionInfo(linePromotionsOwned[iI]).isStampedeChange() )
		{
			bIsStampedeChange = true;
		}
		if ( GC.getPromotionInfo(linePromotionsOwned[iI]).isRemoveStampede() )
		{
			bIsRemoveStampede = true;
		}
		if ( GC.getPromotionInfo(linePromotionsOwned[iI]).isOnslaughtChange() )
		{
			bIsOnslaughtChange = true;
		}
		if ( GC.getPromotionInfo(linePromotionsOwned[iI]).isParalyze() )
		{
			bIsParalyze = true;
		}
		if ( GC.getPromotionInfo(linePromotionsOwned[iI]).isMakesDamageCold() )
		{
			bIsMakesDamageCold = true;
		}
		if ( GC.getPromotionInfo(linePromotionsOwned[iI]).isMakesDamageNotCold() )
		{
			bIsMakesDamageNotCold = true;
		}
		if ( GC.getPromotionInfo(linePromotionsOwned[iI]).isAddsColdImmunity() )
		{
			bIsAddsColdImmunity = true;
		}
		if ( GC.getPromotionInfo(linePromotionsOwned[iI]).isRemovesColdImmunity() )
		{
			bIsRemovesColdImmunity = true;
		}
		if ( GC.getPromotionInfo(linePromotionsOwned[iI]).isCritical() )
		{
			bIsCritical = true;
		}
		if ( GC.getPromotionInfo(linePromotionsOwned[iI]).isDefensiveVictoryMove() )
		{
			bIsDefensiveVictoryMove = true;
		}
		if ( GC.getPromotionInfo(linePromotionsOwned[iI]).isFreeDrop() )
		{
			bIsFreeDrop = true;
		}
		if ( GC.getPromotionInfo(linePromotionsOwned[iI]).isOffensiveVictoryMove() )
		{
			bIsOffensiveVictoryMove = true;
		}
		if ( GC.getPromotionInfo(linePromotionsOwned[iI]).isOneUp() )
		{
			bIsOneUp = true;
		}
		if ( GC.getPromotionInfo(linePromotionsOwned[iI]).isPillageCulture() )
		{
			bIsPillageCulture = true;
		}
		if ( GC.getPromotionInfo(linePromotionsOwned[iI]).isPillageEspionage() )
		{
			bIsPillageEspionage = true;
		}
		if ( GC.getPromotionInfo(linePromotionsOwned[iI]).isPillageMarauder() )
		{
			bIsPillageMarauder = true;
		}
		if ( GC.getPromotionInfo(linePromotionsOwned[iI]).isPillageOnMove() )
		{
			bIsPillageOnMove = true;
		}
		if ( GC.getPromotionInfo(linePromotionsOwned[iI]).isPillageOnVictory() )
		{
			bIsPillageOnVictory = true;
		}
		if ( GC.getPromotionInfo(linePromotionsOwned[iI]).isPillageResearch() )
		{
			bIsPillageResearch = true;
		}
		if (GC.getPromotionInfo(linePromotionsOwned[iI]).getPromotionLine() != NO_PROMOTIONLINE)
		{
			if ( GC.getPromotionLineInfo(GC.getPromotionInfo(linePromotionsOwned[iI]).getPromotionLine()).isNoSpreadonBattle() )
			{
				bIsNoSpreadonBattle = true;
			}
			if ( GC.getPromotionLineInfo(GC.getPromotionInfo(linePromotionsOwned[iI]).getPromotionLine()).isNoSpreadUnitProximity() )
			{
				bIsNoSpreadUnitProximity = true;
			}
			if ( GC.getPromotionLineInfo(GC.getPromotionInfo(linePromotionsOwned[iI]).getPromotionLine()).isNoSpreadUnittoCity() )
			{
				bIsNoSpreadUnittoCity = true;
			}
			if ( GC.getPromotionLineInfo(GC.getPromotionInfo(linePromotionsOwned[iI]).getPromotionLine()).isNoSpreadCitytoUnit() )
			{
				bIsNoSpreadCitytoUnit = true;
			}
		}
	}
	if (bIsBlitz)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_BLITZ_TEXT"));
	}
	if (bIsAmphib)
	{
		//TSHEEP Display Spy Messages Differently
		if(GC.getPromotionInfo(ePromotion).getSound()[5] == 'P')
		{
			szBuffer.append(pcNewline);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_RADIATION_TEXT_SPY"));
		}
		else
		{
			szBuffer.append(pcNewline);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_AMPHIB_TEXT"));
		}
		//szBuffer.append(pcNewline);
		//szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_AMPHIB_TEXT"));
		//TSHEEP End
	}
	if (bIsRiver)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_RIVER_ATTACK_TEXT"));
	}
	if (bIsEnemyRoute)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_ENEMY_ROADS_TEXT"));
	}
	if (bIsStatus)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_STATUS_TEXT"));
	}
	if (bIsNoSelfHeal)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_SELF_HEAL_NONE"));
	}
	if (bIsAlwaysHeal)
	{
		//TSHEEP Display Spy Messages Differently
		if(GC.getPromotionInfo(ePromotion).getSound()[5] == 'P')
		{
			szBuffer.append(pcNewline);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_LOYALTY_TEXT_SPY"));
		}
		else
		{
			szBuffer.append(pcNewline);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_ALWAYS_HEAL_TEXT"));
		}
		//szBuffer.append(pcNewline);
		//szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_ALWAYS_HEAL_TEXT"));
		//TSHEEP End
	}
	if (bIsHillsDoubleMove)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_HILLS_MOVE_TEXT"));
	}
	if (bIsCanMovePeaks)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_CAN_MOVE_PEAKS_TEXT"));
	}
	//	Koshling - enhanced mountaineering mode to differentiate between ability to move through
	//	mountains, and ability to lead a stack through mountains
	if (bIsCanLeadThroughPeaks)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_CAN_LEAD_THROUGH_PEAKS_TEXT"));
	}
	if (bIsAttackOnlyCitiesAdd)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_ATTACK_ONLY_CITIES_ADD"));
	}
	if (bIsAttackOnlyCitiesSubtract)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_ATTACK_ONLY_CITIES_SUBTRACT"));
	}
	if (bIsIgnoreNoEntryLevelAdd)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_IGNORE_NO_ENTRY_LEVEL_ADD"));
	}
	if (bIsIgnoreNoEntryLevelSubtract)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_IGNORE_NO_ENTRY_LEVEL_SUBTRACT"));
	}
	if (bIsIgnoreZoneofControlAdd)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_IGNORE_ZONE_OF_CONTROL_ADD"));
	}
	if (bIsIgnoreZoneofControlSubtract)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_IGNORE_ZONE_OF_CONTROL_SUBTRACT"));
	}
	if (bIsZoneOfControl)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_ZONE_OF_CONTROL"));
	}
	if (bIsFliesToMoveAdd)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_FLIES_TO_MOVE_ADD"));
	}
	if (bIsFliesToMoveSubtract)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_FLIES_TO_MOVE_SUBTRACT"));
	}
	if (bIsStampedeChange)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_STAMPEDE_TEXT"));
	}
	if (bIsRemoveStampede)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_REMOVE_STAMPEDE_TEXT"));
	}
	if (bIsOnslaughtChange)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_ONSLAUGHT_TEXT"));
	}
	if (bIsParalyze)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_PARALYZE_TEXT"));
	}
	if (bIsNoSpreadonBattle)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_NO_SPREAD_ON_BATTLE_TEXT"));
	}
	if (bIsNoSpreadUnitProximity)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_NO_SPREAD_UNIT_PROXIMITY_TEXT"));
	}
	if (bIsNoSpreadUnittoCity)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_NO_SPREAD_UNIT_TO_CITY_TEXT"));
	}
	if (bIsNoSpreadCitytoUnit)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_NO_SPREAD_CITY_TO_UNIT_TEXT"));
	}
	if (bIsMakesDamageCold)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_MAKES_DAMAGE_COLD_TEXT"));
	}
	if (bIsMakesDamageNotCold)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_MAKES_DAMAGE_NOT_COLD_TEXT"));
	}
	if (bIsAddsColdImmunity)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_ADDS_COLD_IMMUNITY_TEXT"));
	}
	if (bIsRemovesColdImmunity)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_REMOVES_COLD_IMMUNITY_TEXT"));
	}
	if (bIsCritical)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_CRITICAL_TEXT"));
	}
	if (bIsDefensiveVictoryMove)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_DV_MOVE_TEXT"));
	}
	if (bIsFreeDrop)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_FREE_DROP_TEXT"));
	}
	if (bIsOffensiveVictoryMove)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_OV_MOVE_TEXT"));
	}
	if (bIsOneUp)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_ONEUP_TEXT"));
	}
	if (bIsPillageCulture)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_CULTURE_PILLAGE_TEXT"));
	}
	if (bIsPillageEspionage)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_ESPIONAGE_PILLAGE_TEXT"));
	}
	if (bIsPillageMarauder)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_MARAUDER_PILLAGE_TEXT"));
	}
	if (bIsPillageOnMove)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_MOVING_PILLAGE_TEXT"));
	}
	if (bIsPillageOnVictory)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_VICTORY_PILLAGE_TEXT"));
	}
	if (bIsPillageResearch)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_RESEARCH_PILLAGE_TEXT"));
	}
	if (bIsPrereqNormInvisible)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_PREREQ_NORM_INVISIBLE_TEXT"));
	}



	//independant bools
	if (GC.getPromotionInfo(ePromotion).isEquipment())
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_EQUIPMENT_TEXT"));
	}

	if (GC.getPromotionInfo(ePromotion).isAffliction())
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_AFFLICTION_TEXT"));
	}


	//int
	int	iGetControlPoints = 0;
	int	iGetCommandRange = 0;
	int	iExcileChange = 0;
	int	iPassageChange = 0;
	int	iNoNonOwnedCityEntryChange = 0;
	int	iBarbCoExistChange = 0;
	int	iBlendIntoCityChange = 0;
	int	iUpgradeAnywhereChange = 0;
	int	iMovesChange = 0;
	int	iMoveDiscountChange = 0;
	int	iAirRangeChange = 0;
	int	iInterceptChange = 0;
	int	iEvasionChange = 0;
	int	iWithdrawalChange = 0;
	int	iAttackCombatModifierChange = 0;
	int	iDefenseCombatModifierChange = 0;
	int	iCombatModifierPerSizeMore = 0;
	int	iCombatModifierPerSizeLess = 0;
	int	iCombatModifierPerVolumeMore = 0;
	int	iCombatModifierPerVolumeLess = 0;
	int	iPursuitChange = 0;
	int	iEarlyWithdrawChange = 0;
	int	iVSBarbsChange = 0;
	int	iReligiousCombatModifierChange = 0;
	int	iArmorChange = 0;
	int	iPunctureChange = 0;
	int	iDamageModifierChange = 0;
	int iUpkeepModifier = 0;
	int iExtraUpkeep100 = 0;
	int	iOverrunChange = 0;
	int	iRepelChange = 0;
	int	iFortRepelChange = 0;
	int	iRepelRetriesChange = 0;
	int	iUnyieldingChange = 0;
	int	iKnockbackChange = 0;
	int	iKnockbackRetriesChange = 0;
	int	iRoundStunProbChange = 0;
	int	iPoisonProbabilityModifierChange = 0;
	int	iStrAdjperRndChange = 0;
	int	iStrAdjperAttChange = 0;
	int	iStrAdjperDefChange = 0;
	int	iWithdrawAdjperAttChange = 0;
	int	iUnnerveChange = 0;
	int	iEncloseChange = 0;
	int	iLungeChange = 0;
	int	iDynamicDefenseChange = 0;
	int	iStrengthChange = 0;
	int	iOvercomeProbability = 0;
	int	iOvercomeAdjperTurn = 0;
	int	iFortitudeChange = 0;
	int	iDamageperTurn = 0;
	int	iStrAdjperTurn = 0;
	int	iWeakenperTurn = 0;
	int	iCommunicability = 0;
	int iWorseningProbability = 0;
	int	iToleranceBuildup = 0;
	int	iToleranceDecay = 0;
	int	iFrontSupportPercentChange = 0;
	int	iShortRangeSupportPercentChange = 0;
	int	iMediumRangeSupportPercentChange = 0;
	int	iLongRangeSupportPercentChange = 0;
	int	iFlankSupportPercentChange = 0;
	int	iDodgeModifierChange = 0;
	int	iPrecisionModifierChange = 0;
	int	iPowerShotsChange = 0;
	int	iPowerShotCombatModifierChange = 0;
	int	iPowerShotPunctureModifierChange = 0;
	int	iPowerShotPrecisionModifierChange = 0;
	int	iPowerShotCriticalModifierChange = 0;
	int	iCriticalModifierChange = 0;
	int	iEnduranceChange = 0;
	int	iInsidiousnessChange = 0;
	int	iInvestigationChange = 0;
	int	iAssassinChange = 0;
	int	iStealthStrikesChange = 0;
	int	iStealthCombatModifierChange = 0;
	int	iStealthDefenseChange = 0;
	int	iDefenseOnlyChange = 0;
	int	iNoInvisibilityChange = 0;
	int	iTrapDamageMin = 0;
	int	iTrapDamageMax = 0;
	int	iTrapComplexity = 0;
	int	iTrapNumTriggers = 0;
	int	iTrapTriggerBeforeAttackChange = 0;
	int	iVisibilityChange = 0;
	int	iCaptureProbabilityModifierChange = 0;
	int	iCaptureResistanceModifierChange = 0;
	int	iBreakdownChanceChange = 0;
	int	iBreakdownDamageChange = 0;
	int	iTauntChange = 0;
	int	iMaxHPChange = 0;
	int	iStrengthModifier = 0;
	int	iAirCombatLimitChange = 0;
	int	iCelebrityHappy = 0;
	int	iCollateralDamageLimitChange = 0;
	int	iCollateralDamageMaxUnitsChange = 0;
	int	iCombatLimitChange = 0;
	int	iExtraDropRange = 0;
	int	iSurvivorChance = 0;
	int	iSelfHealModifier = 0;
	int	iHealSupport = 0;
	int	iVictoryAdjacentHeal = 0;
	int	iVictoryHeal = 0;
	int	iVictoryStackHeal = 0;
	int	iCargoChange = 0;
	int	iCollateralDamageChange = 0;
	int	iBombardRateChange = 0;
	int	iDCMBombRangeChange = 0;
	int	iDCMBombAccuracyChange = 0;
	int	iRBombardDamageChange = 0;
	int	iRBombardDamageLimitChange = 0;
	int	iRBombardDamageMaxUnitsChange = 0;
	int	iFirstStrikesChange = 0;
	int	iChanceFirstStrikesChange = 0;
	int	iEnemyHealChange = 0;
	int	iNeutralHealChange = 0;
	int	iFriendlyHealChange = 0;
	int	iSameTileHealChange = 0;
	int	iAdjacentTileHealChange = 0;
	int	iCombatPercent = 0;
	int	iCityAttackPercent = 0;
	int	iCityDefensePercent = 0;
	int	iHillsAttackPercent = 0;
	int	iHillsDefensePercent = 0;
	int iWorkRate = 0;
	int iHillsWorkPercent = 0;
	int iPeaksWorkPercent = 0;
	int	iRevoltProtection = 0;
	int	iCollateralDamageProtection = 0;
	int	iPillageChange = 0;
	int	iUpgradeDiscount = 0;
	int	iExperiencePercent = 0;
	int	iKamikazePercent = 0;
	int iHiddenNationality = 0;
	int	iIsAnimalIgnoresBordersChange = 0;
	int iNoDefensiveBonusChange = 0;


	for (iI = 0; iI < (int)linePromotionsOwned.size(); iI++)
	{
		const CvPromotionInfo& promo = GC.getPromotionInfo(linePromotionsOwned[iI]);

		iGetControlPoints += promo.getControlPoints();
		iGetCommandRange += promo.getCommandRange();
		iExcileChange += promo.getExcileChange();
		iPassageChange += promo.getPassageChange();
		iNoNonOwnedCityEntryChange += promo.getNoNonOwnedCityEntryChange();
		iBarbCoExistChange += promo.getBarbCoExistChange();
		iBlendIntoCityChange += promo.getBlendIntoCityChange();
		iUpgradeAnywhereChange += promo.getUpgradeAnywhereChange();
		iMovesChange += promo.getMovesChange();
		iMoveDiscountChange += promo.getMoveDiscountChange();
		iAirRangeChange += promo.getAirRangeChange();
		iInterceptChange += promo.getInterceptChange();
		iEvasionChange += promo.getEvasionChange();
		iWithdrawalChange += promo.getWithdrawalChange();
		iAttackCombatModifierChange += promo.getAttackCombatModifierChange();
		iDefenseCombatModifierChange += promo.getDefenseCombatModifierChange();
		iCombatModifierPerSizeMore += promo.getCombatModifierPerSizeMoreChange();
		iCombatModifierPerSizeLess += promo.getCombatModifierPerSizeLessChange();
		iCombatModifierPerVolumeMore += promo.getCombatModifierPerVolumeMoreChange();
		iCombatModifierPerVolumeLess += promo.getCombatModifierPerVolumeLessChange();
		iPursuitChange += promo.getPursuitChange();
		iEarlyWithdrawChange += promo.getEarlyWithdrawChange();
		iVSBarbsChange += promo.getVSBarbsChange();
		iReligiousCombatModifierChange += promo.getReligiousCombatModifierChange();
		iArmorChange += promo.getArmorChange();
		iPunctureChange += promo.getPunctureChange();
		iDamageModifierChange += promo.getDamageModifierChange();
		iUpkeepModifier += promo.getUpkeepModifier();
		iExtraUpkeep100 += promo.getExtraUpkeep100();
		iOverrunChange += promo.getOverrunChange();
		iRepelChange += promo.getRepelChange();
		iFortRepelChange += promo.getFortRepelChange();
		iRepelRetriesChange += promo.getRepelRetriesChange();
		iUnyieldingChange += promo.getUnyieldingChange();
		iKnockbackChange += promo.getKnockbackChange();
		iKnockbackRetriesChange += promo.getKnockbackRetriesChange();
		iRoundStunProbChange += promo.getRoundStunProbChange();
		iPoisonProbabilityModifierChange += promo.getPoisonProbabilityModifierChange();
		iStrAdjperRndChange += promo.getStrAdjperRndChange();
		iStrAdjperAttChange += promo.getStrAdjperAttChange();
		iStrAdjperDefChange += promo.getStrAdjperDefChange();
		iWithdrawAdjperAttChange += promo.getWithdrawAdjperAttChange();
		if (GC.getGame().isOption(GAMEOPTION_SAD))
		{
			iUnnerveChange += promo.getUnnerveChange();
			iEncloseChange += promo.getEncloseChange();
			iLungeChange += promo.getLungeChange();
			iDynamicDefenseChange += promo.getDynamicDefenseChange();
		}
		iStrengthChange += promo.getStrengthChange();
		iFortitudeChange += promo.getFortitudeChange();
		iDamageperTurn += promo.getDamageperTurn();
		iStrAdjperTurn += promo.getStrAdjperTurn();
		iWeakenperTurn += promo.getWeakenperTurn();
		if (GC.getGame().isOption(GAMEOPTION_STRENGTH_IN_NUMBERS))
		{
			iFrontSupportPercentChange += promo.getFrontSupportPercentChange();
			iShortRangeSupportPercentChange += promo.getShortRangeSupportPercentChange();
			iMediumRangeSupportPercentChange += promo.getMediumRangeSupportPercentChange();
			iLongRangeSupportPercentChange += promo.getLongRangeSupportPercentChange();
			iFlankSupportPercentChange += promo.getFlankSupportPercentChange();
		}
		iDodgeModifierChange += promo.getDodgeModifierChange();
		iPrecisionModifierChange += promo.getPrecisionModifierChange();
		iPowerShotsChange += promo.getPowerShotsChange();
		iPowerShotCombatModifierChange += promo.getPowerShotCombatModifierChange();
		iPowerShotPunctureModifierChange += promo.getPowerShotPunctureModifierChange();
		iPowerShotPrecisionModifierChange += promo.getPowerShotPrecisionModifierChange();
		iPowerShotCriticalModifierChange += promo.getPowerShotCriticalModifierChange();
		iCriticalModifierChange += promo.getCriticalModifierChange();
		iEnduranceChange += promo.getEnduranceChange();
		iInsidiousnessChange += promo.getInsidiousnessChange();
		iInvestigationChange += promo.getInvestigationChange();
		iAssassinChange += promo.getAssassinChange();
		iStealthStrikesChange += promo.getStealthStrikesChange();
		iStealthCombatModifierChange += promo.getStealthCombatModifierChange();
		iStealthDefenseChange += promo.getStealthDefenseChange();
		iDefenseOnlyChange += promo.getDefenseOnlyChange();
		if (GC.getGame().isOption(GAMEOPTION_HIDE_AND_SEEK))
		{
			iNoInvisibilityChange += promo.getNoInvisibilityChange();
		}
		iTrapDamageMin += promo.getTrapDamageMin();
		iTrapDamageMax += promo.getTrapDamageMax();
		iTrapComplexity += promo.getTrapComplexity();
		iTrapNumTriggers += promo.getNumTriggers();
		iTrapTriggerBeforeAttackChange += promo.getTriggerBeforeAttackChange();
		iVisibilityChange += promo.getVisibilityChange();
		iCaptureProbabilityModifierChange += promo.getCaptureProbabilityModifierChange();
		iCaptureResistanceModifierChange += promo.getCaptureResistanceModifierChange();
		iBreakdownChanceChange += promo.getBreakdownChanceChange();
		iBreakdownDamageChange += promo.getBreakdownDamageChange();
		iTauntChange += promo.getTauntChange();
		iMaxHPChange += promo.getMaxHPChange();
		iStrengthModifier += promo.getStrengthModifier();
		iAirCombatLimitChange += promo.getAirCombatLimitChange();
		iCelebrityHappy += promo.getCelebrityHappy();
		iCollateralDamageLimitChange += promo.getCollateralDamageLimitChange();
		iCollateralDamageMaxUnitsChange += promo.getCollateralDamageMaxUnitsChange();
		iCombatLimitChange += promo.getCombatLimitChange();
		iExtraDropRange += promo.getExtraDropRange();
		iSurvivorChance += promo.getSurvivorChance();
		iSelfHealModifier += promo.getSelfHealModifier();
		iHealSupport += promo.getNumHealSupport();
		iVictoryAdjacentHeal += promo.getVictoryAdjacentHeal();
		iVictoryHeal += promo.getVictoryHeal();
		iVictoryStackHeal += promo.getVictoryStackHeal();
		iCargoChange += promo.getCargoChange();
		iCollateralDamageChange += promo.getCollateralDamageChange();
		iBombardRateChange += promo.getBombardRateChange();
		if(GC.isDCM_RANGE_BOMBARD())
		{
			iDCMBombRangeChange += promo.getDCMBombRangeChange();
			iDCMBombAccuracyChange += promo.getDCMBombAccuracyChange();
			iRBombardDamageChange += promo.getRBombardDamageChange();
			iRBombardDamageLimitChange += promo.getRBombardDamageLimitChange();
			iRBombardDamageMaxUnitsChange += promo.getRBombardDamageMaxUnitsChange();
		}
		iFirstStrikesChange += promo.getFirstStrikesChange();
		iChanceFirstStrikesChange += promo.getChanceFirstStrikesChange();
		iEnemyHealChange += promo.getEnemyHealChange();
		iNeutralHealChange += promo.getNeutralHealChange();
		iFriendlyHealChange += promo.getFriendlyHealChange();
		iSameTileHealChange += promo.getSameTileHealChange();
		iAdjacentTileHealChange += promo.getAdjacentTileHealChange();
		iCombatPercent += promo.getCombatPercent();
		iCityAttackPercent += promo.getCityAttackPercent();
		iCityDefensePercent += promo.getCityDefensePercent();
		iHillsAttackPercent += promo.getHillsAttackPercent();
		iHillsDefensePercent += promo.getHillsDefensePercent();
		iWorkRate += promo.getWorkRatePercent();
		iHillsWorkPercent += promo.getHillsWorkPercent();
		iHillsWorkPercent += promo.getHillsWorkModifierChange();
		iPeaksWorkPercent += promo.getPeaksWorkModifierChange();
		iRevoltProtection += promo.getRevoltProtection();
		iCollateralDamageProtection += promo.getCollateralDamageProtection();
		iPillageChange += promo.getPillageChange();
		iUpgradeDiscount += promo.getUpgradeDiscount();
		iExperiencePercent += promo.getExperiencePercent();
		iKamikazePercent += promo.getKamikazePercent();
		if (GC.getGame().isOption(GAMEOPTION_OUTBREAKS_AND_AFFLICTIONS))
		{
			if (promo.getPromotionLine() != NO_PROMOTIONLINE)
			{
				iOvercomeProbability += GC.getPromotionLineInfo(promo.getPromotionLine()).getOvercomeProbability();
				iOvercomeProbability += (GC.getPromotionLineInfo(promo.getPromotionLine()).getWorsenedOvercomeIncrementModifier() * (promo.getLinePriority() - 1));
				iOvercomeAdjperTurn += GC.getPromotionLineInfo(promo.getPromotionLine()).getOvercomeAdjperTurn();
				iCommunicability += GC.getPromotionLineInfo(promo.getPromotionLine()).getCommunicability();
				iCommunicability += ((promo.getLinePriority() - 1) * GC.getPromotionLineInfo(promo.getPromotionLine()).getWorsenedCommunicabilityIncrementModifier());
				iWorseningProbability += ((promo.getLinePriority() -1) * GC.getPromotionLineInfo(promo.getPromotionLine()).getWorseningProbabilityIncrementModifier());
				iToleranceBuildup += GC.getPromotionLineInfo(promo.getPromotionLine()).getToleranceBuildup();
				iToleranceDecay += GC.getPromotionLineInfo(promo.getPromotionLine()).getToleranceDecay();
			}
		}
		iHiddenNationality += promo.getHiddenNationalityChange();
		iIsAnimalIgnoresBordersChange += promo.getAnimalIgnoresBordersChange();
		iNoDefensiveBonusChange += promo.getNoDefensiveBonusChange();
	}

	if (iGetControlPoints > 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_CONTROL_POINTS_TEXT", iGetControlPoints));
	}
	if (iGetCommandRange > 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_COMMAND_RANGE_TEXT", iGetCommandRange));
	}
	if (iExcileChange > 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_EXCILE_ADD_TEXT"));
	}
	if (iExcileChange < 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_EXCILE_REMOVE_TEXT"));
	}
	if (iPassageChange > 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_PASSAGE_ADD_TEXT"));
	}
	if (iPassageChange < 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_PASSAGE_REMOVE_TEXT"));
	}
	if (iNoNonOwnedCityEntryChange > 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_NONONOWNED_ADD_TEXT"));
	}
	if (iNoNonOwnedCityEntryChange < 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_NONONOWNED_REMOVE_TEXT"));
	}
	if (iBarbCoExistChange > 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_BARBCOEXIST_ADD_TEXT"));
	}
	if (iBarbCoExistChange < 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_BARBCOEXIST_REMOVE_TEXT"));
	}
	if (iBlendIntoCityChange > 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_BLENDCITY_ADD_TEXT"));
	}
	if (iBlendIntoCityChange < 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_BLENDCITY_REMOVE_TEXT"));
	}
	if (iUpgradeAnywhereChange > 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_UPGRADEANYWHERE_ADD_TEXT"));
	}
	if (iUpgradeAnywhereChange < 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_UPGRADEANYWHERE_REMOVE_TEXT"));
	}
	if (iMovesChange != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_MOVE_TEXT", iMovesChange));
	}
	if (iMoveDiscountChange != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_MOVE_DISCOUNT_TEXT", -iMoveDiscountChange));
	}
	if (iAirRangeChange != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_AIR_RANGE_TEXT", iAirRangeChange));
	}
	if (iInterceptChange != 0)
	{
		//TSHEEP Display Spy Promotions Differently
		if(GC.getPromotionInfo(ePromotion).getSound()[5] == 'P')
		{
			szBuffer.append(pcNewline);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_INTERCEPT_TEXT_SPY", iInterceptChange));
			szBuffer.append(pcNewline);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_INTERCEPT_TEXT_SPY_COUNTER", iInterceptChange * 5));
		}
		else
		{
			szBuffer.append(pcNewline);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_INTERCEPT_TEXT", iInterceptChange));
		}
		//szBuffer.append(pcNewline);
		//szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_INTERCEPT_TEXT", GC.getPromotionInfo(ePromotion).getInterceptChange()));
		//TSHEEP End
	}
	if (iEvasionChange != 0)
	{
		//TSHEEP Display Spy Promotions Differently
		if(GC.getPromotionInfo(ePromotion).getSound()[5] == 'P')
		{
			szBuffer.append(pcNewline);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_EVASION_TEXT_SPY", iEvasionChange));
		}
		else
		{
			szBuffer.append(pcNewline);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_EVASION_TEXT", iEvasionChange));
		}
		//szBuffer.append(pcNewline);
		//szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_EVASION_TEXT", GC.getPromotionInfo(ePromotion).getEvasionChange()));
		//TSHEEP End
	}
	if (iWithdrawalChange != 0)
	{
		//TSHEEP Display Spy Promotions Differently
		if(GC.getPromotionInfo(ePromotion).getSound()[5] == 'P')
		{
			szBuffer.append(pcNewline);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_ESCAPE_TEXT_SPY", iWithdrawalChange));
		}
		else
		{
			szBuffer.append(pcNewline);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_WITHDRAWAL_TEXT", iWithdrawalChange));
		}
		//szBuffer.append(pcNewline);
		//szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_WITHDRAWAL_TEXT", GC.getPromotionInfo(ePromotion).getWithdrawalChange()));
		//TSHEEP End
	}
	if (iAttackCombatModifierChange != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_ATTACK_MODIFIER_TEXT", iAttackCombatModifierChange));
	}
	if (iDefenseCombatModifierChange != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_DEFENSE_MODIFIER_TEXT", iDefenseCombatModifierChange));
	}
	if (iCombatModifierPerSizeMore != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_UNIT_COMBAT_MOD_PER_SIZE_MORE", iCombatModifierPerSizeMore));
	}
	if (iCombatModifierPerSizeLess != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_UNIT_COMBAT_MOD_PER_SIZE_LESS", iCombatModifierPerSizeLess));
	}
	if (iCombatModifierPerVolumeMore != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_UNIT_COMBAT_MOD_PER_VOLUME_MORE", iCombatModifierPerVolumeMore));
	}
	if (iCombatModifierPerVolumeLess != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_UNIT_COMBAT_MOD_PER_VOLUME_LESS", iCombatModifierPerVolumeLess));
	}
	if (iPursuitChange != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_PURSUIT_TEXT", iPursuitChange));
	}
	if (iEarlyWithdrawChange != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_EARLY_WITHDRAW_TEXT", iEarlyWithdrawChange));
	}
	if (iVSBarbsChange != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_VSBARBS_TEXT", iVSBarbsChange));
	}
	if (iReligiousCombatModifierChange != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_UNIT_RELIGIOUS_COMBAT_MODIFIER_SHORT", iReligiousCombatModifierChange));
	}
	if (iArmorChange != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_ARMOR_TEXT", iArmorChange));
	}
	if (iPunctureChange != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_PUNCTURE_TEXT", iPunctureChange));
	}
	if (iDamageModifierChange != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_DAMAGE_MODIFIER_TEXT", iDamageModifierChange));
	}
	if (iUpkeepModifier != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_HELPTEXT_UNIT_UPKEEP_MODIFIER_BASE", iUpkeepModifier));
	}
	if (iExtraUpkeep100 != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_HELPTEXT_UNIT_UPKEEP_EXTRA", CvWString::format(L"%.2f", iExtraUpkeep100 / 100.0).GetCString()));
	}
	if (iOverrunChange != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_OVERRUN_TEXT", iOverrunChange));
	}
	if (iRepelChange != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_REPEL_TEXT", iRepelChange));
	}
	if (iFortRepelChange != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_FORT_REPEL_TEXT", iFortRepelChange));
	}
	if (iRepelRetriesChange != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_REPEL_RETRIES_TEXT", iRepelRetriesChange));
	}
	if (iUnyieldingChange != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_UNYIELDING_TEXT", iUnyieldingChange));
	}
	if (iKnockbackChange != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_KNOCKBACK_TEXT", iKnockbackChange));
	}
	if (iKnockbackRetriesChange != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_KNOCKBACK_RETRIES_TEXT", iKnockbackRetriesChange));
	}
	if (iRoundStunProbChange != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_ROUND_STUN_PROB_TEXT", iRoundStunProbChange));
	}
	if (iPoisonProbabilityModifierChange != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_POISON_PROB_TEXT", iPoisonProbabilityModifierChange));
	}
	if (iStrAdjperRndChange > 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_RAGE_TEXT", iStrAdjperRndChange));
	}
	else if (iStrAdjperRndChange < 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_FATIGUE_TEXT", iStrAdjperRndChange));
	}
	if (iStrAdjperAttChange > 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_RAMPAGE_TEXT", iStrAdjperAttChange));
	}
	else if (iStrAdjperAttChange < 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_TIRES_TEXT", iStrAdjperAttChange));
	}
	if (iStrAdjperDefChange > 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_DETERMINATION_TEXT", iStrAdjperDefChange));
	}
	else if (iStrAdjperDefChange < 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_DEMORALIZATION_TEXT", iStrAdjperDefChange));
	}
	if (iWithdrawAdjperAttChange > 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_REFLEXES_TEXT", iWithdrawAdjperAttChange));
	}
	else if (iWithdrawAdjperAttChange < 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_FRAYS_TEXT", iWithdrawAdjperAttChange));
	}
	if (iUnnerveChange != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_UNNERVE_TEXT", iUnnerveChange));
	}
	if (iEncloseChange != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_ENCLOSE_TEXT", iEncloseChange));
	}
	if (iLungeChange != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_LUNGE_TEXT", iLungeChange));
	}
	if (iDynamicDefenseChange != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_DYNAMIC_DEFENSE_TEXT", iDynamicDefenseChange));
	}
	if (iStrengthChange > 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_STRENGTHEN_TEXT", iStrengthChange));
	}
	else if (iStrengthChange < 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_WEAKEN_TEXT", iStrengthChange));
	}
	if (iOvercomeProbability != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_OVERCOME_PROBABILITY_TEXT", iOvercomeProbability));
	}
	if (iOvercomeAdjperTurn > 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_WEAROFF_TEXT", iOvercomeAdjperTurn));
	}
	else if (iOvercomeAdjperTurn < 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_INTENSIFIES_TEXT", iOvercomeAdjperTurn));
	}
	if (iFortitudeChange != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_FORTITUDE_CHANGE_TEXT", iFortitudeChange));
	}
	if (iDamageperTurn != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_DAMAGE_PER_TURN_TEXT", iDamageperTurn));
	}
	if (iStrAdjperTurn < 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_STR_ADJ_PER_TURN_NEGATIVE_TEXT", iStrAdjperTurn));
	}
	else if (iStrAdjperTurn > 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_STR_ADJ_PER_TURN_POSITIVE_TEXT", iStrAdjperTurn));
	}
	if (iWeakenperTurn > 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_WEAKEN_PER_TURN_POSITIVE_TEXT", iWeakenperTurn));
	}
	else if (iWeakenperTurn < 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_WEAKEN_PER_TURN_NEGATIVE_TEXT", iWeakenperTurn));
	}
	if (iCommunicability != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_COMMUNICABILITY_TEXT", iCommunicability));
	}
	if (iWorseningProbability != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_PROBABILITY_OF_WORSENING_MODIFIER", iWorseningProbability));
	}
	if (iToleranceBuildup > 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_TOLERANCE_BUILDUP_TEXT", iToleranceBuildup));
	}
	else if (iToleranceBuildup < 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_TOLERANCE_EROSION_TEXT", iToleranceBuildup));
	}
	if (iToleranceDecay > 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_TOLERANCE_DECAY_TEXT", iToleranceDecay));
	}
	if (iToleranceDecay < 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_TOLERANCE_DECAY_ADD_TEXT", iToleranceDecay));
	}
	if (iFrontSupportPercentChange > 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_FRONT_SUPPORT_PERCENT_CHANGE_TEXT", iFrontSupportPercentChange));
	}
	if (iShortRangeSupportPercentChange > 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_SHORT_RANGE_SUPPORT_PERCENT_CHANGE_TEXT", iShortRangeSupportPercentChange));
	}
	if (iMediumRangeSupportPercentChange > 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_MEDIUM_RANGE_SUPPORT_PERCENT_CHANGE_TEXT", iMediumRangeSupportPercentChange));
	}
	if (iLongRangeSupportPercentChange > 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_LONG_RANGE_SUPPORT_PERCENT_CHANGE_TEXT", iLongRangeSupportPercentChange));
	}
	if (iFlankSupportPercentChange > 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_FLANK_SUPPORT_PERCENT_CHANGE_TEXT", iFlankSupportPercentChange));
	}
	if (iDodgeModifierChange != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_DODGE_MODIFIER_TEXT", iDodgeModifierChange));
	}
	if (iPrecisionModifierChange != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_PRECISION_MODIFIER_TEXT", iPrecisionModifierChange));
	}
	if (iPowerShotsChange != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_POWER_SHOTS_TEXT", iPowerShotsChange));
	}
	if (iPowerShotCombatModifierChange != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_POWER_SHOT_COMBAT_MODIFIER_TEXT", iPowerShotCombatModifierChange));
	}
	if (iPowerShotPunctureModifierChange != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_POWER_SHOT_PUNCTURE_MODIFIER_TEXT", iPowerShotPunctureModifierChange));
	}
	if (iPowerShotPrecisionModifierChange != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_POWER_SHOT_PRECISION_MODIFIER_TEXT", iPowerShotPrecisionModifierChange));
	}
	if (iPowerShotCriticalModifierChange != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_POWER_SHOT_CRITICAL_MODIFIER_TEXT", iPowerShotCriticalModifierChange));
	}
	if (iCriticalModifierChange != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_CRITICAL_MODIFIER_TEXT", iCriticalModifierChange));
	}
	if (iEnduranceChange != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_ENDURANCE_TEXT", iEnduranceChange));
	}
	if (iInsidiousnessChange != 0)
	{
		szBuffer.append(pcNewline);
		float fValue = (float)iInsidiousnessChange;
		{
			szTempBuffer.Format(L"%.1f", fValue/10);
		}
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_INSIDIOUSNESS_TEXT", szTempBuffer.GetCString()));
	}
	if (iInvestigationChange != 0)
	{
		szBuffer.append(pcNewline);
		float fValue = (float)iInvestigationChange;
		{
			szTempBuffer.Format(L"%.1f", fValue/10);
		}
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_INVESTIGATION_TEXT", szTempBuffer.GetCString()));
	}
	if (iAssassinChange != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_ASSASSIN_TEXT", iAssassinChange));
	}
	bool bWithoutWarning = GC.getGame().isOption(GAMEOPTION_WITHOUT_WARNING);
	if (iStealthStrikesChange != 0 && bWithoutWarning)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_STEALTH_STRIKES_TEXT", iStealthStrikesChange));
	}
	if (iStealthCombatModifierChange != 0 && bWithoutWarning)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_STEALTH_COMBAT_MODIFIER_TEXT", iStealthCombatModifierChange));
	}
	if (iStealthDefenseChange != 0 && bWithoutWarning)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_STEALTH_DEFENSE_CHANGE_TEXT", iStealthDefenseChange));
	}
	if (iDefenseOnlyChange != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_DEFENSE_ONLY_CHANGE_TEXT", iDefenseOnlyChange));
	}
	if (iNoInvisibilityChange != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_NO_INVISIBILITY_CHANGE_TEXT", iNoInvisibilityChange));
	}
	if (iTrapDamageMin != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_TRAP_MIN_DAMAGE_TEXT", iTrapDamageMin));
	}
	if (iTrapDamageMax != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_TRAP_MAX_DAMAGE_TEXT", iTrapDamageMax));
	}
	if (iTrapComplexity != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_TRAP_COMPLEXITY_TEXT", iTrapComplexity));
	}
	if (iTrapNumTriggers != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_TRAP_NUM_TRIGGERS_TEXT", iTrapNumTriggers));
	}
	if (iTrapTriggerBeforeAttackChange != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_TRAP_TRIGGER_BEFORE_ATTACK_TEXT", iTrapTriggerBeforeAttackChange));
	}
	if (iVisibilityChange > 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_VISIBILITY_TEXT", iVisibilityChange));
	}
	if (iCaptureProbabilityModifierChange != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_UNIT_CAPTURE_PROBABILITY_MODIFIER", iCaptureProbabilityModifierChange));
	}
	if (iCaptureResistanceModifierChange != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_UNIT_CAPTURE_RESISTANCE_MODIFIER", iCaptureResistanceModifierChange));
	}
	if (iBreakdownChanceChange != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_BREAKDOWN_CHANCE", iBreakdownChanceChange));
	}
	if (iBreakdownDamageChange != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_BREAKDOWN_DAMAGE", iBreakdownDamageChange));
	}
	if (iTauntChange != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_UNIT_TAUNT", iTauntChange));
	}
	if (iMaxHPChange != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_MAX_HP", iMaxHPChange));
	}
	if (iStrengthModifier != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_STRENGTH_MODIFIER", iStrengthModifier));
	}
	if (iAirCombatLimitChange != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_AIR_LIMIT_CHANGE_TEXT", iAirCombatLimitChange));
	}
	if (iCelebrityHappy != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_CELEBRITY_TEXT", iCelebrityHappy));
	}
	if (iCollateralDamageLimitChange != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_COLLATERAL_LIMIT_CHANGE_TEXT", iCollateralDamageLimitChange));
	}
	if (iCollateralDamageMaxUnitsChange != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_MAX_UNITS_CHANGE_TEXT", iCollateralDamageMaxUnitsChange));
	}
	if (iCombatLimitChange != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_COMBAT_LIMIT_TEXT", iCombatLimitChange));
	}
	if (iExtraDropRange != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_EXTRA_DROP_RANGE_TEXT", iExtraDropRange));
	}
	if (iSurvivorChance != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_SURVIVOR_TEXT", iSurvivorChance));
	}
	if (iSelfHealModifier != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_SELF_HEAL", iSelfHealModifier));
	}
	if (iHealSupport != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_HEAL_SUPPORT_TEXT", iHealSupport));
	}
	if (iVictoryAdjacentHeal != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_VICTORY_ADJACENT_TEXT", iVictoryAdjacentHeal));
	}
	if (iVictoryHeal != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_VICTORY_HEAL_TEXT", iVictoryHeal));
	}
	if (iVictoryStackHeal != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_VICTORY_STACK_TEXT", iVictoryStackHeal));
	}
	if (iCargoChange != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_CARGO_TEXT", iCargoChange));
	}
	if (iCollateralDamageChange != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_COLLATERAL_DAMAGE_TEXT", iCollateralDamageChange));
	}
	if (iBombardRateChange != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_BOMBARD_TEXT", iBombardRateChange));
	}
	if (iDCMBombRangeChange != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_DCM_BOMB_RANGE_TEXT", iDCMBombRangeChange));
	}
	if (iDCMBombAccuracyChange != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_DCM_BOMB_ACCURACY_TEXT", iDCMBombAccuracyChange));
	}
	if (iRBombardDamageChange != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_DCM_BOMB_DAMAGE_TEXT", iRBombardDamageChange));
	}
	if (iRBombardDamageLimitChange != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_DCM_BOMB_DAMAGE_LIMIT_TEXT", iRBombardDamageLimitChange));
	}
	if (iRBombardDamageMaxUnitsChange != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_DCM_BOMB_DAMAGE_MAX_UNITS_TEXT", iRBombardDamageMaxUnitsChange));
	}
	if (iFirstStrikesChange != 0)
	{
		if (iFirstStrikesChange == 1)
		{
			szBuffer.append(pcNewline);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_FIRST_STRIKE_TEXT", iFirstStrikesChange));
		}
		else
		{
			szBuffer.append(pcNewline);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_FIRST_STRIKES_TEXT", iFirstStrikesChange));
		}
	}
	if (iChanceFirstStrikesChange != 0)
	{
		if (iChanceFirstStrikesChange == 1)
		{
			szBuffer.append(pcNewline);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_FIRST_STRIKE_CHANCE_TEXT", iChanceFirstStrikesChange));
		}
		else
		{
			szBuffer.append(pcNewline);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_FIRST_STRIKES_CHANCE_TEXT", iChanceFirstStrikesChange));
		}
	}
	if (iEnemyHealChange != 0)
	{
		//TSHEEP Display Spy Promotions Differently
		if(GC.getPromotionInfo(ePromotion).getSound()[5] == 'P')
		{
			szBuffer.append(pcNewline);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_INSTIGATE_TEXT_SPY", iEnemyHealChange));
		}
		else
		{
			szBuffer.append(pcNewline);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_HEALS_EXTRA_TEXT", iEnemyHealChange) + gDLL->getText("TXT_KEY_PROMOTION_ENEMY_LANDS_TEXT"));
		}
		//szBuffer.append(pcNewline);
		//szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_HEALS_EXTRA_TEXT", GC.getPromotionInfo(ePromotion).getEnemyHealChange()) + gDLL->getText("TXT_KEY_PROMOTION_ENEMY_LANDS_TEXT"));
		//TSHEEP End
	}
	if (iNeutralHealChange != 0)
	{
		//TSHEEP Display Spy Promotions Differently
		if(GC.getPromotionInfo(ePromotion).getSound()[5] == 'P')
		{
			szBuffer.append(pcNewline);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_INSTIGATE2_TEXT_SPY", iNeutralHealChange));
		}
		else
		{
			szBuffer.append(pcNewline);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_HEALS_EXTRA_TEXT", iNeutralHealChange) + gDLL->getText("TXT_KEY_PROMOTION_NEUTRAL_LANDS_TEXT"));
		}
		//szBuffer.append(pcNewline);
		//szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_HEALS_EXTRA_TEXT", GC.getPromotionInfo(ePromotion).getNeutralHealChange()) + gDLL->getText("TXT_KEY_PROMOTION_NEUTRAL_LANDS_TEXT"));
		//TSHEEP End
	}
	if (iFriendlyHealChange != 0)
	{
		//TSHEEP Display Spy Promotions Differently
		if(GC.getPromotionInfo(ePromotion).getSound()[5] == 'P')
		{
			szBuffer.append(pcNewline);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_POISON_TEXT_SPY", iFriendlyHealChange));
		}
		else
		{
			szBuffer.append(pcNewline);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_HEALS_EXTRA_TEXT", iFriendlyHealChange) + gDLL->getText("TXT_KEY_PROMOTION_FRIENDLY_LANDS_TEXT"));
		}
		//szBuffer.append(pcNewline);
		//szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_HEALS_EXTRA_TEXT", GC.getPromotionInfo(ePromotion).getFriendlyHealChange()) + gDLL->getText("TXT_KEY_PROMOTION_FRIENDLY_LANDS_TEXT"));
		//TSHEEP End
	}
	if (iSameTileHealChange != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_HEALS_SAME_TEXT", iSameTileHealChange) + gDLL->getText("TXT_KEY_PROMOTION_DAMAGE_TURN_TEXT"));
	}
	if (iAdjacentTileHealChange != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_HEALS_ADJACENT_TEXT", iAdjacentTileHealChange) + gDLL->getText("TXT_KEY_PROMOTION_DAMAGE_TURN_TEXT"));
	}
	if (iCombatPercent != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_STRENGTH_TEXT", iCombatPercent));
	}
	if (iCityAttackPercent != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_CITY_ATTACK_TEXT", iCityAttackPercent));
	}
	if (iCityDefensePercent != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_CITY_DEFENSE_TEXT", iCityDefensePercent));
	}
	if (iHillsAttackPercent != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_UNIT_HILLS_ATTACK", iHillsAttackPercent));
	}
	if (iHillsDefensePercent != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_HILLS_DEFENSE_TEXT", iHillsDefensePercent));
	}
	if (iWorkRate != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_WORK_RATE_TEXT", iWorkRate));
	}
	if (iHillsWorkPercent != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_HILLS_WORK_TEXT", iHillsWorkPercent));
	}
	if (iPeaksWorkPercent != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_PEAKS_WORK_TEXT", iPeaksWorkPercent));
	}
	if (iRevoltProtection != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_TEMP_REVOLT_PROTECTION", iRevoltProtection));
	}
	if (iCollateralDamageProtection != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_COLLATERAL_PROTECTION_TEXT", iCollateralDamageProtection));
	}
	if (iPillageChange != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_PILLAGE_CHANGE_TEXT", iPillageChange));
	}
	if (iUpgradeDiscount != 0)
	{
		//TSHEEP Display Spy Promotions Differently
		if(GC.getPromotionInfo(ePromotion).getSound()[5] == 'P')
		{
			szBuffer.append(pcNewline);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_UPGRADE_DISCOUNT_TEXT_SPY", iUpgradeDiscount));
		}
		else if (100 == iUpgradeDiscount)
		{
			szBuffer.append(pcNewline);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_UPGRADE_DISCOUNT_FREE_TEXT"));
		}
		else
		{
			szBuffer.append(pcNewline);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_UPGRADE_DISCOUNT_TEXT", iUpgradeDiscount));
		}
		/*if (100 == GC.getPromotionInfo(ePromotion).getUpgradeDiscount())
		{
			szBuffer.append(pcNewline);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_UPGRADE_DISCOUNT_FREE_TEXT"));
		}
		else
		{
			szBuffer.append(pcNewline);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_UPGRADE_DISCOUNT_TEXT", GC.getPromotionInfo(ePromotion).getUpgradeDiscount()));
		}*/
		//TSHEEP End
	}
	if (iExperiencePercent != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_FASTER_EXPERIENCE_TEXT", iExperiencePercent));
	}
	if (iKamikazePercent != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_KAMIKAZE_TEXT", iKamikazePercent));
	}
	if (iHiddenNationality > 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_HIDDEN_NATIONALITY_ADDS_TEXT"));
	}
	else if (iHiddenNationality < 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_HIDDEN_NATIONALITY_REMOVES_TEXT"));
	}
	if ( iIsAnimalIgnoresBordersChange != 0 && !GC.getGame().isOption(GAMEOPTION_ANIMALS_STAY_OUT))
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_ANIMAL_IGNORES_BORDERS_TEXT", iIsAnimalIgnoresBordersChange));
	}

	if ( iNoDefensiveBonusChange > 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_NO_DEFENSIVE_BONUS_CHANGE_POSITIVE_TEXT", iNoDefensiveBonusChange));
	}

	if ( iNoDefensiveBonusChange < 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_NO_DEFENSIVE_BONUS_CHANGE_NEGATIVE_TEXT", iNoDefensiveBonusChange));
	}


	//references
	DomainTypes	eDomainCargoChange = NO_DOMAIN;
	SpecialUnitTypes eSpecialCargoChange = NO_SPECIALUNIT;
	SpecialUnitTypes eNotSpecialCargoChange = NO_SPECIALUNIT;
	SpecialUnitTypes eSpecialUnit = NO_SPECIALUNIT;
	for( iI = 0; iI < (int)linePromotionsOwned.size(); iI++ )
	{
		eDomainCargoChange = GC.getPromotionInfo(linePromotionsOwned[iI]).getDomainCargoChange();
		if (!GC.getGame().isOption(GAMEOPTION_SIZE_MATTERS))
		{
			eSpecialCargoChange = GC.getPromotionInfo(linePromotionsOwned[iI]).getSpecialCargoChange();
		}
		else
		{
			eSpecialCargoChange = GC.getPromotionInfo(linePromotionsOwned[iI]).getSMSpecialCargoChange();
			eNotSpecialCargoChange = GC.getPromotionInfo(linePromotionsOwned[iI]).getSMNotSpecialCargoChange();
		}
		eSpecialUnit = GC.getPromotionInfo(linePromotionsOwned[iI]).setSpecialUnit();
	}
	if (eDomainCargoChange != NO_DOMAIN)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_DOMAIN_CARGO_CHANGE_TEXT", GC.getDomainInfo(eDomainCargoChange).getTextKeyWide()));
	}
	if (bIsImmuneToFirstStrikes)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_IMMUNE_FIRST_STRIKES_TEXT"));
	}
	if (eSpecialCargoChange != NO_SPECIALUNIT)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_SPECIAL_CARGO_CHANGE_TEXT", GC.getSpecialUnitInfo(eSpecialCargoChange).getTextKeyWide()));
	}
	if (eNotSpecialCargoChange != NO_SPECIALUNIT)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOHELP_CHANGE_NOT_SPECIAL_CARGO", GC.getSpecialUnitInfo(eNotSpecialCargoChange).getTextKeyWide()));
	}
	if (eSpecialUnit != NO_SPECIALUNIT)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOHELP_CHANGE_SPECIAL_UNIT", GC.getSpecialUnitInfo(eSpecialUnit).getTextKeyWide()));
	}

	//Vectors

	if (GC.getGame().isModderGameOption(MODDERGAMEOPTION_TERRAIN_DAMAGE))
	{
		std::vector<bool>	abIsIgnoreTerrainDamage;

		abIsIgnoreTerrainDamage.resize(GC.getNumTerrainInfos(), false);

		for( iI = 0; iI < (int)linePromotionsOwned.size(); iI++ )
		{
			if ( GC.getPromotionInfo(linePromotionsOwned[iI]).getIgnoreTerrainDamage() != NO_TERRAIN )
			{
				abIsIgnoreTerrainDamage[GC.getPromotionInfo(linePromotionsOwned[iI]).getIgnoreTerrainDamage()] = true;
			}
		}
		for( iI = 0; iI < GC.getNumTerrainInfos(); iI++ )
		{
			if (abIsIgnoreTerrainDamage[iI])
			{
				szBuffer.append(pcNewline);
				szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_IGNORE_TERRAIN_DAMAGE", GC.getTerrainInfo((TerrainTypes)iI).getDescription()));
			}
		}
	}

	std::vector<PromotionLineTypes> aAfflictions;
	std::vector<int> iMelee;
	std::vector<int> iDistance;
	std::vector<int> iImmediate;
	std::vector<int> iProbability;

	for( iJ = 0; iJ < (int)linePromotionsOwned.size(); iJ++ )
	{
		for (iI = 0; iI < GC.getPromotionInfo(linePromotionsOwned[iJ]).getNumAfflictOnAttackChangeTypes(); ++iI)
		{
			aAfflictions.push_back((PromotionLineTypes)GC.getPromotionInfo(ePromotion).getAfflictOnAttackChangeType(iI).eAfflictionLine);
			iMelee.push_back(GC.getPromotionInfo(ePromotion).getAfflictOnAttackChangeType(iI).iMelee);
			iDistance.push_back(GC.getPromotionInfo(ePromotion).getAfflictOnAttackChangeType(iI).iDistance);
			iImmediate.push_back(GC.getPromotionInfo(ePromotion).getAfflictOnAttackChangeType(iI).iImmediate);
			iProbability.push_back(GC.getPromotionInfo(ePromotion).getAfflictOnAttackChangeType(iI).iProbabilityChange);
		}
	}

	for( iI = 0; iI < (int)aAfflictions.size(); iI++ )
	{
		if (iImmediate[iI] > 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_AFFLICT_ON_ATTACK_IMMEDIATE_TEXT", iProbability[iI], GC.getPromotionLineInfo(aAfflictions[iI]).getDescription()));
		}
		else if (iImmediate[iI] < 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_AFFLICT_ON_ATTACK_NOT_IMMEDIATE_TEXT", iProbability[iI], GC.getPromotionLineInfo(aAfflictions[iI]).getDescription()));
		}
		else
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_AFFLICT_ON_ATTACK_TEXT", iProbability[iI], GC.getPromotionLineInfo(aAfflictions[iI]).getDescription()));
		}
		if (iMelee[iI] > 0 && iDistance[iI] > 0)
		{
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_AFFLICT_ON_ATTACK_BOTH_TEXT"));
		}
		else
		{
			if (iMelee[iI] > 0)
			{
				szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_AFFLICT_ON_ATTACK_MELEE_TEXT"));
			}
			if (iDistance[iI] > 0)
			{
				szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_AFFLICT_ON_ATTACK_DISTANCE_TEXT"));
			}
		}
	}

	if (GC.getGame().isOption(GAMEOPTION_OUTBREAKS_AND_AFFLICTIONS))
	{
		aAfflictions.clear();
		iImmediate.clear();
		iMelee.clear();
		iDistance.clear();
		iProbability.clear();


		for( iJ = 0; iJ < (int)linePromotionsOwned.size(); iJ++ )
		{
			for (iI = 0; iI < GC.getPromotionInfo(linePromotionsOwned[iJ]).getNumCureAfflictionChangeTypes(); ++iI)
			{
				aAfflictions.push_back((PromotionLineTypes)GC.getPromotionInfo(ePromotion).getCureAfflictionChangeType(iI));
			}
		}

		for( iI = 0; iI < (int)aAfflictions.size(); iI++ )
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_CURE_AFFLICTION_TEXT", GC.getPromotionLineInfo(aAfflictions[iI]).getDescription()));
		}

		std::vector<int> afflictionModifier;

		aAfflictions.clear();
		for( iJ = 0; iJ < (int)linePromotionsOwned.size(); iJ++ )
		{
			for (iI = 0; iI < GC.getPromotionInfo(linePromotionsOwned[iJ]).getNumAfflictionFortitudeChangeModifiers(); ++iI)
			{
				aAfflictions.push_back((PromotionLineTypes)GC.getPromotionInfo(ePromotion).getAfflictionFortitudeChangeModifier(iI).ePromotionLine);
				afflictionModifier.push_back(GC.getPromotionInfo(ePromotion).getAfflictionFortitudeChangeModifier(iI).iModifier);
			}
		}

		for( iI = 0; iI < (int)aAfflictions.size(); iI++ )
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_AFFLICTION_FORTITUDE_CHANGE_MODIFIER_TEXT", afflictionModifier[iI], GC.getPromotionLineInfo(aAfflictions[iI]).getDescription()));
		}
	}

	std::vector<UnitCombatTypes> aUnitCombats;

	for( iJ = 0; iJ < (int)linePromotionsOwned.size(); iJ++ )
	{
		for (iI = 0; iI < GC.getPromotionInfo(ePromotion).getNumSubCombatChangeTypes(); ++iI)
		{
			aUnitCombats.push_back((UnitCombatTypes)GC.getPromotionInfo(ePromotion).getSubCombatChangeType(iI));
		}
	}

	for( iI = 0; iI < (int)aUnitCombats.size(); iI++ )
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_SUB_COMBAT_TEXT", GC.getUnitCombatInfo(aUnitCombats[iI]).getDescription()));
	}

	aUnitCombats.clear();

	for( iJ = 0; iJ < (int)linePromotionsOwned.size(); iJ++ )
	{
		for (iI = 0; iI < GC.getPromotionInfo(ePromotion).getNumRemovesUnitCombatTypes(); ++iI)
		{
			aUnitCombats.push_back((UnitCombatTypes)GC.getPromotionInfo(ePromotion).getRemovesUnitCombatType(iI));
		}
	}

	for( iI = 0; iI < (int)aUnitCombats.size(); iI++ )
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_REMOVES_COMBAT_TEXT", GC.getUnitCombatInfo(aUnitCombats[iI]).getDescription()));
	}


	std::vector<PromotionTypes> aTrapSetWithPromotionType;
	aTrapSetWithPromotionType.clear();
	for( iJ = 0; iJ < (int)linePromotionsOwned.size(); iJ++ )
	{
		for (iI = 0; iI < GC.getPromotionInfo(linePromotionsOwned[iJ]).getNumTrapSetWithPromotionTypes(); ++iI)
		{
			aTrapSetWithPromotionType.push_back((PromotionTypes)GC.getPromotionInfo(ePromotion).getTrapSetWithPromotionType(iI));
		}
	}

	for( iI = 0; iI < (int)aTrapSetWithPromotionType.size(); iI++ )
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_TRAP_PROMOTION_SET_TEXT", GC.getPromotionInfo(aTrapSetWithPromotionType[iI]).getTextKeyWide()));
	}

	std::vector<UnitCombatTypes> aTrapImmunityUnitCombatType;
	aTrapImmunityUnitCombatType.clear();
	for( iJ = 0; iJ < (int)linePromotionsOwned.size(); iJ++ )
	{
		for (iI = 0; iI < GC.getPromotionInfo(linePromotionsOwned[iJ]).getNumTrapImmunityUnitCombatTypes(); ++iI)
		{
			aTrapImmunityUnitCombatType.push_back((UnitCombatTypes)GC.getPromotionInfo(ePromotion).getTrapImmunityUnitCombatType(iI));
		}
	}

	for( iI = 0; iI < (int)aTrapImmunityUnitCombatType.size(); iI++ )
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_TRAP_IMMUNITY_TEXT", GC.getUnitCombatInfo(aTrapImmunityUnitCombatType[iI]).getTextKeyWide()));
	}

	std::vector<UnitCombatTypes> aTargetUnitCombatType;
	aTargetUnitCombatType.clear();
	for( iJ = 0; iJ < (int)linePromotionsOwned.size(); iJ++ )
	{
		for (iI = 0; iI < GC.getPromotionInfo(linePromotionsOwned[iJ]).getNumTargetUnitCombatTypes(); iI++)
		{
			aTargetUnitCombatType.push_back((UnitCombatTypes)GC.getPromotionInfo(ePromotion).getTargetUnitCombatType(iI));
		}
	}

	for( iI = 0; iI < (int)aTargetUnitCombatType.size(); iI++ )
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_TARGET_UNITCOMBAT_TEXT", GC.getUnitCombatInfo(aTargetUnitCombatType[iI]).getTextKeyWide()));
	}

	std::vector<UnitCombatTypes> eUnitCombat;
	std::vector<int> iHeal;
	std::vector<int> iAdjacentHeal;

	bool bFirst = true;
	for( iJ = 0; iJ < (int)linePromotionsOwned.size(); iJ++ )
	{
		for (iI = 0; iI < GC.getPromotionInfo(linePromotionsOwned[iJ]).getNumHealUnitCombatChangeTypes(); ++iI)
		{
			bFirst = true;
			for(iK = 0; iK < (int)eUnitCombat.size(); iK++ )
			{
				if (eUnitCombat[iK] == (UnitCombatTypes)GC.getPromotionInfo(linePromotionsOwned[iJ]).getHealUnitCombatChangeType(iI).eUnitCombat)
				{
					bFirst = false;
				}
			}
			if (bFirst)
			{
				eUnitCombat.push_back((UnitCombatTypes)GC.getPromotionInfo(linePromotionsOwned[iJ]).getHealUnitCombatChangeType(iI).eUnitCombat);
				iHeal.push_back(GC.getPromotionInfo(linePromotionsOwned[iJ]).getHealUnitCombatChangeType(iI).iHeal);
				iAdjacentHeal.push_back(GC.getPromotionInfo(linePromotionsOwned[iJ]).getHealUnitCombatChangeType(iI).iAdjacentHeal);
			}
			else
			{
				for(iK = 0; iK < (int)eUnitCombat.size(); iK++ )
				{
					if (eUnitCombat[iK] == (UnitCombatTypes)GC.getPromotionInfo(linePromotionsOwned[iJ]).getHealUnitCombatChangeType(iI).eUnitCombat)
					{
						iHeal[iK] += GC.getPromotionInfo(linePromotionsOwned[iJ]).getHealUnitCombatChangeType(iI).iHeal;
						iAdjacentHeal[iK] += GC.getPromotionInfo(linePromotionsOwned[iJ]).getHealUnitCombatChangeType(iI).iAdjacentHeal;
					}
				}
			}
		}
	}

	for( iI = 0; iI < (int)eUnitCombat.size(); iI++ )
	{
		if (iHeal[iI] > 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_HEALS_UNITCOMBAT_SAME_TEXT", GC.getUnitCombatInfo(eUnitCombat[iI]).getTextKeyWide(), iHeal[iI]) + gDLL->getText("TXT_KEY_PROMOTION_DAMAGE_TURN_TEXT"));
		}
		if (iAdjacentHeal[iI] > 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_HEALS_UNITCOMBAT_ADJACENT_TEXT", GC.getUnitCombatInfo(eUnitCombat[iI]).getTextKeyWide(), iAdjacentHeal[iI]) + gDLL->getText("TXT_KEY_PROMOTION_DAMAGE_TURN_TEXT"));
		}
	}

	eUnitCombat.clear();
	iHeal.clear();
	iAdjacentHeal.clear();


	std::vector<BuildTypes> aAddsBuildTypes;
	aAddsBuildTypes.clear();
	for( iJ = 0; iJ < (int)linePromotionsOwned.size(); iJ++ )
	{
		for (iI = 0; iI < GC.getPromotionInfo(linePromotionsOwned[iJ]).getNumAddsBuildTypes(); ++iI)
		{
			aAddsBuildTypes.push_back((BuildTypes)GC.getPromotionInfo(ePromotion).getAddsBuildType(iI));
		}
	}

	for( iI = 0; iI < (int)aAddsBuildTypes.size(); iI++ )
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_ADDS_BUILD_TYPE_TEXT", GC.getBuildInfo(aAddsBuildTypes[iI]).getTextKeyWide()));
	}

	std::vector<InvisibleTypes> aNegatesInvisibilityType;
	aNegatesInvisibilityType.clear();
	for( iJ = 0; iJ < (int)linePromotionsOwned.size(); iJ++ )
	{
		for (iI = 0; iI < GC.getPromotionInfo(linePromotionsOwned[iJ]).getNumNegatesInvisibilityTypes(); ++iI)
		{
			aNegatesInvisibilityType.push_back((InvisibleTypes)GC.getPromotionInfo(ePromotion).getNegatesInvisibilityType(iI));
		}
	}

	for( iI = 0; iI < (int)aNegatesInvisibilityType.size(); iI++ )
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOHELP_INVISIBILITY_NEGATES_VEIL", GC.getInvisibleInfo(aNegatesInvisibilityType[iI]).getChar()));
	}

	std::vector<TerrainTypes> aPrereqTerrainType;
	aPrereqTerrainType.clear();
	for( iJ = 0; iJ < (int)linePromotionsOwned.size(); iJ++ )
	{
		for (iI = 0; iI < GC.getPromotionInfo(linePromotionsOwned[iJ]).getNumPrereqTerrainTypes(); ++iI)
		{
			aPrereqTerrainType.push_back((TerrainTypes)GC.getPromotionInfo(ePromotion).getPrereqTerrainType(iI));
		}
	}

	for( iI = 0; iI < (int)aPrereqTerrainType.size(); iI++ )
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_TERRAIN_PREREQ_TEXT", GC.getTerrainInfo(aPrereqTerrainType[iI]).getTextKeyWide()));
	}

	std::vector<FeatureTypes> aPrereqFeatureType;
	aPrereqFeatureType.clear();
	for( iJ = 0; iJ < (int)linePromotionsOwned.size(); iJ++ )
	{
		for (iI = 0; iI < GC.getPromotionInfo(linePromotionsOwned[iJ]).getNumPrereqFeatureTypes(); ++iI)
		{
			aPrereqFeatureType.push_back((FeatureTypes)GC.getPromotionInfo(ePromotion).getPrereqFeatureType(iI));
		}
	}

	for( iI = 0; iI < (int)aPrereqFeatureType.size(); iI++ )
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_FEATURE_PREREQ_TEXT", GC.getFeatureInfo(aPrereqFeatureType[iI]).getTextKeyWide()));
	}

	std::vector<ImprovementTypes> aPrereqImprovementType;
	aPrereqImprovementType.clear();
	for( iJ = 0; iJ < (int)linePromotionsOwned.size(); iJ++ )
	{
		for (iI = 0; iI < GC.getPromotionInfo(linePromotionsOwned[iJ]).getNumPrereqImprovementTypes(); ++iI)
		{
			aPrereqImprovementType.push_back((ImprovementTypes)GC.getPromotionInfo(ePromotion).getPrereqImprovementType(iI));
		}
	}

	for( iI = 0; iI < (int)aPrereqImprovementType.size(); iI++ )
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_IMPROVEMENT_PREREQ_TEXT", GC.getImprovementInfo(aPrereqImprovementType[iI]).getTextKeyWide()));
	}

	for( iJ = 0; iJ < (int)linePromotionsOwned.size(); iJ++ )
	{
		for (iI = 0; iI < GC.getPromotionInfo(linePromotionsOwned[iJ]).getNumPrereqLocalBuildingTypes(); ++iI)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_BUILDING_PREREQ_TEXT", GC.getBuildingInfo((BuildingTypes)GC.getPromotionInfo(linePromotionsOwned[iJ]).getPrereqLocalBuildingType(iI)).getTextKeyWide()));
		}
	}

	std::vector<BonusTypes> aPrereqPlotBonusType;
	aPrereqPlotBonusType.clear();
	for( iJ = 0; iJ < (int)linePromotionsOwned.size(); iJ++ )
	{
		for (iI = 0; iI < GC.getPromotionInfo(linePromotionsOwned[iJ]).getNumPrereqPlotBonusTypes(); ++iI)
		{
			aPrereqPlotBonusType.push_back((BonusTypes)GC.getPromotionInfo(ePromotion).getPrereqPlotBonusType(iI));
		}
	}

	for( iI = 0; iI < (int)aPrereqPlotBonusType.size(); iI++ )
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_BONUS_PREREQ_TEXT", GC.getBonusInfo(aPrereqPlotBonusType[iI]).getTextKeyWide()));
	}

	//TerrainInfos
	bool	bIsTerrainDoubleMove = false;
	int	iTerrainAttackPercent = 0;
	int	iTerrainDefensePercent = 0;
	int iTerrainWorkPercent = 0;
	int iWithdrawOnTerrain = 0;
	for (iI = 0; iI < GC.getNumTerrainInfos(); ++iI)
	{
		for( iJ = 0; iJ < (int)linePromotionsOwned.size(); iJ++ )
		{
			if ( GC.getPromotionInfo(linePromotionsOwned[iJ]).getTerrainDoubleMove(iI) )
			{
				bIsTerrainDoubleMove = true;
			}
			iTerrainAttackPercent += GC.getPromotionInfo(linePromotionsOwned[iJ]).getTerrainAttackPercent(iI);
			iTerrainDefensePercent += GC.getPromotionInfo(linePromotionsOwned[iJ]).getTerrainDefensePercent(iI);
			iTerrainWorkPercent += GC.getPromotionInfo(linePromotionsOwned[iJ]).getTerrainWorkPercent(iI);
			iTerrainWorkPercent += GC.getPromotionInfo(linePromotionsOwned[iJ]).getTerrainWorkRateModifierChangeType(iI);
			iWithdrawOnTerrain += GC.getPromotionInfo(linePromotionsOwned[iJ]).getWithdrawOnTerrainTypeChange(iI);
		}
		if (bIsTerrainDoubleMove)
		{
			szBuffer.append(pcNewline);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_DOUBLE_MOVE_TEXT", GC.getTerrainInfo((TerrainTypes) iI).getTextKeyWide()));
		}
		if (iTerrainAttackPercent != 0)
		{
			szBuffer.append(pcNewline);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_ATTACK_TEXT", iTerrainAttackPercent, GC.getTerrainInfo((TerrainTypes) iI).getTextKeyWide()));
		}
		if (iTerrainDefensePercent != 0)
		{
			szBuffer.append(pcNewline);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_DEFENSE_TEXT", iTerrainDefensePercent, GC.getTerrainInfo((TerrainTypes) iI).getTextKeyWide()));
		}
		if (iTerrainWorkPercent != 0)
		{
			szBuffer.append(pcNewline);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_WORK_TEXT", iTerrainWorkPercent, GC.getTerrainInfo((TerrainTypes)iI).getTextKeyWide()));
		}
		if (iWithdrawOnTerrain != 0)
		{
			szBuffer.append(pcNewline);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_WITHDRAW_ON_TEXT", iWithdrawOnTerrain, CvWString(GC.getTerrainInfo((TerrainTypes)iI).getType()).GetCString(), GC.getTerrainInfo((TerrainTypes)iI).getTextKeyWide()));
		}
		bIsTerrainDoubleMove = false;
		iTerrainAttackPercent = 0;
		iTerrainDefensePercent = 0;
		iTerrainWorkPercent = 0;
		iWithdrawOnTerrain = 0;
	}

	//FeatureInfos
	bool	bIsFeatureDoubleMove = false;
	int iFeatureAttackPercent = 0;
	int iFeatureDefensePercent = 0;
	int iFeatureWorkPercent = 0;
	int iWithdrawOnFeature = 0;
	for (iI = 0; iI < GC.getNumFeatureInfos(); ++iI)
	{
		for( iJ = 0; iJ < (int)linePromotionsOwned.size(); iJ++ )
		{
			if ( GC.getPromotionInfo(linePromotionsOwned[iJ]).getFeatureDoubleMove(iI) )
			{
				bIsFeatureDoubleMove = true;
			}
			iFeatureAttackPercent += GC.getPromotionInfo(linePromotionsOwned[iJ]).getFeatureAttackPercent(iI);
			iFeatureDefensePercent += GC.getPromotionInfo(linePromotionsOwned[iJ]).getFeatureDefensePercent(iI);
			iFeatureWorkPercent += GC.getPromotionInfo(linePromotionsOwned[iJ]).getFeatureWorkPercent(iI);
			iFeatureWorkPercent += GC.getPromotionInfo(linePromotionsOwned[iJ]).getFeatureWorkRateModifierChangeType(iI);
			iWithdrawOnFeature += GC.getPromotionInfo(linePromotionsOwned[iJ]).getWithdrawOnFeatureTypeChange(iI);
		}
		if (bIsFeatureDoubleMove)
		{
			szBuffer.append(pcNewline);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_DOUBLE_MOVE_TEXT", GC.getFeatureInfo((FeatureTypes) iI).getTextKeyWide()));
		}
		if (iFeatureAttackPercent != 0)
		{
			szBuffer.append(pcNewline);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_ATTACK_TEXT", iFeatureAttackPercent, GC.getFeatureInfo((FeatureTypes) iI).getTextKeyWide()));
		}
		if (iFeatureDefensePercent != 0)
		{
			szBuffer.append(pcNewline);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_DEFENSE_TEXT", iFeatureDefensePercent, GC.getFeatureInfo((FeatureTypes) iI).getTextKeyWide()));
		}
		if (iFeatureWorkPercent != 0)
		{
			szBuffer.append(pcNewline);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_WORK_TEXT", iFeatureWorkPercent, GC.getFeatureInfo((FeatureTypes)iI).getTextKeyWide()));
		}
		if (iWithdrawOnFeature != 0)
		{
			szBuffer.append(pcNewline);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_WITHDRAW_ON_TEXT", iWithdrawOnFeature, CvWString(GC.getFeatureInfo((FeatureTypes)iI).getType()).GetCString(), GC.getFeatureInfo((FeatureTypes)iI).getTextKeyWide()));
		}
		bIsFeatureDoubleMove = false;
		iFeatureAttackPercent = 0;
		iFeatureDefensePercent = 0;
		iFeatureWorkPercent = 0;
		iWithdrawOnFeature = 0;
	}

	//Builds
	int iBuildWorkPercent = 0;
	for (iI = 0; iI < GC.getNumBuildInfos(); ++iI)
	{
		for(iJ = 0; iJ < (int)linePromotionsOwned.size(); iJ++)
		{
			iBuildWorkPercent += GC.getPromotionInfo(linePromotionsOwned[iJ]).getBuildWorkRateModifierChangeType(iI);
		}
		if (iBuildWorkPercent != 0)
		{
			szBuffer.append(pcNewline);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_WORK_TEXT", iBuildWorkPercent, GC.getBuildInfo((BuildTypes)iI).getTextKeyWide()));
		}
		iBuildWorkPercent = 0;
	}

	//Domains
	for (iI = 0; iI < NUM_DOMAIN_TYPES; ++iI)
	{
		int iDomainModifierPercent = 0;
		for( iJ = 0; iJ < (int)linePromotionsOwned.size(); iJ++ )
		{
			iDomainModifierPercent += GC.getPromotionInfo(linePromotionsOwned[iJ]).getDomainModifierPercent(iI);
		}
		if (iDomainModifierPercent != 0)
		{
			szBuffer.append(pcNewline);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_VERSUS_TEXT", iDomainModifierPercent, CvWString(GC.getDomainInfo((DomainTypes)iI).getType()).GetCString(), GC.getDomainInfo((DomainTypes)iI).getTextKeyWide()));
		}
	}

	//UnitCombats
	int iDisable = 0;
	int iAvoid = 0;
	int iTrigger = 0;
	int iAidChange = 0;
	int	iUnitCombatContractChanceChange = 0;
	int	iUnitCombatOvercomeChange = 0;
	int	iFlankingStrengthbyUnitCombatTypeChange = 0;
	int iUnitCombatModifierPercent = 0;
	int iWithdrawVS = 0;
	int iPursuitVS = 0;
	int iRepelVS = 0;
	int iKnockbackVS = 0;
	int iPunctureVS = 0;
	int iArmorVS = 0;
	int iDodgeVS = 0;
	int iPrecisionVS = 0;
	int iCriticalVS = 0;
	int iRoundStunVS = 0;
	for (iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
	{
		for( iJ = 0; iJ < (int)linePromotionsOwned.size(); iJ++ )
		{
			iDisable += GC.getPromotionInfo(linePromotionsOwned[iJ]).getTrapDisableUnitCombatType(iI);
			iAvoid += GC.getPromotionInfo(linePromotionsOwned[iJ]).getTrapAvoidanceUnitCombatType(iI);
			iTrigger += GC.getPromotionInfo(linePromotionsOwned[iJ]).getTrapTriggerUnitCombatType(iI);
			iAidChange += GC.getPromotionInfo(linePromotionsOwned[iJ]).getAidChange(iI);
			iFlankingStrengthbyUnitCombatTypeChange += GC.getPromotionInfo(linePromotionsOwned[iJ]).getFlankingStrengthbyUnitCombatTypeChange(iI);
			iUnitCombatModifierPercent += GC.getPromotionInfo(linePromotionsOwned[iJ]).getUnitCombatModifierPercent(iI);
			iWithdrawVS += GC.getPromotionInfo(linePromotionsOwned[iJ]).getWithdrawVSUnitCombatChangeType(iI);
			iPursuitVS += GC.getPromotionInfo(linePromotionsOwned[iJ]).getPursuitVSUnitCombatChangeType(iI);
			iRepelVS += GC.getPromotionInfo(linePromotionsOwned[iJ]).getRepelVSUnitCombatChangeType(iI);
			iKnockbackVS += GC.getPromotionInfo(linePromotionsOwned[iJ]).getKnockbackVSUnitCombatChangeType(iI);
			iPunctureVS += GC.getPromotionInfo(linePromotionsOwned[iJ]).getPunctureVSUnitCombatChangeType(iI);
			iArmorVS += GC.getPromotionInfo(linePromotionsOwned[iJ]).getArmorVSUnitCombatChangeType(iI);
			iDodgeVS += GC.getPromotionInfo(linePromotionsOwned[iJ]).getDodgeVSUnitCombatChangeType(iI);
			iPrecisionVS += GC.getPromotionInfo(linePromotionsOwned[iJ]).getPrecisionVSUnitCombatChangeType(iI);
			iCriticalVS += GC.getPromotionInfo(linePromotionsOwned[iJ]).getCriticalVSUnitCombatChangeType(iI);
			iRoundStunVS += GC.getPromotionInfo(linePromotionsOwned[iJ]).getRoundStunVSUnitCombatChangeType(iI);
			if (GC.getPromotionInfo(linePromotionsOwned[iJ]).getPromotionLine() != NO_PROMOTIONLINE)
			{
				iUnitCombatContractChanceChange += GC.getPromotionLineInfo(GC.getPromotionInfo(linePromotionsOwned[iJ]).getPromotionLine()).getUnitCombatContractChanceChange(iI);
				iUnitCombatOvercomeChange += GC.getPromotionLineInfo(GC.getPromotionInfo(linePromotionsOwned[iJ]).getPromotionLine()).getUnitCombatOvercomeChange(iI);
			}
		}
		if (iUnitCombatContractChanceChange > 0)
		{
			szBuffer.append(pcNewline);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_UNIT_COMBAT_COMMUNICABILITY_CHANGE_POSITIVE_TEXT", iUnitCombatContractChanceChange, GC.getUnitCombatInfo((UnitCombatTypes)iI).getDescription()));
		}
		else if (iUnitCombatContractChanceChange < 0)
		{
			szBuffer.append(pcNewline);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_UNIT_COMBAT_COMMUNICABILITY_CHANGE_NEGATIVE_TEXT", iUnitCombatContractChanceChange, GC.getUnitCombatInfo((UnitCombatTypes)iI).getDescription()));
		}
		if (iUnitCombatOvercomeChange > 0)
		{
			szBuffer.append(pcNewline);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_UNIT_COMBAT_OVERCOME_CHANGE_POSITIVE_TEXT", iUnitCombatOvercomeChange, GC.getUnitCombatInfo((UnitCombatTypes)iI).getDescription()));
		}
		else if (iUnitCombatOvercomeChange < 0)
		{
			szBuffer.append(pcNewline);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_UNIT_COMBAT_OVERCOME_CHANGE_NEGATIVE_TEXT", iUnitCombatOvercomeChange, GC.getUnitCombatInfo((UnitCombatTypes)iI).getDescription()));
		}
		if (iFlankingStrengthbyUnitCombatTypeChange > 0)
		{
			szBuffer.append(pcNewline);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_FLANKING_STRENGTH_BY_UNIT_COMBAT_POSITIVE_TEXT", iFlankingStrengthbyUnitCombatTypeChange, GC.getUnitCombatInfo((UnitCombatTypes)iI).getDescription()));
		}
		else if (iFlankingStrengthbyUnitCombatTypeChange < 0)
		{
			szBuffer.append(pcNewline);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_FLANKING_STRENGTH_BY_UNIT_COMBAT_NEGATIVE_TEXT", iFlankingStrengthbyUnitCombatTypeChange, GC.getUnitCombatInfo((UnitCombatTypes)iI).getDescription()));
		}
		if (iDisable != 0)
		{
			szBuffer.append(pcNewline);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_TRAP_DISABLE_TEXT", iDisable, GC.getUnitCombatInfo((UnitCombatTypes)iI).getTextKeyWide()));
		}
		if (iAvoid != 0)
		{
			szBuffer.append(pcNewline);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_TRAP_AVOID_TEXT", iAvoid, GC.getUnitCombatInfo((UnitCombatTypes)iI).getTextKeyWide()));
		}
		if (iTrigger != 0)
		{
			szBuffer.append(pcNewline);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_TRAP_TRIGGER_TEXT", iTrigger, GC.getUnitCombatInfo((UnitCombatTypes)iI).getTextKeyWide()));
		}
		if (iAidChange != 0)
		{
			szBuffer.append(pcNewline);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_AID_CHANGE_TEXT", iAidChange, GC.getPropertyInfo((PropertyTypes)iI).getTextKeyWide()));
		}
		if (iUnitCombatModifierPercent != 0)
		{
			szBuffer.append(pcNewline);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_VERSUS_TEXT", iUnitCombatModifierPercent, CvWString(GC.getUnitCombatInfo((UnitCombatTypes)iI).getType()).GetCString(), GC.getUnitCombatInfo((UnitCombatTypes)iI).getTextKeyWide()));
		}
		if (iWithdrawVS != 0)
		{
			szBuffer.append(pcNewline);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_WITHDRAW_VERSUS_TEXT", iWithdrawVS, CvWString(GC.getUnitCombatInfo((UnitCombatTypes)iI).getType()).GetCString(), GC.getUnitCombatInfo((UnitCombatTypes)iI).getTextKeyWide()));
		}
		if (iPursuitVS != 0)
		{
			szBuffer.append(pcNewline);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_PURSUIT_VERSUS_TEXT", iPursuitVS, CvWString(GC.getUnitCombatInfo((UnitCombatTypes)iI).getType()).GetCString(), GC.getUnitCombatInfo((UnitCombatTypes)iI).getTextKeyWide()));
		}
		if (iRepelVS != 0)
		{
			szBuffer.append(pcNewline);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_REPEL_VERSUS_TEXT", iRepelVS, CvWString(GC.getUnitCombatInfo((UnitCombatTypes)iI).getType()).GetCString(), GC.getUnitCombatInfo((UnitCombatTypes)iI).getTextKeyWide()));
		}
		if (iKnockbackVS != 0)
		{
			szBuffer.append(pcNewline);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_KNOCKBACK_VERSUS_TEXT", iKnockbackVS, CvWString(GC.getUnitCombatInfo((UnitCombatTypes)iI).getType()).GetCString(), GC.getUnitCombatInfo((UnitCombatTypes)iI).getTextKeyWide()));
		}
		if (iPunctureVS != 0)
		{
			szBuffer.append(pcNewline);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_PUNCTURE_VERSUS_TEXT", iPunctureVS, CvWString(GC.getUnitCombatInfo((UnitCombatTypes)iI).getType()).GetCString(), GC.getUnitCombatInfo((UnitCombatTypes)iI).getTextKeyWide()));
		}
		if (iArmorVS != 0)
		{
			szBuffer.append(pcNewline);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_ARMOR_VERSUS_TEXT", iArmorVS, CvWString(GC.getUnitCombatInfo((UnitCombatTypes)iI).getType()).GetCString(), GC.getUnitCombatInfo((UnitCombatTypes)iI).getTextKeyWide()));
		}
		if (iDodgeVS != 0)
		{
			szBuffer.append(pcNewline);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_DODGE_VERSUS_TEXT", iDodgeVS, CvWString(GC.getUnitCombatInfo((UnitCombatTypes)iI).getType()).GetCString(), GC.getUnitCombatInfo((UnitCombatTypes)iI).getTextKeyWide()));
		}
		if (iPrecisionVS != 0)
		{
			szBuffer.append(pcNewline);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_PRECISION_VERSUS_TEXT", iPrecisionVS, CvWString(GC.getUnitCombatInfo((UnitCombatTypes)iI).getType()).GetCString(), GC.getUnitCombatInfo((UnitCombatTypes)iI).getTextKeyWide()));
		}
		if (iCriticalVS != 0)
		{
			szBuffer.append(pcNewline);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_CRITICAL_VERSUS_TEXT", iCriticalVS, CvWString(GC.getUnitCombatInfo((UnitCombatTypes)iI).getType()).GetCString(), GC.getUnitCombatInfo((UnitCombatTypes)iI).getTextKeyWide()));
		}
		if (iRoundStunVS != 0)
		{
			szBuffer.append(pcNewline);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_ROUND_STUN_VERSUS_TEXT", iRoundStunVS, CvWString(GC.getUnitCombatInfo((UnitCombatTypes)iI).getType()).GetCString(), GC.getUnitCombatInfo((UnitCombatTypes)iI).getTextKeyWide()));
		}
		iDisable = 0;
		iAvoid = 0;
		iTrigger = 0;
		iUnitCombatContractChanceChange = 0;
		iUnitCombatOvercomeChange = 0;
		iFlankingStrengthbyUnitCombatTypeChange = 0;
		iUnitCombatModifierPercent = 0;
		iWithdrawVS = 0;
		iPursuitVS = 0;
		iRepelVS = 0;
		iKnockbackVS = 0;
		iPunctureVS = 0;
		iArmorVS = 0;
		iDodgeVS = 0;
		iPrecisionVS = 0;
		iCriticalVS = 0;
		iRoundStunVS = 0;
	}

	//Techs
	int	iTechContractChanceChange = 0;
	int	iTechOvercomeChange = 0;
	for (iI = 0; iI < GC.getNumTechInfos(); iI++)
	{
		if (GC.getPromotionInfo(ePromotion).getPromotionLine() != NO_PROMOTIONLINE)
		{
			if (GC.getPromotionLineInfo(GC.getPromotionInfo(ePromotion).getPromotionLine()).isTechContractChanceChange(iI))
			{
				for( iJ = 0; iJ < (int)linePromotionsOwned.size(); iJ++ )
				{
					iTechContractChanceChange += GC.getPromotionLineInfo(GC.getPromotionInfo(linePromotionsOwned[iJ]).getPromotionLine()).getTechContractChanceChange(iI);
				}
				if (iTechContractChanceChange > 0)
				{
					szBuffer.append(pcNewline);
					szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_TECH_COMMUNICABILITY_CHANGE_POSITIVE_TEXT", iTechContractChanceChange, GC.getTechInfo((TechTypes)iI).getDescription()));
				}
				else if (iTechContractChanceChange < 0)
				{
					szBuffer.append(pcNewline);
					szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_TECH_COMMUNICABILITY_CHANGE_NEGATIVE_TEXT", iTechContractChanceChange, GC.getTechInfo((TechTypes)iI).getDescription()));
				}
				iTechContractChanceChange = 0;
			}

			if (GC.getPromotionLineInfo((PromotionLineTypes)GC.getPromotionInfo(ePromotion).getPromotionLine()).isTechOvercomeChange(iI))
			{
				for( iJ = 0; iJ < (int)linePromotionsOwned.size(); iJ++ )
				{
					iTechOvercomeChange += GC.getPromotionLineInfo(GC.getPromotionInfo(linePromotionsOwned[iJ]).getPromotionLine()).getTechOvercomeChange(iI);
				}
				if (iTechOvercomeChange > 0)
				{
					szBuffer.append(pcNewline);
					szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_TECH_OVERCOME_CHANGE_POSITIVE_TEXT", iTechOvercomeChange, GC.getTechInfo((TechTypes)iI).getDescription()));
				}
				else if (iTechOvercomeChange < 0)
				{
					szBuffer.append(pcNewline);
					szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_TECH_OVERCOME_CHANGE_NEGATIVE_TEXT", iTechOvercomeChange, GC.getTechInfo((TechTypes)iI).getDescription()));
				}
				iTechOvercomeChange = 0;
			}
		}
	}

	//Hide and Seek
	if (GC.getGame().isOption(GAMEOPTION_HIDE_AND_SEEK))
	{
		int iVisibilityIntensityChange = 0;
		int iVisibilityIntensityRangeChange = 0;
		int iInvisibilityIntensityChange = 0;
		int iInvisibleTerrainChange = 0;
		int iInvisibleFeatureChange = 0;
		int iInvisibleImprovementChange = 0;
		int iVisibleTerrainChange = 0;
		int iVisibleFeatureChange = 0;
		int iVisibleImprovementChange = 0;
		int iVisibleTerrainRangeChange = 0;
		int iVisibleFeatureRangeChange = 0;
		int iVisibleImprovementRangeChange = 0;
		for (iI = 0; iI < GC.getNumInvisibleInfos(); ++iI)
		{
			for(iJ = 0; iJ < (int)linePromotionsOwned.size(); iJ++)
			{
				iVisibilityIntensityChange += GC.getPromotionInfo(linePromotionsOwned[iJ]).getVisibilityIntensityChangeType(iI);
				iVisibilityIntensityRangeChange += GC.getPromotionInfo(linePromotionsOwned[iJ]).getVisibilityIntensityRangeChangeType(iI);
				iInvisibilityIntensityChange += GC.getPromotionInfo(linePromotionsOwned[iJ]).getInvisibilityIntensityChangeType(iI);
			}
			if (iVisibilityIntensityChange != 0)
			{
				szBuffer.append(pcNewline);
				szBuffer.append(gDLL->getText("TXT_KEY_PROMOHELP_INVISIBILITY_SPOT_CHANGE", iVisibilityIntensityChange, GC.getInvisibleInfo((InvisibleTypes)iI).getChar()));
			}
			if (iVisibilityIntensityRangeChange != 0)
			{
				szBuffer.append(pcNewline);
				szBuffer.append(gDLL->getText("TXT_KEY_PROMOHELP_INVISIBILITY_SPOT_RANGE_CHANGE", iVisibilityIntensityRangeChange, GC.getInvisibleInfo((InvisibleTypes)iI).getChar()));
			}
			if (iInvisibilityIntensityChange != 0)
			{
				szBuffer.append(pcNewline);
				szBuffer.append(gDLL->getText("TXT_KEY_PROMOHELP_INVISIBILITY_VEIL_INTENSITY_CHANGE", iInvisibilityIntensityChange, GC.getInvisibleInfo((InvisibleTypes)iI).getChar()));
			}
			iVisibilityIntensityChange = 0;
			iVisibilityIntensityRangeChange = 0;
			iInvisibilityIntensityChange = 0;
			for (iK = 0; iK < GC.getNumTerrainInfos(); iK++)
			{
				for(iJ = 0; iJ < (int)linePromotionsOwned.size(); iJ++)
				{
					for (int iL = 0; iL < GC.getPromotionInfo(linePromotionsOwned[iJ]).getNumInvisibleTerrainChanges(); iL++)
					{
						if (GC.getPromotionInfo(linePromotionsOwned[iJ]).getInvisibleTerrainChange(iL).eInvisible == ((InvisibleTypes)iI) &&
							GC.getPromotionInfo(linePromotionsOwned[iJ]).getInvisibleTerrainChange(iL).eTerrain == ((TerrainTypes)iK))
						{
							iInvisibleTerrainChange += GC.getPromotionInfo(linePromotionsOwned[iJ]).getInvisibleTerrainChange(iL).iIntensity;
						}
					}
					for (int iL = 0; iL < GC.getPromotionInfo(linePromotionsOwned[iJ]).getNumVisibleTerrainChanges(); iL++)
					{
						if (GC.getPromotionInfo(linePromotionsOwned[iJ]).getVisibleTerrainChange(iL).eInvisible == ((InvisibleTypes)iI) &&
							GC.getPromotionInfo(linePromotionsOwned[iJ]).getVisibleTerrainChange(iL).eTerrain == ((TerrainTypes)iK))
						{
							iVisibleTerrainChange += GC.getPromotionInfo(linePromotionsOwned[iJ]).getVisibleTerrainChange(iL).iIntensity;
						}
					}
					for (int iL = 0; iL < GC.getPromotionInfo(linePromotionsOwned[iJ]).getNumVisibleTerrainRangeChanges(); iL++)
					{
						if (GC.getPromotionInfo(linePromotionsOwned[iJ]).getVisibleTerrainRangeChange(iL).eInvisible == ((InvisibleTypes)iI) &&
							GC.getPromotionInfo(linePromotionsOwned[iJ]).getVisibleTerrainRangeChange(iL).eTerrain == ((TerrainTypes)iK))
						{
							iVisibleTerrainRangeChange += GC.getPromotionInfo(linePromotionsOwned[iJ]).getVisibleTerrainRangeChange(iL).iIntensity;
						}
					}
				}
				if (iInvisibleTerrainChange != 0)
				{
					szBuffer.append(pcNewline);
					szBuffer.append(gDLL->getText("TXT_KEY_PROMOHELP_INVISIBILITY_VEIL_PLOT_CHANGE", iInvisibleTerrainChange, GC.getInvisibleInfo((InvisibleTypes)iI).getChar(), GC.getTerrainInfo((TerrainTypes)iK).getTextKeyWide()));
				}
				if (iVisibleTerrainChange != 0)
				{
					szBuffer.append(pcNewline);
					szBuffer.append(gDLL->getText("TXT_KEY_PROMOHELP_INVISIBILITY_SPOT_PLOT_CHANGE", iVisibleTerrainChange, GC.getInvisibleInfo((InvisibleTypes)iI).getChar(), GC.getTerrainInfo((TerrainTypes)iK).getTextKeyWide()));
				}
				if (iVisibleTerrainRangeChange != 0)
				{
					szBuffer.append(pcNewline);
					szBuffer.append(gDLL->getText("TXT_KEY_PROMOHELP_INVISIBILITY_SPOT_PLOT_RANGE_CHANGE", iVisibleTerrainRangeChange, GC.getInvisibleInfo((InvisibleTypes)iI).getChar(), GC.getTerrainInfo((TerrainTypes)iK).getTextKeyWide()));
				}
				iInvisibleTerrainChange = 0;
				iVisibleTerrainChange = 0;
				iVisibleTerrainRangeChange = 0;
			}
			for (iK = 0; iK < GC.getNumFeatureInfos(); iK++)
			{
				for(iJ = 0; iJ < (int)linePromotionsOwned.size(); iJ++)
				{
					for (int iL = 0; iL < GC.getPromotionInfo(linePromotionsOwned[iJ]).getNumInvisibleFeatureChanges(); iL++)
					{
						if (GC.getPromotionInfo(linePromotionsOwned[iJ]).getInvisibleFeatureChange(iL).eInvisible == ((InvisibleTypes)iI) &&
							GC.getPromotionInfo(linePromotionsOwned[iJ]).getInvisibleFeatureChange(iL).eFeature == ((FeatureTypes)iK))
						{
							iInvisibleFeatureChange += GC.getPromotionInfo(linePromotionsOwned[iJ]).getInvisibleFeatureChange(iL).iIntensity;
						}
					}
					for (int iL = 0; iL < GC.getPromotionInfo(linePromotionsOwned[iJ]).getNumVisibleFeatureChanges(); iL++)
					{
						if (GC.getPromotionInfo(linePromotionsOwned[iJ]).getVisibleFeatureChange(iL).eInvisible == ((InvisibleTypes)iI) &&
							GC.getPromotionInfo(linePromotionsOwned[iJ]).getVisibleFeatureChange(iL).eFeature == ((FeatureTypes)iK))
						{
							iVisibleFeatureChange += GC.getPromotionInfo(linePromotionsOwned[iJ]).getVisibleFeatureChange(iL).iIntensity;
						}
					}
					for (int iL = 0; iL < GC.getPromotionInfo(linePromotionsOwned[iJ]).getNumVisibleFeatureRangeChanges(); iL++)
					{
						if (GC.getPromotionInfo(linePromotionsOwned[iJ]).getVisibleFeatureRangeChange(iL).eInvisible == ((InvisibleTypes)iI) &&
							GC.getPromotionInfo(linePromotionsOwned[iJ]).getVisibleFeatureRangeChange(iL).eFeature == ((FeatureTypes)iK))
						{
							iVisibleFeatureRangeChange += GC.getPromotionInfo(linePromotionsOwned[iJ]).getVisibleFeatureRangeChange(iL).iIntensity;
						}
					}
				}
				if (iInvisibleFeatureChange != 0)
				{
					szBuffer.append(pcNewline);
					szBuffer.append(gDLL->getText("TXT_KEY_PROMOHELP_INVISIBILITY_VEIL_PLOT_CHANGE", iInvisibleFeatureChange, GC.getInvisibleInfo((InvisibleTypes)iI).getChar(), GC.getFeatureInfo((FeatureTypes)iK).getTextKeyWide()));
				}
				if (iVisibleFeatureChange != 0)
				{
					szBuffer.append(pcNewline);
					szBuffer.append(gDLL->getText("TXT_KEY_PROMOHELP_INVISIBILITY_SPOT_PLOT_CHANGE", iVisibleFeatureChange, GC.getInvisibleInfo((InvisibleTypes)iI).getChar(), GC.getFeatureInfo((FeatureTypes)iK).getTextKeyWide()));
				}
				if (iVisibleFeatureRangeChange != 0)
				{
					szBuffer.append(pcNewline);
					szBuffer.append(gDLL->getText("TXT_KEY_PROMOHELP_INVISIBILITY_SPOT_PLOT_RANGE_CHANGE", iVisibleFeatureRangeChange, GC.getInvisibleInfo((InvisibleTypes)iI).getChar(), GC.getFeatureInfo((FeatureTypes)iK).getTextKeyWide()));
				}
				iInvisibleFeatureChange = 0;
				iVisibleFeatureChange = 0;
				iVisibleFeatureRangeChange = 0;
			}
			for (iK = 0; iK < GC.getNumImprovementInfos(); iK++)
			{
				for(iJ = 0; iJ < (int)linePromotionsOwned.size(); iJ++)
				{
					for (int iL = 0; iL < GC.getPromotionInfo(linePromotionsOwned[iJ]).getNumInvisibleImprovementChanges(); iL++)
					{
						if (GC.getPromotionInfo(linePromotionsOwned[iJ]).getInvisibleImprovementChange(iL).eInvisible == ((InvisibleTypes)iI) &&
							GC.getPromotionInfo(linePromotionsOwned[iJ]).getInvisibleImprovementChange(iL).eImprovement == ((ImprovementTypes)iK))
						{
							iInvisibleImprovementChange += GC.getPromotionInfo(linePromotionsOwned[iJ]).getInvisibleImprovementChange(iL).iIntensity;
						}
					}
					for (int iL = 0; iL < GC.getPromotionInfo(linePromotionsOwned[iJ]).getNumVisibleImprovementChanges(); iL++)
					{
						if (GC.getPromotionInfo(linePromotionsOwned[iJ]).getVisibleImprovementChange(iL).eInvisible == ((InvisibleTypes)iI) &&
							GC.getPromotionInfo(linePromotionsOwned[iJ]).getVisibleImprovementChange(iL).eImprovement == ((ImprovementTypes)iK))
						{
							iVisibleImprovementChange += GC.getPromotionInfo(linePromotionsOwned[iJ]).getVisibleImprovementChange(iL).iIntensity;
						}
					}
					for (int iL = 0; iL < GC.getPromotionInfo(linePromotionsOwned[iJ]).getNumVisibleImprovementRangeChanges(); iL++)
					{
						if (GC.getPromotionInfo(linePromotionsOwned[iJ]).getVisibleImprovementRangeChange(iL).eInvisible == ((InvisibleTypes)iI) &&
							GC.getPromotionInfo(linePromotionsOwned[iJ]).getVisibleImprovementRangeChange(iL).eImprovement == ((ImprovementTypes)iK))
						{
							iVisibleImprovementRangeChange += GC.getPromotionInfo(linePromotionsOwned[iJ]).getVisibleImprovementRangeChange(iL).iIntensity;
						}
					}
				}
				if (iInvisibleImprovementChange != 0)
				{
					szBuffer.append(pcNewline);
					szBuffer.append(gDLL->getText("TXT_KEY_PROMOHELP_INVISIBILITY_VEIL_PLOT_CHANGE", iInvisibleImprovementChange, GC.getInvisibleInfo((InvisibleTypes)iI).getChar(), GC.getImprovementInfo((ImprovementTypes)iK).getTextKeyWide()));
				}
				if (iVisibleImprovementChange != 0)
				{
					szBuffer.append(pcNewline);
					szBuffer.append(gDLL->getText("TXT_KEY_PROMOHELP_INVISIBILITY_SPOT_PLOT_CHANGE", iVisibleImprovementChange, GC.getInvisibleInfo((InvisibleTypes)iI).getChar(), GC.getImprovementInfo((ImprovementTypes)iK).getTextKeyWide()));
				}
				if (iVisibleImprovementRangeChange != 0)
				{
					szBuffer.append(pcNewline);
					szBuffer.append(gDLL->getText("TXT_KEY_PROMOHELP_INVISIBILITY_SPOT_PLOT_RANGE_CHANGE", iVisibleImprovementRangeChange, GC.getInvisibleInfo((InvisibleTypes)iI).getChar(), GC.getImprovementInfo((ImprovementTypes)iK).getTextKeyWide()));
				}
				iInvisibleImprovementChange = 0;
				iVisibleImprovementChange = 0;
				iVisibleImprovementRangeChange = 0;
			}
		}
	}

	// AIAndy: Help display for increasing specific outcomes
	for (iI = 0; iI < GC.getNumOutcomeInfos(); iI++)
	{
		const CvOutcomeInfo& kOutcome = GC.getOutcomeInfo((OutcomeTypes)iI);

		int iExtraChancePromotion = 0;
		for( iJ = 0; iJ < (int)linePromotionsOwned.size(); iJ++ )
		{
			for (iK = 0; iK < kOutcome.getNumExtraChancePromotions(); iK++)
			{
				if (kOutcome.getExtraChancePromotion(iK) == linePromotionsOwned[iJ])
				{
					iExtraChancePromotion += kOutcome.getExtraChancePromotionChance(iK);
				}
			}
		}
		if (iExtraChancePromotion != 0)
		{
			szBuffer.append(pcNewline);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_OUTCOME_TEXT", iExtraChancePromotion, CvWString(kOutcome.getType()).GetCString(), kOutcome.getTextKeyWide()));
		}
	}

	//	This bit won't look terribly pretty - needs a little more work
	for( iI = 0; iI < (int)linePromotionsOwned.size(); iI++ )
	{
		GC.getPromotionInfo(linePromotionsOwned[iI]).getPropertyManipulators()->buildDisplayString(szBuffer);
	}

	if (GC.getPromotionInfo(ePromotion).getLevelPrereq() > 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_LEVEL_PREREQ_TEXT", GC.getPromotionInfo(ePromotion).getLevelPrereq()));
	}

	if (GC.getPromotionInfo(ePromotion).getHelp()[0] != '\0')
	{
		szBuffer.append(pcNewline);
		szBuffer.append(GC.getPromotionInfo(ePromotion).getHelp());
	}
}

//	Function:			parseCivicInfo()
//	Description:	Will parse the civic info help
//	Parameters:		szHelpText -- the text to put it into
//								civicInfo - what to parse
//	Returns:			nothing
void CvGameTextMgr::parseCivicInfo(CvWStringBuffer &szHelpText, CivicTypes eCivic, bool bCivilopediaText, bool bPlayerContext, bool bSkipName)
{
	PROFILE_FUNC();

	CvWString szFirstBuffer;
	bool bFound;
	bool bFirst;
	int iLast;
	int iI, iJ;

	if (NO_CIVIC == eCivic)
	{
		return;
	}

	szHelpText.clear();

	FAssert(GC.getGame().getActivePlayer() != NO_PLAYER || !bPlayerContext);

	if (!bSkipName)
	{
		szHelpText.append(GC.getCivicInfo(eCivic).getDescription());
	}

	if (!bCivilopediaText)
	{
		if (!bPlayerContext || !(GET_PLAYER(GC.getGame().getActivePlayer()).canDoCivics(eCivic)))
		{
			if (!bPlayerContext || !(GET_TEAM(GC.getGame().getActiveTeam()).isHasTech((TechTypes)(GC.getCivicInfo(eCivic).getTechPrereq()))))
			{
				if (GC.getCivicInfo(eCivic).getTechPrereq() != NO_TECH)
				{
					szHelpText.append(NEWLINE);
					szHelpText.append(gDLL->getText("TXT_KEY_CIVIC_REQUIRES", CvWString(GC.getTechInfo((TechTypes)GC.getCivicInfo(eCivic).getTechPrereq()).getType()).GetCString(), GC.getTechInfo((TechTypes)GC.getCivicInfo(eCivic).getTechPrereq()).getTextKeyWide()));
				}
			}
		}
	}

	// Special Building Not Required...
	for (iI = 0; iI < GC.getNumSpecialBuildingInfos(); ++iI)
	{
		if (GC.getCivicInfo(eCivic).isSpecialBuildingNotRequired(iI))
		{
			// XXX "Missionaries"??? - Now in XML
			szHelpText.append(NEWLINE);
			szHelpText.append(gDLL->getText("TXT_KEY_CIVIC_BUILD_MISSIONARIES", GC.getSpecialBuildingInfo((SpecialBuildingTypes)iI).getTextKeyWide()));
		}
	}
	if (GC.getCivicInfo(eCivic).IsFixedBorders() && GC.getGame().isOption(GAMEOPTION_FIXED_BORDERS))
	{
		szHelpText.append(NEWLINE);
		szHelpText.append(gDLL->getText("TXT_KEY_FIXED_BORDERS_CIVIC"));
	}

	// Valid Specialists...
	bFirst = true;

	for (iI = 0; iI < GC.getNumSpecialistInfos(); ++iI)
	{
		if (GC.getCivicInfo(eCivic).isSpecialistValid(iI))
		{
			szFirstBuffer.Format(L"%s%s", NEWLINE, gDLL->getText("TXT_KEY_CIVIC_UNLIMTED").c_str());
			CvWString szSpecialist;
			szSpecialist.Format(L"<link=%s>%s</link>", CvWString(GC.getSpecialistInfo((SpecialistTypes)iI).getType()).GetCString(), GC.getSpecialistInfo((SpecialistTypes)iI).getDescription());
			setListHelp(szHelpText, szFirstBuffer, szSpecialist, L", ", bFirst);
			bFirst = false;
		}
	}

	//	Great People Modifier...
	if (GC.getCivicInfo(eCivic).getGreatPeopleRateModifier() != 0)
	{
		szHelpText.append(NEWLINE);
		szHelpText.append(gDLL->getText("TXT_KEY_CIVIC_GREAT_PEOPLE_MOD", GC.getCivicInfo(eCivic).getGreatPeopleRateModifier()));
	}

	//	Great General Modifier...
	if (GC.getCivicInfo(eCivic).getGreatGeneralRateModifier() != 0)
	{
		szHelpText.append(NEWLINE);
		szHelpText.append(gDLL->getText("TXT_KEY_CIVIC_GREAT_GENERAL_MOD", GC.getCivicInfo(eCivic).getGreatGeneralRateModifier()));
	}

	if (GC.getCivicInfo(eCivic).getDomesticGreatGeneralRateModifier() != 0)
	{
		szHelpText.append(NEWLINE);
		szHelpText.append(gDLL->getText("TXT_KEY_DOMESTIC_GREAT_GENERAL_MODIFIER", GC.getCivicInfo(eCivic).getDomesticGreatGeneralRateModifier()));
	}

	//	State Religion Great People Modifier...
	if (GC.getCivicInfo(eCivic).getStateReligionGreatPeopleRateModifier() != 0)
	{
		if (bPlayerContext && (GET_PLAYER(GC.getGame().getActivePlayer()).getStateReligion() != NO_RELIGION))
		{
			szHelpText.append(NEWLINE);
			szHelpText.append(gDLL->getText("TXT_KEY_CIVIC_GREAT_PEOPLE_MOD_RELIGION", GC.getCivicInfo(eCivic).getStateReligionGreatPeopleRateModifier(), GC.getReligionInfo(GET_PLAYER(GC.getGame().getActivePlayer()).getStateReligion()).getChar()));
		}
		else
		{
			szHelpText.append(NEWLINE);
			szHelpText.append(gDLL->getText("TXT_KEY_CIVIC_GREAT_PEOPLE_MOD_STATE_RELIGION", GC.getCivicInfo(eCivic).getStateReligionGreatPeopleRateModifier(), gDLL->getSymbolID(RELIGION_CHAR)));
		}
	}

	//	Distance Maintenance Modifer...
	if (GC.getCivicInfo(eCivic).getDistanceMaintenanceModifier() != 0)
	{
		if (GC.getCivicInfo(eCivic).getDistanceMaintenanceModifier() <= -100)
		{
			szHelpText.append(NEWLINE);
			szHelpText.append(gDLL->getText("TXT_KEY_CIVIC_DISTANCE_MAINT"));
		}
		else
		{
			szHelpText.append(NEWLINE);
			szHelpText.append(gDLL->getText("TXT_KEY_CIVIC_DISTANCE_MAINT_MOD", GC.getCivicInfo(eCivic).getDistanceMaintenanceModifier()));
		}
		//Afforess: Actual civic effects
		if (bPlayerContext)
		{
			CvWString szTempBuffer;
			int iSaved = 0;
			foreach_(const CvCity* pLoopCity, GET_PLAYER(GC.getGame().getActivePlayer()).cities())
			{
				iSaved += pLoopCity->getDistanceMaintenanceSavedTimes100ByCivic(eCivic);
			}
			if (iSaved != 0)
			{
				szTempBuffer.Format(L" (%.2f %c)", (float)iSaved / 100, GC.getCommerceInfo(COMMERCE_GOLD).getChar());
				szHelpText.append(szTempBuffer.GetCString());
			}
		}
	}

	//	Num Cities Maintenance Modifer...
	if (GC.getCivicInfo(eCivic).getNumCitiesMaintenanceModifier() != 0)
	{
		if (GC.getCivicInfo(eCivic).getNumCitiesMaintenanceModifier() <= -100)
		{
			szHelpText.append(NEWLINE);
			szHelpText.append(gDLL->getText("TXT_KEY_CIVIC_NO_MAINT_NUM_CITIES"));
		}
		else
		{
			szHelpText.append(NEWLINE);
			szHelpText.append(gDLL->getText("TXT_KEY_CIVIC_NO_MAINT_NUM_CITIES_MOD", GC.getCivicInfo(eCivic).getNumCitiesMaintenanceModifier()));
		}
		//Afforess: Actual civic effects
		if (bPlayerContext)
		{
			CvWString szTempBuffer;
			int iSaved = 0;
			foreach_(const CvCity* pLoopCity, GET_PLAYER(GC.getGame().getActivePlayer()).cities())
			{
				iSaved += pLoopCity->getNumCitiesMaintenanceSavedTimes100ByCivic(eCivic);
			}
			if (iSaved != 0)
			{
				szTempBuffer.Format(L" (%.2f %c)", (float)iSaved / 100, GC.getCommerceInfo(COMMERCE_GOLD).getChar());
				szHelpText.append(szTempBuffer.GetCString());
			}
		}
	}

	if (GC.getGame().isOption(GAMEOPTION_REALISTIC_CORPORATIONS))
	{
		if (GC.getCivicInfo(eCivic).getRealCorporationMaintenanceModifier() < -100)
		{
			szHelpText.append(NEWLINE);
			szHelpText.append(gDLL->getText("TXT_KEY_CIVIC_CORPORATION_TAXES", abs( 100 + GC.getCivicInfo(eCivic).getRealCorporationMaintenanceModifier())));
		}
		else if (GC.getCivicInfo(eCivic).getRealCorporationMaintenanceModifier() > -100 && GC.getCivicInfo(eCivic).getRealCorporationMaintenanceModifier() != 0)
		{
			szHelpText.append(NEWLINE);
			szHelpText.append(gDLL->getText("TXT_KEY_CIVIC_SUBSIDY", 100 + GC.getCivicInfo(eCivic).getRealCorporationMaintenanceModifier()));
		}
	}
	else if (GC.getCivicInfo(eCivic).getCorporationMaintenanceModifier() != 0)
	{
		//	Corporations Maintenance Modifer...
		if (GC.getCivicInfo(eCivic).getCorporationMaintenanceModifier() <= -100)
		{
			szHelpText.append(NEWLINE);
			szHelpText.append(gDLL->getText("TXT_KEY_CIVIC_NO_MAINT_CORPORATION"));
		}
		else
		{
			szHelpText.append(NEWLINE);
			szHelpText.append(gDLL->getText("TXT_KEY_CIVIC_NO_MAINT_CORPORATION_MOD", GC.getCivicInfo(eCivic).getCorporationMaintenanceModifier()));
		}
	}

	if (GC.getCivicInfo(eCivic).getHomeAreaMaintenanceModifier() != 0)
	{
		szHelpText.append(NEWLINE);
		if (GC.getCivicInfo(eCivic).getHomeAreaMaintenanceModifier() <= -100)
		{
			szHelpText.append(gDLL->getText("TXT_KEY_CIVIC_HOME_AREA_MAINT"));
		}
		else
		{
			szHelpText.append(gDLL->getText("TXT_KEY_CIVIC_HOME_AREA_MAINT_MOD", GC.getCivicInfo(eCivic).getHomeAreaMaintenanceModifier()));
		}
		//Afforess: Actual civic effects
		if (bPlayerContext)
		{
			CvWString szTempBuffer;
			int iSaved = 0;
			foreach_(const CvCity* pLoopCity, GET_PLAYER(GC.getGame().getActivePlayer()).cities())
			{
				iSaved += pLoopCity->getHomeAreaMaintenanceSavedTimes100ByCivic(eCivic);
			}
			if (iSaved != 0)
			{
				szTempBuffer.Format(L" (%.2f %c)", (float)iSaved / 100, GC.getCommerceInfo(COMMERCE_GOLD).getChar());
				szHelpText.append(szTempBuffer.GetCString());
			}
		}
	}
	if (GC.getCivicInfo(eCivic).getOtherAreaMaintenanceModifier() != 0)
	{
		szHelpText.append(NEWLINE);
		if (GC.getCivicInfo(eCivic).getOtherAreaMaintenanceModifier() <= -100)
		{
			szHelpText.append(gDLL->getText("TXT_KEY_OVERSEAS_CITY_MAINT"));
		}
		else
		{
			szHelpText.append(gDLL->getText("TXT_KEY_OVERSEAS_CITY_MAINT_MOD", GC.getCivicInfo(eCivic).getOtherAreaMaintenanceModifier()));
		}
		//Afforess: Actual civic effects
		if (bPlayerContext)
		{
			CvWString szTempBuffer;
			int iSaved = 0;
			foreach_(const CvCity* pLoopCity, GET_PLAYER(GC.getGame().getActivePlayer()).cities())
			{
				iSaved += pLoopCity->getOtherAreaMaintenanceSavedTimes100ByCivic(eCivic);
			}
			if (iSaved != 0)
			{
				szTempBuffer.Format(L" (%.2f %c)", (float)iSaved / 100, GC.getCommerceInfo(COMMERCE_GOLD).getChar());
				szHelpText.append(szTempBuffer.GetCString());
			}
		}
	}
	//DPII < Maintenance Modifiers >
	//	Extra Health
	if (GC.getCivicInfo(eCivic).getExtraHealth() != 0)
	{
		szHelpText.append(NEWLINE);
		szHelpText.append(gDLL->getText("TXT_KEY_CIVIC_EXTRA_HEALTH", abs(GC.getCivicInfo(eCivic).getExtraHealth()), ((GC.getCivicInfo(eCivic).getExtraHealth() > 0) ? gDLL->getSymbolID(HEALTHY_CHAR): gDLL->getSymbolID(UNHEALTHY_CHAR))));
	}

	//	Free Experience
	if (GC.getCivicInfo(eCivic).getFreeExperience() != 0)
	{
		szHelpText.append(NEWLINE);
		szHelpText.append(gDLL->getText("TXT_KEY_CIVIC_FREE_XP", GC.getCivicInfo(eCivic).getFreeExperience()));
	}

	//	Worker speed modifier
	if (GC.getCivicInfo(eCivic).getWorkerSpeedModifier() != 0)
	{
		szHelpText.append(NEWLINE);
		szHelpText.append(gDLL->getText("TXT_KEY_CIVIC_WORKER_SPEED", GC.getCivicInfo(eCivic).getWorkerSpeedModifier()));
	}

	//	Improvement upgrade rate modifier
	if (GC.getCivicInfo(eCivic).getImprovementUpgradeRateModifier() != 0)
	{
		bFirst = true;

		for (iI = 0; iI < GC.getNumImprovementInfos(); ++iI)
		{
			if (GC.getImprovementInfo((ImprovementTypes)iI).getImprovementUpgrade() != NO_IMPROVEMENT)
			{
				szFirstBuffer.Format(L"%s%s", NEWLINE, gDLL->getText("TXT_KEY_CIVIC_IMPROVEMENT_UPGRADE", GC.getCivicInfo(eCivic).getImprovementUpgradeRateModifier()).c_str());
				CvWString szImprovement;
				szImprovement.Format(L"<link=%s>%s</link>", CvWString(GC.getImprovementInfo((ImprovementTypes)iI).getType()).GetCString(), GC.getImprovementInfo((ImprovementTypes)iI).getDescription());
				setListHelp(szHelpText, szFirstBuffer, szImprovement, L", ", bFirst);
				bFirst = false;
			}
		}
	}

	//	Military unit production modifier
	if (GC.getCivicInfo(eCivic).getMilitaryProductionModifier() != 0)
	{
		szHelpText.append(NEWLINE);
		szHelpText.append(gDLL->getText("TXT_KEY_CIVIC_MILITARY_PRODUCTION", GC.getCivicInfo(eCivic).getMilitaryProductionModifier()));
	}

	if (GC.getCivicInfo(eCivic).isEnablesMAD())
	{
		szHelpText.append(NEWLINE);
		szHelpText.append(gDLL->getText("TXT_KEY_BUILDING_ENABLES_MAD"));
	}

	// Free Civilian unit upkeep
	if (GC.getCivicInfo(eCivic).getFreeUnitUpkeepCivilian() != 0)
	{
		szHelpText.append(NEWLINE);
		szHelpText.append(gDLL->getText("TXT_KEY_HELPTEXT_UNIT_UPKEEP_FREE_CIVILIAN", GC.getCivicInfo(eCivic).getFreeUnitUpkeepCivilian()));
	}
	if (GC.getCivicInfo(eCivic).getFreeUnitUpkeepCivilianPopPercent() != 0)
	{
		if (bPlayerContext)
		{
			int iValue = 0;
			int iMod = GC.getCivicInfo(eCivic).getFreeUnitUpkeepCivilianPopPercent();
			if (iMod > 0)
			{
				iValue = GET_PLAYER(GC.getGame().getActivePlayer()).getTotalPopulation() * (100 + iMod);
			}
			else if (iMod < 0)
			{
				iValue =
					GET_PLAYER(GC.getGame().getActivePlayer()).getTotalPopulation() -
					GET_PLAYER(GC.getGame().getActivePlayer()).getTotalPopulation() * 100 / (100 - iMod);
			}
			szHelpText.append(NEWLINE);
			szHelpText.append(gDLL->getText("TXT_KEY_HELPTEXT_UNIT_UPKEEP_FREE_CIVILIAN_PER_POP",  iMod));
			szHelpText.append(gDLL->getText("TXT_KEY_HELPTEXT_UNIT_UPKEEP_FREE_PER_POP", CvWString::format(L"%.2f", iValue / 100.0).GetCString()));
		}
		else
		{
			szHelpText.append(NEWLINE);
			szHelpText.append(gDLL->getText("TXT_KEY_HELPTEXT_UNIT_UPKEEP_FREE_CIVILIAN_PER_POP_0", GC.getCivicInfo(eCivic).getFreeUnitUpkeepCivilianPopPercent()));
		}
	}
	// Free Military unit upkeep
	if (GC.getCivicInfo(eCivic).getFreeUnitUpkeepMilitary() != 0)
	{
		szHelpText.append(NEWLINE);
		szHelpText.append(gDLL->getText("TXT_KEY_HELPTEXT_UNIT_UPKEEP_FREE_MILITARY", GC.getCivicInfo(eCivic).getFreeUnitUpkeepMilitary()));
	}
	if (GC.getCivicInfo(eCivic).getFreeUnitUpkeepMilitaryPopPercent() != 0)
	{
		if (bPlayerContext)
		{
			int iValue = 0;
			int iMod = GC.getCivicInfo(eCivic).getFreeUnitUpkeepMilitaryPopPercent();
			if (iMod > 0)
			{
				iValue = GET_PLAYER(GC.getGame().getActivePlayer()).getTotalPopulation() * (100 + iMod);
			}
			else if (iMod < 0)
			{
				iValue =
					GET_PLAYER(GC.getGame().getActivePlayer()).getTotalPopulation() -
					GET_PLAYER(GC.getGame().getActivePlayer()).getTotalPopulation() * 100 / (100 - iMod);
			}
			szHelpText.append(NEWLINE);
			szHelpText.append(gDLL->getText("TXT_KEY_HELPTEXT_UNIT_UPKEEP_FREE_MILITARY_PER_POP",  iMod));
			szHelpText.append(gDLL->getText("TXT_KEY_HELPTEXT_UNIT_UPKEEP_FREE_PER_POP", CvWString::format(L"%.2f", iValue / 100.0).GetCString()));
		}
		else
		{
			szHelpText.append(NEWLINE);
			szHelpText.append(gDLL->getText("TXT_KEY_HELPTEXT_UNIT_UPKEEP_FREE_MILITARY_PER_POP", GC.getCivicInfo(eCivic).getFreeUnitUpkeepMilitaryPopPercent()));
		}
	}

	//	Happiness per military unit
	if (GC.getCivicInfo(eCivic).getHappyPerMilitaryUnit() != 0)
	{
		szHelpText.append(NEWLINE);
		szHelpText.append(gDLL->getText("TXT_KEY_CIVIC_UNIT_HAPPINESS", abs(GC.getCivicInfo(eCivic).getHappyPerMilitaryUnit()), ((GC.getCivicInfo(eCivic).getHappyPerMilitaryUnit() > 0) ? gDLL->getSymbolID(HAPPY_CHAR) : gDLL->getSymbolID(UNHAPPY_CHAR))));
	}

	//	Military units produced with food
	if (GC.getCivicInfo(eCivic).isMilitaryFoodProduction())
	{
		szHelpText.append(NEWLINE);
		szHelpText.append(gDLL->getText("TXT_KEY_CIVIC_MILITARY_FOOD"));
	}

	//	Conscription
	if (getWorldSizeMaxConscript(eCivic) != 0)
	{
		szHelpText.append(NEWLINE);
		szHelpText.append(gDLL->getText("TXT_KEY_CIVIC_CONSCRIPTION", getWorldSizeMaxConscript(eCivic)));
	}

	//	Population Unhealthiness
	if (GC.getCivicInfo(eCivic).isNoUnhealthyPopulation())
	{
		szHelpText.append(NEWLINE);
		szHelpText.append(gDLL->getText("TXT_KEY_CIVIC_NO_POP_UNHEALTHY"));
	}

	//	Building Unhealthiness
	if (GC.getCivicInfo(eCivic).isBuildingOnlyHealthy())
	{
		szHelpText.append(NEWLINE);
		szHelpText.append(gDLL->getText("TXT_KEY_CIVIC_NO_BUILDING_UNHEALTHY"));
	}

	//	Population Unhealthiness
	if (0 != GC.getCivicInfo(eCivic).getExpInBorderModifier())
	{
		szHelpText.append(NEWLINE);
		szHelpText.append(gDLL->getText("TXT_KEY_CIVIC_EXPERIENCE_IN_BORDERS", GC.getCivicInfo(eCivic).getExpInBorderModifier()));
	}

/************************************************************************************************/
/* REVDCM								 02/16/10								phungus420	*/
/*																							  */
/* RevCivic Effects																			 */
/************************************************************************************************/
	if (GC.getCivicInfo(eCivic).isUpgradeAnywhere())
	{
		szHelpText.append(NEWLINE);
		szHelpText.append(gDLL->getText("TXT_KEY_CAN_UPGRADE_ANYWHERE"));
	}

	if (GC.getGame().isOption(GAMEOPTION_INQUISITIONS))
	{
		if (GC.getCivicInfo(eCivic).isAllowInquisitions())
		{
			szHelpText.append(NEWLINE);
			szHelpText.append(gDLL->getText("TXT_KEY_CIVIC_ALLOW_INQUISITONS"));
		}
	}

	if (GC.getGame().isOption(GAMEOPTION_INQUISITIONS))
	{
		if (GC.getCivicInfo(eCivic).isDisallowInquisitions())
		{
			szHelpText.append(NEWLINE);
			szHelpText.append(gDLL->getText("TXT_KEY_CIVIC_DISALLOW_INQUISITONS"));
		}
	}

//Team Project (5)
	if (GC.getGame().isOption(GAMEOPTION_RELIGIOUS_DISABLING))
	{
		// All Religions active
		if (GC.getCivicInfo(eCivic).isAllReligionsActive())
		{
			szHelpText.append(NEWLINE);
			szHelpText.append(gDLL->getText("TXT_KEY_ALL_RELIGIONS_ACTIVE"));
		}
		if (GC.getCivicInfo(eCivic).isBansNonStateReligions())
		{
			szHelpText.append(NEWLINE);
			szHelpText.append(gDLL->getText("TXT_KEY_BANS_NON_STATE_RELIGIONS"));
		}
	}

	if (GC.getCivicInfo(eCivic).isFreedomFighter())
	{
		szHelpText.append(NEWLINE);
		szHelpText.append(gDLL->getText("TXT_KEY_FREEDOM_FIGHTER"));
	}
//Team Project (3)
	//Capture Probabilities
	if (GC.getCivicInfo(eCivic).getNationalCaptureProbabilityModifier() != 0)
	{
		szHelpText.append(NEWLINE);
		szHelpText.append(gDLL->getText("TXT_KEY_NATIONAL_CAPTURE_PROBABILITY_MODIFIER", GC.getCivicInfo(eCivic).getNationalCaptureProbabilityModifier()));
	}
	if (GC.getCivicInfo(eCivic).getNationalCaptureResistanceModifier() != 0)
	{
		szHelpText.append(NEWLINE);
		szHelpText.append(gDLL->getText("TXT_KEY_NATIONAL_CAPTURE_RESISTANCE_MODIFIER", GC.getCivicInfo(eCivic).getNationalCaptureResistanceModifier()));
	}

	if (GC.getGame().isOption(GAMEOPTION_REVOLUTION))
	{
		if (GC.getGame().getActivePlayer() != NO_PLAYER && GET_PLAYER(GC.getGame().getActivePlayer()).isModderOption(MODDEROPTION_SHOW_REV_EFFECTS))
		{
			//  Revolution Local Civic Index Modifiers
			if (0 != GC.getCivicInfo(eCivic).getRevIdxLocal())
			{
				if ( GC.getCivicInfo(eCivic).getRevIdxLocal() > 0 )
				{
					szHelpText.append(NEWLINE);
					szHelpText.append(gDLL->getText("TXT_KEY_CIVIC_REV_INDEX_LOCAL_PENALTY", GC.getCivicInfo(eCivic).getRevIdxLocal()));
				}
				if ( GC.getCivicInfo(eCivic).getRevIdxLocal() < 0 )
				{
					szHelpText.append(NEWLINE);
					szHelpText.append(gDLL->getText("TXT_KEY_CIVIC_REV_INDEX_LOCAL_BONUS", abs(GC.getCivicInfo(eCivic).getRevIdxLocal())));
				}
			}

			//  Revolution National Civic Index Modifiers
			if (0 != GC.getCivicInfo(eCivic).getRevIdxNational())
			{
				if ( GC.getCivicInfo(eCivic).getRevIdxNational() > 0 )
				{
					szHelpText.append(NEWLINE);
					szHelpText.append(gDLL->getText("TXT_KEY_CIVIC_REV_INDEX_NATIONAL_PENALTY", GC.getCivicInfo(eCivic).getRevIdxNational()));
				}
				if ( GC.getCivicInfo(eCivic).getRevIdxNational() < 0 )
				{
					szHelpText.append(NEWLINE);
					szHelpText.append(gDLL->getText("TXT_KEY_CIVIC_REV_INDEX_NATIONAL_BONUS", abs(GC.getCivicInfo(eCivic).getRevIdxNational())));
				}
			}

			//  Revolution Good Holy City Modifier
			if (0 != GC.getCivicInfo(eCivic).getRevIdxHolyCityGood())
			{
				szHelpText.append(NEWLINE);
				szHelpText.append(gDLL->getText("TXT_KEY_CIVIC_REV_GOOD_HOLY_CITY", GC.getCivicInfo(eCivic).getRevIdxHolyCityGood()));
			}

			//  Revolution Bad Holy City Modifier
			if (0 != GC.getCivicInfo(eCivic).getRevIdxHolyCityBad())
			{
				szHelpText.append(NEWLINE);
				szHelpText.append(gDLL->getText("TXT_KEY_CIVIC_REV_BAD_HOLY_CITY", GC.getCivicInfo(eCivic).getRevIdxHolyCityBad()));
			}

			//  Revolution Switch to Modifier
			if (0 != GC.getCivicInfo(eCivic).getRevIdxSwitchTo())
			{
				if (GC.getCivicInfo(eCivic).getRevIdxSwitchTo() < 0)
				{
					szHelpText.append(NEWLINE);
					szHelpText.append(gDLL->getText("TXT_KEY_CIVIC_REV_SWITCH_TO_BONUS", abs(GC.getCivicInfo(eCivic).getRevIdxSwitchTo())));
				}
				if (GC.getCivicInfo(eCivic).getRevIdxSwitchTo() > 0)
				{
					szHelpText.append(NEWLINE);
					szHelpText.append(gDLL->getText("TXT_KEY_CIVIC_REV_SWITCH_TO_PENALTY", GC.getCivicInfo(eCivic).getRevIdxSwitchTo()));
				}
			}

			//  Revolution Nationality Modifier
			if (0 != GC.getCivicInfo(eCivic).getRevIdxNationalityMod())
			{
				if ( GC.getCivicInfo(eCivic).getRevIdxNationalityMod() < 0)
				{
					szHelpText.append(NEWLINE);
					CvWString szTempBuffer;
					szTempBuffer.Format(L"%.0f", 100 * GC.getCivicInfo(eCivic).getRevIdxNationalityMod());
					szHelpText.append(gDLL->getText("TXT_KEY_CIVIC_REV_NATIONALITY_REDUCTION_MOD", szTempBuffer.GetCString()));
				}
				if ( GC.getCivicInfo(eCivic).getRevIdxNationalityMod() > 0)
				{
					szHelpText.append(NEWLINE);
					CvWString szTempBuffer;
					szTempBuffer.Format(L"%.0f", 100 * GC.getCivicInfo(eCivic).getRevIdxNationalityMod());
					szHelpText.append(gDLL->getText("TXT_KEY_CIVIC_REV_NATIONALITY_INCREASE_MOD", szTempBuffer.GetCString()));
				}
			}

			//  Revolution Bad Religion Modifier
			if (0 != GC.getCivicInfo(eCivic).getRevIdxBadReligionMod())
			{
				szHelpText.append(NEWLINE);
				CvWString szTempBuffer;
				szTempBuffer.Format(L"%.0f", 100 * GC.getCivicInfo(eCivic).getRevIdxBadReligionMod());
				szHelpText.append(gDLL->getText("TXT_KEY_CIVIC_REV_BAD_RELIGION_MOD", szTempBuffer.GetCString()));
			}

			//  Revolution Good Religion Modifier
			if (0 != GC.getCivicInfo(eCivic).getRevIdxGoodReligionMod())
			{
				szHelpText.append(NEWLINE);
				CvWString szTempBuffer;
				szTempBuffer.Format(L"%.0f", 100 * GC.getCivicInfo(eCivic).getRevIdxGoodReligionMod());
				szHelpText.append(gDLL->getText("TXT_KEY_CIVIC_REV_GOOD_RELIGION_MOD", szTempBuffer.GetCString()));
			}

			//  Revolution City Distance Modifier
			if (0 != GC.getCivicInfo(eCivic).getRevIdxDistanceModifier())
			{
				if ( GC.getCivicInfo(eCivic).getRevIdxDistanceModifier() < 0 )
				{
					szHelpText.append(NEWLINE);
					szHelpText.append(gDLL->getText("TXT_KEY_CIVIC_CITY_DISTANCE_GOOD_MOD", GC.getCivicInfo(eCivic).getRevIdxDistanceModifier()));
				}
				if ( GC.getCivicInfo(eCivic).getRevIdxDistanceModifier() > 0 )
				{
					szHelpText.append(NEWLINE);
					szHelpText.append(gDLL->getText("TXT_KEY_CIVIC_CITY_DISTANCE_BAD_MOD", abs(GC.getCivicInfo(eCivic).getRevIdxDistanceModifier())));
				}
			}

			if (0 != GC.getCivicInfo(eCivic).getRevReligiousFreedom())
			{
				if ( GC.getCivicInfo(eCivic).getRevReligiousFreedom() < 0 )
				{
					szHelpText.append(NEWLINE);
					szHelpText.append(gDLL->getText("TXT_KEY_CIVIC_REV_RELIGION_OPRESSION", GC.getCivicInfo(eCivic).getRevReligiousFreedom()));
				}
				if ( GC.getCivicInfo(eCivic).getRevReligiousFreedom() > 0 )
				{
					szHelpText.append(NEWLINE);
					szHelpText.append(gDLL->getText("TXT_KEY_CIVIC_REV_RELIGION_FREEDOM", GC.getCivicInfo(eCivic).getRevReligiousFreedom()));
				}
			}


			//  Revolution Labor Modifier
			if (0 != GC.getCivicInfo(eCivic).getRevLaborFreedom())
			{
					szHelpText.append(NEWLINE);
					szHelpText.append(gDLL->getText("TXT_KEY_CIVIC_REV_LABOR", GC.getCivicInfo(eCivic).getRevLaborFreedom()));
			}


			//  Revolution Environment Modifier
			if (0 != GC.getCivicInfo(eCivic).getRevEnvironmentalProtection())
			{
					szHelpText.append(NEWLINE);
					szHelpText.append(gDLL->getText("TXT_KEY_CIVIC_REV_ENVIRONMENT", GC.getCivicInfo(eCivic).getRevEnvironmentalProtection()));
			}


			//  Revolution Democracy Modifier
			if (0 != GC.getCivicInfo(eCivic).getRevDemocracyLevel())
			{
					szHelpText.append(NEWLINE);
					szHelpText.append(gDLL->getText("TXT_KEY_CIVIC_REV_DEMOCRACY", GC.getCivicInfo(eCivic).getRevDemocracyLevel()));
			}
		}
		else
		{
			if ( GC.getCivicInfo(eCivic).getRevIdxLocal() > 0 )
			{
				//szHelpText.append(NEWLINE);
				szHelpText.append(gDLL->getText("TXT_KEY_INCREASE_LOCAL_REBELS", GC.getCivicInfo(eCivic).getRevIdxLocal()));
			}
			else if (GC.getCivicInfo(eCivic).getRevIdxLocal() < 0 )
			{
				//szHelpText.append(NEWLINE);
				szHelpText.append(gDLL->getText("TXT_KEY_DECREASE_LOCAL_REBELS", GC.getCivicInfo(eCivic).getRevIdxLocal()));
			}
			if ( GC.getCivicInfo(eCivic).getRevIdxNational() > 0 )
			{
				//szHelpText.append(NEWLINE);
				szHelpText.append(gDLL->getText("TXT_KEY_INCREASE_NATIONAL_REBELS", GC.getCivicInfo(eCivic).getRevIdxNational()));
			}
			else if ( GC.getCivicInfo(eCivic).getRevIdxNational() < 0 )
			{
				//szHelpText.append(NEWLINE);
				szHelpText.append(gDLL->getText("TXT_KEY_DECREASE_NATIONAL_REBELS", GC.getCivicInfo(eCivic).getRevIdxNational()));
			}
			if ( GC.getCivicInfo(eCivic).getRevIdxHolyCityGood() > 0 )
			{
				//szHelpText.append(NEWLINE);
				szHelpText.append(gDLL->getText("TXT_KEY_STATE_RELIGION_WITH_HOLY_CITY", GC.getCivicInfo(eCivic).getRevIdxHolyCityGood()));
			}
			if ( GC.getCivicInfo(eCivic).getRevIdxHolyCityBad() > 0 )
			{
				//szHelpText.append(NEWLINE);
				szHelpText.append(gDLL->getText("TXT_KEY_STATE_RELIGION_WITHOUT_HOLY_CITY", GC.getCivicInfo(eCivic).getRevIdxHolyCityBad()));
			}
		}
	}
	// RevolutionDCM - End Revolution Civic Expose

	//	War Weariness
	if (GC.getCivicInfo(eCivic).getWarWearinessModifier() != 0)
	{
		if (GC.getCivicInfo(eCivic).getWarWearinessModifier() <= -100)
		{
			szHelpText.append(NEWLINE);
			szHelpText.append(gDLL->getText("TXT_KEY_CIVIC_NO_WAR_WEARINESS"));
		}
		else
		{
			szHelpText.append(NEWLINE);
			szHelpText.append(gDLL->getText("TXT_KEY_CIVIC_EXTRA_WAR_WEARINESS", GC.getCivicInfo(eCivic).getWarWearinessModifier()));
		}
	}

	//	Free specialists
	if (GC.getCivicInfo(eCivic).getFreeSpecialist() != 0)
	{
		szHelpText.append(NEWLINE);
		szHelpText.append(gDLL->getText("TXT_KEY_CIVIC_FREE_SPECIALISTS", GC.getCivicInfo(eCivic).getFreeSpecialist()));
	}

	//	Trade routes
	if (GC.getCivicInfo(eCivic).getTradeRoutes() != 0)
	{
		szHelpText.append(NEWLINE);
		szHelpText.append(gDLL->getText("TXT_KEY_CIVIC_TRADE_ROUTES", GC.getCivicInfo(eCivic).getTradeRoutes()));
	}

	if (GC.getCivicInfo(eCivic).getForeignTradeRouteModifier() != 0)
	{
		szHelpText.append(NEWLINE);
		szHelpText.append(gDLL->getText("TXT_KEY_CIVIC_FOREIGN_TRADE_ROUTE_MOD", GC.getCivicInfo(eCivic).getForeignTradeRouteModifier()));
	}

	if (GC.getCivicInfo(eCivic).getDistantUnitSupportCostModifier() > 0)
	{
		szHelpText.append(NEWLINE);
		szHelpText.append(gDLL->getText("TXT_KEY_CIVIC_DISTANT_UNIT_SUPPLY_COST_MOD", GC.getCivicInfo(eCivic).getDistantUnitSupportCostModifier()));
	}

	else if (GC.getCivicInfo(eCivic).getDistantUnitSupportCostModifier() < 0)
	{
		szHelpText.append(NEWLINE);
		szHelpText.append(gDLL->getText("TXT_KEY_CIVIC_DISTANT_UNIT_SUPPLY_COST_MOD_DECREASE", GC.getCivicInfo(eCivic).getDistantUnitSupportCostModifier()));
	}

	if (GC.getCivicInfo(eCivic).getExtraCityDefense() != 0)
	{
		szHelpText.append(NEWLINE);
		szHelpText.append(gDLL->getText("TXT_KEY_CIVIC_CITY_DEFENSE_MOD", GC.getCivicInfo(eCivic).getExtraCityDefense()));
	}

	if (GC.getCivicInfo(eCivic).getFreedomFighterChange() != 0)
	{
		szHelpText.append(NEWLINE);
		szHelpText.append(gDLL->getText("TXT_KEY_FREEDOM_FIGHTER_CHANGE", GC.getCivicInfo(eCivic).getFreedomFighterChange()));
	}

	//	No Foreign Trade
	if (GC.getCivicInfo(eCivic).isNoForeignTrade())
	{
		szHelpText.append(NEWLINE);
		szHelpText.append(gDLL->getText("TXT_KEY_CIVIC_NO_FOREIGN_TRADE"));
	}

	//	No Corporations
	if (GC.getCivicInfo(eCivic).isNoCorporations())
	{
		szHelpText.append(NEWLINE);
		szHelpText.append(gDLL->getText("TXT_KEY_CIVIC_NO_CORPORATIONS"));
	}

	//	No Foreign Corporations
	if (GC.getCivicInfo(eCivic).isNoForeignCorporations())
	{
		szHelpText.append(NEWLINE);
		szHelpText.append(gDLL->getText("TXT_KEY_CIVIC_NO_FOREIGN_CORPORATIONS"));

		if (GC.getGame().isOption(GAMEOPTION_REALISTIC_CORPORATIONS))
		{
			szHelpText.append(NEWLINE);
			szHelpText.append(gDLL->getText("TXT_KEY_CIVIC_ALLOWS_USE_OF_EXECUTIVES"));
		}
	}

	int iValue = GC.getCivicInfo(eCivic).getCivicPercentAnger();
	if (iValue != 0)
	{
		if (iValue > 0)
		{
			szHelpText.append(NEWLINE);
			szHelpText.append(gDLL->getText("TXT_KEY_CIVIC_FREEDOM_ANGER", iValue));
		}

		else
		{
			szHelpText.append(NEWLINE);
			szHelpText.append(gDLL->getText("TXT_KEY_CIVIC_FREEDOM_HAPPINESS", -iValue));
		}
	}

	if (!(GC.getCivicInfo(eCivic).isStateReligion()))
	{
		bFound = false;

		for (iI = 0; iI < GC.getNumCivicInfos(); ++iI)
		{
			if ((GC.getCivicInfo((CivicTypes) iI).getCivicOptionType() == GC.getCivicInfo(eCivic).getCivicOptionType()) && (GC.getCivicInfo((CivicTypes) iI).isStateReligion()))
			{
				bFound = true;
			}
		}

		if (bFound)
		{
			szHelpText.append(NEWLINE);
			szHelpText.append(gDLL->getText("TXT_KEY_CIVIC_NO_STATE_RELIGION"));
		}
	}

	if (GC.getCivicInfo(eCivic).getStateReligionHappiness() != 0)
	{
		if (bPlayerContext && (GET_PLAYER(GC.getGame().getActivePlayer()).getStateReligion() != NO_RELIGION))
		{
			szHelpText.append(NEWLINE);
			szHelpText.append(gDLL->getText("TXT_KEY_CIVIC_STATE_RELIGION_HAPPINESS", abs(GC.getCivicInfo(eCivic).getStateReligionHappiness()), ((GC.getCivicInfo(eCivic).getStateReligionHappiness() > 0) ? gDLL->getSymbolID(HAPPY_CHAR) : gDLL->getSymbolID(UNHAPPY_CHAR)), GC.getReligionInfo(GET_PLAYER(GC.getGame().getActivePlayer()).getStateReligion()).getChar()));
		}
		else
		{
			szHelpText.append(NEWLINE);
			szHelpText.append(gDLL->getText("TXT_KEY_CIVIC_RELIGION_HAPPINESS", abs(GC.getCivicInfo(eCivic).getStateReligionHappiness()), ((GC.getCivicInfo(eCivic).getStateReligionHappiness() > 0) ? gDLL->getSymbolID(HAPPY_CHAR) : gDLL->getSymbolID(UNHAPPY_CHAR))));
		}
	}

	if (GC.getCivicInfo(eCivic).getNonStateReligionHappiness() != 0)
	{
/************************************************************************************************/
/* UNOFFICIAL_PATCH					   08/28/09				  EmperorFool & jdog5000	  */
/*																							  */
/* Bugfix																					   */
/************************************************************************************************/
/* original bts code
		if (GC.getCivicInfo(eCivic).isStateReligion())
		{
			szHelpText.append(NEWLINE);
			szHelpText.append(gDLL->getText("TXT_KEY_CIVIC_NON_STATE_REL_HAPPINESS_NO_STATE"));
		}
		else
		{
			szHelpText.append(NEWLINE);
			szHelpText.append(gDLL->getText("TXT_KEY_CIVIC_NON_STATE_REL_HAPPINESS_WITH_STATE", abs(GC.getCivicInfo(eCivic).getNonStateReligionHappiness()), ((GC.getCivicInfo(eCivic).getNonStateReligionHappiness() > 0) ? gDLL->getSymbolID(HAPPY_CHAR) : gDLL->getSymbolID(UNHAPPY_CHAR))));
		}
*/
		if (!GC.getCivicInfo(eCivic).isStateReligion())
		{
			szHelpText.append(NEWLINE);
			szHelpText.append(gDLL->getText("TXT_KEY_CIVIC_NON_STATE_REL_HAPPINESS_NO_STATE", abs(GC.getCivicInfo(eCivic).getNonStateReligionHappiness()), ((GC.getCivicInfo(eCivic).getNonStateReligionHappiness() > 0) ? gDLL->getSymbolID(HAPPY_CHAR) : gDLL->getSymbolID(UNHAPPY_CHAR))));
		}
		else
		{
			szHelpText.append(NEWLINE);
			szHelpText.append(gDLL->getText("TXT_KEY_CIVIC_NON_STATE_REL_HAPPINESS_WITH_STATE", abs(GC.getCivicInfo(eCivic).getNonStateReligionHappiness()), ((GC.getCivicInfo(eCivic).getNonStateReligionHappiness() > 0) ? gDLL->getSymbolID(HAPPY_CHAR) : gDLL->getSymbolID(UNHAPPY_CHAR))));
		}
/************************************************************************************************/
/* UNOFFICIAL_PATCH						END												  */
/************************************************************************************************/
	}

	//	State Religion Unit Production Modifier
	if (GC.getCivicInfo(eCivic).getStateReligionUnitProductionModifier() != 0)
	{
		if (bPlayerContext && (GET_PLAYER(GC.getGame().getActivePlayer()).getStateReligion() != NO_RELIGION))
		{
			szHelpText.append(NEWLINE);
			szHelpText.append(gDLL->getText("TXT_KEY_CIVIC_REL_TRAIN", GC.getReligionInfo(GET_PLAYER(GC.getGame().getActivePlayer()).getStateReligion()).getChar(), GC.getCivicInfo(eCivic).getStateReligionUnitProductionModifier()));
		}
		else
		{
			szHelpText.append(NEWLINE);
			szHelpText.append(gDLL->getText("TXT_KEY_CIVIC_STATE_REL_TRAIN", GC.getCivicInfo(eCivic).getStateReligionUnitProductionModifier()));
		}
	}

	//	State Religion Building Production Modifier
	if (GC.getCivicInfo(eCivic).getStateReligionBuildingProductionModifier() != 0)
	{
		if (bPlayerContext && (GET_PLAYER(GC.getGame().getActivePlayer()).getStateReligion() != NO_RELIGION))
		{
			szHelpText.append(NEWLINE);
			szHelpText.append(gDLL->getText("TXT_KEY_CIVIC_REL_BUILDING", GC.getReligionInfo(GET_PLAYER(GC.getGame().getActivePlayer()).getStateReligion()).getChar(), GC.getCivicInfo(eCivic).getStateReligionBuildingProductionModifier()));
		}
		else
		{
			szHelpText.append(NEWLINE);
			szHelpText.append(gDLL->getText("TXT_KEY_CIVIC_STATE_REL_BUILDING", GC.getCivicInfo(eCivic).getStateReligionBuildingProductionModifier()));
		}
	}

	//	State Religion Free Experience
	if (GC.getCivicInfo(eCivic).getStateReligionFreeExperience() != 0)
	{
		if (bPlayerContext && (GET_PLAYER(GC.getGame().getActivePlayer()).getStateReligion() != NO_RELIGION))
		{
			szHelpText.append(NEWLINE);
			szHelpText.append(gDLL->getText("TXT_KEY_CIVIC_REL_FREE_XP", GC.getCivicInfo(eCivic).getStateReligionFreeExperience(), GC.getReligionInfo(GET_PLAYER(GC.getGame().getActivePlayer()).getStateReligion()).getChar()));
		}
		else
		{
			szHelpText.append(NEWLINE);
			szHelpText.append(gDLL->getText("TXT_KEY_CIVIC_STATE_REL_FREE_XP", GC.getCivicInfo(eCivic).getStateReligionFreeExperience()));
		}
	}

	if (GC.getCivicInfo(eCivic).isNoNonStateReligionSpread())
	{
		szHelpText.append(NEWLINE);
		szHelpText.append(gDLL->getText("TXT_KEY_CIVIC_NO_NON_STATE_SPREAD"));
	}

	const CvCivicInfo& kCivic = GC.getCivicInfo(eCivic);
	if (kCivic.getReligionSpreadRate() > 0)
	{
		szHelpText.append(NEWLINE);
		szHelpText.append(gDLL->getText("TXT_KEY_CIVIC_RELIGION_SPREAD_RATE_FAST", kCivic.getReligionSpreadRate()));
	}

	else if (kCivic.getReligionSpreadRate() < 0 && kCivic.getReligionSpreadRate() > -100)
	{
		szHelpText.append(NEWLINE);
		szHelpText.append(gDLL->getText("TXT_KEY_CIVIC_RELIGION_SPREAD_RATE_SLOW", (100 + kCivic.getReligionSpreadRate())));
	}

	else if (kCivic.getReligionSpreadRate() < -100)
	{
		szHelpText.append(NEWLINE);
		szHelpText.append(gDLL->getText("TXT_KEY_CIVIC_RELIGION_NO_SPREAD"));
	}

	if (kCivic.getPopulationgrowthratepercentage() > 0)
	{
		szHelpText.append(NEWLINE);
		szHelpText.append(gDLL->getText("TXT_KEY_BUILDING_CITY_SLOW_GROWTH_SPEED", kCivic.getPopulationgrowthratepercentage()));
	}
	else if (kCivic.getPopulationgrowthratepercentage() < 0)
	{
		szHelpText.append(NEWLINE);
		szHelpText.append(gDLL->getText("TXT_KEY_BUILDING_CITY_FAST_GROWTH_SPEED", kCivic.getPopulationgrowthratepercentage()));
	}

	if (kCivic.isNoCapitalUnhappiness())
	{
		szHelpText.append(NEWLINE);
		szHelpText.append(gDLL->getText("TXT_KEY_CIVIC_NO_CAPITAL_ANGER"));
	}

	if (kCivic.getTaxRateUnhappiness() > 0)
	{
		//This is to round it to the nearest 5%.
		int iTaxRate = abs((100 / kCivic.getTaxRateUnhappiness()));
		if ((iTaxRate % 5) > 2)
			iTaxRate += 5 - (iTaxRate % 5);
		szHelpText.append(NEWLINE);
		szHelpText.append(gDLL->getText("TXT_KEY_CIVIC_TAXATION_ANGER", iTaxRate));
	}

	if (kCivic.getCivicHappiness() != 0)
	{
		if (kCivic.getCivicHappiness() > 0)
		{
			szHelpText.append(NEWLINE);
			szHelpText.append(gDLL->getText("TXT_KEY_CIVIC_HAPPINESS", abs(kCivic.getCivicHappiness()), ((kCivic.getCivicHappiness() > 0) ? gDLL->getSymbolID(HAPPY_CHAR) : gDLL->getSymbolID(UNHAPPY_CHAR))));
		}
		else
		{
			szHelpText.append(NEWLINE);
			szHelpText.append(gDLL->getText("TXT_KEY_CIVIC_UNHAPPINESS", abs(kCivic.getCivicHappiness()), ((kCivic.getCivicHappiness() > 0) ? gDLL->getSymbolID(HAPPY_CHAR) : gDLL->getSymbolID(UNHAPPY_CHAR))));
		}
	}

	if (kCivic.getCityLimit(GC.getGame().getActivePlayer()) > 0)
	{
		szHelpText.append(NEWLINE);

		if (kCivic.getCityOverLimitUnhappy() > 0)
		{
			szHelpText.append(gDLL->getText("TXT_KEY_CIVIC_SOFT_CITY_LIMIT", kCivic.getCityLimit(GC.getGame().getActivePlayer()), kCivic.getCityOverLimitUnhappy()));
		}
		else
		{
			szHelpText.append(gDLL->getText("TXT_KEY_CIVIC_CITY_LIMIT", kCivic.getCityLimit(GC.getGame().getActivePlayer())));
		}
	}

	if (kCivic.getForeignerUnhappyPercent() > 0) {
		szHelpText.append(NEWLINE);
		szHelpText.append(gDLL->getText("TXT_KEY_CIVIC_FOREIGNER_ANGER", 1, (100 / kCivic.getForeignerUnhappyPercent())));
	}

	if (bCivilopediaText || GC.getGame().isOption(GAMEOPTION_ADVANCED_ECONOMY))
	{
		if (kCivic.getInflationModifier() != 0)
		{
			if (kCivic.getInflationModifier() == -100)
			{
				szHelpText.append(NEWLINE);
				szHelpText.append(gDLL->getText("TXT_KEY_NO_INFLATION"));
			}
			else
			{
				szHelpText.append(NEWLINE);
				szHelpText.append(gDLL->getText("TXT_KEY_ADJUSTS_INFLATION", kCivic.getInflationModifier()));
			}
		}

		/* if (kCivic.isChooseCurrency() != 0)
		{
			szHelpText.append(NEWLINE);
			szHelpText.append(gDLL->getText("TXT_KEY_CIVIC_CHOOSE_CURRENCY"));
		} */

		if (kCivic.getHurryCostModifier() != 0)
		{
			szHelpText.append(NEWLINE);
			szHelpText.append(gDLL->getText("TXT_KEY_BUILDING_HURRY_MOD", kCivic.getHurryCostModifier()));
		}

		if (kCivic.getHurryInflationModifier() > 0)
		{
			szHelpText.append(NEWLINE);
			szHelpText.append(gDLL->getText("TXT_KEY_HURRY_INFLATION_MOD_MORE", kCivic.getHurryInflationModifier()));
		}
		else if (kCivic.getHurryInflationModifier() < 0)
		{
			szHelpText.append(NEWLINE);
			szHelpText.append(gDLL->getText("TXT_KEY_HURRY_INFLATION_MOD_LESS", kCivic.getHurryInflationModifier()));
		}

		if (kCivic.getSharedCivicTradeRouteModifier() != 0)
		{
			szHelpText.append(NEWLINE);
			szHelpText.append(gDLL->getText("TXT_KEY_SHARED_CIVIC_TRADE_MOD", kCivic.getSharedCivicTradeRouteModifier()));
		}
	}

	if (bCivilopediaText || GC.getGame().isOption(GAMEOPTION_PERSONALIZED_MAP))
	{
		if (kCivic.getLandmarkHappiness() > 0)
		{
			szHelpText.append(NEWLINE);
			szHelpText.append(gDLL->getText("TXT_KEY_CIVIC_LANDMARK_HAPPINESS", kCivic.getLandmarkHappiness()));
		}

		if (kCivic.getLandmarkHappiness() < 0)
		{
			szHelpText.append(NEWLINE);
			szHelpText.append(gDLL->getText("TXT_KEY_CIVIC_LANDMARK_UNHAPPINESS", -kCivic.getLandmarkHappiness()));
		}

		if (kCivic.isNoLandmarkAnger())
		{
			szHelpText.append(NEWLINE);
			szHelpText.append(gDLL->getText("TXT_KEY_CIVIC_NO_LANDMARK_ANGER"));
		}
	}

	//+1 gold per turn from each city with access to Gold.
	iLast = 0;
	CvWString szBonusName;
	CvWString szBonusList;
	szBonusList.Format(L"");
	bool bFoundAnyBonus = false;
	for (iI = 0; iI < GC.getNumBonusInfos(); iI++)
	{
		if (kCivic.getBonusMintedPercent(iI) > 0)
		{
			szBonusName.Format(L"<link=%s>%s</link> (%c)", gDLL->getText(CvWString(GC.getBonusInfo((BonusTypes)iI).getType()).GetCString(), GC.getBonusInfo((BonusTypes)iI).getTextKeyWide()).c_str(), GC.getBonusInfo((BonusTypes)iI).getChar());
			if (bFoundAnyBonus)
			{
				szBonusList.append(L", ");
			}
			szBonusList.append(szBonusName);
			bFoundAnyBonus = true;
			CvWString szTempBuffer;
			float fValue = (float)kCivic.getBonusMintedPercent(iI);
			if (fmod(fValue,100) == 0)
			{
				if (fValue > 0)
				{
					szTempBuffer.Format(L"+%.0f", fValue/100);
				}
				else
				{
					szTempBuffer.Format(L"%.0f", fValue/100);
				}
			}
			else
			{
				if (fValue > 0)
				{
					szTempBuffer.Format(L"+%.2f", fValue/100);
				}
				else
				{
					szTempBuffer.Format(L"%.2f", fValue/100);
				}
			}
			szFirstBuffer.Format(L"%s%s ", NEWLINE, gDLL->getText("TXT_KEY_CIVIC_BONUS_MINTED", szTempBuffer.GetCString()).c_str());
			setListHelp(szHelpText, szFirstBuffer, szBonusName, L", ", (kCivic.getBonusMintedPercent(iI) != iLast));
			iLast = kCivic.getBonusMintedPercent(iI);
		}
	}
	if (bFoundAnyBonus)
	{
		szHelpText.append(NEWLINE);
		szHelpText.append(gDLL->getText("TXT_KEY_CONSUMES_BONUSES_CIVIC", szBonusList.GetCString()));
	}

	iLast = 0;
	int iCount = 0;
	for (iI = 0; iI < GC.getNumBuildingInfos(); iI++)
	{
		for (iJ = 0; iJ < NUM_COMMERCE_TYPES; iJ++)
		{
			const BuildingTypes eBuilding = static_cast<BuildingTypes>(iI);

			if (kCivic.getBuildingCommerceModifier(eBuilding, iJ) != 0)
			{
				szFirstBuffer.Format(L"%s%s", NEWLINE, gDLL->getText("TXT_KEY_CIVIC_BUILDING_COMMERCE_MODIFIER", kCivic.getBuildingCommerceModifier(eBuilding, iJ), GC.getCommerceInfo((CommerceTypes)iJ).getChar()).c_str());
				CvWString szBuilding;
				szBuilding.Format(L"<link=%s>%s</link>", CvWString(GC.getBuildingInfo(eBuilding).getType()).GetCString(), GC.getBuildingInfo(eBuilding).getDescription());
				setListHelp(szHelpText, szFirstBuffer, szBuilding, L", ", (kCivic.getBuildingCommerceModifier(eBuilding, iJ) != iLast));
				if (iLast == kCivic.getBuildingCommerceModifier(eBuilding, iJ)) iCount++;
				iLast = kCivic.getBuildingCommerceModifier(eBuilding, iJ);
				if (iCount > 3) iCount = iLast = 0;
			}
		}
	}

	iLast = 0;
	iCount = 0;
	for (iI = 0; iI < GC.getNumBuildingInfos(); iI++)
	{
		for (iJ = 0; iJ < NUM_COMMERCE_TYPES; iJ++)
		{
			const BuildingTypes eBuilding = static_cast<BuildingTypes>(iI);

			if (kCivic.getBuildingCommerceChange(iI, iJ) != 0)
			{
				szFirstBuffer.Format(L"%s%s", NEWLINE, gDLL->getText("TXT_KEY_CIVIC_BUILDING_COMMERCE_CHANGE", kCivic.getBuildingCommerceChange(iI, iJ), GC.getCommerceInfo((CommerceTypes)iJ).getChar()).c_str());
				CvWString szBuilding;
				szBuilding.Format(L"<link=%s>%s</link>", CvWString(GC.getBuildingInfo(eBuilding).getType()).GetCString(), GC.getBuildingInfo(eBuilding).getDescription());
				setListHelp(szHelpText, szFirstBuffer, szBuilding, L", ", (kCivic.getBuildingCommerceChange(iI, iJ) != iLast));
				if (iLast == kCivic.getBuildingCommerceChange(iI, iJ)) iCount++;
				iLast = kCivic.getBuildingCommerceChange(iI, iJ);
				if (iCount > 3) iCount = iLast = 0;
			}
		}
	}
	// +0.35 gold for scientists
	//if (kCivic.m_bAnySpecialistCommerceChanges)
	{
		for (iJ = 0; iJ < NUM_COMMERCE_TYPES; iJ++)
		{
			iLast = 0;
			for (iI = 0; iI < GC.getNumSpecialistInfos(); iI++)
			{
				if (kCivic.getSpecialistCommercePercentChanges(iI, iJ) != 0)
				{
					CvWString szTempBuffer;
					float fValue = (float)kCivic.getSpecialistCommercePercentChanges(iI, iJ);
					if (fmod(fValue,100) == 0)
					{
						szTempBuffer.Format(L"%+.0f", fValue/100);
					}
					else
					{
						szTempBuffer.Format(L"%+.2f", fValue/100);
					}
					szFirstBuffer.Format(L"%s%s", NEWLINE, gDLL->getText("TXT_KEY_CIVIC_SPECIALIST_COMMERCE_CHANGE", szTempBuffer.GetCString(), GC.getCommerceInfo((CommerceTypes)iJ).getChar()).c_str());
					CvWString szSpecialist;
					szSpecialist.Format(L"<link=%s>%s</link>", CvWString(GC.getSpecialistInfo((SpecialistTypes)iI).getType()).GetCString(), GC.getSpecialistInfo((SpecialistTypes)iI).getDescription());
					setListHelp(szHelpText, szFirstBuffer, szSpecialist, L", ", (kCivic.getSpecialistCommercePercentChanges(iI, iJ) != iLast));
					iLast = kCivic.getSpecialistCommercePercentChanges(iI, iJ);
				}
			}
		}
	}
	//if (kCivic.m_bAnySpecialistYieldChanges)
	{
		for (iJ = 0; iJ < NUM_YIELD_TYPES; iJ++)
		{
			iLast = 0;
			for (iI = 0; iI < GC.getNumSpecialistInfos(); iI++)
			{
				if (kCivic.getSpecialistYieldPercentChanges(iI, iJ) != 0)
				{
					CvWString szTempBuffer;
					float fValue = (float)kCivic.getSpecialistYieldPercentChanges(iI, iJ);
					if (fmod(fValue,100) == 0)
					{
						szTempBuffer.Format(L"%.0f", fValue/100);
					}
					else
					{
						szTempBuffer.Format(L"%.2f", fValue/100);
					}
					szFirstBuffer.Format(L"%s%s", NEWLINE, gDLL->getText("TXT_KEY_CIVIC_IMPROVEMENT_HEALTHPERCENT", szTempBuffer.GetCString(), GC.getYieldInfo((YieldTypes)iJ).getChar()).c_str());
					CvWString szSpecialist;
					szSpecialist.Format(L"<link=%s>%s</link>", CvWString(GC.getSpecialistInfo((SpecialistTypes)iI).getType()).GetCString(), GC.getSpecialistInfo((SpecialistTypes)iI).getDescription());
					setListHelp(szHelpText, szFirstBuffer, szSpecialist, L", ", (kCivic.getSpecialistYieldPercentChanges(iI, iJ) != iLast));
					iLast = kCivic.getSpecialistYieldPercentChanges(iI, iJ);
				}
			}
		}
	}

	CvWString szImprovement;
	iLast = 0;
	for (iI = 0; iI < GC.getNumImprovementInfos(); iI++)
	{
		if (kCivic.getImprovementHappinessChanges(iI) != 0)
		{
			int iImprovementHappinessChange = kCivic.getImprovementHappinessChanges(iI);
			szFirstBuffer.Format(L"%s%s", NEWLINE ,gDLL->getText("TXT_KEY_CIVIC_IMPROVEMENT_HAPPINESS", iImprovementHappinessChange, (iImprovementHappinessChange > 0 ? gDLL->getSymbolID(HAPPY_CHAR) : gDLL->getSymbolID(UNHAPPY_CHAR))).c_str());
			szImprovement.Format(L"<link=%s>%s</link>", CvWString(GC.getImprovementInfo((ImprovementTypes)iI).getType()).GetCString(), GC.getImprovementInfo((ImprovementTypes)iI).getDescription());
			setListHelp(szHelpText, szFirstBuffer, szImprovement, L", ", (iImprovementHappinessChange != iLast));
			iLast = iImprovementHappinessChange;
		}
	}

	iLast = 0;
	for (iI = 0; iI < GC.getNumImprovementInfos(); iI++)
	{
		if (kCivic.getImprovementHealthPercentChanges(iI) != 0)
		{
			CvWString szTempBuffer;
			float fValue = (float)kCivic.getImprovementHealthPercentChanges(iI);
			if (fmod(fValue,100) == 0)
			{
				szTempBuffer.Format(L"%.0f", fValue/100);
			}
			else if (fmod(fValue,10) == 0)
			{
				szTempBuffer.Format(L"%.1f", fValue/100);
			}
			else
			{
				szTempBuffer.Format(L"%.2f", fValue/100);
			}
			szFirstBuffer.Format(L"%s%s", NEWLINE, gDLL->getText("TXT_KEY_CIVIC_IMPROVEMENT_HEALTHPERCENT", szTempBuffer.GetCString(), (kCivic.getImprovementHealthPercentChanges(iI) > 0 ? gDLL->getSymbolID(HEALTHY_CHAR) : gDLL->getSymbolID(UNHEALTHY_CHAR))).c_str());
			//szFirstBuffer.Format(L"%s%s %s", NEWLINE, szTempBuffer, /*(kCivic.getImprovementHealthPercentChanges(iI) > 0 ? gDLL->getSymbolID(HEALTHY_CHAR) : gDLL->getSymbolID(UNHEALTHY_CHAR)),*/ gDLL->getText("TXT_KEY_MISC_FROM"));
			szImprovement.Format(L"<link=%s>%s</link>", CvWString(GC.getImprovementInfo((ImprovementTypes)iI).getType()).GetCString(), GC.getImprovementInfo((ImprovementTypes)iI).getDescription());
			setListHelp(szHelpText, szFirstBuffer, szImprovement, L", ", (kCivic.getImprovementHealthPercentChanges(iI) != iLast));
			iLast = kCivic.getImprovementHealthPercentChanges(iI);
		}
	}

	for (iI = 0; iI < GC.getNumBonusInfos(); iI++)
	{
		szFirstBuffer = gDLL->getText("TXT_KEY_BUILDING_WITH_BONUS", CvWString(GC.getBonusInfo((BonusTypes) iI).getType()).GetCString(), GC.getBonusInfo((BonusTypes) iI).getTextKeyWide());
		setCommerceChangeHelp(szHelpText, L"", L"", szFirstBuffer, kCivic.getBonusCommerceModifierArray(iI), true);
	}

	if (bCivilopediaText || GC.getGame().isOption(GAMEOPTION_PERSONALIZED_MAP))
	{
		setYieldChangeHelp(szHelpText, L"", L"", gDLL->getText("TXT_KEY_CIVIC_FROM_LANDMARK").GetCString(), kCivic.getLandmarkYieldChangesArray(), false);
	}

	//	Yield Modifiers
	setYieldChangeHelp(szHelpText, L"", L"", gDLL->getText("TXT_KEY_CIVIC_IN_ALL_CITIES").GetCString(), GC.getCivicInfo(eCivic).getYieldModifierArray(), true);

	//	Capital Yield Modifiers
	setYieldChangeHelp(szHelpText, L"", L"", gDLL->getText("TXT_KEY_CIVIC_IN_CAPITAL").GetCString(), GC.getCivicInfo(eCivic).getCapitalYieldModifierArray(), true);

	//	Trade Yield Modifiers
	setYieldChangeHelp(szHelpText, L"", L"", gDLL->getText("TXT_KEY_CIVIC_FROM_TRADE_ROUTES").GetCString(), GC.getCivicInfo(eCivic).getTradeYieldModifierArray(), true);

	//	Commerce Modifier
	setCommerceChangeHelp(szHelpText, L"", L"", gDLL->getText("TXT_KEY_CIVIC_IN_ALL_CITIES").GetCString(), GC.getCivicInfo(eCivic).getCommerceModifierArray(), true);

	//	Capital Commerce Modifiers
	setCommerceChangeHelp(szHelpText, L"", L"", gDLL->getText("TXT_KEY_CIVIC_IN_CAPITAL").GetCString(), GC.getCivicInfo(eCivic).getCapitalCommerceModifierArray(), true);

	//	Specialist Commerce
	setCommerceChangeHelp(szHelpText, L"", L"", gDLL->getText("TXT_KEY_CIVIC_PER_SPECIALIST").GetCString(), GC.getCivicInfo(eCivic).getSpecialistExtraCommerceArray());

	//	Largest City Happiness
	if (GC.getCivicInfo(eCivic).getLargestCityHappiness() != 0)
	{
		szHelpText.append(NEWLINE);

		// Use absolute value with unhappy face
		szHelpText.append(gDLL->getText("TXT_KEY_CIVIC_LARGEST_CITIES_HAPPINESS", abs(GC.getCivicInfo(eCivic).getLargestCityHappiness()), ((GC.getCivicInfo(eCivic).getLargestCityHappiness() > 0) ? gDLL->getSymbolID(HAPPY_CHAR) : gDLL->getSymbolID(UNHAPPY_CHAR)), GC.getWorldInfo(GC.getMap().getWorldSize()).getTargetNumCities()));
	}

	//	Improvement Yields
	for (iI = 0; iI < NUM_YIELD_TYPES; ++iI)
	{
		iLast = 0;

		for (iJ = 0; iJ < GC.getNumImprovementInfos(); iJ++)
		{
			if (GC.getCivicInfo(eCivic).getImprovementYieldChanges(iJ, iI) != 0)
			{
				szFirstBuffer.Format(L"%s%s", NEWLINE, gDLL->getText("TXT_KEY_CIVIC_IMPROVEMENT_YIELD_CHANGE", GC.getCivicInfo(eCivic).getImprovementYieldChanges(iJ, iI), GC.getYieldInfo((YieldTypes)iI).getChar()).c_str());
				CvWString szImprovement;
				szImprovement.Format(L"<link=%s>%s</link>", CvWString(GC.getImprovementInfo((ImprovementTypes)iJ).getType()).GetCString(), GC.getImprovementInfo((ImprovementTypes)iJ).getDescription());
				setListHelp(szHelpText, szFirstBuffer, szImprovement, L", ", (GC.getCivicInfo(eCivic).getImprovementYieldChanges(iJ, iI) != iLast));
				iLast = GC.getCivicInfo(eCivic).getImprovementYieldChanges(iJ, iI);
			}
		}
	}

	//	Terrain Yields
	for (iI = 0; iI < NUM_YIELD_TYPES; ++iI)
	{
		iLast = 0;

		for (iJ = 0; iJ < GC.getNumTerrainInfos(); iJ++)
		{
			if (kCivic.getTerrainYieldChanges(iJ, iI) != 0)
			{
				szFirstBuffer.Format(L"%s%s", NEWLINE, gDLL->getText("TXT_KEY_CIVIC_TERRAIN_YIELD_CHANGE", kCivic.getTerrainYieldChanges(iJ, iI), GC.getYieldInfo((YieldTypes)iI).getChar()).c_str());
				CvWString szTerrain;
				szTerrain.Format(L"<link=%s>%s</link>", CvWString(GC.getTerrainInfo((TerrainTypes)iJ).getType()).GetCString(), GC.getTerrainInfo((TerrainTypes)iJ).getDescription());
				setListHelp(szHelpText, szFirstBuffer, szTerrain, L", ", (kCivic.getTerrainYieldChanges(iJ, iI) != iLast));
				iLast = kCivic.getTerrainYieldChanges(iJ, iI);
			}
		}
	}

	//	Building Happiness
	int CounterHappy = -1; //Dummy Value
	int CounterHealthy = -1; //Dummy Value
	int XResolution = GC.getGame().getXResolution();

	iLast = 0;
	iCount = 0;

	for (iI = 0; iI < GC.getNumBuildingInfos(); ++iI)
	{
		if (kCivic.getBuildingHappinessChanges(iI) != 0)
		{
			if (bPlayerContext && NO_PLAYER != GC.getGame().getActivePlayer())
			{
				const BuildingTypes eBuilding = static_cast<BuildingTypes>(iI);
				szFirstBuffer.Format(L"%s%s", NEWLINE, gDLL->getText("TXT_KEY_CIVIC_BUILDING_HAPPINESS_PREFIX", abs(kCivic.getBuildingHappinessChanges(iI)), ((kCivic.getBuildingHappinessChanges(iI) > 0) ? gDLL->getSymbolID(HAPPY_CHAR) : gDLL->getSymbolID(UNHAPPY_CHAR))).c_str());
				CvWString szBuilding;
				szBuilding.Format(L"<link=%s>%s</link>", CvWString(GC.getBuildingInfo(eBuilding).getType()).GetCString(), GC.getBuildingInfo(eBuilding).getDescription());
				setListHelp(szHelpText, szFirstBuffer, szBuilding, L", ", (kCivic.getBuildingHappinessChanges(iI) != iLast));
				if (iLast == kCivic.getBuildingHappinessChanges(iI)) iCount++;
				iLast = kCivic.getBuildingHappinessChanges(iI);
				if (iCount > 3) iCount = iLast = 0;
			}
			else
			{
				szHelpText.append(NEWLINE);								 		 // abs() below added by Supercheese 10/13/09  to fix "-1 Angry" issue
				szHelpText.append(gDLL->getText("TXT_KEY_CIVIC_BUILDING_HAPPINESS", abs(kCivic.getBuildingHappinessChanges(iI)), ((kCivic.getBuildingHappinessChanges(iI) > 0) ? gDLL->getSymbolID(HAPPY_CHAR) : gDLL->getSymbolID(UNHAPPY_CHAR)), CvWString(GC.getBuildingInfo((BuildingTypes)iI).getType()).GetCString(), GC.getBuildingInfo((BuildingTypes)iI).getTextKeyWide()));
			}
		}
	}

	iLast = 0;
	iCount = 0;

	for (iI = 0; iI < GC.getNumBuildingInfos(); ++iI)
	{
		if (kCivic.getBuildingHealthChanges(iI) != 0)
		{
			if (bPlayerContext && NO_PLAYER != GC.getGame().getActivePlayer())
			{
				const BuildingTypes eBuilding = static_cast<BuildingTypes>(iI);
				szFirstBuffer.Format(L"%s%s", NEWLINE, gDLL->getText("TXT_KEY_CIVIC_BUILDING_HAPPINESS_PREFIX", abs(kCivic.getBuildingHealthChanges(iI)), ((kCivic.getBuildingHealthChanges(iI) > 0) ? gDLL->getSymbolID(HEALTHY_CHAR) : gDLL->getSymbolID(UNHEALTHY_CHAR))).c_str());
				CvWString szBuilding;
				szBuilding.Format(L"<link=%s>%s</link>", CvWString(GC.getBuildingInfo(eBuilding).getType()).GetCString(), GC.getBuildingInfo(eBuilding).getDescription());
				setListHelp(szHelpText, szFirstBuffer, szBuilding, L", ", (kCivic.getBuildingHealthChanges(iI) != iLast));
				if (iLast == kCivic.getBuildingHealthChanges(iI)) iCount++;
				iLast = kCivic.getBuildingHealthChanges(iI);
				if (iCount > 3) iCount = iLast = 0;
			}
			else
			{
				szHelpText.append(NEWLINE);										 // abs() below added by Supercheese 10/13/09  to fix "-1 Unhealthy" issue
				szHelpText.append(gDLL->getText("TXT_KEY_CIVIC_BUILDING_HAPPINESS", abs(kCivic.getBuildingHealthChanges(iI)), ((kCivic.getBuildingHealthChanges(iI) > 0) ? gDLL->getSymbolID(HEALTHY_CHAR) : gDLL->getSymbolID(UNHEALTHY_CHAR)), CvWString(GC.getBuildingInfo((BuildingTypes)iI).getType()).GetCString(), GC.getBuildingInfo((BuildingTypes)iI).getTextKeyWide()));
			}
		}
	}

	if (kCivic.getEnslavementChance() != 0)
	{
		szHelpText.append(NEWLINE);
		szHelpText.append(gDLL->getText("TXT_KEY_UNIT_ENSLAVEMENT_CHANCE", kCivic.getEnslavementChance()));
	}

	for (iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
	{
		if (kCivic.getUnitCombatProductionModifier(iI) != 0)
		{
			szHelpText.append(NEWLINE);
			szHelpText.append(CvWString::format(L"%c<link=%s>%s</link>", gDLL->getSymbolID(BULLET_CHAR), CvWString(GC.getUnitCombatInfo((UnitCombatTypes)iI).getType()).GetCString(), GC.getUnitCombatInfo((UnitCombatTypes)iI).getDescription()));
			szHelpText.append(gDLL->getText("TXT_KEY_CIVIC_UNIT_COMBAT_PRODUCTION_MOD", kCivic.getUnitCombatProductionModifier(iI)));
		}
	}

	iLast = 0;
	int CounterMod = 0;
	CvWString szUnit;
	for (iI = 0; iI < GC.getNumUnitInfos(); ++iI)
	{
		if (GC.getGame().canEverTrain((UnitTypes) iI))
		{
			if (kCivic.getUnitProductionModifier(iI) != 0)
			{
				szFirstBuffer.Format(L"%s%c%d%s", NEWLINE, gDLL->getSymbolID(BULLET_CHAR), abs(kCivic.getUnitProductionModifier(iI)),
					(kCivic.getUnitProductionModifier(iI) > 0 ? gDLL->getText("TXT_KEY_UNIT_CLASS_PRODUCTION_FAST_MOD") : gDLL->getText("TXT_KEY_UNIT_CLASS_PRODUCTION_SLOW_MOD")).c_str());

				szUnit.Format(L"<link=%s>%s</link>", CvWString(GC.getUnitInfo((UnitTypes) iI).getType()).GetCString(), GC.getUnitInfo((UnitTypes) iI).getDescription());

				setListHelp(szHelpText, szFirstBuffer, szUnit, L", ", (kCivic.getUnitProductionModifier(iI) != iLast));

				if (iLast == kCivic.getUnitProductionModifier(iI))
				{
					CounterMod++;
				}
				iLast = kCivic.getUnitProductionModifier(iI);

				if (XResolution <= 1024 && CounterMod >= 3)
				{
					CounterMod = 0;
					iLast = 0;
				}
				else if (XResolution > 1024 && XResolution < 1600 && CounterMod >= 4)
				{
					CounterMod = 0;
					iLast = 0;
				}
				else if (XResolution > 1024 && XResolution < 2000 && CounterMod >= 6)
				{
					CounterMod = 0;
					iLast = 0;
				}
			}
		}
	}

	CvWString szBuilding;
	CounterMod = 0;
	for (iI = 0; iI < GC.getNumBuildingInfos(); iI++)
	{
		if (kCivic.getBuildingProductionModifier(iI) != 0)
		{
			szFirstBuffer.Format(L"%s%c%d%s", NEWLINE, gDLL->getSymbolID(BULLET_CHAR), abs(kCivic.getBuildingProductionModifier(iI)), (kCivic.getBuildingProductionModifier(iI) > 0 ? gDLL->getText("TXT_KEY_CIVIC_BUILDING_PRODUCTION_MOD") : gDLL->getText("TXT_KEY_CIVIC_BUILDING_PRODUCTION_SLOW")).c_str());
			szBuilding.Format(L"<link=%s>%s</link>", CvWString(GC.getBuildingInfo((BuildingTypes)iI).getType()).GetCString(), GC.getBuildingInfo((BuildingTypes)iI).getDescription());
			setListHelp(szHelpText, szFirstBuffer, szBuilding, L", ", (kCivic.getBuildingProductionModifier(iI) != iLast));
			iLast = kCivic.getBuildingProductionModifier(iI);
			if (iLast == kCivic.getBuildingProductionModifier(iI))
			{
				CounterMod++;
			}
			if (XResolution <= 1024 && CounterMod >= 3)
			{
				CounterMod = 0;
				iLast = 0;
			}
			else if (XResolution > 1024 && XResolution < 1600 && CounterMod >= 4)
			{
				CounterMod = 0;
				iLast = 0;
			}
			else if (XResolution > 1024 && XResolution < 2000 && CounterMod >= 6)
			{
				CounterMod = 0;
				iLast = 0;
			}
		}
	}
	CivicTypes eTargetCivic;
	bool bEnemiesFirst = true;
	if (bPlayerContext || GC.getGame().getActivePlayer() != NO_PLAYER)
	{
		CvPlayer& kPlayer = GET_PLAYER(GC.getGame().getActivePlayer());
		CivicTypes eCurrentCivic = kPlayer.getCivics((CivicOptionTypes)kCivic.getCivicOptionType());
		int aiPlayerDiplomacyChanges[MAX_PC_PLAYERS];

		for (int iK = 0; iK < MAX_PC_PLAYERS; iK++)
		{
			aiPlayerDiplomacyChanges[iK] = 0;
			if (GET_PLAYER((PlayerTypes)iK).isAlive())
			{
				if (!GET_PLAYER((PlayerTypes)iK).isHuman())
				{
					if (GET_TEAM(kPlayer.getTeam()).isHasMet(GET_PLAYER((PlayerTypes)iK).getTeam()))
					{
						for (int iL = 0; iL < GC.getNumCivicOptionInfos(); iL++)
						{
							eTargetCivic = GET_PLAYER((PlayerTypes)iK).getCivics((CivicOptionTypes)iL);
							aiPlayerDiplomacyChanges[iK] += GC.getCivicInfo(eTargetCivic).getCivicAttitudeChange(eCivic) - GC.getCivicInfo(eTargetCivic).getCivicAttitudeChange(eCurrentCivic);
						}
					}
				}
			}
		}
		bFirst = true;

		int iPlayerCount = 0;
		int iEnemyCount = 0;
		CvWString szPlayers;
		CvWString szEnemies;
		szEnemies.Format(L"");
		szPlayers.Format(L"");
		for (int iJ = 0; iJ < MAX_PC_PLAYERS; iJ++)
		{
			if (aiPlayerDiplomacyChanges[iJ] > 0)
			{
				if (!bFirst)
					szPlayers.append(CvWString::format(L", "));
				szPlayers.append(CvWString::format(L"<link=%s>%s</link> (+%d)", CvWString(GC.getCivilizationInfo(GET_PLAYER((PlayerTypes)iJ).getCivilizationType()).getType()).GetCString(), GC.getCivilizationInfo(GET_PLAYER((PlayerTypes)iJ).getCivilizationType()).getShortDescription(), aiPlayerDiplomacyChanges[iJ]));
				bFirst = false;
				//Resolution Scaling
				iPlayerCount++;
				if (iEnemyCount > XResolution / 10)
				{
					szPlayers.append(NEWLINE);
					iEnemyCount = 0;
				}
			}
			else if (aiPlayerDiplomacyChanges[iJ] < 0)
			{
				if (!bEnemiesFirst)
					szEnemies.append(CvWString::format(L", "));
				szEnemies.append(CvWString::format(L"<link=%s>%s</link> (%d)", CvWString(GC.getCivilizationInfo(GET_PLAYER((PlayerTypes)iJ).getCivilizationType()).getType()).GetCString(), GC.getCivilizationInfo(GET_PLAYER((PlayerTypes)iJ).getCivilizationType()).getShortDescription(), aiPlayerDiplomacyChanges[iJ]));
				bEnemiesFirst = false;
				//Resolution Scaling
				iEnemyCount++;
				if (iEnemyCount > XResolution / 10)
				{
					szEnemies.append(NEWLINE);
					iEnemyCount = 0;
				}
			}
		}
		if (!bFirst)
		{
			szHelpText.append(NEWLINE);
			szHelpText.append(gDLL->getSymbolID(BULLET_CHAR));
			szHelpText.append(gDLL->getText("TXT_KEY_CIVIC_BOOSTS_DIPLOMACY"));
			szHelpText.append(szPlayers);
		}
		if (!bEnemiesFirst)
		{
			szHelpText.append(NEWLINE);
			szHelpText.append(gDLL->getSymbolID(BULLET_CHAR));
			szHelpText.append(gDLL->getText("TXT_KEY_CIVIC_HURTS_DIPLOMACY"));
			szHelpText.append(szEnemies);
		}
	}
	else
	{
	//Civilopedia Text
		bFirst = true;
		bEnemiesFirst = true;
		int iAttitudeChange;
		for (int iJ = 0; iJ < GC.getNumCivicInfos(); iJ++)
		{
			eTargetCivic = CivicTypes(iJ);
			iAttitudeChange = GC.getCivicInfo(eTargetCivic).getCivicAttitudeChange(eCivic);
			if (iAttitudeChange < 0)
			{
				if (bEnemiesFirst)
				{
					szHelpText.append(NEWLINE);
					szHelpText.append(gDLL->getSymbolID(BULLET_CHAR));
					szHelpText.append(gDLL->getText("TXT_KEY_CIVIC_HURTS_DIPLOMACY_WITH_PLAYERS"));
				}
				else
					szHelpText.append(CvWString::format(L", "));
				szHelpText.append(CvWString::format(L"<link=%s>%s</link> (%d)", CvWString(GC.getCivicInfo(eTargetCivic).getType()).GetCString(), GC.getCivicInfo(eTargetCivic).getDescription(), iAttitudeChange));
				bEnemiesFirst = false;
			}
			else if (iAttitudeChange > 0)
			{
				if (bFirst)
				{
					szHelpText.append(NEWLINE);
					szHelpText.append(gDLL->getSymbolID(BULLET_CHAR));
					szHelpText.append(gDLL->getText("TXT_KEY_CIVIC_BOOSTS_DIPLOMACY_WITH_PLAYERS"));
				}
				else
					szHelpText.append(CvWString::format(L", "));
				szHelpText.append(CvWString::format(L"<link=%s>%s</link> (%d)", CvWString(GC.getCivicInfo(eTargetCivic).getType()).GetCString(), GC.getCivicInfo(eTargetCivic).getDescription(), iAttitudeChange));
				bFirst = false;
			}
		}
	}

	for (iI = 0; iI < GC.getNumSpecialistInfos(); ++iI)
	{
		if (kCivic.getFreeSpecialistCount(iI) > 0)
		{
			szHelpText.append(NEWLINE);
			szHelpText.append(gDLL->getText("TXT_KEY_BUILDING_FREE_SPECIALIST", kCivic.getFreeSpecialistCount(iI), CvWString(GC.getSpecialistInfo((SpecialistTypes)iI).getType()).GetCString(), GC.getSpecialistInfo((SpecialistTypes)iI).getTextKeyWide()));
			szHelpText.append(gDLL->getText("TXT_KEY_BUILDING_GLOBAL"));
		}
	}

	//	Feature Happiness
	iLast = 0;

	for (iI = 0; iI < GC.getNumFeatureInfos(); ++iI)
	{
		if (GC.getCivicInfo(eCivic).getFeatureHappinessChanges(iI) != 0)
		{
			// Use absolute value with unhappy face
			szFirstBuffer.Format(L"%s%s", NEWLINE, gDLL->getText("TXT_KEY_CIVIC_FEATURE_HAPPINESS", abs(GC.getCivicInfo(eCivic).getFeatureHappinessChanges(iI)), ((GC.getCivicInfo(eCivic).getFeatureHappinessChanges(iI) > 0) ? gDLL->getSymbolID(HAPPY_CHAR) : gDLL->getSymbolID(UNHAPPY_CHAR))).c_str());

			CvWString szFeature;
			szFeature.Format(L"<link=%s>%s</link>", CvWString(GC.getFeatureInfo((FeatureTypes)iI).getType()).GetCString(), GC.getFeatureInfo((FeatureTypes)iI).getDescription());
			setListHelp(szHelpText, szFirstBuffer, szFeature, L", ", (GC.getCivicInfo(eCivic).getFeatureHappinessChanges(iI) != iLast));
			iLast = GC.getCivicInfo(eCivic).getFeatureHappinessChanges(iI);
		}
	}

	//	Hurry types
	for (iI = 0; iI < GC.getNumHurryInfos(); ++iI)
	{
		if (GC.getCivicInfo(eCivic).isHurry(iI))
		{
			szHelpText.append(CvWString::format(L"%s%c%s", NEWLINE, gDLL->getSymbolID(BULLET_CHAR), GC.getHurryInfo((HurryTypes)iI).getDescription()));
		}
	}

	if (GC.getCivicInfo(eCivic).getCivilianUnitUpkeepMod() != 0)
	{
		szHelpText.append(NEWLINE);
		szHelpText.append(gDLL->getText("TXT_KEY_HELPTEXT_UNIT_UPKEEP_MOD_CIVILIAN", GC.getCivicInfo(eCivic).getCivilianUnitUpkeepMod()));
	}
	if (GC.getCivicInfo(eCivic).getMilitaryUnitUpkeepMod() != 0)
	{
		szHelpText.append(NEWLINE);
		szHelpText.append(gDLL->getText("TXT_KEY_HELPTEXT_UNIT_UPKEEP_MOD_MILITARY", GC.getCivicInfo(eCivic).getMilitaryUnitUpkeepMod()));
	}

	bFirst = true;
	for (iI = 0; iI < GC.getNumBuildingInfos(); ++iI)
	{
		const BuildingTypes eLoopBuilding = static_cast<BuildingTypes>(iI);

		if (GC.getGame().canEverConstruct(eLoopBuilding))
		{
			if ((GC.getBuildingInfo(eLoopBuilding).isPrereqOrCivics(eCivic) || GC.getBuildingInfo(eLoopBuilding).isPrereqAndCivics(eCivic)))
			{
				CvWString szBuilding;
				szFirstBuffer.Format(L"%s%s", NEWLINE, gDLL->getText("TXT_KEY_CIVIC_UNLOCKS_BUILDING").c_str());
				szBuilding.Format(L"<link=%s>%s</link>", CvWString(GC.getBuildingInfo(eLoopBuilding).getType()).GetCString(), GC.getBuildingInfo(eLoopBuilding).getDescription());
				setListHelp(szHelpText, szFirstBuffer, szBuilding, L", ", bFirst);
				bFirst = false;
			}
		}
	}
	bFirst = true;
	if (NO_PLAYER != GC.getGame().getActivePlayer())
	{
		if (!GET_PLAYER(GC.getGame().getActivePlayer()).isCivic(eCivic))
		{
			for (iI = 0; iI < GC.getNumBuildingInfos(); ++iI)
			{
				const BuildingTypes eLoopBuilding = static_cast<BuildingTypes>(iI);

				if (GC.getGame().canEverConstruct(eLoopBuilding))
				{
					bool bObsolete = false;
					CivicTypes eCurCivic = GET_PLAYER(GC.getGame().getActivePlayer()).getCivics((CivicOptionTypes)GC.getCivicInfo(eCivic).getCivicOptionType());
					if (GC.getBuildingInfo(eLoopBuilding).isPrereqAndCivics(eCurCivic))
					{
						bObsolete = true;
					}
					else if (GC.getBuildingInfo(eLoopBuilding).isPrereqOrCivics(eCurCivic) && !GC.getBuildingInfo(eLoopBuilding).isPrereqOrCivics(eCivic))
					{
						bObsolete = true;
						for (int iJ = 0; iJ < GC.getNumCivicInfos(); iJ++)
						{
							if (iJ != eCurCivic && iJ != eCivic)
							{
								if (GC.getBuildingInfo(eLoopBuilding).isPrereqOrCivics((CivicTypes)iJ))
								{
									if (GET_PLAYER(GC.getGame().getActivePlayer()).isCivic((CivicTypes)iJ))
									{
										bObsolete = false;
										break;
									}
								}
							}
						}
					}
					if (bObsolete)
					{
						CvWString szBuilding;
						szFirstBuffer.Format(L"%s%s", NEWLINE, gDLL->getText("TXT_KEY_CIVIC_BLOCKS_BUILDING").c_str());
						szBuilding.Format(L"<link=%s>%s</link>", CvWString(GC.getBuildingInfo(eLoopBuilding).getType()).GetCString(), GC.getBuildingInfo(eLoopBuilding).getDescription());
						setListHelp(szHelpText, szFirstBuffer, szBuilding, L", ", bFirst);
						bFirst = false;
					}
				}
			}
		}
	}
	kCivic.getPropertyManipulators()->buildDisplayString(szHelpText);

	if (!CvWString(GC.getCivicInfo(eCivic).getHelp()).empty())
	{
		szHelpText.append(CvWString::format(L"%s%s", NEWLINE, GC.getCivicInfo(eCivic).getHelp()).c_str());
	}
}

// BUG - Trade Denial - start
void CvGameTextMgr::setTechHelp(CvWStringBuffer &szBuffer, TechTypes eTech, bool bCivilopediaText, bool bPlayerContext, bool bStrategyText, bool bTreeInfo, TechTypes eFromTech)
{
	setTechTradeHelp(szBuffer, eTech, NO_PLAYER, bCivilopediaText, bPlayerContext, bStrategyText, bTreeInfo, eFromTech);
}

void CvGameTextMgr::setTechTradeHelp(CvWStringBuffer &szBuffer, TechTypes eTech, PlayerTypes eTradePlayer, bool bCivilopediaText, bool bPlayerContext, bool bStrategyText, bool bTreeInfo, TechTypes eFromTech)
// BUG - Trade Denial - end
{
	PROFILE_FUNC();

	CvWString szTempBuffer;
	CvWString szFirstBuffer;
	bool bFirst;
	int iI;

	// show debug info if cheat level > 0 and alt down
	bool bAlt = gDLL->altKey();
	if (bAlt && (gDLL->getChtLvl() > 0))
	{
		szBuffer.clear();

		for (int iI = 0; iI < MAX_PLAYERS; iI++)
		{
			CvPlayerAI* playerI = &GET_PLAYER((PlayerTypes)iI);
			CvTeamAI* teamI = &GET_TEAM(playerI->getTeam());
			if (playerI->isAlive())
			{
				szTempBuffer.Format(L"%s: ", playerI->getName());
				szBuffer.append(szTempBuffer);

				TechTypes ePlayerTech = playerI->getCurrentResearch();
				if (ePlayerTech == NO_TECH)
					szTempBuffer.Format(L"-\n");
				else
					szTempBuffer.Format(L"%s (%d->%dt)(%d/%d)\n", GC.getTechInfo(ePlayerTech).getDescription(), playerI->calculateResearchRate(ePlayerTech), playerI->getResearchTurnsLeft(ePlayerTech, true), teamI->getResearchProgress(ePlayerTech), teamI->getResearchCost(ePlayerTech));

				szBuffer.append(szTempBuffer);
			}
		}

		return;
	}


	if (NO_TECH == eTech)
	{
		return;
	}

	//	Tech Name
	if (!bCivilopediaText && (!bTreeInfo || (NO_TECH == eFromTech)))
	{
		szTempBuffer.Format( SETCOLR L"%s" ENDCOLR , TEXT_COLOR("COLOR_TECH_TEXT"), GC.getTechInfo(eTech).getDescription());
		szBuffer.append(szTempBuffer);
	}

	FAssert(GC.getGame().getActivePlayer() != NO_PLAYER || !bPlayerContext);

	if (bTreeInfo && (NO_TECH != eFromTech))
	{
		buildTechTreeString(szBuffer, eTech, bPlayerContext, eFromTech);
	}

	//	Obsolete Buildings
	for (iI = 0; iI < GC.getNumBuildingInfos(); ++iI)
	{
		if (!bPlayerContext || GET_PLAYER(GC.getGame().getActivePlayer()).getBuildingCount((BuildingTypes)iI) > 0)
		{
			if (GC.getGame().canEverConstruct((BuildingTypes)iI))
			{
				//	Obsolete Buildings Check...
				if (GC.getBuildingInfo((BuildingTypes)iI).getObsoleteTech() == eTech)
				{
					buildObsoleteString(szBuffer, (BuildingTypes)iI, true);
				}
			}
		}
	}

	//	Obsolete Bonuses
	for (iI = 0; iI < GC.getNumBonusInfos(); ++iI)
	{
		if (GC.getBonusInfo((BonusTypes)iI).getTechObsolete() == eTech)
		{
			buildObsoleteBonusString(szBuffer, iI, true);
		}
	}

	for (iI = 0; iI < GC.getNumSpecialBuildingInfos(); ++iI)
	{
		if (GC.getSpecialBuildingInfo((SpecialBuildingTypes) iI).getObsoleteTech() == eTech)
		{
			buildObsoleteSpecialString(szBuffer, iI, true);
		}
	}

	//	Route movement change...
	buildMoveString(szBuffer, eTech, true, bPlayerContext);

	//	Creates a free unit...
	buildFreeUnitString(szBuffer, eTech, true, bPlayerContext);

	//	Increases feature production...
	buildFeatureProductionString(szBuffer, eTech, true, bPlayerContext);

	//	Increases worker build rate...
	buildWorkerRateString(szBuffer, eTech, true, bPlayerContext);

	//DPII < Maintenance Modifiers >
	//  Decreases maintenance costs...
	buildMaintenanceModifiersString(szBuffer, eTech, true, bPlayerContext);
	//DPII < Maintenance Modifiers >

	//	Trade Routed per city change...
	buildTradeRouteString(szBuffer, eTech, true, bPlayerContext);

	//	Health increase...
	buildHealthRateString(szBuffer, eTech, true, bPlayerContext);

	//  Specialist Health
	buildSpecialistHealthString(szBuffer, eTech, true, bPlayerContext);

	//	Happiness increase...
	buildHappinessRateString(szBuffer, eTech, true, bPlayerContext);

	//  Specialist Happiness
	buildSpecialistHappinessString(szBuffer, eTech, true, bPlayerContext);

	//	Free Techs...
	buildFreeTechString(szBuffer, eTech, true, bPlayerContext);

	//	Line of Sight Bonus across water...
	buildLOSString(szBuffer, eTech, true, bPlayerContext);

	//	Centers world map...
	buildMapCenterString(szBuffer, eTech, true, bPlayerContext);

	//	Reveals World Map...
	buildMapRevealString(szBuffer, eTech, true);

	//	Enables map trading...
	buildMapTradeString(szBuffer, eTech, true, bPlayerContext);

	//	Enables tech trading...
	buildTechTradeString(szBuffer, eTech, true, bPlayerContext);

	//	Enables gold trading...
	buildGoldTradeString(szBuffer, eTech, true, bPlayerContext);

	//	Enables open borders...
	buildOpenBordersString(szBuffer, eTech, true, bPlayerContext);

	//	Enables defensive pacts...
	buildDefensivePactString(szBuffer, eTech, true, bPlayerContext);

	//	Enables permanent alliances...
	buildPermanentAllianceString(szBuffer, eTech, true, bPlayerContext);

	const CvTechInfo& kTech = GC.getTechInfo(eTech);
	//   Enables Embassies...
	buildEmbassyString(szBuffer, eTech, true, bPlayerContext);

	//	Peak passability...
	buildCanPassPeaksString(szBuffer, eTech, true, bPlayerContext);

	//	If it Removes Movement slowdown...
	buildMoveFastPeaksString(szBuffer, eTech, true, bPlayerContext);

	//	Can found cities on peak...
	buildCanFoundOnPeaksString(szBuffer, eTech, true, bPlayerContext);

	//   Removes Airlift Restriction...
	buildCanRebaseAnywhereString(szBuffer, eTech, true, bPlayerContext);

	if (kTech.getInflationModifier() != 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_ADJUSTS_INFLATION", kTech.getInflationModifier()));
	}

	if (kTech.getGlobalTradeModifier() != 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_TRADE_INCOME", kTech.getGlobalTradeModifier()));
	}

	if (kTech.getGlobalForeignTradeModifier() != 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_FOREIGN_TRADE_INCOME", kTech.getGlobalForeignTradeModifier()));
	}

	if (kTech.getTradeMissionModifier() != 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_TRADE_MISSION_INCOME", kTech.getTradeMissionModifier()));
	}

	if (kTech.getCorporationRevenueModifier() != 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_CORPORATIONS_REVENUE", kTech.getCorporationRevenueModifier()));
	}

	if (kTech.getCorporationMaintenanceModifier() != 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_TECH_CORPORATION_MAINTENANCE", kTech.getCorporationMaintenanceModifier()));
	}

	if (kTech.isEnablesDesertFarming())
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_TECH_ENABLES_DESERT_FARMING"));
	}

	if (kTech.isGlobal())
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_TECH_GLOBAL"));
	}

	for (iI = 0; iI < GC.getNumUnitInfos(); ++iI)
	{
		if (kTech.getUnitStrengthChange((UnitTypes) iI) != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_TECH_UNIT_STRENGTH_CHANGE", kTech.getUnitStrengthChange((UnitTypes) iI), ((CvWString)GC.getUnitInfo((UnitTypes) iI).getDescription()).c_str()));
		}
	}

	for (iI = 0; iI < GC.getNumSpecialistInfos(); ++iI)
	{
		if (kTech.getFreeSpecialistCount(iI) > 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_FREE_SPECIALIST", kTech.getFreeSpecialistCount(iI), CvWString(GC.getSpecialistInfo((SpecialistTypes) iI).getType()).GetCString(), GC.getSpecialistInfo((SpecialistTypes) iI).getTextKeyWide()));
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_GLOBAL"));
		}
	}

	for (iI = 0; iI < GC.getNumImprovementInfos(); ++iI)
	{
		if (GC.getImprovementInfo((ImprovementTypes)iI).getPrereqTech() == eTech && GC.getImprovementInfo((ImprovementTypes)iI).getImprovementPillage() != NO_IMPROVEMENT)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_TECH_ALLOWS_IMPROVEMENT_UPGRADE", GC.getImprovementInfo((ImprovementTypes)GC.getImprovementInfo((ImprovementTypes)iI).getImprovementPillage()).getTextKeyWide(), GC.getImprovementInfo((ImprovementTypes)iI).getTextKeyWide()));
		}
	}

	//	Enables bridge building...
	buildBridgeString(szBuffer, eTech, true, bPlayerContext);

	//	Can spread irrigation...
	buildIrrigationString(szBuffer, eTech, true, bPlayerContext);

	//	Ignore irrigation...
	buildIgnoreIrrigationString(szBuffer, eTech, true, bPlayerContext);

	//	Coastal work...
	buildWaterWorkString(szBuffer, eTech, true, bPlayerContext);

	//	Enables permanent alliances...
	buildVassalStateString(szBuffer, eTech, true, bPlayerContext);

	//	Build farm, irrigation, etc...
	for (iI = 0; iI < GC.getNumBuildInfos(); ++iI)
	{
		buildImprovementString(szBuffer, eTech, iI, true, bPlayerContext);
	}

	//	Extra moves for certain domains...
	for (iI = 0; iI < NUM_DOMAIN_TYPES; ++iI)
	{
		buildDomainExtraMovesString(szBuffer, eTech, iI, true, bPlayerContext);
	}

	//	Adjusting culture, science, etc
	for (iI = 0; iI < NUM_COMMERCE_TYPES; ++iI)
	{
		buildAdjustString(szBuffer, eTech, iI, true, bPlayerContext);
	}

	//	Enabling trade routes on water...?
	for (iI = 0; iI < GC.getNumTerrainInfos(); ++iI)
	{
		buildTerrainTradeString(szBuffer, eTech, iI, true, bPlayerContext);
	}

	//ls612: Tech Commerce Modifiers
	setCommerceChangeHelp(szBuffer, szTempBuffer, L": ", L"", GC.getTechInfo(eTech).getCommerceModifierArray(), true, true);

	buildRiverTradeString(szBuffer, eTech, true, bPlayerContext);

	//	Special Buildings
	for (iI = 0; iI < GC.getNumSpecialBuildingInfos(); ++iI)
	{
		buildSpecialBuildingString(szBuffer, eTech, iI, true, bPlayerContext);
	}

	for (iI = 0; iI < GC.getNumBuildingInfos(); ++iI)
	{
		const CvBuildingInfo& kBuilding = GC.getBuildingInfo((BuildingTypes)iI);

		if (GC.getGame().canEverConstruct((BuildingTypes)iI))
		{
		//	Building commerce changes
			if (kBuilding.m_bAnyTechCommerceChanges)
				buildBuildingTechCommerceChangeString(szBuffer, eTech, iI, true, bPlayerContext);
		//	Building yield changes
			if (kBuilding.m_bAnyTechYieldChanges)
				buildBuildingTechYieldChangeString(szBuffer, eTech, iI, true, bPlayerContext);
		//	Building specialist count changes
			if (kBuilding.m_bAnyTechSpecialistChanges)
				buildBuildingTechSpecialistChangeString(szBuffer, eTech, iI, true, bPlayerContext);
		//	Building commerce changes
			if (kBuilding.m_bAnyTechCommerceModifiers)
				buildBuildingTechCommerceModifierString(szBuffer, eTech, iI, true, bPlayerContext);
		//	Building yield changes
			if (kBuilding.m_bAnyTechYieldModifiers)
				buildBuildingTechYieldModifierString(szBuffer, eTech, iI, true, bPlayerContext);
		//	Building happy changes
			buildBuildingTechHappinessChangesString(szBuffer, eTech, iI, true, bPlayerContext);
		//	Building health changes
			buildBuildingTechHealthChangesString(szBuffer, eTech, iI, true, bPlayerContext);
		}
	}
	//	Build farm, mine, etc...
	for (iI = 0; iI < GC.getNumImprovementInfos(); ++iI)
	{
		buildYieldChangeString(szBuffer, eTech, iI, true, bPlayerContext);
	}

	bFirst = true;

	for (iI = 0; iI < GC.getNumBonusInfos(); ++iI)
	{
		bFirst = buildBonusRevealString(szBuffer, eTech, iI, bFirst, true, bPlayerContext);
	}

	bFirst = true;

	for (iI = 0; iI < GC.getNumCivicInfos(); ++iI)
	{
		bFirst = buildCivicRevealString(szBuffer, eTech, iI, bFirst, true, bPlayerContext);
	}

	if (!bCivilopediaText)
	{
		bFirst = true;

		for (iI = 0; iI < GC.getNumUnitInfos(); ++iI)
		{
			if (GC.getGame().canEverTrain((UnitTypes) iI)
			&& (!bPlayerContext ||
					!GET_PLAYER(GC.getGame().getActivePlayer()).isProductionMaxedUnit((UnitTypes) iI)
				&&	!GET_PLAYER(GC.getGame().getActivePlayer()).canTrain((UnitTypes) iI)))
			{
				const CvUnitInfo& kUnit = GC.getUnitInfo((UnitTypes) iI);
				if (kUnit.getPrereqAndTech() == eTech)
				{
					szFirstBuffer.Format(L"%s%s", NEWLINE, gDLL->getText("TXT_KEY_TECH_CAN_TRAIN").c_str());
					szTempBuffer.Format( SETCOLR L"%s" ENDCOLR , TEXT_COLOR("COLOR_UNIT_TEXT"), kUnit.getDescription());
					setListHelp(szBuffer, szFirstBuffer, szTempBuffer, L", ", bFirst);
					bFirst = false;
					continue;
				}
				for (int iJ = 0; iJ < GC.getNUM_UNIT_AND_TECH_PREREQS(); iJ++)
				{
					if (kUnit.getPrereqAndTechs(iJ) == eTech)
					{
						szFirstBuffer.Format(L"%s%s", NEWLINE, gDLL->getText("TXT_KEY_TECH_CAN_TRAIN").c_str());
						szTempBuffer.Format( SETCOLR L"%s" ENDCOLR , TEXT_COLOR("COLOR_UNIT_TEXT"), kUnit.getDescription());
						setListHelp(szBuffer, szFirstBuffer, szTempBuffer, L", ", bFirst);
						bFirst = false;
						break;
					}
				}
			}
		}

		bFirst = true;

		for (iI = 0; iI < GC.getNumBuildingInfos(); ++iI)
		{
			const BuildingTypes eLoopBuilding = static_cast<BuildingTypes>(iI);
			if (!bPlayerContext || !GET_PLAYER(GC.getGame().getActivePlayer()).isProductionMaxedBuilding(eLoopBuilding))
			{
				if (GC.getGame().canEverConstruct(eLoopBuilding))
				{
					if (!bPlayerContext || !(GET_PLAYER(GC.getGame().getActivePlayer()).canConstruct(eLoopBuilding, false, true)))
					{
						if (GC.getBuildingInfo(eLoopBuilding).getPrereqAndTech() == eTech)
						{
							szFirstBuffer.Format(L"%s%s", NEWLINE, gDLL->getText("TXT_KEY_TECH_CAN_CONSTRUCT").c_str());
							szTempBuffer.Format( SETCOLR L"<link=%s>%s</link>" ENDCOLR , TEXT_COLOR("COLOR_BUILDING_TEXT"), CvWString(GC.getBuildingInfo(eLoopBuilding).getType()).GetCString(), GC.getBuildingInfo(eLoopBuilding).getDescription());
							setListHelp(szBuffer, szFirstBuffer, szTempBuffer, L", ", bFirst);
							bFirst = false;
						}
						else
						{
							for (int iJ = 0; iJ < GC.getNUM_BUILDING_AND_TECH_PREREQS(); iJ++)
							{
								if (GC.getBuildingInfo(eLoopBuilding).getPrereqAndTechs(iJ) == eTech)
								{
									szFirstBuffer.Format(L"%s%s", NEWLINE, gDLL->getText("TXT_KEY_TECH_CAN_CONSTRUCT").c_str());
									szTempBuffer.Format( SETCOLR L"<link=%s>%s</link>" ENDCOLR , TEXT_COLOR("COLOR_BUILDING_TEXT"), CvWString(GC.getBuildingInfo(eLoopBuilding).getType()).GetCString(), GC.getBuildingInfo(eLoopBuilding).getDescription());
									setListHelp(szBuffer, szFirstBuffer, szTempBuffer, L", ", bFirst);
									bFirst = false;
									break;
								}
							}
						}
					}
				}
			}
		}

		bFirst = true;

		for (iI = 0; iI < GC.getNumProjectInfos(); ++iI)
		{
			if (!bPlayerContext || !(GET_PLAYER(GC.getGame().getActivePlayer()).isProductionMaxedProject((ProjectTypes)iI)))
			{
				if (!bPlayerContext || !(GET_PLAYER(GC.getGame().getActivePlayer()).canCreate(((ProjectTypes)iI), false, true)))
				{
					if (GC.getProjectInfo((ProjectTypes)iI).getTechPrereq() == eTech)
					{
						szFirstBuffer.Format(L"%s%s", NEWLINE, gDLL->getText("TXT_KEY_TECH_CAN_CREATE").c_str());
						szTempBuffer.Format( SETCOLR L"%s" ENDCOLR , TEXT_COLOR("COLOR_PROJECT_TEXT"), GC.getProjectInfo((ProjectTypes)iI).getDescription());
						setListHelp(szBuffer, szFirstBuffer, szTempBuffer, L", ", bFirst);
						bFirst = false;
					}
				}
			}
		}
	}

	bFirst = true;
	for (iI = 0; iI < GC.getNumProcessInfos(); ++iI)
	{
		bFirst = buildProcessInfoString(szBuffer, eTech, iI, bFirst, true, bPlayerContext);
	}

	bFirst = true;
	if (!GC.getGame().isOption(GAMEOPTION_DIVINE_PROPHETS))
	{
		for (iI = 0; iI < GC.getNumReligionInfos(); ++iI)
		{
		/************************************************************************************************/
		/* RevDCM					  Start		 4/29/10												*/
		/*																							  */
		/* OC_LIMITED_RELIGIONS																		 */
		/************************************************************************************************/
			if (!bPlayerContext ||
			(!(GC.getGame().isReligionSlotTaken((ReligionTypes)iI))
			&& GET_PLAYER(GC.getGame().getActivePlayer()).canFoundReligion()) )
		/************************************************************************************************/
		/* LIMITED_RELIGIONS			   END														  */
		/************************************************************************************************/
			{
				bFirst = buildFoundReligionString(szBuffer, eTech, iI, bFirst, true, bPlayerContext);
			}
		}
	}
	else if (!GC.getGame().isOption(GAMEOPTION_LIMITED_RELIGIONS))
	{
		if (GC.getTechInfo(eTech).getFirstFreeProphet() > -1 && GC.getGame().countKnownTechNumTeams(eTech) == 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_TECH_FIRST_FREE_PROPHET"));
			bFirst = false;
		}
	}

	bFirst = true;
	for (iI = 0; iI < GC.getNumCorporationInfos(); ++iI)
	{
		if (GC.getGame().canEverSpread((CorporationTypes)iI))
		{
			if (!bPlayerContext || !(GC.getGame().isCorporationFounded((CorporationTypes)iI)))
			{
				bFirst = buildFoundCorporationString(szBuffer, eTech, iI, bFirst, true, bPlayerContext);
			}
		}
	}

	bFirst = true;
	for (iI = 0; iI < GC.getNumPromotionInfos(); ++iI)
	{
		bFirst = buildPromotionString(szBuffer, eTech, iI, bFirst, true, bPlayerContext);
	}

	bFirst = true;
	for (iI = 0; iI < GC.getNumPromotionInfos(); ++iI)
	{
		if (GC.getPromotionInfo((PromotionTypes)iI).getObsoleteTech() == eTech)
		{
			if (bFirst)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_TECH_OBSOLETES", CvWString(GC.getPromotionInfo((PromotionTypes)iI).getType()).GetCString(), GC.getPromotionInfo((PromotionTypes)iI).getDescription()));
				bFirst = false;
			}
			else
			{
				szTempBuffer.Format(L", <link=%s>%s</link>", CvWString(GC.getPromotionInfo((PromotionTypes)iI).getType()).GetCString(), GC.getPromotionInfo((PromotionTypes)iI).getDescription());
				szBuffer.append(szTempBuffer);
			}
		}
	}

	if (bTreeInfo && NO_TECH == eFromTech)
	{
		buildSingleLineTechTreeString(szBuffer, eTech, bPlayerContext);
	}

	if (!CvWString(GC.getTechInfo(eTech).getHelp()).empty())
	{
		szBuffer.append(CvWString::format(L"%s%s", NEWLINE, GC.getTechInfo(eTech).getHelp()).c_str());
	}

	if (bCivilopediaText || GC.getGame().getActivePlayer() == NO_PLAYER || !GET_PLAYER(GC.getGame().getActivePlayer()).canResearch(eTech))
	{
		for (iI = 0; iI < GC.getTechInfo(eTech).getNumPrereqBuildings(); iI++)
		{
			const int iPrereq = GC.getTechInfo(eTech).getPrereqBuilding(iI).iMinimumRequired;
			if (iPrereq > 0)
			{
				if (GC.getGame().getActivePlayer() == NO_PLAYER)
				{
					const BuildingTypes eLoopBuilding = GC.getTechInfo(eTech).getPrereqBuilding(iI).eBuilding;
					szTempBuffer.Format(L"%s%s", NEWLINE, gDLL->getText("TXT_KEY_BUILDING_REQUIRES_NUM_SPECIAL_BUILDINGS_NO_CITY", GC.getBuildingInfo(eLoopBuilding).getTextKeyWide(), iPrereq).c_str());
				}
				else
				{
					const BuildingTypes eLoopBuilding = GC.getTechInfo(eTech).getPrereqBuilding(iI).eBuilding;
					szTempBuffer.Format(L"%s%s", NEWLINE, gDLL->getText("TXT_KEY_BUILDING_REQUIRES_NUM_SPECIAL_BUILDINGS", GC.getBuildingInfo(eLoopBuilding).getTextKeyWide(), GET_PLAYER(GC.getGame().getActivePlayer()).getBuildingCount(GC.getTechInfo(eTech).getPrereqBuilding(iI).eBuilding), iPrereq).c_str());
				}
				szBuffer.append(szTempBuffer);
			}
		}
	}
	if (bCivilopediaText || GC.getGame().getActivePlayer() == NO_PLAYER || !GET_PLAYER(GC.getGame().getActivePlayer()).canResearch(eTech))
	{
		for (iI = 0; iI < GC.getTechInfo(eTech).getNumPrereqOrBuildings(); iI++)
		{
			int iPrereq = GC.getTechInfo(eTech).getPrereqOrBuilding(iI).iMinimumRequired;
			if (iPrereq > 0)
			{
				if (GC.getGame().getActivePlayer() == NO_PLAYER)
				{
					const BuildingTypes eLoopBuilding = GC.getTechInfo(eTech).getPrereqBuilding(iI).eBuilding;
					szTempBuffer.Format(L"%s%s", NEWLINE, gDLL->getText("TXT_KEY_BUILDING_REQUIRES_NUM_SPECIAL_BUILDINGS_NO_CITY", GC.getBuildingInfo(eLoopBuilding).getTextKeyWide(), iPrereq).c_str());
				}
				else
				{
					const BuildingTypes eLoopBuilding = GC.getTechInfo(eTech).getPrereqBuilding(iI).eBuilding;
					szTempBuffer.Format(L"%s%s", NEWLINE, gDLL->getText("TXT_KEY_BUILDING_REQUIRES_NUM_SPECIAL_BUILDINGS", GC.getBuildingInfo(eLoopBuilding).getTextKeyWide(), GET_PLAYER(GC.getGame().getActivePlayer()).getBuildingCount(GC.getTechInfo(eTech).getPrereqOrBuilding(iI).eBuilding), iPrereq).c_str());
				}
				szBuffer.append(szTempBuffer);
			}
		}
	}

	if (!bCivilopediaText)
	{
		if (GC.getGame().getActivePlayer() == NO_PLAYER)
		{
			szTempBuffer.Format(L"\n%d%c", GC.getTechInfo(eTech).getResearchCost(), GC.getCommerceInfo(COMMERCE_RESEARCH).getChar());
			szBuffer.append(szTempBuffer);
		}
		else if (GET_TEAM(GC.getGame().getActiveTeam()).isHasTech(eTech))
		{
			szTempBuffer.Format(L"\n%d%c", GET_TEAM(GC.getGame().getActiveTeam()).getResearchCost(eTech), GC.getCommerceInfo(COMMERCE_RESEARCH).getChar());
			szBuffer.append(szTempBuffer);
		}
		else
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_TECH_NUM_TURNS", GET_PLAYER(GC.getGame().getActivePlayer()).getResearchTurnsLeft(eTech, (gDLL->ctrlKey() || !(gDLL->shiftKey())))));

			szTempBuffer.Format(L" (%d/%d %c)", GET_TEAM(GC.getGame().getActiveTeam()).getResearchProgress(eTech), GET_TEAM(GC.getGame().getActiveTeam()).getResearchCost(eTech), GC.getCommerceInfo(COMMERCE_RESEARCH).getChar());
			szBuffer.append(szTempBuffer);
		}
	}

	if (GC.getGame().getActivePlayer() != NO_PLAYER)
	{
		if (GET_PLAYER(GC.getGame().getActivePlayer()).canResearch(eTech))
		{
			for (iI = 0; iI < GC.getNumUnitInfos(); ++iI)
			{
				const CvUnitInfo& kUnit = GC.getUnitInfo((UnitTypes)iI);

				if (kUnit.getBaseDiscover() > 0 || kUnit.getDiscoverMultiplier() > 0)
				{
					if (::getDiscoveryTech((UnitTypes)iI, GC.getGame().getActivePlayer()) == eTech)
					{
						szBuffer.append(NEWLINE);
						szBuffer.append(gDLL->getText("TXT_KEY_TECH_GREAT_PERSON_DISCOVER", kUnit.getTextKeyWide()));
					}
				}
			}

			if (GET_PLAYER(GC.getGame().getActivePlayer()).getCurrentEra() < GC.getTechInfo(eTech).getEra())
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_TECH_ERA_ADVANCE", GC.getEraInfo((EraTypes)GC.getTechInfo(eTech).getEra()).getTextKeyWide()));
			}
		}
	}

// BUG - Trade Denial - start
	if (eTradePlayer != NO_PLAYER && GC.getGame().getActivePlayer() != NO_PLAYER && getBugOptionBOOL("MiscHover__TechTradeDenial", true, "BUG_TECH_TRADE_DENIAL_HOVER"))
	{
		TradeData trade;
		trade.m_eItemType = TRADE_TECHNOLOGIES;
		trade.m_iData = eTech;

		if (GET_PLAYER(eTradePlayer).canTradeItem(GC.getGame().getActivePlayer(), trade, false))
		{
			DenialTypes eDenial = GET_PLAYER(eTradePlayer).getTradeDenial(GC.getGame().getActivePlayer(), trade);
			if (eDenial != NO_DENIAL)
			{
				szTempBuffer.Format(SETCOLR L"%s" ENDCOLR, TEXT_COLOR("COLOR_NEGATIVE_TEXT"), GC.getDenialInfo(eDenial).getDescription());
				szBuffer.append(NEWLINE);
				szBuffer.append(szTempBuffer);
			}
		}
	}
// BUG - Trade Denial - end

	if (bStrategyText)
	{
		if (!CvWString(GC.getTechInfo(eTech).getStrategy()).empty())
		{
			if ((GC.getGame().getActivePlayer() == NO_PLAYER) || GET_PLAYER(GC.getGame().getActivePlayer()).isOption(PLAYEROPTION_ADVISOR_HELP))
			{
				szBuffer.append(SEPARATOR);
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_SIDS_TIPS"));
				szBuffer.append(L'\"');
				szBuffer.append(GC.getTechInfo(eTech).getStrategy());
				szBuffer.append(L'\"');
			}
		}
	}
}


void CvGameTextMgr::setBasicUnitHelp(CvWStringBuffer &szBuffer, UnitTypes eUnit, bool bCivilopediaText)
{
	setBasicUnitHelpWithCity(szBuffer, eUnit, bCivilopediaText, 0, false, gDLL->ctrlKey(), gDLL->altKey(), gDLL->shiftKey());
}

void CvGameTextMgr::setBasicUnitHelpWithCity(CvWStringBuffer &szBuffer, UnitTypes eUnit, bool bCivilopediaText, CvCity* pCity, bool bConscript, bool bTBUnitView1, bool bTBUnitView2, bool bTBUnitView3)
{
	if (NO_UNIT == eUnit)
	{
		return;
	}
	PROFILE_FUNC();

	const CvGame& game = GC.getGame();
	CvWString szTempBuffer;
	bool bFirst;
	int iCount;

	const CvUnitInfo& kUnit = GC.getUnitInfo(eUnit);
	//bTBUnitView1 = (Combat)
	//bTBUnitView2 = (Civil)
	//bTBUnitView3 = (Combat Classes)
	//bNormalView = default to show but replaced by any of the above
	bool bNormalView = (!bTBUnitView1 && !bTBUnitView2 && !bTBUnitView3);

	if (bCivilopediaText)
	{
		bTBUnitView1 = true;
		bTBUnitView2 = true;
		bTBUnitView3 = true;
		bNormalView = true;
	}

/*
	//TBGRIDX
	int iX = GC.getTechInfo((TechTypes)GC.getUnitInfo(eUnit).getPrereqAndTech()).getGridX();
	TechTypes eMostAdvancedTech = (TechTypes)GC.getUnitInfo(eUnit).getPrereqAndTech();
	for (int iI = 0; iI < GC.getNumTechInfos(); iI++)
	{
		TechTypes tTech = (TechTypes)iI;
		for (int iJ = 0; iJ < GC.getNUM_UNIT_AND_TECH_PREREQS(); iJ++)
		{
			if (GC.getUnitInfo(eUnit).getPrereqAndTechs(iJ) == tTech)
			{
				if (GC.getTechInfo(tTech).getGridX() > iX)
				{
					iX = GC.getTechInfo(tTech).getGridX();
					eMostAdvancedTech = tTech;
				}
			}
		}
	}
	if (eMostAdvancedTech != NO_TECH)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_UNIT_GRID_X_TEXT", GC.getTechInfo(eMostAdvancedTech).getTextKeyWide(), iX));
	}
*/
	if (!bCivilopediaText)
	{
		szBuffer.append(NEWLINE);

		if (kUnit.getDomainType() == DOMAIN_AIR)
		{
			if (kUnit.getAirCombat() > 0)
			{
				float fBase = (float)kUnit.getTotalModifiedAirCombatStrength100();
				fBase /= 100;

				szTempBuffer.Format(L"%.1f%c, ", fBase, gDLL->getSymbolID(STRENGTH_CHAR));
				szBuffer.append(szTempBuffer);

				//szTempBuffer.Format(L"%d%c, ", kUnit.getAirCombat(), gDLL->getSymbolID(STRENGTH_CHAR));
				//szBuffer.append(szTempBuffer);
			}
		}
		else
		{
			float fCombat = (float)kUnit.getTotalModifiedCombatStrength100();
			int iModifier = kUnit.getCombatStrengthModifier();
			int iAdditional = game.getActiveTeam() == NO_TEAM ? 0 : (GET_TEAM(pCity != NULL ? pCity->getTeam() : game.getActiveTeam()).getUnitStrengthChange(eUnit));
			fCombat += (iModifier * iAdditional);
			fCombat /= 100;

			if (fCombat > 0)
			{
				szTempBuffer.Format(L"%.1f%c, ", fCombat, gDLL->getSymbolID(STRENGTH_CHAR));
				szBuffer.append(szTempBuffer);
			}
		}

		szTempBuffer.Format(L"%d%c", kUnit.getMoves(), gDLL->getSymbolID(MOVES_CHAR));
		szBuffer.append(szTempBuffer);

		if (kUnit.getAirRange() > 0)
		{
			szBuffer.append(L", ");
			szBuffer.append(gDLL->getText("TXT_KEY_UNIT_AIR_RANGE", kUnit.getAirRange()));
		}

// BUG - Starting Experience - start
		if (pCity != NULL && getBugOptionBOOL("MiscHover__UnitExperience", true, "BUG_UNIT_EXPERIENCE_HOVER"))
		{
			setUnitExperienceHelp(szBuffer, L", ", eUnit, pCity, bConscript);
		}
// BUG - Starting Experience - end
	}

	//bTBUnitView1 = (Combat)
	if (bTBUnitView1)
	{
		if (kUnit.getFortRepel() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNIT_FORT_REPEL", kUnit.getFortRepel()));
		}

		if (kUnit.getOverrun() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNIT_OVERRUN", kUnit.getOverrun()));
		}
		//Basic Combat Modifiers
		if (kUnit.isNoDefensiveBonus())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNIT_NO_DEFENSE_BONUSES"));
		}

		if (kUnit.getAttackCombatModifier() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNIT_ATTACK_MODIFIER", kUnit.getAttackCombatModifier()));
		}

		if (kUnit.getDefenseCombatModifier() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNIT_DEFENSE_MODIFIER", kUnit.getDefenseCombatModifier()));
		}

		if (kUnit.getCityAttackModifier() == kUnit.getCityDefenseModifier())
		{
			if (kUnit.getCityAttackModifier() != 0)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_UNIT_CITY_STRENGTH_MOD", kUnit.getCityAttackModifier()));
			}
		}
		else
		{
			if (kUnit.getCityAttackModifier() != 0)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_UNIT_CITY_ATTACK_MOD", kUnit.getCityAttackModifier()));
			}

			if (kUnit.getCityDefenseModifier() != 0)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_UNIT_CITY_DEFENSE_MOD", kUnit.getCityDefenseModifier()));
			}
		}

		for (int iI = 0; iI < NUM_DOMAIN_TYPES; ++iI)
		{
			if (kUnit.getDomainModifier(iI) != 0)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_UNIT_MOD_VS_TYPE_NO_LINK", kUnit.getDomainModifier(iI), CvWString(GC.getDomainInfo((DomainTypes)iI).getType()).GetCString(), GC.getDomainInfo((DomainTypes)iI).getTextKeyWide()));
			}
		}

		if (kUnit.getHillsDefenseModifier() == kUnit.getHillsAttackModifier())
		{
			if (kUnit.getHillsAttackModifier() != 0)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_UNIT_HILLS_STRENGTH", kUnit.getHillsAttackModifier()));
			}
		}
		else
		{
			if (kUnit.getHillsAttackModifier() != 0)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_UNIT_HILLS_ATTACK", kUnit.getHillsAttackModifier()));
			}

			if (kUnit.getHillsDefenseModifier() != 0)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_UNIT_HILLS_DEFENSE", kUnit.getHillsDefenseModifier()));
			}
		}

		bFirst = true;
		for (int iI = 0; iI < GC.getNumTerrainInfos(); ++iI)
		{
			if (kUnit.getTerrainDefenseModifier(iI) != 0)
			{
				if (!bFirst)
				{
					szBuffer.append(gDLL->getText("TXT_KEY_COMMA"));
				}
				if (bFirst)
				{
					szBuffer.append(NEWLINE);
					bFirst = false;
				}
				szBuffer.append(gDLL->getText("TXT_KEY_UNIT_DEFENSE", kUnit.getTerrainDefenseModifier(iI), GC.getTerrainInfo((TerrainTypes) iI).getTextKeyWide()));
			}
		}

		bFirst = true;
		for (int iI = 0; iI < GC.getNumTerrainInfos(); ++iI)
		{
			if (kUnit.getTerrainAttackModifier(iI) != 0)
			{
				if (!bFirst)
				{
					szBuffer.append(gDLL->getText("TXT_KEY_COMMA"));
				}
				if (bFirst)
				{
					szBuffer.append(NEWLINE);
					bFirst = false;
				}
				szBuffer.append(gDLL->getText("TXT_KEY_UNIT_ATTACK", kUnit.getTerrainAttackModifier(iI), GC.getTerrainInfo((TerrainTypes) iI).getTextKeyWide()));
			}
		}

		bFirst = true;
		for (int iI = 0; iI < GC.getNumFeatureInfos(); ++iI)
		{
			if (kUnit.getFeatureDefenseModifier(iI) != 0)
			{
				if (!bFirst)
				{
					szBuffer.append(gDLL->getText("TXT_KEY_COMMA"));
				}
				if (bFirst)
				{
					szBuffer.append(NEWLINE);
					bFirst = false;
				}
				szBuffer.append(gDLL->getText("TXT_KEY_UNIT_DEFENSE", kUnit.getFeatureDefenseModifier(iI), GC.getFeatureInfo((FeatureTypes) iI).getTextKeyWide()));
			}
		}

		bFirst = true;
		for (int iI = 0; iI < GC.getNumFeatureInfos(); ++iI)
		{
			if (kUnit.getFeatureAttackModifier(iI) != 0)
			{
				if (!bFirst)
				{
					szBuffer.append(gDLL->getText("TXT_KEY_COMMA"));
				}
				if (bFirst)
				{
					szBuffer.append(NEWLINE);
					bFirst = false;
				}
				szBuffer.append(gDLL->getText("TXT_KEY_UNIT_ATTACK", kUnit.getFeatureAttackModifier(iI), GC.getFeatureInfo((FeatureTypes) iI).getTextKeyWide()));
			}
		}

		bFirst = true;
		for (int iI = 0; iI < GC.getNumUnitInfos(); ++iI)
		{
			if (kUnit.getUnitAttackModifier(iI) == GC.getUnitInfo(eUnit).getUnitDefenseModifier(iI))
			{
				if (kUnit.getUnitAttackModifier(iI) != 0)
				{
					if (!bFirst)
					{
						szBuffer.append(gDLL->getText("TXT_KEY_COMMA"));
					}
					if (bFirst)
					{
						szBuffer.append(NEWLINE);
						bFirst = false;
					}
					szBuffer.append(gDLL->getText("TXT_KEY_UNIT_MOD_VS_TYPE", kUnit.getUnitAttackModifier(iI),
						CvWString(GC.getUnitInfo((UnitTypes)iI).getType()).GetCString(), GC.getUnitInfo((UnitTypes)iI).getTextKeyWide()));
				}
			}
			else
			{
				if (kUnit.getUnitAttackModifier(iI) != 0)
				{
					if (!bFirst)
					{
						szBuffer.append(gDLL->getText("TXT_KEY_COMMA"));
					}
					if (bFirst)
					{
						szBuffer.append(NEWLINE);
						bFirst = false;
					}
					szBuffer.append(gDLL->getText("TXT_KEY_UNIT_ATTACK_MOD_VS_CLASS", kUnit.getUnitAttackModifier(iI),
						CvWString(GC.getUnitInfo((UnitTypes)iI).getType()).GetCString(), GC.getUnitInfo((UnitTypes)iI).getTextKeyWide()));
				}
			}
		}

		bFirst = true;
		for (int iI = 0; iI < GC.getNumUnitInfos(); ++iI)
		{
			if (kUnit.getUnitDefenseModifier(iI) != 0)
			{
				if (!bFirst)
				{
					szBuffer.append(gDLL->getText("TXT_KEY_COMMA"));
				}
				if (bFirst)
				{
					szBuffer.append(NEWLINE);
					bFirst = false;
				}
				szBuffer.append(gDLL->getText("TXT_KEY_UNIT_DEFENSE_MOD_VS_CLASS", kUnit.getUnitDefenseModifier(iI),
					CvWString(GC.getUnitInfo((UnitTypes) iI).getType()).GetCString(), GC.getUnitInfo((UnitTypes) iI).getTextKeyWide()));
			}
		}

		bFirst = true;
		for (int iI = 0; iI < GC.getNumUnitCombatInfos(); ++iI)
		{
			if (kUnit.getUnitCombatModifier(iI) != 0)
			{
				if (!bFirst)
				{
					szBuffer.append(gDLL->getText("TXT_KEY_COMMA"));
				}
				if (bFirst)
				{
					szBuffer.append(NEWLINE);
					bFirst = false;
				}
				szBuffer.append(gDLL->getText("TXT_KEY_UNIT_MOD_VS_TYPE", kUnit.getUnitCombatModifier(iI), CvWString(GC.getUnitCombatInfo((UnitCombatTypes) iI).getType()).GetCString(), GC.getUnitCombatInfo((UnitCombatTypes) iI).getTextKeyWide()));
			}
		}

		if (kUnit.getReligiousCombatModifier() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNIT_RELIGIOUS_COMBAT_MODIFIER", kUnit.getReligiousCombatModifier()));
		}

		if (kUnit.getVSBarbs() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNIT_VSBARBS", kUnit.getVSBarbs()));
		}

		if (kUnit.getAnimalCombatModifier() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNIT_ANIMAL_COMBAT_MOD", kUnit.getAnimalCombatModifier()));
		}

		//Advanced Combat Modifiers
			//Armor
		if (kUnit.getArmor() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNIT_ARMOR_BASE", kUnit.getArmor()));
		}

		bFirst = true;
		for (int iI = 0; iI < GC.getNumUnitCombatInfos(); ++iI)
		{
			if (kUnit.getArmorVSUnitCombatType(iI) != 0)
			{
				if (!bFirst)
				{
					szBuffer.append(gDLL->getText("TXT_KEY_COMMA"));
				}
				if (bFirst)
				{
					szBuffer.append(NEWLINE);
					bFirst = false;
				}
				szBuffer.append(gDLL->getText("TXT_KEY_UNIT_ARMOR_VS_TYPE", kUnit.getArmorVSUnitCombatType(iI), CvWString(GC.getUnitCombatInfo((UnitCombatTypes) iI).getType()).GetCString(), GC.getUnitCombatInfo((UnitCombatTypes) iI).getTextKeyWide()));
			}
		}

			//puncture
		if (kUnit.getPuncture() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNIT_PUNCTURE", kUnit.getPuncture()));
		}

		bFirst = true;
		for (int iI = 0; iI < GC.getNumUnitCombatInfos(); ++iI)
		{
			if (kUnit.getPunctureVSUnitCombatType(iI) != 0)
			{
				if (!bFirst)
				{
					szBuffer.append(gDLL->getText("TXT_KEY_COMMA"));
				}
				if (bFirst)
				{
					szBuffer.append(NEWLINE);
					bFirst = false;
				}
				szBuffer.append(gDLL->getText("TXT_KEY_UNIT_PUNCTURE_VS_TYPE", kUnit.getPunctureVSUnitCombatType(iI), CvWString(GC.getUnitCombatInfo((UnitCombatTypes) iI).getType()).GetCString(), GC.getUnitCombatInfo((UnitCombatTypes) iI).getTextKeyWide()));
			}
		}

		//damage
		if (kUnit.getDamageModifier() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNIT_DAMAGE_MODIFIER", kUnit.getDamageModifier()));
		}

		//dodge
		if (kUnit.getDodgeModifier() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNIT_DODGE_MODIFIER", kUnit.getDodgeModifier()));
		}

		bFirst = true;
		for (int iI = 0; iI < GC.getNumUnitCombatInfos(); ++iI)
		{
			if (kUnit.getDodgeVSUnitCombatType(iI) != 0)
			{
				if (!bFirst)
				{
					szBuffer.append(gDLL->getText("TXT_KEY_COMMA"));
				}
				if (bFirst)
				{
					szBuffer.append(NEWLINE);
					bFirst = false;
				}
				szBuffer.append(gDLL->getText("TXT_KEY_UNIT_DODGE_VS_TYPE", kUnit.getDodgeVSUnitCombatType(iI), CvWString(GC.getUnitCombatInfo((UnitCombatTypes) iI).getType()).GetCString(), GC.getUnitCombatInfo((UnitCombatTypes) iI).getTextKeyWide()));
			}
		}

			//precision
		if (kUnit.getPrecisionModifier() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNIT_PRECISION_MODIFIER", kUnit.getPrecisionModifier()));
		}

		bFirst = true;
		for (int iI = 0; iI < GC.getNumUnitCombatInfos(); ++iI)
		{
			if (kUnit.getPrecisionVSUnitCombatType(iI) != 0)
			{
				if (!bFirst)
				{
					szBuffer.append(gDLL->getText("TXT_KEY_COMMA"));
				}
				if (bFirst)
				{
					szBuffer.append(NEWLINE);
					bFirst = false;
				}
				szBuffer.append(gDLL->getText("TXT_KEY_UNIT_PRECISION_VS_TYPE", kUnit.getPrecisionVSUnitCombatType(iI), CvWString(GC.getUnitCombatInfo((UnitCombatTypes)iI).getType()).GetCString(), GC.getUnitCombatInfo((UnitCombatTypes) iI).getTextKeyWide()));
			}
		}

		if (kUnit.getCombatModifierPerSizeMore() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNIT_COMBAT_MOD_PER_SIZE_MORE", kUnit.getCombatModifierPerSizeMore()));
		}

		if (kUnit.getCombatModifierPerSizeLess() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNIT_COMBAT_MOD_PER_SIZE_LESS", kUnit.getCombatModifierPerSizeLess()));
		}

		if (kUnit.getCombatModifierPerVolumeMore() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNIT_COMBAT_MOD_PER_VOLUME_MORE", kUnit.getCombatModifierPerVolumeMore()));
		}

		if (kUnit.getCombatModifierPerVolumeLess() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNIT_COMBAT_MOD_PER_VOLUME_LESS", kUnit.getCombatModifierPerVolumeLess()));
		}

		//Withdrawal
		if (kUnit.getCombatLimit() < GC.getMAX_HIT_POINTS() && kUnit.getCombat() > 0 && !kUnit.isOnlyDefensive())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNIT_COMBAT_LIMIT", (100 * kUnit.getCombatLimit()) / GC.getMAX_HIT_POINTS()));
		}

		if (kUnit.getAirCombatLimit() < GC.getMAX_HIT_POINTS() && kUnit.getAirCombat() > 0 && !kUnit.isOnlyDefensive())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNIT_COMBAT_LIMIT", (100 * kUnit.getAirCombatLimit()) / GC.getMAX_HIT_POINTS()));
		}

		if (kUnit.getWithdrawalProbability() > 0)
		{
			if(GC.getUnitInfo(eUnit).isSpy())
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_UNIT_ESCAPE_SPY", kUnit.getWithdrawalProbability()));
			}
			else
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_UNIT_WITHDRAWL_PROBABILITY", kUnit.getWithdrawalProbability()));
			}
		}

		bFirst = true;
		for (int iI = 0; iI < GC.getNumUnitCombatInfos(); ++iI)
		{
			if (kUnit.getWithdrawVSUnitCombatType(iI) != 0)
			{
				if (!bFirst)
				{
					szBuffer.append(gDLL->getText("TXT_KEY_COMMA"));
				}
				if (bFirst)
				{
					szBuffer.append(NEWLINE);
					bFirst = false;
				}
				szBuffer.append(gDLL->getText("TXT_KEY_UNIT_WITHDRAW_VS_TYPE", kUnit.getWithdrawVSUnitCombatType(iI), CvWString(GC.getUnitCombatInfo((UnitCombatTypes)iI).getTextKeyWide()).GetCString(), GC.getUnitCombatInfo((UnitCombatTypes) iI).getTextKeyWide()));
			}
		}

		if (kUnit.getEarlyWithdraw() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNIT_EARLY_WITHDRAW", kUnit.getEarlyWithdraw()));
		}

		if (kUnit.getWithdrawAdjperAtt() > 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNIT_REFLEXES", kUnit.getWithdrawAdjperAtt()));
		}

		if (kUnit.getWithdrawAdjperAtt() < 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNIT_FRAYS", kUnit.getWithdrawAdjperAtt()));
		}

		//Pursuit
		if (kUnit.getPursuit() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNIT_PURSUIT", kUnit.getPursuit()));
		}

		bFirst = true;
		for (int iI = 0; iI < GC.getNumUnitCombatInfos(); ++iI)
		{
			if (kUnit.getPursuitVSUnitCombatType(iI) != 0)
			{
				if (!bFirst)
				{
					szBuffer.append(gDLL->getText("TXT_KEY_COMMA"));
				}
				if (bFirst)
				{
					szBuffer.append(NEWLINE);
					bFirst = false;
				}
				szBuffer.append(gDLL->getText("TXT_KEY_UNIT_PURSUIT_VS_TYPE", kUnit.getPursuitVSUnitCombatType(iI), CvWString(GC.getUnitCombatInfo((UnitCombatTypes)iI).getType()).GetCString(), GC.getUnitCombatInfo((UnitCombatTypes) iI).getTextKeyWide()));
			}
		}

		//Repel
		if (kUnit.getRepel() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNIT_REPEL", kUnit.getRepel()));
		}

		if (kUnit.getRepelRetries() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNIT_REPEL_RETRIES", kUnit.getRepelRetries()));
		}

		bFirst = true;
		for (int iI = 0; iI < GC.getNumUnitCombatInfos(); ++iI)
		{
			if (kUnit.getRepelVSUnitCombatType(iI) != 0)
			{
				if (!bFirst)
				{
					szBuffer.append(gDLL->getText("TXT_KEY_COMMA"));
				}
				if (bFirst)
				{
					szBuffer.append(NEWLINE);
					bFirst = false;
				}
				szBuffer.append(gDLL->getText("TXT_KEY_UNIT_REPEL_VS_TYPE", kUnit.getRepelVSUnitCombatType(iI), CvWString(GC.getUnitCombatInfo((UnitCombatTypes)iI).getType()).GetCString(), GC.getUnitCombatInfo((UnitCombatTypes) iI).getTextKeyWide()));
			}
		}

		//Knockback
		if (kUnit.getKnockback() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNIT_KNOCKBACK", kUnit.getKnockback()));
		}

		if (kUnit.getKnockbackRetries() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNIT_KNOCKBACK_RETRIES", kUnit.getKnockbackRetries()));
		}

		bFirst = true;
		for (int iI = 0; iI < GC.getNumUnitCombatInfos(); ++iI)
		{
			if (kUnit.getKnockbackVSUnitCombatType(iI) != 0)
			{
				if (!bFirst)
				{
					szBuffer.append(gDLL->getText("TXT_KEY_COMMA"));
				}
				if (bFirst)
				{
					szBuffer.append(NEWLINE);
					bFirst = false;
				}
				szBuffer.append(gDLL->getText("TXT_KEY_UNIT_KNOCKBACK_VS_TYPE", kUnit.getKnockbackVSUnitCombatType(iI), CvWString(GC.getUnitCombatInfo((UnitCombatTypes)iI).getType()).GetCString(), GC.getUnitCombatInfo((UnitCombatTypes) iI).getTextKeyWide()));
			}
		}

		//Unyielding
		if (kUnit.getUnyielding() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNIT_UNYIELDING", kUnit.getUnyielding()));
		}

		//Movement pertaining to Combat
		if (kUnit.isStampede())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNIT_STAMPEDE"));
		}

		if (kUnit.isOnslaught())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNIT_ONSLAUGHT"));
		}

		//First Strikes
		if (kUnit.getFirstStrikes() + kUnit.getChanceFirstStrikes() > 0)
		{
			if (kUnit.getChanceFirstStrikes() == 0)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_FIRST_STRIKES", kUnit.getFirstStrikes()));
			}
			else
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_FIRST_STRIKE_CHANCES", kUnit.getFirstStrikes(), kUnit.getFirstStrikes() + kUnit.getChanceFirstStrikes()));
			}
		}

		//Immunity to First Strikes
		if (kUnit.isFirstStrikeImmune())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_FIRST_STRIKES_IMMUNE"));
		}

		//Siege
			//Breakdown Chance
		if (kUnit.getBreakdownChance() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_BREAKDOWN_CHANCE", kUnit.getBreakdownChance()));
		}
			//Breakdown Damage
		if (kUnit.getBreakdownDamage() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_BREAKDOWN_DAMAGE", kUnit.getBreakdownDamage()));
		}

			//Attack Only Cities
		if (kUnit.isAttackOnlyCities())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_CAN_ONLY_ATTACK_CITIES"));
		}

			//Ignore No Entry
		if (kUnit.isIgnoreNoEntryLevel())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_CAN_ALWAYS_ATTACK_CITIES"));
		}

			//Bombard
		if (GC.isDCM_RANGE_BOMBARD())
		{
			if (kUnit.getDCMBombRange() > 0 || kUnit.getDCMBombAccuracy() > 0)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_IS_DCM_BOMBARD"));
			}
			if (kUnit.getDCMBombRange() > 0)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_DCM_BOMB_RANGE_TEXT", kUnit.getDCMBombRange()));
			}
			if (kUnit.getDCMBombAccuracy() > 0)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_DCM_BOMB_ACCURACY_TEXT", kUnit.getDCMBombAccuracy()));
			}
			if (kUnit.getRBombardDamage() > 0)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_DCM_BOMB_DAMAGE_TEXT", kUnit.getRBombardDamage()));
			}
			if (kUnit.getRBombardDamageLimit() > 0)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_DCM_BOMB_DAMAGE_LIMIT_TEXT", kUnit.getRBombardDamageLimit()));
			}
			if (kUnit.getRBombardDamageMaxUnits() > 0)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_DCM_BOMB_DAMAGE_MAX_UNITS_TEXT", kUnit.getRBombardDamageMaxUnits()));
			}
		}

		if (kUnit.getBombardRate() > 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNIT_BOMBARD_RATE", ((kUnit.getBombardRate() * 100) / GC.getMAX_CITY_DEFENSE_DAMAGE())));
		}

		if (kUnit.getBombRate() > 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNIT_BOMB_RATE", ((kUnit.getBombRate() * 100) / GC.getMAX_CITY_DEFENSE_DAMAGE())));
		}

			//Collateral
		if (kUnit.getCollateralDamage() > 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNIT_COLLATERAL_DAMAGE_REVDCM", 100 * kUnit.getCollateralDamageLimit() / GC.getMAX_HIT_POINTS(), GC.getUnitInfo(eUnit).getCollateralDamageMaxUnits()));
		}

		//Flanking
		bFirst = true;
		for (int iI = 0; iI < GC.getNumUnitInfos(); ++iI)
		{
			int iFlank = kUnit.getFlankingStrikeUnit(iI);
			if (iFlank > 0)
			{
				if (bFirst)
				{
					szBuffer.append(NEWLINE);
					bFirst = false;
				}
				else
				{
					szBuffer.append(L", ");
				}
				szBuffer.append(gDLL->getText("TXT_KEY_UNIT_COMBAT_FLANKING_STRIKES", iFlank, GC.getUnitInfo((UnitTypes)iI).getDescription()));
			}
		}

		bFirst = true;
		for (int iI = 0; iI < GC.getNumUnitCombatInfos(); ++iI)
		{
			int iFlank = kUnit.getFlankingStrengthbyUnitCombatType(iI);
			if (iFlank > 0)
			{
				if (bFirst)
				{
					szBuffer.append(NEWLINE);
					bFirst = false;
				}
				else
				{
					szBuffer.append(L", ");
				}

				szBuffer.append(gDLL->getText("TXT_KEY_UNIT_COMBAT_FLANKING_STRIKES", iFlank, GC.getUnitCombatInfo((UnitCombatTypes)iI).getDescription()));
			}
		}

		//Interception and Evasion
		if (kUnit.getInterceptionProbability() > 0)
		{
			if(kUnit.isSpy())
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_UNIT_INTERCEPT_AIRCRAFT_SPY", kUnit.getInterceptionProbability()));
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_UNIT_INTERCEPT_AIRCRAFT_SPY_COUNTER", kUnit.getInterceptionProbability() * 5));
			}
			else
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_UNIT_INTERCEPT_AIRCRAFT", kUnit.getInterceptionProbability()));
			}
		}

		if (kUnit.getEvasionProbability() > 0)
		{
			if(kUnit.isSpy())
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_UNIT_EVADE_INTERCEPTION_SPY", kUnit.getEvasionProbability()));
			}
			else
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_UNIT_EVADE_INTERCEPTION", kUnit.getEvasionProbability()));
			}
		}

		if (GC.isDCM_FIGHTER_ENGAGE())
		{
			if (kUnit.getDCMFighterEngage())
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_IS_FIGHTER_ENGAGE"));
			}
		}

		//Surround and Destroy
		if (game.isOption(GAMEOPTION_SAD))
		{
			if (kUnit.getUnnerve() != 0)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_UNIT_UNNERVE", kUnit.getUnnerve()));
			}
			if (kUnit.getEnclose() != 0)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_UNIT_ENCLOSE", kUnit.getEnclose()));
			}
			if (kUnit.getLunge() != 0)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_UNIT_LUNGE", kUnit.getLunge()));
			}
			if (kUnit.getDynamicDefense() != 0)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_UNIT_DYNAMIC_DEFENSE", kUnit.getDynamicDefense()));
			}
		}

		//Power Shots
		if (kUnit.getPowerShots() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNIT_POWER_SHOTS", kUnit.getPowerShots()));
		}

		if (kUnit.getPowerShotCombatModifier() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNIT_POWER_SHOT_COMBAT_MODIFIER", kUnit.getPowerShotCombatModifier()));
		}

		if (kUnit.getPowerShotPunctureModifier() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNIT_POWER_SHOT_PUNCTURE_MODIFIER", kUnit.getPowerShotPunctureModifier()));
		}

		if (kUnit.getPowerShotPrecisionModifier() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNIT_POWER_SHOT_PRECISION_MODIFIER", kUnit.getPowerShotPrecisionModifier()));
		}

		if (kUnit.getPowerShotCriticalModifier() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNIT_POWER_SHOT_CRITICAL_MODIFIER", kUnit.getPowerShotCriticalModifier()));
		}

		//Stuns and afflictions
		//Critical
		if (kUnit.getCriticalModifier() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNIT_CRITICAL_MODIFIER", kUnit.getCriticalModifier()));
		}

		bFirst = true;
		for (int iI = 0; iI < GC.getNumUnitCombatInfos(); ++iI)
		{
			if (kUnit.getCriticalVSUnitCombatType(iI) != 0)
			{
				if (!bFirst)
				{
					szBuffer.append(gDLL->getText("TXT_KEY_COMMA"));
				}
				if (bFirst)
				{
					szBuffer.append(NEWLINE);
					bFirst = false;
				}
				szBuffer.append(gDLL->getText("TXT_KEY_UNIT_CRITICAL_VS_TYPE", kUnit.getCriticalVSUnitCombatType(iI), CvWString(GC.getUnitCombatInfo((UnitCombatTypes) iI).getType()).GetCString(), GC.getUnitCombatInfo((UnitCombatTypes) iI).getTextKeyWide()));
			}
		}
		//Stun
		if (kUnit.getRoundStunProb() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNIT_ROUND_STUN_PROB", kUnit.getRoundStunProb()));
		}

		bFirst = true;
		for (int iI = 0; iI < GC.getNumUnitCombatInfos(); ++iI)
		{
			if (kUnit.getRoundStunVSUnitCombatType(iI) != 0)
			{
				if (!bFirst)
				{
					szBuffer.append(gDLL->getText("TXT_KEY_COMMA"));
				}
				if (bFirst)
				{
					szBuffer.append(NEWLINE);
					bFirst = false;
				}
				szBuffer.append(gDLL->getText("TXT_KEY_UNIT_ROUND_STUN_VS_TYPE", kUnit.getRoundStunVSUnitCombatType(iI), CvWString(GC.getUnitCombatInfo((UnitCombatTypes) iI).getType()).GetCString(), GC.getUnitCombatInfo((UnitCombatTypes) iI).getTextKeyWide()));
			}
		}

		//Traps
		int iValue = 0;
		bFirst = true;
		for (int iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
		{
			iValue = kUnit.getTrapDisableUnitCombatType(iI);
			if (iValue != 0)
			{
				if (!bFirst)
				{
					szBuffer.append(gDLL->getText("TXT_KEY_COMMA"));
				}
				if (bFirst)
				{
					szBuffer.append(NEWLINE);
					bFirst = false;
				}
				szBuffer.append(gDLL->getText("TXT_KEY_UNIT_TRAP_DISABLE_TYPE", iValue, CvWString(GC.getUnitCombatInfo((UnitCombatTypes) iI).getType()).GetCString(), GC.getUnitCombatInfo((UnitCombatTypes) iI).getTextKeyWide()));
			}
		}
		iValue = 0;
		bFirst = true;
		for (int iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
		{
			iValue = kUnit.getTrapAvoidanceUnitCombatType(iI);
			if (iValue != 0)
			{
				if (!bFirst)
				{
					szBuffer.append(gDLL->getText("TXT_KEY_COMMA"));
				}
				if (bFirst)
				{
					szBuffer.append(NEWLINE);
					bFirst = false;
				}
				szBuffer.append(gDLL->getText("TXT_KEY_UNIT_TRAP_AVOID_TYPE", iValue, CvWString(GC.getUnitCombatInfo((UnitCombatTypes) iI).getType()).GetCString(), GC.getUnitCombatInfo((UnitCombatTypes) iI).getTextKeyWide()));
			}
		}
		iValue = 0;
		bFirst = true;
		for (int iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
		{
			iValue = kUnit.getTrapTriggerUnitCombatType(iI);
			if (iValue != 0)
			{
				if (!bFirst)
				{
					szBuffer.append(gDLL->getText("TXT_KEY_COMMA"));
				}
				if (bFirst)
				{
					szBuffer.append(NEWLINE);
					bFirst = false;
				}
				szBuffer.append(gDLL->getText("TXT_KEY_UNIT_TRAP_TRIGGER_TYPE", iValue, CvWString(GC.getUnitCombatInfo((UnitCombatTypes) iI).getType()).GetCString(), GC.getUnitCombatInfo((UnitCombatTypes) iI).getTextKeyWide()));
			}
		}
		bFirst = true;
		for (int iI = 0; iI < kUnit.getNumTrapSetWithPromotionTypes(); iI++)
		{
			PromotionTypes eTrapPromo = (PromotionTypes)kUnit.getTrapSetWithPromotionType(iI);
			if (iValue != 0)
			{
				if (!bFirst)
				{
					szBuffer.append(gDLL->getText("TXT_KEY_COMMA"));
				}
				if (bFirst)
				{
					szBuffer.append(NEWLINE);
					bFirst = false;
				}
				szBuffer.append(gDLL->getText("TXT_KEY_UNIT_TRAP_PROMOTION_TYPE", GC.getPromotionInfo(eTrapPromo).getTextKeyWide()));
			}
		}
		bFirst = true;
		for (int iI = 0; iI < kUnit.getNumTrapImmunityUnitCombatTypes(); iI++)
		{
			UnitCombatTypes eTrapUnitCombat = (UnitCombatTypes)kUnit.getTrapImmunityUnitCombatType(iI);
			if (iValue != 0)
			{
				if (!bFirst)
				{
					szBuffer.append(gDLL->getText("TXT_KEY_COMMA"));
				}
				if (bFirst)
				{
					szBuffer.append(NEWLINE);
					bFirst = false;
				}
				szBuffer.append(gDLL->getText("TXT_KEY_UNIT_TRAP_IMMUNE_TYPE", GC.getUnitCombatInfo(eTrapUnitCombat).getTextKeyWide()));
			}
		}
		int iTrapMin = kUnit.getTrapDamageMin();
		int iTrapMax = kUnit.getTrapDamageMax();
		if (iTrapMax > 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNIT_TRAP_DAMAGE", iTrapMin, iTrapMax));
		}

		int iNumTriggers = kUnit.getNumTriggers();
		if (iNumTriggers > 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNIT_TRAP_NUM_TRIGGERS", iNumTriggers));
		}

		if (kUnit.isTriggerBeforeAttack())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNIT_TRAP_TRIGGER_BEFORE_ATTACK"));
		}

		int iComplexity = kUnit.getTrapComplexity();
		if (iComplexity > 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNIT_TRAP_COMPLEXITY", iComplexity));
		}

		//Afflict on Attack
		for (int iI = 0; iI < kUnit.getNumAfflictOnAttackTypes(); ++iI)
		{
			PromotionLineTypes eAfflictionLine = ((PromotionLineTypes)GC.getUnitInfo(eUnit).getAfflictOnAttackType(iI).eAfflictionLine);
			int iProbability = kUnit.getAfflictOnAttackType(iI).iProbability;
			if (kUnit.getAfflictOnAttackType(iI).iImmediate > 0)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_AFFLICT_ON_ATTACK_IMMEDIATE_TEXT", iProbability, GC.getPromotionLineInfo(eAfflictionLine).getDescription()));
			}
			else
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_AFFLICT_ON_ATTACK_TEXT", iProbability, GC.getPromotionLineInfo(eAfflictionLine).getDescription()));
			}
		}

		if (kUnit.getPoisonProbabilityModifier() > 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNIT_POISON_PROB", kUnit.getPoisonProbabilityModifier()));
		}

		if (kUnit.getPoisonProbabilityModifier() < 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNIT_POISON_PROB_NEG", kUnit.getPoisonProbabilityModifier()));
		}

			//Cold Dmg
		if (kUnit.isDealsColdDamage())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNIT_DEALS_COLD_DAMAGE"));
		}

		//Str Per
		if (kUnit.getStrAdjperRnd() > 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNIT_RAGE", kUnit.getStrAdjperRnd()));
		}

		if (kUnit.getStrAdjperRnd() < 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNIT_FATIGUE", kUnit.getStrAdjperRnd()));
		}

		if (kUnit.getStrAdjperAtt() > 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNIT_RAMPAGE", kUnit.getStrAdjperAtt()));
		}

		if (kUnit.getStrAdjperAtt() < 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNIT_TIRES", kUnit.getStrAdjperAtt()));
		}

		if (kUnit.getStrAdjperDef() > 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNIT_DETERMINATION", kUnit.getStrAdjperDef()));
		}

		if (kUnit.getStrAdjperDef() < 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNIT_DEMORALIZATION", kUnit.getStrAdjperDef()));
		}
	}

	//bTBUnitView2 = (Civil)
	int iCargoValue = kUnit.getCargoSpace();
	if (bTBUnitView2)
	{
		//Cargo
		if (game.isOption(GAMEOPTION_SIZE_MATTERS))
		{
			if (iCargoValue > 0)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_CARGO_SPACE_BASE_SM", iCargoValue));

				if (kUnit.getSMSpecialCargo() != NO_SPECIALUNIT)
				{
					szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_CARRIES", GC.getSpecialUnitInfo((SpecialUnitTypes) kUnit.getSMSpecialCargo()).getTextKeyWide()));
				}
				if (kUnit.getSMNotSpecialCargo() != NO_SPECIALUNIT)
				{
					szBuffer.append(gDLL->getText("TXT_KEY_PROMOHELP_CHANGE_NOT_SPECIAL_CARGO", GC.getSpecialUnitInfo((SpecialUnitTypes) kUnit.getSMNotSpecialCargo()).getTextKeyWide()));
				}
			}
		}
		else if (iCargoValue > 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_CARGO_SPACE_FOREIGN", iCargoValue));

			if (kUnit.getSpecialCargo() != NO_SPECIALUNIT)
			{
				szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_CARRIES", GC.getSpecialUnitInfo((SpecialUnitTypes) kUnit.getSpecialCargo()).getTextKeyWide()));
			}
		}

		if (game.isOption(GAMEOPTION_OUTBREAKS_AND_AFFLICTIONS))
		{
			int iAidChange = 0;
			//Curing, resisting and overcoming afflictions
			for (int iI=0; iI < GC.getNumPropertyInfos(); iI++)
			{
				iAidChange = kUnit.getAidChange(iI);
				if (iAidChange != 0)
				{
					PropertyTypes eProperty = (PropertyTypes)iI;
					szBuffer.append(NEWLINE);
					szBuffer.append(gDLL->getText("TXT_KEY_UNIT_AID", GC.getPropertyInfo(eProperty).getDescription(), iAidChange));
				}
			}

			bFirst = true;
			for (int iI = 0; iI < kUnit.getNumCureAfflictionTypes(); ++iI)
			{
				PromotionLineTypes eAfflictionLine = ((PromotionLineTypes)kUnit.getCureAfflictionType(iI));
				if (!bFirst)
				{
					szBuffer.append(gDLL->getText("TXT_KEY_COMMA"));
				}
				if (bFirst)
				{
					szBuffer.append(NEWLINE);
					bFirst = false;
				}
				szBuffer.append(gDLL->getText("TXT_KEY_CURE_AFFLICTION_TEXT", GC.getPromotionLineInfo(eAfflictionLine).getDescription()));
			}

			bFirst = true;
			for (int iI = 0; iI < kUnit.getNumAfflictionFortitudeModifiers(); iI++)
			{
				PromotionLineTypes eAfflictionLine = ((PromotionLineTypes)kUnit.getAfflictionFortitudeModifier(iI).ePromotionLine);
				if (kUnit.getAfflictionFortitudeModifier(iI).iModifier > 0)
				{
					if (!bFirst)
					{
						szBuffer.append(gDLL->getText("TXT_KEY_COMMA"));
					}
					if (bFirst)
					{
						szBuffer.append(NEWLINE);
						bFirst = false;
					}
					szBuffer.append(gDLL->getText("TXT_KEY_UNIT_AFFLICTION_FORTITUDE_MODIFIER_POSITIVE_TEXT", kUnit.getAfflictionFortitudeModifier(iI).iModifier, GC.getPromotionLineInfo(eAfflictionLine).getDescription()));
				}

				if (kUnit.getAfflictionFortitudeModifier(iI).iModifier < 0)
				{
					if (!bFirst)
					{
						szBuffer.append(gDLL->getText("TXT_KEY_COMMA"));
					}
					if (bFirst)
					{
						szBuffer.append(NEWLINE);
						bFirst = false;
					}
					szBuffer.append(gDLL->getText("TXT_KEY_UNIT_AFFLICTION_FORTITUDE_MODIFIER_NEGATIVE_TEXT", kUnit.getAfflictionFortitudeModifier(iI).iModifier, GC.getPromotionLineInfo(eAfflictionLine).getDescription()));
				}
			}

			//Resistances
			//Fortitude
			if (kUnit.getFortitude() != 0)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_UNIT_FORTITUDE", kUnit.getFortitude()));
			}
		}
		//Endurance
		if (kUnit.getEndurance() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNIT_ENDURANCE", kUnit.getEndurance()));
		}
		//Immunity to Cold
		if (kUnit.isColdImmune())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNIT_COLD_IMMUNE"));
		}
		//Collateral Resistance
		bFirst = true;
		for (int iI = 0; iI < GC.getNumUnitCombatInfos(); ++iI)
		{
			if (kUnit.getUnitCombatCollateralImmune(iI))
			{
				if (!bFirst)
				{
					szBuffer.append(gDLL->getText("TXT_KEY_COMMA"));
				}
				if (bFirst)
				{
					szBuffer.append(NEWLINE);
					bFirst = false;
				}
				szBuffer.append(gDLL->getText("TXT_KEY_UNIT_COLLATERAL_IMMUNE", CvWString(GC.getUnitCombatInfo((UnitCombatTypes)iI).getType()).GetCString(), GC.getUnitCombatInfo((UnitCombatTypes)iI).getTextKeyWide()));
			}
		}

		//Capture interactions
		if (kUnit.isNoCapture())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNIT_CANNOT_CAPTURE"));
		}

		if (kUnit.getCaptureProbabilityModifier() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNIT_CAPTURE_PROBABILITY_MODIFIER", kUnit.getCaptureProbabilityModifier()));
		}

		if (kUnit.getCaptureResistanceModifier() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNIT_CAPTURE_RESISTANCE_MODIFIER", kUnit.getCaptureResistanceModifier()));
		}

		//Taunt
		if (kUnit.getTaunt() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNIT_TAUNT", kUnit.getTaunt()));
		}


		if (kUnit.getCultureGarrisonValue() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_TEMP_REVOLT_PROTECTION", kUnit.getCultureGarrisonValue()));
		}
		//Targeting and Defending vs types
		szTempBuffer.clear();
		bFirst = true;
		for (int iI = 0; iI < kUnit.getNumTargetUnits(); ++iI)
		{
			const UnitTypes eUnitX = (UnitTypes) kUnit.getTargetUnit(iI);

			if (bFirst)
			{
				bFirst = false;
			}
			else
			{
				szTempBuffer += L", ";
			}
			szTempBuffer += CvWString::format(L"<link=%s>%s</link>", CvWString(GC.getUnitInfo(eUnitX).getType()).GetCString(), GC.getUnitInfo(eUnitX).getDescription());
		}

		if (!bFirst)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNIT_TARGETS_UNIT_FIRST", szTempBuffer.GetCString()));
		}

		szTempBuffer.clear();
		bFirst = true;
		for (int iI = 0; iI < kUnit.getNumDefendAgainstUnits(); ++iI)
		{
			const UnitTypes eUnitX = (UnitTypes)kUnit.getDefendAgainstUnit(iI);

			if (bFirst)
			{
				bFirst = false;
			}
			else
			{
				szTempBuffer += L", ";
			}
			szTempBuffer += CvWString::format(L"<link=%s>%s</link>", CvWString(GC.getUnitInfo(eUnitX).getType()).GetCString(), GC.getUnitInfo(eUnitX).getDescription());
		}

		if (!bFirst)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNIT_DEFENDS_UNIT_FIRST", szTempBuffer.GetCString()));
		}

		szTempBuffer.clear();
		bFirst = true;
		for (int iI = 0; iI < GC.getNumUnitCombatInfos(); ++iI)
		{
			if (kUnit.getTargetUnitCombat(iI))
			{
				if (bFirst)
				{
					bFirst = false;
				}
				else
				{
					szTempBuffer += L", ";
				}
				szTempBuffer += CvWString::format(L"<link=%s>%s</link>", CvWString(GC.getUnitCombatInfo((UnitCombatTypes)iI).getType()).GetCString(), GC.getUnitCombatInfo((UnitCombatTypes)iI).getDescription());
			}
		}

		if (!bFirst)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNIT_TARGETS_UNIT_FIRST", szTempBuffer.GetCString()));
		}

		szTempBuffer.clear();
		bFirst = true;
		for (int iI = 0; iI < GC.getNumUnitCombatInfos(); ++iI)
		{
			if (kUnit.getDefenderUnitCombat(iI))
			{
				if (bFirst)
				{
					bFirst = false;
				}
				else
				{
					szTempBuffer += L", ";
				}
				szTempBuffer += CvWString::format(L"<link=%s>%s</link>", CvWString(GC.getUnitCombatInfo((UnitCombatTypes)iI).getType()).GetCString(), GC.getUnitCombatInfo((UnitCombatTypes)iI).getDescription());
			}
		}

		if (!bFirst)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNIT_DEFENDS_UNIT_FIRST", szTempBuffer.GetCString()));
		}

		//Worker details
		iCount = 0;

		for (int iI = 0; iI < GC.getNumBuildInfos(); ++iI)
		{
			if (kUnit.getBuilds(iI))
			{
				iCount++;
			}
		}
		if (iCount > ((GC.getNumBuildInfos() * 3) / 4))
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNIT_IMPROVE_PLOTS"));
		}
		else
		{
			bFirst = true;
			for (int iI = 0; iI < GC.getNumBuildInfos(); ++iI)
			{
				if (kUnit.getBuilds(iI))
				{
					szTempBuffer.Format(L"%s%s ", NEWLINE, gDLL->getText("TXT_KEY_UNIT_CAN").c_str());
					setListHelp(szBuffer, szTempBuffer, GC.getBuildInfo((BuildTypes) iI).getDescription(), L", ", bFirst);
					bFirst = false;
				}
			}
		}

		for (int iI = 0; iI < GC.getNumTerrainInfos(); iI++)
		{
			if (kUnit.getTerrainWorkRateModifierType(iI) != 0)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_WORK_TEXT", kUnit.getTerrainWorkRateModifierType(iI), GC.getTerrainInfo((TerrainTypes)iI).getTextKeyWide()));
			}
		}
		for (int iI = 0; iI < GC.getNumFeatureInfos(); iI++)
		{
			if (kUnit.getFeatureWorkRateModifierType(iI) != 0)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_WORK_TEXT", kUnit.getFeatureWorkRateModifierType(iI), GC.getFeatureInfo((FeatureTypes)iI).getTextKeyWide()));
			}
		}
		for (int iI = 0; iI < GC.getNumBuildInfos(); iI++)
		{
			if (kUnit.getBuildWorkRateModifierType(iI) != 0)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_WORK_TEXT", kUnit.getBuildWorkRateModifierType(iI), GC.getBuildInfo((BuildTypes)iI).getTextKeyWide()));
			}
		}

		if (kUnit.getHillsWorkModifier() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_HILLS_WORK_TEXT", kUnit.getHillsWorkModifier()));
		}

		if (kUnit.getPeaksWorkModifier() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_PEAKS_WORK_TEXT", kUnit.getPeaksWorkModifier()));
		}

		//Strength in Numbers offered support
		if (game.isOption(GAMEOPTION_STRENGTH_IN_NUMBERS))
		{
			if (kUnit.getFrontSupportPercent() > 0)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_UNIT_FRONT_SUPPORT_PERCENT_TEXT", kUnit.getFrontSupportPercent()));
			}
			if (kUnit.getShortRangeSupportPercent() > 0)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_UNIT_SHORT_RANGE_SUPPORT_PERCENT_TEXT", kUnit.getShortRangeSupportPercent()));
			}
			if (kUnit.getMediumRangeSupportPercent() > 0)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_UNIT_MEDIUM_RANGE_SUPPORT_PERCENT_TEXT", kUnit.getMediumRangeSupportPercent()));
			}
			if (kUnit.getLongRangeSupportPercent() > 0)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_UNIT_LONG_RANGE_SUPPORT_PERCENT_TEXT", kUnit.getLongRangeSupportPercent()));
			}
			if (kUnit.getFlankSupportPercent() > 0)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_UNIT_FLANK_SUPPORT_PERCENT_TEXT", kUnit.getFlankSupportPercent()));
			}
		}

		//Property Manipulators
		kUnit.getPropertyManipulators()->buildDisplayString(szBuffer);

		//Golden Age
		if (kUnit.isGoldenAge())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNIT_GOLDEN_AGE"));
		}

		//Discover
		if ((kUnit.getBaseDiscover() > 0) || (kUnit.getDiscoverMultiplier() > 0))
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNIT_DISCOVER_TECH"));
		}

		//Hurry Production
		if ((kUnit.getBaseHurry() > 0) || (kUnit.getHurryMultiplier() > 0))
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNIT_HURRY_PRODUCTION"));
		}

		//Hurry Food
		int iFood = kUnit.getBaseFoodChange();
		if (iFood > 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNIT_HURRY_FOOD", iFood));
		}

		//Trade Mission
		int iBase = kUnit.getBaseTrade();
		int iMult = kUnit.getTradeMultiplier();
		if ((iBase > 0) || (iMult > 0))
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNIT_TRADE_MISSION", iBase, iMult));
		}

		//Cultural Great Work
		if (kUnit.getGreatWorkCulture() > 0)
		{
			int iCulture = kUnit.getGreatWorkCulture();
			if (NO_GAMESPEED != game.getGameSpeedType())
			{
				iCulture *= GC.getGameSpeedInfo(game.getGameSpeedType()).getUnitGreatWorkPercent();
				iCulture /= 100;
			}

			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNIT_GREAT_WORK", iCulture));
		}

		//Espionage
		if (kUnit.getEspionagePoints() > 0)
		{
			int iEspionage = GC.getUnitInfo(eUnit).getEspionagePoints();
			if (NO_GAMESPEED != game.getGameSpeedType())
			{
				iEspionage *= GC.getGameSpeedInfo(game.getGameSpeedType()).getUnitGreatWorkPercent();
				iEspionage /= 100;
			}

			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNIT_ESPIONAGE_MISSION", iEspionage));
		}

		//Inquisitor
		if (kUnit.isInquisitor())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNIT_IS_INQUISITOR"));
		}

		//Religion Spreads
		bFirst = true;
		for (int iI = 0; iI < GC.getNumReligionInfos(); ++iI)
		{
			if (kUnit.getReligionSpreads(iI) > 0)
			{
				szTempBuffer.Format(L"%s%s", NEWLINE, gDLL->getText("TXT_KEY_UNIT_CAN_SPREAD").c_str());
				CvWString szReligion;
				szReligion.Format(L"<link=%s>%s</link>", CvWString(GC.getReligionInfo((ReligionTypes)iI).getType()).GetCString(), GC.getReligionInfo((ReligionTypes) iI).getDescription());
				setListHelp(szBuffer, szTempBuffer, szReligion, L", ", bFirst);
				bFirst = false;
			}
		}

		//Corporation Spreads
		bFirst = true;
		for (int iI = 0; iI < GC.getNumCorporationInfos(); ++iI)
		{
			if (kUnit.getCorporationSpreads(iI) > 0)
			{
				szTempBuffer.Format(L"%s%s", NEWLINE, gDLL->getText("TXT_KEY_UNIT_CAN_EXPAND").c_str());
				CvWString szCorporation;
				szCorporation.Format(L"<link=%s>%s</link>", CvWString(GC.getCorporationInfo((CorporationTypes) iI).getType()).GetCString(), GC.getCorporationInfo((CorporationTypes) iI).getDescription());
				setListHelp(szBuffer, szTempBuffer, szCorporation, L", ", bFirst);
				bFirst = false;
			}
		}

		//Can Join
		bFirst = true;
		for (int iI = 0; iI < GC.getNumSpecialistInfos(); ++iI)
		{
			if (kUnit.getGreatPeoples(iI))
			{
				szTempBuffer.Format(L"%s%s", NEWLINE, gDLL->getText("TXT_KEY_UNIT_CAN_JOIN").c_str());
				CvWString szSpecialistLink = CvWString::format(L"<link=%s>%s</link>", CvWString(GC.getSpecialistInfo((SpecialistTypes)iI).getType()).GetCString(), GC.getSpecialistInfo((SpecialistTypes) iI).getDescription());
				setListHelp(szBuffer, szTempBuffer, szSpecialistLink.GetCString(), L", ", bFirst);
				bFirst = false;
			}
		}

		//Force Buildings
		bFirst = true;
		for (int iI = 0; iI < kUnit.getNumBuildings(); iI++)
		{
			const BuildingTypes eLoopBuilding = (BuildingTypes)kUnit.getBuildings(iI);

			if (NO_BUILDING != eLoopBuilding)
			{
				szTempBuffer.Format(L"%s%s", NEWLINE, gDLL->getText("TXT_KEY_UNIT_CAN_CONSTRUCT").c_str());
				CvWString szBuildingLink = CvWString::format(L"<link=%s>%s</link>", CvWString(GC.getBuildingInfo(eLoopBuilding).getType()).GetCString(), GC.getBuildingInfo(eLoopBuilding).getDescription());
				setListHelp(szBuffer, szTempBuffer, szBuildingLink.GetCString(), L", ", bFirst);
				bFirst = false;
			}
		}

		//No bad goodies
		if (kUnit.isNoBadGoodies())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNIT_NO_BAD_GOODIES"));
		}

		//Tradeable Unit
		if (game.isOption(GAMEOPTION_ADVANCED_DIPLOMACY) || bCivilopediaText)
		{
			if (kUnit.isMilitaryTrade() || kUnit.isWorkerTrade())
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_TRADABLE_UNIT"));
			}
		}

		//Found City
		if (kUnit.isFound())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNIT_FOUND_CITY"));
		}
	}
	//bTBUnitView3 = (Combat Classes)
	//bNormalView = default to show but replaced by any of the above
	if (bNormalView)
	{
		//Max HP
		if (kUnit.getTotalModifiedCombatStrength100() > 0 && kUnit.getMaxHP() != 100)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNIT_MAX_HP", kUnit.getMaxHP()));
		}

		if (kUnit.isMilitarySupport())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_BRANCH_MILITARY"));
		}
		else
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_BRANCH_CIVILIAN"));
		}

		if (kUnit.getBaseUpkeep() > 0)
		{
			UnitCombatTypes eUnitCombat;
			int iExtra = 0;
			int iMod = 0;
			for (int iI = -1; iI < kUnit.getNumSubCombatTypes(); iI++)
			{
				if (iI > -1)
				{
					eUnitCombat = (UnitCombatTypes)kUnit.getSubCombatType(iI);
				}
				else
				{
					eUnitCombat = (UnitCombatTypes)kUnit.getUnitCombatType();

					if (eUnitCombat == NO_UNITCOMBAT) continue;
				}
				if (game.isValidByGameOption(GC.getUnitCombatInfo(eUnitCombat)))
				{
					iExtra += GC.getUnitCombatInfo(eUnitCombat).getExtraUpkeep100();
					iMod += GC.getUnitCombatInfo(eUnitCombat).getUpkeepModifier();
				}
			}
			int iUpkeep = 100 * kUnit.getBaseUpkeep() + iExtra;
			if (iMod > 0)
			{
				iUpkeep = iUpkeep * (100 + iMod) / 100;
			}
			else if (iMod < 0)
			{
				iUpkeep = iUpkeep * 100 / (100 - iMod);
			}
			if (iUpkeep > 0)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_UPKEEP", CvWString::format(L"%.2f", iUpkeep / 100.0).GetCString()));

				if (pCity != NULL)
				{
					iUpkeep = GET_PLAYER(pCity->getOwner()).getFinalUnitUpkeepChange(iUpkeep, kUnit.isMilitarySupport());
					if (iUpkeep > 0)
					{
						szBuffer.append(NEWLINE);
						szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_UPKEEP_CHANGE", iUpkeep));
					}
				}
			}
		}

		//Spy
		if (kUnit.isCounterSpy())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNIT_EXPOSE_SPIES"));
		}

		//Nuclear
		if (kUnit.getNukeRange() != -1)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNIT_CAN_NUKE"));
		}

		//Is Always Hostile
		if (kUnit.isAlwaysHostile())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNIT_ALWAYS_HOSTILE"));
		}

		//Can Explore Rival Territory
		if (kUnit.isRivalTerritory())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNIT_EXPLORE_RIVAL"));
		}


		if (kUnit.isUpgradeAnywhere())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UPGRADE_ANYWHERE_TEXT"));
		}

		//Hidden Nationality
		if (kUnit.isHiddenNationality())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNIT_HIDDEN_NATIONALITY"));
		}

		if (kUnit.isExcile())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_EXCILE_TEXT"));
		}

		if (kUnit.isPassage())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_PASSAGE_TEXT"));
		}

		if (kUnit.isNoNonOwnedCityEntry())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_NO_NON_OWNED_CITY_TEXT"));
		}

		if (kUnit.isBarbCoExist())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BARB_COEXIST_TEXT"));
		}

		if (kUnit.isBlendIntoCity())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BLEND_INTO_CITY_TEXT"));
		}

		if (kUnit.isAssassin())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_ASSASSIN_TEXT"));
		}

		//Invisibility/Visibility
		if (kUnit.isInvisible())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNIT_INVISIBLE_ALL"));
		}

		if (!game.isOption(GAMEOPTION_HIDE_AND_SEEK))
		{
			if (kUnit.getInvisibleType() != NO_INVISIBLE)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_UNIT_INVISIBLE_MOST"));
			}

			for (int iI = 0; iI < kUnit.getNumSeeInvisibleTypes(); ++iI)
			{
				if (bCivilopediaText || (kUnit.getSeeInvisibleType(iI) != kUnit.getInvisibleType()))
				{
					szBuffer.append(NEWLINE);
					szBuffer.append(gDLL->getText("TXT_KEY_UNIT_SEE_INVISIBLE", GC.getInvisibleInfo((InvisibleTypes) kUnit.getSeeInvisibleType(iI)).getChar()));
				}
			}
		}
		else
		{
			bFirst = true;
			for (int iI = 0; iI < GC.getNumInvisibleInfos(); ++iI)
			{
				if (kUnit.getVisibilityIntensityType(iI) != 0)
				{
					if (!bFirst)
					{
						szBuffer.append(gDLL->getText("TXT_KEY_COMMA"));
					}
					if (bFirst)
					{
						szBuffer.append(NEWLINE);
						bFirst = false;
					}
					szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_INVISIBILITY_SPOT_VALUE", kUnit.getVisibilityIntensityType(iI), GC.getInvisibleInfo((InvisibleTypes) iI).getChar()));
				}
			}
			bFirst = true;
			for (int iI = 0; iI < GC.getNumInvisibleInfos(); ++iI)
			{
				if (kUnit.getVisibilityIntensityRangeType(iI) != 0)
				{
					if (!bFirst)
					{
						szBuffer.append(gDLL->getText("TXT_KEY_COMMA"));
					}
					if (bFirst)
					{
						szBuffer.append(NEWLINE);
						bFirst = false;
					}
					szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_INVISIBILITY_SPOT_RANGE_VALUE", GC.getInvisibleInfo((InvisibleTypes) iI).getTextKeyWide(), kUnit.getVisibilityIntensityRangeType(iI)));
				}
			}
			bFirst = true;
			for (int iI = 0; iI < GC.getNumInvisibleInfos(); ++iI)
			{
				if (kUnit.getInvisibilityIntensityType(iI) != 0 && !kUnit.isNoInvisibility())
				{
					if (!bFirst)
					{
						szBuffer.append(gDLL->getText("TXT_KEY_COMMA"));
					}
					if (bFirst)
					{
						szBuffer.append(NEWLINE);
						bFirst = false;
					}
					szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_INVISIBILITY_VEIL_VALUE", kUnit.getInvisibilityIntensityType(iI), GC.getInvisibleInfo((InvisibleTypes) iI).getChar()));
				}
			}
			bFirst = true;
			for (int iI = 0; iI < kUnit.getNumInvisibleTerrainChanges(); ++iI)
			{
				if (kUnit.getInvisibleTerrainChange(iI).iIntensity != 0 && !kUnit.isNoInvisibility())
				{
					if (!bFirst)
					{
						szBuffer.append(gDLL->getText("TXT_KEY_COMMA"));
					}
					if (bFirst)
					{
						szBuffer.append(NEWLINE);
						bFirst = false;
					}
					szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_INVISIBILITY_VEIL_PLOT_VALUE", kUnit.getInvisibleTerrainChange(iI).iIntensity, GC.getInvisibleInfo((InvisibleTypes)kUnit.getInvisibleTerrainChange(iI).eInvisible).getChar(), GC.getTerrainInfo((TerrainTypes)kUnit.getInvisibleTerrainChange(iI).eTerrain).getTextKeyWide()));
				}
			}
			bFirst = true;
			for (int iI = 0; iI < kUnit.getNumInvisibleFeatureChanges(); ++iI)
			{
				if (kUnit.getInvisibleFeatureChange(iI).iIntensity != 0 && !kUnit.isNoInvisibility())
				{
					if (!bFirst)
					{
						szBuffer.append(gDLL->getText("TXT_KEY_COMMA"));
					}
					if (bFirst)
					{
						szBuffer.append(NEWLINE);
						bFirst = false;
					}
					szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_INVISIBILITY_VEIL_PLOT_VALUE", kUnit.getInvisibleFeatureChange(iI).iIntensity, GC.getInvisibleInfo((InvisibleTypes)kUnit.getInvisibleFeatureChange(iI).eInvisible).getChar(), GC.getFeatureInfo((FeatureTypes)kUnit.getInvisibleFeatureChange(iI).eFeature).getTextKeyWide()));
				}
			}
			bFirst = true;
			for (int iI = 0; iI < kUnit.getNumInvisibleImprovementChanges(); ++iI)
			{
				if (kUnit.getInvisibleImprovementChange(iI).iIntensity != 0 && !kUnit.isNoInvisibility())
				{
					if (!bFirst)
					{
						szBuffer.append(gDLL->getText("TXT_KEY_COMMA"));
					}
					if (bFirst)
					{
						szBuffer.append(NEWLINE);
						bFirst = false;
					}
					szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_INVISIBILITY_VEIL_PLOT_VALUE", kUnit.getInvisibleImprovementChange(iI).iIntensity, GC.getInvisibleInfo((InvisibleTypes)kUnit.getInvisibleImprovementChange(iI).eInvisible).getChar(), GC.getImprovementInfo((ImprovementTypes)kUnit.getInvisibleImprovementChange(iI).eImprovement).getTextKeyWide()));
				}
			}
			bFirst = true;
			for (int iI = 0; iI < kUnit.getNumVisibleTerrainChanges(); ++iI)
			{
				if (kUnit.getVisibleTerrainChange(iI).iIntensity != 0)
				{
					if (!bFirst)
					{
						szBuffer.append(gDLL->getText("TXT_KEY_COMMA"));
					}
					if (bFirst)
					{
						szBuffer.append(NEWLINE);
						bFirst = false;
					}
					szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_INVISIBILITY_SPOT_PLOT_VALUE", GC.getInvisibleInfo((InvisibleTypes)kUnit.getVisibleTerrainChange(iI).eInvisible).getTextKeyWide(), kUnit.getVisibleTerrainChange(iI).iIntensity, GC.getTerrainInfo((TerrainTypes)kUnit.getVisibleTerrainChange(iI).eTerrain).getTextKeyWide()));
				}
			}
			bFirst = true;
			for (int iI = 0; iI < kUnit.getNumVisibleFeatureChanges(); ++iI)
			{
				if (kUnit.getVisibleFeatureChange(iI).iIntensity != 0)
				{
					if (!bFirst)
					{
						szBuffer.append(gDLL->getText("TXT_KEY_COMMA"));
					}
					if (bFirst)
					{
						szBuffer.append(NEWLINE);
						bFirst = false;
					}
					szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_INVISIBILITY_SPOT_PLOT_VALUE", kUnit.getVisibleFeatureChange(iI).iIntensity, GC.getInvisibleInfo((InvisibleTypes)kUnit.getVisibleFeatureChange(iI).eInvisible).getChar(), GC.getFeatureInfo((FeatureTypes)kUnit.getVisibleFeatureChange(iI).eFeature).getTextKeyWide()));
				}
			}
			bFirst = true;
			for (int iI = 0; iI < kUnit.getNumVisibleImprovementChanges(); ++iI)
			{
				if (kUnit.getVisibleImprovementChange(iI).iIntensity != 0)
				{
					if (!bFirst)
					{
						szBuffer.append(gDLL->getText("TXT_KEY_COMMA"));
					}
					if (bFirst)
					{
						szBuffer.append(NEWLINE);
						bFirst = false;
					}
					szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_INVISIBILITY_SPOT_PLOT_VALUE", kUnit.getVisibleImprovementChange(iI).iIntensity, GC.getInvisibleInfo((InvisibleTypes)kUnit.getVisibleImprovementChange(iI).eInvisible).getChar(), GC.getImprovementInfo((ImprovementTypes)kUnit.getVisibleImprovementChange(iI).eImprovement).getTextKeyWide()));
				}
			}
			bFirst = true;
			for (int iI = 0; iI < kUnit.getNumVisibleTerrainRangeChanges(); ++iI)
			{
				if (kUnit.getVisibleTerrainRangeChange(iI).iIntensity != 0)
				{
					if (!bFirst)
					{
						szBuffer.append(gDLL->getText("TXT_KEY_COMMA"));
					}
					if (bFirst)
					{
						szBuffer.append(NEWLINE);
						bFirst = false;
					}
					szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_INVISIBILITY_SPOT_PLOT_RANGE_VALUE", GC.getInvisibleInfo((InvisibleTypes)kUnit.getVisibleTerrainRangeChange(iI).eInvisible).getTextKeyWide(), kUnit.getVisibleTerrainRangeChange(iI).iIntensity, GC.getTerrainInfo((TerrainTypes)kUnit.getVisibleTerrainRangeChange(iI).eTerrain).getTextKeyWide()));
				}
			}
			bFirst = true;
			for (int iI = 0; iI < kUnit.getNumVisibleFeatureRangeChanges(); ++iI)
			{
				if (kUnit.getVisibleFeatureRangeChange(iI).iIntensity != 0)
				{
					if (!bFirst)
					{
						szBuffer.append(gDLL->getText("TXT_KEY_COMMA"));
					}
					if (bFirst)
					{
						szBuffer.append(NEWLINE);
						bFirst = false;
					}
					szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_INVISIBILITY_SPOT_PLOT_RANGE_VALUE", kUnit.getVisibleFeatureRangeChange(iI).iIntensity, GC.getInvisibleInfo((InvisibleTypes)kUnit.getVisibleFeatureRangeChange(iI).eInvisible).getChar(), GC.getFeatureInfo((FeatureTypes)kUnit.getVisibleFeatureRangeChange(iI).eFeature).getTextKeyWide()));
				}
			}
			bFirst = true;
			for (int iI = 0; iI < kUnit.getNumVisibleImprovementRangeChanges(); ++iI)
			{
				if (kUnit.getVisibleImprovementRangeChange(iI).iIntensity != 0)
				{
					if (!bFirst)
					{
						szBuffer.append(gDLL->getText("TXT_KEY_COMMA"));
					}
					if (bFirst)
					{
						szBuffer.append(NEWLINE);
						bFirst = false;
					}
					szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_INVISIBILITY_SPOT_PLOT_RANGE_VALUE", kUnit.getVisibleImprovementRangeChange(iI).iIntensity, GC.getInvisibleInfo((InvisibleTypes)kUnit.getVisibleImprovementRangeChange(iI).eInvisible).getChar(), GC.getImprovementInfo((ImprovementTypes)kUnit.getVisibleImprovementRangeChange(iI).eImprovement).getTextKeyWide()));
				}
			}
		}

		//Movement
		if (kUnit.isFlatMovementCost())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNIT_FLAT_MOVEMENT"));
		}

		if (kUnit.isIgnoreTerrainCost())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNIT_IGNORE_TERRAIN"));
		}

		if (kUnit.isIgnoreZoneofControl())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNIT_IGNORE_ZONE_OF_CONTROL"));
		}

		if (kUnit.isFliesToMove())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNIT_FLIES_TO_MOVE"));
		}

		if (kUnit.getAnimalIgnoresBorders() != 0 && !game.isOption(GAMEOPTION_ANIMALS_STAY_OUT))
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNIT_ANIMAL_IGNORES_BORDERS", kUnit.getAnimalIgnoresBorders()));
		}

		//Cannot Enter Terrains
		szTempBuffer.Format(L"%s%s ", NEWLINE, gDLL->getText("TXT_KEY_UNIT_CANNOT_ENTER").GetCString());

		bFirst = true;
		for (int iI = 0; iI < kUnit.getNumTerrainImpassableTypes(); ++iI)
		{
			TerrainTypes eTerrain = (TerrainTypes)kUnit.getTerrainImpassableType(iI);
			CvWString szTerrain;
			TechTypes eTech = (TechTypes)kUnit.getTerrainPassableTech(kUnit.getTerrainImpassableType(iI));
			if (NO_TECH == eTech)
			{
				szTerrain.Format(L"<link=%s>%s</link>", CvWString(GC.getTerrainInfo(eTerrain).getType()).GetCString(), GC.getTerrainInfo(eTerrain).getDescription());
			}
			else
			{
				szTerrain = gDLL->getText("TXT_KEY_TERRAIN_UNTIL_TECH", CvWString(GC.getTerrainInfo(eTerrain).getType()).GetCString(), GC.getTerrainInfo(eTerrain).getTextKeyWide(), GC.getTechInfo(eTech).getTextKeyWide());
			}
			setListHelp(szBuffer, szTempBuffer, szTerrain, L", ", bFirst);
			bFirst = false;
		}

		//May only Traverse
		szTempBuffer.clear();
		szTempBuffer.Format(L"%s%s ", NEWLINE, gDLL->getText("TXT_KEY_UNIT_CAN_ONLY_TRAVERSE").GetCString());
		bFirst = true;
		for (int iI = 0; iI < GC.getNumRouteInfos(); ++iI)
		{
			if (kUnit.getPassableRouteNeeded(iI))
			{
				CvWString szRoute;
				szRoute.Format(L"<link=%s>%s</link>", CvWString(GC.getRouteInfo((RouteTypes)iI).getType()).GetCString(), GC.getRouteInfo((RouteTypes)iI).getDescription());
				setListHelp(szBuffer, szTempBuffer, szRoute, L", ", bFirst);
				bFirst = false;
			}
		}

		//Impassable Feature
		for (int iI = 0; iI < kUnit.getNumFeatureImpassableTypes(); ++iI)
		{
			FeatureTypes eFeature = (FeatureTypes)kUnit.getFeatureImpassableType(iI);
			CvWString szFeature;
			TechTypes eTech = (TechTypes)kUnit.getFeaturePassableTech(kUnit.getFeatureImpassableType(iI));
			if (NO_TECH == eTech)
			{
				szFeature.Format(L"<link=%s>%s</link>", CvWString(GC.getFeatureInfo(eFeature).getType()).GetCString(), GC.getFeatureInfo(eFeature).getDescription());
			}
			else
			{
				szFeature = gDLL->getText("TXT_KEY_TERRAIN_UNTIL_TECH", CvWString(GC.getFeatureInfo(eFeature).getType()).GetCString(), GC.getFeatureInfo(eFeature).getTextKeyWide(), GC.getTechInfo(eTech).getTextKeyWide());
			}
			setListHelp(szBuffer, szTempBuffer, szFeature, L", ", bFirst);
			bFirst = false;
		}

		if (kUnit.isCanMoveImpassable())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNIT_CAN_MOVE_IMPASSABLE"));
		}

		//Defensive Only
		if (kUnit.isOnlyDefensive())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNIT_ONLY_DEFENSIVE"));
		}

		if (kUnit.getLeaderExperience() > 0)
		{
			if (0 == GC.getDefineINT("WARLORD_EXTRA_EXPERIENCE_PER_UNIT_PERCENT"))
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_UNIT_LEADER", kUnit.getLeaderExperience()));
			}
			else
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_UNIT_LEADER_EXPERIENCE", kUnit.getLeaderExperience()));
			}
		}

		//Paradrop
		if (kUnit.getDropRange() > 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNIT_PARADROP_RANGE", kUnit.getDropRange()));
		}

		//Outcome Missions?
		//Leader
		if (NO_PROMOTION != kUnit.getLeaderPromotion())
		{
			szBuffer.append(CvWString::format(L"%s%c%s", NEWLINE, gDLL->getSymbolID(BULLET_CHAR), gDLL->getText("TXT_KEY_PROMOTION_WHEN_LEADING").GetCString()));
			parsePromotionHelp(szBuffer, (PromotionTypes)kUnit.getLeaderPromotion(), L"\n   ");
		}

		//Prereq
		if (kUnit.isRequiresStateReligionInCity())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_REQUIRES_STATE_RELIGION_IN_CITY"));
		}

		if (kUnit.isStateReligion())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNIT_REQUIRES_STATE_RELIGION"));
		}

		if (kUnit.getMaxStartEra() != NO_ERA)
		{
			szTempBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNIT_MAX_START_ERA", GC.getEraInfo((EraTypes)kUnit.getMaxStartEra()).getTextKeyWide()));
		}

		//Experience
		if (pCity != NULL && kUnit.canAcquireExperience()
		&& getBugOptionBOOL("MiscHover__UnitExperienceModifiers", true, "BUG_UNIT_EXPERIENCE_MODIFIERS_HOVER"))
		{
			CvPlayer& kPlayer = GET_PLAYER(pCity->getOwner());
			int iTotalXPBonus = 0;
			bool bFirst = true;

			if (kUnit.isSpy() && !GC.isSS_ENABLED())
			{
				iTotalXPBonus = 0;
			}
			else
			{
				int iExperience = pCity->getFreeExperience();
				if (iExperience != 0)
				{
					if (bFirst)
					{
						szBuffer.append(NEWLINE);
						szBuffer.append(gDLL->getText("TXT_KEY_UNIT_WILL_RECEIVE_FREE_EXPERIENCE"));
					}
					bFirst = false;
					szBuffer.append(NEWLINE);
					szBuffer.append(gDLL->getText("TXT_KEY_CITY_FREE_EXPERIENCE", iExperience));
					iTotalXPBonus += iExperience;
				}
				iExperience = kPlayer.getFreeExperience();
				if (iExperience != 0)
				{
					if (bFirst)
					{
						szBuffer.append(NEWLINE);
						szBuffer.append(gDLL->getText("TXT_KEY_UNIT_WILL_RECEIVE_FREE_EXPERIENCE"));
					}
					bFirst = false;
					szBuffer.append(NEWLINE);
					szBuffer.append(gDLL->getText("TXT_KEY_PLAYER_FREE_EXPERIENCE", iExperience));
					iTotalXPBonus += iExperience;
				}
				iExperience = pCity->getSpecialistFreeExperience();
				if (iExperience != 0)
				{
					if (bFirst)
					{
						szBuffer.append(NEWLINE);
						szBuffer.append(gDLL->getText("TXT_KEY_UNIT_WILL_RECEIVE_FREE_EXPERIENCE"));
					}
					bFirst = false;
					szBuffer.append(NEWLINE);
					szBuffer.append(gDLL->getText("TXT_KEY_SPECIALIST_FREE_EXPERIENCE", iExperience));
					iTotalXPBonus += iExperience;
				}

				UnitCombatTypes eCombat;
				for (int iI = -1; iI < kUnit.getNumSubCombatTypes(); iI++)
				{
					if (iI > -1)
					{
						eCombat = (UnitCombatTypes)kUnit.getSubCombatType(iI);
					}
					else
					{
						eCombat = (UnitCombatTypes)kUnit.getUnitCombatType();

						if (eCombat == NO_UNITCOMBAT) continue;
					}
					iExperience = pCity->getUnitCombatFreeExperience(eCombat);
					if (iExperience != 0)
					{
						if (bFirst)
						{
							szBuffer.append(NEWLINE);
							szBuffer.append(gDLL->getText("TXT_KEY_UNIT_WILL_RECEIVE_FREE_EXPERIENCE"));
						}
						bFirst = false;
						szBuffer.append(NEWLINE);
						szBuffer.append(gDLL->getText("TXT_KEY_UNITCOMBAT_FREE_EXPERIENCE", iExperience, GC.getUnitCombatInfo(eCombat).getTextKeyWide()));
						iTotalXPBonus += iExperience;
					}
				}

				DomainTypes eDomain = (DomainTypes)kUnit.getDomainType();
				iExperience = pCity->getDomainFreeExperience(eDomain);
				if (iExperience != 0)
				{
					if (bFirst)
					{
						szBuffer.append(NEWLINE);
						szBuffer.append(gDLL->getText("TXT_KEY_UNIT_WILL_RECEIVE_FREE_EXPERIENCE"));
					}
					bFirst = false;
					szBuffer.append(NEWLINE);
					szBuffer.append(gDLL->getText("TXT_KEY_DOMAIN_FREE_EXPERIENCE", iExperience, GC.getDomainInfo(eDomain).getTextKeyWide()));
					iTotalXPBonus += iExperience;
				}

				if (kPlayer.getStateReligion() != NO_RELIGION)
				{
					iExperience = kPlayer.getStateReligionFreeExperience();
					if (iExperience != 0)
					{
						if (pCity->isHasReligion(kPlayer.getStateReligion()))
						{
							if (bFirst)
							{
								szBuffer.append(NEWLINE);
								szBuffer.append(gDLL->getText("TXT_KEY_UNIT_WILL_RECEIVE_FREE_EXPERIENCE"));
							}
							bFirst = false;
							szBuffer.append(NEWLINE);
							szBuffer.append(gDLL->getText("TXT_KEY_STATE_RELIGION_FREE_EXPERIENCE", iExperience));
							iTotalXPBonus += iExperience;
						}
						else//Display what you could have IF you could get your state religion into the city
						{
							if (bFirst)
							{
								szBuffer.append(NEWLINE);
								szBuffer.append(gDLL->getText("TXT_KEY_UNIT_WILL_RECEIVE_FREE_EXPERIENCE"));
							}
							bFirst = false;
							szBuffer.append(NEWLINE);
							szBuffer.append(gDLL->getText("TXT_KEY_NO_STATE_RELIGION_FREE_EXPERIENCE", iExperience));
						}
					}
				}
				const UnitCombatTypes eCombatType = (UnitCombatTypes)kUnit.getUnitCombatType();
				const DomainTypes eDomainType = (DomainTypes)kUnit.getDomainType();
				//Display sources you could have if you constructed them first
				for (int iI = 0; iI < GC.getNumBuildingInfos(); iI++)
				{
					const CvBuildingInfo& kBuilding = GC.getBuildingInfo((BuildingTypes)iI);
					iExperience = kBuilding.getUnitCombatFreeExperience(eCombatType);
					for (int iJ = 0; iJ < kUnit.getNumSubCombatTypes(); iJ++)
					{
						iExperience += kBuilding.getUnitCombatFreeExperience((UnitCombatTypes)kUnit.getSubCombatType(iJ));
					}
					iExperience += kBuilding.getDomainFreeExperience(eDomainType);

					if (iExperience != 0)
					{
						if (pCity->getNumBuilding((BuildingTypes)iI) < 1 && pCity->canConstruct((BuildingTypes)iI, false, true))
						{
							if (bFirst)
							{
								szBuffer.append(NEWLINE);
								szBuffer.append(gDLL->getText("TXT_KEY_UNIT_WILL_RECEIVE_FREE_EXPERIENCE"));
							}
							bFirst = false;
							szBuffer.append(NEWLINE);
							szBuffer.append(gDLL->getText("TXT_KEY_NO_BUILDING_FREE_EXPERIENCE", iExperience, kBuilding.getTextKeyWide()));
						}
					}
				}
			}
			int iExperienceModifier = 0;
			int iMod = 0;
			if (pCity->isCapital() || pCity->isGovernmentCenter())
			{
				iMod = kPlayer.getCapitalXPModifier();
				if (iMod != 0)
				{
					szBuffer.append(NEWLINE);
					szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_XP_MOD_CAPITAL", iMod));
					iExperienceModifier += iMod;
				}
			}
			if (pCity->isHolyCity())
			{
				if (pCity->isHolyCity(kPlayer.getStateReligion()))
				{
					iMod = kPlayer.getStateReligionHolyCityXPModifier();
					if (iMod != 0)
					{
						szBuffer.append(NEWLINE);
						szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_XP_MOD_HOLY_CITY_STATE_RELIGION", iMod));
						iExperienceModifier += iMod;
					}
				}
				else
				{
					iMod = kPlayer.getNonStateReligionHolyCityXPModifier();
					if (iMod != 0)
					{
						szBuffer.append(NEWLINE);
						szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_XP_MOD_HOLY_CITY_NONSTATE_RELIGION", iMod));
						iExperienceModifier += iMod;
					}
				}
			}
			if (iExperienceModifier != 0)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_XP_MOD_TOTAL", iExperienceModifier));
				iTotalXPBonus *= (iExperienceModifier + 100);
				iTotalXPBonus /= 100;
			}
			if (iTotalXPBonus != 0)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_XP_TOTAL", iTotalXPBonus));
			}
		}

		//Free Promos
		bFirst = true;
		for (int iI = 0; iI < GC.getNumPromotionInfos(); ++iI)
		{
			if (kUnit.getFreePromotions(iI))
			{
				szTempBuffer.Format(L"%s%s", NEWLINE, gDLL->getText("TXT_KEY_BULLET_STARTS_WITH").c_str());
				setListHelp(szBuffer, szTempBuffer, CvWString::format(L"<link=%s>%s</link>", CvWString(GC.getPromotionInfo((PromotionTypes)iI).getType()).GetCString(), GC.getPromotionInfo((PromotionTypes) iI).getDescription()), L", ", bFirst);
				bFirst = false;
			}
		}

		//Healing
		if (kUnit.isNoSelfHeal())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_SELF_HEAL_NONE"));
		}
		else if (kUnit.getSelfHealModifier() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_SELF_HEAL", kUnit.getSelfHealModifier()));
		}
		if (kUnit.getNumHealSupport() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_HEAL_SUPPORT_TEXT", kUnit.getNumHealSupport()));
		}

		//Heal Unit Combat
		for (int iI = 0; iI < kUnit.getNumHealUnitCombatTypes(); ++iI)
		{
			UnitCombatTypes eUnitCombat = ((UnitCombatTypes)kUnit.getHealUnitCombatType(iI).eUnitCombat);
			int iHeal = kUnit.getHealUnitCombatType(iI).iHeal;
			int iAdjHeal = kUnit.getHealUnitCombatType(iI).iAdjacentHeal;
			if (iHeal > 0)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_HEALS_UNITCOMBAT_SAME_TEXT", GC.getUnitCombatInfo(eUnitCombat).getTextKeyWide(), iHeal) + gDLL->getText("TXT_KEY_PROMOTION_DAMAGE_TURN_TEXT"));
			}
			if (iAdjHeal > 0)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_HEALS_UNITCOMBAT_ADJACENT_TEXT", GC.getUnitCombatInfo(eUnitCombat).getTextKeyWide(), iAdjHeal) + gDLL->getText("TXT_KEY_PROMOTION_DAMAGE_TURN_TEXT"));
			}
		}

		//Modified Production
			//From Trait
		for (int i = 0; i < GC.getNumTraitInfos(); ++i)
		{
			TraitTypes eTrait = ((TraitTypes)i);
			for (int j = 0; j < GC.getTraitInfo(eTrait).getNumUnitProductionModifiers(); j++)
			{
				if ((UnitTypes)GC.getTraitInfo(eTrait).getUnitProductionModifier(j).eUnit == eUnit)
				{
					if (GC.getTraitInfo(eTrait).getUnitProductionModifier(j).iModifier != 0)
					{
						if (GC.getTraitInfo(eTrait).getUnitProductionModifier(j).iModifier == 100)
						{
							szBuffer.append(NEWLINE);
							szBuffer.append(gDLL->getText("TXT_KEY_DOUBLE_SPEED_TRAIT", GC.getTraitInfo(eTrait).getTextKeyWide()));
						}
						else
						{
							szBuffer.append(NEWLINE);
							szBuffer.append(gDLL->getText("TXT_KEY_PRODUCTION_MODIFIER_TRAIT", GC.getTraitInfo(eTrait).getUnitProductionModifier(j).iModifier, GC.getTraitInfo(eTrait).getTextKeyWide()));
						}
					}
				}
			}
		}

		if (kUnit.isNoNonTypeProdMods())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_NO_NON_TYPE_PROD_MODS_TEXT"));
		}

		if (kUnit.getInsidiousness() != 0)
		{
			szBuffer.append(NEWLINE);
			float fValue = (float)kUnit.getInsidiousness();
			{
				szTempBuffer.Format(L"%.1f", fValue/10);
			}
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_INSIDIOUSNESS_TEXT", szTempBuffer.GetCString()));
		}

		if (kUnit.getInvestigation() != 0)
		{
			szBuffer.append(NEWLINE);
			float fValue = (float)kUnit.getInvestigation();
			{
				szTempBuffer.Format(L"%.1f", fValue/10);
			}
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_INVESTIGATION_TEXT", szTempBuffer.GetCString()));
		}

		bool bWithoutWarning = game.isOption(GAMEOPTION_WITHOUT_WARNING);
		if (kUnit.getStealthStrikes() != 0 && bWithoutWarning)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_STEALTH_STRIKES_TEXT", kUnit.getStealthStrikes()));
		}

		if (kUnit.getStealthCombatModifier() != 0 && bWithoutWarning)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_STEALTH_COMBAT_MODIFIER_TEXT", kUnit.getStealthCombatModifier()));
		}

		if (kUnit.isStealthDefense() && bWithoutWarning)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_STEALTH_DEFEND"));
		}

		if (kUnit.isNoInvisibility() && game.isOption(GAMEOPTION_HIDE_AND_SEEK))
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_NO_INVISIBILIY_TEXT"));
		}

		//Misc
		if (!CvWString(kUnit.getHelp()).empty())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(kUnit.getHelp());
		}

		if (!CvWString(kUnit.getExtraHoverText()).empty())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(kUnit.getExtraHoverText());
		}
		for (int iI = 0; iI < kUnit.getNumMapCategoryTypes(); iI++)
		{
			MapCategoryTypes eMapCategory = (MapCategoryTypes)kUnit.getMapCategoryType(iI);
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_MAP_CATEGORY_PREREQUISITE", GC.getMapCategoryInfo(eMapCategory).getTextKeyWide()));
		}
	}

	if (!bCivilopediaText && bTBUnitView3 && game.getActivePlayer() != NO_PLAYER)
	{
		const uint16_t iDisplayCount = inspectUnitCombatCounters->getCount(eUnit);
		uint16_t iPotentialDisplays = 0;
		if (kUnit.getUnitCombatType() != NO_UNITCOMBAT)
		{
			if (game.isValidByGameOption(GC.getUnitCombatInfo((UnitCombatTypes)kUnit.getUnitCombatType())))
			{
				iPotentialDisplays++;
			}
			for (int iI = 0; iI < kUnit.getNumSubCombatTypes(); iI++)
			{
				if (game.isValidByGameOption(GC.getUnitCombatInfo((UnitCombatTypes)kUnit.getSubCombatType(iI)))
				&& ++iPotentialDisplays > iDisplayCount)
				{
					break;
				}
			}
		}
		UnitCombatTypes eUnitCombat;
		int iCount = 0;
		for (int iI = -1; iI < kUnit.getNumSubCombatTypes(); iI++)
		{
			if (iI > -1)
			{
				eUnitCombat = (UnitCombatTypes)kUnit.getSubCombatType(iI);
			}
			else
			{
				eUnitCombat = (UnitCombatTypes)kUnit.getUnitCombatType();

				if (eUnitCombat == NO_UNITCOMBAT) continue;
			}
			if (game.isValidByGameOption(GC.getUnitCombatInfo(eUnitCombat)))
			{
				if (++iCount == iDisplayCount)
				{
					szBuffer.append(DOUBLE_SEPARATOR);
					setUnitCombatHelp(szBuffer, eUnitCombat, false, true);
					szBuffer.append(DOUBLE_SEPARATOR);
				}
				else
				{
					szBuffer.append(NEWLINE);
					szBuffer.append(GC.getUnitCombatInfo(eUnitCombat).getDescription());
				}
			}
		}
		if (iDisplayCount == iPotentialDisplays)
		{
			inspectUnitCombatCounters->setCount(eUnit, 0);
		}
		else if (iDisplayCount > iPotentialDisplays)
		{
			inspectUnitCombatCounters->setCount(eUnit, 1);
		}
		else
		{
			inspectUnitCombatCounters->setCount(eUnit, iDisplayCount + 1);
		}
	}
	else if (bTBUnitView3 || bCivilopediaText)
	{
		bool bisValid = true;
		if (kUnit.getUnitCombatType() != NO_UNITCOMBAT)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(DOUBLE_SEPARATOR);
			setUnitCombatHelp(szBuffer, (UnitCombatTypes)kUnit.getUnitCombatType(), bCivilopediaText, true);
			szBuffer.append(DOUBLE_SEPARATOR);

			for (int iI = 0; iI < kUnit.getNumSubCombatTypes(); iI++)
			{
				UnitCombatTypes eSubCombatType = (UnitCombatTypes)GC.getUnitInfo(eUnit).getSubCombatType(iI);

				if (game.isValidByGameOption(GC.getUnitCombatInfo(eSubCombatType)))
				{
					setUnitCombatHelp(szBuffer, eSubCombatType, bCivilopediaText, true);
					szBuffer.append(DOUBLE_SEPARATOR);
				}
			}
		}
	}
}

// BUG - Starting Experience - start
/*
 * Appends the starting experience and number of promotions the given unit will have
 * when trained or conscripted in the given city.
 */
void CvGameTextMgr::setUnitExperienceHelp(CvWStringBuffer &szBuffer, CvWString szStart, UnitTypes eUnit, CvCity* pCity, bool bConscript)
{
	if (GC.getUnitInfo(eUnit).canAcquireExperience())
	{
		const int iExperience = pCity->getProductionExperience(eUnit) / (bConscript ? 2 : 1);

		if (iExperience > 0)
		{
			szBuffer.append(szStart);
			if (bConscript)
			{
				szBuffer.append(gDLL->getText("TXT_KEY_MISC_EXPERIENCE_DRAFT", iExperience));
			}
			else szBuffer.append(gDLL->getText("TXT_KEY_MISC_EXPERIENCE", iExperience));

			const int iLevel = calculateLevel(iExperience, pCity->getOwner());
			if (iLevel > 1)
			{
				szBuffer.append(L", ");
				szBuffer.append(gDLL->getText("TXT_KEY_MISC_PROMOTIONS", iLevel - 1));
			}
		}
	}
}
// BUG - Starting Experience - end


void CvGameTextMgr::setUnitHelp(CvWStringBuffer &szBuffer, UnitTypes eUnit, bool bCivilopediaText, bool bStrategyText, bool bTechChooserText, CvCity* pCity)
{
	PROFILE_FUNC();

	CvWString szTempBuffer;
	PlayerTypes ePlayer;
	bool bFirst;
	int iI;

	//bTBUnitView1 = (Combat)
	//bTBUnitView2 = (Civil)
	//bTBUnitView3 = (Combat Classes)
	//bNormalView = default to show but replaced by any of the above
	bool bTBUnitView1 = gDLL->ctrlKey();
	bool bTBUnitView2 = gDLL->altKey();
	bool bTBUnitView3 = gDLL->shiftKey();
	bool bNormalView = (!bTBUnitView1 && !bTBUnitView2 && !bTBUnitView3);

	if (bCivilopediaText)
	{
		bTBUnitView1 = true;
		bTBUnitView2 = true;
		bTBUnitView3 = true;
		bNormalView = true;
	}

	if (NO_UNIT == eUnit)
	{
		return;
	}

	if (pCity != NULL)
	{
		ePlayer = pCity->getOwner();
	}
	else
	{
		ePlayer = GC.getGame().getActivePlayer();
	}

	bool bisValid = true;
	if (!bCivilopediaText)
	{
		szTempBuffer.Format(SETCOLR L"%s" ENDCOLR , TEXT_COLOR("COLOR_UNIT_TEXT"), GC.getUnitInfo(eUnit).getDescription());
		szBuffer.append(szTempBuffer);
	}

	// test for unique unit
	if (bNormalView)
	{
		if (isWorldUnit(eUnit))
		{
			if (pCity == NULL)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_UNIT_WORLD_UNIT_ALLOWED", GC.getUnitInfo(eUnit).getMaxGlobalInstances()));
			}
			else
			{
				szBuffer.append(gDLL->getText("TXT_KEY_UNIT_WORLD_UNIT_LEFT",
					(GC.getUnitInfo(eUnit).getMaxGlobalInstances() - (ePlayer != NO_PLAYER ? GC.getGame().getUnitCreatedCount(eUnit) + GET_TEAM(GET_PLAYER(ePlayer).getTeam()).getUnitMaking(eUnit) : 0))));
			}
		}

/* Toffer:
iMaxTeamInstances was unused in CvUnit(Class)Info and removed as part of us shedding the unit-class object, maybe we want to add it back in for CvUnitInfo?

		if (isTeamUnit(eUnit)
		&& (!GC.getGame().isOption(GAMEOPTION_UNLIMITED_NATIONAL_UNITS) || GC.getUnitInfo(eUnit).isUnlimitedException()))
		{
			if (pCity == NULL)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_UNIT_TEAM_UNIT_ALLOWED", GC.getUnitInfo(eUnit).getMaxTeamInstances()));
			}
			else
			{
				szBuffer.append(gDLL->getText("TXT_KEY_UNIT_TEAM_UNIT_LEFT",
					(GC.getUnitInfo(eUnit).getMaxTeamInstances() - (ePlayer != NO_PLAYER ? GET_TEAM(GET_PLAYER(ePlayer).getTeam()).getUnitCountPlusMaking(eUnit) : 0))));
			}
		}
*/

		if (isNationalUnit(eUnit)
		&& (!GC.getGame().isOption(GAMEOPTION_UNLIMITED_NATIONAL_UNITS) || GC.getUnitInfo(eUnit).isUnlimitedException()))
		{
			if (pCity == NULL)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_UNIT_NATIONAL_UNIT_ALLOWED", GC.getUnitInfo(eUnit).getMaxPlayerInstances()));
			}
			else
			{
				szBuffer.append(gDLL->getText("TXT_KEY_UNIT_NATIONAL_UNIT_LEFT",
					(GC.getUnitInfo(eUnit).getMaxPlayerInstances() - (ePlayer != NO_PLAYER ? GET_PLAYER(ePlayer).getUnitCountPlusMaking(eUnit) : 0))));
			}
		}

		if (0 != GC.getUnitInfo(eUnit).getInstanceCostModifier())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNIT_INSTANCE_COST_MOD", GC.getUnitInfo(eUnit).getInstanceCostModifier()));
		}


		BoolExpr* pExpr = GC.getUnitInfo(eUnit).getTrainCondition();
		if (pExpr)
		{
			bool bEval = false;
			if (pCity)
			{
				bEval = pExpr->evaluate(const_cast<CvGameObjectCity*>(pCity->getGameObject())); // Const wegcasten ist hier ok da evaluate nicht wirklich etwas ändert
			}
			if (!bEval)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_REQUIRES"));
				szBuffer.append(" ");
				pExpr->buildDisplayString(szBuffer);
				szBuffer.append(ENDCOLR);
			}
		}
	}
	// Starting Experience
	setBasicUnitHelpWithCity(szBuffer, eUnit, bCivilopediaText, pCity, false, bTBUnitView1, bTBUnitView2, bTBUnitView3);

	if (bNormalView)
	{
		if ((pCity == NULL) || !(pCity->canTrain(eUnit)))
		{
			if (pCity != NULL)
			{
				if (GC.getGame().isNoNukes())
				{
					if (GC.getUnitInfo(eUnit).getNukeRange() != -1)
					{
						szBuffer.append(NEWLINE);
						szBuffer.append(gDLL->getText("TXT_KEY_UNIT_NO_NUKES"));
					}
				}
			}

			if (GC.getUnitInfo(eUnit).getHolyCity() != NO_RELIGION)
			{
				if ((pCity == NULL) || !(pCity->isHolyCity((ReligionTypes)(GC.getUnitInfo(eUnit).getHolyCity()))))
				{
					szBuffer.append(NEWLINE);
					szBuffer.append(gDLL->getText("TXT_KEY_UNIT_REQUIRES_HOLY_CITY", GC.getReligionInfo((ReligionTypes)(GC.getUnitInfo(eUnit).getHolyCity())).getChar()));
				}
			}

			bFirst = true;

			if (GC.getUnitInfo(eUnit).getSpecialUnitType() != NO_SPECIALUNIT)
			{
				if ((pCity == NULL) || !(GC.getGame().isSpecialUnitValid((SpecialUnitTypes)(GC.getUnitInfo(eUnit).getSpecialUnitType()))))
				{
					for (iI = 0; iI < GC.getNumProjectInfos(); ++iI)
					{
						if (GC.getProjectInfo((ProjectTypes)iI).getEveryoneSpecialUnit() == GC.getUnitInfo(eUnit).getSpecialUnitType())
						{
							szTempBuffer.Format(L"%s%s", NEWLINE, gDLL->getText("TXT_KEY_REQUIRES").c_str());
							CvWString szProject;
							szProject.Format(L"<link=%s>%s</link>", CvWString(GC.getProjectInfo((ProjectTypes)iI).getType()).GetCString(), GC.getProjectInfo((ProjectTypes)iI).getDescription());
							setListHelp(szBuffer, szTempBuffer, szProject, gDLL->getText("TXT_KEY_OR").c_str(), bFirst);
							bFirst = false;
						}
					}
				}
			}

			if (!bFirst)
			{
				szBuffer.append(ENDCOLR);
			}

			bFirst = true;

			if (GC.getUnitInfo(eUnit).getNukeRange() != -1)
			{
				if (NULL == pCity || !GET_PLAYER(ePlayer).isNukesValid())
				{
					for (iI = 0; iI < GC.getNumProjectInfos(); ++iI)
					{
						if (GC.getProjectInfo((ProjectTypes)iI).isAllowsNukes())
						{
							szTempBuffer.Format(L"%s%s", NEWLINE, gDLL->getText("TXT_KEY_REQUIRES").c_str());
							CvWString szProject;
							szProject.Format(L"<link=%s>%s</link>", CvWString(GC.getProjectInfo((ProjectTypes)iI).getType()).GetCString(), GC.getProjectInfo((ProjectTypes)iI).getDescription());
							setListHelp(szBuffer, szTempBuffer, szProject, gDLL->getText("TXT_KEY_OR").c_str(), bFirst);
							bFirst = false;
						}
					}

					for (iI = 0; iI < GC.getNumBuildingInfos(); ++iI)
					{
						if (GC.getBuildingInfo((BuildingTypes)iI).isAllowsNukes())
						{
							szTempBuffer.Format(L"%s%s", NEWLINE, gDLL->getText("TXT_KEY_REQUIRES").c_str());
							CvWString szBuilding;
							szBuilding.Format(L"<link=%s>%s</link>", CvWString(GC.getBuildingInfo((BuildingTypes)iI).getType()).GetCString(), GC.getBuildingInfo((BuildingTypes)iI).getDescription());
							setListHelp(szBuffer, szTempBuffer, szBuilding, gDLL->getText("TXT_KEY_OR").c_str(), bFirst);
							bFirst = false;
						}
					}
				}
			}

			if (!bFirst)
			{
				szBuffer.append(ENDCOLR);
			}

			// Afforess	Vicinity Bonus 07/29/09
			if (GC.getUnitInfo(eUnit).getPrereqVicinityBonus() != NO_BONUS)
			{
				if ((pCity == NULL) || !(pCity->canTrain(eUnit)))
				{
					szBuffer.append(NEWLINE);
					szBuffer.append(gDLL->getText("TXT_KEY_REQUIRES_VICINITY_BONUS", GC.getBonusInfo((BonusTypes)(GC.getUnitInfo(eUnit).getPrereqVicinityBonus())).getTextKeyWide()));
				}
			}

			bFirst = true;

			for (iI = 0; iI < GC.getNUM_UNIT_PREREQ_OR_BONUSES(); ++iI)
			{
				if (GC.getUnitInfo(eUnit).getPrereqOrVicinityBonuses(iI) != NO_BONUS)
				{
					if ((pCity == NULL) || !(pCity->canTrain(eUnit)))
					{
						szTempBuffer.Format(L"%s%s", NEWLINE, gDLL->getText("TXT_KEY_REQUIRES_IN_CITY_VICINITY").c_str());
						setListHelp(szBuffer, szTempBuffer, GC.getBonusInfo((BonusTypes) GC.getUnitInfo(eUnit).getPrereqOrVicinityBonuses(iI)).getDescription(), gDLL->getText("TXT_KEY_OR").c_str(), bFirst);
						bFirst = false;
					}
				}
			}

			if (!bFirst)
			{
				szBuffer.append(ENDCOLR);
			}
			// Afforess	Vicinity Bonus END

			if (!bCivilopediaText)
			{
				for (iI = 0; iI < GC.getUnitInfo(eUnit).getNumPrereqAndBuildings(); ++iI)
				{
					if (pCity == NULL || pCity->getNumBuilding((BuildingTypes)GC.getUnitInfo(eUnit).getPrereqAndBuilding(iI)) < 1)
					{
						szBuffer.append(NEWLINE);
						szBuffer.append(gDLL->getText("TXT_KEY_UNIT_REQUIRES_STRING", GC.getBuildingInfo((BuildingTypes)GC.getUnitInfo(eUnit).getPrereqAndBuilding(iI)).getTextKeyWide()));
					}
				}

				bFirst = true;
				int iNum = GC.getUnitInfo(eUnit).getPrereqOrBuildingsNum();
				bool bNeeded = true;
				if (pCity)
				{
					for (iI = 0; iI < iNum; iI++) // Check if this requirement has been met already
					{
						BuildingTypes eBuilding = GC.getUnitInfo(eUnit).getPrereqOrBuilding(iI);
						if (pCity->getNumBuilding(eBuilding) > 0)
						{
							bNeeded = false;
							break;
						}
					}
				}
				if (bNeeded)
				{
					for (iI = 0; iI < iNum; iI++)
					{
						BuildingTypes eBuilding = GC.getUnitInfo(eUnit).getPrereqOrBuilding(iI);
						if (!bFirst)
						{
							szBuffer.append(gDLL->getText("TXT_KEY_OR"));
							CvWString szBuilding;
							szBuffer.append(gDLL->getText("TXT_KEY_SET_WARNING_COLOR"));
							szBuilding.Format(L"<link=%s>%s</link>", CvWString(GC.getBuildingInfo(eBuilding).getType()).GetCString(), GC.getBuildingInfo(eBuilding).getDescription());
							szBuffer.append(szBuilding);
							szBuffer.append(ENDCOLR);
						}
						else
						{
							szBuffer.append(NEWLINE);
							szBuffer.append(gDLL->getText("TXT_KEY_UNIT_REQUIRES_STRING", GC.getBuildingInfo(eBuilding).getTextKeyWide()));
							bFirst = false;
						}
					}
				}

				if (!bTechChooserText)
				{
					if (GC.getUnitInfo(eUnit).getPrereqAndTech() != NO_TECH)
					{
						if (GC.getGame().getActivePlayer() == NO_PLAYER || !(GET_TEAM(GET_PLAYER(ePlayer).getTeam()).isHasTech((TechTypes)(GC.getUnitInfo(eUnit).getPrereqAndTech()))))
						{
							szBuffer.append(NEWLINE);
							szBuffer.append(gDLL->getText("TXT_KEY_UNIT_REQUIRES_STRING", GC.getTechInfo((TechTypes)(GC.getUnitInfo(eUnit).getPrereqAndTech())).getTextKeyWide()));
						}
					}
				}

				bFirst = true;

				for (iI = 0; iI < GC.getNUM_UNIT_AND_TECH_PREREQS(); ++iI)
				{
					if (GC.getUnitInfo(eUnit).getPrereqAndTechs(iI) != NO_TECH)
					{
						if (bTechChooserText || GC.getGame().getActivePlayer() == NO_PLAYER || !(GET_TEAM(GET_PLAYER(ePlayer).getTeam()).isHasTech((TechTypes)(GC.getUnitInfo(eUnit).getPrereqAndTechs(iI)))))
						{
							szTempBuffer.Format(L"%s%s", NEWLINE, gDLL->getText("TXT_KEY_REQUIRES").c_str());
							setListHelp(szBuffer, szTempBuffer, GC.getTechInfo(((TechTypes)(GC.getUnitInfo(eUnit).getPrereqAndTechs(iI)))).getDescription(), gDLL->getText("TXT_KEY_AND").c_str(), bFirst);
							bFirst = false;
						}
					}
				}

				if (!bFirst)
				{
					szBuffer.append(ENDCOLR);
				}

				if (GC.getUnitInfo(eUnit).getPrereqAndBonus() != NO_BONUS)
				{
					if ((pCity == NULL) || !(pCity->hasBonus((BonusTypes)GC.getUnitInfo(eUnit).getPrereqAndBonus())))
					{
						szBuffer.append(NEWLINE);
						szBuffer.append(gDLL->getText("TXT_KEY_UNIT_REQUIRES_STRING", GC.getBonusInfo((BonusTypes)(GC.getUnitInfo(eUnit).getPrereqAndBonus())).getTextKeyWide()));
					}
				}

				bFirst = true;

				for (iI = 0; iI < GC.getNUM_UNIT_PREREQ_OR_BONUSES(); ++iI)
				{
					if (GC.getUnitInfo(eUnit).getPrereqOrBonuses(iI) != NO_BONUS)
					{
						if ((pCity == NULL) || !(pCity->hasBonus((BonusTypes)GC.getUnitInfo(eUnit).getPrereqOrBonuses(iI))))
						{
							szTempBuffer.Format(L"%s%s", NEWLINE, gDLL->getText("TXT_KEY_REQUIRES").c_str());
							setListHelp(szBuffer, szTempBuffer, GC.getBonusInfo((BonusTypes) GC.getUnitInfo(eUnit).getPrereqOrBonuses(iI)).getDescription(), gDLL->getText("TXT_KEY_OR").c_str(), bFirst);
							bFirst = false;
						}
					}
				}
				bFirst = true;
				for (iI = 0; iI < GC.getNumCivicInfos(); ++iI)
				{
					if (GC.getUnitInfo(eUnit).isPrereqOrCivics(CivicTypes(iI)))
					{
						bool civicActive = (pCity == NULL ?
							(GC.getGame().getActivePlayer() != NO_PLAYER && GET_PLAYER(GC.getGame().getActivePlayer()).isCivic(CivicTypes(iI))) :
							GET_PLAYER(pCity->getOwner()).isCivic(CivicTypes(iI)));

						CvWString prefix = gDLL->getText("TXT_KEY_REVERT_COLOR") + gDLL->getText("TXT_KEY_REQUIRES_NO_WARNING");
						CvWString desc = GC.getCivicInfo((CivicTypes(iI))).getDescription();

						CvWString separator = gDLL->getText("TXT_KEY_REVERT_COLOR") + gDLL->getText("TXT_KEY_OR");

						if (!civicActive)
						{
							desc = gDLL->getText("TXT_KEY_SET_WARNING_COLOR") + desc;
						}
						else
						{
							desc = gDLL->getText("TXT_KEY_POSITIVE_COLOR") + desc;
						}

						szTempBuffer.Format(L"%s%s", NEWLINE, prefix.c_str());
						setListHelp(szBuffer,szTempBuffer, desc.c_str(), separator.c_str(), bFirst);
						bFirst = false;
					}
				}

				for (iI = 0; iI < GC.getUnitInfo(eUnit).getNumPrereqAndBuildings(); ++iI)
				{
					szBuffer.append(NEWLINE);
					szBuffer.append(gDLL->getText("TXT_KEY_UNIT_REQUIRES_STRING", GC.getBuildingInfo((BuildingTypes)GC.getUnitInfo(eUnit).getPrereqAndBuilding(iI)).getTextKeyWide()));
				}

				if (GC.getUnitInfo(eUnit).isStateReligion())
				{
					if ((pCity == NULL) || GET_PLAYER(ePlayer).getStateReligion() == NO_RELIGION || !pCity->isHasReligion(GET_PLAYER(ePlayer).getStateReligion()))
					{
						szBuffer.append(NEWLINE);
						szBuffer.append(gDLL->getText("TXT_KEY_REQUIRES_STATE_RELIGION"));
					}
				}

				if (GC.getUnitInfo(eUnit).isInquisitor())
				{
					if ((pCity == NULL) || !GET_PLAYER(ePlayer).isInquisitionConditions())
					{
						szBuffer.append(NEWLINE);
						szBuffer.append(gDLL->getText("TXT_KEY_NOT_INQUISITION_CONDITIONS"));
					}
				}
				if (!bFirst)
				{
					szBuffer.append(ENDCOLR);
				}
			}
		}

		if (!bCivilopediaText && GC.getGame().getActivePlayer() != NO_PLAYER)
		{
			if (pCity == NULL)
			{
				szTempBuffer.Format(L"%s%d%c", NEWLINE, GET_PLAYER(ePlayer).getProductionNeeded(eUnit), GC.getYieldInfo(YIELD_PRODUCTION).getChar());
				szBuffer.append(szTempBuffer);
			}
			else
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_UNIT_TURNS", pCity->getProductionTurnsLeft(eUnit,((gDLL->ctrlKey() || !(gDLL->shiftKey())) ? 0 : pCity->getOrderQueueLength())), pCity->getProductionNeeded(eUnit), GC.getYieldInfo(YIELD_PRODUCTION).getChar()));

				if (pCity->getUnitProduction(eUnit) > 0)
				{
					szTempBuffer.Format(L" - %d/%d%c", pCity->getUnitProduction(eUnit), pCity->getProductionNeeded(eUnit), GC.getYieldInfo(YIELD_PRODUCTION).getChar());
					szBuffer.append(szTempBuffer);

					if (getBugOptionBOOL("CityScreen__ProductionDecayHover", true, "BUG_PRODUCTION_DECAY_HOVER"))
					{
						setProductionDecayHelp(szBuffer, pCity->getUnitProductionDecayTurns(eUnit), getBugOptionINT("CityScreen__ProductionDecayHoverUnitThreshold",
							5, "BUG_PRODUCTION_DECAY_HOVER_UNIT_THRESHOLD"), pCity->getUnitProductionDecay(eUnit), pCity->getProductionUnit() == eUnit);
					}
				}
				else
				{
					szTempBuffer.Format(L" - %d%c", pCity->getProductionNeeded(eUnit), GC.getYieldInfo(YIELD_PRODUCTION).getChar());
					szBuffer.append(szTempBuffer);
				}
			}
		}

		for (iI = 0; iI < GC.getNumBonusInfos(); ++iI)
		{
			if (GC.getUnitInfo(eUnit).getBonusProductionModifier(iI) != 0)
			{
				if (pCity != NULL)
				{
					if (pCity->hasBonus((BonusTypes)iI))
					{
						szBuffer.append(gDLL->getText("TXT_KEY_COLOR_POSITIVE"));
					}
					else
					{
						szBuffer.append(gDLL->getText("TXT_KEY_COLOR_NEGATIVE"));
					}
				}
				if (!bCivilopediaText)
				{
					szBuffer.append(L" (");
				}
				else
				{
					szTempBuffer.Format(L"%s%c", NEWLINE, gDLL->getSymbolID(BULLET_CHAR), szTempBuffer.c_str());
					szBuffer.append(szTempBuffer);
				}
				if (GC.getUnitInfo(eUnit).getBonusProductionModifier(iI) == 100)
				{
					szBuffer.append(gDLL->getText("TXT_KEY_UNIT_DOUBLE_SPEED", CvWString(GC.getBonusInfo((BonusTypes)iI).getType()).GetCString(), GC.getBonusInfo((BonusTypes)iI).getTextKeyWide()));
				}
				else
				{
					szBuffer.append(gDLL->getText("TXT_KEY_UNIT_BUILDS_FASTER", GC.getUnitInfo(eUnit).getBonusProductionModifier(iI), CvWString(GC.getBonusInfo((BonusTypes)iI).getType()).GetCString(), GC.getBonusInfo((BonusTypes)iI).getTextKeyWide()));
				}
				if (!bCivilopediaText)
				{
					szBuffer.append(L")");
				}
				if (pCity != NULL)
				{
					szBuffer.append(gDLL->getText("TXT_KEY_COLOR_REVERT"));
				}
			}
		}
	}

	if (bTBUnitView1)
	{
		if (bStrategyText)
		{
			if (!CvWString(GC.getUnitInfo(eUnit).getStrategy()).empty())
			{
				if ((ePlayer == NO_PLAYER) || GET_PLAYER(ePlayer).isOption(PLAYEROPTION_ADVISOR_HELP))
				{
					szBuffer.append(SEPARATOR);
					szBuffer.append(NEWLINE);
					szBuffer.append(gDLL->getText("TXT_KEY_SIDS_TIPS"));
					szBuffer.append(L'\"');
					szBuffer.append(GC.getUnitInfo(eUnit).getStrategy());
					szBuffer.append(L'\"');
				}
			}
		}
	}

	if (pCity != NULL && bNormalView)
	{
		if ((gDLL->getChtLvl() > 0) && gDLL->ctrlKey())
		{
			szBuffer.append(NEWLINE);
			for (int iUnitAI = 0; iUnitAI < NUM_UNITAI_TYPES; iUnitAI++)
			{
				int iTempValue = GET_PLAYER(pCity->getOwner()).AI_unitValue(eUnit, (UnitAITypes)iUnitAI, pCity->area());
				if (iTempValue != 0)
				{
					CvWString szTempString;
					getUnitAIString(szTempString, (UnitAITypes)iUnitAI);
					szBuffer.append(CvWString::format(L"(%s : %d) ", szTempString.GetCString(), iTempValue));
				}
			}
		}
	}
	if (!bCivilopediaText)
	{
		if (!bTBUnitView1)
		{
			szBuffer.append(NEWLINE);
			szTempBuffer.Format( SETCOLR L"%s" ENDCOLR, TEXT_COLOR("COLOR_UNIT_TEXT"), gDLL->getText("TXT_TB_UNIT_VIEW_1").c_str());
			szBuffer.append(szTempBuffer);
		}
		if (!bTBUnitView2)
		{
			szBuffer.append(NEWLINE);
			szTempBuffer.Format( SETCOLR L"%s" ENDCOLR, TEXT_COLOR("COLOR_UNIT_TEXT"), gDLL->getText("TXT_TB_UNIT_VIEW_2").c_str());
			szBuffer.append(szTempBuffer);
		}
		if (!bTBUnitView3)
		{
			szBuffer.append(NEWLINE);
			szTempBuffer.Format( SETCOLR L"%s" ENDCOLR, TEXT_COLOR("COLOR_UNIT_TEXT"), gDLL->getText("TXT_TB_UNIT_VIEW_3").c_str());
			szBuffer.append(szTempBuffer);
		}
	}
}

// BUG - Building Actual Effects - start
/*
 * Adds the actual effects of adding a building to the city.
 */
void CvGameTextMgr::setBuildingActualEffects(CvWStringBuffer &szBuffer, CvWString& szStart, BuildingTypes eBuilding, CvCity* pCity, bool bNewLine)
{
	if (NULL != pCity)
	{
		bool bStarted = false;

		// Defense
		int iDefense = pCity->getAdditionalDefenseByBuilding(eBuilding);
		bStarted = setResumableValueChangeHelp(szBuffer, szStart, L": ", L"", iDefense, gDLL->getSymbolID(DEFENSE_CHAR), true, bNewLine, bStarted);

		// Happiness
		int iGood = 0;
		int iBad = 0;
		int iAngryPop = 0;
		int iHappiness = pCity->getAdditionalHappinessByBuilding(eBuilding, iGood, iBad, iAngryPop);
		bStarted = setResumableGoodBadChangeHelp(szBuffer, szStart, L": ", L"", iGood, gDLL->getSymbolID(HAPPY_CHAR), iBad, gDLL->getSymbolID(UNHAPPY_CHAR), false, bNewLine, bStarted);
		bStarted = setResumableValueChangeHelp(szBuffer, szStart, L": ", L"", iAngryPop, gDLL->getSymbolID(ANGRY_POP_CHAR), false, bNewLine, bStarted);

		// Health
		iGood = 0;
		iBad = 0;
		int iSpoiledFood = 0;
		int iStarvation = 0;
		int iHealth = pCity->getAdditionalHealthByBuilding(eBuilding, iGood, iBad, iSpoiledFood, iStarvation);
		bStarted = setResumableGoodBadChangeHelp(szBuffer, szStart, L": ", L"", iGood, gDLL->getSymbolID(HEALTHY_CHAR), iBad, gDLL->getSymbolID(UNHEALTHY_CHAR), false, bNewLine, bStarted);
		bStarted = setResumableValueChangeHelp(szBuffer, szStart, L": ", L"", iSpoiledFood, gDLL->getSymbolID(EATEN_FOOD_CHAR), false, bNewLine, bStarted);
		bStarted = setResumableValueChangeHelp(szBuffer, szStart, L": ", L"", iStarvation, gDLL->getSymbolID(BAD_FOOD_CHAR), false, bNewLine, bStarted);

		// Yield
		int aiYields[NUM_YIELD_TYPES];
		for (int iI = 0; iI < NUM_YIELD_TYPES; ++iI)
		{
			aiYields[iI] = pCity->getAdditionalYieldByBuilding((YieldTypes)iI, eBuilding);
		}

		int iCommerce = aiYields[YIELD_COMMERCE];
		aiYields[YIELD_COMMERCE] = 0;

		bStarted = setResumableYieldChangeHelp(szBuffer, szStart, L": ", L"", aiYields, false, bNewLine, bStarted);

		// Commerce
		int aiCommerces[NUM_COMMERCE_TYPES];
		for (int iI = 0; iI < NUM_COMMERCE_TYPES; ++iI)
		{
			aiCommerces[iI] = pCity->getAdditionalCommerceTimes100ByBuilding((CommerceTypes)iI, eBuilding);

			aiCommerces[iI] += iCommerce * GET_PLAYER(pCity->getOwner()).getCommercePercent((CommerceTypes)iI);
		}

		// Maintenance - add to gold
		aiCommerces[COMMERCE_GOLD] += pCity->getSavedMaintenanceTimes100ByBuilding(eBuilding);
		bStarted = setResumableCommerceTimes100ChangeHelp(szBuffer, szStart, L": ", L"", aiCommerces, bNewLine, bStarted);

		// Great People
		int iGreatPeopleRate = pCity->getAdditionalGreatPeopleRateByBuilding(eBuilding);
		bStarted = setResumableValueChangeHelp(szBuffer, szStart, L": ", L"", iGreatPeopleRate, gDLL->getSymbolID(GREAT_PEOPLE_CHAR), false, bNewLine, bStarted);
	}
}

/*
 * Calls new function below without displaying actual effects.
 */
void CvGameTextMgr::setBuildingHelp(CvWStringBuffer &szBuffer, BuildingTypes eBuilding, bool bCivilopediaText, bool bStrategyText, bool bTechChooserText, CvCity* pCity)
{
	setBuildingHelpActual(szBuffer, eBuilding, bCivilopediaText, bStrategyText, bTechChooserText, pCity, false);
}


void buildingHelpTechAndSpecialistModifiers_Old(const CvBuildingInfo& kBuilding, CvWStringBuffer& szBuffer, PlayerTypes ePlayer, TeamTypes eTeam)
{
	int iTechHappiness = 0;
	int iTechHealth = 0;
	int iSpecialistHealth = 0;
	int iSpecialistHappiness = 0;

	bool bHasTechHappinessTypes = kBuilding.getNumTechHappinessTypes() > 0;
	bool bHasTechHealthTypes = kBuilding.getNumTechHealthTypes() > 0;
	for (int techInfoIdx = 0; techInfoIdx < GC.getNumTechInfos(); techInfoIdx++)
	{
		TechTypes eTech = ((TechTypes)techInfoIdx);

		if (bHasTechHappinessTypes)
		{
			iTechHappiness = kBuilding.getTechHappinessType(eTech);
			if (iTechHappiness > 0)
			{
				szBuffer.append(NEWLINE);
				if (GC.getGame().getActivePlayer() != NO_PLAYER && ePlayer != NO_PLAYER && GET_TEAM(eTeam).isHasTech(eTech))
				{
					szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_TECH_HAPPINESS_TYPE_KNOWN", iTechHappiness, gDLL->getSymbolID(HAPPY_CHAR), GC.getTechInfo(eTech).getTextKeyWide()));
				}
				else
				{
					szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_TECH_HAPPINESS_TYPE", iTechHappiness, gDLL->getSymbolID(HAPPY_CHAR), GC.getTechInfo(eTech).getTextKeyWide()));
				}
			}
			else if (iTechHappiness < 0)
			{
				szBuffer.append(NEWLINE);
				if (GC.getGame().getActivePlayer() != NO_PLAYER && ePlayer != NO_PLAYER && GET_TEAM(eTeam).isHasTech(eTech))
				{
					szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_TECH_HAPPINESS_TYPE_KNOWN", -iTechHappiness, gDLL->getSymbolID(UNHAPPY_CHAR), GC.getTechInfo(eTech).getTextKeyWide()));
				}
				else
				{
					szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_TECH_HAPPINESS_TYPE", -iTechHappiness, gDLL->getSymbolID(UNHAPPY_CHAR), GC.getTechInfo(eTech).getTextKeyWide()));
				}
			}
		}

		if (bHasTechHealthTypes)
		{
			iTechHealth = kBuilding.getTechHealthType(eTech);
			if (iTechHealth > 0)
			{
				szBuffer.append(NEWLINE);
				if (GC.getGame().getActivePlayer() != NO_PLAYER && ePlayer != NO_PLAYER && GET_TEAM(eTeam).isHasTech(eTech))
				{
					szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_TECH_HEALTH_TYPE_KNOWN", iTechHealth, gDLL->getSymbolID(HEALTHY_CHAR), GC.getTechInfo(eTech).getTextKeyWide()));
				}
				else
				{
					szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_TECH_HEALTH_TYPE", iTechHealth, gDLL->getSymbolID(HEALTHY_CHAR), GC.getTechInfo(eTech).getTextKeyWide()));
				}
			}
			else if (iTechHealth < 0)
			{
				szBuffer.append(NEWLINE);
				if (GC.getGame().getActivePlayer() != NO_PLAYER && ePlayer != NO_PLAYER && GET_TEAM(eTeam).isHasTech(eTech))
				{
					szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_TECH_HEALTH_TYPE_KNOWN", -iTechHealth, gDLL->getSymbolID(UNHEALTHY_CHAR), GC.getTechInfo(eTech).getTextKeyWide()));
				}
				else
				{
					szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_TECH_HEALTH_TYPE", -iTechHealth, gDLL->getSymbolID(UNHEALTHY_CHAR), GC.getTechInfo(eTech).getTextKeyWide()));
				}
			}
		}
	}
}

void buildingHelpTechModifiers(/*in out*/ CvWStringBuffer& szBuffer, const TechModifierArray& modifierArray, const PlayerTypes ePlayer, const TeamTypes eTeam, const char* const textKeyKnown, const char* const textKeyUnknown, const int symbolCharPositive, const int symbolCharNegative)
{
	// tepid argument for using iterator instead of indexing: https://stackoverflow.com/a/776629/6402065
	// TODO: test that on this compiler
	for (TechModifierArray::const_iterator itr = modifierArray.begin(); itr != modifierArray.end(); ++itr)
	{
		const TechTypes& tech = itr->first;
		const int& modifier = itr->second;
		if (modifier > 0)
		{
			szBuffer.append(NEWLINE);
			if (GC.getGame().getActivePlayer() != NO_PLAYER && ePlayer != NO_PLAYER && GET_TEAM(eTeam).isHasTech(tech))
			{
				szBuffer.append(gDLL->getText(textKeyKnown, modifier, gDLL->getSymbolID(symbolCharPositive), GC.getTechInfo(tech).getTextKeyWide()));
			}
			else
			{
				szBuffer.append(gDLL->getText(textKeyUnknown, modifier, gDLL->getSymbolID(symbolCharPositive), GC.getTechInfo(tech).getTextKeyWide()));
			}
		}
		else if (modifier < 0)
		{
			szBuffer.append(NEWLINE);
			if (GC.getGame().getActivePlayer() != NO_PLAYER && ePlayer != NO_PLAYER && GET_TEAM(eTeam).isHasTech(tech))
			{
				szBuffer.append(gDLL->getText(textKeyKnown, -modifier, gDLL->getSymbolID(symbolCharNegative), GC.getTechInfo(tech).getTextKeyWide()));
			}
			else
			{
				szBuffer.append(gDLL->getText(textKeyUnknown, -modifier, gDLL->getSymbolID(symbolCharNegative), GC.getTechInfo(tech).getTextKeyWide()));
			}
		}
	}
}

void buildingHelpTechAndSpecialistModifiers(/* in out*/ CvWStringBuffer& szBuffer, const CvBuildingInfo& kBuilding, const PlayerTypes ePlayer, const TeamTypes eTeam)
{
	buildingHelpTechModifiers(szBuffer, kBuilding.getTechHappinessTypeArray(), ePlayer, eTeam,
		"TXT_KEY_BUILDING_TECH_HAPPINESS_TYPE_KNOWN", "TXT_KEY_BUILDING_TECH_HAPPINESS_TYPE",
		HAPPY_CHAR, UNHAPPY_CHAR);
	buildingHelpTechModifiers(szBuffer, kBuilding.getTechHealthTypeArray(), ePlayer, eTeam,
		"TXT_KEY_BUILDING_TECH_HEALTH_TYPE_KNOWN", "TXT_KEY_BUILDING_TECH_HEALTH_TYPE",
		HEALTHY_CHAR, UNHEALTHY_CHAR);
}

/*
 * Adds option to display actual effects.
 */
void CvGameTextMgr::setBuildingHelpActual(CvWStringBuffer &szBuffer, BuildingTypes eBuilding, bool bCivilopediaText, bool bStrategyText, bool bTechChooserText, CvCity* pCity, bool bActual)
// BUG - Building Actual Effects - end
{
	PROFILE_FUNC();

	CvWString szFirstBuffer;
	CvWString szTempBuffer;
	UnitTypes eGreatPeopleUnit;
	PlayerTypes ePlayer;
	TeamTypes eTeam = NO_TEAM;
	bool bFirst;
	int iLast;
	bool bRelDisabled = false;

	if (NO_BUILDING == eBuilding)
	{
		return;
	}

	const CvBuildingInfo& kBuilding = GC.getBuildingInfo(eBuilding);

	if (pCity != NULL)
	{
		ePlayer = pCity->getOwner();
		bRelDisabled = GET_PLAYER(ePlayer).isBuildingtoDisplayReligiouslyDisabled(eBuilding);
	}
	else
	{
		ePlayer = GC.getGame().getActivePlayer();
	}

	if (ePlayer != NO_PLAYER)
	{
		eTeam = GET_PLAYER(ePlayer).getTeam();
	}

	if (bCivilopediaText || !GC.getGame().isOption(GAMEOPTION_RELIGIOUS_DISABLING))
	{
		bRelDisabled = false;
	}

	if (!bCivilopediaText)
	{
		szTempBuffer.Format( SETCOLR L"<link=%s>%s</link>" ENDCOLR , TEXT_COLOR("COLOR_BUILDING_TEXT"), CvWString(kBuilding.getType()).GetCString(), kBuilding.getDescription());
		szBuffer.append(szTempBuffer);
		//ls612: Orbital Buildings are denoted but not explained, as it would take too much space
		//The Full explanation will be located in the Concepts section of the Pedia
		if (bRelDisabled)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_REL_DISABLED"));
		}

		bool bOrbital = kBuilding.isOrbital();
		if (bOrbital)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_ORBITAL"));
		}

		bool bOrbitalInfra = kBuilding.isOrbitalInfrastructure();
		if (bOrbitalInfra)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_ORBITAL_INFRASTRUCTURE"));
		}

		//ls612: bNoHolyCity tag text
		if (kBuilding.isNoHolyCity())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_NO_HOLY_CITY"));
		}

		if (!bRelDisabled)
		{
			int iHappiness;
			if (NULL != pCity)
			{
				iHappiness = pCity->getBuildingHappiness(eBuilding);
			}
			else
			{
				iHappiness = kBuilding.getHappiness();
			}

			if (iHappiness != 0)
			{
				szTempBuffer.Format(L", +%d%c", abs(iHappiness), ((iHappiness > 0) ? gDLL->getSymbolID(HAPPY_CHAR) : gDLL->getSymbolID(UNHAPPY_CHAR)));
				szBuffer.append(szTempBuffer);
			}

			int iHealth;
			if (NULL != pCity)
			{
				iHealth = pCity->getBuildingGoodHealth(eBuilding);
			}
			else
			{
				iHealth = kBuilding.getHealth();
				if (ePlayer != NO_PLAYER)
				{
					iHealth += GET_PLAYER(ePlayer).getExtraBuildingHealth(eBuilding);
				}
			}
			if (iHealth != 0)
			{
				szTempBuffer.Format(L", +%d%c", abs(iHealth), ((iHealth > 0) ? gDLL->getSymbolID(HEALTHY_CHAR): gDLL->getSymbolID(UNHEALTHY_CHAR)));
				szBuffer.append(szTempBuffer);
			}

			iHealth = 0;
			if (NULL != pCity)
			{
				iHealth = pCity->getBuildingBadHealth(eBuilding);
			}
			if (iHealth != 0)
			{
				szTempBuffer.Format(L", +%d%c", abs(iHealth), ((iHealth > 0) ? gDLL->getSymbolID(HEALTHY_CHAR): gDLL->getSymbolID(UNHEALTHY_CHAR)));
				szBuffer.append(szTempBuffer);
			}

			bool bCity = (pCity != NULL);
			int aiYields[NUM_YIELD_TYPES];
			int aiYieldModifiers[NUM_YIELD_TYPES];
			for (int iI = 0; iI < NUM_YIELD_TYPES; ++iI)
			{
				aiYields[iI] = kBuilding.getYieldChange(iI);
				aiYieldModifiers[iI] = kBuilding.getYieldModifier(iI);
				if (bCity)
				{
					aiYields[iI] += ((kBuilding.getYieldPerPopChange(iI) * pCity->getPopulation())/100);
					aiYields[iI] += (pCity->getBuildingYieldChange(eBuilding, (YieldTypes)iI) + GET_TEAM(eTeam).getBuildingYieldChange(eBuilding, (YieldTypes)iI));
					aiYieldModifiers[iI] += (pCity->getBuildingYieldModifier(eBuilding, (YieldTypes)iI) + GET_TEAM(eTeam).getBuildingYieldModifier(eBuilding, (YieldTypes)iI));
				}
			}

			setYieldChangeHelp(szBuffer, L", ", L"", L"", aiYields, false, false);

			if (!bCity)
			{
				for (int iI = 0; iI < NUM_YIELD_TYPES; ++iI)
				{
					aiYields[iI] = kBuilding.getYieldPerPopChange(iI);
				}
				setYieldPerPopChangeHelp(szBuffer, L", ", L"", L"", aiYields, false, false);
			}

			int aiCommerces[NUM_COMMERCE_TYPES];
			int aiCommerceModifiers[NUM_COMMERCE_TYPES];

			for (int iI = 0; iI < NUM_COMMERCE_TYPES; ++iI)
			{
				int iBaseCommerceChange = kBuilding.getCommerceChange(iI);
				if ( iBaseCommerceChange < 0 && iI == COMMERCE_GOLD && GC.getDefineINT("TREAT_NEGATIVE_GOLD_AS_MAINTENANCE") )
				{
					iBaseCommerceChange = 0;
				}
				if (bCity)
				{
					iBaseCommerceChange += ((kBuilding.getCommercePerPopChange(iI) * pCity->getPopulation())/100);
				}

				aiCommerceModifiers[iI] = kBuilding.getCommerceModifier(iI);
				if (NULL == pCity)
				{
					aiCommerces[iI] = iBaseCommerceChange;
					aiCommerces[iI] += kBuilding.getObsoleteSafeCommerceChange(iI);
				}
				else if (pCity->getNumBuilding(eBuilding) <= 0)
				{
					aiCommerces[iI] = iBaseCommerceChange;
					aiCommerces[iI] += kBuilding.getObsoleteSafeCommerceChange(iI);
					if (ePlayer != NO_PLAYER)
					{
						aiCommerces[iI] += GET_TEAM(eTeam).getBuildingCommerceChange(eBuilding, (CommerceTypes)iI);
						aiCommerceModifiers[iI] += GET_TEAM(eTeam).getBuildingCommerceModifier(eBuilding, (CommerceTypes)iI);
					}
				}
				else
				{
					aiCommerces[iI] = pCity->getBuildingCommerceByBuilding((CommerceTypes)iI, eBuilding) + (pCity->getBonusCommercePercentChanges((CommerceTypes)iI, eBuilding) / 100);
				}
			}
			setCommerceChangeHelp(szBuffer, L", ", L"", L"", aiCommerces, false, false);

			if (!bCity)
			{
				for (int iI = 0; iI < NUM_COMMERCE_TYPES; ++iI)
				{
					aiCommerces[iI] = kBuilding.getCommercePerPopChange(iI);
				}
				setCommercePerPopChangeHelp(szBuffer, L", ", L"", L"", aiCommerces, false, false);
			}

			setYieldChangeHelp(szBuffer, L", ", L"", L"", aiYieldModifiers, true, bCivilopediaText);
			setCommerceChangeHelp(szBuffer, L", ", L"", L"", aiCommerceModifiers, true, bCivilopediaText);
		}

		if (kBuilding.getGreatPeopleRateChange() != 0)
		{
			szTempBuffer.Format(L", %s%d%c", ((kBuilding.getGreatPeopleRateChange() > 0) ? L"+" : L""), kBuilding.getGreatPeopleRateChange(), gDLL->getSymbolID(GREAT_PEOPLE_CHAR));
			szBuffer.append(szTempBuffer);

			eGreatPeopleUnit = (UnitTypes)kBuilding.getGreatPeopleUnitType();

			if (eGreatPeopleUnit != NO_UNIT)
			{
				szTempBuffer.Format(L" (%s)", GC.getUnitInfo(eGreatPeopleUnit).getDescription());
				szBuffer.append(szTempBuffer);
			}
		}

		if (!bRelDisabled)
		{
			int iBuildingMaintenance = -kBuilding.getCommerceChange(COMMERCE_GOLD) * 100;
			if (iBuildingMaintenance > 0)
			{
				CvWString szRate = CvWString::format(L"%d.%02d", iBuildingMaintenance/100, iBuildingMaintenance%100);
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_MAINTENANCE", szRate.GetCString()));
			}

	// BUG - Building Actual Effects - start
			if (bActual && NULL != pCity && pCity->getOwner() == GC.getGame().getActivePlayer() && getBugOptionBOOL("MiscHover__BuildingActualEffects", true, "BUG_BUILDING_HOVER_ACTUAL_EFFECTS"))
			{
				CvWString szStart = gDLL->getText("TXT_KEY_ACTUAL_EFFECTS");
				setBuildingActualEffects(szBuffer, szStart, eBuilding, pCity);
			}
		}
// BUG - Building Actual Effects - end
	}

	if (bCivilopediaText)
	{
		if (!bRelDisabled)
		{
			setYieldChangeHelp(szBuffer, L"", L"", L"", kBuilding.getYieldModifierArray(), true, bCivilopediaText);

			setCommerceChangeHelp(szBuffer, L"", L"", L"", kBuilding.getCommerceModifierArray(), true, bCivilopediaText);
		}
	}
	else
	{
		if (isWorldWonder(eBuilding))
		{
			if (pCity == NULL || ePlayer == NO_PLAYER)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_WORLD_WONDER_ALLOWED", kBuilding.getMaxGlobalInstances()));
			}
			else
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_WORLD_WONDER_LEFT", kBuilding.getMaxGlobalInstances() - GC.getGame().getBuildingCreatedCount(eBuilding) - GET_TEAM(eTeam).getBuildingMaking(eBuilding)));
			}
		}

		if (isTeamWonder(eBuilding))
		{
			if (pCity == NULL || ePlayer == NO_PLAYER)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_TEAM_WONDER_ALLOWED", kBuilding.getMaxTeamInstances()));
			}
			else
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_TEAM_WONDER_LEFT", kBuilding.getMaxTeamInstances() - GET_TEAM(eTeam).getBuildingCountPlusMaking(eBuilding)));
			}
		}

		if (isNationalWonder(eBuilding))
		{

			if (pCity == NULL || ePlayer == NO_PLAYER)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_NATIONAL_WONDER_ALLOWED", kBuilding.getMaxPlayerInstances()));
			}
			else
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_NATIONAL_WONDER_LEFT", kBuilding.getMaxPlayerInstances() - GET_PLAYER(ePlayer).getBuildingCountPlusMaking(eBuilding)));
			}
		}

		SpecialBuildingTypes eSpecialBuilding = (SpecialBuildingTypes)kBuilding.getSpecialBuildingType();
		if (eSpecialBuilding != NO_SPECIALBUILDING && isNationalWonderGroupSpecialBuilding(eSpecialBuilding))
		{

			if (pCity == NULL || ePlayer == NO_PLAYER)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_GROUP_WONDER_ALLOWED", GC.getSpecialBuildingInfo(eSpecialBuilding).getTextKeyWide(), GC.getSpecialBuildingInfo(eSpecialBuilding).getMaxPlayerInstances()));
			}
			else
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_GROUP_WONDER_LEFT", GC.getSpecialBuildingInfo(eSpecialBuilding).getTextKeyWide(), GC.getSpecialBuildingInfo(eSpecialBuilding).getMaxPlayerInstances() - GET_PLAYER(ePlayer).getBuildingGroupCountPlusMaking(eSpecialBuilding)));
			}
		}
	}

	if (kBuilding.isAutoBuild())
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_AUTO_BUILD"));
	}

	if (!bRelDisabled)
	{
		int iCount = 0;
		for (int iJ = 0; iJ < NUM_COMMERCE_TYPES; iJ++)
		{
			iLast = 0;

			for (int iI = 0; iI < GC.getNumBuildingInfos(); iI++)
			{
				const BuildingTypes eLoopBuilding = static_cast<BuildingTypes>(iI);

				if (kBuilding.getGlobalBuildingCommerceChange(iI, iJ) != 0)
				{
					szFirstBuffer.Format(L"%s%s", NEWLINE, gDLL->getText("TXT_KEY_CIVIC_BUILDING_COMMERCE_CHANGE", kBuilding.getGlobalBuildingCommerceChange(iI, iJ), GC.getCommerceInfo((CommerceTypes)iJ).getChar()).c_str());
					CvWString szBuilding;
					szBuilding.Format(L"<link=%s>%s</link>", CvWString(GC.getBuildingInfo(eLoopBuilding).getType()).GetCString(), GC.getBuildingInfo(eLoopBuilding).getDescription());
					setListHelp(szBuffer, szFirstBuffer, szBuilding, L", ", (kBuilding.getGlobalBuildingCommerceChange(iI, iJ) != iLast));
					if (iLast == kBuilding.getGlobalBuildingCommerceChange(iI, iJ)) iCount++;
					iLast = kBuilding.getGlobalBuildingCommerceChange(iI, iJ);
					if (iCount > 3) iCount = iLast = 0;
				}
			}
		}
	}

	if (!bRelDisabled)
	{
		int aiYields[NUM_YIELD_TYPES];
		for (int iI = 0; iI < NUM_YIELD_TYPES; ++iI)
		{
			aiYields[iI] = kBuilding.getYieldPerPopChange(iI);
		}
		setYieldPerPopChangeHelp(szBuffer, L", ", L"", L"", aiYields, false, true);

		int aiCommerce[NUM_COMMERCE_TYPES];
		for (int iI = 0; iI < NUM_COMMERCE_TYPES; ++iI)
		{
			aiCommerce[iI] = kBuilding.getCommercePerPopChange(iI);
		}
		setCommercePerPopChangeHelp(szBuffer, L", ", L"", L"", aiCommerce, false, true);
	}
	//	Hurry types
	for (int iI = 0; iI < GC.getNumHurryInfos(); ++iI)
	{
		if (kBuilding.isHurry(iI))
		{
			szBuffer.append(CvWString::format(L"%s%c%s", NEWLINE, gDLL->getSymbolID(BULLET_CHAR), GC.getHurryInfo((HurryTypes)iI).getDescription()));
		}
	}

	if (kBuilding.getGlobalReligionCommerce() != NO_RELIGION)
	{
		if (!bRelDisabled)
		{
			szFirstBuffer = gDLL->getText("TXT_KEY_BUILDING_PER_CITY_WITH", GC.getReligionInfo((ReligionTypes) kBuilding.getGlobalReligionCommerce()).getChar());
			setCommerceChangeHelp(szBuffer, L"", L"", szFirstBuffer, GC.getReligionInfo((ReligionTypes) kBuilding.getGlobalReligionCommerce()).getGlobalReligionCommerceArray());
		}
	}

	if (NO_CORPORATION != kBuilding.getFoundsCorporation())
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_FOUNDS_CORPORATION", CvWString(GC.getCorporationInfo((CorporationTypes)kBuilding.getFoundsCorporation()).getType()).GetCString(), GC.getCorporationInfo((CorporationTypes)kBuilding.getFoundsCorporation()).getTextKeyWide()));
	}

	if (kBuilding.getGlobalCorporationCommerce() != NO_CORPORATION)
	{
		szFirstBuffer = gDLL->getText("TXT_KEY_BUILDING_PER_CITY_WITH", GC.getCorporationInfo((CorporationTypes) kBuilding.getGlobalCorporationCommerce()).getChar());
		setCommerceChangeHelp(szBuffer, L"", L"", szFirstBuffer, GC.getCorporationInfo((CorporationTypes) kBuilding.getGlobalCorporationCommerce()).getHeadquarterCommerceArray());
	}

	if (kBuilding.getNoBonus() != NO_BONUS)
	{
		const CvBonusInfo& kBonus = GC.getBonusInfo((BonusTypes) kBuilding.getNoBonus());
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_DISABLES", CvWString(kBonus.getType()).GetCString(), kBonus.getTextKeyWide(), kBonus.getChar()));
	}

	if (kBuilding.getFreeBonus() != NO_BONUS)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_PROVIDES", GC.getGame().getNumFreeBonuses(eBuilding), CvWString(GC.getBonusInfo((BonusTypes)kBuilding.getFreeBonus()).getType()).GetCString(), GC.getBonusInfo((BonusTypes)kBuilding.getFreeBonus()).getTextKeyWide(), GC.getBonusInfo((BonusTypes)kBuilding.getFreeBonus()).getChar()));

		if (GC.getBonusInfo((BonusTypes)(kBuilding.getFreeBonus())).getHealth() != 0)
		{
			szTempBuffer.Format(L", +%d%c", abs(GC.getBonusInfo((BonusTypes) kBuilding.getFreeBonus()).getHealth()), ((GC.getBonusInfo((BonusTypes)(kBuilding.getFreeBonus())).getHealth() > 0) ? gDLL->getSymbolID(HEALTHY_CHAR): gDLL->getSymbolID(UNHEALTHY_CHAR)));
			szBuffer.append(szTempBuffer);
		}

		if (GC.getBonusInfo((BonusTypes)(kBuilding.getFreeBonus())).getHappiness() != 0)
		{
			szTempBuffer.Format(L", +%d%c", abs(GC.getBonusInfo((BonusTypes) kBuilding.getFreeBonus()).getHappiness()), ((GC.getBonusInfo((BonusTypes)(kBuilding.getFreeBonus())).getHappiness() > 0) ? gDLL->getSymbolID(HAPPY_CHAR) : gDLL->getSymbolID(UNHAPPY_CHAR)));
			szBuffer.append(szTempBuffer);
		}

		if (ePlayer != NO_PLAYER)
		{
			CvPlayer& kPlayer = GET_PLAYER(ePlayer);
			szBuffer.append(gDLL->getText("TXT_KEY_BONUS_AVAILABLE_PLAYER", kPlayer.getNumAvailableBonuses((BonusTypes)(kBuilding.getFreeBonus())), kPlayer.getNameKey()));
		}
	}

	int iNum = kBuilding.getNumExtraFreeBonuses();
	for (int iI=0; iI<iNum; iI++)
	{
		const CvBonusInfo& kBonus = GC.getBonusInfo(kBuilding.getExtraFreeBonus(iI));
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_PROVIDES", kBuilding.getExtraFreeBonusNum(iI), CvWString(kBonus.getType()).GetCString(), kBonus.getTextKeyWide(), kBonus.getChar()));

		if (kBonus.getHealth() != 0)
		{
			szTempBuffer.Format(L", +%d%c", abs(kBonus.getHealth()), (kBonus.getHealth() > 0) ? gDLL->getSymbolID(HEALTHY_CHAR): gDLL->getSymbolID(UNHEALTHY_CHAR));
			szBuffer.append(szTempBuffer);
		}

		if (kBonus.getHappiness() != 0)
		{
			szTempBuffer.Format(L", +%d%c", abs(kBonus.getHappiness()), (kBonus.getHappiness() > 0) ? gDLL->getSymbolID(HAPPY_CHAR) : gDLL->getSymbolID(UNHAPPY_CHAR));
			szBuffer.append(szTempBuffer);
		}
	}

	const BuildingTypes eFreeBuilding = static_cast<BuildingTypes>(kBuilding.getFreeBuilding());
	if (eFreeBuilding != NO_BUILDING)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_FREE_IN_CITY", CvWString(GC.getBuildingInfo(eFreeBuilding).getType()).GetCString(), GC.getBuildingInfo(eFreeBuilding).getTextKeyWide()));
	}

	const BuildingTypes eFreeAreaBuilding = static_cast<BuildingTypes>(kBuilding.getFreeAreaBuilding());
	if (eFreeAreaBuilding != NO_BUILDING)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_FREE_IN_AREA", CvWString(GC.getBuildingInfo(eFreeAreaBuilding).getType()).GetCString(), GC.getBuildingInfo(eFreeAreaBuilding).getTextKeyWide()));
	}

	if (!bRelDisabled)
	{
		PromotionTypes ePromotion = (PromotionTypes)kBuilding.getFreePromotion();
		bool bPromoLine = false;
		if (kBuilding.getFreePromotion() != NO_PROMOTION)
		{
			bFirst = true;
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_FREE_PROMOTION_START", CvWString(GC.getPromotionInfo(ePromotion).getType()).GetCString(), GC.getPromotionInfo(ePromotion).getTextKeyWide()));
			for (int iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
			{
				UnitCombatTypes eUnitCombat = (UnitCombatTypes)iI;
				bPromoLine = false;
				if (GC.getPromotionInfo(ePromotion).getPromotionLine() != NO_PROMOTIONLINE)
				{
					PromotionLineTypes ePromotionLine = GC.getPromotionInfo(ePromotion).getPromotionLine();
					for (int iJ = 0; iJ < GC.getPromotionLineInfo(ePromotionLine).getNumUnitCombatPrereqTypes(); iJ++)
					{
						UnitCombatTypes ePromoLineUnitCombat = (UnitCombatTypes)GC.getPromotionLineInfo(ePromotionLine).getUnitCombatPrereqType(iJ);
						if (ePromoLineUnitCombat == eUnitCombat)
						{
							bPromoLine = true;
							break;
						}
					}
				}
				if (bPromoLine || GC.getPromotionInfo((PromotionTypes)(kBuilding.getFreePromotion())).getUnitCombat(iI))
				{
					szFirstBuffer.clear();
					szTempBuffer.Format(L"<link=%s>%s</link>", CvWString(GC.getUnitCombatInfo(eUnitCombat).getType()).GetCString(), GC.getUnitCombatInfo(eUnitCombat).getDescription());
					setListHelp(szBuffer, szFirstBuffer, szTempBuffer, L", ", bFirst);
					bFirst = false;
				}
			}
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_FREE_PROMOTION_END"));
		}

		ePromotion = (PromotionTypes)kBuilding.getFreePromotion_2();
		bPromoLine = false;
		if (kBuilding.getFreePromotion_2() != NO_PROMOTION)
		{
			bFirst = true;
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_FREE_PROMOTION_START", CvWString(GC.getPromotionInfo(ePromotion).getType()).GetCString(), GC.getPromotionInfo(ePromotion).getTextKeyWide()));
			for (int iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
			{
				UnitCombatTypes eUnitCombat = (UnitCombatTypes)iI;
				bPromoLine = false;
				if (GC.getPromotionInfo(ePromotion).getPromotionLine() != NO_PROMOTIONLINE)
				{
					PromotionLineTypes ePromotionLine = GC.getPromotionInfo(ePromotion).getPromotionLine();
					for (int iJ = 0; iJ < GC.getPromotionLineInfo(ePromotionLine).getNumUnitCombatPrereqTypes(); iJ++)
					{
						UnitCombatTypes ePromoLineUnitCombat = (UnitCombatTypes)GC.getPromotionLineInfo(ePromotionLine).getUnitCombatPrereqType(iJ);
						if (ePromoLineUnitCombat = eUnitCombat)
						{
							bPromoLine = true;
							break;
						}
					}
				}
				if (bPromoLine || GC.getPromotionInfo((PromotionTypes)kBuilding.getFreePromotion_2()).getUnitCombat(iI))
				{
					szFirstBuffer.clear();
					szTempBuffer.Format(L"<link=%s>%s</link>", CvWString(GC.getUnitCombatInfo((UnitCombatTypes)iI).getType()).GetCString(), GC.getUnitCombatInfo((UnitCombatTypes)iI).getDescription());
					setListHelp(szBuffer, szFirstBuffer, szTempBuffer, L", ", bFirst);
					bFirst = false;
				}
			}
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_FREE_PROMOTION_END"));
		}

		ePromotion = (PromotionTypes)kBuilding.getFreePromotion_3();
		bPromoLine = false;
		if (kBuilding.getFreePromotion_3() != NO_PROMOTION)
		{
			bFirst = true;
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_FREE_PROMOTION_START", CvWString(GC.getPromotionInfo(ePromotion).getType()).GetCString(), GC.getPromotionInfo(ePromotion).getTextKeyWide()));
			for (int iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
			{
				UnitCombatTypes eUnitCombat = (UnitCombatTypes)iI;
				bPromoLine = false;
				if (GC.getPromotionInfo(ePromotion).getPromotionLine() != NO_PROMOTIONLINE)
				{
					PromotionLineTypes ePromotionLine = GC.getPromotionInfo(ePromotion).getPromotionLine();
					for (int iJ = 0; iJ < GC.getPromotionLineInfo(ePromotionLine).getNumUnitCombatPrereqTypes(); iJ++)
					{
						UnitCombatTypes ePromoLineUnitCombat = (UnitCombatTypes)GC.getPromotionLineInfo(ePromotionLine).getUnitCombatPrereqType(iJ);
						if (ePromoLineUnitCombat = eUnitCombat)
						{
							bPromoLine = true;
							break;
						}
					}
				}
				if (bPromoLine || GC.getPromotionInfo((PromotionTypes)kBuilding.getFreePromotion_3()).getUnitCombat(iI))
				{
					szFirstBuffer.clear();
					szTempBuffer.Format(L"<link=%s>%s</link>", CvWString(GC.getUnitCombatInfo((UnitCombatTypes)iI).getType()).GetCString(), GC.getUnitCombatInfo((UnitCombatTypes)iI).getDescription());
					setListHelp(szBuffer, szFirstBuffer, szTempBuffer, L", ", bFirst);
					bFirst = false;
				}
			}
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_FREE_PROMOTION_END"));
		}

		buildingHelpTechAndSpecialistModifiers(szBuffer, kBuilding, ePlayer, eTeam);

	}

	if (kBuilding.isProvidesFreshWater())
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_PROVIDES_WATER"));
	}

	if (kBuilding.getWorkableRadius() > 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_EXPANDS_WORKABLE_RADIUS", kBuilding.getWorkableRadius()));
	}

	if (kBuilding.getAdjacentDamagePercent() > 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_DAMAGES_ENEMY_UNITS", kBuilding.getAdjacentDamagePercent()));
	}

	if (kBuilding.getInvasionChance() > 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_INVASION", kBuilding.getInvasionChance()));
	}

	if (kBuilding.isProtectedCulture() && GC.getDefineINT("IDW_ENABLED"))
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_PROTECTS_CULTURE"));
	}

	if (!bRelDisabled)
	{
		if (kBuilding.getOccupationTimeModifier() > 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_OCCUPATION_TIME", kBuilding.getOccupationTimeModifier()));
		}
	}

	if (kBuilding.getNoEntryDefenseLevel() > 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_NO_ENTRY", kBuilding.getNoEntryDefenseLevel()));
	}

	if (!bRelDisabled)
	{
		if (kBuilding.getNumUnitFullHeal() > 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_FULL_HEAL_UNITS", kBuilding.getNumUnitFullHeal()));
		}
	}

	if (GC.getGame().isOption(GAMEOPTION_ZONE_OF_CONTROL) && kBuilding.isZoneOfControl())
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_ZONE_OF_CONTROL"));
	}

	if (kBuilding.isDamageAttackerCapable())
	{
		bFirst = true;
		if (kBuilding.isDamageAllAttackers())
		{
			if (kBuilding.getDamageAttackerChance() > 0 && kBuilding.getDamageToAttacker() > 0)
			{
				if (bFirst)
				{
					bFirst = false;
				}
				if (kBuilding.isDamageToAttackerIgnoresArmor())
				{
					szBuffer.append(NEWLINE);
					szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_DAMAGE_ALL_ATTACKER_ARMOR_EXEMPT", kBuilding.getDamageAttackerChance(), kBuilding.getDamageToAttacker()));
				}
				else
				{
					szBuffer.append(NEWLINE);
					szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_DAMAGE_ALL_ATTACKER", kBuilding.getDamageAttackerChance(), kBuilding.getDamageToAttacker()));
				}
			}
		}
		else
		{
			for (int iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
			{
				UnitCombatTypes eUnitCombat = ((UnitCombatTypes)iI);
				if (kBuilding.isMayDamageAttackingUnitCombatType(eUnitCombat))
				{
					if (kBuilding.getDamageAttackerChance() > 0 && kBuilding.getDamageToAttacker() > 0)
					{
						if (bFirst)
						{
							szBuffer.append(NEWLINE);
							szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_DAMAGE_ATTACKER_START", GC.getUnitCombatInfo(eUnitCombat).getTextKeyWide()));
						}
						else if (!bFirst)
						{
							szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_DAMAGE_ATTACKER_MIDDLE", GC.getUnitCombatInfo(eUnitCombat).getTextKeyWide()));
						}
						bFirst = false;
					}
				}
			}
			if (!bFirst)
			{
				if (kBuilding.isDamageToAttackerIgnoresArmor())
				{
					szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_DAMAGE_ATTACKER_END_ARMOR_EXEMPT", kBuilding.getDamageAttackerChance(), kBuilding.getDamageToAttacker()));
				}
				else
				{
					szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_DAMAGE_ATTACKER_END", kBuilding.getDamageAttackerChance(), kBuilding.getDamageToAttacker()));
				}
			}
		}
	}

	if (kBuilding.getMaxPopulationAllowed() > -1)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_MAX_POPULATION_ALLOWED", kBuilding.getMaxPopulationAllowed()));
	}

	if (kBuilding.getMaxPopulationChange() != 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_MAX_POPULATION_CHANGE", kBuilding.getMaxPopulationChange()));
	}

	if (kBuilding.getPropertySpawnUnit() != NO_UNIT && kBuilding.getPropertySpawnProperty() != NO_PROPERTY)
	{
		if (GC.getPropertyInfo(kBuilding.getPropertySpawnProperty()).getAIWeight() < 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_PROPERTY_SPAWN_BARB", GC.getUnitInfo(kBuilding.getPropertySpawnUnit()).getTextKeyWide()));
		}
		else
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_PROPERTY_SPAWN_FRIENDLY", GC.getUnitInfo(kBuilding.getPropertySpawnUnit()).getTextKeyWide()));
		}
	}

	if (kBuilding.getInsidiousness() != 0)
	{
		szBuffer.append(NEWLINE);
		float fValue = (float)kBuilding.getInsidiousness();
		{
			szTempBuffer.Format(L"%.1f", fValue/10);
		}
		szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_INSIDIOUSNESS", szTempBuffer.GetCString()));
	}

	if (kBuilding.getInvestigation() != 0)
	{
		szBuffer.append(NEWLINE);
		float fValue = (float)kBuilding.getInvestigation();
		{
			szTempBuffer.Format(L"%.1f", fValue/10);
		}
		szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_INVESTIGATION", szTempBuffer.GetCString()));
	}

	int iPopChange = kBuilding.getPopulationChange();
	if (iPopChange != 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_POPULATION_CHANGE", iPopChange));
	}

	int iPopLoss = kBuilding.getOneTimePopulationPercentLoss();
	if (iPopLoss != 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_ONE_TIME_POPULATION_LOSS", iPopLoss));
	}

	if (!bRelDisabled)
	{
		if (kBuilding.getNumPopulationEmployed() > 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_POPULATION_EMPLOYED", kBuilding.getNumPopulationEmployed()));
		}

		if (kBuilding.getHealthPercentPerPopulation() != 0)
		{
			szBuffer.append(NEWLINE);
			int iHealthPercent = kBuilding.getHealthPercentPerPopulation();
			if (iHealthPercent % 100 == 0)
			{
				szTempBuffer = CvWString::format(L"%c%s%d%c%s", gDLL->getSymbolID(BULLET_CHAR),
				iHealthPercent > 0 ? L"+" : L"",
				abs(iHealthPercent / 100),
				(iHealthPercent > 0 ? gDLL->getSymbolID(HEALTHY_CHAR) : gDLL->getSymbolID(UNHEALTHY_CHAR)),
				gDLL->getText("TXT_KEY_MISC_PER_CITIZEN").GetCString());
			}
			else if (iHealthPercent % 10 == 0)
			{
				szTempBuffer = CvWString::format(L"%c%s%.1f%c%s", gDLL->getSymbolID(BULLET_CHAR),
				iHealthPercent > 0 ? L"+" : L"",
				abs(iHealthPercent) * 0.01f,
				(iHealthPercent > 0 ? gDLL->getSymbolID(HEALTHY_CHAR) : gDLL->getSymbolID(UNHEALTHY_CHAR)),
				gDLL->getText("TXT_KEY_MISC_PER_CITIZEN").GetCString());
			}
			else
			{
				szTempBuffer = CvWString::format(L"%c%s%.2f%c%s", gDLL->getSymbolID(BULLET_CHAR),
				iHealthPercent > 0 ? L"+" : L"",
				abs(iHealthPercent) * 0.01f,
				(iHealthPercent > 0 ? gDLL->getSymbolID(HEALTHY_CHAR) : gDLL->getSymbolID(UNHEALTHY_CHAR)),
				gDLL->getText("TXT_KEY_MISC_PER_CITIZEN").GetCString());
			}
			szBuffer.append(szTempBuffer);
		}

		if (kBuilding.getHappinessPercentPerPopulation() != 0)
		{
			szBuffer.append(NEWLINE);
			int iHappinessPercent = kBuilding.getHappinessPercentPerPopulation();
			if (iHappinessPercent % 100 == 0)
			{
				szTempBuffer = CvWString::format(L"%c%s%d%c%s", gDLL->getSymbolID(BULLET_CHAR),
				iHappinessPercent > 0 ? L"+" : L"",
				abs(iHappinessPercent / 100),
				(iHappinessPercent > 0 ? gDLL->getSymbolID(HAPPY_CHAR) : gDLL->getSymbolID(UNHAPPY_CHAR)),
				gDLL->getText("TXT_KEY_MISC_PER_CITIZEN").GetCString());
			}
			else if (iHappinessPercent % 10 == 0)
			{
				szTempBuffer = CvWString::format(L"%c%s%.1f%c%s", gDLL->getSymbolID(BULLET_CHAR),
				iHappinessPercent > 0 ? L"+" : L"",
				abs(iHappinessPercent) * 0.01f,
				(iHappinessPercent > 0 ? gDLL->getSymbolID(HAPPY_CHAR) : gDLL->getSymbolID(UNHAPPY_CHAR)),
				gDLL->getText("TXT_KEY_MISC_PER_CITIZEN").GetCString());
			}
			else
			{
				szTempBuffer = CvWString::format(L"%c%s%.2f%c%s", gDLL->getSymbolID(BULLET_CHAR),
				iHappinessPercent > 0 ? L"+" : L"",
				abs(iHappinessPercent) * 0.01f,
				(iHappinessPercent > 0 ? gDLL->getSymbolID(HAPPY_CHAR) : gDLL->getSymbolID(UNHAPPY_CHAR)),
				gDLL->getText("TXT_KEY_MISC_PER_CITIZEN").GetCString());
			}
			szBuffer.append(szTempBuffer);
		}

		if (bCivilopediaText || GC.getGame().isOption(GAMEOPTION_REVOLUTION))
		{
			if (0 != kBuilding.getRevIdxLocal())
			{
				if ( kBuilding.getRevIdxLocal() > 0 )
				{
					szBuffer.append(NEWLINE);
					szBuffer.append(gDLL->getText("TXT_KEY_CIVIC_REV_INDEX_LOCAL_PENALTY", kBuilding.getRevIdxLocal()));
				}
				else if ( kBuilding.getRevIdxLocal() < 0 )
				{
					szBuffer.append(NEWLINE);
					szBuffer.append(gDLL->getText("TXT_KEY_CIVIC_REV_INDEX_LOCAL_BONUS", abs(kBuilding.getRevIdxLocal())));
				}
			}

			//  Revolution National Civic Index Modifiers
			if (0 != kBuilding.getRevIdxNational())
			{
				if ( kBuilding.getRevIdxNational() > 0 )
				{
					szBuffer.append(NEWLINE);
					szBuffer.append(gDLL->getText("TXT_KEY_CIVIC_REV_INDEX_NATIONAL_PENALTY", kBuilding.getRevIdxNational()));
				}
				else if ( kBuilding.getRevIdxNational() < 0 )
				{
					szBuffer.append(NEWLINE);
					szBuffer.append(gDLL->getText("TXT_KEY_CIVIC_REV_INDEX_NATIONAL_BONUS", abs(kBuilding.getRevIdxNational())));
				}
			}

			if ( kBuilding.getRevIdxDistanceModifier() < 0 )
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_CIVIC_CITY_DISTANCE_GOOD_MOD", kBuilding.getRevIdxDistanceModifier()));
			}
			else if ( kBuilding.getRevIdxDistanceModifier() > 0 )
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_CIVIC_CITY_DISTANCE_BAD_MOD", abs(kBuilding.getRevIdxDistanceModifier())));
			}
		}

		if (kBuilding.getCivicOption() != NO_CIVICOPTION)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_ENABLES_CIVICS", GC.getCivicOptionInfo((CivicOptionTypes)(kBuilding.getCivicOption())).getTextKeyWide()));
		}
	}

	if (kBuilding.getFreeSpecialTech() != NO_TECH)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_FREE_SPECIAL_TECH", CvWString(GC.getTechInfo((kBuilding.getFreeSpecialTech())).getType()).GetCString(), GC.getTechInfo((kBuilding.getFreeSpecialTech())).getTextKeyWide()));
	}

	if (kBuilding.isPower())
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_PROVIDES_POWER"));

		if (kBuilding.isDirtyPower() && (GC.getDefineINT("DIRTY_POWER_HEALTH_CHANGE") != 0))
		{
			szTempBuffer.Format(L" (+%d%c)", abs(GC.getDIRTY_POWER_HEALTH_CHANGE()), ((GC.getDIRTY_POWER_HEALTH_CHANGE() > 0) ? gDLL->getSymbolID(HEALTHY_CHAR): gDLL->getSymbolID(UNHEALTHY_CHAR)));
			szBuffer.append(szTempBuffer);
		}
	}

	if (kBuilding.isAreaCleanPower())
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_PROVIDES_AREA_CLEAN_POWER"));
	}

	if (kBuilding.isAreaBorderObstacle())
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_BORDER_OBSTACLE"));
	}

	for (int iI = 0; iI < GC.getNumVoteSourceInfos(); ++iI)
	{
		if (kBuilding.getVoteSourceType() == (VoteSourceTypes)iI)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_DIPLO_VOTE", GC.getVoteSourceInfo((VoteSourceTypes)iI).getTextKeyWide()));
		}
	}

	if (kBuilding.isForceTeamVoteEligible())
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_ELECTION_ELIGIBILITY"));
	}

	if (kBuilding.isCapital())
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_CAPITAL"));
	}

	if (!bRelDisabled)
	{
		if (kBuilding.isGovernmentCenter())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_REDUCES_MAINTENANCE"));
		}

		if (kBuilding.isGoldenAge())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_GOLDEN_AGE"));
		}
	}

	if (kBuilding.isAllowsNukes())
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROJECT_ENABLES_NUKES"));
	}

	if (kBuilding.isMapCentering())
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_CENTERS_MAP"));
	}

	if (!bRelDisabled)
	{
		if (kBuilding.isNoUnhappiness())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_NO_UNHAPPY"));
		}

		if (kBuilding.isNoUnhealthyPopulation())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_NO_UNHEALTHY_POP"));
		}

		if (kBuilding.isBuildingOnlyHealthy())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_NO_UNHEALTHY_BUILDINGS"));
		}
	}

	if (kBuilding.getGreatPeopleRateModifier() != 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_BIRTH_RATE_MOD", kBuilding.getGreatPeopleRateModifier()));
	}

	if (!bRelDisabled)
	{
		if (kBuilding.getGreatGeneralRateModifier() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_GENERAL_RATE_MOD", kBuilding.getGreatGeneralRateModifier()));
		}

		if (kBuilding.getDomesticGreatGeneralRateModifier() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_DOMESTIC_GREAT_GENERAL_MODIFIER", kBuilding.getDomesticGreatGeneralRateModifier()));
		}
	}

	if (kBuilding.getGlobalGreatPeopleRateModifier() != 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_BIRTH_RATE_MOD_ALL_CITIES", kBuilding.getGlobalGreatPeopleRateModifier()));
	}

	if (!bRelDisabled)
	{
		if (kBuilding.getAnarchyModifier() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_ANARCHY_MOD", kBuilding.getAnarchyModifier()));
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_ANARCHY_TIMER_MOD", kBuilding.getAnarchyModifier()));
		}

		if (kBuilding.getGoldenAgeModifier() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_GOLDENAGE_MOD", kBuilding.getGoldenAgeModifier()));
		}

		if (kBuilding.getGlobalHurryModifier() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_HURRY_MOD", kBuilding.getGlobalHurryModifier()));
		}

		if (kBuilding.getFreeExperience() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_FREE_XP_UNITS", kBuilding.getFreeExperience()));
		}

		if (kBuilding.getGlobalFreeExperience() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_FREE_XP_ALL_CITIES", kBuilding.getGlobalFreeExperience()));
		}

		if (kBuilding.getFoodKept() > 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_STORES_FOOD", kBuilding.getFoodKept()));
		}

		if (kBuilding.getAirlift() > 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_AIRLIFT", kBuilding.getAirlift()));
		}

		if (kBuilding.getAirModifier() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_AIR_DAMAGE_MOD", kBuilding.getAirModifier()));
		}

		if (kBuilding.getAirUnitCapacity() != 0)
		{
			int iTotal = kBuilding.getAirUnitCapacity();
			szBuffer.append(NEWLINE);
			if (GC.getGame().isOption(GAMEOPTION_SIZE_MATTERS))
			{
				iTotal *= GC.getGame().getBaseAirUnitIncrementsbyCargoVolume();
			}
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_AIR_UNIT_CAPACITY", kBuilding.getAirUnitCapacity()));
		}

		if (kBuilding.getNukeModifier() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_NUKE_DAMAGE_MOD", kBuilding.getNukeModifier()));
		}

		int iNukeExplosionRand = kBuilding.getNukeExplosionRand();
		if ( iNukeExplosionRand != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_NUKE_EXPLOSION_CHANCE", iNukeExplosionRand));
		}

		if (kBuilding.getFreeSpecialist() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_FREE_SPECIALISTS", kBuilding.getFreeSpecialist()));
		}

		if (kBuilding.getAreaFreeSpecialist() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_FREE_SPECIALISTS_CONT", kBuilding.getAreaFreeSpecialist()));
		}

		if (kBuilding.getGlobalFreeSpecialist() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_FREE_SPECIALISTS_ALL_CITIES", kBuilding.getGlobalFreeSpecialist()));
		}

		if (kBuilding.getMaintenanceModifier() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_MAINT_MOD", kBuilding.getMaintenanceModifier()));
		}
		//DPII < Maintenance Modifiers >
		if (kBuilding.getGlobalMaintenanceModifier() != 0)
		{
			if (kBuilding.getGlobalMaintenanceModifier() <= -100)
			{
				szBuffer.append(NEWLINE);
			   szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_GLOBAL_MAINT"));
			}
			else
			{
				szBuffer.append(NEWLINE);
			   szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_GLOBAL_MAINT_MOD", kBuilding.getGlobalMaintenanceModifier()));
			}
		}

		if (kBuilding.getDistanceMaintenanceModifier() != 0)
		{
			if (kBuilding.getDistanceMaintenanceModifier() <= -100)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_DISTANCE_MAINT"));
			}
			else
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_DISTANCE_MAINT_MOD", kBuilding.getDistanceMaintenanceModifier()));
			}
		}

		if (kBuilding.getNumCitiesMaintenanceModifier() != 0)
		{
			if (kBuilding.getNumCitiesMaintenanceModifier() <= -100)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_NO_MAINT_NUM_CITIES"));
			}
			else
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_NO_MAINT_NUM_CITIES_MOD", kBuilding.getNumCitiesMaintenanceModifier()));
			}
		}

		if (kBuilding.getCoastalDistanceMaintenanceModifier() != 0)
		{
			if (kBuilding.getCoastalDistanceMaintenanceModifier() <= -100)
			{
				szBuffer.append(NEWLINE);
			   szBuffer.append(gDLL->getText("TXT_KEY_COASTAL_DISTANCE_MAINT"));
			}
			else
			{
				szBuffer.append(NEWLINE);
			   szBuffer.append(gDLL->getText("TXT_KEY_COASTAL_DISTANCE_MAINT_MOD", kBuilding.getCoastalDistanceMaintenanceModifier()));
			}
		}

		if (kBuilding.getConnectedCityMaintenanceModifier() != 0)
		{
			if (kBuilding.getConnectedCityMaintenanceModifier() <= -100)
			{
				szBuffer.append(NEWLINE);
			   szBuffer.append(gDLL->getText("TXT_KEY_CONNECTED_CITY_MAINT"));
			}
			else
			{
				szBuffer.append(NEWLINE);
			   szBuffer.append(gDLL->getText("TXT_KEY_CONNECTED_CITY_MAINT_MOD", kBuilding.getConnectedCityMaintenanceModifier()));
			}
		}

		if (kBuilding.getAreaMaintenanceModifier() != 0)
		{
			if (kBuilding.getAreaMaintenanceModifier() <= -100)
			{
				szBuffer.append(NEWLINE);
			   szBuffer.append(gDLL->getText("TXT_KEY_CONTINENTAL_CITY_MAINT"));
			}
			else
			{
				szBuffer.append(NEWLINE);
			   szBuffer.append(gDLL->getText("TXT_KEY_CONTINENTAL_CITY_MAINT_MOD", kBuilding.getAreaMaintenanceModifier()));
			}
		}

		if (kBuilding.getOtherAreaMaintenanceModifier() != 0)
		{
			if (kBuilding.getOtherAreaMaintenanceModifier() <= -100)
			{
				szBuffer.append(NEWLINE);
			   szBuffer.append(gDLL->getText("TXT_KEY_OVERSEAS_CITY_MAINT"));
			}
			else
			{
				szBuffer.append(NEWLINE);
			   szBuffer.append(gDLL->getText("TXT_KEY_OVERSEAS_CITY_MAINT_MOD", kBuilding.getOtherAreaMaintenanceModifier()));
			}
		}
		//DPII < Maintenance Modifiers >
		if (kBuilding.getHurryAngerModifier() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_HURRY_ANGER_MOD", kBuilding.getHurryAngerModifier()));
		}
	}
	if (kBuilding.getLineOfSight() > 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_INCREASES_LINE_OF_SIGHT"));
	}
	else if (kBuilding.getLineOfSight() < 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_DECREASES_LINE_OF_SIGHT"));
	}

	if (!bRelDisabled)
	{
		if (kBuilding.getInflationModifier() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_ADJUSTS_INFLATION", kBuilding.getInflationModifier()));
		}

		if (kBuilding.getWarWearinessModifier() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_WAR_WEAR_MOD", kBuilding.getWarWearinessModifier()));
		}

		if (kBuilding.getGlobalWarWearinessModifier() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_WAR_WEAR_MOD_ALL_CITIES", kBuilding.getGlobalWarWearinessModifier()));
		}

		if (kBuilding.getEnemyWarWearinessModifier() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_ENEMY_WAR_WEAR", kBuilding.getEnemyWarWearinessModifier()));
		}

		if (kBuilding.getHealRateChange() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_HEAL_MOD", kBuilding.getHealRateChange()));
		}

		if (kBuilding.getNumHealUnitCombatTypes() > 0)
		{
			for (int iI = 0; iI < kBuilding.getNumHealUnitCombatTypes(); iI++)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_HEAL_UNITCOMBAT_MOD", GC.getUnitCombatInfo(kBuilding.getHealUnitCombatType(iI).eUnitCombat).getTextKeyWide(), kBuilding.getHealUnitCombatType(iI).iHeal));
			}
		}

		if (kBuilding.getAreaHealth() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_HEALTH_CHANGE_CONT", abs(kBuilding.getAreaHealth()), ((kBuilding.getAreaHealth() > 0) ? gDLL->getSymbolID(HEALTHY_CHAR): gDLL->getSymbolID(UNHEALTHY_CHAR))));
		}

		if (kBuilding.getGlobalHealth() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_HEALTH_CHANGE_ALL_CITIES", abs(kBuilding.getGlobalHealth()), ((kBuilding.getGlobalHealth() > 0) ? gDLL->getSymbolID(HEALTHY_CHAR): gDLL->getSymbolID(UNHEALTHY_CHAR))));
		}

		// Use absolute value with unhappy face
		if (kBuilding.getAreaHappiness() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_HAPPY_CHANGE_CONT", abs(kBuilding.getAreaHappiness()), ((kBuilding.getAreaHappiness() > 0) ? gDLL->getSymbolID(HAPPY_CHAR) : gDLL->getSymbolID(UNHAPPY_CHAR))));
		}

		if (kBuilding.getGlobalHappiness() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_HAPPY_CHANGE_ALL_CITIES", abs(kBuilding.getGlobalHappiness()), ((kBuilding.getGlobalHappiness() > 0) ? gDLL->getSymbolID(HAPPY_CHAR) : gDLL->getSymbolID(UNHAPPY_CHAR))));
		}

		if (kBuilding.getStateReligionHappiness() != 0)
		{
			if (kBuilding.getReligionType() != NO_RELIGION)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_RELIGION_HAPPINESS", abs(kBuilding.getStateReligionHappiness()), ((kBuilding.getStateReligionHappiness() > 0) ? gDLL->getSymbolID(HAPPY_CHAR) : gDLL->getSymbolID(UNHAPPY_CHAR)), GC.getReligionInfo((ReligionTypes)(kBuilding.getReligionType())).getChar()));
			}
		}

		if (kBuilding.getWorkerSpeedModifier() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_WORKER_MOD", kBuilding.getWorkerSpeedModifier()));
		}

		if (kBuilding.getMilitaryProductionModifier() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_MILITARY_MOD", kBuilding.getMilitaryProductionModifier()));
		}

		if (kBuilding.getSpaceProductionModifier() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_SPACESHIP_MOD", kBuilding.getSpaceProductionModifier()));
		}

		if (kBuilding.getGlobalSpaceProductionModifier() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_SPACESHIP_MOD_ALL_CITIES", kBuilding.getGlobalSpaceProductionModifier()));
		}

		if (kBuilding.getTradeRoutes() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_TRADE_ROUTES", kBuilding.getTradeRoutes()));
		}

		if (kBuilding.getCoastalTradeRoutes() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_COASTAL_TRADE_ROUTES", kBuilding.getCoastalTradeRoutes()));
		}

		if (kBuilding.getGlobalTradeRoutes() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_TRADE_ROUTES_ALL_CITIES", kBuilding.getGlobalTradeRoutes()));
		}

		if (kBuilding.getTradeRouteModifier() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_TRADE_ROUTE_MOD", kBuilding.getTradeRouteModifier()));
		}

		if (kBuilding.getForeignTradeRouteModifier() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_FOREIGN_TRADE_ROUTE_MOD", kBuilding.getForeignTradeRouteModifier()));
		}

		if (kBuilding.getGlobalPopulationChange() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_GLOBAL_POP", kBuilding.getGlobalPopulationChange()));
		}
	}

	if (kBuilding.getFreeTechs() != 0)
	{
		if (kBuilding.getFreeTechs() == 1)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_FREE_TECH"));
		}
		else
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_FREE_TECHS", kBuilding.getFreeTechs()));
		}
	}

	if (kBuilding.getDefenseModifier() != 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_DEFENSE_MOD", kBuilding.getDefenseModifier()));
	}

	if (kBuilding.getBombardDefenseModifier() != 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_BOMBARD_DEFENSE_MOD", -kBuilding.getBombardDefenseModifier()));
	}

	if (!bRelDisabled)
	{
		if (kBuilding.getAllCityDefenseModifier() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_DEFENSE_MOD_ALL_CITIES", kBuilding.getAllCityDefenseModifier()));
		}

		if (kBuilding.getEspionageDefenseModifier() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_ESPIONAGE_DEFENSE_MOD", kBuilding.getEspionageDefenseModifier()));

			if (kBuilding.getEspionageDefenseModifier() > 0)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_UNIT_EXPOSE_SPIES"));
			}
		}

		//TB Combat Mod (Buildings) begin
		for (int iI = 0; iI < kBuilding.getNumAidRateChanges(); iI++)
		{
			PropertyTypes eProperty = kBuilding.getAidRateChange(iI).ePropertyType;
			int iChange = kBuilding.getAidRateChange(iI).iChange;
			if (iChange != 0)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_AID_RATE", iChange, GC.getPropertyInfo(eProperty).getDescription()));
			}
		}
	}

	if (kBuilding.getTradeCommunicability() > 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_TRADE_COMMUNICABILITY_ADDED", kBuilding.getTradeCommunicability()));
	}

	if (kBuilding.getTradeCommunicability() < 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_TRADE_COMMUNICABILITY_REDUCED", kBuilding.getTradeCommunicability()));
	}

	if (kBuilding.getPromotionLineType() != NO_PROMOTIONLINE)
	{
		PromotionLineTypes eDiseaseLine = kBuilding.getPromotionLineType();
		if (GC.getPromotionLineInfo(eDiseaseLine).isAffliction())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_DISEASE_TYPE", GC.getPromotionLineInfo(eDiseaseLine).getDescription()));
		}
	}

	for (int iI = 0; iI < kBuilding.getNumBonusAidModifiers(); iI++)
	{
		int iBonusAidModifier = kBuilding.getBonusAidModifier(iI).iModifier;
		if (iBonusAidModifier != 0)
		{
			BonusTypes eBonus = kBuilding.getBonusAidModifier(iI).eBonusType;
			PropertyTypes eProperty = kBuilding.getBonusAidModifier(iI).ePropertyType;
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_BONUS_AID_MODIFIER", GC.getBonusInfo(eBonus).getDescription(), iBonusAidModifier, GC.getPropertyInfo(eProperty).getDescription()));
		}
	}

	for (int iI = 0; iI < GC.getNumPromotionLineInfos(); iI++)
	{
		if (kBuilding.getAfflictionOutbreakLevelChange(iI) != 0)
		{
			PromotionLineTypes eAfflictionLine = ((PromotionLineTypes)iI);
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_AFFLICTION_OUTBREAK_LEVEL_CHANGE", GC.getPromotionLineInfo(eAfflictionLine).getDescription(), kBuilding.getAfflictionOutbreakLevelChange(iI)));
		}
	}

	for (int iI = 0; iI < GC.getNumTechInfos(); iI++)
	{
		if (kBuilding.getTechOutbreakLevelChange(iI) != 0)
		{
			TechTypes eTech = ((TechTypes)iI);
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_TECH_OUTBREAK_LEVEL_CHANGE", GC.getTechInfo(eTech).getDescription(), kBuilding.getTechOutbreakLevelChange(iI)));
		}
	}

	for (int iI = 0; iI < kBuilding.getNumFreeTraitTypes(); iI++)
	{
		TraitTypes eTrait = (TraitTypes) kBuilding.getFreeTraitType(iI);
		if (GC.getTraitInfo(eTrait).isCivilizationTrait())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_FREE_TRAIT", GC.getTraitInfo(eTrait).getDescription()));
		}
	}


	if (!bRelDisabled)
	{
		for (int iI = 0; iI < kBuilding.getNumFreePromoTypes(); iI++)
		{
			BoolExpr* pExpr = kBuilding.getFreePromoType(iI).m_pExprFreePromotionCondition;
			if (pExpr)
			{
				const PromotionTypes ePromo = (PromotionTypes) kBuilding.getFreePromoType(iI).ePromotion;
				szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_FREE_PROMO_CONDITION", CvWString(GC.getPromotionInfo(ePromo).getType()).GetCString(), GC.getPromotionInfo(ePromo).getTextKeyWide()));
				szBuffer.append(" (");
				szBuffer.append(gDLL->getText("TXT_KEY_UNIT_REQUIRES"));
				pExpr->buildDisplayString(szBuffer);
				szBuffer.append(gDLL->getText("TXT_KEY_REVERT_COLOR"));
				szBuffer.append(")");
			}
			//if (GC.getBuildingInfo(eBuilding).isFreePromoType(iI))
			//{
			//	bFirst = true;
			//	szBuffer.append(NEWLINE);
			//	szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_FREE_PROMOTION_START", CvWString(GC.getPromotionInfo((PromotionTypes)kBuilding.getFreePromoType(iI)).getType()).GetCString(), GC.getPromotionInfo((PromotionTypes)kBuilding.getFreePromoType(iI)).getTextKeyWide()));
			//	for (int iJ = 0; iJ < GC.getNumUnitCombatInfos(); iJ++)
			//	{
			//		if (GC.getPromotionInfo((PromotionTypes)kBuilding.getFreePromoType(iI)).getUnitCombat(iJ))
			//		{
			//			szFirstBuffer.clear();
			//			szTempBuffer.Format(L"<link=%s>%s</link>", CvWString(GC.getUnitCombatInfo((UnitCombatTypes)iJ).getType()).GetCString(), GC.getUnitCombatInfo((UnitCombatTypes)iJ).getDescription());
			//			setListHelp(szBuffer, szFirstBuffer, szTempBuffer, L", ", bFirst);
			//			bFirst = false;
			//		}
			//	}
			//	szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_FREE_PROMOTION_END"));
			//}
		}

		if (kBuilding.getNumUnitCombatProdModifiers() > 0)
		{
			for (int iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
			{
				if (kBuilding.getUnitCombatProdModifier(iI) > 0)
				{
					UnitCombatTypes eCombat = ((UnitCombatTypes)iI);
					szBuffer.append(NEWLINE);
					szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_UNIT_COMBAT_PROD_POSITIVE_MODIFIER", GC.getUnitCombatInfo(eCombat).getDescription(), kBuilding.getUnitCombatProdModifier(iI)));
				}
				if (kBuilding.getUnitCombatProdModifier(iI) < 0)
				{
					UnitCombatTypes eCombat = ((UnitCombatTypes)iI);
					szBuffer.append(NEWLINE);
					szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_UNIT_COMBAT_PROD_NEGATIVE_MODIFIER", GC.getUnitCombatInfo(eCombat).getDescription(), kBuilding.getUnitCombatProdModifier(iI)));
				}
			}
		}
	}

	if (kBuilding.getNumUnitCombatRepelModifiers() > 0)
	{
		for (int iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
		{
			if (kBuilding.getUnitCombatRepelModifier(iI) != 0)
			{
				UnitCombatTypes eCombat = ((UnitCombatTypes)iI);
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_UNIT_COMBAT_REPEL_MODIFIER", kBuilding.getUnitCombatRepelModifier(iI), GC.getUnitCombatInfo(eCombat).getDescription()));
			}
		}
	}

	if (kBuilding.getNumUnitCombatRepelAgainstModifiers() > 0)
	{
		for (int iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
		{
			if (kBuilding.getUnitCombatRepelAgainstModifier(iI) != 0)
			{
				UnitCombatTypes eCombat = ((UnitCombatTypes)iI);
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_UNIT_COMBAT_REPEL_AGAINST_MODIFIER", kBuilding.getUnitCombatRepelAgainstModifier(iI), GC.getUnitCombatInfo(eCombat).getDescription()));
			}
		}
	}

	if (kBuilding.getNumUnitCombatDefenseAgainstModifiers() > 0)
	{
		for (int iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
		{
			if (kBuilding.getUnitCombatDefenseAgainstModifier(iI) != 0)
			{
				UnitCombatTypes eCombat = ((UnitCombatTypes)iI);
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_UNIT_COMBAT_DEFENSE_AGAINST_MODIFIER", kBuilding.getUnitCombatDefenseAgainstModifier(iI), GC.getUnitCombatInfo(eCombat).getDescription()));
			}
		}
	}

	if (GC.getGame().isOption(GAMEOPTION_STRENGTH_IN_NUMBERS))
	{
		if (kBuilding.getFrontSupportPercentModifier() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_FRONT_SUPPORT_PERCENT_MODIFIER", kBuilding.getFrontSupportPercentModifier()));
		}

		if (kBuilding.getShortRangeSupportPercentModifier() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_SHORT_RANGE_SUPPORT_PERCENT_MODIFIER", kBuilding.getShortRangeSupportPercentModifier()));
		}

		if (kBuilding.getMediumRangeSupportPercentModifier() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_MEDIUM_RANGE_SUPPORT_PERCENT_MODIFIER", kBuilding.getMediumRangeSupportPercentModifier()));
		}

		if (kBuilding.getLongRangeSupportPercentModifier() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_LONG_RANGE_SUPPORT_PERCENT_MODIFIER", kBuilding.getLongRangeSupportPercentModifier()));
		}

		if (kBuilding.getFlankSupportPercentModifier() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_FLANK_SUPPORT_PERCENT_MODIFIER", kBuilding.getFlankSupportPercentModifier()));
		}
	}

	if (!bRelDisabled)
	{
		for (int iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
		{
			if (kBuilding.getUnitCombatOngoingTrainingDuration(iI) > 0)
			{
				UnitCombatTypes eCombat = ((UnitCombatTypes)iI);
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_UNIT_COMBAT_ONGOING_TRAINING_DURATION", GC.getUnitCombatInfo(eCombat).getDescription(), kBuilding.getUnitCombatOngoingTrainingDuration(iI)));
			}
		}
		//TB Combat Mod (Buildings) end

		setYieldChangeHelp(szBuffer, gDLL->getText("TXT_KEY_BUILDING_WATER_PLOTS").c_str(), L": ", L"", kBuilding.getSeaPlotYieldChangeArray());

		setYieldChangeHelp(szBuffer, gDLL->getText("TXT_KEY_BUILDING_RIVER_PLOTS").c_str(), L": ", L"", kBuilding.getRiverPlotYieldChangeArray());

		setYieldChangeHelp(szBuffer, gDLL->getText("TXT_KEY_BUILDING_WATER_PLOTS_ALL_CITIES").c_str(), L": ", L"", kBuilding.getGlobalSeaPlotYieldChangeArray());

		setYieldChangeHelp(szBuffer, L"", L"", gDLL->getText("TXT_KEY_BUILDING_WITH_POWER").c_str(), kBuilding.getPowerYieldModifierArray(), true, true);

		setYieldChangeHelp(szBuffer, L"", L"", gDLL->getText("TXT_KEY_BUILDING_ALL_CITIES_THIS_CONTINENT").c_str(), kBuilding.getAreaYieldModifierArray(), true, true);

		setYieldChangeHelp(szBuffer, L"", L"", gDLL->getText("TXT_KEY_BUILDING_ALL_CITIES").c_str(), kBuilding.getGlobalYieldModifierArray(), true, true);

		setCommerceChangeHelp(szBuffer, L"", L"", gDLL->getText("TXT_KEY_BUILDING_ALL_CITIES").c_str(), kBuilding.getGlobalCommerceModifierArray(), true);

		setCommerceChangeHelp(szBuffer, L"", L"", gDLL->getText("TXT_KEY_BUILDING_PER_SPECIALIST_ALL_CITIES").c_str(), kBuilding.getSpecialistExtraCommerceArray());

		if (ePlayer != NO_PLAYER && GET_PLAYER(ePlayer).getStateReligion() != NO_RELIGION)
		{
			szTempBuffer = gDLL->getText("TXT_KEY_BUILDING_FROM_ALL_REL_BUILDINGS", GC.getReligionInfo(GET_PLAYER(ePlayer).getStateReligion()).getChar());
		}
		else
		{
			szTempBuffer = gDLL->getText("TXT_KEY_BUILDING_STATE_REL_BUILDINGS");
		}
		setCommerceChangeHelp(szBuffer, L"", L"", szTempBuffer, kBuilding.getStateReligionCommerceArray());

		for (int iI = 0; iI < NUM_COMMERCE_TYPES; ++iI)
		{
			if (kBuilding.getCommerceHappiness(iI) != 0)
			{
				szBuffer.append(NEWLINE);
				// Use absolute value with unhappy face
				szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_PER_LEVEL", ((kBuilding.getCommerceHappiness(iI) > 0) ? gDLL->getSymbolID(HAPPY_CHAR) : gDLL->getSymbolID(UNHAPPY_CHAR)), abs(100 / kBuilding.getCommerceHappiness(iI)), GC.getCommerceInfo((CommerceTypes)iI).getChar()));
			}

			if (kBuilding.isCommerceFlexible(iI) != 0)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_ADJUST_COMM_RATE", GC.getCommerceInfo((CommerceTypes) iI).getChar()));
			}
		}
		if (kBuilding.m_bAnySpecialistYieldChanges)
		{
			bFirst = true;
			for (int iI = 0; iI < GC.getNumSpecialistInfos(); ++iI)
			{
				if (kBuilding.getSpecialistYieldChangeArray(iI) != NULL )
				{
					if (!bFirst)
					{
						szBuffer.append(gDLL->getText("TXT_KEY_COMMA"));
					}
					if (bFirst)
					{
						szBuffer.append(NEWLINE);
						szBuffer.append(gDLL->getSymbolID(BULLET_CHAR));
						bFirst = false;
					}
					szFirstBuffer = gDLL->getText("TXT_KEY_BUILDING_FROM_IN_ALL_CITIES", CvWString(GC.getSpecialistInfo((SpecialistTypes) iI).getType()).GetCString(), GC.getSpecialistInfo((SpecialistTypes) iI).getTextKeyWide());
					setYieldChangeHelp(szBuffer, L"", L"", szFirstBuffer, kBuilding.getSpecialistYieldChangeArray(iI), false, false);
				}
			}
		}
		if (kBuilding.m_bAnySpecialistCommerceChanges)
		{
			bFirst = true;
			for (int iI = 0; iI < GC.getNumSpecialistInfos(); ++iI)
			{
				if (kBuilding.getSpecialistCommerceChangeArray(iI) != NULL )
				{
					if (!bFirst)
					{
						szBuffer.append(gDLL->getText("TXT_KEY_COMMA"));
					}
					if (bFirst)
					{
						szBuffer.append(NEWLINE);
						szBuffer.append(gDLL->getSymbolID(BULLET_CHAR));
						bFirst = false;
					}
					szFirstBuffer = gDLL->getText("TXT_KEY_BUILDING_FROM_IN_ALL_CITIES", CvWString(GC.getSpecialistInfo((SpecialistTypes) iI).getType()).GetCString(), GC.getSpecialistInfo((SpecialistTypes) iI).getTextKeyWide());
					setCommerceChangeHelp(szBuffer, L"", L"", szFirstBuffer, kBuilding.getSpecialistCommerceChangeArray(iI), false, false);
				}
			}
		}

		if (kBuilding.m_bAnyLocalSpecialistYieldChanges)
		{
			bFirst = true;
			for (int iI = 0; iI < GC.getNumSpecialistInfos(); ++iI)
			{
				if (kBuilding.getLocalSpecialistYieldChangeArray(iI) != NULL )
				{
					if (!bFirst)
					{
						szBuffer.append(gDLL->getText("TXT_KEY_COMMA"));
					}
					if (bFirst)
					{
						szBuffer.append(NEWLINE);
						szBuffer.append(gDLL->getSymbolID(BULLET_CHAR));
						bFirst = false;
					}
					szFirstBuffer = gDLL->getText("TXT_KEY_BUILDING_FROM_SPECIALIST", CvWString(GC.getSpecialistInfo((SpecialistTypes) iI).getType()).GetCString(), GC.getSpecialistInfo((SpecialistTypes) iI).getTextKeyWide());
					setYieldChangeHelp(szBuffer, L"", L"", szFirstBuffer, kBuilding.getLocalSpecialistYieldChangeArray(iI), false, false);
				}
			}
		}
		if (kBuilding.m_bAnyLocalSpecialistCommerceChanges)
		{
			bFirst = true;
			for (int iI = 0; iI < GC.getNumSpecialistInfos(); ++iI)
			{
				if (kBuilding.getLocalSpecialistCommerceChangeArray(iI) != NULL )
				{
					if (!bFirst)
					{
						szBuffer.append(gDLL->getText("TXT_KEY_COMMA"));
					}
					if (bFirst)
					{
						szBuffer.append(NEWLINE);
						szBuffer.append(gDLL->getSymbolID(BULLET_CHAR));
						bFirst = false;
					}
					szFirstBuffer = gDLL->getText("TXT_KEY_BUILDING_FROM_SPECIALIST", CvWString(GC.getSpecialistInfo((SpecialistTypes) iI).getType()).GetCString(), GC.getSpecialistInfo((SpecialistTypes) iI).getTextKeyWide());
					setCommerceChangeHelp(szBuffer, L"", L"", szFirstBuffer, kBuilding.getLocalSpecialistCommerceChangeArray(iI), false, false);
				}
			}
		}

		//TB TESTING to see if we can't change the new line bool so that it doesn't display each one individually - this will impact the long Taxidermy building's list.

		if (kBuilding.m_bAnyBonusYieldModifiers)
		{
			bFirst = true;
			for (int iI = 0; iI < GC.getNumBonusInfos(); ++iI)
			{
				if (kBuilding.getBonusYieldModifierArray(iI) != NULL )
				{
					if (!bFirst)
					{
						szBuffer.append(gDLL->getText("TXT_KEY_COMMA"));
					}
					if (bFirst)
					{
						szBuffer.append(NEWLINE);
						szBuffer.append(gDLL->getSymbolID(BULLET_CHAR));
						bFirst = false;
					}
					szFirstBuffer = gDLL->getText("TXT_KEY_BUILDING_WITH_BONUS", CvWString(GC.getBonusInfo((BonusTypes) iI).getType()).GetCString(), GC.getBonusInfo((BonusTypes) iI).getTextKeyWide());
					setYieldChangeHelp(szBuffer, L"", L"", szFirstBuffer, kBuilding.getBonusYieldModifierArray(iI), true, false);
				}
			}
		}

		if (kBuilding.m_bAnyBonusCommerceModifiers)
		{
			bFirst = true;
			for (int iI = 0; iI < GC.getNumBonusInfos(); ++iI)
			{
				if (kBuilding.getBonusCommerceModifierArray(iI) != NULL )
				{
					if (!bFirst)
					{
						szBuffer.append(gDLL->getText("TXT_KEY_COMMA"));
					}
					if (bFirst)
					{
						szBuffer.append(NEWLINE);
						szBuffer.append(gDLL->getSymbolID(BULLET_CHAR));
						bFirst = false;
					}
					szFirstBuffer = gDLL->getText("TXT_KEY_BUILDING_WITH_BONUS", CvWString(GC.getBonusInfo((BonusTypes) iI).getType()).GetCString(), GC.getBonusInfo((BonusTypes) iI).getTextKeyWide());
					setCommerceChangeHelp(szBuffer, L"", L"", szFirstBuffer, kBuilding.getBonusCommerceModifierArray(iI), true, false);
				}
			}
		}

		iLast = 0;
		if (kBuilding.m_bAnyVicinityBonusYieldChanges)
		{
			bFirst = true;
			for (int iI = 0; iI < GC.getNumBonusInfos(); ++iI)
			{
				if (kBuilding.getVicinityBonusYieldChangesArray(iI) != NULL )
				{
					if (!bFirst)
					{
						szBuffer.append(gDLL->getText("TXT_KEY_COMMA"));
					}
					if (bFirst)
					{
						szBuffer.append(NEWLINE);
						szBuffer.append(gDLL->getSymbolID(BULLET_CHAR));
						bFirst = false;
					}
					szFirstBuffer = gDLL->getText("TXT_KEY_BUILDING_WITH_BONUS", CvWString(GC.getBonusInfo((BonusTypes) iI).getType()).GetCString(), GC.getBonusInfo((BonusTypes) iI).getTextKeyWide());
					szFirstBuffer += gDLL->getText("TXT_KEY_IN_CITY_VICINITY");
					setYieldChangeHelp(szBuffer, L"", L"", szFirstBuffer, kBuilding.getVicinityBonusYieldChangesArray(iI), false, false);
				}
			}
		}

		iLast = 0;
		if (kBuilding.m_bAnyBonusYieldChanges)
		{
			bFirst = true;
			for (int iI = 0; iI < GC.getNumBonusInfos(); ++iI)
			{
				if (kBuilding.getBonusYieldChangesArray(iI) != NULL )
				{
					if (!bFirst)
					{
						szBuffer.append(gDLL->getText("TXT_KEY_COMMA"));
					}
					if (bFirst)
					{
						szBuffer.append(NEWLINE);
						szBuffer.append(gDLL->getSymbolID(BULLET_CHAR));
						bFirst = false;
					}
					szFirstBuffer = gDLL->getText("TXT_KEY_BUILDING_WITH_BONUS", CvWString(GC.getBonusInfo((BonusTypes) iI).getType()).GetCString(), GC.getBonusInfo((BonusTypes) iI).getTextKeyWide());
					setYieldChangeHelp(szBuffer, L"", L"", szFirstBuffer, kBuilding.getBonusYieldChangesArray(iI), false, false);
				}
			}
		}

		iLast = 0;

		if (kBuilding.m_bAnyBonusCommercePercentChanges)
		{
			bool* pabProcessed = new bool[GC.getNumBonusInfos()];
			for (int iI = 0; iI < GC.getNumBonusInfos(); ++iI)
			{
				pabProcessed[iI] = false;
			}
			for (int iI = 0; iI < GC.getNumBonusInfos(); ++iI)
			{
				CvWString szTempBuffer;
				CvWString szTempBuffer2;
				for (int iJ = 0; iJ < NUM_COMMERCE_TYPES; ++iJ)
				{
					if (kBuilding.getBonusCommercePercentChanges(iI, iJ) != 0 && !pabProcessed[iI])
					{
						float fValue = (float)kBuilding.getBonusCommercePercentChanges(iI, iJ);
						if (fmod(fValue,100) == 0)
						{
							if (fValue > 0)
							{
								szTempBuffer2.Format(L"+%.0f", fValue/100);
							}
							else
							{
								szTempBuffer2.Format(L"%.0f", fValue/100);
							}
						}
						else
						{
							if (fValue > 0)
							{
								szTempBuffer2.Format(L"+%.2f", fValue/100);
							}
							else
							{
								szTempBuffer2.Format(L"%.2f", fValue/100);
							}
						}

						szTempBuffer.Format(L"\n%c%s%c%s", gDLL->getSymbolID(BULLET_CHAR), szTempBuffer2.GetCString(), GC.getCommerceInfo((CommerceTypes) iJ).getChar(), gDLL->getText("TXT_KEY_WITH").GetCString());
						szTempBuffer += CvWString::format(L"<link=%s>%s</link>", CvWString(GC.getBonusInfo((BonusTypes)iI).getType()).GetCString(), GC.getBonusInfo((BonusTypes)iI).getDescription());

						for (int iK = 0; iK < GC.getNumBonusInfos(); ++iK)
						{
							if (iK != iI && kBuilding.getBonusCommercePercentChanges(iI, iJ) == kBuilding.getBonusCommercePercentChanges(iK, iJ))
							{
								szTempBuffer += CvWString::format(L", <link=%s>%s</link>", CvWString(GC.getBonusInfo((BonusTypes)iK).getType()).GetCString(), GC.getBonusInfo((BonusTypes)iK).getDescription());
								pabProcessed[iK] = true;
							}
						}
						pabProcessed[iI] = true;
						iLast = kBuilding.getBonusCommercePercentChanges(iI, iJ);
						szBuffer.append(szTempBuffer);
					}
				}
			}
			SAFE_DELETE_ARRAY(pabProcessed);
		}

		for (int iI = 0; iI < NUM_COMMERCE_TYPES; iI++)
		{
			if (kBuilding.getCommerceAttacks(iI) > 0)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_FROM_ATTACKS", GC.getCommerceInfo((CommerceTypes) iI).getChar(), kBuilding.getCommerceAttacks(iI), GC.getCommerceInfo((CommerceTypes) iI).getChar(), GC.getCommerceInfo((CommerceTypes) iI).getChar(), GC.getDefineINT("COMMERCE_ATTACKS_FADE_RATE")));
			}
		}

		for (int iI = 0; iI < GC.getNumReligionInfos(); ++iI)
		{
			if (kBuilding.getReligionChange(iI) > 0)
			{
				szTempBuffer.Format(L"%s%s", NEWLINE, gDLL->getText("TXT_KEY_BUILDING_SPREADS_RELIGION", GC.getReligionInfo((ReligionTypes) iI).getChar()).c_str());
				szBuffer.append(szTempBuffer);
			}
		}

		for (int iI = 0; iI < GC.getNumSpecialistInfos(); ++iI)
		{
			if (kBuilding.getSpecialistCount(iI) > 0)
			{
				if (kBuilding.getSpecialistCount(iI) == 1)
				{
					szBuffer.append(NEWLINE);
					szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_TURN_CITIZEN_INTO", CvWString(GC.getSpecialistInfo((SpecialistTypes) iI).getType()).GetCString(), GC.getSpecialistInfo((SpecialistTypes) iI).getTextKeyWide()));
				}
				else
				{
					szBuffer.append(NEWLINE);
					szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_TURN_CITIZENS_INTO", kBuilding.getSpecialistCount(iI), CvWString(GC.getSpecialistInfo((SpecialistTypes) iI).getType()).GetCString(), GC.getSpecialistInfo((SpecialistTypes) iI).getTextKeyWide()));
				}
			}

			if (kBuilding.getFreeSpecialistCount(iI) > 0)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_FREE_SPECIALIST", kBuilding.getFreeSpecialistCount(iI), CvWString(GC.getSpecialistInfo((SpecialistTypes) iI).getType()).GetCString(), GC.getSpecialistInfo((SpecialistTypes) iI).getTextKeyWide()));
			}
		}

		iLast = 0;

		for (int iI = 0; iI < GC.getNumImprovementInfos(); ++iI)
		{
			if (kBuilding.getImprovementFreeSpecialist(iI) > 0)
			{
				szFirstBuffer.Format(L"%s%s", NEWLINE, gDLL->getText("TXT_KEY_BUILDING_IMPROVEMENT_FREE_SPECIALISTS", kBuilding.getImprovementFreeSpecialist(iI)).GetCString() );
				szTempBuffer.Format(L"<link=%s>%s</link>", CvWString(GC.getImprovementInfo((ImprovementTypes)iI).getType()).GetCString(), GC.getImprovementInfo((ImprovementTypes)iI).getDescription());
				setListHelp(szBuffer, szFirstBuffer, szTempBuffer, L", ", (kBuilding.getImprovementFreeSpecialist(iI) != iLast));
				iLast = kBuilding.getImprovementFreeSpecialist(iI);
			}
		}

		iLast = 0;

		for (int iI = 0; iI < GC.getNumBonusInfos(); ++iI)
		{
			if (kBuilding.getBonusHealthChanges(iI) != 0)
			{
				szFirstBuffer.Format(L"%s%s", NEWLINE, gDLL->getText("TXT_KEY_BUILDING_HEALTH_HAPPINESS_CHANGE", abs(kBuilding.getBonusHealthChanges(iI)), ((kBuilding.getBonusHealthChanges(iI) > 0) ? gDLL->getSymbolID(HEALTHY_CHAR): gDLL->getSymbolID(UNHEALTHY_CHAR))).c_str());
				szTempBuffer.Format(L"<link=%s>%s</link>", CvWString(GC.getBonusInfo((BonusTypes)iI).getType()).GetCString(), GC.getBonusInfo((BonusTypes)iI).getDescription());
				setListHelp(szBuffer, szFirstBuffer, szTempBuffer, L", ", (kBuilding.getBonusHealthChanges(iI) != iLast));
				iLast = kBuilding.getBonusHealthChanges(iI);
			}
		}

		for (int iTech = 0; iTech < GC.getNumTechInfos(); iTech++)
		{
			if (GC.getGame().canEverResearch((TechTypes)iTech))
			{
				if (kBuilding.m_bAnyTechCommerceChanges)
				{
					if (bCivilopediaText)
					{
						szTempBuffer.Format(L"%s<link=%s>%s</link>", gDLL->getText("TXT_KEY_WITH").GetCString(), CvWString(GC.getTechInfo((TechTypes)iTech).getType()).GetCString(), GC.getTechInfo((TechTypes)iTech).getDescription());
					}
					else if (GC.getGame().getActivePlayer() != NO_PLAYER && ePlayer != NO_PLAYER && GET_TEAM(eTeam).isHasTech((TechTypes)iTech))
					{
						szTempBuffer.Format(SETCOLR L"%s%s" ENDCOLR, TEXT_COLOR("COLOR_GREEN"), gDLL->getText("TXT_KEY_WITH").GetCString(), GC.getTechInfo((TechTypes)iTech).getDescription());
					}
					else
					{
						szTempBuffer.Format(L"%s%s", gDLL->getText("TXT_KEY_WITH").GetCString(), GC.getTechInfo((TechTypes)iTech).getDescription());
					}
					setCommerceChangeHelp(szBuffer, L"", L"", szTempBuffer, kBuilding.getTechCommerceChangeArray(iTech), false, true);
				}
				if (kBuilding.m_bAnyTechYieldChanges)
				{
					if (bCivilopediaText)
					{
						szTempBuffer.Format(L"%s<link=%s>%s</link>", gDLL->getText("TXT_KEY_WITH").GetCString(), CvWString(GC.getTechInfo((TechTypes)iTech).getType()).GetCString(), GC.getTechInfo((TechTypes)iTech).getDescription());
					}
					else if (GC.getGame().getActivePlayer() != NO_PLAYER && ePlayer != NO_PLAYER && GET_TEAM(eTeam).isHasTech((TechTypes)iTech))
					{
						szTempBuffer.Format(SETCOLR L"%s%s" ENDCOLR, TEXT_COLOR("COLOR_GREEN"), gDLL->getText("TXT_KEY_WITH").GetCString(), GC.getTechInfo((TechTypes)iTech).getDescription());
					}
					else
					{
						szTempBuffer.Format(L"%s%s", gDLL->getText("TXT_KEY_WITH").GetCString(), GC.getTechInfo((TechTypes)iTech).getDescription());
					}
					setYieldChangeHelp(szBuffer, L"", L"", szTempBuffer, kBuilding.getTechYieldChangeArray(iTech), false, true);
				}

				if (kBuilding.m_bAnyTechSpecialistChanges)
				{
					for (int iSpecialist = 0; iSpecialist < GC.getNumSpecialistInfos(); iSpecialist++)
					{
						int iChange = kBuilding.getTechSpecialistChange(iTech, iSpecialist);
						if (0 != iChange)
						{
							szBuffer.append(NEWLINE);
							if (iChange == 1)
							{
								szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_TURN_CITIZEN_INTO", CvWString(GC.getSpecialistInfo((SpecialistTypes)iSpecialist).getType()).GetCString(), GC.getSpecialistInfo((SpecialistTypes) iSpecialist).getTextKeyWide()));
							}
							else
							{
								szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_TURN_CITIZENS_INTO", iChange, CvWString(GC.getSpecialistInfo((SpecialistTypes)iSpecialist).getType()).GetCString(), GC.getSpecialistInfo((SpecialistTypes) iSpecialist).getTextKeyWide()));
							}
							szBuffer.append(gDLL->getText("TXT_KEY_WITH"));
							szTempBuffer.Format(L"<link=%s>%s</link>", CvWString(GC.getTechInfo((TechTypes)iTech).getType()).GetCString(), GC.getTechInfo((TechTypes)iTech).getDescription());
							szBuffer.append(szTempBuffer);
						}
					}
				}

				if (kBuilding.m_bAnyTechCommerceModifiers)
				{
					if (bCivilopediaText)
					{
						szTempBuffer.Format(L"%s<link=%s>%s</link>", gDLL->getText("TXT_KEY_WITH").GetCString(), CvWString(GC.getTechInfo((TechTypes)iTech).getType()).GetCString(), GC.getTechInfo((TechTypes)iTech).getDescription());
					}
					else if (GC.getGame().getActivePlayer() != NO_PLAYER && ePlayer != NO_PLAYER && GET_TEAM(eTeam).isHasTech((TechTypes)iTech))
					{
						szTempBuffer.Format(SETCOLR L"%s%s" ENDCOLR, TEXT_COLOR("COLOR_GREEN"), gDLL->getText("TXT_KEY_WITH").GetCString(), GC.getTechInfo((TechTypes)iTech).getDescription());
					}
					else
					{
						szTempBuffer.Format(L"%s%s", gDLL->getText("TXT_KEY_WITH").GetCString(), GC.getTechInfo((TechTypes)iTech).getDescription());
					}
					setCommerceChangeHelp(szBuffer, L"", L"", szTempBuffer, kBuilding.getTechCommerceModifierArray(iTech), true, true);
				}

				if (kBuilding.m_bAnyTechYieldModifiers)
				{
					if (bCivilopediaText)
					{
						szTempBuffer.Format(L"%s<link=%s>%s</link>", gDLL->getText("TXT_KEY_WITH").GetCString(), CvWString(GC.getTechInfo((TechTypes)iTech).getType()).GetCString(), GC.getTechInfo((TechTypes)iTech).getDescription());
					}
					else if (GC.getGame().getActivePlayer() != NO_PLAYER && ePlayer != NO_PLAYER && GET_TEAM(eTeam).isHasTech((TechTypes)iTech))
					{
						szTempBuffer.Format(SETCOLR L"%s%s" ENDCOLR, TEXT_COLOR("COLOR_GREEN"), gDLL->getText("TXT_KEY_WITH").GetCString(), GC.getTechInfo((TechTypes)iTech).getDescription());
					}
					else
					{
						szTempBuffer.Format(L"%s%s", gDLL->getText("TXT_KEY_WITH").GetCString(), GC.getTechInfo((TechTypes)iTech).getDescription());
					}
					setYieldChangeHelp(szBuffer, L"", L"", szTempBuffer, kBuilding.getTechYieldModifierArray(iTech), true, true);
				}

				if (kBuilding.getTechHealthChanges(iTech) != 0)
				{
					szFirstBuffer.Format(L"%s%c+%d%c%s ", NEWLINE, gDLL->getSymbolID(BULLET_CHAR), abs(kBuilding.getTechHealthChanges(iTech)), (((kBuilding.getTechHealthChanges(iTech) > 0) ? gDLL->getSymbolID(HEALTHY_CHAR): gDLL->getSymbolID(UNHEALTHY_CHAR))), gDLL->getText("TXT_KEY_WITH").GetCString());
					szTempBuffer.Format(L"<link=%s>%s</link>", CvWString(GC.getTechInfo((TechTypes)iTech).getType()).GetCString(), GC.getTechInfo((TechTypes)iTech).getDescription());
					setListHelp(szBuffer, szFirstBuffer, szTempBuffer, L", ", (kBuilding.getTechHealthChanges(iTech) != iLast));
					iLast = kBuilding.getTechHealthChanges(iTech);
				}

				iLast = 0;

				if (kBuilding.getTechHappinessChanges(iTech) != 0)
				{
					szFirstBuffer.Format(L"%s%c+%d%c%s", NEWLINE, gDLL->getSymbolID(BULLET_CHAR), abs(kBuilding.getTechHappinessChanges(iTech)), (((kBuilding.getTechHappinessChanges(iTech) > 0) ? gDLL->getSymbolID(HAPPY_CHAR): gDLL->getSymbolID(UNHAPPY_CHAR))), gDLL->getText("TXT_KEY_WITH").GetCString());
					szTempBuffer.Format(L"<link=%s>%s</link>", CvWString(GC.getTechInfo((TechTypes)iTech).getType()).GetCString(), GC.getTechInfo((TechTypes)iTech).getDescription());
					setListHelp(szBuffer, szFirstBuffer, szTempBuffer, L", ", (kBuilding.getTechHappinessChanges(iTech) != iLast));
					iLast = kBuilding.getTechHappinessChanges(iTech);
				}
			}
		}

		iLast = 0;

		for (int iI = 0; iI < GC.getNumCivicInfos(); ++iI)
		{
			const int iChange = GC.getCivicInfo((CivicTypes)iI).getBuildingHealthChanges(eBuilding);
			if (0 != iChange)
			{
				szFirstBuffer.Format(L"%s%s", NEWLINE, gDLL->getText("TXT_KEY_BUILDING_CIVIC_HEALTH_HAPPINESS_CHANGE", abs(iChange), ((iChange > 0) ? gDLL->getSymbolID(HEALTHY_CHAR): gDLL->getSymbolID(UNHEALTHY_CHAR))).c_str());
				szTempBuffer.Format(L"<link=%s>%s</link>", CvWString(GC.getCivicInfo((CivicTypes)iI).getType()).GetCString(), GC.getCivicInfo((CivicTypes)iI).getDescription());
				setListHelp(szBuffer, szFirstBuffer, szTempBuffer, L", ", (iChange != iLast));
				iLast = iChange;
			}
		}

		iLast = 0;
		for (int iI = 0; iI < GC.getNumBonusInfos(); ++iI)
		{
			if (kBuilding.getBonusHappinessChanges(iI) != 0)
			{
				szFirstBuffer.Format(L"%s%s", NEWLINE, gDLL->getText("TXT_KEY_BUILDING_HEALTH_HAPPINESS_CHANGE", abs(kBuilding.getBonusHappinessChanges(iI)), ((kBuilding.getBonusHappinessChanges(iI) > 0) ? gDLL->getSymbolID(HAPPY_CHAR) : gDLL->getSymbolID(UNHAPPY_CHAR))).c_str());
				szTempBuffer.Format(L"<link=%s>%s</link>", CvWString(GC.getBonusInfo((BonusTypes)iI).getType()).GetCString(), GC.getBonusInfo((BonusTypes)iI).getDescription());
				setListHelp(szBuffer, szFirstBuffer, szTempBuffer, L", ", (kBuilding.getBonusHappinessChanges(iI) != iLast));
				iLast = kBuilding.getBonusHappinessChanges(iI);
			}
		}

		iLast = 0;

		for (int iI = 0; iI < GC.getNumCivicInfos(); ++iI)
		{
			const int iChange = GC.getCivicInfo((CivicTypes)iI).getBuildingHappinessChanges(eBuilding);
			if (0 != iChange)
			{
				szFirstBuffer.Format(L"%s%s", NEWLINE, gDLL->getText("TXT_KEY_BUILDING_CIVIC_HEALTH_HAPPINESS_CHANGE", abs(iChange), ((iChange > 0) ? gDLL->getSymbolID(HAPPY_CHAR): gDLL->getSymbolID(UNHAPPY_CHAR))).c_str());
				szTempBuffer.Format(L"<link=%s>%s</link>", CvWString(GC.getCivicInfo((CivicTypes)iI).getType()).GetCString(), GC.getCivicInfo((CivicTypes)iI).getDescription());
				setListHelp(szBuffer, szFirstBuffer, szTempBuffer, L", ", (iChange != iLast));
				iLast = iChange;
			}
		}

		if (kBuilding.isAnyUnitCombatFreeExperience())
		{
			for (int iI = 0; iI < GC.getNumUnitCombatInfos(); ++iI)
			{
				if (kBuilding.getUnitCombatFreeExperience(iI) != 0)
				{
					szBuffer.append(NEWLINE);
					szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_FREE_XP", GC.getUnitCombatInfo((UnitCombatTypes)iI).getTextKeyWide(), kBuilding.getUnitCombatFreeExperience(iI)));
				}
			}
		}

		for (int iI = 0; iI < NUM_DOMAIN_TYPES; ++iI)
		{
			if (kBuilding.getDomainFreeExperience(iI) != 0)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_FREE_XP", GC.getDomainInfo((DomainTypes)iI).getTextKeyWide(), kBuilding.getDomainFreeExperience(iI)));
			}
		}

		for (int iI = 0; iI < NUM_DOMAIN_TYPES; ++iI)
		{
			if (kBuilding.getDomainProductionModifier(iI) != 0)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_BUILDS_FASTER_DOMAIN", GC.getDomainInfo((DomainTypes)iI).getTextKeyWide(), kBuilding.getDomainProductionModifier(iI)));
			}
		}

		if (kBuilding.isForceAllTradeRoutes())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_ALL_TRADE"));
		}

		if (kBuilding.getWorldTradeRoutes() > 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_MORE_WORLD_TRADE", kBuilding.getWorldTradeRoutes()));
		}
		else if (kBuilding.getWorldTradeRoutes() < 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_LESS_WORLD_TRADE", -kBuilding.getWorldTradeRoutes()));
		}

		if (kBuilding.getUnitProductionModifier(NO_UNIT) != 0)
		{
			CvWString szUnit;

			for (int iI = 0; iI < GC.getNumUnitInfos(); ++iI)
			{
				if (GC.getGame().canEverTrain((UnitTypes) iI) && kBuilding.getUnitProductionModifier(iI) != 0)
				{
					szFirstBuffer.Format(L"%s%c%d%s", NEWLINE, gDLL->getSymbolID(BULLET_CHAR), abs(kBuilding.getUnitProductionModifier(iI)),
						(kBuilding.getUnitProductionModifier(iI) > 0 ? gDLL->getText("TXT_KEY_UNIT_CLASS_PRODUCTION_FAST_MOD") : gDLL->getText("TXT_KEY_UNIT_CLASS_PRODUCTION_SLOW_MOD")).c_str());

					szUnit.Format(L"<link=%s>%s</link>", CvWString(GC.getUnitInfo((UnitTypes) iI).getType()).GetCString(), GC.getUnitInfo((UnitTypes) iI).getDescription());

					setListHelp(szBuffer, szFirstBuffer, szUnit, L", ", (kBuilding.getUnitProductionModifier(iI) != iLast));
					iLast = kBuilding.getUnitProductionModifier(iI);
				}
			}
		}

		CvWString szBuilding;

		if (kBuilding.getBuildingProductionModifier(NO_BUILDING) != 0)
		{
			iLast = 0;
			for (int iI = 0; iI < GC.getNumBuildingInfos(); ++iI)
			{
				const BuildingTypes eLoopBuilding = static_cast<BuildingTypes>(iI);

				if (GC.getGame().canEverConstruct(eLoopBuilding))
				{
					if (kBuilding.getBuildingProductionModifier(iI) != 0)
					{
						szFirstBuffer.Format(L"%s%c%d%s", NEWLINE, gDLL->getSymbolID(BULLET_CHAR), abs(kBuilding.getBuildingProductionModifier(iI)), (kBuilding.getBuildingProductionModifier(iI) > 0 ? gDLL->getText("TXT_KEY_CIVIC_BUILDING_PRODUCTION_MOD") : gDLL->getText("TXT_KEY_CIVIC_BUILDING_PRODUCTION_SLOW")).c_str());
						szBuilding.Format(L"<link=%s>%s</link>", CvWString(GC.getBuildingInfo(eLoopBuilding).getType()).GetCString(), GC.getBuildingInfo(eLoopBuilding).getDescription());
						setListHelp(szBuffer, szFirstBuffer, szBuilding, L", ", (kBuilding.getBuildingProductionModifier(iI) != iLast));
						iLast = kBuilding.getBuildingProductionModifier(iI);
					}
				}
			}
		}

		if (kBuilding.getGlobalBuildingCostModifier(NO_BUILDING) != 0)
		{
			std::map<int, std::vector<int> > aMap;
			for (int iI = 0; iI < GC.getNumBuildingInfos(); ++iI)
			{
				if (kBuilding.getGlobalBuildingCostModifier(iI) != 0)
				{
					aMap[kBuilding.getGlobalBuildingCostModifier(iI)].push_back(iI);
				}
			}
			for (std::map<int, std::vector<int> >::const_iterator it = aMap.begin(); it != aMap.end(); ++it)
			{
				szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_GLOBAL_BUILDINGCOST_MOD", it->first));

				int iI = 0;
				for (std::vector<int>::const_iterator itr = it->second.begin(); itr != it->second.end(); ++itr)
				{
					const BuildingTypes eBuildingX = static_cast<BuildingTypes>(*itr);

					if (iI++ % 3 == 0)
					{
						szBuffer.append(gDLL->getText("TXT_KEY_HELP_LIST"));
					}
					else szBuffer.append(L", ");

					szBuilding.Format(L"<link=%s>%s</link>", CvWString(GC.getBuildingInfo(eBuildingX).getType()).GetCString(), GC.getBuildingInfo(eBuildingX).getDescription());
					szBuffer.append(szBuilding);
				}
			}
		}

		if (kBuilding.getGlobalBuildingProductionModifier(NO_BUILDING) != 0)
		{
			iLast = 0;
			bool bGlobal = false;
			for (int iI = 0; iI < GC.getNumBuildingInfos(); ++iI)
			{
				const BuildingTypes eLoopBuilding = static_cast<BuildingTypes>(iI);

				if (GC.getGame().canEverConstruct(eLoopBuilding))
				{
					if (kBuilding.getGlobalBuildingProductionModifier(iI) != 0)
					{
						if (bGlobal && kBuilding.getGlobalBuildingProductionModifier(iI) != iLast)
							szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_GLOBAL"));
						bGlobal = true;
						szFirstBuffer.Format(L"%s%c%d%s", NEWLINE, gDLL->getSymbolID(BULLET_CHAR), abs(kBuilding.getGlobalBuildingProductionModifier(iI)), (kBuilding.getGlobalBuildingProductionModifier(iI) > 0 ? gDLL->getText("TXT_KEY_CIVIC_BUILDING_PRODUCTION_MOD") : gDLL->getText("TXT_KEY_CIVIC_BUILDING_PRODUCTION_SLOW")).c_str());
						szBuilding.Format(L"<link=%s>%s</link>", CvWString(GC.getBuildingInfo(eLoopBuilding).getType()).GetCString(), GC.getBuildingInfo(eLoopBuilding).getDescription());
						setListHelp(szBuffer, szFirstBuffer, szBuilding, L", ", (kBuilding.getGlobalBuildingProductionModifier(iI) != iLast));
						iLast = kBuilding.getGlobalBuildingProductionModifier(iI);
					}
				}
			}
			if (bGlobal)
				szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_GLOBAL"));
		}
		//City Growth Speed Modifier

		if (kBuilding.getPopulationgrowthratepercentage() != 0)
		{
			if (kBuilding.getPopulationgrowthratepercentage() > 0)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_CITY_SLOW_GROWTH_SPEED", kBuilding.getPopulationgrowthratepercentage()));
			}
			if (kBuilding.getPopulationgrowthratepercentage() < 0)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_CITY_FAST_GROWTH_SPEED", -kBuilding.getPopulationgrowthratepercentage()));
			}
		}

		//Properties
		kBuilding.getProperties()->buildChangesString(szBuffer);
		kBuilding.getPropertiesAllCities()->buildChangesAllCitiesString(szBuffer);

		kBuilding.getPrereqMinProperties()->buildRequiresMinString(szBuffer, pCity ? pCity->getPropertiesConst() : NULL);
		kBuilding.getPrereqMaxProperties()->buildRequiresMaxString(szBuffer, pCity ? pCity->getPropertiesConst() : NULL);

		kBuilding.getPrereqPlayerMinProperties()->buildRequiresMinString(szBuffer, ePlayer != NO_PLAYER ? GET_PLAYER(ePlayer).getPropertiesConst() : NULL);
		kBuilding.getPrereqPlayerMaxProperties()->buildRequiresMaxString(szBuffer, ePlayer != NO_PLAYER ? GET_PLAYER(ePlayer).getPropertiesConst() : NULL);

		kBuilding.getPropertyManipulators()->buildDisplayString(szBuffer);
	}

	bFirst = true;
	for (int iI = 0; iI < GC.getNumBuildingInfos(); ++iI)
	{
		const BuildingTypes eLoopBuilding = static_cast<BuildingTypes>(iI);

		if (GC.getGame().canEverConstruct(eLoopBuilding))
		{
			if (GC.getBuildingInfo(eLoopBuilding).isReplaceBuilding(eBuilding))
			{
				if ((pCity == NULL) || (pCity->getNumBuilding(eLoopBuilding) == 0))
				{
					szFirstBuffer.Format(L"%s%s", NEWLINE, gDLL->getText("TXT_KEY_BUILDING_REPLACED_BY_BUILDING").c_str());
					szTempBuffer.Format(SETCOLR L"<link=%s>%s</link>" ENDCOLR, TEXT_COLOR("COLOR_BUILDING_TEXT"), CvWString(GC.getBuildingInfo(eLoopBuilding).getType()).GetCString(), GC.getBuildingInfo(eLoopBuilding).getDescription());
					setListHelp(szBuffer, szFirstBuffer, szTempBuffer, L", ", bFirst);
					bFirst = false;
				}
			}
		}
	}

	iLast = 0;
	for (int iI = 0; iI < GC.getNumBonusInfos(); ++iI)
	{
		if (kBuilding.getBonusDefenseChanges(iI) != 0)
		{
			int iBonusDefenseChange = kBuilding.getBonusDefenseChanges(iI);
			szFirstBuffer.Format(L"%s%c%s%d%s", NEWLINE, gDLL->getSymbolID(BULLET_CHAR), (iBonusDefenseChange > 0 ? L"+" : L""), iBonusDefenseChange, gDLL->getText("TXT_KEY_BUILDING_BONUS_DEFENSE_CHANGE").c_str());
			szTempBuffer.Format(L"<link=%s>%s</link>", CvWString(GC.getBonusInfo((BonusTypes)iI).getType()).GetCString(), GC.getBonusInfo((BonusTypes)iI).getDescription());
			setListHelp(szBuffer, szFirstBuffer, szTempBuffer, L", ", (iBonusDefenseChange != iLast));
			iLast = iBonusDefenseChange;
		}
	}

	if (!bRelDisabled)
	{
		iLast = 0;
		for (int iI = 0; iI < GC.getNumUnitCombatInfos(); ++iI)
		{
			if (kBuilding.getUnitCombatExtraStrength(iI) != 0)
			{
				int iUnitCombatExtraStrength = kBuilding.getUnitCombatExtraStrength(iI);
				szFirstBuffer.Format(L"%s%c%s%d%s", NEWLINE, gDLL->getSymbolID(BULLET_CHAR), (iUnitCombatExtraStrength > 0 ? L"+" : L""), iUnitCombatExtraStrength, gDLL->getText("TXT_KEY_BUILDING_UNITCOMBAT_EXTRA_STRENGTH").c_str());
				szTempBuffer.Format(L"<link=%s>%s</link>", CvWString(GC.getUnitCombatInfo((UnitCombatTypes)iI).getType()).GetCString(), GC.getUnitCombatInfo((UnitCombatTypes)iI).getDescription());
				setListHelp(szBuffer, szFirstBuffer, szTempBuffer, L", ", (iUnitCombatExtraStrength != iLast));
				if (iLast != iUnitCombatExtraStrength)
					szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_IN_CITY"));
				iLast = iUnitCombatExtraStrength;
			}
		}
/*
		iLast = 0;
		for (int iI = 0; iI < NUM_YIELD_TYPES; ++iI)
		{
			for (int iJ = 0; iJ < GC.getNumImprovementInfos(); iJ++)
			{
				if (kBuilding.getImprovementYieldChanges(iJ, iI) != 0)
				{
					szFirstBuffer.Format(L"%s%s", NEWLINE, gDLL->getText("TXT_KEY_CIVIC_IMPROVEMENT_YIELD_CHANGE", kBuilding.getImprovementYieldChanges(iJ, iI), GC.getYieldInfo((YieldTypes)iI).getChar()).c_str());
					CvWString szImprovement;
					szImprovement.Format(L"<link=%s>%s</link>", CvWString(GC.getImprovementInfo((ImprovementTypes)iJ).getType()).GetCString(), GC.getImprovementInfo((ImprovementTypes)iJ).getDescription());
					setListHelp(szBuffer, szFirstBuffer, szImprovement, L", ", (kBuilding.getImprovementYieldChanges(iJ, iI) != iLast));
					iLast = kBuilding.getImprovementYieldChanges(iJ, iI);
				}
			}
		}
*/
		bFirst = true;

		for (int iI = 0; iI < GC.getNumUnitInfos(); ++iI)
		{
			if (GC.getUnitInfo((UnitTypes)iI).isPrereqAndBuilding((int)eBuilding))
			{
				szFirstBuffer.Format(L"%s%s", NEWLINE, gDLL->getText("TXT_KEY_BUILDING_REQUIRED_TO_TRAIN").c_str());

				if (ePlayer != NO_PLAYER)
				{
					szTempBuffer.Format( SETCOLR L"<link=%s>%s</link>" ENDCOLR , TEXT_COLOR("COLOR_UNIT_TEXT"), CvWString(GC.getUnitInfo((UnitTypes)iI).getType()).GetCString(), GC.getUnitInfo((UnitTypes)iI).getDescription(GET_PLAYER(ePlayer).getCivilizationType()));
				}
				else
				{
					szTempBuffer.Format( SETCOLR L"<link=%s>%s</link>" ENDCOLR , TEXT_COLOR("COLOR_UNIT_TEXT"), CvWString(GC.getUnitInfo((UnitTypes)iI).getType()).GetCString(), GC.getUnitInfo((UnitTypes)iI).getDescription());
				}

				setListHelp(szBuffer, szFirstBuffer, szTempBuffer, L", ", bFirst);
				bFirst = false;
			}
		}

		bFirst = true;
		int iCount = 0;

		for (int iI = 0; iI < GC.getNumUnitInfos(); ++iI)
		{
			if (GC.getUnitInfo((UnitTypes)iI).getHasBuilding(eBuilding))
			{
				iCount++;
				if (!bCivilopediaText && (iCount > 5))
				{
					szBuffer.append(L", ...");
					break;
				}

				szFirstBuffer.Format(L"%s%s", NEWLINE, gDLL->getText("TXT_KEY_UNIT_REQUIRED_TO_BUILD").c_str());

				if (ePlayer != NO_PLAYER)
				{
					szTempBuffer.Format( SETCOLR L"<link=%s>%s</link>" ENDCOLR , TEXT_COLOR("COLOR_UNIT_TEXT"), CvWString(GC.getUnitInfo((UnitTypes)iI).getType()).GetCString(), GC.getUnitInfo((UnitTypes)iI).getDescription(GET_PLAYER(ePlayer).getCivilizationType()));
				}
				else
				{
					szTempBuffer.Format( SETCOLR L"<link=%s>%s</link>" ENDCOLR , TEXT_COLOR("COLOR_UNIT_TEXT"), CvWString(GC.getUnitInfo((UnitTypes)iI).getType()).GetCString(), GC.getUnitInfo((UnitTypes)iI).getDescription());
				}
				setListHelp(szBuffer, szFirstBuffer, szTempBuffer, L", ", bFirst);
				bFirst = false;
			}
		}

		iLast = 0;

		for (int iI = 0; iI < GC.getNumBuildingInfos(); ++iI)
		{
			if (kBuilding.getBuildingHappinessChanges(iI) != 0)
			{
				// Use absolute value with unhappy face
				szTempBuffer.Format(L"%s%s", NEWLINE, gDLL->getText("TXT_KEY_BUILDING_HAPPINESS_CHANGE", abs(kBuilding.getBuildingHappinessChanges(iI)),
					((kBuilding.getBuildingHappinessChanges(iI) > 0) ? gDLL->getSymbolID(HAPPY_CHAR) : gDLL->getSymbolID(UNHAPPY_CHAR))).c_str());

				CvWString szBuilding;
				szBuilding.Format(L"<link=%s>%s</link>", CvWString(GC.getBuildingInfo((BuildingTypes)iI).getType()).GetCString(), GC.getBuildingInfo((BuildingTypes)iI).getDescription());
				setListHelp(szBuffer, szTempBuffer, szBuilding, L", ", (kBuilding.getBuildingHappinessChanges(iI) != iLast));
				iLast = kBuilding.getBuildingHappinessChanges(iI);
			}
		}
	}

	if (kBuilding.getPowerBonus() != NO_BONUS)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_PROVIDES_POWER_WITH", CvWString(GC.getBonusInfo((BonusTypes)kBuilding.getPowerBonus()).getType()).GetCString(), GC.getBonusInfo((BonusTypes)kBuilding.getPowerBonus()).getTextKeyWide()));

		if (kBuilding.isDirtyPower() && (GC.getDIRTY_POWER_HEALTH_CHANGE() != 0))
		{
			szTempBuffer.Format(L" (+%d%c)", abs(GC.getDIRTY_POWER_HEALTH_CHANGE()), ((GC.getDIRTY_POWER_HEALTH_CHANGE() > 0) ? gDLL->getSymbolID(HEALTHY_CHAR): gDLL->getSymbolID(UNHEALTHY_CHAR)));
			szBuffer.append(szTempBuffer);
		}
	}

	bFirst = true;

	for (int iI = 0; iI < GC.getNumBuildingInfos(); ++iI)
	{
		const BuildingTypes eLoopBuilding = static_cast<BuildingTypes>(iI);

		if (GC.getBuildingInfo(eLoopBuilding).isPrereqInCityBuilding(eBuilding)
		&& (pCity == NULL || pCity->canConstruct(eLoopBuilding, false, true)))
		{
			szFirstBuffer.Format(L"%s%s", NEWLINE, gDLL->getText("TXT_KEY_BUILDING_REQUIRED_TO_BUILD").c_str());
			szTempBuffer.Format(SETCOLR L"<link=%s>%s</link>" ENDCOLR, TEXT_COLOR("COLOR_BUILDING_TEXT"), CvWString(GC.getBuildingInfo(eLoopBuilding).getType()).GetCString(), GC.getBuildingInfo(eLoopBuilding).getDescription());
			setListHelp(szBuffer, szFirstBuffer, szTempBuffer, L", ", bFirst);
			bFirst = false;
		}
	}

	if (!bRelDisabled)
	{
		if (kBuilding.getUnitUpgradePriceModifier() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_UNIT_UPGRADE_COST_MOD", kBuilding.getUnitUpgradePriceModifier()));
		}

		if (kBuilding.getNationalCaptureProbabilityModifier() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_NATIONAL_CAPTURE_PROBABILITY_MODIFIER", kBuilding.getNationalCaptureProbabilityModifier()));
		}
		if (kBuilding.getNationalCaptureResistanceModifier() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_NATIONAL_CAPTURE_RESISTANCE_MODIFIER", kBuilding.getNationalCaptureResistanceModifier()));
		}
		if (kBuilding.getLocalCaptureProbabilityModifier() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_LOCAL_CAPTURE_PROBABILITY_MODIFIER", kBuilding.getLocalCaptureProbabilityModifier()));
		}
		if (kBuilding.getLocalCaptureResistanceModifier() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_LOCAL_CAPTURE_RESISTANCE_MODIFIER", kBuilding.getLocalCaptureResistanceModifier()));
		}
	}

	if (GC.getGame().isOption(GAMEOPTION_SAD))
	{
		if (kBuilding.getLocalDynamicDefense() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_LOCAL_DYNAMIC_DEFENSE", kBuilding.getLocalDynamicDefense()));
		}
	}

	if (kBuilding.getRiverDefensePenalty() > 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_RIVER_DEFENSE_PENALTY_POSITIVE", kBuilding.getRiverDefensePenalty()));
	}

	if (kBuilding.getRiverDefensePenalty() < 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_RIVER_DEFENSE_PENALTY_NEGATIVE", -kBuilding.getRiverDefensePenalty()));
	}

	if (kBuilding.getLocalRepel() != 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_CITY_REPEL", kBuilding.getLocalRepel()));
	}

	if (kBuilding.getMinDefense() != 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_MIN_DEFENSE", kBuilding.getMinDefense()));
	}

	if (kBuilding.getBuildingDefenseRecoverySpeedModifier() > 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_DEFENSE_RECOVERY_SPEED_MODIFIER_POSITIVE", kBuilding.getBuildingDefenseRecoverySpeedModifier()));
	}

	if (kBuilding.getBuildingDefenseRecoverySpeedModifier() < 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_DEFENSE_RECOVERY_SPEED_MODIFIER_NEGATIVE", -kBuilding.getBuildingDefenseRecoverySpeedModifier()));
	}

	if (kBuilding.getCityDefenseRecoverySpeedModifier() > 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_CITY_DEFENSE_RECOVERY_SPEED_MODIFIER_POSITIVE", kBuilding.getCityDefenseRecoverySpeedModifier()));
	}

	if (kBuilding.getCityDefenseRecoverySpeedModifier() < 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_CITY_DEFENSE_RECOVERY_SPEED_MODIFIER_NEGATIVE", -kBuilding.getCityDefenseRecoverySpeedModifier()));
	}

	if (bCivilopediaText)
	{
		// Trait
		for (int i = 0; i < GC.getNumTraitInfos(); ++i)
		{
			TraitTypes eTrait = ((TraitTypes)i);
			for (int j = 0; j < GC.getTraitInfo(eTrait).getNumBuildingProductionModifiers(); j++)
			{
				if ((BuildingTypes)GC.getTraitInfo(eTrait).getBuildingProductionModifier(j).eBuilding == eBuilding)
				{
					if (GC.getTraitInfo(eTrait).getBuildingProductionModifier(j).iModifier != 0)
					{
						if (GC.getTraitInfo(eTrait).getBuildingProductionModifier(j).iModifier == 100)
						{
							szBuffer.append(NEWLINE);
							szBuffer.append(gDLL->getText("TXT_KEY_DOUBLE_SPEED_TRAIT", GC.getTraitInfo(eTrait).getTextKeyWide()));
						}
						else
						{
							szBuffer.append(NEWLINE);
							szBuffer.append(gDLL->getText("TXT_KEY_PRODUCTION_MODIFIER_TRAIT", GC.getTraitInfo(eTrait).getBuildingProductionModifier(j).iModifier, GC.getTraitInfo(eTrait).getTextKeyWide()));
						}
					}
				}
			}
		}

		if (!bRelDisabled)
		{
			for (int i = 0; i < GC.getNumTraitInfos(); ++i)
			{
				TraitTypes eTrait = ((TraitTypes)i);
				for (int j = 0; j < GC.getTraitInfo(eTrait).getNumBuildingHappinessModifiers(); j++)
				{
					if ((BuildingTypes)GC.getTraitInfo(eTrait).getBuildingHappinessModifier(j).eBuilding == eBuilding)
					{
						if (GC.getTraitInfo(eTrait).getBuildingHappinessModifier(j).iModifier != 0)
						{
							szBuffer.append(NEWLINE);
							szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_HAPPINESS_TRAIT", GC.getTraitInfo(eTrait).getBuildingHappinessModifier(j).iModifier, GC.getTraitInfo(eTrait).getTextKeyWide()));
						}
					}
				}
			}
		}
	}

	if (bCivilopediaText)
	{
		eGreatPeopleUnit = (UnitTypes)kBuilding.getGreatPeopleUnitType();

		if (eGreatPeopleUnit!= NO_UNIT)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_LIKELY_TO_GENERATE", CvWString(GC.getUnitInfo(eGreatPeopleUnit).getType()).GetCString(), GC.getUnitInfo(eGreatPeopleUnit).getTextKeyWide()));
		}

		if (kBuilding.getFreeStartEra() != NO_ERA)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_FREE_START_ERA", GC.getEraInfo((EraTypes)kBuilding.getFreeStartEra()).getTextKeyWide()));
		}
	}

	if (!CvWString(kBuilding.getHelp()).empty())
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(kBuilding.getHelp());
	}

	buildBuildingRequiresString(szBuffer, eBuilding, bCivilopediaText, bTechChooserText, pCity);

	//AIAndy: Display in which range of a property this building is auto built
	for (int i=0; i<GC.getNumPropertyInfos(); i++)
	{
		const CvPropertyInfo& kInfo = GC.getPropertyInfo((PropertyTypes)i);
		int iNum = kInfo.getNumPropertyBuildings();
		for (int j=0; j<iNum; j++)
		{
			if (kInfo.getPropertyBuilding(j).eBuilding == eBuilding)
			{
				szBuffer.append(NEWLINE);
				int iMinVal = kInfo.getPropertyBuilding(j).iMinValue;
				int iMaxVal = kInfo.getPropertyBuilding(j).iMaxValue;
				int iOpMin = kInfo.getOperationalRangeMin();
				int iOpMax = kInfo.getOperationalRangeMax();
				if (iMinVal < iOpMin - 5*(iOpMax - iOpMin))
				{
					szBuffer.append(gDLL->getText("TXT_KEY_PROPERTY_BUILDING_DISPLAY_UNDER", iMaxVal));
				}
				else if (iMaxVal > iOpMax + 5*(iOpMax - iOpMin))
				{
					szBuffer.append(gDLL->getText("TXT_KEY_PROPERTY_BUILDING_DISPLAY_OVER", iMinVal));
				}
				else
				{
					szBuffer.append(gDLL->getText("TXT_KEY_PROPERTY_BUILDING_DISPLAY", iMinVal, iMaxVal));
				}
				CvWString szTemp;
				szTemp.Format(L"%c", kInfo.getChar());
				szBuffer.append(szTemp);
			}
		}
	}

	if (pCity != NULL)
	{
// BUG - Building Double Commerce - start
		if (GC.getGame().getActivePlayer() != NO_PLAYER &&
			(pCity->getNumRealBuilding(eBuilding) == 0 || (pCity->getNumRealBuilding(eBuilding) > 0 && pCity->getBuildingOriginalOwner(eBuilding) == GC.getGame().getActivePlayer())))
		{
			if (getBugOptionBOOL("CityScreen__BuildingDoubleCommerce", true, "BUG_BUILDING_DOUBLE_COMMERCE"))
			{
				int iYear = pCity->getBuildingOriginalTime(eBuilding);

				if (iYear != MIN_INT)
				{
					// year built
					CvWString szYear;

					if (iYear < 0)
					{
						szYear = gDLL->getText("TXT_KEY_TIME_BC", -iYear);
					}
					else if (iYear > 0)
					{
						szYear = gDLL->getText("TXT_KEY_TIME_AD", iYear);
					}
					else
					{
						szYear = gDLL->getText("TXT_KEY_TIME_AD", 1);
					}

					szBuffer.append(NEWLINE);
					szBuffer.append(gDLL->getText("TXT_KEY_BUG_YEAR_BUILT", szYear.GetCString()));
				}

				if ( iYear == MIN_INT )
				{
					iYear = GC.getGame().getGameTurnYear();	//	Not yet built so display the full time to double commerces
				}

				// double commerce
				if (pCity->getOwner() == GC.getGame().getActivePlayer())
				{
					for (int iI = 0; iI < NUM_COMMERCE_TYPES; iI++)
					{
						int iDoubleTime = kBuilding.getCommerceChangeDoubleTime(iI);
						int iAge = GC.getGame().getGameTurnYear() - iYear;

						if (iAge < iDoubleTime)
						{
							szBuffer.append(NEWLINE);
							if (iAge - iDoubleTime == 1)
							{
								szBuffer.append(gDLL->getText("TXT_KEY_BUG_DOUBLE_COMMERCE_NEXT_YEAR", GC.getCommerceInfo((CommerceTypes)iI).getTextKeyWide()));
							}
							else
							{
								szBuffer.append(gDLL->getText("TXT_KEY_BUG_DOUBLE_COMMERCE_YEARS", GC.getCommerceInfo((CommerceTypes)iI).getTextKeyWide(), iDoubleTime - iAge));
							}
						}
					}
				}
			}
		}
// BUG - Building Double Commerce - end

		if (!kBuilding.isNoLimit())
		{
			if (isWorldWonder(eBuilding))
			{
				if (pCity->isWorldWondersMaxed())
				{
					szBuffer.append(NEWLINE);
					szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_WORLD_WONDERS_PER_CITY", GC.getCultureLevelInfo(pCity->getCultureLevel()).getMaxWorldWonders()));
				}
			}
			else if (isTeamWonder(eBuilding))
			{
				if (pCity->isTeamWondersMaxed())
				{
					szBuffer.append(NEWLINE);
					szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_TEAM_WONDERS_PER_CITY", GC.getCultureLevelInfo(pCity->getCultureLevel()).getMaxTeamWonders()));
				}
			}
			else if (isNationalWonder(eBuilding))
			{
				if (pCity->isNationalWondersMaxed())
				{
					const int iMaxNumWonders = (GC.getGame().isOption(GAMEOPTION_ONE_CITY_CHALLENGE) && GET_PLAYER(pCity->getOwner()).isHuman()) ? GC.getCultureLevelInfo(pCity->getCultureLevel()).getMaxNationalWondersOCC() : GC.getCultureLevelInfo(pCity->getCultureLevel()).getMaxNationalWonders();
					szBuffer.append(NEWLINE);
					szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_NATIONAL_WONDERS_PER_CITY", iMaxNumWonders));
				}
			}
		}
	}

	if ((pCity == NULL) || pCity->getNumRealBuilding(eBuilding) < GC.getCITY_MAX_NUM_BUILDINGS())
	{
		if (!bCivilopediaText)
		{
			if (pCity == NULL)
			{
				if (kBuilding.getProductionCost() > 0)
				{
					szTempBuffer.Format(L"\n%d%c", (ePlayer != NO_PLAYER ? GET_PLAYER(ePlayer).getProductionNeeded(eBuilding) : kBuilding.getProductionCost()), GC.getYieldInfo(YIELD_PRODUCTION).getChar());
					szBuffer.append(szTempBuffer);
				}
			}
			else
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_NUM_TURNS", pCity->getProductionTurnsLeft(eBuilding, ((gDLL->ctrlKey() || !(gDLL->shiftKey())) ? 0 : pCity->getOrderQueueLength()))));

				if (pCity->getBuildingProduction(eBuilding) > 0)
				{
					szTempBuffer.Format(L" - %d/%d%c", pCity->getBuildingProduction(eBuilding), pCity->getProductionNeeded(eBuilding), GC.getYieldInfo(YIELD_PRODUCTION).getChar());
					szBuffer.append(szTempBuffer);

					if (getBugOptionBOOL("CityScreen__ProductionDecayHover", true, "BUG_PRODUCTION_DECAY_HOVER"))
					{
						setProductionDecayHelp(szBuffer, pCity->getBuildingProductionDecayTurns(eBuilding), getBugOptionINT("CityScreen__ProductionDecayHoverBuildingThreshold",
							5, "BUG_PRODUCTION_DECAY_HOVER_BUILDING_THRESHOLD"), pCity->getBuildingProductionDecay(eBuilding), pCity->getProductionBuilding() == eBuilding);
					}
				}
				else
				{
					szTempBuffer.Format(L" - %d%c", pCity->getProductionNeeded(eBuilding), GC.getYieldInfo(YIELD_PRODUCTION).getChar());
					szBuffer.append(szTempBuffer);
				}
			}
		}

		for (int iI = 0; iI < GC.getNumBonusInfos(); ++iI)
		{
			if (kBuilding.getBonusProductionModifier(iI) != 0)
			{
				if (pCity != NULL)
				{
					if (pCity->hasBonus((BonusTypes)iI))
					{
						szBuffer.append(gDLL->getText("TXT_KEY_COLOR_POSITIVE"));
					}
					else
					{
						szBuffer.append(gDLL->getText("TXT_KEY_COLOR_NEGATIVE"));
					}
				}
				if (!bCivilopediaText)
				{
					szBuffer.append(L" (");
				}
				else
				{
					szTempBuffer.Format(L"\n%c", gDLL->getSymbolID(BULLET_CHAR), szTempBuffer.c_str());
					szBuffer.append(szTempBuffer);
				}
				if (kBuilding.getBonusProductionModifier(iI) == 100)
				{
					szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_DOUBLE_SPEED_WITH", CvWString(GC.getBonusInfo((BonusTypes)iI).getType()).GetCString(), GC.getBonusInfo((BonusTypes) iI).getTextKeyWide()));
				}
				else
				{
					szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_BUILDS_FASTER_WITH", kBuilding.getBonusProductionModifier(iI), CvWString(GC.getBonusInfo((BonusTypes)iI).getType()).GetCString(), GC.getBonusInfo((BonusTypes) iI).getTextKeyWide()));
				}
				if (!bCivilopediaText)
				{
					szBuffer.append(L')');
				}
				if (pCity != NULL)
				{
					szBuffer.append(gDLL->getText("TXT_KEY_COLOR_REVERT"));
				}
			}
		}

		if (kBuilding.getObsoleteTech() != NO_TECH)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_OBSOLETE_WITH", CvWString(GC.getTechInfo((TechTypes)kBuilding.getObsoleteTech()).getType()).GetCString(), GC.getTechInfo((TechTypes) kBuilding.getObsoleteTech()).getTextKeyWide()));

			if (kBuilding.getDefenseModifier() != 0 || kBuilding.getBombardDefenseModifier() != 0)
			{
				szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_OBSOLETE_EXCEPT"));
			}
		}

		if (kBuilding.getSpecialBuildingType() != NO_SPECIALBUILDING)
		{
			if (GC.getSpecialBuildingInfo((SpecialBuildingTypes) kBuilding.getSpecialBuildingType()).getObsoleteTech() != NO_TECH)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_OBSOLETE_WITH", CvWString(GC.getTechInfo((TechTypes) GC.getSpecialBuildingInfo((SpecialBuildingTypes)kBuilding.getSpecialBuildingType()).getObsoleteTech()).getType()).GetCString(), GC.getTechInfo((TechTypes) GC.getSpecialBuildingInfo((SpecialBuildingTypes) kBuilding.getSpecialBuildingType()).getObsoleteTech()).getTextKeyWide()));
			}
		}

		if ((gDLL->getChtLvl() > 0) && gDLL->ctrlKey() && (pCity != NULL))
		{
			int iBuildingValue = pCity->AI_buildingValue(eBuilding);
			szBuffer.append(CvWString::format(L"\nAI Building Value = %d", iBuildingValue));
		}
	}

	if (bStrategyText)
	{
		if (!CvWString(kBuilding.getStrategy()).empty())
		{
			if ((ePlayer == NO_PLAYER) || GET_PLAYER(ePlayer).isOption(PLAYEROPTION_ADVISOR_HELP))
			{
				szBuffer.append(SEPARATOR);
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_SIDS_TIPS"));
				szBuffer.append(L'\"');
				szBuffer.append(kBuilding.getStrategy());
				szBuffer.append(L'\"');
			}
		}
	}

	if (bCivilopediaText)
	{
		for (int iI = 0; iI < kBuilding.getNumMapCategoryTypes(); iI++)
		{
			const MapCategoryTypes eMapCategory = (MapCategoryTypes)kBuilding.getMapCategoryType(iI);
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_MAP_CATEGORY_PREREQUISITE", GC.getMapCategoryInfo(eMapCategory).getTextKeyWide()));
		}
	}
}

void CvGameTextMgr::buildBuildingRequiresString(CvWStringBuffer& szBuffer, BuildingTypes eBuilding, bool bCivilopediaText, bool bTechChooserText, const CvCity* pCity)
{
	bool bFirst;
	PlayerTypes ePlayer;
	CvWString szTempBuffer;
	CvWString szFirstBuffer;
	const CvBuildingInfo& kBuilding = GC.getBuildingInfo(eBuilding);
	int iI;
	int iTerrainCount;

	if (pCity != NULL)
	{
		ePlayer = pCity->getOwner();
	}
	else
	{
		ePlayer = GC.getGame().getActivePlayer();
	}

	bool bCanConstruct = (NULL != pCity && pCity->canConstruct(eBuilding));

	//	Future - do the green/red text thing with all of this - for now just civics do it
	//	so can skip the rest of teh code for constructable buildings
	if ( !bCanConstruct )
	{

		bFirst = true;

		if (kBuilding.getSpecialBuildingType() != NO_SPECIALBUILDING)
		{
			if ((pCity == NULL) || !(GC.getGame().isSpecialBuildingValid((SpecialBuildingTypes)(kBuilding.getSpecialBuildingType()))))
			{
				for (int iI = 0; iI < GC.getNumProjectInfos(); ++iI)
				{
					if (GC.getProjectInfo((ProjectTypes)iI).getEveryoneSpecialBuilding() == kBuilding.getSpecialBuildingType())
					{
						szTempBuffer.Format(L"%s%s", NEWLINE, gDLL->getText("TXT_KEY_REQUIRES").c_str());
						CvWString szProject;
						szProject.Format(L"<link=%s>%s</link>", CvWString(GC.getProjectInfo((ProjectTypes)iI).getType()).GetCString(), GC.getProjectInfo((ProjectTypes)iI).getDescription());
						setListHelp(szBuffer, szTempBuffer, szProject, gDLL->getText("TXT_KEY_OR").c_str(), bFirst);
						bFirst = false;
					}
				}
			}
		}

		if (!bFirst)
		{
			szBuffer.append(ENDCOLR);
		}

		TechTypes eTech = NO_TECH;
		if (kBuilding.getSpecialBuildingType() != NO_SPECIALBUILDING)
		{
			if ((pCity == NULL) || !(GC.getGame().isSpecialBuildingValid((SpecialBuildingTypes)(kBuilding.getSpecialBuildingType()))))
			{
				eTech = (TechTypes)GC.getSpecialBuildingInfo((SpecialBuildingTypes)kBuilding.getSpecialBuildingType()).getTechPrereqAnyone();
				if (NO_TECH != eTech)
				{
					szBuffer.append(NEWLINE);
					szBuffer.append(gDLL->getText("TXT_KEY_REQUIRES_TECH_ANYONE", CvWString(GC.getTechInfo(eTech).getType()).GetCString(), GC.getTechInfo(eTech).getTextKeyWide()));
				}
			}
			eTech = (TechTypes)GC.getSpecialBuildingInfo((SpecialBuildingTypes)kBuilding.getSpecialBuildingType()).getTechPrereq();
			if (NO_TECH != eTech)
			{
				if ((pCity == NULL) || !(GET_TEAM(pCity->getTeam()).isHasTech(eTech)))
				{
					if (NO_TECH != eTech)
					{
						szBuffer.append(NEWLINE);
						szBuffer.append(gDLL->getText("TXT_KEY_REQUIRES_TECH", CvWString(GC.getTechInfo(eTech).getType()).GetCString(), GC.getTechInfo(eTech).getTextKeyWide()));
					}
				}
			}
		}

		for (iI = 0; iI < GC.getNumBuildingInfos(); ++iI)
		{
			if (ePlayer == NO_PLAYER && kBuilding.getPrereqNumOfBuilding((BuildingTypes)iI) > 0)
			{
				szTempBuffer.Format(L"%s%s", NEWLINE, gDLL->getText("TXT_KEY_BUILDING_REQUIRES_NUM_SPECIAL_BUILDINGS_NO_CITY", GC.getBuildingInfo((BuildingTypes)iI).getTextKeyWide(), kBuilding.getPrereqNumOfBuilding((BuildingTypes)iI)).c_str());
				szBuffer.append(szTempBuffer);
			}
			else if (ePlayer != NO_PLAYER && GET_PLAYER(ePlayer).getBuildingPrereqBuilding(eBuilding, (BuildingTypes)iI) > 0)
			{
				if (pCity == NULL || GET_PLAYER(ePlayer).getBuildingCount((BuildingTypes)iI) < GET_PLAYER(ePlayer).getBuildingPrereqBuilding(eBuilding, (BuildingTypes)iI))
				{
					if (pCity != NULL)
					{
						szTempBuffer.Format(L"%s%s", NEWLINE, gDLL->getText("TXT_KEY_BUILDING_REQUIRES_NUM_SPECIAL_BUILDINGS", GC.getBuildingInfo((BuildingTypes)iI).getTextKeyWide(), GET_PLAYER(ePlayer).getBuildingCount((BuildingTypes)iI), GET_PLAYER(ePlayer).getBuildingPrereqBuilding(eBuilding, (BuildingTypes)iI)).c_str());
					}
					else
					{
						szTempBuffer.Format(L"%s%s", NEWLINE, gDLL->getText("TXT_KEY_BUILDING_REQUIRES_NUM_SPECIAL_BUILDINGS_NO_CITY", GC.getBuildingInfo((BuildingTypes)iI).getTextKeyWide(), GET_PLAYER(ePlayer).getBuildingPrereqBuilding(eBuilding, (BuildingTypes)iI)).c_str());
					}

					szBuffer.append(szTempBuffer);
				}
			}
			else if (kBuilding.isPrereqInCityBuilding(iI)
			&& (pCity == NULL || pCity->getNumBuilding((BuildingTypes)iI) <= 0))
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_REQUIRES_STRING", CvWString(GC.getBuildingInfo((BuildingTypes)iI).getType()).GetCString(), GC.getBuildingInfo((BuildingTypes)iI).getTextKeyWide()));
			}
		}

		if (kBuilding.getNumCitiesPrereq() > 0)
		{
			if (NO_PLAYER == ePlayer || GET_PLAYER(ePlayer).getNumCities() < kBuilding.getNumCitiesPrereq())
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_REQUIRES_NUM_CITIES", kBuilding.getNumCitiesPrereq()));
			}
		}

		if (kBuilding.getUnitLevelPrereq() > 0)
		{
			if (NO_PLAYER == ePlayer || GET_PLAYER(ePlayer).getHighestUnitLevel() < kBuilding.getUnitLevelPrereq())
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_REQUIRES_UNIT_LEVEL", kBuilding.getUnitLevelPrereq()));
			}
		}

		if (kBuilding.getMinLatitude() > 0)
		{
			if (NULL == pCity || pCity->plot()->getLatitude() < kBuilding.getMinLatitude())
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_MIN_LATITUDE", kBuilding.getMinLatitude()));
			}
		}

		if (kBuilding.getMaxLatitude() < 90)
		{
			if (NULL == pCity || pCity->plot()->getLatitude() > kBuilding.getMaxLatitude())
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_MAX_LATITUDE", kBuilding.getMaxLatitude()));
			}
		}

		if (kBuilding.isBuildOnlyOnPeaks())
		{
			if (pCity == NULL || !pCity->plot()->isPeak2(true))
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_REQUIRES_MOUNTAIN"));
			}
		}

		if (kBuilding.isStateReligion())
		{
			if (NULL == pCity || NO_PLAYER == ePlayer || NO_RELIGION == GET_PLAYER(ePlayer).getStateReligion() || !pCity->isHasReligion(GET_PLAYER(ePlayer).getStateReligion()))
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_REQUIRES_STATE_RELIGION"));
			}
		}

		if (kBuilding.getHolyCity() != NO_RELIGION)
		{
			if (pCity == NULL || !pCity->isHolyCity((ReligionTypes)(kBuilding.getHolyCity())))
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_ACTION_ONLY_HOLY_CONSTRUCT", GC.getReligionInfo((ReligionTypes) kBuilding.getHolyCity()).getChar()));
			}
		}

		if (kBuilding.getPrereqReligion() != NO_RELIGION)
		{
			if (NULL == pCity || NO_PLAYER == ePlayer || !pCity->isHasReligion((ReligionTypes)kBuilding.getPrereqReligion()))
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_REQUIRES_PREREQUISITE_RELIGION", GC.getReligionInfo((ReligionTypes)kBuilding.getPrereqReligion()).getChar()));
			}
		}

		if (kBuilding.getReligionType() != NO_RELIGION)
		{
			ReligionTypes eReligion = (ReligionTypes)kBuilding.getReligionType();
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_RELIGION_DECLARED", GC.getReligionInfo((ReligionTypes)(kBuilding.getReligionType())).getChar()));
		}

		if (kBuilding.getStateReligion() != NO_RELIGION)
		{
			ReligionTypes eReligion = (ReligionTypes)kBuilding.getStateReligion();
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_STATE_RELIGION_PREREQ", GC.getReligionInfo((ReligionTypes)(kBuilding.getStateReligion())).getChar()));
		}
	}

	bFirst = true;
	bool bLastCivicWasMet = false;
	bool civicRequirementsAllMet = true;

	for (iI = 0; iI < GC.getNumCivicInfos(); ++iI)
	{
		if (kBuilding.isPrereqAndCivics(CivicTypes(iI)))
		{
			if ((GC.getGame().getActivePlayer() == NO_PLAYER )|| !(GET_PLAYER(GC.getGame().getActivePlayer()).isCivic((CivicTypes(iI)))))
			{
				if ( bLastCivicWasMet && !bFirst )
				{
					szBuffer.append(gDLL->getText("TXT_KEY_SET_WARNING_COLOR").c_str());
				}
				szTempBuffer.Format(L"%s%s", NEWLINE, gDLL->getText("TXT_KEY_REQUIRES").c_str());
				setListHelp(szBuffer, szTempBuffer, GC.getCivicInfo((CivicTypes(iI))).getDescription(), gDLL->getText("TXT_KEY_AND").c_str(), bFirst);
				bLastCivicWasMet = false;
				civicRequirementsAllMet = false;
			}
			else
			{
				if ( !bLastCivicWasMet && !bFirst )
				{
					szBuffer.append(gDLL->getText("TXT_KEY_REVERT_COLOR").c_str());
				}
				szTempBuffer.Format(L"%s%s", NEWLINE, gDLL->getText("TXT_KEY_REQUIRES_NO_WARNING").c_str());
				setListHelp(szBuffer, szTempBuffer, GC.getCivicInfo((CivicTypes(iI))).getDescription(), gDLL->getText("TXT_KEY_AND").c_str(), bFirst);
				bLastCivicWasMet = true;
			}

			bFirst = false;
		}
	}

	bFirst = true;
	bool bCivicORRequirementMet = false;

	for (iI = 0; iI < GC.getNumCivicInfos(); ++iI)
	{
		if (kBuilding.isPrereqOrCivics(CivicTypes(iI)))
		{
			bool bThisConditionMet = (GC.getGame().getActivePlayer() != NO_PLAYER && GET_PLAYER(GC.getGame().getActivePlayer()).isCivic(CivicTypes(iI)));
			CvWString prefix = gDLL->getText("TXT_KEY_REQUIRES_NO_WARNING");
			CvWString desc = GC.getCivicInfo((CivicTypes(iI))).getDescription();

			CvWString separator = gDLL->getText("TXT_KEY_REVERT_COLOR") + gDLL->getText("TXT_KEY_OR");

			if (!bThisConditionMet)
			{
				desc = gDLL->getText("TXT_KEY_SET_WARNING_COLOR") + desc;
			}
			else
			{
				desc = gDLL->getText("TXT_KEY_POSITIVE_COLOR") + desc;
				bCivicORRequirementMet= true;
			}

			szTempBuffer.Format(L"%s%s", NEWLINE, prefix.c_str());
			setListHelp(szBuffer,szTempBuffer, desc.c_str(), separator.c_str(), bFirst);
			bFirst = false;
		}
	}

	civicRequirementsAllMet &= (bFirst || bCivicORRequirementMet);

	if (kBuilding.isRequiresActiveCivics())
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText(civicRequirementsAllMet ? "TXT_KEY_BUILDING_REQUIRES_ACTIVE_CIVICS_MET" : "TXT_KEY_BUILDING_REQUIRES_ACTIVE_CIVICS"));
	}

	if ( !bCanConstruct )
	{
		if (kBuilding.getPrereqVicinityBonus() != NO_BONUS)
		{
			if (pCity == NULL || !pCity->hasVicinityBonus((BonusTypes)kBuilding.getPrereqVicinityBonus()))
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_REQUIRES_VICINITY_BONUS", GC.getBonusInfo((BonusTypes)kBuilding.getPrereqVicinityBonus()).getTextKeyWide()));
			}
		}
		if (kBuilding.getPrereqRawVicinityBonus() != NO_BONUS)
		{
			if (pCity == NULL || !pCity->hasRawVicinityBonus((BonusTypes)kBuilding.getPrereqRawVicinityBonus()))
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_REQUIRES_RAW_VICINITY_BONUS", GC.getBonusInfo((BonusTypes)kBuilding.getPrereqRawVicinityBonus()).getTextKeyWide()));
			}
		}

		CvWStringBuffer szBonusList;
		bFirst = true;

		for (iI = 0; iI < GC.getNUM_BUILDING_PREREQ_OR_BONUSES(); ++iI)
		{
			if (kBuilding.getPrereqOrVicinityBonuses(iI) != NO_BONUS)
			{
				if (pCity == NULL || !pCity->hasVicinityBonus((BonusTypes)kBuilding.getPrereqOrVicinityBonuses(iI)))
				{
					szTempBuffer.Format(L"%s%s", NEWLINE, gDLL->getText("TXT_KEY_REQUIRES_IN_CITY_VICINITY").c_str());
					setListHelp(szBonusList, szTempBuffer, GC.getBonusInfo((BonusTypes)kBuilding.getPrereqOrVicinityBonuses(iI)).getDescription(), gDLL->getText("TXT_KEY_OR").c_str(), bFirst);
					bFirst = false;
				}
				else if (NULL != pCity)
				{
					bFirst = true;
					break;
				}
			}
		}

		if (!bFirst)
		{
			szBonusList.append(ENDCOLR);
			szBuffer.append(szBonusList);
		}

		CvWStringBuffer szRawBonusList;
		bFirst = true;

		for (iI = 0; iI < GC.getNUM_BUILDING_PREREQ_OR_BONUSES(); ++iI)
		{
			if (kBuilding.getPrereqOrRawVicinityBonuses(iI) != NO_BONUS)
			{
				if (pCity == NULL || !pCity->hasRawVicinityBonus((BonusTypes)kBuilding.getPrereqOrRawVicinityBonuses(iI)))
				{
					szTempBuffer.Format(L"%s%s", NEWLINE, gDLL->getText("TXT_KEY_REQUIRES_RAW_IN_CITY_VICINITY").c_str());
					setListHelp(szRawBonusList, szTempBuffer, GC.getBonusInfo((BonusTypes)kBuilding.getPrereqOrRawVicinityBonuses(iI)).getDescription(), gDLL->getText("TXT_KEY_OR").c_str(), bFirst);
					bFirst = false;
				}
				else if (NULL != pCity)
				{
					bFirst = true;
					break;
				}
			}
		}

		if (!bFirst)
		{
			szBonusList.append(ENDCOLR);
			szBuffer.append(szRawBonusList);
		}

		if (kBuilding.isPrereqPower())
		{
			if (pCity == NULL || !pCity->isPower())
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_REQUIRES_POWER"));
				szBuffer.append(CvWString::format(L" (%c)", gDLL->getSymbolID(POWER_CHAR)));
			}
		}

		if (kBuilding.isPrereqWar())
		{
			if (pCity == NULL || !GET_TEAM(pCity->getTeam()).isAtWar())
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_REQUIRES_WARTIME"));
			}
		}

		int iPrereqPopulation = std::max(kBuilding.getPrereqPopulation(), (pCity != NULL ? pCity->getNumPopulationEmployed() + 1 : 0) + kBuilding.getNumPopulationEmployed());
		if (iPrereqPopulation > 0)
		{
			if (pCity == NULL || pCity->getPopulation() < iPrereqPopulation)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_REQUIRES_POPULATION", iPrereqPopulation));
			}
		}

		if (kBuilding.isRiver() && kBuilding.isWater())
		{
			if (pCity == NULL || !(pCity->plot()->isRiver() || pCity->isCoastal(kBuilding.getMinAreaSize())))
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_REQUIRES_RIVER_OR_COAST"));
			}
		}
		else if (kBuilding.isRiver())
		{
			if (pCity == NULL || !(pCity->plot()->isRiver()))
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_REQUIRES_RIVER"));
			}
		}
		else if (kBuilding.isWater())
		{
			if (pCity == NULL || !(pCity->isCoastal(kBuilding.getMinAreaSize())))
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_REQUIRES_COAST"));
			}
		}
		else if (kBuilding.isFreshWater())
		{
			if (pCity == NULL || !(pCity->plot()->isFreshWater()))
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_REQUIRES_FRESH_WATER"));
			}
		}

		bool bFound = false;
		if (pCity != NULL)
		{
			for (iI = 0; iI < GC.getNumGameSpeedInfos(); iI++)
			{
				if (kBuilding.isPrereqOrGameSpeed(iI))
				{
					if (GC.getGame().getGameSpeedType() == iI)
					{
						bFound = true;
						break;
					}
				}
			}
		}
		if (!bFound)
		{
			bFirst = true;
			for (iI = 0; iI < GC.getNumGameSpeedInfos(); iI++)
			{
				if (kBuilding.isPrereqOrGameSpeed(iI))
				{
					szTempBuffer.Format(L"%s%s", NEWLINE, gDLL->getText("TXT_KEY_REQUIRES").c_str());
					setListHelp(szBuffer, szTempBuffer, GC.getGameSpeedInfo((GameSpeedTypes)iI).getDescription(), gDLL->getText("TXT_KEY_OR").c_str(), bFirst);
					bFirst = false;
				}
			}
		}

		if (kBuilding.getPrereqCultureLevel() != NO_CULTURELEVEL)
		{
			if (pCity == NULL || pCity->getCultureLevel() < kBuilding.getPrereqCultureLevel())
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_REQUIRES_CULTURE", GC.getCultureLevelInfo((CultureLevelTypes)kBuilding.getPrereqCultureLevel()).getDescription()));
			}
		}

		const BuildingTypes ePrereqBuilding = static_cast<BuildingTypes>(GC.getBuildingInfo(eBuilding).getPrereqAnyoneBuilding());
		if (ePrereqBuilding != NO_BUILDING)
		{
			if (pCity == NULL || GC.getGame().getBuildingCreatedCount(ePrereqBuilding) == 0)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_REQUIRES_ANY_BUILDING", GC.getBuildingInfo(ePrereqBuilding).getDescription()));
			}
		}

		bFirst = true;
		bool bValid = false;
		if (pCity != NULL)
		{
			for (iI = 0; iI < GC.getNumBuildingInfos(); ++iI)
			{
				if (kBuilding.isPrereqOrBuilding(iI) && pCity->getNumBuilding((BuildingTypes)iI) > 0)
				{
					bValid = true;
					break;
				}
			}
		}
		if (!bValid)
		{
			for (iI = 0; iI < GC.getNumBuildingInfos(); ++iI)
			{
				if (kBuilding.isPrereqOrBuilding(iI))
				{
					szTempBuffer.Format(L"%s%s", NEWLINE, gDLL->getText("TXT_KEY_REQUIRES").c_str());
					setListHelp(szBuffer, szTempBuffer, GC.getBuildingInfo((BuildingTypes)iI).getDescription(), gDLL->getText("TXT_KEY_OR").c_str(), bFirst);
					bFirst = false;
				}
			}
		}

		bFirst = true;
		for (iI = 0; iI < GC.getNumBuildingInfos(); ++iI)
		{
			if (kBuilding.isPrereqNotBuilding(iI) && (pCity == NULL || pCity->getNumActiveBuilding((BuildingTypes)iI) > 0))
			{
				szFirstBuffer.Format(L"%s%s", NEWLINE, gDLL->getText("TXT_KEY_BUILDING_NOT_REQUIRED_TO_BUILD").c_str());
				szTempBuffer.Format(SETCOLR L"<link=%s>%s</link>" ENDCOLR, TEXT_COLOR("COLOR_BUILDING_TEXT"), CvWString(GC.getBuildingInfo((BuildingTypes)iI).getType()).GetCString(), GC.getBuildingInfo((BuildingTypes)iI).getDescription());
				setListHelp(szBuffer, szFirstBuffer, szTempBuffer, L", ", bFirst);
				bFirst = false;
			}
		}
		bFirst = true;
		for (iTerrainCount = 0; iTerrainCount < GC.getNumTerrainInfos(); ++iTerrainCount)
		{
			if (kBuilding.isPrereqOrTerrain(iTerrainCount))
			{
				szTempBuffer.Format(L"%s%s", NEWLINE, gDLL->getText("TXT_KEY_REQUIRES").c_str());
				setListHelp(szBuffer, szTempBuffer, GC.getTerrainInfo((TerrainTypes(iTerrainCount))).getDescription(), gDLL->getText("TXT_KEY_OR").c_str(), bFirst);
				bFirst = false;
			}
		}
		if (!bFirst)
		{
			szBuffer.append(gDLL->getText("TXT_KEY_IN_CITY_VICINITY"));
		}

		bFirst = true;
		for (iTerrainCount = 0; iTerrainCount < GC.getNumTerrainInfos(); ++iTerrainCount)
		{
			if (kBuilding.isPrereqAndTerrain(iTerrainCount))
			{
				szTempBuffer.Format(L"%s%s", NEWLINE, gDLL->getText("TXT_KEY_REQUIRES").c_str());
				setListHelp(szBuffer, szTempBuffer, GC.getTerrainInfo((TerrainTypes(iTerrainCount))).getDescription(), gDLL->getText("TXT_KEY_AND").c_str(), bFirst);
				bFirst = false;
			}
		}
		if (!bFirst)
		{
			szBuffer.append(gDLL->getText("TXT_KEY_IN_CITY_VICINITY"));
		}

		bFirst = true;
		for (iTerrainCount = 0; iTerrainCount < GC.getNumImprovementInfos(); ++iTerrainCount)
		{
			if (kBuilding.isPrereqOrImprovement(iTerrainCount))
			{
				szTempBuffer.Format(L"%s%s", NEWLINE, gDLL->getText("TXT_KEY_REQUIRES").c_str());
				setListHelp(szBuffer, szTempBuffer, GC.getImprovementInfo((ImprovementTypes(iTerrainCount))).getDescription(), gDLL->getText("TXT_KEY_OR").c_str(), bFirst);
				bFirst = false;
			}
		}
		if (!bFirst)
		{
			szBuffer.append(gDLL->getText("TXT_KEY_IN_CITY_VICINITY"));
		}
		bFirst = true;
		for (iTerrainCount = 0; iTerrainCount < GC.getNumFeatureInfos(); ++iTerrainCount)
		{
			if (kBuilding.isPrereqOrFeature(iTerrainCount))
			{
				szTempBuffer.Format(L"%s%s", NEWLINE, gDLL->getText("TXT_KEY_REQUIRES").c_str());
				setListHelp(szBuffer, szTempBuffer, GC.getFeatureInfo((FeatureTypes(iTerrainCount))).getDescription(), gDLL->getText("TXT_KEY_OR").c_str(), bFirst);
				bFirst = false;
			}
		}
		if (!bFirst)
		{
			szBuffer.append(gDLL->getText("TXT_KEY_IN_CITY_VICINITY"));
		}

		if (pCity != NULL)
		{
			if (GC.getGame().isNoNukes())
			{
				if (kBuilding.isAllowsNukes())
				{
					szBuffer.append(NEWLINE);
					szBuffer.append(gDLL->getText("TXT_KEY_PROJECT_NO_NUKES"));
				}
			}
		}

		BoolExpr* pExpr = kBuilding.getConstructCondition();
		if (pExpr)
		{
			bool bEval = false;
			if (pCity)
			{
				bEval = pExpr->evaluate(const_cast<CvGameObjectCity*>(pCity->getGameObject())); // Const wegcasten ist hier ok da evaluate nicht wirklich etwas ändert
			}
			if (!bEval)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_REQUIRES"));
				szBuffer.append(" ");
				pExpr->buildDisplayString(szBuffer);
			}
		}

		if (bCivilopediaText)
		{
			if (kBuilding.getVictoryPrereq() != NO_VICTORY)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_REQUIRES_VICTORY", GC.getVictoryInfo((VictoryTypes)(kBuilding.getVictoryPrereq())).getTextKeyWide()));
			}

			if (kBuilding.getMaxStartEra() != NO_ERA)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_MAX_START_ERA", GC.getEraInfo((EraTypes)kBuilding.getMaxStartEra()).getTextKeyWide()));
			}

			if (kBuilding.getNumTeamsPrereq() > 0)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_REQUIRES_NUM_TEAMS", kBuilding.getNumTeamsPrereq()));
			}
		}
		else
		{
			if (!bTechChooserText)
			{
				if (kBuilding.getPrereqAndTech() != NO_TECH)
				{
					if (ePlayer == NO_PLAYER || !(GET_TEAM(GET_PLAYER(ePlayer).getTeam()).isHasTech((TechTypes)(kBuilding.getPrereqAndTech()))))
					{
						szBuffer.append(NEWLINE);
						szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_REQUIRES_STRING", CvWString(GC.getTechInfo((TechTypes)(kBuilding.getPrereqAndTech())).getType()).GetCString(), GC.getTechInfo((TechTypes)(kBuilding.getPrereqAndTech())).getTextKeyWide()));
					}
				}
			}

			bFirst = true;

			for (iI = 0; iI < GC.getNUM_BUILDING_AND_TECH_PREREQS(); ++iI)
			{
				if (kBuilding.getPrereqAndTechs(iI) != NO_TECH)
				{
					if (bTechChooserText || ePlayer == NO_PLAYER || !(GET_TEAM(GET_PLAYER(ePlayer).getTeam()).isHasTech((TechTypes)(kBuilding.getPrereqAndTechs(iI)))))
					{
						szTempBuffer.Format(L"%s%s", NEWLINE, gDLL->getText("TXT_KEY_REQUIRES").c_str());
						setListHelp(szBuffer, szTempBuffer, GC.getTechInfo(((TechTypes)(kBuilding.getPrereqAndTechs(iI)))).getDescription(), gDLL->getText("TXT_KEY_AND").c_str(), bFirst);
						bFirst = false;
					}
				}
			}

			if (!bFirst)
			{
				szBuffer.append(ENDCOLR);
			}

			if (kBuilding.getPrereqAndBonus() != NO_BONUS)
			{
				if ((pCity == NULL) || !(pCity->hasBonus((BonusTypes)kBuilding.getPrereqAndBonus())))
				{
					szBuffer.append(NEWLINE);
					szBuffer.append(gDLL->getText("TXT_KEY_UNIT_REQUIRES_STRING", GC.getBonusInfo((BonusTypes)kBuilding.getPrereqAndBonus()).getTextKeyWide()));
				}
			}
			szBonusList.clear();

			bFirst = true;

			for (iI = 0; iI < kBuilding.getNumPrereqOrBonuses(); ++iI)
			{
				if (kBuilding.getPrereqOrBonuses(iI) != NO_BONUS)
				{
					if ((pCity == NULL) || !(pCity->hasBonus((BonusTypes)kBuilding.getPrereqOrBonuses(iI))))
					{
						szTempBuffer.Format(L"%s%s", NEWLINE, gDLL->getText("TXT_KEY_REQUIRES").c_str());
						setListHelp(szBonusList, szTempBuffer, GC.getBonusInfo((BonusTypes)kBuilding.getPrereqOrBonuses(iI)).getDescription(), gDLL->getText("TXT_KEY_OR").c_str(), bFirst);
						bFirst = false;
					}
					else if (NULL != pCity)
					{
						bFirst = true;
						break;
					}
				}
			}

			if (!bFirst)
			{
				szBonusList.append(ENDCOLR);
				szBuffer.append(szBonusList);
			}

			if (NO_CORPORATION != kBuilding.getFoundsCorporation())
			{
				bFirst = true;
				szBonusList.clear();
				for (iI = 0; iI < GC.getNUM_CORPORATION_PREREQ_BONUSES(); ++iI)
				{
					BonusTypes eBonus = (BonusTypes)GC.getCorporationInfo((CorporationTypes)kBuilding.getFoundsCorporation()).getPrereqBonus(iI);
					if (NO_BONUS != eBonus)
					{
						if ((pCity == NULL) || !(pCity->hasBonus(eBonus)))
						{
							szFirstBuffer.Format(L"%s%s", NEWLINE, gDLL->getText("TXT_KEY_REQUIRES").c_str());
							szTempBuffer.Format(L"<link=%s>%s</link>", CvWString(GC.getBonusInfo(eBonus).getType()).GetCString(), GC.getBonusInfo(eBonus).getDescription());
							setListHelp(szBonusList, szFirstBuffer, szTempBuffer, gDLL->getText("TXT_KEY_OR"), bFirst);
							bFirst = false;
						}
						else if (NULL != pCity)
						{
							bFirst = true;
							break;
						}
					}
				}

				if (!bFirst)
				{
					szBonusList.append(ENDCOLR);
					szBuffer.append(szBonusList);
				}
			}
		}
	}
}

void CvGameTextMgr::setProductionDecayHelp(CvWStringBuffer &szBuffer, int iTurnsLeft, int iThreshold, int iDecay, bool bProducing)
{
	if (iTurnsLeft <= 1)
	{
		if (bProducing)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_PRODUCTION_DECAY_PRODUCING", iDecay));
		}
		else
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_PRODUCTION_DECAY", iDecay));
		}
	}
	else if (iTurnsLeft <= iThreshold)
	{
		if (bProducing)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_PRODUCTION_DECAY_TURNS_PRODUCING", iDecay, iTurnsLeft));
		}
		else
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_PRODUCTION_DECAY_TURNS", iDecay, iTurnsLeft));
		}
	}
}

void CvGameTextMgr::setProjectHelp(CvWStringBuffer &szBuffer, ProjectTypes eProject, bool bCivilopediaText, CvCity* pCity)
{
	PROFILE_FUNC();

	CvWString szTempBuffer;
	CvWString szFirstBuffer;
	PlayerTypes ePlayer;
	bool bFirst;
	int iProduction;
	int iI;

	if (NO_PROJECT == eProject)
	{
		return;
	}

	const CvProjectInfo& kProject = GC.getProjectInfo(eProject);

	if (pCity != NULL)
	{
		ePlayer = pCity->getOwner();
	}
	else
	{
		ePlayer = GC.getGame().getActivePlayer();
	}

	if (!bCivilopediaText)
	{
		szTempBuffer.Format( SETCOLR L"<link=%s>%s</link>" ENDCOLR , TEXT_COLOR("COLOR_PROJECT_TEXT"), CvWString(kProject.getType()).GetCString(), kProject.getDescription());
		szBuffer.append(szTempBuffer);

		if (isWorldProject(eProject))
		{
			if (pCity == NULL)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_PROJECT_WORLD_NUM_ALLOWED", kProject.getMaxGlobalInstances()));
			}
			else
			{
				szBuffer.append(gDLL->getText("TXT_KEY_PROJECT_WORLD_NUM_LEFT", (kProject.getMaxGlobalInstances() - GC.getGame().getProjectCreatedCount(eProject) - GET_TEAM(GET_PLAYER(ePlayer).getTeam()).getProjectMaking(eProject))));
			}
		}

		if (isTeamProject(eProject))
		{
			if (pCity == NULL)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_PROJECT_TEAM_NUM_ALLOWED", kProject.getMaxTeamInstances()));
			}
			else
			{
				szBuffer.append(gDLL->getText("TXT_KEY_PROJECT_TEAM_NUM_LEFT", (kProject.getMaxTeamInstances() - GET_TEAM(GET_PLAYER(ePlayer).getTeam()).getProjectCount(eProject) - GET_TEAM(GET_PLAYER(ePlayer).getTeam()).getProjectMaking(eProject))));
			}
		}
	}

	if (kProject.getNukeInterception() != 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROJECT_CHANCE_INTERCEPT_NUKES", kProject.getNukeInterception()));
	}

	if (kProject.getTechShare() != 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROJECT_TECH_SHARE", kProject.getTechShare()));
	}
	//DPII < Maintenance Modifiers >
	if (kProject.getGlobalMaintenanceModifier() != 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROJECT_GLOBAL_MAINT_MOD", kProject.getGlobalMaintenanceModifier()));
	}

	if (kProject.getDistanceMaintenanceModifier() != 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROJECT_DISTANCE_MAINT_MOD", kProject.getDistanceMaintenanceModifier()));
	}

	if (kProject.getNumCitiesMaintenanceModifier() != 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROJECT_NUM_CITIES_MAINT_MOD", kProject.getNumCitiesMaintenanceModifier()));
	}
	//DPII < Maintenance Modifiers >
	if (kProject.isAllowsNukes())
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROJECT_ENABLES_NUKES"));
	}

	if (kProject.getEveryoneSpecialUnit() != NO_SPECIALUNIT)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROJECT_ENABLES_SPECIAL", GC.getSpecialUnitInfo((SpecialUnitTypes)(kProject.getEveryoneSpecialUnit())).getTextKeyWide()));
	}

	if (kProject.getEveryoneSpecialBuilding() != NO_SPECIALBUILDING)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROJECT_ENABLES_SPECIAL", GC.getSpecialBuildingInfo((SpecialBuildingTypes)(kProject.getEveryoneSpecialBuilding())).getTextKeyWide()));
	}

	if (kProject.getWorldHappiness() > 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROJECT_WORLD_HAPPINESS", kProject.getWorldHappiness()));
	}

	else if (kProject.getWorldHappiness() < 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROJECT_WORLD_UNHAPPINESS", -kProject.getWorldHappiness()));
	}

	if (kProject.getWorldHealth() > 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROJECT_WORLD_HEALTH", kProject.getWorldHealth()));
	}

	else if (kProject.getWorldHealth() < 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROJECT_WORLD_UNHEALTH", -kProject.getWorldHealth()));
	}

	if (kProject.getGlobalHappiness() > 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROJECT_HAPPINESS", kProject.getGlobalHappiness()));
	}

	else if (kProject.getGlobalHappiness() < 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROJECT_UNHAPPINESS", -kProject.getGlobalHappiness()));
	}

	if (kProject.getGlobalHealth() > 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROJECT_HEALTH", kProject.getGlobalHealth()));
	}

	else if (kProject.getGlobalHealth() < 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROJECT_UNHEALTH", -kProject.getGlobalHealth()));
	}

	if (kProject.getWorldTradeRoutes() > 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_MORE_WORLD_TRADE", kProject.getWorldTradeRoutes()));
	}
	else if (kProject.getWorldTradeRoutes() < 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_LESS_WORLD_TRADE", -kProject.getWorldTradeRoutes()));
	}

	if (kProject.getInflationModifier() != 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_ADJUSTS_INFLATION", kProject.getInflationModifier()));
	}

	setCommerceChangeHelp(szBuffer, L"", L"", gDLL->getText("TXT_KEY_BUILDING_ALL_CITIES").c_str(), kProject.getCommerceModifierArray(), true);

	for (iI = 0; iI < GC.getNumVictoryInfos(); ++iI)
	{
		if (kProject.getVictoryThreshold(iI) > 0)
		{
			if (kProject.getVictoryThreshold(iI) == kProject.getVictoryMinThreshold(iI))
			{
				szTempBuffer.Format(L"%d", kProject.getVictoryThreshold(iI));
			}
			else
			{
				szTempBuffer.Format(L"%d-%d", kProject.getVictoryMinThreshold(iI), kProject.getVictoryThreshold(iI));
			}

			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_PROJECT_REQUIRED_FOR_VICTORY", szTempBuffer.GetCString(), GC.getVictoryInfo((VictoryTypes)iI).getTextKeyWide()));
		}
	}

	bFirst = true;

	for (iI = 0; iI < GC.getNumProjectInfos(); ++iI)
	{
		if (GC.getProjectInfo((ProjectTypes)iI).getAnyoneProjectPrereq() == eProject)
		{
			szFirstBuffer.Format(L"%s%s", NEWLINE, gDLL->getText("TXT_KEY_PROJECT_REQUIRED_TO_CREATE_ANYONE").c_str());
			szTempBuffer.Format(SETCOLR L"<link=%s>%s</link>" ENDCOLR, TEXT_COLOR("COLOR_PROJECT_TEXT"), CvWString(GC.getProjectInfo((ProjectTypes)iI).getType()).GetCString(), GC.getProjectInfo((ProjectTypes)iI).getDescription());
			setListHelp(szBuffer, szFirstBuffer, szTempBuffer, L", ", bFirst);
			bFirst = false;
		}
	}

	bFirst = true;

	for (iI = 0; iI < GC.getNumProjectInfos(); ++iI)
	{
		if (GC.getProjectInfo((ProjectTypes)iI).getProjectsNeeded(eProject) > 0)
		{
			if ((pCity == NULL) || pCity->canCreate(((ProjectTypes)iI), false, true))
			{
				szFirstBuffer.Format(L"%s%s", NEWLINE, gDLL->getText("TXT_KEY_PROJECT_REQUIRED_TO_CREATE").c_str());
				szTempBuffer.Format(SETCOLR L"<link=%s>%s</link>" ENDCOLR, TEXT_COLOR("COLOR_PROJECT_TEXT"), CvWString(GC.getProjectInfo((ProjectTypes)iI).getType()).GetCString(), GC.getProjectInfo((ProjectTypes)iI).getDescription());
				setListHelp(szBuffer, szFirstBuffer, szTempBuffer, L", ", bFirst);
				bFirst = false;
			}
		}
	}

	if ((pCity == NULL) || !(pCity->canCreate(eProject)))
	{
		if (pCity != NULL)
		{
			if (GC.getGame().isNoNukes())
			{
				if (kProject.isAllowsNukes())
				{
					szBuffer.append(NEWLINE);
					szBuffer.append(gDLL->getText("TXT_KEY_PROJECT_NO_NUKES"));
				}
			}
		}

		if (kProject.getAnyoneProjectPrereq() != NO_PROJECT)
		{
			if ((pCity == NULL) || (GC.getGame().getProjectCreatedCount((ProjectTypes)(kProject.getAnyoneProjectPrereq())) == 0))
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_PROJECT_REQUIRES_ANYONE", CvWString(GC.getProjectInfo((ProjectTypes)kProject.getAnyoneProjectPrereq()).getType()).GetCString(), GC.getProjectInfo((ProjectTypes)kProject.getAnyoneProjectPrereq()).getTextKeyWide()));
			}
		}

		for (iI = 0; iI < GC.getNumProjectInfos(); ++iI)
		{
			if (kProject.getProjectsNeeded(iI) > 0)
			{
				if ((pCity == NULL) || (GET_TEAM(GET_PLAYER(ePlayer).getTeam()).getProjectCount((ProjectTypes)iI) < kProject.getProjectsNeeded(iI)))
				{
					if (pCity != NULL)
					{
						szBuffer.append(NEWLINE);
						szBuffer.append(gDLL->getText("TXT_KEY_PROJECT_REQUIRES", CvWString(GC.getProjectInfo((ProjectTypes)iI).getType()).GetCString(), GC.getProjectInfo((ProjectTypes)iI).getTextKeyWide(), GET_TEAM(GET_PLAYER(ePlayer).getTeam()).getProjectCount((ProjectTypes)iI), kProject.getProjectsNeeded(iI)));
					}
					else
					{
						szBuffer.append(NEWLINE);
						szBuffer.append(gDLL->getText("TXT_KEY_PROJECT_REQUIRES_NO_CITY", CvWString(GC.getProjectInfo((ProjectTypes)iI).getType()).GetCString(), GC.getProjectInfo((ProjectTypes)iI).getTextKeyWide(), kProject.getProjectsNeeded(iI)));
					}
				}
			}
		}

		if (bCivilopediaText)
		{
			if (kProject.getVictoryPrereq() != NO_VICTORY)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_PROJECT_REQUIRES_STRING_VICTORY", GC.getVictoryInfo((VictoryTypes)(kProject.getVictoryPrereq())).getTextKeyWide()));
			}
		}
	}

	if (!bCivilopediaText)
	{
		if (pCity == NULL)
		{
			if (ePlayer != NO_PLAYER)
			{
				szTempBuffer.Format(L"\n%d%c", GET_PLAYER(ePlayer).getProductionNeeded(eProject), GC.getYieldInfo(YIELD_PRODUCTION).getChar());
			}
			else
			{
				szTempBuffer.Format(L"\n%d%c", kProject.getProductionCost(), GC.getYieldInfo(YIELD_PRODUCTION).getChar());
			}
			szBuffer.append(szTempBuffer);
		}
		else
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_PROJECT_NUM_TURNS", pCity->getProductionTurnsLeft(eProject, ((gDLL->ctrlKey() || !(gDLL->shiftKey())) ? 0 : pCity->getOrderQueueLength()))));

			iProduction = pCity->getProjectProduction(eProject);

			if (iProduction > 0)
			{
				szTempBuffer.Format(L" - %d/%d%c", iProduction, pCity->getProductionNeeded(eProject), GC.getYieldInfo(YIELD_PRODUCTION).getChar());
			}
			else
			{
				szTempBuffer.Format(L" - %d%c", pCity->getProductionNeeded(eProject), GC.getYieldInfo(YIELD_PRODUCTION).getChar());
			}
			szBuffer.append(szTempBuffer);
		}
	}

	for (iI = 0; iI < GC.getNumBonusInfos(); ++iI)
	{
		if (kProject.getBonusProductionModifier(iI) != 0)
		{
			if (pCity != NULL)
			{
				if (pCity->hasBonus((BonusTypes)iI))
				{
					szBuffer.append(gDLL->getText("TXT_KEY_COLOR_POSITIVE"));
				}
				else
				{
					szBuffer.append(gDLL->getText("TXT_KEY_COLOR_NEGATIVE"));
				}
			}
			if (!bCivilopediaText)
			{
				szBuffer.append(L" (");
			}
			else
			{
				szTempBuffer.Format(L"%s%c", NEWLINE, gDLL->getSymbolID(BULLET_CHAR), szTempBuffer.c_str());
				szBuffer.append(szTempBuffer);
			}
			if (kProject.getBonusProductionModifier(iI) == 100)
			{
				szBuffer.append(gDLL->getText("TXT_KEY_PROJECT_DOUBLE_SPEED_WITH", CvWString(GC.getBonusInfo((BonusTypes)iI).getType()).GetCString(), GC.getBonusInfo((BonusTypes)iI).getTextKeyWide()));
			}
			else
			{
				szBuffer.append(gDLL->getText("TXT_KEY_PROJECT_BUILDS_FASTER_WITH", kProject.getBonusProductionModifier(iI), CvWString(GC.getBonusInfo((BonusTypes)iI).getType()).GetCString(), GC.getBonusInfo((BonusTypes)iI).getTextKeyWide()));
			}
			if (!bCivilopediaText)
			{
				szBuffer.append(L')');
			}
			if (pCity != NULL)
			{
				szBuffer.append(gDLL->getText("TXT_KEY_COLOR_REVERT"));
			}
		}
	}
}


void CvGameTextMgr::setProcessHelp(CvWStringBuffer &szBuffer, ProcessTypes eProcess)
{
	int iI;

	szBuffer.append(GC.getProcessInfo(eProcess).getDescription());

	for (iI = 0; iI < NUM_COMMERCE_TYPES; ++iI)
	{
		if (GC.getProcessInfo(eProcess).getProductionToCommerceModifier(iI) != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_PROCESS_CONVERTS", GC.getProcessInfo(eProcess).getProductionToCommerceModifier(iI), GC.getYieldInfo(YIELD_PRODUCTION).getChar(), GC.getCommerceInfo((CommerceTypes) iI).getChar()));
		}
	}
}

void CvGameTextMgr::setBadHealthHelp(CvWStringBuffer &szBuffer, CvCity& city)
{
	CvPlot* pLoopPlot;
	FeatureTypes eFeature;
	int iHealth;
	int iI;

	if (city.badHealth() > 0)
	{
		iHealth = -(city.getFreshWaterBadHealth());
		if (iHealth > 0)
		{
			szBuffer.append(gDLL->getText("TXT_KEY_MISC_FROM_FRESH_WATER", iHealth));
			szBuffer.append(NEWLINE);
		}

		iHealth = -(city.getFeatureBadHealth());
		if (iHealth > 0)
		{
			eFeature = NO_FEATURE;

			for (iI = 0; iI < NUM_CITY_PLOTS; ++iI)
			{
				pLoopPlot = plotCity(city.getX(), city.getY(), iI);

				if (pLoopPlot != NULL)
				{
					if (pLoopPlot->getFeatureType() != NO_FEATURE)
					{
						if (GC.getFeatureInfo(pLoopPlot->getFeatureType()).getHealthPercent() < 0)
						{
							if (eFeature == NO_FEATURE)
							{
								eFeature = pLoopPlot->getFeatureType();
							}
							else if (eFeature != pLoopPlot->getFeatureType())
							{
								eFeature = NO_FEATURE;
								break;
							}
						}
					}
				}
			}

			szBuffer.append(gDLL->getText("TXT_KEY_MISC_FEAT_HEALTH", iHealth, ((eFeature == NO_FEATURE) ? L"TXT_KEY_MISC_FEATURES" : GC.getFeatureInfo(eFeature).getTextKeyWide())));
			szBuffer.append(NEWLINE);
		}

/************************************************************************************************/
/* JOOYO_ADDON, Added by Jooyo, 06/19/09														*/
/*																							  */
/*																							  */
/************************************************************************************************/
		iHealth = -(city.getImprovementBadHealth()) / 100;
		CvPlayer &kPlayer = GET_PLAYER(city.getOwner());
		if (iHealth > 0)
		{
			ImprovementTypes eImprovement = NO_IMPROVEMENT;
			int iTotalHealth;
			int iBestHealth = 0;
			for (int iI = 0; iI < GC.getNumImprovementInfos(); iI++)
			{
				iTotalHealth = 0;

				if (GC.getImprovementInfo((ImprovementTypes)iI).getHealthPercent() < 0)
				{
					for (int iJ = 0; iJ < city.getNumCityPlots(); ++iJ)
					{
						pLoopPlot = plotCity(city.getX(), city.getY(), iJ);

						if (pLoopPlot != NULL)
						{
							if (pLoopPlot->getImprovementType() == iI)
							{
								iTotalHealth -= GC.getImprovementInfo((ImprovementTypes)iI).getHealthPercent();
								for (int iK = 0; iK < GC.getNumCivicOptionInfos(); iK++)
								{
									if (kPlayer.getCivics((CivicOptionTypes)iK) != NO_CIVIC)
									{
										iTotalHealth -= std::min(0, GC.getCivicInfo(kPlayer.getCivics((CivicOptionTypes)iK)).getImprovementHealthPercentChanges(iI)) / 100;
									}
								}
							}
						}
					}
				}
				if (iTotalHealth > iBestHealth)
				{
					eImprovement = (ImprovementTypes)iI;
					iBestHealth = iTotalHealth;
				}
			}

			szBuffer.append(gDLL->getText("TXT_KEY_MISC_IMPR_HEALTH", iHealth, ((eImprovement == NO_IMPROVEMENT) ? L"TXT_KEY_MISC_IMPROVEMENTS" : GC.getImprovementInfo(eImprovement).getTextKeyWide())));
			szBuffer.append(NEWLINE);
		}
/************************************************************************************************/
/* JOOYO_ADDON						  END													 */
/************************************************************************************************/

/************************************************************************************************/
/* Specialists Enhancements, by Supercheese 10/9/09												   */
/*																							  */
/*																							  */
/************************************************************************************************/
		iHealth = -(city.getSpecialistBadHealth() / 100);
		if (iHealth > 0)
		{
			szBuffer.append(gDLL->getText("TXT_KEY_BAD_HEALTH_FROM_SPECIALISTS", iHealth));
			szBuffer.append(NEWLINE);
		}
/************************************************************************************************/
/* Specialists Enhancements						  END											  */
/************************************************************************************************/

		iHealth = city.getEspionageHealthCounter();
		if (iHealth > 0)
		{
			szBuffer.append(gDLL->getText("TXT_KEY_MISC_HEALTH_FROM_ESPIONAGE", iHealth));
			szBuffer.append(NEWLINE);
		}

		iHealth = -(city.getPowerBadHealth());
		if (iHealth > 0)
		{
			szBuffer.append(gDLL->getText("TXT_KEY_MISC_HEALTH_FROM_POWER", iHealth));
			szBuffer.append(NEWLINE);
		}

		iHealth = -(city.getBonusBadHealth());
		if (iHealth > 0)
		{
			szBuffer.append(gDLL->getText("TXT_KEY_MISC_HEALTH_FROM_BONUSES", iHealth));
			szBuffer.append(NEWLINE);
		}

		iHealth = -(city.totalBadBuildingHealth());
		if (iHealth > 0)
		{
			szBuffer.append(gDLL->getText("TXT_KEY_MISC_HEALTH_FROM_BUILDINGS", iHealth));
			szBuffer.append(NEWLINE);
		}

		iHealth = -GET_PLAYER(city.getOwner()).getCivicHealth();
		if (iHealth > 0)
		{
			szBuffer.append(gDLL->getText("TXT_KEY_MISC_BAD_HEALTH_FROM_CIVICS", iHealth));
			szBuffer.append(NEWLINE);
		}
		iHealth = -GET_PLAYER(city.getOwner()).getCivilizationHealth();

		if (iHealth > 0)
		{
			szBuffer.append(gDLL->getText("TXT_KEY_MISC_HEALTH_FROM_CIV", iHealth));
			szBuffer.append(NEWLINE);
		}

		//	Koshling - event health
		iHealth = -GET_PLAYER(city.getOwner()).getExtraHealth() + GET_PLAYER(city.getOwner()).getCivicHealth();
		if (iHealth > 0)
		{
			szBuffer.append(gDLL->getText("TXT_KEY_MISC_BAD_HEALTH_FROM_EVENTS", iHealth));
			szBuffer.append(NEWLINE);
		}

		iHealth = -city.getExtraHealth();
		if (iHealth > 0)
		{
			szBuffer.append(gDLL->getText("TXT_KEY_MISC_UNHEALTH_EXTRA", iHealth));
			szBuffer.append(NEWLINE);
		}

		if ( GC.getGame().getHandicapType() != NO_HANDICAP )
		{
			iHealth = -(GC.getHandicapInfo(city.getHandicapType()).getHealthBonus());
			if (iHealth > 0)
			{
				szBuffer.append(gDLL->getText("TXT_KEY_MISC_HEALTH_FROM_HANDICAP", iHealth));
				szBuffer.append(NEWLINE);
			}
		}

		iHealth = city.unhealthyPopulation();
		if (iHealth > 0)
		{
			szBuffer.append(gDLL->getText("TXT_KEY_MISC_HEALTH_FROM_POP", iHealth));
			szBuffer.append(NEWLINE);
		}

		iHealth = -(GET_PLAYER(city.getOwner()).getWorldHealth());
		if (iHealth > 0)
		{
			szBuffer.append(gDLL->getText("TXT_KEY_MISC_HEALTH_FROM_WORLD_PROJECT", iHealth));
			szBuffer.append(NEWLINE);
		}

		iHealth = -(GET_PLAYER(city.getOwner()).getProjectHealth());
		if (iHealth > 0)
		{
			szBuffer.append(gDLL->getText("TXT_KEY_MISC_HEALTH_FROM_PROJECT", iHealth));
			szBuffer.append(NEWLINE);
		}
		iHealth = -city.calculateCorporationHealth();
		if (iHealth > 0)
		{
			szBuffer.append(gDLL->getText("TXT_KEY_MISC_HEALTH_FROM_CORPORATION", iHealth));
			szBuffer.append(NEWLINE);
		}

		iHealth = city.getExtraTechUnHealthTotal();
		if (iHealth > 0)
		{
			szBuffer.append(gDLL->getText("TXT_KEY_UNHEALTHY_TECH_SPECIALIST", iHealth));
			szBuffer.append(NEWLINE);
		}
		szBuffer.append(L"-----------------------\n");
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_TOTAL_UNHEALTHY", city.badHealth()));
	}
}

void CvGameTextMgr::setGoodHealthHelp(CvWStringBuffer &szBuffer, CvCity& city)
{
	CvPlot* pLoopPlot;
	FeatureTypes eFeature;
	int iHealth;
	int iI;

	if (city.goodHealth() > 0)
	{
		iHealth = city.getFreshWaterGoodHealth();
		if (iHealth > 0)
		{
			szBuffer.append(gDLL->getText("TXT_KEY_MISC_HEALTH_FROM_FRESH_WATER", iHealth));
			szBuffer.append(NEWLINE);
		}

		iHealth = city.getFeatureGoodHealth();
		if (iHealth > 0)
		{
			eFeature = NO_FEATURE;

			for (iI = 0; iI < NUM_CITY_PLOTS; ++iI)
			{
				pLoopPlot = plotCity(city.getX(), city.getY(), iI);

				if (pLoopPlot != NULL)
				{
					if (pLoopPlot->getFeatureType() != NO_FEATURE)
					{
						if (GC.getFeatureInfo(pLoopPlot->getFeatureType()).getHealthPercent() > 0)
						{
							if (eFeature == NO_FEATURE)
							{
								eFeature = pLoopPlot->getFeatureType();
							}
							else if (eFeature != pLoopPlot->getFeatureType())
							{
								eFeature = NO_FEATURE;
								break;
							}
						}
					}
				}
			}

			szBuffer.append(gDLL->getText("TXT_KEY_MISC_FEAT_GOOD_HEALTH", iHealth, ((eFeature == NO_FEATURE) ? L"TXT_KEY_MISC_FEATURES" : GC.getFeatureInfo(eFeature).getTextKeyWide())));
			szBuffer.append(NEWLINE);
		}
		iHealth = city.getImprovementGoodHealth() / 100;
		CvPlayer &kPlayer = GET_PLAYER(city.getOwner());
		if (iHealth > 0)
		{
			ImprovementTypes eImprovement = NO_IMPROVEMENT;
			int iTotalHealth;
			int iBestHealth = 0;
			for (int iI = 0; iI < GC.getNumImprovementInfos(); iI++)
			{
				iTotalHealth = 0;

				if (GC.getImprovementInfo((ImprovementTypes)iI).getHealthPercent() > 0)
				{
					for (int iJ = 0; iJ < city.getNumCityPlots(); ++iJ)
					{
						pLoopPlot = plotCity(city.getX(), city.getY(), iJ);

						if (pLoopPlot != NULL)
						{
							if (pLoopPlot->getImprovementType() == iI)
							{
								iTotalHealth += GC.getImprovementInfo((ImprovementTypes)iI).getHealthPercent();
								for (int iK = 0; iK < GC.getNumCivicOptionInfos(); iK++)
								{
									if (kPlayer.getCivics((CivicOptionTypes)iK) != NO_CIVIC)
									{
										iTotalHealth += std::max(0, GC.getCivicInfo(kPlayer.getCivics((CivicOptionTypes)iK)).getImprovementHealthPercentChanges(iI)) / 100;
									}
								}
							}
						}
					}
				}
				if (iTotalHealth > iBestHealth)
				{
					eImprovement = (ImprovementTypes)iI;
					iBestHealth = iTotalHealth;
				}
			}
			szBuffer.append(gDLL->getText("TXT_KEY_MISC_IMPR_GOOD_HEALTH", iHealth, ((eImprovement == NO_IMPROVEMENT) ? L"TXT_KEY_MISC_IMPROVEMENTS" : GC.getImprovementInfo(eImprovement).getTextKeyWide())));
			szBuffer.append(NEWLINE);
		}
		iHealth = city.getSpecialistGoodHealth() / 100;
		if (iHealth > 0)
		{
			szBuffer.append(gDLL->getText("TXT_KEY_GOOD_HEALTH_FROM_SPECIALISTS", iHealth));
			szBuffer.append(NEWLINE);
		}

		iHealth = city.getPowerGoodHealth();
		if (iHealth > 0)
		{
			szBuffer.append(gDLL->getText("TXT_KEY_MISC_GOOD_HEALTH_FROM_POWER", iHealth));
			szBuffer.append(NEWLINE);
		}

		iHealth = city.getBonusGoodHealth();
		if (iHealth > 0)
		{
			szBuffer.append(gDLL->getText("TXT_KEY_MISC_GOOD_HEALTH_FROM_BONUSES", iHealth));
			szBuffer.append(NEWLINE);
		}

		iHealth = city.totalGoodBuildingHealth();
		if (iHealth > 0)
		{
			szBuffer.append(gDLL->getText("TXT_KEY_MISC_GOOD_HEALTH_FROM_BUILDINGS", iHealth));
			szBuffer.append(NEWLINE);
		}

		iHealth = GET_PLAYER(city.getOwner()).getCivicHealth();
		if (iHealth > 0)
		{
			szBuffer.append(gDLL->getText("TXT_KEY_MISC_GOOD_HEALTH_FROM_CIVICS", iHealth));
			szBuffer.append(NEWLINE);
		}
		iHealth = GET_PLAYER(city.getOwner()).getCivilizationHealth();

		if (iHealth > 0)
		{
			szBuffer.append(gDLL->getText("TXT_KEY_MISC_GOOD_HEALTH_FROM_CIV", iHealth));
			szBuffer.append(NEWLINE);
		}

		//	Koshling - event health
		iHealth = GET_PLAYER(city.getOwner()).getExtraHealth() - GET_PLAYER(city.getOwner()).getCivicHealth();
		if (iHealth > 0)
		{
			szBuffer.append(gDLL->getText("TXT_KEY_MISC_GOOD_HEALTH_FROM_EVENTS", iHealth));
			szBuffer.append(NEWLINE);
		}

		iHealth = city.getExtraHealth();
		if (iHealth > 0)
		{
			szBuffer.append(gDLL->getText("TXT_KEY_MISC_HEALTH_EXTRA", iHealth));
			szBuffer.append(NEWLINE);
		}

		if ( GC.getGame().getHandicapType() != NO_HANDICAP )
		{
			iHealth = GC.getHandicapInfo(city.getHandicapType()).getHealthBonus();
			if (iHealth > 0)
			{
				szBuffer.append(gDLL->getText("TXT_KEY_MISC_GOOD_HEALTH_FROM_HANDICAP", iHealth));
				szBuffer.append(NEWLINE);
			}
		}
		iHealth = (GET_PLAYER(city.getOwner()).getWorldHealth());
		if (iHealth > 0)
		{
			szBuffer.append(gDLL->getText("TXT_KEY_MISC_GOOD_HEALTH_FROM_WORLD_PROJECT", iHealth));
			szBuffer.append(NEWLINE);
		}

		iHealth = (GET_PLAYER(city.getOwner()).getProjectHealth());
		if (iHealth > 0)
		{
			szBuffer.append(gDLL->getText("TXT_KEY_MISC_GOOD_HEALTH_FROM_PROJECT", iHealth));
			szBuffer.append(NEWLINE);
		}

		iHealth = city.calculateCorporationHealth();
		if (iHealth > 0)
		{
			szBuffer.append(gDLL->getText("TXT_KEY_MISC_GOOD_HEALTH_FROM_CORPORATION", iHealth));
			szBuffer.append(NEWLINE);
		}

		iHealth = city.getExtraTechHealthTotal();
		if (iHealth > 0)
		{
			szBuffer.append(gDLL->getText("TXT_KEY_HEALTHY_TECH_SPECIALIST", iHealth));
			szBuffer.append(NEWLINE);
		}

		szBuffer.append(L"-----------------------\n");

		szBuffer.append(gDLL->getText("TXT_KEY_MISC_TOTAL_HEALTHY", city.goodHealth()));
	}
}


bool CvGameTextMgr::setBuildingAdditionalHealthHelp(CvWStringBuffer &szBuffer, CvCity& city, const CvWString& szStart, bool bStarted)
{
	for (int iI = 0; iI < GC.getNumBuildingInfos(); iI++)
	{
		const BuildingTypes eBuilding = static_cast<BuildingTypes>(iI);

		if (city.canConstruct(eBuilding, false, false, false))
		{
			int iGood = 0, iBad = 0, iSpoiledFood = 0, iStarvation = 0;
			const int iChange = city.getAdditionalHealthByBuilding(eBuilding, iGood, iBad, iSpoiledFood, iStarvation);

			if (iGood != 0 || iBad != 0)
			{
				if (!bStarted)
				{
					szBuffer.append(szStart);
					bStarted = true;
				}

				CvWString szLabel;
				szLabel.Format(SETCOLR L"%s" ENDCOLR, TEXT_COLOR("COLOR_BUILDING_TEXT"), GC.getBuildingInfo(eBuilding).getDescription());
				const bool bStartedLine = setResumableGoodBadChangeHelp(szBuffer, szLabel, L": ", L"", iGood, gDLL->getSymbolID(HEALTHY_CHAR), iBad, gDLL->getSymbolID(UNHEALTHY_CHAR), false, true);
				setResumableValueChangeHelp(szBuffer, szLabel, L": ", L"", iSpoiledFood, gDLL->getSymbolID(EATEN_FOOD_CHAR), false, true, bStartedLine);
				setResumableValueChangeHelp(szBuffer, szLabel, L": ", L"", iStarvation, gDLL->getSymbolID(BAD_FOOD_CHAR), false, true, bStartedLine);
			}
		}
	}

	return bStarted;
}


void CvGameTextMgr::parseHappinessHelp(CvWStringBuffer &szBuffer)
{
	CvCity* pHeadSelectedCity = gDLL->getInterfaceIFace()->getHeadSelectedCity();

	if (pHeadSelectedCity != NULL)
	{
		setAngerHelp(szBuffer, *pHeadSelectedCity);
		szBuffer.append(L"\n=======================\n");
		setHappyHelp(szBuffer, *pHeadSelectedCity);

		if (pHeadSelectedCity->getOwner() == GC.getGame().getActivePlayer() && getBugOptionBOOL("MiscHover__BuildingAdditionalHappiness", true, "BUG_BUILDING_ADDITIONAL_HAPPINESS_HOVER"))
		{
			setBuildingAdditionalHappinessHelp(szBuffer, *pHeadSelectedCity, DOUBLE_SEPARATOR);
		}
	}
}

void CvGameTextMgr::setAngerHelp(CvWStringBuffer &szBuffer, CvCity& city)
{
	if (city.isOccupation())
	{
		szBuffer.append(gDLL->getText("TXT_KEY_ANGER_RESISTANCE"));
		return;
	}
	CvPlayer& kPlayer = GET_PLAYER(city.getOwner());

	if (kPlayer.isAnarchy())
	{
		szBuffer.append(gDLL->getText("TXT_KEY_ANGER_ANARCHY"));
		return;
	}
	if (city.unhappyLevel() < 1)
	{
		return;
	}
	int iPop = city.getPopulation();
	int iDivisor = GC.getPERCENT_ANGER_DIVISOR();
	int iTotal = 0;

	int iAnger = city.getOvercrowdingPercentAnger() * iPop / iDivisor;
	if (iAnger > 0)
	{
		szBuffer.append(gDLL->getText("TXT_KEY_ANGER_OVERCROWDING", iAnger));
		szBuffer.append(NEWLINE);
		iTotal += iAnger;
	}

	iAnger = city.getNoMilitaryPercentAnger() * iPop / iDivisor;
	if (iAnger > 0)
	{
		szBuffer.append(gDLL->getText("TXT_KEY_ANGER_MILITARY_PROTECTION", iAnger));
		szBuffer.append(NEWLINE);
		iTotal += iAnger;
	}

	iAnger = city.getCulturePercentAnger() * iPop / iDivisor;
	if (iAnger > 0)
	{
		szBuffer.append(gDLL->getText("TXT_KEY_ANGER_OCCUPIED", iAnger));
		szBuffer.append(NEWLINE);
		iTotal += iAnger;
	}

	iAnger = city.getReligionPercentAnger() * iPop / iDivisor;
	if (iAnger > 0)
	{
		szBuffer.append(gDLL->getText("TXT_KEY_ANGER_RELIGION_FIGHT", iAnger));
		szBuffer.append(NEWLINE);
		iTotal += iAnger;
	}

	iAnger = (city.getHurryPercentAnger() + city.getEventAnger()) * iPop / iDivisor;
	if (iAnger > 0)
	{
		szBuffer.append(gDLL->getText("TXT_KEY_ANGER_OPPRESSION", iAnger));
		szBuffer.append(NEWLINE);
		iTotal += iAnger;
	}

	iAnger = city.getRevRequestPercentAnger() * iPop / iDivisor;
	if (iAnger > 0)
	{
		szBuffer.append(gDLL->getText("TXT_KEY_REV_REQUEST_ANGER", iAnger));
		szBuffer.append(NEWLINE);
		iTotal += iAnger;
	}

	iAnger = city.getRevIndexPercentAnger() * iPop / iDivisor;
	if (iAnger > 0)
	{
		szBuffer.append(gDLL->getText("TXT_KEY_REV_INDEX_ANGER", iAnger));
		szBuffer.append(NEWLINE);
		iTotal += iAnger;
	}

	iAnger = city.getConscriptPercentAnger() * iPop / iDivisor;
	if (iAnger > 0)
	{
		szBuffer.append(gDLL->getText("TXT_KEY_ANGER_DRAFT", iAnger));
		szBuffer.append(NEWLINE);
		iTotal += iAnger;
	}

	iAnger = city.getDefyResolutionPercentAnger() * iPop / iDivisor;
	if (iAnger > 0)
	{
		szBuffer.append(gDLL->getText("TXT_KEY_ANGER_DEFY_RESOLUTION", iAnger));
		szBuffer.append(NEWLINE);
		iTotal += iAnger;
	}

	iAnger = city.getWarWearinessPercentAnger() * iPop / iDivisor;
	if (iAnger > 0)
	{
		szBuffer.append(gDLL->getText("TXT_KEY_ANGER_WAR_WEAR", iAnger));
		szBuffer.append(NEWLINE);
		iTotal += iAnger;
	}

	iAnger = city.getVassalUnhappiness();
	if (iAnger > 0)
	{
		szBuffer.append(gDLL->getText("TXT_KEY_UNHAPPY_VASSAL", iAnger));
		szBuffer.append(NEWLINE);
		iTotal += iAnger;
	}

	iAnger = city.getEspionageHappinessCounter();
	if (iAnger > 0)
	{
		szBuffer.append(gDLL->getText("TXT_KEY_ANGER_ESPIONAGE", iAnger));
		szBuffer.append(NEWLINE);
		iTotal += iAnger;
	}

	for (int iI = 0; iI < GC.getNumCivicInfos(); ++iI)
	{
		iAnger = kPlayer.getCivicPercentAnger((CivicTypes)iI) * iPop / iDivisor;
		if (iAnger != 0)
		{
			if (iAnger > 0)
			{
				szBuffer.append(gDLL->getText("TXT_KEY_ANGER_CIVIC_PERCENT_BAD", iAnger, GC.getCivicInfo((CivicTypes) iI).getTextKeyWide()));
				szBuffer.append(NEWLINE);
			}
			else
			{
				szBuffer.append(gDLL->getText("TXT_KEY_ANGER_CIVIC_PERCENT_GOOD", iAnger, GC.getCivicInfo((CivicTypes) iI).getTextKeyWide()));
				szBuffer.append(NEWLINE);
			}
			iTotal += iAnger;
		}
	}

	iAnger = city.getLargestCityHappiness();
	if (iAnger > 0)
	{
		szBuffer.append(gDLL->getText("TXT_KEY_ANGER_BIG_CITY", iAnger));
		szBuffer.append(NEWLINE);
		iTotal += iAnger;
	}

	iAnger = -city.getCivicHappiness();
	if (iAnger > 0)
	{
		szBuffer.append(gDLL->getText("TXT_KEY_UNHAPPY_CIVIC", iAnger));
		szBuffer.append(NEWLINE);
		iTotal += iAnger;
	}

	iAnger = -kPlayer.getWorldHappiness();
	if (iAnger > 0)
	{
		szBuffer.append(gDLL->getText("TXT_KEY_UNHAPPY_WORLD_PROJECT", iAnger));
		szBuffer.append(NEWLINE);
		iTotal += iAnger;
	}

	iAnger = -kPlayer.getProjectHappiness();
	if (iAnger > 0)
	{
		szBuffer.append(gDLL->getText("TXT_KEY_UNHAPPY_PROJECT", iAnger));
		szBuffer.append(NEWLINE);
		iTotal += iAnger;
	}

	iAnger = kPlayer.calculateTaxRateUnhappiness();
	if (iAnger > 0)
	{
		szBuffer.append(gDLL->getText("TXT_KEY_CITY_TAXATION_ANGER", iAnger));
		szBuffer.append(NEWLINE);
		iTotal += iAnger;
	}

	iAnger = -city.calculateCorporationHappiness();
	if (iAnger > 0)
	{
		szBuffer.append(gDLL->getText("TXT_KEY_UNHAPPY_CORPORATIONS", iAnger));
		szBuffer.append(NEWLINE);
		iTotal += iAnger;
	}

	iAnger = kPlayer.getForeignUnhappyPercent();
	if (iAnger > 0)
	{
		iAnger = (100 - city.plot()->calculateCulturePercent(city.getOwner())) / iAnger;
		if (iAnger > 0)
		{
			szBuffer.append(gDLL->getText("TXT_KEY_CITY_FOREIGNER_ANGER", iAnger));
			szBuffer.append(NEWLINE);
			iTotal += iAnger;
		}
	}

	if (GC.getGame().isOption(GAMEOPTION_PERSONALIZED_MAP))
	{
		iAnger = -kPlayer.getLandmarkHappiness();
		if (iAnger > 0)
		{
			szBuffer.append(gDLL->getText("TXT_KEY_CITY_LANDMARK_ANGER", iAnger));
			szBuffer.append(NEWLINE);
			iTotal += iAnger;
		}

		if (!kPlayer.isNoLandmarkAnger())
		{
			iAnger = city.getLandmarkAnger();
			if (iAnger > 0)
			{
				szBuffer.append(gDLL->getText("TXT_KEY_CITY_LANDMARK_DESTRUCTION_ANGER", iAnger));
				szBuffer.append(NEWLINE);
				iTotal += iAnger;
			}
		}
	}

	iAnger = -city.getMilitaryHappiness();
	if (iAnger > 0)
	{
		szBuffer.append(gDLL->getText("TXT_KEY_ANGER_MILITARY_PRESENCE", iAnger));
		szBuffer.append(NEWLINE);
		iTotal += iAnger;
	}

	iAnger = -city.getCurrentStateReligionHappiness();
	if (iAnger > 0)
	{
		szBuffer.append(gDLL->getText("TXT_KEY_ANGER_STATE_RELIGION", iAnger));
		szBuffer.append(NEWLINE);
		iTotal += iAnger;
	}

	if (kPlayer.getCityLimit() > 0 && kPlayer.getCityOverLimitUnhappy() > 0)
	{
		iAnger = kPlayer.getCityOverLimitUnhappy() * (kPlayer.getNumCities() - kPlayer.getCityLimit());
		if (iAnger > 0)
		{
			szBuffer.append(gDLL->getText("TXT_KEY_ANGER_TOO_MANY_CITIES", iAnger));
			szBuffer.append(NEWLINE);
			iTotal += iAnger;
		}
	}

	iAnger = -(city.getBuildingBadHappiness() + city.getExtraBuildingBadHappiness());
	if (iAnger > 0)
	{
		szBuffer.append(gDLL->getText("TXT_KEY_UNHAPPY_CITY_BUILDINGS", iAnger));
		szBuffer.append(NEWLINE);
		iTotal += iAnger;
	}

	iAnger = -city.getFeatureBadHappiness();
	if (iAnger > 0)
	{
		szBuffer.append(gDLL->getText("TXT_KEY_ANGER_FEATURES", iAnger));
		szBuffer.append(NEWLINE);
		iTotal += iAnger;
	}

	iAnger = -city.getBonusBadHappiness();
	if (iAnger > 0)
	{
		szBuffer.append(gDLL->getText("TXT_KEY_ANGER_BONUS", iAnger));
		szBuffer.append(NEWLINE);
		iTotal += iAnger;
	}

	iAnger = -city.getSpecialistUnhappiness() / 100;
	if (iAnger > 0)
	{
		szBuffer.append(gDLL->getText("TXT_KEY_UNHAPPY_SPECIALISTS", iAnger));
		szBuffer.append(NEWLINE);
		iTotal += iAnger;
	}

	iAnger = -city.getReligionBadHappiness();
	if (iAnger > 0)
	{
		szBuffer.append(gDLL->getText("TXT_KEY_ANGER_RELIGIOUS_FREEDOM", iAnger));
		szBuffer.append(NEWLINE);
		iTotal += iAnger;
	}

	iAnger = -city.getCommerceHappiness();
	if (iAnger > 0)
	{
		szBuffer.append(gDLL->getText("TXT_KEY_ANGER_BAD_ENTERTAINMENT", iAnger));
		szBuffer.append(NEWLINE);
		iTotal += iAnger;
	}

	iAnger = -city.area()->getBuildingHappiness(city.getOwner());
	if (iAnger > 0)
	{
		szBuffer.append(gDLL->getText("TXT_KEY_UNHAPPY_AREA_BUILDINGS", iAnger));
		szBuffer.append(NEWLINE);
		iTotal += iAnger;
	}

	iAnger = -kPlayer.getBuildingHappiness();
	if (iAnger > 0)
	{
		szBuffer.append(gDLL->getText("TXT_KEY_UNHAPPY_PLAYER_BUILDINGS", iAnger));
		szBuffer.append(NEWLINE);
		iTotal += iAnger;
	}

	iAnger = -(city.getExtraHappiness() + kPlayer.getExtraHappiness());
	if (iAnger > 0)
	{
		szBuffer.append(gDLL->getText("TXT_KEY_ANGER_ARGH", iAnger));
		szBuffer.append(NEWLINE);
		iTotal += iAnger;
	}

	iAnger = city.getExtraTechUnHappinessTotal();
	if (iAnger > 0)
	{
		szBuffer.append(gDLL->getText("TXT_KEY_UNHAPPY_TECH_SPECIALIST", iAnger));
		szBuffer.append(NEWLINE);
		iTotal += iAnger;
	}

	if (GC.getGame().getHandicapType() != NO_HANDICAP)
	{
		iAnger = -GC.getHandicapInfo(city.getHandicapType()).getHappyBonus();
		if (iAnger > 0)
		{
			szBuffer.append(gDLL->getText("TXT_KEY_ANGER_HANDICAP", iAnger));
			szBuffer.append(NEWLINE);
			iTotal += iAnger;
		}
	}

	int iUnhappy = city.unhappyLevel();
	if (iUnhappy > iTotal)
	{
		// Accounting for rounding error in the above decomposition and other possible sources not handled above.
		szBuffer.append(gDLL->getText("TXT_KEY_ANGER_MISC", iUnhappy - iTotal));
		szBuffer.append(NEWLINE);
	}
	szBuffer.append(L"-----------------------\n");
	szBuffer.append(gDLL->getText("TXT_KEY_ANGER_TOTAL_UNHAPPY", iUnhappy));
}


void CvGameTextMgr::setHappyHelp(CvWStringBuffer &szBuffer, CvCity& city)
{

	if (city.isDisorder())
	{
		return;
	}
	if (city.happyLevel() > 0)
	{
		int iTotalHappy = 0;
		int iHappy = city.getRevSuccessHappiness();
		if (iHappy > 0)
		{
			iTotalHappy += iHappy;
			szBuffer.append(gDLL->getText("TXT_KEY_REV_SUCCESS_HAPPINESS", iHappy));
			szBuffer.append(NEWLINE);
		}

		iHappy = city.getLargestCityHappiness();
		if (iHappy > 0)
		{
			iTotalHappy += iHappy;
			szBuffer.append(gDLL->getText("TXT_KEY_HAPPY_BIG_CITY", iHappy));
			szBuffer.append(NEWLINE);
		}

		iHappy = city.getCivicHappiness();
		if (iHappy > 0)
		{
			iTotalHappy += iHappy;
			szBuffer.append(gDLL->getText("TXT_KEY_HAPPY_CIVIC", iHappy));
			szBuffer.append(NEWLINE);
		}

		iHappy = GET_PLAYER(city.getOwner()).getWorldHappiness();
		if (iHappy > 0)
		{
			iTotalHappy += iHappy;
			szBuffer.append(gDLL->getText("TXT_KEY_HAPPY_WORLD_PROJECT", iHappy));
			szBuffer.append(NEWLINE);
		}

		iHappy = GET_PLAYER(city.getOwner()).getProjectHappiness();
		if (iHappy > 0)
		{
			iTotalHappy += iHappy;
			szBuffer.append(gDLL->getText("TXT_KEY_HAPPY_WORLD_PROJECT", iHappy));
			szBuffer.append(NEWLINE);
		}
		iHappy = city.calculateCorporationHappiness();
		if (iHappy > 0)
		{
			iTotalHappy += iHappy;
			szBuffer.append(gDLL->getText("TXT_KEY_HAPPY_CORPORATIONS", iHappy));
			szBuffer.append(NEWLINE);
		}
		if (GC.getGame().isOption(GAMEOPTION_PERSONALIZED_MAP))
		{
			iHappy = GET_PLAYER(city.getOwner()).getLandmarkHappiness();
			if (iHappy > 0)
			{
				iTotalHappy += iHappy;
				szBuffer.append(gDLL->getText("TXT_KEY_HAPPY_LANDMARKS", iHappy));
				szBuffer.append(NEWLINE);
			}
		}

		iHappy = city.getMilitaryHappiness();
		if (iHappy > 0)
		{
			iTotalHappy += iHappy;
			szBuffer.append(gDLL->getText("TXT_KEY_HAPPY_MILITARY_PRESENCE", iHappy));
			szBuffer.append(NEWLINE);
		}

		iHappy = city.getVassalHappiness();
		if (iHappy > 0)
		{
			iTotalHappy += iHappy;
			szBuffer.append(gDLL->getText("TXT_KEY_HAPPY_VASSAL", iHappy));
			szBuffer.append(NEWLINE);
		}

		iHappy = city.getCurrentStateReligionHappiness();
		if (iHappy > 0)
		{
			iTotalHappy += iHappy;
			szBuffer.append(gDLL->getText("TXT_KEY_HAPPY_STATE_RELIGION", iHappy));
			szBuffer.append(NEWLINE);
		}

		iHappy = 0;
		int iValue = city.area()->getBuildingHappiness(city.getOwner());
		if (iValue > 0)
		{
			iHappy += iValue;
		}
		iValue = GET_PLAYER(city.getOwner()).getBuildingHappiness();
		if (iValue > 0)
		{
			iHappy += iValue;
		}
		iValue = (city.getBuildingGoodHappiness() + city.getExtraBuildingGoodHappiness());
		if (iValue > 0)
		{
			iHappy += iValue;
		}
		if (iHappy > 0)
		{
			iTotalHappy += iHappy;
			szBuffer.append(gDLL->getText("TXT_KEY_HAPPY_BUILDINGS", iHappy));
			szBuffer.append(NEWLINE);
		}

		iHappy = city.getFeatureGoodHappiness();
		if (iHappy > 0)
		{
			iTotalHappy += iHappy;
			szBuffer.append(gDLL->getText("TXT_KEY_HAPPY_FEATURES", iHappy));
			szBuffer.append(NEWLINE);
		}

		iHappy = city.getBonusGoodHappiness();
		if (iHappy > 0)
		{
			iTotalHappy += iHappy;
			szBuffer.append(gDLL->getText("TXT_KEY_HAPPY_BONUS", iHappy));
			szBuffer.append(NEWLINE);
		}

		iHappy = city.getSpecialistHappiness() / 100;
		if (iHappy > 0)
		{
			iTotalHappy += iHappy;
			szBuffer.append(gDLL->getText("TXT_KEY_HAPPY_SPECIALISTS", iHappy));
			szBuffer.append(NEWLINE);
		}

		iHappy = city.getReligionGoodHappiness();
		if (iHappy > 0)
		{
			iTotalHappy += iHappy;
			szBuffer.append(gDLL->getText("TXT_KEY_HAPPY_RELIGIOUS_FREEDOM", iHappy));
			szBuffer.append(NEWLINE);
		}

		iHappy = city.getCommerceHappiness();
		if (iHappy > 0)
		{
			iTotalHappy += iHappy;
			szBuffer.append(gDLL->getText("TXT_KEY_HAPPY_ENTERTAINMENT", iHappy));
			szBuffer.append(NEWLINE);
		}

		iHappy = (city.getExtraHappiness() + GET_PLAYER(city.getOwner()).getExtraHappiness());
		if (iHappy > 0)
		{
			iTotalHappy += iHappy;
			szBuffer.append(gDLL->getText("TXT_KEY_HAPPY_YEAH", iHappy));
			szBuffer.append(NEWLINE);
		}

		if (city.getHappinessTimer() > 0)
		{
			iHappy = GC.getTEMP_HAPPY();
			iTotalHappy += iHappy;
			szBuffer.append(gDLL->getText("TXT_KEY_HAPPY_TEMP", iHappy, city.getHappinessTimer()));
			szBuffer.append(NEWLINE);
		}

		iHappy = GC.getHandicapInfo(city.getHandicapType()).getHappyBonus();
		if (iHappy > 0)
		{
			iTotalHappy += iHappy;
			szBuffer.append(gDLL->getText("TXT_KEY_HAPPY_HANDICAP", iHappy));
			szBuffer.append(NEWLINE);
		}

		iHappy = std::max(0, (city.getCelebrityHappiness()));
		if (iHappy > 0)
		{
			iTotalHappy += iHappy;
			szBuffer.append(gDLL->getText("TXT_KEY_HAPPY_CELEBRITY", iHappy));
			szBuffer.append(NEWLINE);
		}

		iHappy = city.getExtraTechHappinessTotal();
		if (iHappy > 0)
		{
			iTotalHappy += iHappy;
			szBuffer.append(gDLL->getText("TXT_KEY_HAPPY_TECH_SPECIALIST", iHappy));
			szBuffer.append(NEWLINE);
		}

		szBuffer.append(L"-----------------------\n");

		szBuffer.append(gDLL->getText("TXT_KEY_HAPPY_TOTAL_HAPPY", iTotalHappy));

		FAssert(iTotalHappy == city.happyLevel())
	}
}

// BUG - Building Additional Happiness - start
bool CvGameTextMgr::setBuildingAdditionalHappinessHelp(CvWStringBuffer &szBuffer, CvCity& city, const CvWString& szStart, bool bStarted)
{
	for (int i = 0; i < GC.getNumBuildingInfos(); i++)
	{
		const BuildingTypes eBuilding = static_cast<BuildingTypes>(i);

		if (city.canConstruct(eBuilding, false, false, false))
		{
			int iGood = 0, iBad = 0, iAngryPop = 0;
			const int iChange = city.getAdditionalHappinessByBuilding(eBuilding, iGood, iBad, iAngryPop);

			if (iGood != 0 || iBad != 0)
			{
				if (!bStarted)
				{
					szBuffer.append(szStart);
					bStarted = true;
				}

				CvWString szLabel;
				szLabel.Format(SETCOLR L"%s" ENDCOLR, TEXT_COLOR("COLOR_BUILDING_TEXT"), GC.getBuildingInfo(eBuilding).getDescription());
				const bool bStartedLine = setResumableGoodBadChangeHelp(szBuffer, szLabel, L": ", L"", iGood, gDLL->getSymbolID(HAPPY_CHAR), iBad, gDLL->getSymbolID(UNHAPPY_CHAR), false, true);
				setResumableValueChangeHelp(szBuffer, szLabel, L": ", L"", iAngryPop, gDLL->getSymbolID(ANGRY_POP_CHAR), false, true, bStartedLine);
			}
		}
	}

	return bStarted;
}
// BUG - Building Additional Happiness - end


// BUG - Resumable Value Change Help - start
void CvGameTextMgr::setYieldChangeHelp(CvWStringBuffer &szBuffer, const CvWString& szStart, const CvWString& szSpace, const CvWString& szEnd, const int* piYieldChange, bool bPercent, bool bNewLine)
{
	setResumableYieldChangeHelp(szBuffer, szStart, szSpace, szEnd, piYieldChange, bPercent, bNewLine);
}
void CvGameTextMgr::setYieldPerPopChangeHelp(CvWStringBuffer &szBuffer, const CvWString& szStart, const CvWString& szSpace, const CvWString& szEnd, const int* piYieldChange, bool bPercent, bool bNewLine)
{
	setResumableYieldChangeHelp(szBuffer, szStart, szSpace, szEnd, piYieldChange, bPercent, bNewLine, false, true);
}

/*
 * Adds the ability to pass in and get back the value of bStarted so that
 * it can be used with other setResumable<xx>ChangeHelp() calls on a single line.
 */
bool CvGameTextMgr::setResumableYieldChangeHelp(CvWStringBuffer &szBuffer, const CvWString& szStart, const CvWString& szSpace, const CvWString& szEnd, const int* piYieldChange, bool bPercent, bool bNewLine, bool bStarted, bool bPerPop)
{
	CvWString szTempBuffer;
	CvWString szPerPop;
//	bool bStarted;
	int iI;

	if (bPerPop)
	{
		szPerPop.append(gDLL->getText("TXT_KEY_PER_POP"));
	}
//	bStarted = false;

	if ( piYieldChange != NULL )
	{
		for (iI = 0; iI < NUM_YIELD_TYPES; ++iI)
		{
			if (piYieldChange != NULL && piYieldChange[iI] != 0)
			{
				if (!bStarted)
				{
					if (bNewLine)
					{
						szTempBuffer.Format(L"\n%c", gDLL->getSymbolID(BULLET_CHAR));
					}
					if (!bPerPop)
					{
						szTempBuffer += CvWString::format(L"%s%s%s%d%s%c",
							szStart.GetCString(),
							szSpace.GetCString(),
							piYieldChange[iI] > 0 ? L"+" : L"",
							piYieldChange[iI],
							bPercent ? L"%" : L"",
							GC.getYieldInfo((YieldTypes)iI).getChar());
					}
					else
					{
						if (piYieldChange[iI] % 100 == 0)
						{
							szTempBuffer += CvWString::format(L"%s%s%s%d%s%c%s",
								szStart.GetCString(),
								szSpace.GetCString(),
								piYieldChange[iI] > 0 ? L"+" : L"",
								piYieldChange[iI] / 100,
								bPercent ? L"%" : L"",
								GC.getYieldInfo((YieldTypes)iI).getChar(),
								szPerPop.GetCString());
						}
						else
						{
							szTempBuffer += CvWString::format(L"%s%s%s%d.%02d%s%c%s",
								szStart.GetCString(),
								szSpace.GetCString(),
								piYieldChange[iI] > 0 ? L"+" : L"",
								piYieldChange[iI] / 100,
								piYieldChange[iI] % 100,
								bPercent ? L"%" : L"",
								GC.getYieldInfo((YieldTypes)iI).getChar(),
								szPerPop.GetCString());
						}
					}
				}
				else
				{
					if (!bPerPop)
					{
						szTempBuffer.Format(L", %s%d%s%c",
							piYieldChange[iI] > 0 ? L"+" : L"",
							piYieldChange[iI],
							bPercent ? L"%" : L"",
							GC.getYieldInfo((YieldTypes)iI).getChar());
					}
					else
					{
						if (piYieldChange[iI] % 100 == 0)
						{
							szTempBuffer.Format((L", %s%d%s%c%s"),
								piYieldChange[iI] > 0 ? L"+" : L"",
								piYieldChange[iI] / 100,
								bPercent ? L"%" : L"",
								GC.getYieldInfo((YieldTypes)iI).getChar(),
								szPerPop.GetCString());
						}
						else
						{
							szTempBuffer.Format((L", %s%d.%02d%s%c%s"),
								piYieldChange[iI] > 0 ? L"+" : L"",
								piYieldChange[iI] / 100,
								piYieldChange[iI] % 100,
								bPercent ? L"%" : L"",
								GC.getYieldInfo((YieldTypes)iI).getChar(),
								szPerPop.GetCString());
						}
					}
				}
				szBuffer.append(szTempBuffer);

				bStarted = true;
			}
		}

		if (bStarted)
		{
			szBuffer.append(szEnd);
		}
	}

// added
	return bStarted;
}

void CvGameTextMgr::setCommerceChangeHelp(CvWStringBuffer &szBuffer, const CvWString& szStart, const CvWString& szSpace, const CvWString& szEnd, const int* piCommerceChange, bool bPercent, bool bNewLine)
{
	setResumableCommerceChangeHelp(szBuffer, szStart, szSpace, szEnd, piCommerceChange, bPercent, bNewLine);
}
void CvGameTextMgr::setCommercePerPopChangeHelp(CvWStringBuffer &szBuffer, const CvWString& szStart, const CvWString& szSpace, const CvWString& szEnd, const int* piCommerceChange, bool bPercent, bool bNewLine)
{
	setResumableCommerceChangeHelp(szBuffer, szStart, szSpace, szEnd, piCommerceChange, bPercent, bNewLine, false, true);
}

/*
 * Adds the ability to pass in and get back the value of bStarted so that
 * it can be used with other setResumable<xx>ChangeHelp() calls on a single line.
 */
bool CvGameTextMgr::setResumableCommerceChangeHelp(CvWStringBuffer &szBuffer, const CvWString& szStart, const CvWString& szSpace, const CvWString& szEnd, const int* piCommerceChange, bool bPercent, bool bNewLine, bool bStarted, bool bPerPop)
{
	CvWString szTempBuffer;
	CvWString szPerPop;
//	bool bStarted;
	int iI;

//	bStarted = false;

	if (bPerPop)
	{
		szPerPop.append(gDLL->getText("TXT_KEY_PER_POP"));
	}
	if ( piCommerceChange )
	{
		for (iI = 0; iI < NUM_COMMERCE_TYPES; ++iI)
		{
			if (piCommerceChange[iI] != 0)
			{
				if (!bStarted)
				{
					if (bNewLine)
					{
						szTempBuffer.Format(L"\n%c", gDLL->getSymbolID(BULLET_CHAR));
					}
					if (bPerPop)
					{
						if (piCommerceChange[iI] % 100 == 0)
						{
							szTempBuffer += CvWString::format(L"%s%s%s%d%s%c%s", szStart.GetCString(), szSpace.GetCString(), ((piCommerceChange[iI] > 0) ? L"+" : L""), piCommerceChange[iI] / 100, ((bPercent) ? L"%" : L""), GC.getCommerceInfo((CommerceTypes) iI).getChar(), szPerPop.GetCString());
						}
						else
						{
							szTempBuffer += CvWString::format(L"%s%s%s%d.%02d%s%c%s", szStart.GetCString(), szSpace.GetCString(), ((piCommerceChange[iI] > 0) ? L"+" : L""), piCommerceChange[iI] / 100, piCommerceChange[iI] % 100, ((bPercent) ? L"%" : L""), GC.getCommerceInfo((CommerceTypes) iI).getChar(), szPerPop.GetCString());
						}
					}
					else
					{
						szTempBuffer += CvWString::format(L"%s%s%s%d%s%c", szStart.GetCString(), szSpace.GetCString(), ((piCommerceChange[iI] > 0) ? L"+" : L""), piCommerceChange[iI], ((bPercent) ? L"%" : L""), GC.getCommerceInfo((CommerceTypes) iI).getChar());
					}
				}
				else
				{
					if (bPerPop)
					{
						if (piCommerceChange[iI] % 100 == 0)
						{
							szTempBuffer.Format((L", %s%d%s%c%s"), ((piCommerceChange[iI] > 0) ? L"+" : L""), piCommerceChange[iI] / 100, ((bPercent) ? L"%" : L""), GC.getCommerceInfo((CommerceTypes) iI).getChar(), szPerPop.GetCString());
						}
						else
						{
							szTempBuffer.Format((L", %s%d.%02d%s%c%s"), ((piCommerceChange[iI] > 0) ? L"+" : L""), piCommerceChange[iI] / 100, piCommerceChange[iI] % 100, ((bPercent) ? L"%" : L""), GC.getCommerceInfo((CommerceTypes) iI).getChar(), szPerPop.GetCString());
						}
					}
					else
					{
						szTempBuffer.Format((L", %s%d%s%c"), ((piCommerceChange[iI] > 0) ? L"+" : L""), piCommerceChange[iI], ((bPercent) ? L"%" : L""), GC.getCommerceInfo((CommerceTypes) iI).getChar());
					}
				}
				szBuffer.append(szTempBuffer);

				bStarted = true;
			}
		}
	}

	if (bStarted)
	{
		szBuffer.append(szEnd);
	}

// added
	return bStarted;
}

/*
 * Displays float values by dividing each value by 100.
 */
void CvGameTextMgr::setCommerceTimes100ChangeHelp(CvWStringBuffer &szBuffer, const CvWString& szStart, const CvWString& szSpace, const CvWString& szEnd, const int* piCommerceChange, bool bNewLine, bool bStarted)
{
	setResumableCommerceTimes100ChangeHelp(szBuffer, szStart, szSpace, szEnd, piCommerceChange, bNewLine);
}

/*
 * Adds the ability to pass in and get back the value of bStarted so that
 * it can be used with other setResumable<xx>ChangeHelp() calls on a single line.
 */
bool CvGameTextMgr::setResumableCommerceTimes100ChangeHelp(CvWStringBuffer &szBuffer, const CvWString& szStart, const CvWString& szSpace, const CvWString& szEnd, const int* piCommerceChange, bool bNewLine, bool bStarted)
{
	CvWString szTempBuffer;

	for (int iI = 0; iI < NUM_COMMERCE_TYPES; ++iI)
	{
		int iChange = piCommerceChange[iI];
		if (iChange != 0)
		{
			if (!bStarted)
			{
				if (bNewLine)
				{
					szTempBuffer.Format(L"\n%c", gDLL->getSymbolID(BULLET_CHAR));
				}
				szTempBuffer += CvWString::format(L"%s%s", szStart.GetCString(), szSpace.GetCString());
				bStarted = true;
			}
			else
			{
				szTempBuffer.Format(L", ");
			}
			szBuffer.append(szTempBuffer);

			if (iChange % 100 == 0)
			{
				szTempBuffer.Format(L"%+d%c", iChange / 100, GC.getCommerceInfo((CommerceTypes) iI).getChar());
			}
			else
			{
				if (iChange >= 0)
				{
					szBuffer.append(L"+");
				}
				else
				{
					iChange = - iChange;
					szBuffer.append(L"-");
				}
				szTempBuffer.Format(L"%d.%02d%c", iChange / 100, iChange % 100, GC.getCommerceInfo((CommerceTypes) iI).getChar());
			}
			szBuffer.append(szTempBuffer);
		}
	}

	if (bStarted)
	{
		szBuffer.append(szEnd);
	}

	return bStarted;
}

/*
 * Adds the ability to pass in and get back the value of bStarted so that
 * it can be used with other setResumable<xx>ChangeHelp() calls on a single line.
 */
bool CvGameTextMgr::setResumableGoodBadChangeHelp(CvWStringBuffer &szBuffer, const CvWString& szStart, const CvWString& szSpace, const CvWString& szEnd, int iGood, int iGoodSymbol, int iBad, int iBadSymbol, bool bPercent, bool bNewLine, bool bStarted)
{
	bStarted = setResumableValueChangeHelp(szBuffer, szStart, szSpace, szEnd, iGood, iGoodSymbol, bPercent, bNewLine, bStarted);
	bStarted = setResumableValueChangeHelp(szBuffer, szStart, szSpace, szEnd, iBad, iBadSymbol, bPercent, bNewLine, bStarted);

	return bStarted;
}

/*
 * Adds the ability to pass in and get back the value of bStarted so that
 * it can be used with other setResumable<xx>ChangeHelp() calls on a single line.
 */
bool CvGameTextMgr::setResumableValueChangeHelp(CvWStringBuffer &szBuffer, const CvWString& szStart, const CvWString& szSpace, const CvWString& szEnd, int iValue, int iSymbol, bool bPercent, bool bNewLine, bool bStarted)
{
	CvWString szTempBuffer;

	if (iValue != 0)
	{
		if (!bStarted)
		{
			if (bNewLine)
			{
				szTempBuffer.Format(L"\n%c", gDLL->getSymbolID(BULLET_CHAR));
			}
			szTempBuffer += CvWString::format(L"%s%s", szStart.GetCString(), szSpace.GetCString());
		}
		else
		{
			szTempBuffer = L", ";
		}
		szBuffer.append(szTempBuffer);

		szTempBuffer.Format(L"%+d%s%c", iValue, bPercent ? L"%" : L"", iSymbol);
		szBuffer.append(szTempBuffer);

		bStarted = true;
	}

	return bStarted;
}

/*
 * Adds the ability to pass in and get back the value of bStarted so that
 * it can be used with other setResumable<xx>ChangeHelp() calls on a single line.
 */
bool CvGameTextMgr::setResumableValueTimes100ChangeHelp(CvWStringBuffer &szBuffer, const CvWString& szStart, const CvWString& szSpace, const CvWString& szEnd, int iValue, int iSymbol, bool bNewLine, bool bStarted)
{
	CvWString szTempBuffer;

	if (iValue != 0)
	{
		if (!bStarted)
		{
			if (bNewLine)
			{
				szTempBuffer.Format(L"\n%c", gDLL->getSymbolID(BULLET_CHAR));
			}
			szTempBuffer += CvWString::format(L"%s%s", szStart.GetCString(), szSpace.GetCString());
		}
		else
		{
			szTempBuffer = L", ";
		}
		szBuffer.append(szTempBuffer);

		if (iValue % 100 == 0)
		{
			szTempBuffer.Format(L"%+d%c", iValue / 100, iSymbol);
		}
		else
		{
			if (iValue >= 0)
			{
				szBuffer.append(L"+");
			}
			else
			{
				iValue = - iValue;
				szBuffer.append(L"-");
			}
			szTempBuffer.Format(L"%d.%02d%c", iValue / 100, iValue % 100, iSymbol);
		}
		szBuffer.append(szTempBuffer);

		bStarted = true;
	}

	return bStarted;
}
// BUG - Resumable Value Change Help - end

/************************************************************************************************/
/* REVOLUTION_MOD								 ?/?/?						   DPII		  */
/*																							  */
/* BUG																						  */
/************************************************************************************************/
void CvGameTextMgr::setBonusHelp(CvWStringBuffer &szBuffer, BonusTypes eBonus, bool bCivilopediaText)
{
	setBonusTradeHelp(szBuffer, eBonus, bCivilopediaText, NO_PLAYER);
}

void CvGameTextMgr::setBonusTradeHelp(CvWStringBuffer &szBuffer, BonusTypes eBonus, bool bCivilopediaText, PlayerTypes eTradePlayer)
{
/************************************************************************************************/
/* REVOLUTION_MOD						  END												  */
/************************************************************************************************/

	if (NO_BONUS == eBonus)
	{
		return;
	}

	PlayerTypes eTradingPlayer = NO_PLAYER;
	if ( gDLL->isDiplomacy() )
	{
		eTradingPlayer = (PlayerTypes) gDLL->getDiplomacyPlayer();
	}
	else if (gDLL->isMPDiplomacy() && gDLL->isMPDiplomacyScreenUp())
	{
		eTradingPlayer = (PlayerTypes) gDLL->getMPDiplomacyPlayer();
	}

	bool bTradingPlayer = eTradingPlayer != NO_PLAYER;

	if (!bCivilopediaText)
	{
		szBuffer.append(CvWString::format( SETCOLR L"%s" ENDCOLR , TEXT_COLOR("COLOR_HIGHLIGHT_TEXT"), GC.getBonusInfo(eBonus).getDescription()));

		if (NO_PLAYER != GC.getGame().getActivePlayer())
		{
			CvPlayer& kActivePlayer = GET_PLAYER(GC.getGame().getActivePlayer());
			szBuffer.append(gDLL->getText("TXT_KEY_BONUS_AVAILABLE_PLAYER", kActivePlayer.getNumAvailableBonuses(eBonus), kActivePlayer.getNameKey()));

			if (bTradingPlayer)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_BONUS_AVAILABLE_PLAYER", GET_PLAYER(eTradingPlayer).getNumAvailableBonuses(eBonus), GET_PLAYER(eTradingPlayer).getNameKey()));
			}
			for (int iCorp = 0; iCorp < GC.getNumCorporationInfos(); ++iCorp)
			{
				bool bFound = false;
				if (kActivePlayer.isActiveCorporation((CorporationTypes)iCorp) || (bTradingPlayer && GET_PLAYER(eTradingPlayer).isActiveCorporation((CorporationTypes)iCorp)))
				{
					for (int i = 0; i < GC.getNUM_CORPORATION_PREREQ_BONUSES(); ++i)
					{
						if (eBonus == GC.getCorporationInfo((CorporationTypes)iCorp).getPrereqBonus(i))
						{
							foreach_(const CvCity* pCity, kActivePlayer.cities())
							{
								if (pCity->isHasCorporation((CorporationTypes)iCorp))
								{
									bFound = true;
									break;
								}
							}
							if (bTradingPlayer)
							{
								foreach_(const CvCity* pCity, GET_PLAYER(eTradingPlayer).cities())
								{
									if (pCity->isHasCorporation((CorporationTypes)iCorp))
									{
										bFound = true;
										break;
									}
								}
							}
						}

						if (bFound)
						{
							break;
						}
					}
				}

				if (bFound)
				{
					szBuffer.append(GC.getCorporationInfo((CorporationTypes)iCorp).getChar());
				}
			}

			if (kActivePlayer.getBonusImport(eBonus) > 0)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_BONUS_IMPORTS_PLAYER", kActivePlayer.getBonusImport(eBonus), kActivePlayer.getNameKey()));
			}
			if (kActivePlayer.getBonusExport(eBonus) > 0)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_BONUS_EXPORTS_PLAYER", kActivePlayer.getBonusExport(eBonus), kActivePlayer.getNameKey()));
			}
			if (bTradingPlayer)
			{
				if (GET_PLAYER(eTradingPlayer).getBonusImport(eBonus) > 0)
				{
					szBuffer.append(NEWLINE);
					szBuffer.append(gDLL->getText("TXT_KEY_BONUS_IMPORTS_PLAYER", GET_PLAYER(eTradingPlayer).getBonusImport(eBonus), GET_PLAYER(eTradingPlayer).getNameKey()));
				}
				if (GET_PLAYER(eTradingPlayer).getBonusExport(eBonus) > 0)
				{
					szBuffer.append(NEWLINE);
					szBuffer.append(gDLL->getText("TXT_KEY_BONUS_EXPORTS_PLAYER", GET_PLAYER(eTradingPlayer).getBonusExport(eBonus), GET_PLAYER(eTradingPlayer).getNameKey()));
				}
			}
		}

		setYieldChangeHelp(szBuffer, L"", L"", L"", GC.getBonusInfo(eBonus).getYieldChangeArray());

		if (GC.getBonusInfo(eBonus).getTechReveal() != NO_TECH)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BONUS_REVEALED_BY", GC.getTechInfo((TechTypes)GC.getBonusInfo(eBonus).getTechReveal()).getTextKeyWide()));
		}
	}


	ImprovementTypes eImprovement = NO_IMPROVEMENT;
	for (int iLoopImprovement = 0; iLoopImprovement < GC.getNumImprovementInfos(); iLoopImprovement++)
	{
		eImprovement = NO_IMPROVEMENT;
		if (GC.getImprovementInfo((ImprovementTypes)iLoopImprovement).isImprovementBonusMakesValid(eBonus))
		{
			eImprovement = (ImprovementTypes)iLoopImprovement;
		}
		if (eImprovement != NO_IMPROVEMENT)
		{
			if (GC.getBonusInfo(eBonus).getHealth() != 0)
			{
				if (GC.getBonusInfo(eBonus).getHealth() > 0)
				{
					szBuffer.append(NEWLINE);
					szBuffer.append(gDLL->getText("TXT_KEY_BONUS_HEALTHY", GC.getBonusInfo(eBonus).getHealth()));
				}
				else
				{
					szBuffer.append(NEWLINE);
					szBuffer.append(gDLL->getText("TXT_KEY_BONUS_UNHEALTHY", -GC.getBonusInfo(eBonus).getHealth()));
				}

				szBuffer.append(gDLL->getText("TXT_KEY_BONUS_WITH_IMPROVEMENT", GC.getImprovementInfo(eImprovement).getTextKeyWide()));
			}

			if (GC.getBonusInfo(eBonus).getHappiness() != 0)
			{
				if (GC.getBonusInfo(eBonus).getHappiness() > 0)
				{
					szBuffer.append(NEWLINE);
					szBuffer.append(gDLL->getText("TXT_KEY_BONUS_HAPPY", GC.getBonusInfo(eBonus).getHappiness()));
				}
				else
				{
					szBuffer.append(NEWLINE);
					szBuffer.append(gDLL->getText("TXT_KEY_BONUS_UNHAPPY", -GC.getBonusInfo(eBonus).getHappiness()));
				}

				szBuffer.append(gDLL->getText("TXT_KEY_BONUS_WITH_IMPROVEMENT", GC.getImprovementInfo(eImprovement).getTextKeyWide()));
			}
		}
		else if (GC.getImprovementInfo((ImprovementTypes)iLoopImprovement).isImprovementObsoleteBonusMakesValid(eBonus))
		{
			eImprovement = (ImprovementTypes)iLoopImprovement;
			szBuffer.append(gDLL->getText("TXT_KEY_BONUS_OBSOLETED_VALIDATES_IMPROVEMENT", GC.getImprovementInfo(eImprovement).getTextKeyWide()));
		}

	}

	for (int i = 0; i < GC.getNumBuildingInfos(); i++)
	{
		const BuildingTypes eLoopBuilding = static_cast<BuildingTypes>(i);
		const CvBuildingInfo& kBuilding = GC.getBuildingInfo(eLoopBuilding);
		if (kBuilding.getBonusHappinessChanges(eBonus) != 0)
		{
			if (kBuilding.getBonusHappinessChanges(eBonus) > 0)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_BONUS_HAPPY", kBuilding.getBonusHappinessChanges(eBonus)));
			}
			else
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_BONUS_UNHAPPY", -kBuilding.getBonusHappinessChanges(eBonus)));
			}

			szBuffer.append(gDLL->getText("TXT_KEY_BONUS_WITH_IMPROVEMENT", kBuilding.getTextKeyWide()));
		}

		if (kBuilding.getBonusHealthChanges(eBonus) != 0)
		{
			if (kBuilding.getBonusHealthChanges(eBonus) > 0)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_BONUS_HEALTHY", kBuilding.getBonusHealthChanges(eBonus)));
			}
			else
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_BONUS_UNHEALTHY", -kBuilding.getBonusHealthChanges(eBonus)));
			}

			szBuffer.append(gDLL->getText("TXT_KEY_BONUS_WITH_IMPROVEMENT", kBuilding.getTextKeyWide()));
		}
	}

// BUG - Trade Denial - start
	if (eTradePlayer != NO_PLAYER && GC.getGame().getActivePlayer() != NO_PLAYER && getBugOptionBOOL("MiscHover__BonusTradeDenial", true, "BUG_BONUS_TRADE_DENIAL_HOVER"))
	{
		TradeData trade;
		trade.m_eItemType = TRADE_RESOURCES;
		trade.m_iData = eBonus;

		if (GET_PLAYER(eTradePlayer).canTradeItem(GC.getGame().getActivePlayer(), trade, false))
		{
			DenialTypes eDenial = GET_PLAYER(eTradePlayer).getTradeDenial(GC.getGame().getActivePlayer(), trade);
			if (eDenial != NO_DENIAL)
			{
				CvWString szTempBuffer;
				szTempBuffer.Format(SETCOLR L"%s" ENDCOLR, TEXT_COLOR("COLOR_NEGATIVE_TEXT"), GC.getDenialInfo(eDenial).getDescription());
				szBuffer.append(NEWLINE);
				szBuffer.append(szTempBuffer);
			}
		}
	}
// BUG - Trade Denial - end

	if (!CvWString(GC.getBonusInfo(eBonus).getHelp()).empty())
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(GC.getBonusInfo(eBonus).getHelp());
	}
	if (bCivilopediaText)
	{
		for (int iI = 0; iI < GC.getBonusInfo(eBonus).getNumMapCategoryTypes(); iI++)
		{
			MapCategoryTypes eMapCategory = (MapCategoryTypes)GC.getBonusInfo(eBonus).getMapCategoryType(iI);
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_MAP_CATEGORY_PREREQUISITE", GC.getMapCategoryInfo(eMapCategory).getTextKeyWide()));
		}
	}
}

void CvGameTextMgr::setReligionHelp(CvWStringBuffer &szBuffer, ReligionTypes eReligion, bool bCivilopedia)
{
	if (NO_RELIGION == eReligion)
	{
		return;
	}
	const CvReligionInfo& religion = GC.getReligionInfo(eReligion);

	if (!bCivilopedia)
	{
		szBuffer.append(CvWString::format(SETCOLR L"%s" ENDCOLR , TEXT_COLOR("COLOR_HIGHLIGHT_TEXT"), religion.getDescription()));
	}

	setCommerceChangeHelp(szBuffer, gDLL->getText("TXT_KEY_RELIGION_HOLY_CITY").c_str(), L": ", L"", religion.getHolyCityCommerceArray());
	setCommerceChangeHelp(szBuffer, gDLL->getText("TXT_KEY_RELIGION_ALL_CITIES").c_str(), L": ", L"", religion.getStateReligionCommerceArray());

	if (!bCivilopedia)
	{
		if (religion.getTechPrereq() != NO_TECH)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_RELIGION_FOUNDED_FIRST", GC.getTechInfo((TechTypes)religion.getTechPrereq()).getTextKeyWide()));
		}
	}

	const UnitTypes eFreeUnit = (UnitTypes) religion.getFreeUnit();

	if (eFreeUnit != NO_UNIT)
	{
		if (religion.getNumFreeUnits() > 1)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_RELIGION_FOUNDER_RECEIVES_NUM", GC.getUnitInfo(eFreeUnit).getTextKeyWide(), religion.getNumFreeUnits()));
		}
		else if (religion.getNumFreeUnits() > 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_RELIGION_FOUNDER_RECEIVES", GC.getUnitInfo(eFreeUnit).getTextKeyWide()));
		}
	}
}

void CvGameTextMgr::setReligionHelpCity(CvWStringBuffer &szBuffer, ReligionTypes eReligion, CvCity *pCity, bool bCityBar, bool bForceReligion, bool bForceState, bool bNoStateReligion)
{
	int i;
	CvWString szTempBuffer;
	bool bHandled = false;
	int iCommerce;
	int iHappiness;
	int iProductionModifier;
	int iFreeExperience;
	int iGreatPeopleRateModifier;

	if (pCity == NULL)
	{
		return;
	}

	ReligionTypes eStateReligion = (bNoStateReligion ? NO_RELIGION : GET_PLAYER(pCity->getOwner()).getStateReligion());

	if (bCityBar)
	{
		szBuffer.append(CvWString::format(SETCOLR L"%s" ENDCOLR , TEXT_COLOR("COLOR_HIGHLIGHT_TEXT"), GC.getReligionInfo(eReligion).getDescription()));
		szBuffer.append(NEWLINE);

		if (!(GC.getGame().isReligionFounded(eReligion)) && !GC.getGame().isOption(GAMEOPTION_PICK_RELIGION))
		{
			if (GC.getReligionInfo(eReligion).getTechPrereq() != NO_TECH)
			{
				szBuffer.append(gDLL->getText("TXT_KEY_RELIGION_FOUNDED_FIRST", GC.getTechInfo((TechTypes)(GC.getReligionInfo(eReligion).getTechPrereq())).getTextKeyWide()));
			}
		}
	}

	if (!bForceReligion)
	{
		if (!(pCity->isHasReligion(eReligion)))
		{
			return;
		}
	}

	if (eStateReligion == eReligion || eStateReligion == NO_RELIGION || (GET_PLAYER(pCity->getOwner()).isNonStateReligionCommerce()) || bForceState)
	{
		for (i = 0; i < NUM_COMMERCE_TYPES; i++)
		{
			iCommerce = GC.getReligionInfo(eReligion).getStateReligionCommerce((CommerceTypes)i);

			if (pCity->isHolyCity(eReligion))
			{
				iCommerce += GC.getReligionInfo(eReligion).getHolyCityCommerce((CommerceTypes)i);
			}

			if (iCommerce != 0)
			{
				if (bHandled)
				{
					szBuffer.append(L", ");
				}

				szTempBuffer.Format(L"%s%d%c", iCommerce > 0 ? L"+" : L"", iCommerce, GC.getCommerceInfo((CommerceTypes)i).getChar());
				szBuffer.append(szTempBuffer);
				bHandled = true;
			}
		}
	}

	if (eStateReligion == eReligion || bForceState)
	{
		iHappiness = (pCity->getStateReligionHappiness(eReligion) + GET_PLAYER(pCity->getOwner()).getStateReligionHappiness());

		if (iHappiness != 0)
		{
			if (bHandled)
			{
				szBuffer.append(L", ");
			}
			// Use absolute value with unhappy face
			szTempBuffer.Format(L"%d%c", abs(iHappiness), ((iHappiness > 0) ? gDLL->getSymbolID(HAPPY_CHAR) : gDLL->getSymbolID(UNHAPPY_CHAR)));

			szBuffer.append(szTempBuffer);
			bHandled = true;
		}

		iProductionModifier = GET_PLAYER(pCity->getOwner()).getStateReligionBuildingProductionModifier();
		if (iProductionModifier != 0)
		{
			if (bHandled)
			{
				szBuffer.append(L", ");
			}

			szBuffer.append(gDLL->getText("TXT_KEY_RELIGION_BUILDING_PROD_MOD", iProductionModifier));
			bHandled = true;
		}

		iProductionModifier = GET_PLAYER(pCity->getOwner()).getStateReligionUnitProductionModifier();
		if (iProductionModifier != 0)
		{
			if (bHandled)
			{
				szBuffer.append(L", ");
			}

			szBuffer.append(gDLL->getText("TXT_KEY_RELIGION_UNIT_PROD_MOD", iProductionModifier));
			bHandled = true;
		}

		iFreeExperience = GET_PLAYER(pCity->getOwner()).getStateReligionFreeExperience();
		if (iFreeExperience != 0)
		{
			if (bHandled)
			{
				szBuffer.append(L", ");
			}

			szBuffer.append(gDLL->getText("TXT_KEY_RELIGION_FREE_XP", iFreeExperience));
			bHandled = true;
		}

		iGreatPeopleRateModifier = GET_PLAYER(pCity->getOwner()).getStateReligionGreatPeopleRateModifier();
		if (iGreatPeopleRateModifier != 0)
		{
			if (bHandled)
			{
				szBuffer.append(L", ");
			}

			szBuffer.append(gDLL->getText("TXT_KEY_RELIGION_BIRTH_RATE_MOD", iGreatPeopleRateModifier));
			bHandled = true;
		}
	}
}

void CvGameTextMgr::setCorporationHelp(CvWStringBuffer &szBuffer, CorporationTypes eCorporation, bool bCivilopedia)
{
	if (NO_CORPORATION == eCorporation)
	{
		return;
	}
	const CvCorporationInfo& kCorporation = GC.getCorporationInfo(eCorporation);

	if (!bCivilopedia)
	{
		szBuffer.append(CvWString::format(SETCOLR L"%s" ENDCOLR , TEXT_COLOR("COLOR_HIGHLIGHT_TEXT"), kCorporation.getDescription()));
	}

	CvWString szTempBuffer;
	szTempBuffer.clear();

	for (int iI = 0; iI < NUM_YIELD_TYPES; ++iI)
	{
		int iYieldProduced = kCorporation.getYieldProduced((YieldTypes)iI);
		if (NO_PLAYER != GC.getGame().getActivePlayer())
		{
			iYieldProduced *= GC.getWorldInfo(GC.getMap().getWorldSize()).getCorporationMaintenancePercent();
			iYieldProduced /= 100;
		}

		if (iYieldProduced != 0)
		{
			if (!szTempBuffer.empty())
			{
				szTempBuffer += L", ";
			}

			if (iYieldProduced % 100 == 0)
			{
				szTempBuffer += CvWString::format(L"%s%d%c",
					iYieldProduced > 0 ? L"+" : L"",
					iYieldProduced / 100,
					GC.getYieldInfo((YieldTypes)iI).getChar());
			}
			else
			{
				szTempBuffer += CvWString::format(L"%s%.2f%c",
					iYieldProduced > 0 ? L"+" : L"",
					0.01f * abs(iYieldProduced),
					GC.getYieldInfo((YieldTypes)iI).getChar());
			}
		}
	}

	if (!szTempBuffer.empty())
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_CORPORATION_ALL_CITIES", szTempBuffer.GetCString()));
	}

	szTempBuffer.clear();
	for (int iI = 0; iI < NUM_COMMERCE_TYPES; ++iI)
	{
		int iCommerceProduced = kCorporation.getCommerceProduced((CommerceTypes)iI);
		if (NO_PLAYER != GC.getGame().getActivePlayer())
		{
			iCommerceProduced *= GC.getWorldInfo(GC.getMap().getWorldSize()).getCorporationMaintenancePercent();
			iCommerceProduced /= 100;
		}
		if (iCommerceProduced != 0)
		{
			if (!szTempBuffer.empty())
			{
				szTempBuffer += L", ";
			}

			if (iCommerceProduced % 100 == 0)
			{
				szTempBuffer += CvWString::format(L"%s%d%c",
					iCommerceProduced > 0 ? L"+" : L"",
					iCommerceProduced / 100,
					GC.getCommerceInfo((CommerceTypes)iI).getChar());
			}
			else
			{
				szTempBuffer += CvWString::format(L"%s%.2f%c",
					iCommerceProduced > 0 ? L"+" : L"",
					0.01f * abs(iCommerceProduced),
					GC.getCommerceInfo((CommerceTypes)iI).getChar());
			}

		}
	}

	if (!szTempBuffer.empty())
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_CORPORATION_ALL_CITIES", szTempBuffer.GetCString()));
	}

	if (!bCivilopedia)
	{
		if (kCorporation.getTechPrereq() != NO_TECH)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_CORPORATION_FOUNDED_FIRST", CvWString(GC.getTechInfo((TechTypes)kCorporation.getTechPrereq()).getType()).GetCString(), GC.getTechInfo((TechTypes)kCorporation.getTechPrereq()).getTextKeyWide()));
		}
	}
	/************************************************************************************************/
	/* TGA_INDEXATION						  02/18/08								MRGENIE	  */
	/*																							  */
	/* adding link to resources in the Pedia														*/
	/************************************************************************************************/
	/*
	szBuffer.append(NEWLINE);
	szBuffer.append(gDLL->getText("TXT_KEY_CORPORATION_BONUS_REQUIRED"));
	*/
	bool bFirst = true;
	/*
	for (int i = 0; i < GC.getNUM_CORPORATION_PREREQ_BONUSES(); ++i)
	*/
	{
	/*
		if (NO_BONUS != kCorporation.getPrereqBonus(i))
	*/
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_CORPORATION_BONUS_REQUIRED"));
		for (int i = 0; i < GC.getNUM_CORPORATION_PREREQ_BONUSES(); ++i)
		{
	/*
			if (bFirst)
	*/
			if (NO_BONUS != kCorporation.getPrereqBonus(i))
			{
	/*
				bFirst = false;
	*/
				if (bFirst)
				{
					bFirst = false;
				}
				else
				{
					szBuffer.append(L", ");
				}

	/*
				szBuffer.append(CvWString::format(L"%c", GC.getBonusInfo((BonusTypes)kCorporation.getPrereqBonus(i)).getChar()));
	*/			if (!bFirst)
					szBuffer.append(gDLL->getText("TXT_KEY_CORPORATION_BONUS_CONSUMES", CvWString(GC.getBonusInfo((BonusTypes)kCorporation.getPrereqBonus(i)).getType()).GetCString(), GC.getBonusInfo((BonusTypes)kCorporation.getPrereqBonus(i)).getTextKeyWide(), GC.getBonusInfo((BonusTypes)kCorporation.getPrereqBonus(i)).getChar()));
			}
	/*
			else
			{
				szBuffer.append(L", ");
			}

			szBuffer.append(CvWString::format(L"%c", GC.getBonusInfo((BonusTypes)kCorporation.getPrereqBonus(i)).getChar()));
	*/
	/************************************************************************************************/
	/* TGA_INDEXATION						  END												  */
	/************************************************************************************************/
		}
	}

	if (kCorporation.getBonusProduced() != NO_BONUS)
	{
		if (!bFirst)
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_CORPORATION_BONUS_PRODUCED", GC.getBonusInfo((BonusTypes)kCorporation.getBonusProduced()).getChar()));
	}

	const UnitTypes eFreeUnit = (UnitTypes) kCorporation.getFreeUnit();

	if (eFreeUnit != NO_UNIT)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_RELIGION_FOUNDER_RECEIVES", GC.getUnitInfo(eFreeUnit).getTextKeyWide()));
	}

	bFirst = true;
	for (int iI = 0; iI < GC.getNumCorporationInfos(); ++iI)
	{
		if (iI != eCorporation)
		{
			const CvCorporationInfo& kLoopCorporation = GC.getCorporationInfo((CorporationTypes)iI);

			bool bCompeting = kLoopCorporation.isCompetingCorporation(eCorporation) || kCorporation.isCompetingCorporation(iI);

			if (!bCompeting)
			{
				for (int i = 0; i < GC.getNUM_CORPORATION_PREREQ_BONUSES(); ++i)
				{
					if (kCorporation.getPrereqBonus(i) != NO_BONUS)
					{
						for (int j = 0; j < GC.getNUM_CORPORATION_PREREQ_BONUSES(); ++j)
						{
							if (kLoopCorporation.getPrereqBonus(j) == kCorporation.getPrereqBonus(i))
							{
								bCompeting = true;
								break;
							}
						}
					}
					if (bCompeting)
					{
						break;
					}
				}
			}
			if (bCompeting)
			{
				CvWString szTemp = CvWString::format(L"<link=%s>%s</link>", CvWString(kLoopCorporation.getType()).GetCString(), kLoopCorporation.getDescription());
				setListHelp(szBuffer, gDLL->getText("TXT_KEY_CORPORATION_COMPETES").c_str(), szTemp.GetCString(), L", ", bFirst);
				bFirst = false;
			}
		}
	}

	if (kCorporation.getHealth() > 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_CORPORATION_HEALTHINESS", kCorporation.getHealth()));
	}
	else if (kCorporation.getHealth() < 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_CORPORATION_UNHEALTHINESS", -kCorporation.getHealth()));
	}

	if (kCorporation.getHappiness() > 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_CORPORATION_HAPPINESS", kCorporation.getHappiness()));
	}
	else if (kCorporation.getHappiness() < 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_CORPORATION_UNHAPPINESS", -kCorporation.getHappiness()));
	}

	if (kCorporation.getMilitaryProductionModifier() != 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_CIVIC_MILITARY_PRODUCTION", kCorporation.getMilitaryProductionModifier()));
	}

	if (kCorporation.getFreeXP() != 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_CIVIC_FREE_XP", kCorporation.getFreeXP()));
	}

	setCommerceChangeHelp(szBuffer, L"", L"", gDLL->getText("TXT_KEY_BUILDING_ALL_CITIES").c_str(), kCorporation.getCommerceChangeArray(), false);
	setYieldChangeHelp(szBuffer, L"", L"", gDLL->getText("TXT_KEY_BUILDING_ALL_CITIES").c_str(), kCorporation.getYieldChangeArray(), false);

	for (int iI = 0; iI < GC.getNumBuildingInfos(); iI++)
	{
		if (kCorporation.getPrereqBuilding(iI) > 0)
		{
			szTempBuffer.Format(L"%s%s", NEWLINE, gDLL->getText("TXT_KEY_BUILDING_REQUIRES_NUM_SPECIAL_BUILDINGS_NO_CITY", GC.getBuildingInfo((BuildingTypes)iI).getTextKeyWide(), kCorporation.getPrereqBuilding(iI)).c_str());
			szBuffer.append(szTempBuffer);
		}
	}
	if (kCorporation.getObsoleteTech() != NO_TECH)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_OBSOLETE_WITH", CvWString(GC.getTechInfo((TechTypes)kCorporation.getObsoleteTech()).getType()).GetCString(), GC.getTechInfo((TechTypes)kCorporation.getObsoleteTech()).getTextKeyWide()));
	}
}

void CvGameTextMgr::setCorporationHelpCity(CvWStringBuffer &szBuffer, CorporationTypes eCorporation, CvCity *pCity, bool bCityBar, bool bForceCorporation)
{
	if (pCity == NULL)
	{
		return;
	}

	const CvCorporationInfo& kCorporation = GC.getCorporationInfo(eCorporation);

	if (bCityBar)
	{
		szBuffer.append(CvWString::format(SETCOLR L"%s" ENDCOLR , TEXT_COLOR("COLOR_HIGHLIGHT_TEXT"), kCorporation.getDescription()));
		szBuffer.append(NEWLINE);

		if (!GC.getGame().isCorporationFounded(eCorporation) && GC.getCorporationInfo(eCorporation).getTechPrereq() != NO_TECH)
		{
			szBuffer.append(gDLL->getText("TXT_KEY_CORPORATION_FOUNDED_FIRST",
				CvWString(GC.getTechInfo((TechTypes)kCorporation.getTechPrereq()).getType()).GetCString(),
				GC.getTechInfo((TechTypes)(kCorporation.getTechPrereq())).getTextKeyWide()));
		}
	}

	if (!bForceCorporation && !pCity->isHasCorporation(eCorporation))
	{
		return;
	}

	int iNumResources = 0;
	int iNumReqResources = 0;
	for (int i = 0; i < GC.getNUM_CORPORATION_PREREQ_BONUSES(); ++i)
	{
		BonusTypes eBonus = (BonusTypes)kCorporation.getPrereqBonus(i);
		if (NO_BONUS != eBonus)
		{
			iNumReqResources++;
			iNumResources += pCity->getNumBonuses(eBonus);
		}
	}

	bool bActive = ((pCity->isActiveCorporation(eCorporation) || (bForceCorporation && iNumResources > 0) || (iNumReqResources == 0)) &&
	(!GET_TEAM(pCity->getTeam()).isHasTech((TechTypes)kCorporation.getObsoleteTech()) || (kCorporation.getObsoleteTech() == NO_TECH)));
	bool bGenerates = kCorporation.getBonusProduced() != NO_BONUS || kCorporation.getHappiness() != 0 || kCorporation.getHealth() != 0;
	int iMaintenance = 0;

	bool bHandled = false;
	for (int i = 0; i < NUM_YIELD_TYPES; ++i)
	{
		int iYield = 0;

		if (bActive)
		{
			iYield += (kCorporation.getYieldProduced(i) * iNumResources * GC.getWorldInfo(GC.getMap().getWorldSize()).getCorporationMaintenancePercent()) / 100;
			iYield += 100 * kCorporation.getYieldChange(i);
		}

		if (iYield != 0)
		{
			if (bHandled)
			{
				szBuffer.append(L", ");
			}

			CvWString szTempBuffer;
			szTempBuffer.Format(L"%s%d%c", iYield > 0 ? L"+" : L"", (iYield + 99) / 100, GC.getYieldInfo((YieldTypes)i).getChar());
			szBuffer.append(szTempBuffer);
			bHandled = true;
		}
	}

	bHandled = false;
	for (int i = 0; i < NUM_COMMERCE_TYPES; ++i)
	{
		int iCommerce = 0;

		if (bActive)
		{
			iCommerce += (kCorporation.getCommerceProduced(i) * iNumResources * GC.getWorldInfo(GC.getMap().getWorldSize()).getCorporationMaintenancePercent()) / 100;

			iCommerce += 100 * kCorporation.getCommerceChange(i);
			iCommerce *= (GET_TEAM(pCity->getTeam()).getCorporationRevenueModifier() + 100);
			iCommerce /= 100;
			if (i == COMMERCE_GOLD)
			{
				iMaintenance += pCity->calculateCorporationMaintenanceTimes100(eCorporation);
				iMaintenance *= 100 + pCity->getMaintenanceModifier();
				iMaintenance /= 100;
				iCommerce -= iMaintenance;
			}
		}

		if (iCommerce != 0)
		{
			if (bHandled)
			{
				szBuffer.append(L", ");
			}

			CvWString szTempBuffer;
			szTempBuffer.Format(L"%s%d%c", iCommerce > 0 ? L"+" : L"", (iCommerce + 99) / 100, GC.getCommerceInfo((CommerceTypes)i).getChar());
			szBuffer.append(szTempBuffer);
			bHandled = true;
		}
	}

	if (bCityBar)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_CORPORATION_BONUS_REQUIRED"));
		bool bFirst = true;
		for (int i = 0; i < GC.getNUM_CORPORATION_PREREQ_BONUSES(); ++i)
		{
			if (NO_BONUS != kCorporation.getPrereqBonus(i))
			{
				if (bFirst)
				{
					bFirst = false;
				}
				else
				{
					szBuffer.append(L", ");
				}

				szBuffer.append(CvWString::format(L"%c", GC.getBonusInfo((BonusTypes)kCorporation.getPrereqBonus(i)).getChar()));
			}
		}

		if (bActive && bGenerates)
		{
			szBuffer.append(NEWLINE);
			if (kCorporation.getBonusProduced() != NO_BONUS)
			{
				szBuffer.append(gDLL->getText("TXT_KEY_CORPORATION_BONUS_PRODUCED", GC.getBonusInfo((BonusTypes)kCorporation.getBonusProduced()).getChar()));
			}
			else
			{
				szBuffer.append(gDLL->getText("TXT_KEY_CORPORATION_BONUS_GENERATES"));
			}
			if (kCorporation.getHappiness() != 0)
			{
				szBuffer.append(CvWString::format(L"%c", ((kCorporation.getHappiness() > 0) ? gDLL->getSymbolID(HAPPY_CHAR): gDLL->getSymbolID(UNHAPPY_CHAR))));
			}
			if (kCorporation.getHealth() != 0)
			{
				szBuffer.append(CvWString::format(L"%c", ((kCorporation.getHealth() > 0) ? gDLL->getSymbolID(HEALTHY_CHAR): gDLL->getSymbolID(UNHEALTHY_CHAR))));
			}
		}

	}
	else
	{
		if (bGenerates)
		{
			if (bActive)
			{
				if (bHandled)
				{
					szBuffer.append(L", ");
				}
				if (kCorporation.getBonusProduced() != NO_BONUS)
				{
					szBuffer.append(CvWString::format(L"%c", GC.getBonusInfo((BonusTypes)kCorporation.getBonusProduced()).getChar()));
				}
				if (kCorporation.getHappiness() != 0)
				{
					szBuffer.append(CvWString::format(L"%c", ((kCorporation.getHappiness() > 0) ? gDLL->getSymbolID(HAPPY_CHAR): gDLL->getSymbolID(UNHAPPY_CHAR))));
				}
				if (kCorporation.getHealth() != 0)
				{
					szBuffer.append(CvWString::format(L"%c", ((kCorporation.getHealth() > 0) ? gDLL->getSymbolID(HEALTHY_CHAR): gDLL->getSymbolID(UNHEALTHY_CHAR))));
				}
			}
		}
	}
}

void CvGameTextMgr::buildObsoleteString(CvWStringBuffer &szBuffer, int iItem, bool bList, bool bPlayerContext)
{
	CvWString szTempBuffer;

	if (bList)
	{
		szBuffer.append(NEWLINE);
	}
	szBuffer.append(gDLL->getText("TXT_KEY_TECH_OBSOLETES", CvWString(GC.getBuildingInfo((BuildingTypes)iItem).getType()).GetCString(), GC.getBuildingInfo((BuildingTypes) iItem).getTextKeyWide()));
}

void CvGameTextMgr::buildObsoleteBonusString(CvWStringBuffer &szBuffer, int iItem, bool bList, bool bPlayerContext)
{
	CvWString szTempBuffer;

	if (bList)
	{
		szBuffer.append(NEWLINE);
	}
	szBuffer.append(gDLL->getText("TXT_KEY_TECH_OBSOLETES", CvWString(GC.getBonusInfo((BonusTypes)iItem).getType()).GetCString(), GC.getBonusInfo((BonusTypes) iItem).getTextKeyWide()));
}

void CvGameTextMgr::buildObsoleteSpecialString(CvWStringBuffer &szBuffer, int iItem, bool bList, bool bPlayerContext)
{
	CvWString szTempBuffer;

	if (bList)
	{
		szBuffer.append(NEWLINE);
	}
	szBuffer.append(gDLL->getText("TXT_KEY_TECH_OBSOLETES_NO_LINK", GC.getSpecialBuildingInfo((SpecialBuildingTypes) iItem).getTextKeyWide()));
}

void CvGameTextMgr::buildMoveString(CvWStringBuffer &szBuffer, TechTypes eTech, bool bList, bool bPlayerContext)
{
	int iI;
	int iMoveDiff;

	for (iI = 0; iI < GC.getNumRouteInfos(); ++iI)
	{
		iMoveDiff = ((GC.getMOVE_DENOMINATOR() / std::max(1, (GC.getRouteInfo((RouteTypes) iI).getMovementCost() + ((bPlayerContext) ? GET_TEAM(GC.getGame().getActiveTeam()).getRouteChange((RouteTypes)iI) : 0)))) - (GC.getMOVE_DENOMINATOR() / std::max(1, (GC.getRouteInfo((RouteTypes) iI).getMovementCost() + ((bPlayerContext) ? GET_TEAM(GC.getGame().getActiveTeam()).getRouteChange((RouteTypes)iI) : 0) + GC.getRouteInfo((RouteTypes) iI).getTechMovementChange(eTech)))));

		if (iMoveDiff != 0)
		{
			if (bList)
			{
				szBuffer.append(NEWLINE);
			}
			szBuffer.append(gDLL->getText("TXT_KEY_UNIT_MOVEMENT", -(iMoveDiff), GC.getRouteInfo((RouteTypes) iI).getTextKeyWide()));
			bList = true;
		}
	}
}

void CvGameTextMgr::buildFreeUnitString(CvWStringBuffer &szBuffer, TechTypes eTech, bool bList, bool bPlayerContext)
{
	UnitTypes eFreeUnit = NO_UNIT;
	if (GC.getGame().getActivePlayer() != NO_PLAYER)
	{
		eFreeUnit = GET_PLAYER(GC.getGame().getActivePlayer()).getTechFreeUnit(eTech);
	}
	else if (GC.getTechInfo(eTech).getFirstFreeUnit() != NO_UNIT)
	{
		eFreeUnit = (UnitTypes)GC.getTechInfo(eTech).getFirstFreeUnit();
	}
	if (eFreeUnit != NO_UNIT && (!bPlayerContext || GC.getGame().countKnownTechNumTeams(eTech) == 0))
	{
		if (bList)
		{
			szBuffer.append(NEWLINE);
		}
		szBuffer.append(gDLL->getText("TXT_KEY_TECH_FIRST_RECEIVES", CvWString(GC.getUnitInfo(eFreeUnit).getType()).GetCString(), GC.getUnitInfo(eFreeUnit).getTextKeyWide()));
	}
}

void CvGameTextMgr::buildFeatureProductionString(CvWStringBuffer &szBuffer, TechTypes eTech, bool bList, bool bPlayerContext)
{
	if (GC.getTechInfo(eTech).getFeatureProductionModifier() != 0)
	{
		if (bList)
		{
			szBuffer.append(NEWLINE);
		}
		szBuffer.append(gDLL->getText("TXT_KEY_FEATURE_PRODUCTION_MODIFIER", GC.getTechInfo(eTech).getFeatureProductionModifier()));
	}
}

void CvGameTextMgr::buildWorkerRateString(CvWStringBuffer &szBuffer, TechTypes eTech, bool bList, bool bPlayerContext)
{
	if (GC.getTechInfo(eTech).getWorkerSpeedModifier() != 0)
	{
		if (bList)
		{
			szBuffer.append(NEWLINE);
		}
		szBuffer.append(gDLL->getText("TXT_KEY_UNIT_WORKERS_FASTER", GC.getTechInfo(eTech).getWorkerSpeedModifier()));
	}
}

void CvGameTextMgr::buildTradeRouteString(CvWStringBuffer &szBuffer, TechTypes eTech, bool bList, bool bPlayerContext)
{
	if (GC.getTechInfo(eTech).getTradeRoutes() != 0)
	{
		if (bList)
		{
			szBuffer.append(NEWLINE);
		}
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_TRADE_ROUTES", GC.getTechInfo(eTech).getTradeRoutes()));
	}
}

void CvGameTextMgr::buildHealthRateString(CvWStringBuffer &szBuffer, TechTypes eTech, bool bList, bool bPlayerContext)
{
	if (GC.getTechInfo(eTech).getHealth() != 0)
	{
		if (bList)
		{
			szBuffer.append(NEWLINE);
		}
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_HEALTH_ALL_CITIES", abs(GC.getTechInfo(eTech).getHealth()), ((GC.getTechInfo(eTech).getHealth() > 0) ? gDLL->getSymbolID(HEALTHY_CHAR): gDLL->getSymbolID(UNHEALTHY_CHAR))));
	}
}

//Team Project (1)
void CvGameTextMgr::buildSpecialistHealthString(CvWStringBuffer &szBuffer, TechTypes eTech, bool bList, bool bPlayerContext)
{
	int iI;
	int iJ;
	int iSpecialistHealth = 0;
	for (iI = 0; iI < GC.getNumSpecialistInfos(); iI++)
	{
		iSpecialistHealth = 0;
		SpecialistTypes eSpecialist = ((SpecialistTypes)iI);
		for (iJ = 0; iJ < GC.getSpecialistInfo(eSpecialist).getNumTechHealthTypes(); iJ++)
		{
			if (GC.getSpecialistInfo(eSpecialist).getTechHealthType(iJ).eTech == eTech)
			{
				iSpecialistHealth += GC.getSpecialistInfo(eSpecialist).getTechHealthType(iJ).iModifier;
			}
		}

		if (iSpecialistHealth > 0)
		{
			if (bList)
			{
				szBuffer.append(NEWLINE);
			}
			szBuffer.append(gDLL->getText("TXT_KEY_TECH_SPECIALIST_TECH_HEALTH_TYPE", GC.getSpecialistInfo(eSpecialist).getTextKeyWide(), iSpecialistHealth, gDLL->getSymbolID(HEALTHY_CHAR)));
		}
		else if (iSpecialistHealth < 0)
		{
			if (bList)
			{
				szBuffer.append(NEWLINE);
			}
			szBuffer.append(gDLL->getText("TXT_KEY_TECH_SPECIALIST_TECH_HEALTH_TYPE", GC.getSpecialistInfo(eSpecialist).getTextKeyWide(), -iSpecialistHealth, gDLL->getSymbolID(UNHEALTHY_CHAR)));
		}
	}
}

void CvGameTextMgr::buildHappinessRateString(CvWStringBuffer &szBuffer, TechTypes eTech, bool bList, bool bPlayerContext)
{
	if (GC.getTechInfo(eTech).getHappiness() != 0)
	{
		if (bList)
		{
			szBuffer.append(NEWLINE);
		}
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_HAPPINESS_ALL_CITIES", abs(GC.getTechInfo(eTech).getHappiness()), ((GC.getTechInfo(eTech).getHappiness() > 0) ? gDLL->getSymbolID(HAPPY_CHAR): gDLL->getSymbolID(UNHAPPY_CHAR))));
	}
}

//Team Project (1)
void CvGameTextMgr::buildSpecialistHappinessString(CvWStringBuffer &szBuffer, TechTypes eTech, bool bList, bool bPlayerContext)
{
	for (int iI = 0; iI < GC.getNumSpecialistInfos(); iI++)
	{
		int iSpecialistHappiness = 0;
		SpecialistTypes eSpecialist = ((SpecialistTypes)iI);
		for (int iJ = 0; iJ < GC.getSpecialistInfo(eSpecialist).getNumTechHappinessTypes(); iJ++)
		{
			if (GC.getSpecialistInfo(eSpecialist).getTechHappinessType(iJ).eTech == eTech)
			{
				iSpecialistHappiness += GC.getSpecialistInfo(eSpecialist).getTechHappinessType(iJ).iModifier;
			}
		}
		if (iSpecialistHappiness > 0)
		{
			if (bList)
			{
				szBuffer.append(NEWLINE);
			}
			szBuffer.append(gDLL->getText("TXT_KEY_TECH_SPECIALIST_TECH_HAPPINESS_TYPE", GC.getSpecialistInfo(eSpecialist).getTextKeyWide(), iSpecialistHappiness, gDLL->getSymbolID(HAPPY_CHAR)));
		}
		else if (iSpecialistHappiness < 0)
		{
			if (bList)
			{
				szBuffer.append(NEWLINE);
			}
			szBuffer.append(gDLL->getText("TXT_KEY_TECH_SPECIALIST_TECH_HAPPINESS_TYPE", GC.getSpecialistInfo(eSpecialist).getTextKeyWide(), -iSpecialistHappiness, gDLL->getSymbolID(UNHAPPY_CHAR)));
		}
	}
}

void CvGameTextMgr::buildFreeTechString(CvWStringBuffer &szBuffer, TechTypes eTech, bool bList, bool bPlayerContext)
{
	if (GC.getTechInfo(eTech).getFirstFreeTechs() > 0)
	{
		if (!bPlayerContext || (GC.getGame().countKnownTechNumTeams(eTech) == 0))
		{
			if (bList)
			{
				szBuffer.append(NEWLINE);
			}

			if (GC.getTechInfo(eTech).getFirstFreeTechs() == 1)
			{
				szBuffer.append(gDLL->getText("TXT_KEY_TECH_FIRST_FREE_TECH"));
			}
			else
			{
				szBuffer.append(gDLL->getText("TXT_KEY_TECH_FIRST_FREE_TECHS", GC.getTechInfo(eTech).getFirstFreeTechs()));
			}
		}
	}
}

void CvGameTextMgr::buildLOSString(CvWStringBuffer &szBuffer, TechTypes eTech, bool bList, bool bPlayerContext)
{
	if (GC.getTechInfo(eTech).isExtraWaterSeeFrom() && (!bPlayerContext || !(GET_TEAM(GC.getGame().getActiveTeam()).isExtraWaterSeeFrom())))
	{
		if (bList)
		{
			szBuffer.append(NEWLINE);
		}
		szBuffer.append(gDLL->getText("TXT_KEY_UNIT_EXTRA_SIGHT"));
	}
}

void CvGameTextMgr::buildMapCenterString(CvWStringBuffer &szBuffer, TechTypes eTech, bool bList, bool bPlayerContext)
{
	if (GC.getTechInfo(eTech).isMapCentering() && (!bPlayerContext || !(GET_TEAM(GC.getGame().getActiveTeam()).isMapCentering())))
	{
		if (bList)
		{
			szBuffer.append(NEWLINE);
		}
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_CENTERS_MAP"));
	}
}

void CvGameTextMgr::buildMapRevealString(CvWStringBuffer &szBuffer, TechTypes eTech, bool bList)
{
	if (GC.getTechInfo(eTech).isMapVisible())
	{
		if (bList)
		{
			szBuffer.append(NEWLINE);
		}
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_REVEALS_MAP"));
	}
}

void CvGameTextMgr::buildMapTradeString(CvWStringBuffer &szBuffer, TechTypes eTech, bool bList, bool bPlayerContext)
{
	if (GC.getTechInfo(eTech).isMapTrading() && (!bPlayerContext || !(GET_TEAM(GC.getGame().getActiveTeam()).isMapTrading())))
	{
		if (bList)
		{
			szBuffer.append(NEWLINE);
		}
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_ENABLES_MAP_TRADING"));
	}
}

void CvGameTextMgr::buildTechTradeString(CvWStringBuffer &szBuffer, TechTypes eTech, bool bList, bool bPlayerContext)
{
	if (GC.getTechInfo(eTech).isTechTrading() && (!bPlayerContext || !(GET_TEAM(GC.getGame().getActiveTeam()).isTechTrading())))
	{
		if (bList)
		{
			szBuffer.append(NEWLINE);
		}
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_ENABLES_TECH_TRADING"));
	}
}

void CvGameTextMgr::buildGoldTradeString(CvWStringBuffer &szBuffer, TechTypes eTech, bool bList, bool bPlayerContext)
{
	if (GC.getTechInfo(eTech).isGoldTrading() && (!bPlayerContext || !(GET_TEAM(GC.getGame().getActiveTeam()).isGoldTrading())))
	{
		if (bList)
		{
			szBuffer.append(NEWLINE);
		}
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_ENABLES_GOLD_TRADING"));
	}
}

void CvGameTextMgr::buildOpenBordersString(CvWStringBuffer &szBuffer, TechTypes eTech, bool bList, bool bPlayerContext)
{
	if (GC.getTechInfo(eTech).isOpenBordersTrading() && (!bPlayerContext || !(GET_TEAM(GC.getGame().getActiveTeam()).isOpenBordersTrading())))
	{
		if (bList)
		{
			szBuffer.append(NEWLINE);
		}
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_ENABLES_OPEN_BORDERS"));
	}
}

void CvGameTextMgr::buildDefensivePactString(CvWStringBuffer &szBuffer, TechTypes eTech, bool bList, bool bPlayerContext)
{
	if (GC.getTechInfo(eTech).isDefensivePactTrading() && (!bPlayerContext || !(GET_TEAM(GC.getGame().getActiveTeam()).isDefensivePactTrading())))
	{
		if (bList)
		{
			szBuffer.append(NEWLINE);
		}
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_ENABLES_DEFENSIVE_PACTS"));
	}
}

void CvGameTextMgr::buildPermanentAllianceString(CvWStringBuffer &szBuffer, TechTypes eTech, bool bList, bool bPlayerContext)
{
	if (GC.getTechInfo(eTech).isPermanentAllianceTrading() && (!bPlayerContext || (!(GET_TEAM(GC.getGame().getActiveTeam()).isPermanentAllianceTrading()) && GC.getGame().isOption(GAMEOPTION_PERMANENT_ALLIANCES))))
	{
		if (bList)
		{
			szBuffer.append(NEWLINE);
		}
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_ENABLES_PERM_ALLIANCES"));
	}
}

void CvGameTextMgr::buildVassalStateString(CvWStringBuffer &szBuffer, TechTypes eTech, bool bList, bool bPlayerContext)
{
	if (GC.getTechInfo(eTech).isVassalStateTrading() && (!bPlayerContext || (!(GET_TEAM(GC.getGame().getActiveTeam()).isVassalStateTrading()) && GC.getGame().isOption(GAMEOPTION_NO_VASSAL_STATES))))
	{
		if (bList)
		{
			szBuffer.append(NEWLINE);
		}
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_ENABLES_VASSAL_STATES"));
	}
}


void CvGameTextMgr::buildEmbassyString(CvWStringBuffer &szBuffer, TechTypes eTech, bool bList, bool bPlayerContext)
{
	if (GC.getGame().isOption(GAMEOPTION_ADVANCED_DIPLOMACY))
	{
		if (GC.getTechInfo(eTech).isEmbassyTrading() && (!bPlayerContext || !(GET_TEAM(GC.getGame().getActiveTeam()).isEmbassyTrading())))
		{
			if (bList)
			{
				szBuffer.append(NEWLINE);
			}
			szBuffer.append(gDLL->getText("TXT_KEY_MISC_ENABLES_EMBASSIES"));
		}
	}
}


void CvGameTextMgr::buildBridgeString(CvWStringBuffer &szBuffer, TechTypes eTech, bool bList, bool bPlayerContext)
{
	if (GC.getTechInfo(eTech).isBridgeBuilding() && (!bPlayerContext || !(GET_TEAM(GC.getGame().getActiveTeam()).isBridgeBuilding())))
	{
		if (bList)
		{
			szBuffer.append(NEWLINE);
		}
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_ENABLES_BRIDGE_BUILDING"));
	}
}

void CvGameTextMgr::buildIrrigationString(CvWStringBuffer &szBuffer, TechTypes eTech, bool bList, bool bPlayerContext)
{
	if (GC.getTechInfo(eTech).isIrrigation() && (!bPlayerContext || !(GET_TEAM(GC.getGame().getActiveTeam()).isIrrigation())))
	{
		if (bList)
		{
			szBuffer.append(NEWLINE);
		}
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_SPREAD_IRRIGATION"));
	}
}

void CvGameTextMgr::buildIgnoreIrrigationString(CvWStringBuffer &szBuffer, TechTypes eTech, bool bList, bool bPlayerContext)
{
	if (GC.getTechInfo(eTech).isIgnoreIrrigation() && (!bPlayerContext || !(GET_TEAM(GC.getGame().getActiveTeam()).isIgnoreIrrigation())))
	{
		if (bList)
		{
			szBuffer.append(NEWLINE);
		}
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_IRRIGATION_ANYWHERE"));
	}
}

void CvGameTextMgr::buildWaterWorkString(CvWStringBuffer &szBuffer, TechTypes eTech, bool bList, bool bPlayerContext)
{
	if (GC.getTechInfo(eTech).isWaterWork() && (!bPlayerContext || !(GET_TEAM(GC.getGame().getActiveTeam()).isWaterWork())))
	{
		if (bList)
		{
			szBuffer.append(NEWLINE);
		}
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_WATER_WORK"));
	}
}

void CvGameTextMgr::buildImprovementString(CvWStringBuffer &szBuffer, TechTypes eTech, int iImprovement, bool bList, bool bPlayerContext)
{
	bool bTechFound;
	int iJ;

	bool bIsTeam = (GC.getGame().getActiveTeam() != NO_TEAM);

	bTechFound = false;

	if (GC.getBuildInfo((BuildTypes) iImprovement).getTechPrereq() == NO_TECH)
	{
		for (iJ = 0; iJ < GC.getNumFeatureInfos(); iJ++)
		{
			if (GC.getBuildInfo((BuildTypes) iImprovement).getFeatureTech(iJ) == eTech)
			{
				bTechFound = true;
			}
		}
		for (iJ = 0; iJ < GC.getBuildInfo((BuildTypes)iImprovement).getNumTerrainStructs(); iJ++)
		{
			if (GC.getBuildInfo((BuildTypes)iImprovement).getTerrainStruct(iJ).ePrereqTech == eTech)
			{
				bTechFound = true;
			}
		}
	}
	else
	{
		if (GC.getBuildInfo((BuildTypes) iImprovement).getTechPrereq() == eTech)
		{
			bTechFound = true;
		}
	}

	if (bTechFound)
	{
		if (bList)
		{
			szBuffer.append(NEWLINE);
		}
		if (bIsTeam)
		{
			if (GC.getBuildInfo((BuildTypes)iImprovement).getObsoleteTech() != NO_TECH)
			{
				if (GET_TEAM(GC.getGame().getActiveTeam()).isHasTech((TechTypes)GC.getBuildInfo((BuildTypes)iImprovement).getObsoleteTech()))
				{
					szBuffer.append(gDLL->getText("TXT_KEY_TECH_OBSOLETES", CvWString(GC.getBuildInfo((BuildTypes)iImprovement).getType()).GetCString(), GC.getBuildInfo((BuildTypes)iImprovement).getTextKeyWide()));
				}
				else
				{
					szBuffer.append(gDLL->getText("TXT_KEY_MISC_CAN_BUILD_IMPROVEMENT", GC.getBuildInfo((BuildTypes) iImprovement).getTextKeyWide()));
				}
			}
			else
			{
				szBuffer.append(gDLL->getText("TXT_KEY_MISC_CAN_BUILD_IMPROVEMENT", GC.getBuildInfo((BuildTypes) iImprovement).getTextKeyWide()));
			}
		}
		else
		{
			szBuffer.append(gDLL->getText("TXT_KEY_MISC_CAN_BUILD_IMPROVEMENT", GC.getBuildInfo((BuildTypes) iImprovement).getTextKeyWide()));
		}
	}
	for (int iI = 0; iI < GC.getBuildInfo((BuildTypes) iImprovement).getNumMapCategoryTypes(); iI++)
	{
		MapCategoryTypes eMapCategory = (MapCategoryTypes)GC.getBuildInfo((BuildTypes) iImprovement).getMapCategoryType(iI);
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_MAP_CATEGORY_PREREQUISITE", GC.getMapCategoryInfo(eMapCategory).getTextKeyWide()));
	}
}

void CvGameTextMgr::buildDomainExtraMovesString(CvWStringBuffer &szBuffer, TechTypes eTech, int iDomainType, bool bList, bool bPlayerContext)
{
	if (GC.getTechInfo(eTech).getDomainExtraMoves(iDomainType) != 0)
	{
		if (bList)
		{
			szBuffer.append(NEWLINE);
		}

		if (iDomainType == DOMAIN_AIR)
		{
			szBuffer.append(gDLL->getText("TXT_KEY_MISC_EXTRA_RANGE", GC.getTechInfo(eTech).getDomainExtraMoves(iDomainType)));
		}
		else
		{
			szBuffer.append(gDLL->getText("TXT_KEY_MISC_EXTRA_MOVES", GC.getTechInfo(eTech).getDomainExtraMoves(iDomainType), GC.getDomainInfo((DomainTypes)iDomainType).getTextKeyWide()));
		}
	}
}

void CvGameTextMgr::buildAdjustString(CvWStringBuffer &szBuffer, TechTypes eTech, int iCommerceType, bool bList, bool bPlayerContext)
{
	if (GC.getTechInfo(eTech).isCommerceFlexible(iCommerceType) && (!bPlayerContext || !(GET_TEAM(GC.getGame().getActiveTeam()).isCommerceFlexible((CommerceTypes)iCommerceType))))
	{
		if (bList)
		{
			szBuffer.append(NEWLINE);
		}
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_ADJUST_COMMERCE_RATE", GC.getCommerceInfo((CommerceTypes) iCommerceType).getChar()));
	}
}

void CvGameTextMgr::buildTerrainTradeString(CvWStringBuffer &szBuffer, TechTypes eTech, int iTerrainType, bool bList, bool bPlayerContext)
{
	if (GC.getTechInfo(eTech).isTerrainTrade(iTerrainType) && (!bPlayerContext || !(GET_TEAM(GC.getGame().getActiveTeam()).isTerrainTrade((TerrainTypes)iTerrainType))))
	{
		if (bList)
		{
			szBuffer.append(NEWLINE);
		}
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_ENABLES_ON_TERRAIN", gDLL->getSymbolID(TRADE_CHAR), GC.getTerrainInfo((TerrainTypes) iTerrainType).getTextKeyWide()));
	}
}

void CvGameTextMgr::buildRiverTradeString(CvWStringBuffer &szBuffer, TechTypes eTech, bool bList, bool bPlayerContext)
{
	if (GC.getTechInfo(eTech).isRiverTrade() && (!bPlayerContext || !(GET_TEAM(GC.getGame().getActiveTeam()).isRiverTrade())))
	{
		if (bList)
		{
			szBuffer.append(NEWLINE);
		}
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_ENABLES_ON_TERRAIN", gDLL->getSymbolID(TRADE_CHAR), gDLL->getText("TXT_KEY_MISC_RIVERS").GetCString()));
	}
}

void CvGameTextMgr::buildSpecialBuildingString(CvWStringBuffer &szBuffer, TechTypes eTech, int iBuildingType, bool bList, bool bPlayerContext)
{
	if (GC.getSpecialBuildingInfo((SpecialBuildingTypes)iBuildingType).getTechPrereq() == eTech)
	{
		if (bList)
		{
			szBuffer.append(NEWLINE);
		}
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_CAN_CONSTRUCT_BUILDING", GC.getSpecialBuildingInfo((SpecialBuildingTypes) iBuildingType).getTextKeyWide()));
	}

	if (GC.getSpecialBuildingInfo((SpecialBuildingTypes)iBuildingType).getTechPrereqAnyone() == eTech)
	{
		if (bList)
		{
			szBuffer.append(NEWLINE);
		}
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_CAN_CONSTRUCT_BUILDING_ANYONE", CvWString(GC.getSpecialBuildingInfo((SpecialBuildingTypes) iBuildingType).getType()).GetCString(), GC.getSpecialBuildingInfo((SpecialBuildingTypes) iBuildingType).getTextKeyWide()));
	}
}

void CvGameTextMgr::buildYieldChangeString(CvWStringBuffer &szBuffer, TechTypes eTech, int iYieldType, bool bList, bool bPlayerContext)
{
	CvWString szTempBuffer;
	if (bList)
	{
		szTempBuffer.Format(L"<link=%s>%s</link>", CvWString(GC.getImprovementInfo((ImprovementTypes)iYieldType).getType()).GetCString(), GC.getImprovementInfo((ImprovementTypes)iYieldType).getDescription());
	}
	else
	{
		szTempBuffer.Format(L"%c<link=%s>%s</link>", gDLL->getSymbolID(BULLET_CHAR), CvWString(GC.getImprovementInfo((ImprovementTypes)iYieldType).getType()).GetCString(), GC.getImprovementInfo((ImprovementTypes)iYieldType).getDescription());
	}

	setYieldChangeHelp(szBuffer, szTempBuffer, L": ", L"", GC.getImprovementInfo((ImprovementTypes)iYieldType).getTechYieldChangesArray(eTech), false, bList);
}


void CvGameTextMgr::buildBuildingTechCommerceChangeString(CvWStringBuffer &szBuffer, TechTypes eTech, int iBuildingType, bool bList, bool bPlayerContext)
{
	CvWString szTempBuffer;
	if (bList)
	{
		szTempBuffer.Format(L"<link=%s>%s</link>", CvWString(GC.getBuildingInfo((BuildingTypes)iBuildingType).getType()).GetCString(), GC.getBuildingInfo((BuildingTypes)iBuildingType).getDescription());
	}
	else
	{
		szTempBuffer.Format(L"%c<link=%s>%s</link>", gDLL->getSymbolID(BULLET_CHAR), CvWString(GC.getBuildingInfo((BuildingTypes)iBuildingType).getType()).GetCString(), GC.getBuildingInfo((BuildingTypes)iBuildingType).getDescription());
	}

	setCommerceChangeHelp(szBuffer, szTempBuffer, L": ", L"", GC.getBuildingInfo((BuildingTypes)iBuildingType).getTechCommerceChangeArray(eTech), false, bList);
}


void CvGameTextMgr::buildBuildingTechYieldChangeString(CvWStringBuffer &szBuffer, TechTypes eTech, int iBuildingType, bool bList, bool bPlayerContext)
{
	CvWString szTempBuffer;
	if (bList)
	{
		szTempBuffer.Format(L"<link=%s>%s</link>", CvWString(GC.getBuildingInfo((BuildingTypes)iBuildingType).getType()).GetCString(), GC.getBuildingInfo((BuildingTypes)iBuildingType).getDescription());
	}
	else
	{
		szTempBuffer.Format(L"%c<link=%s>%s</link>", gDLL->getSymbolID(BULLET_CHAR), CvWString(GC.getBuildingInfo((BuildingTypes)iBuildingType).getType()).GetCString(), GC.getBuildingInfo((BuildingTypes)iBuildingType).getDescription());
	}

	setYieldChangeHelp(szBuffer, szTempBuffer, L": ", L"", GC.getBuildingInfo((BuildingTypes)iBuildingType).getTechYieldChangeArray(eTech), false, bList);
}


void CvGameTextMgr::buildBuildingTechSpecialistChangeString(CvWStringBuffer &szBuffer, TechTypes eTech, int iBuildingType, bool bList, bool bPlayerContext)
{
	CvWString szTempBuffer;
	for (int iSpecialist = 0; iSpecialist < GC.getNumSpecialistInfos(); iSpecialist++)
	{
		int iChange = GC.getBuildingInfo((BuildingTypes)iBuildingType).getTechSpecialistChange(eTech, iSpecialist);
		if (0 != iChange)
		{
			szBuffer.append(NEWLINE);
			if (bList)
			{
				szTempBuffer.Format(L"%c<link=%s>%s</link>: ", gDLL->getSymbolID(BULLET_CHAR), CvWString(GC.getBuildingInfo((BuildingTypes)iBuildingType).getType()).GetCString(), GC.getBuildingInfo((BuildingTypes)iBuildingType).getDescription());
			}
			else
			{
				szTempBuffer.Format(L"<link=%s>%s</link>: ", CvWString(GC.getBuildingInfo((BuildingTypes)iBuildingType).getType()).GetCString(), GC.getBuildingInfo((BuildingTypes)iBuildingType).getDescription());
			}
			szBuffer.append(szTempBuffer);
			if (iChange == 1)
			{
				szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_TURN_CITIZEN_INTO_NO_BULLET", CvWString(GC.getSpecialistInfo((SpecialistTypes) iSpecialist).getType()).GetCString(), GC.getSpecialistInfo((SpecialistTypes) iSpecialist).getTextKeyWide()));
			}
			else
			{
				szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_TURN_CITIZENS_INTO_NO_BULLET", iChange, CvWString(GC.getSpecialistInfo((SpecialistTypes)iSpecialist).getType()).GetCString(), GC.getSpecialistInfo((SpecialistTypes) iSpecialist).getTextKeyWide()));
			}
		}
	}
}

void CvGameTextMgr::buildBuildingTechCommerceModifierString(CvWStringBuffer &szBuffer, TechTypes eTech, int iBuildingType, bool bList, bool bPlayerContext)
{
	CvWString szTempBuffer;
	if (bList)
	{
		szTempBuffer.Format(L"<link=%s>%s</link>", CvWString(GC.getBuildingInfo((BuildingTypes)iBuildingType).getType()).GetCString(), GC.getBuildingInfo((BuildingTypes)iBuildingType).getDescription());
	}
	else
	{
		szTempBuffer.Format(L"%c<link=%s>%s</link>", gDLL->getSymbolID(BULLET_CHAR), CvWString(GC.getBuildingInfo((BuildingTypes)iBuildingType).getType()).GetCString(), GC.getBuildingInfo((BuildingTypes)iBuildingType).getDescription());
	}

	setCommerceChangeHelp(szBuffer, szTempBuffer, L": ", L"", GC.getBuildingInfo((BuildingTypes)iBuildingType).getTechCommerceModifierArray(eTech), true, bList);
}


void CvGameTextMgr::buildBuildingTechYieldModifierString(CvWStringBuffer &szBuffer, TechTypes eTech, int iBuildingType, bool bList, bool bPlayerContext)
{
	CvWString szTempBuffer;
	if (bList)
	{
		szTempBuffer.Format(L"<link=%s>%s</link>", CvWString(GC.getBuildingInfo((BuildingTypes)iBuildingType).getType()).GetCString(), GC.getBuildingInfo((BuildingTypes)iBuildingType).getDescription());
	}
	else
	{
		szTempBuffer.Format(L"%c<link=%s>%s</link>", gDLL->getSymbolID(BULLET_CHAR), CvWString(GC.getBuildingInfo((BuildingTypes)iBuildingType).getType()).GetCString(), GC.getBuildingInfo((BuildingTypes)iBuildingType).getDescription());
	}

	setYieldChangeHelp(szBuffer, szTempBuffer, L": ", L"", GC.getBuildingInfo((BuildingTypes)iBuildingType).getTechYieldModifierArray(eTech), true, bList);
}

void CvGameTextMgr::buildBuildingTechHappinessChangesString(CvWStringBuffer &szBuffer, TechTypes eTech, int iBuildingType, bool bList, bool bPlayerContext)
{
	CvWString szTempBuffer;
	CvWString szFirstBuffer;
	if (GC.getBuildingInfo((BuildingTypes)iBuildingType).getTechHappinessChanges(eTech) != 0)
	{
		szTempBuffer.Format(L"%s%c+%d%c%s<link=%s>%s</link>", NEWLINE, gDLL->getSymbolID(BULLET_CHAR), abs(GC.getBuildingInfo((BuildingTypes)iBuildingType).getTechHappinessChanges(eTech)), (((GC.getBuildingInfo((BuildingTypes)iBuildingType).getTechHappinessChanges(eTech) > 0) ? gDLL->getSymbolID(HAPPY_CHAR): gDLL->getSymbolID(UNHAPPY_CHAR))), gDLL->getText("TXT_KEY_WITH").GetCString(), CvWString(GC.getBuildingInfo((BuildingTypes)iBuildingType).getType()).GetCString(), GC.getBuildingInfo((BuildingTypes)iBuildingType).getDescription());
		setListHelp(szBuffer, szFirstBuffer, szTempBuffer, L", ", true);
	}
}

void CvGameTextMgr::buildBuildingTechHealthChangesString(CvWStringBuffer &szBuffer, TechTypes eTech, int iBuildingType, bool bList, bool bPlayerContext)
{
	CvWString szTempBuffer;
	CvWString szFirstBuffer;
	if (GC.getBuildingInfo((BuildingTypes)iBuildingType).getTechHealthChanges(eTech) != 0)
	{
		szTempBuffer.Format(L"%s%c+%d%c%s<link=%s>%s</link>", NEWLINE, gDLL->getSymbolID(BULLET_CHAR), abs(GC.getBuildingInfo((BuildingTypes)iBuildingType).getTechHealthChanges(eTech)), (((GC.getBuildingInfo((BuildingTypes)iBuildingType).getTechHealthChanges(eTech) > 0) ? gDLL->getSymbolID(HEALTHY_CHAR): gDLL->getSymbolID(UNHEALTHY_CHAR))), gDLL->getText("TXT_KEY_WITH").GetCString(), CvWString(GC.getBuildingInfo((BuildingTypes)iBuildingType).getType()).GetCString(), GC.getBuildingInfo((BuildingTypes)iBuildingType).getDescription());
		setListHelp(szBuffer, szFirstBuffer, szTempBuffer, L", ", true);
	}
}


bool CvGameTextMgr::buildBonusRevealString(CvWStringBuffer &szBuffer, TechTypes eTech, int iBonusType, bool bFirst, bool bList, bool bPlayerContext)
{
	CvWString szTempBuffer;

	if (GC.getBonusInfo((BonusTypes) iBonusType).getTechReveal() == eTech)
	{
		if (bList && bFirst)
		{
			szBuffer.append(NEWLINE);
		}
		szTempBuffer.Format( SETCOLR L"<link=%s>%s</link>" ENDCOLR , TEXT_COLOR("COLOR_HIGHLIGHT_TEXT"), CvWString(GC.getBonusInfo((BonusTypes) iBonusType).getType()).GetCString(), GC.getBonusInfo((BonusTypes) iBonusType).getDescription());
		setListHelp(szBuffer, gDLL->getText("TXT_KEY_MISC_REVEALS").c_str(), szTempBuffer, L", ", bFirst);
		bFirst = false;
	}
	return bFirst;
}

bool CvGameTextMgr::buildCivicRevealString(CvWStringBuffer &szBuffer, TechTypes eTech, int iCivicType, bool bFirst, bool bList, bool bPlayerContext)
{
	CvWString szTempBuffer;

	if (GC.getCivicInfo((CivicTypes) iCivicType).getTechPrereq() == eTech)
	{
		if (bList && bFirst)
		{
			szBuffer.append(NEWLINE);
		}
		szTempBuffer.Format( SETCOLR L"<link=%s>%s</link>" ENDCOLR , TEXT_COLOR("COLOR_HIGHLIGHT_TEXT"), CvWString(GC.getCivicInfo((CivicTypes) iCivicType).getType()).GetCString(), GC.getCivicInfo((CivicTypes) iCivicType).getDescription());
		setListHelp(szBuffer, gDLL->getText("TXT_KEY_MISC_ENABLES").c_str(), szTempBuffer, L", ", bFirst);
		bFirst = false;
	}
	return bFirst;
}

bool CvGameTextMgr::buildProcessInfoString(CvWStringBuffer &szBuffer, TechTypes eTech, int iProcessType, bool bFirst, bool bList, bool bPlayerContext)
{
	CvWString szTempBuffer;

	if (GC.getProcessInfo((ProcessTypes) iProcessType).getTechPrereq() == eTech)
	{
		if (bList && bFirst)
		{
			szBuffer.append(NEWLINE);
		}
		szTempBuffer.Format( SETCOLR L"<link=%s>%s</link>" ENDCOLR , TEXT_COLOR("COLOR_HIGHLIGHT_TEXT"), CvWString(GC.getProcessInfo((ProcessTypes) iProcessType).getType()).GetCString(), GC.getProcessInfo((ProcessTypes) iProcessType).getDescription());
		setListHelp(szBuffer, gDLL->getText("TXT_KEY_MISC_CAN_BUILD").c_str(), szTempBuffer, L", ", bFirst);
		bFirst = false;
	}
	return bFirst;
}

bool CvGameTextMgr::buildFoundReligionString(CvWStringBuffer &szBuffer, TechTypes eTech, int iReligionType, bool bFirst, bool bList, bool bPlayerContext)
{
	CvWString szTempBuffer;

	if (GC.getReligionInfo((ReligionTypes) iReligionType).getTechPrereq() == eTech)
	{
/************************************************************************************************/
/* REVDCM								 04/29/10								phungus420	*/
/*																							  */
/* Player Functions																			 */
/************************************************************************************************/
		if (!bPlayerContext ||
		(!(GC.getGame().isReligionSlotTaken((ReligionTypes)iReligionType))
		&& GET_PLAYER(GC.getGame().getActivePlayer()).canFoundReligion()) )
/************************************************************************************************/
/* LIMITED_RELIGIONS			   END														  */
/************************************************************************************************/
		{
			if (bList && bFirst)
			{
				szBuffer.append(NEWLINE);
			}

			if (GC.getGame().isOption(GAMEOPTION_PICK_RELIGION))
			{
				szTempBuffer = gDLL->getText("TXT_KEY_RELIGION_UNKNOWN");
			}
			else
			{
				szTempBuffer.Format( SETCOLR L"<link=%s>%s</link>" ENDCOLR , TEXT_COLOR("COLOR_HIGHLIGHT_TEXT"), CvWString(GC.getReligionInfo((ReligionTypes) iReligionType).getType()).GetCString(), GC.getReligionInfo((ReligionTypes) iReligionType).getDescription());
			}
			setListHelp(szBuffer, gDLL->getText("TXT_KEY_MISC_FIRST_DISCOVER_FOUNDS").c_str(), szTempBuffer, L", ", bFirst);
			bFirst = false;
		}
	}
	return bFirst;
}

bool CvGameTextMgr::buildFoundCorporationString(CvWStringBuffer &szBuffer, TechTypes eTech, int iCorporationType, bool bFirst, bool bList, bool bPlayerContext)
{
	CvWString szTempBuffer;

	if (GC.getCorporationInfo((CorporationTypes) iCorporationType).getTechPrereq() == eTech)
	{
		if (!bPlayerContext || (GC.getGame().countKnownTechNumTeams(eTech) == 0))
		{
			if (bList && bFirst)
			{
				szBuffer.append(NEWLINE);
			}
			szTempBuffer.Format( SETCOLR L"<link=%s>%s</link>" ENDCOLR , TEXT_COLOR("COLOR_HIGHLIGHT_TEXT"), CvWString(GC.getCorporationInfo((CorporationTypes) iCorporationType).getType()).GetCString(), GC.getCorporationInfo((CorporationTypes) iCorporationType).getDescription());
			setListHelp(szBuffer, gDLL->getText("TXT_KEY_MISC_FIRST_DISCOVER_INCORPORATES").c_str(), szTempBuffer, L", ", bFirst);
			bFirst = false;
		}
	}
	return bFirst;
}

bool CvGameTextMgr::buildPromotionString(CvWStringBuffer &szBuffer, TechTypes eTech, int iPromotionType, bool bFirst, bool bList, bool bPlayerContext)
{
	CvWString szTempBuffer;

	if (GC.getPromotionInfo((PromotionTypes) iPromotionType).getTechPrereq() == eTech)
	{
		if (bList && bFirst)
		{
			szBuffer.append(NEWLINE);
		}
		szTempBuffer.Format( SETCOLR L"<link=%s>%s</link>" ENDCOLR , TEXT_COLOR("COLOR_HIGHLIGHT_TEXT"), CvWString(GC.getPromotionInfo((PromotionTypes) iPromotionType).getType()).GetCString(), GC.getPromotionInfo((PromotionTypes) iPromotionType).getDescription());
		setListHelp(szBuffer, gDLL->getText("TXT_KEY_MISC_ENABLES").c_str(), szTempBuffer, L", ", bFirst);
		bFirst = false;
	}
	return bFirst;
}

// Displays a list of derived technologies - no distinction between AND/OR prerequisites
void CvGameTextMgr::buildSingleLineTechTreeString(CvWStringBuffer &szBuffer, TechTypes eTech, bool bPlayerContext)
{
	CvWString szTempBuffer;	// Formatting

	if (NO_TECH == eTech)
	{
		// you need to specify a tech of origin for this method to do anything
		return;
	}

	bool bFirst = true;
	for (int iI = 0; iI < GC.getNumTechInfos(); ++iI)
	{
		bool bTechAlreadyAccessible = false;
		if (bPlayerContext)
		{
			bTechAlreadyAccessible = (GET_TEAM(GC.getGame().getActiveTeam()).isHasTech((TechTypes)iI) || GET_PLAYER(GC.getGame().getActivePlayer()).canResearch((TechTypes)iI));
		}
		if (!bTechAlreadyAccessible)
		{
			bool bTechFound = false;

			if (!bTechFound)
			{
				for (int iJ = 0; iJ < GC.getNUM_OR_TECH_PREREQS(); iJ++)
				{
					if (GC.getTechInfo((TechTypes) iI).getPrereqOrTechs(iJ) == eTech)
					{
						bTechFound = true;
						break;
					}
				}
			}

			if (!bTechFound)
			{
				for (int iJ = 0; iJ < GC.getNUM_AND_TECH_PREREQS(); iJ++)
				{
					if (GC.getTechInfo((TechTypes) iI).getPrereqAndTechs(iJ) == eTech)
					{
						bTechFound = true;
						break;
					}
				}
			}

			if (bTechFound)
			{
				szTempBuffer.Format( SETCOLR L"<link=%s>%s</link>" ENDCOLR , TEXT_COLOR("COLOR_TECH_TEXT"), CvWString(GC.getTechInfo((TechTypes)iI).getType()).GetCString(), GC.getTechInfo((TechTypes) iI).getDescription());
				setListHelp(szBuffer, gDLL->getText("TXT_KEY_MISC_LEADS_TO").c_str(), szTempBuffer, L", ", bFirst);
				bFirst = false;
			}
		}
	}
}

// Information about other prerequisite technologies to eTech besides eFromTech
void CvGameTextMgr::buildTechTreeString(CvWStringBuffer &szBuffer, TechTypes eTech, bool bPlayerContext, TechTypes eFromTech)
{
	CvWString szTempBuffer;	// Formatting

	if (NO_TECH == eTech || NO_TECH == eFromTech)
	{
		return;
	}

	szTempBuffer.Format(SETCOLR L"%s" ENDCOLR, TEXT_COLOR("COLOR_TECH_TEXT"), GC.getTechInfo(eTech).getDescription());
	szBuffer.append(szTempBuffer);

	// Loop through OR prerequisites to make list
	CvWString szOtherOrTechs;
	int nOtherOrTechs = 0;
	bool bOrTechFound = false;
	for (int iJ = 0; iJ < GC.getNUM_OR_TECH_PREREQS(); iJ++)
	{
		TechTypes eTestTech = (TechTypes)GC.getTechInfo(eTech).getPrereqOrTechs(iJ);
		if (eTestTech >= 0)
		{
			bool bTechAlreadyResearched = false;
			if (bPlayerContext)
			{
				bTechAlreadyResearched = GET_TEAM(GC.getGame().getActiveTeam()).isHasTech(eTestTech);
			}
			if (!bTechAlreadyResearched)
			{
				if (eTestTech == eFromTech)
				{
					bOrTechFound = true;
				}
				else
				{
					szTempBuffer.Format( SETCOLR L"%s" ENDCOLR , TEXT_COLOR("COLOR_TECH_TEXT"), GC.getTechInfo(eTestTech).getDescription());
					setListHelp(szOtherOrTechs, L"", szTempBuffer, gDLL->getText("TXT_KEY_OR").c_str(), 0 == nOtherOrTechs);
					nOtherOrTechs++;
				}
			}
		}
	}

	// Loop through AND prerequisites to make list
	CvWString szOtherAndTechs;
	int nOtherAndTechs = 0;
	bool bAndTechFound = false;
	for (int iJ = 0; iJ < GC.getNUM_AND_TECH_PREREQS(); iJ++)
	{
		TechTypes eTestTech = (TechTypes)GC.getTechInfo(eTech).getPrereqAndTechs(iJ);
		if (eTestTech >= 0)
		{
			bool bTechAlreadyResearched = false;
			if (bPlayerContext)
			{
				bTechAlreadyResearched = GET_TEAM(GC.getGame().getActiveTeam()).isHasTech(eTestTech);
			}
			if (!bTechAlreadyResearched)
			{
				if (eTestTech == eFromTech)
				{
					bAndTechFound = true;
				}
				else
				{
					szTempBuffer.Format( SETCOLR L"%s" ENDCOLR , TEXT_COLOR("COLOR_TECH_TEXT"), GC.getTechInfo(eTestTech).getDescription());
					setListHelp(szOtherAndTechs, L"", szTempBuffer, L", ", 0 == nOtherAndTechs);
					nOtherAndTechs++;
				}
			}
		}
	}

	if (bOrTechFound || bAndTechFound)
	{
		if (nOtherAndTechs > 0 || nOtherOrTechs > 0)
		{
			szBuffer.append(L' ');

			if (nOtherAndTechs > 0)
			{
				szBuffer.append(gDLL->getText("TXT_KEY_WITH_SPACE"));
				szBuffer.append(szOtherAndTechs);
			}

			if (nOtherOrTechs > 0)
			{
				if (bAndTechFound)
				{
					if (nOtherAndTechs > 0)
					{
						szBuffer.append(gDLL->getText("TXT_KEY_AND_SPACE"));
					}
					else
					{
						szBuffer.append(gDLL->getText("TXT_KEY_WITH_SPACE"));
					}
					szBuffer.append(szOtherOrTechs);
				}
				else if (bOrTechFound)
				{
					szBuffer.append(NEWLINE);
					szBuffer.append(gDLL->getText("TXT_KEY_MISC_ALTERNATIVELY_DERIVED", GC.getTechInfo(eTech).getTextKeyWide(), szOtherOrTechs.GetCString()));
				}
			}
		}
	}
}

void CvGameTextMgr::setPromotionHelp(CvWStringBuffer &szBuffer, PromotionTypes ePromotion, bool bCivilopediaBodyText)
{
	CvUnit*	pUnit = gDLL->getInterfaceIFace()->getHeadSelectedUnit();


	//	Hide overridden promotions if there is a selected unit and this is not a pedia request
	if ( GC.getIsInPedia() || pUnit == NULL || !pUnit->isPromotionOverriden(ePromotion) )
	{
		if (!bCivilopediaBodyText)
		{
			CvWString szTempBuffer;

			if (NO_PROMOTION == ePromotion)
			{
				return;
			}
			const CvPromotionInfo& promo = GC.getPromotionInfo(ePromotion);

			szTempBuffer.Format( SETCOLR L"%s" ENDCOLR , TEXT_COLOR("COLOR_HIGHLIGHT_TEXT"), promo.getDescription());
			szBuffer.append(szTempBuffer);
		}

		parsePromotionHelpInternal(szBuffer, ePromotion, NEWLINE, !GC.getIsInPedia());
	}
}

void CvGameTextMgr::setBuildUpHelp(CvWStringBuffer &szBuffer, PromotionLineTypes ePromotionLine)
{
	CivilizationTypes eCivilization;

	if (GC.getGame().getActivePlayer() != NO_PLAYER)
	{
		eCivilization = GET_PLAYER(GC.getGame().getActivePlayer()).getCivilizationType();
	}
	else
	{
		eCivilization = NO_CIVILIZATION;
	}

	if (NO_PROMOTIONLINE == ePromotionLine)
	{
		return;
	}
	parseBuildUp(szBuffer, ePromotionLine, eCivilization);
}

void CvGameTextMgr::setTraitHelp(CvWStringBuffer &szBuffer, TraitTypes eTrait)
{
	CivilizationTypes eCivilization;

	if (GC.getGame().getActivePlayer() != NO_PLAYER)
	{
		eCivilization = GET_PLAYER(GC.getGame().getActivePlayer()).getCivilizationType();
	}
	else
	{
		eCivilization = NO_CIVILIZATION;
	}

	if (NO_TRAIT == eTrait)
	{
		return;
	}
	parseTraits(szBuffer, eTrait, eCivilization, false, false);
}

void CvGameTextMgr::setUnitCombatHelp(CvWStringBuffer &szBuffer, UnitCombatTypes eUnitCombat, bool bCivilopediaText, bool bFromUnit)
{
	int iI;
	CvWString szTempBuffer;
	const CvUnitCombatInfo& info = GC.getUnitCombatInfo(eUnitCombat);

	bool bFirstDisplay = true;

	if (info.getExcileChange() > 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_EXCILE_ADD_TEXT"));
	}
	if (info.getExcileChange() < 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_EXCILE_REMOVE_TEXT"));
	}

	if (info.getPassageChange() > 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_PASSAGE_ADD_TEXT"));
	}
	if (info.getPassageChange() < 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_PASSAGE_REMOVE_TEXT"));
	}

	if (info.getNoNonOwnedCityEntryChange() > 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_NONONOWNED_ADD_TEXT"));
	}
	if (info.getNoNonOwnedCityEntryChange() < 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_NONONOWNED_REMOVE_TEXT"));
	}

	if (info.getBarbCoExistChange() > 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_BARBCOEXIST_ADD_TEXT"));
	}
	if (info.getBarbCoExistChange() < 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_BARBCOEXIST_REMOVE_TEXT"));
	}

	if (info.getBlendIntoCityChange() > 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_BLENDCITY_ADD_TEXT"));
	}
	if (info.getBlendIntoCityChange() < 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_BLENDCITY_REMOVE_TEXT"));
	}

	// integers
	if (info.isAlwaysInvisible())
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_UNIT_INVISIBLE_ALL"));
	}
	if (info.getVisibilityChange() != 0)
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_IMPROVEMENT_VISIBILITY_RANGE", info.getVisibilityChange()));
	}

	if (GC.getGame().isOption(GAMEOPTION_HIDE_AND_SEEK))
	{
		for (iI = 0; iI < GC.getNumInvisibleInfos(); iI++)
		{
			if (info.getVisibilityIntensityChangeType((InvisibleTypes)iI) != 0)
			{
				if (bFirstDisplay)
				{
					szBuffer.append(NEWLINE);
					szBuffer.append(info.getDescription());
					bFirstDisplay = false;
				}
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_PROMOHELP_INVISIBILITY_SPOT_CHANGE", info.getVisibilityIntensityChangeType((InvisibleTypes)iI), GC.getInvisibleInfo((InvisibleTypes)iI).getChar()));
			}
		}
		for (iI = 0; iI < GC.getNumInvisibleInfos(); iI++)
		{
			if (info.getVisibilityIntensityRangeChangeType((InvisibleTypes)iI) != 0)
			{
				if (bFirstDisplay)
				{
					szBuffer.append(NEWLINE);
					szBuffer.append(info.getDescription());
					bFirstDisplay = false;
				}
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_PROMOHELP_INVISIBILITY_SPOT_RANGE_CHANGE", info.getVisibilityIntensityRangeChangeType((InvisibleTypes)iI), GC.getInvisibleInfo((InvisibleTypes)iI).getChar()));
			}
		}
		for (iI = 0; iI < GC.getNumInvisibleInfos(); iI++)
		{
			if (info.getVisibilityIntensitySameTileChangeType((InvisibleTypes)iI) != 0)
			{
				if (bFirstDisplay)
				{
					szBuffer.append(NEWLINE);
					szBuffer.append(info.getDescription());
					bFirstDisplay = false;
				}
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_PROMOHELP_INVISIBILITY_SPOT_SAME_TILE_CHANGE", info.getVisibilityIntensitySameTileChangeType((InvisibleTypes)iI), GC.getInvisibleInfo((InvisibleTypes)iI).getChar()));
			}
		}
		for (iI = 0; iI < GC.getNumInvisibleInfos(); iI++)
		{
			if (info.getInvisibilityIntensityChangeType((InvisibleTypes)iI) != 0)
			{
				if (bFirstDisplay)
				{
					szBuffer.append(NEWLINE);
					szBuffer.append(info.getDescription());
					bFirstDisplay = false;
				}
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_PROMOHELP_INVISIBILITY_VEIL_INTENSITY_CHANGE", info.getInvisibilityIntensityChangeType((InvisibleTypes)iI), GC.getInvisibleInfo((InvisibleTypes)iI).getChar()));
			}
		}
		int iIntensity = 0;
		for (iI = 0; iI < info.getNumInvisibleTerrainChanges(); iI++)
		{
			InvisibleTypes eInvisible = (info.getInvisibleTerrainChange(iI).eInvisible);
			TerrainTypes eTerrain = (info.getInvisibleTerrainChange(iI).eTerrain);
			iIntensity = info.getInvisibleTerrainChange(iI).iIntensity;
			if (iIntensity != 0)
			{
				if (bFirstDisplay)
				{
					szBuffer.append(NEWLINE);
					szBuffer.append(info.getDescription());
					bFirstDisplay = false;
				}
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_PROMOHELP_INVISIBILITY_VEIL_PLOT_CHANGE", iIntensity, GC.getInvisibleInfo(eInvisible).getChar(), GC.getTerrainInfo(eTerrain).getTextKeyWide()));
			}
		}
		iIntensity = 0;
		for (iI = 0; iI < info.getNumInvisibleFeatureChanges(); iI++)
		{
			InvisibleTypes eInvisible = (info.getInvisibleFeatureChange(iI).eInvisible);
			FeatureTypes eFeature = (info.getInvisibleFeatureChange(iI).eFeature);
			iIntensity = info.getInvisibleFeatureChange(iI).iIntensity;
			if (iIntensity != 0)
			{
				if (bFirstDisplay)
				{
					szBuffer.append(NEWLINE);
					szBuffer.append(info.getDescription());
					bFirstDisplay = false;
				}
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_PROMOHELP_INVISIBILITY_VEIL_PLOT_CHANGE", iIntensity, GC.getInvisibleInfo(eInvisible).getChar(), GC.getFeatureInfo(eFeature).getTextKeyWide()));
			}
		}
		iIntensity = 0;
		for (iI = 0; iI < info.getNumInvisibleImprovementChanges(); iI++)
		{
			InvisibleTypes eInvisible = (info.getInvisibleImprovementChange(iI).eInvisible);
			ImprovementTypes eImprovement = (info.getInvisibleImprovementChange(iI).eImprovement);
			iIntensity = info.getInvisibleImprovementChange(iI).iIntensity;
			if (iIntensity != 0)
			{
				if (bFirstDisplay)
				{
					szBuffer.append(NEWLINE);
					szBuffer.append(info.getDescription());
					bFirstDisplay = false;
				}
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_PROMOHELP_INVISIBILITY_VEIL_PLOT_CHANGE", iIntensity, GC.getInvisibleInfo(eInvisible).getChar(), GC.getImprovementInfo(eImprovement).getTextKeyWide()));
			}
		}
		iIntensity = 0;
		for (iI = 0; iI < info.getNumVisibleTerrainChanges(); iI++)
		{
			InvisibleTypes eInvisible = (info.getVisibleTerrainChange(iI).eInvisible);
			TerrainTypes eTerrain = (info.getVisibleTerrainChange(iI).eTerrain);
			iIntensity = info.getVisibleTerrainChange(iI).iIntensity;
			if (iIntensity != 0)
			{
				if (bFirstDisplay)
				{
					szBuffer.append(NEWLINE);
					szBuffer.append(info.getDescription());
					bFirstDisplay = false;
				}
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_PROMOHELP_INVISIBILITY_SPOT_PLOT_CHANGE", iIntensity, GC.getInvisibleInfo(eInvisible).getChar(), GC.getTerrainInfo(eTerrain).getTextKeyWide()));
			}
		}
		iIntensity = 0;
		for (iI = 0; iI < info.getNumVisibleFeatureChanges(); iI++)
		{
			InvisibleTypes eInvisible = (info.getVisibleFeatureChange(iI).eInvisible);
			FeatureTypes eFeature = (info.getVisibleFeatureChange(iI).eFeature);
			iIntensity = info.getVisibleFeatureChange(iI).iIntensity;
			if (iIntensity != 0)
			{
				if (bFirstDisplay)
				{
					szBuffer.append(NEWLINE);
					szBuffer.append(info.getDescription());
					bFirstDisplay = false;
				}
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_PROMOHELP_INVISIBILITY_SPOT_PLOT_CHANGE", iIntensity, GC.getInvisibleInfo(eInvisible).getChar(), GC.getFeatureInfo(eFeature).getTextKeyWide()));
			}
		}
		iIntensity = 0;
		for (iI = 0; iI < info.getNumVisibleImprovementChanges(); iI++)
		{
			InvisibleTypes eInvisible = (info.getVisibleImprovementChange(iI).eInvisible);
			ImprovementTypes eImprovement = (info.getVisibleImprovementChange(iI).eImprovement);
			iIntensity = info.getVisibleImprovementChange(iI).iIntensity;
			if (iIntensity != 0)
			{
				if (bFirstDisplay)
				{
					szBuffer.append(NEWLINE);
					szBuffer.append(info.getDescription());
					bFirstDisplay = false;
				}
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_PROMOHELP_INVISIBILITY_SPOT_PLOT_CHANGE", iIntensity, GC.getInvisibleInfo(eInvisible).getChar(), GC.getImprovementInfo(eImprovement).getTextKeyWide()));
			}
		}
		iIntensity = 0;
		for (iI = 0; iI < info.getNumVisibleTerrainRangeChanges(); iI++)
		{
			InvisibleTypes eInvisible = (info.getVisibleTerrainRangeChange(iI).eInvisible);
			TerrainTypes eTerrain = (info.getVisibleTerrainRangeChange(iI).eTerrain);
			iIntensity = info.getVisibleTerrainRangeChange(iI).iIntensity;
			if (iIntensity != 0)
			{
				if (bFirstDisplay)
				{
					szBuffer.append(NEWLINE);
					szBuffer.append(info.getDescription());
					bFirstDisplay = false;
				}
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_PROMOHELP_INVISIBILITY_SPOT_PLOT_RANGE_CHANGE", iIntensity, GC.getInvisibleInfo(eInvisible).getChar(), GC.getTerrainInfo(eTerrain).getTextKeyWide()));
			}
		}
		iIntensity = 0;
		for (iI = 0; iI < info.getNumVisibleFeatureRangeChanges(); iI++)
		{
			InvisibleTypes eInvisible = (info.getVisibleFeatureRangeChange(iI).eInvisible);
			FeatureTypes eFeature = (info.getVisibleFeatureRangeChange(iI).eFeature);
			iIntensity = info.getVisibleFeatureRangeChange(iI).iIntensity;
			if (iIntensity != 0)
			{
				if (bFirstDisplay)
				{
					szBuffer.append(NEWLINE);
					szBuffer.append(info.getDescription());
					bFirstDisplay = false;
				}
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_PROMOHELP_INVISIBILITY_SPOT_PLOT_RANGE_CHANGE", iIntensity, GC.getInvisibleInfo(eInvisible).getChar(), GC.getFeatureInfo(eFeature).getTextKeyWide()));
			}
		}
		iIntensity = 0;
		for (iI = 0; iI < info.getNumVisibleImprovementRangeChanges(); iI++)
		{
			InvisibleTypes eInvisible = (info.getVisibleImprovementRangeChange(iI).eInvisible);
			ImprovementTypes eImprovement = (info.getVisibleImprovementRangeChange(iI).eImprovement);
			iIntensity = info.getVisibleImprovementRangeChange(iI).iIntensity;
			if (iIntensity != 0)
			{
				if (bFirstDisplay)
				{
					szBuffer.append(NEWLINE);
					szBuffer.append(info.getDescription());
					bFirstDisplay = false;
				}
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_PROMOHELP_INVISIBILITY_SPOT_PLOT_RANGE_CHANGE", iIntensity, GC.getInvisibleInfo(eInvisible).getChar(), GC.getImprovementInfo(eImprovement).getTextKeyWide()));
			}
		}
	}


	if (GC.getGame().isOption(GAMEOPTION_OUTBREAKS_AND_AFFLICTIONS))
	{
		for (iI = 0; iI < GC.getNumPropertyInfos(); iI++)
		{
			if (info.getAidChange(iI) != 0)
			{
				if (bFirstDisplay)
				{
					szBuffer.append(NEWLINE);
					szBuffer.append(info.getDescription());
					bFirstDisplay = false;
				}
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_AID_CHANGE_TEXT", info.getAidChange(iI), GC.getPropertyInfo((PropertyTypes)iI).getTextKeyWide()));
			}
		}
	}

	if (info.getMovesChange() != 0)
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_MOVE_TEXT", info.getMovesChange()));
	}

	if (info.getMoveDiscountChange() != 0)
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_MOVE_DISCOUNT_TEXT", info.getMoveDiscountChange()));
	}

	if (info.getAirRangeChange() != 0)
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_AIR_RANGE_TEXT", info.getAirRangeChange()));
	}

	if (info.getInterceptChange() != 0)
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		if(info.isSpy())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_INTERCEPT_TEXT_SPY", info.getInterceptChange()));
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_INTERCEPT_TEXT_SPY_COUNTER", info.getInterceptChange() * 5));
		}
		else
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_INTERCEPT_TEXT", info.getInterceptChange()));
		}
	}

	if (info.getEvasionChange() != 0)
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		if(info.isSpy())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_EVASION_TEXT_SPY", info.getEvasionChange()));
		}
		else
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_EVASION_TEXT", info.getEvasionChange()));
		}
	}

	if (info.getWithdrawalChange() != 0)
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		if(info.isSpy())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_ESCAPE_TEXT_SPY", info.getWithdrawalChange()));
		}
		else
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_WITHDRAWAL_TEXT", info.getWithdrawalChange()));
		}
	}

	if (info.getCargoChange() != 0)
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_CARGO_TEXT", info.getCargoChange()));
	}

	if (info.getSMCargoChange() != 0)
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_SM_CARGO_TEXT", info.getSMCargoChange()));
	}

	if (info.getCollateralDamageChange() != 0)
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_COLLATERAL_DAMAGE_TEXT", info.getCollateralDamageChange()));
	}


	//Bombard
	if(GC.isDCM_RANGE_BOMBARD())
	{
		if (info.getDCMBombRangeBase() != 0)
		{
			if (bFirstDisplay)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(info.getDescription());
				bFirstDisplay = false;
			}
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_DCM_BOMB_RANGE_TEXT", info.getDCMBombRangeBase()));
		}
		if (info.getDCMBombAccuracyBase() != 0)
		{
			if (bFirstDisplay)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(info.getDescription());
				bFirstDisplay = false;
			}
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_DCM_BOMB_ACCURACY_TEXT", info.getDCMBombAccuracyBase()));
		}
		if (info.getRBombardDamageBase() != 0)
		{
			if (bFirstDisplay)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(info.getDescription());
				bFirstDisplay = false;
			}
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_DCM_BOMB_DAMAGE_TEXT", info.getRBombardDamageBase()));
		}
		if (info.getRBombardDamageLimitBase() != 0)
		{
			if (bFirstDisplay)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(info.getDescription());
				bFirstDisplay = false;
			}
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_DCM_BOMB_DAMAGE_LIMIT_TEXT", info.getRBombardDamageLimitBase()));
		}
		if (info.getRBombardDamageMaxUnitsBase() != 0)
		{
			if (bFirstDisplay)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(info.getDescription());
				bFirstDisplay = false;
			}
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_DCM_BOMB_DAMAGE_MAX_UNITS_TEXT", info.getRBombardDamageMaxUnitsBase()));
		}
		if (info.isRBombardDirect() != 0)
		{
			if (bFirstDisplay)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(info.getDescription());
				bFirstDisplay = false;
			}
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_RANGED_BOMBARD_DIRECT_TEXT"));
		}
	}

	if (info.getBombardRateChange() != 0)
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_BOMBARD_TEXT", info.getBombardRateChange()));
	}

	if (info.getFirstStrikesChange() != 0)
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_FIRST_STRIKE_TEXT", info.getFirstStrikesChange()));
	}

	if (info.getChanceFirstStrikesChange() != 0)
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_FIRST_STRIKE_CHANCE_TEXT", info.getChanceFirstStrikesChange()));
	}

	if (info.isNoSelfHeal())
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_SELF_HEAL_NONE"));
	}
	else if (info.getSelfHealModifier() != 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_SELF_HEAL", info.getSelfHealModifier()));
	}

	if (info.getEnemyHealChange() != 0)
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		if(info.isSpy())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_INSTIGATE_TEXT_SPY", info.getEnemyHealChange()));
		}
		else
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_HEALS_EXTRA_TEXT", info.getEnemyHealChange()) + gDLL->getText("TXT_KEY_PROMOTION_ENEMY_LANDS_TEXT"));
		}
	}

	if (info.getNeutralHealChange() != 0)
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		if(info.isSpy())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_INSTIGATE2_TEXT_SPY", info.getNeutralHealChange()));
		}
		else
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_HEALS_EXTRA_TEXT", info.getNeutralHealChange()) + gDLL->getText("TXT_KEY_PROMOTION_NEUTRAL_LANDS_TEXT"));
		}
	}

	if (info.getFriendlyHealChange() != 0)
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		if(info.isSpy())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_POISON_TEXT_SPY", info.getFriendlyHealChange()));
		}
		else
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_HEALS_EXTRA_TEXT", info.getFriendlyHealChange()) + gDLL->getText("TXT_KEY_PROMOTION_FRIENDLY_LANDS_TEXT"));
		}
	}

	if (info.getNumHealSupport() != 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_HEAL_SUPPORT_TEXT", info.getNumHealSupport()));
	}

	if (info.getSameTileHealChange() != 0)
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_HEALS_SAME_TEXT", info.getSameTileHealChange()) + gDLL->getText("TXT_KEY_PROMOTION_DAMAGE_TURN_TEXT"));
	}

	if (info.getAdjacentTileHealChange() != 0)
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_HEALS_ADJACENT_TEXT", info.getAdjacentTileHealChange()) + gDLL->getText("TXT_KEY_PROMOTION_DAMAGE_TURN_TEXT"));
	}

	if (info.getCombatPercent() != 0)
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_STRENGTH_TEXT", info.getCombatPercent()));
	}

	if (info.getCombatModifierPerSizeMoreChange() != 0)
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_UNIT_COMBAT_MOD_PER_SIZE_MORE", info.getCombatModifierPerSizeMoreChange()));
	}

	if (info.getCombatModifierPerSizeLessChange() != 0)
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_UNIT_COMBAT_MOD_PER_SIZE_LESS", info.getCombatModifierPerSizeLessChange()));
	}

	if (info.getCombatModifierPerVolumeMoreChange() != 0)
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_UNIT_COMBAT_MOD_PER_VOLUME_MORE", info.getCombatModifierPerVolumeMoreChange()));
	}

	if (info.getCombatModifierPerVolumeLessChange() != 0)
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_UNIT_COMBAT_MOD_PER_VOLUME_LESS", info.getCombatModifierPerVolumeLessChange()));
	}

	if (info.getCityAttackPercent() != 0)
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_CITY_ATTACK_TEXT", info.getCityAttackPercent()));
	}

	if (info.getCityDefensePercent() != 0)
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_CITY_DEFENSE_TEXT", info.getCityDefensePercent()));
	}

	if (info.getHillsAttackPercent() != 0)
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_UNIT_HILLS_ATTACK", info.getHillsAttackPercent()));
	}

	if (info.getHillsDefensePercent() != 0)
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_HILLS_DEFENSE_TEXT", info.getHillsDefensePercent()));
	}

	if (info.getHillsWorkPercent() != 0)
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_HILLS_WORK_TEXT", info.getHillsWorkPercent()));
	}

	if (info.getWorkRatePercent() != 0)
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_WORK_RATE_TEXT", info.getWorkRatePercent()));
	}

	if (info.getRevoltProtection() != 0)
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_TEMP_REVOLT_PROTECTION", info.getRevoltProtection()));
	}

	if (info.getCollateralDamageProtection() != 0)
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_COLLATERAL_PROTECTION_TEXT", info.getCollateralDamageProtection()));
	}

	if (info.getPillageChange() != 0)
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_PILLAGE_CHANGE_TEXT", info.getPillageChange()));
	}

	if (info.getUpgradeDiscount() != 0)
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		if(info.isSpy())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_UPGRADE_DISCOUNT_TEXT_SPY", info.getUpgradeDiscount()));
		}
		else if (100 == info.getUpgradeDiscount())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_UPGRADE_DISCOUNT_FREE_TEXT"));
		}
		else
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_UPGRADE_DISCOUNT_TEXT", info.getUpgradeDiscount()));
		}
	}

	if (info.getExperiencePercent() != 0)
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_FASTER_EXPERIENCE_TEXT", info.getExperiencePercent()));
	}

	if (info.getKamikazePercent() != 0)
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_COMBAT_KAMIKAZE_MOD", -info.getKamikazePercent()));
	}

	if (info.getAirCombatLimitChange() != 0)
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_AIR_LIMIT_CHANGE_TEXT", info.getAirCombatLimitChange()));
	}

	if (info.getCelebrityHappy() != 0)
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_CELEBRITY_TEXT", info.getCelebrityHappy()));
	}

	if (info.getCollateralDamageLimitChange() != 0)
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_COLLATERAL_LIMIT_CHANGE_TEXT", info.getCollateralDamageLimitChange()));
	}

	if (info.getCollateralDamageMaxUnitsChange() != 0)
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_MAX_UNITS_CHANGE_TEXT", info.getCollateralDamageMaxUnitsChange()));
	}

	if (info.getCombatLimitChange() != 0)
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_COMBAT_LIMIT_TEXT", info.getCombatLimitChange()));
	}

	if (info.getExtraDropRange() != 0)
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_EXTRA_DROP_RANGE_TEXT", info.getExtraDropRange()));
	}

	if (info.getSurvivorChance() != 0)
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_SURVIVOR_TEXT", info.getSurvivorChance()));
	}

	if (info.getVictoryAdjacentHeal())
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_UNIT_VICTORY_ADJACENT_TEXT", info.getVictoryHeal(), info.getVictoryStackHeal(), info.getVictoryAdjacentHeal()));
	}

	if ((info.getVictoryHeal() != 0) && (info.getVictoryStackHeal() == 0))
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_VICTORY_HEAL_TEXT", info.getVictoryHeal()));
	}

	if (info.getVictoryStackHeal() != 0 && info.getVictoryAdjacentHeal() == 0)
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_UNIT_VICTORY_STACK_TEXT", info.getVictoryHeal(), info.getVictoryStackHeal()));
	}

	if (info.getAttackCombatModifierChange() != 0)
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_ATTACK_MODIFIER_TEXT", info.getAttackCombatModifierChange()));
	}

	if (info.getDefenseCombatModifierChange() != 0)
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_DEFENSE_MODIFIER_TEXT", info.getDefenseCombatModifierChange()));
	}

	if (info.getPursuitChange() != 0)
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_PURSUIT_TEXT", info.getPursuitChange()));
	}

	if (info.getEarlyWithdrawChange() != 0)
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_EARLY_WITHDRAW_TEXT", info.getEarlyWithdrawChange()));
	}

	if (info.getVSBarbsChange() != 0)
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_VSBARBS_TEXT", info.getVSBarbsChange()));
	}

	if (info.getReligiousCombatModifierChange() != 0)
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_UNIT_RELIGIOUS_COMBAT_MODIFIER_SHORT", info.getReligiousCombatModifierChange()));
	}

	if (info.getArmorChange() != 0)
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_ARMOR_TEXT", info.getArmorChange()));
	}

	if (info.getPunctureChange() != 0)
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_PUNCTURE_TEXT", info.getPunctureChange()));
	}

	if (info.getDamageModifierChange() != 0)
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_DAMAGE_MODIFIER_TEXT", info.getDamageModifierChange()));
	}

	if (info.getUpkeepModifier() != 0)
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_HELPTEXT_UNIT_UPKEEP_MODIFIER_BASE", info.getUpkeepModifier()));
	}

	if (info.getExtraUpkeep100() != 0)
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_HELPTEXT_UNIT_UPKEEP_EXTRA", CvWString::format(L"%.2f", info.getExtraUpkeep100() / 100.0).GetCString()));
	}

	if (info.getOverrunChange() != 0)
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_OVERRUN_TEXT", info.getOverrunChange()));
	}

	if (info.getRepelChange() != 0)
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_REPEL_TEXT", info.getRepelChange()));
	}

	if (info.getFortRepelChange() != 0)
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_FORT_REPEL_TEXT", info.getFortRepelChange()));
	}

	if (info.getRepelRetriesChange() != 0)
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_REPEL_RETRIES_TEXT", info.getRepelRetriesChange()));
	}

	if (info.getUnyieldingChange() != 0)
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_UNYIELDING_TEXT", info.getUnyieldingChange()));
	}

	if (info.getKnockbackChange() != 0)
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_KNOCKBACK_TEXT", info.getKnockbackChange()));
	}

	if (info.getKnockbackRetriesChange() != 0)
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_KNOCKBACK_RETRIES_TEXT", info.getKnockbackRetriesChange()));
	}

	if (info.getStrAdjperAttChange() > 0)
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_RAMPAGE_TEXT", info.getStrAdjperAttChange()));
	}

	if (info.getStrAdjperAttChange() < 0)
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_TIRES_TEXT", info.getStrAdjperAttChange()));
	}

	if (info.getStrAdjperDefChange() > 0)
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_DETERMINATION_TEXT", info.getStrAdjperDefChange()));
	}

	if (info.getStrAdjperDefChange() < 0)
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_DEMORALIZATION_TEXT", info.getStrAdjperDefChange()));
	}

	if (info.getWithdrawAdjperAttChange() > 0)
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_REFLEXES_TEXT", info.getWithdrawAdjperAttChange()));
	}

	if (info.getWithdrawAdjperAttChange() < 0)
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_FRAYS_TEXT", info.getWithdrawAdjperAttChange()));
	}

	if (info.getUnnerveChange() != 0)
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_UNNERVE_TEXT", info.getUnnerveChange()));
	}

	if (info.getEncloseChange() != 0)
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_ENCLOSE_TEXT", info.getEncloseChange()));
	}

	if (info.getLungeChange() != 0)
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_LUNGE_TEXT", info.getLungeChange()));
	}

	if (info.getDynamicDefenseChange() != 0)
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_DYNAMIC_DEFENSE_TEXT", info.getDynamicDefenseChange()));
	}

	int iStrengthChange = info.getStrengthChange();

	if (iStrengthChange > 0)
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_STRENGTHEN_TEXT", iStrengthChange));
	}

	if (iStrengthChange < 0)
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_WEAKEN_TEXT", iStrengthChange));
	}

	if (info.getFortitudeChange() != 0)
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_FORTITUDE_CHANGE_TEXT", info.getFortitudeChange()));
	}

	if (GC.getGame().isOption(GAMEOPTION_STRENGTH_IN_NUMBERS))
	{
		if (info.getFrontSupportPercentChange() != 0)
		{
			if (bFirstDisplay)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(info.getDescription());
				bFirstDisplay = false;
			}
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_FRONT_SUPPORT_PERCENT_CHANGE_TEXT", info.getFrontSupportPercentChange()));
		}

		if (info.getShortRangeSupportPercentChange() != 0)
		{
			if (bFirstDisplay)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(info.getDescription());
				bFirstDisplay = false;
			}
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_SHORT_RANGE_SUPPORT_PERCENT_CHANGE_TEXT", info.getShortRangeSupportPercentChange()));
		}

		if (info.getMediumRangeSupportPercentChange() != 0)
		{
			if (bFirstDisplay)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(info.getDescription());
				bFirstDisplay = false;
			}
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_MEDIUM_RANGE_SUPPORT_PERCENT_CHANGE_TEXT", info.getMediumRangeSupportPercentChange()));
		}

		if (info.getLongRangeSupportPercentChange() != 0)
		{
			if (bFirstDisplay)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(info.getDescription());
				bFirstDisplay = false;
			}
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_LONG_RANGE_SUPPORT_PERCENT_CHANGE_TEXT", info.getLongRangeSupportPercentChange()));
		}

		if (info.getFlankSupportPercentChange() != 0)
		{
			if (bFirstDisplay)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(info.getDescription());
				bFirstDisplay = false;
			}
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_FLANK_SUPPORT_PERCENT_CHANGE_TEXT", info.getFlankSupportPercentChange()));
		}
	}

	if (info.getDodgeModifierChange() != 0)
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_DODGE_MODIFIER_TEXT", info.getDodgeModifierChange()));
	}

	if (info.getPrecisionModifierChange() != 0)
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_PRECISION_MODIFIER_TEXT", info.getPrecisionModifierChange()));
	}

	if (info.getPowerShotsChange() != 0)
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_POWER_SHOTS_TEXT", info.getPowerShotsChange()));
	}

	if (info.getPowerShotCombatModifierChange() != 0)
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_POWER_SHOT_COMBAT_MODIFIER_TEXT", info.getPowerShotCombatModifierChange()));
	}

	if (info.getPowerShotPunctureModifierChange() != 0)
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_POWER_SHOT_PUNCTURE_MODIFIER_TEXT", info.getPowerShotPunctureModifierChange()));
	}

	if (info.getPowerShotPrecisionModifierChange() != 0)
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_POWER_SHOT_PRECISION_MODIFIER_TEXT", info.getPowerShotPrecisionModifierChange()));
	}

	if (info.getPowerShotCriticalModifierChange() != 0)
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_POWER_SHOT_CRITICAL_MODIFIER_TEXT", info.getPowerShotCriticalModifierChange()));
	}

	if (info.getCriticalModifierChange() != 0)
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_CRITICAL_MODIFIER_TEXT", info.getCriticalModifierChange()));
	}

	if (info.getEnduranceChange() != 0)
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_ENDURANCE_TEXT", info.getEnduranceChange()));
	}

	if (info.getRoundStunProbChange() != 0)
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_ROUND_STUN_PROB_TEXT", info.getRoundStunProbChange()));
	}

	if (info.getPoisonProbabilityModifierChange() != 0)
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_POISON_PROB_TEXT", info.getPoisonProbabilityModifierChange()));
	}

	if (info.getCaptureProbabilityModifierChange() != 0)
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_UNIT_CAPTURE_PROBABILITY_MODIFIER", info.getCaptureProbabilityModifierChange()));
	}

	if (info.getCaptureResistanceModifierChange() != 0)
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_UNIT_CAPTURE_RESISTANCE_MODIFIER", info.getCaptureResistanceModifierChange()));
	}

	if (info.getHillsWorkModifierChange() != 0)
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_HILLS_WORK_TEXT", info.getHillsWorkModifierChange()));
	}

	if (info.getPeaksWorkModifierChange() != 0)
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_PEAKS_WORK_TEXT", info.getPeaksWorkModifierChange()));
	}

	if (info.getBreakdownChanceChange() != 0)
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_BREAKDOWN_CHANCE", info.getBreakdownChanceChange()));
	}

	if (info.getBreakdownDamageChange() != 0)
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_BREAKDOWN_DAMAGE", info.getBreakdownDamageChange()));
	}

	if (info.getTauntChange() != 0)
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_UNIT_TAUNT", info.getTauntChange()));
	}

	if (info.getMaxHPChange() != 0)
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_MAX_HP", info.getMaxHPChange()));
	}

	if (info.getStrengthModifier() != 0)
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_STRENGTH_MODIFIER", info.getStrengthModifier()));
	}

	bool bWithoutWarning = GC.getGame().isOption(GAMEOPTION_WITHOUT_WARNING);
	if (info.getStealthStrikesChange() != 0 && bWithoutWarning)
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_STEALTH_STRIKES_TEXT", info.getStealthStrikesChange()));
	}

	if (info.getStealthCombatModifierChange() != 0 && bWithoutWarning)
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_STEALTH_COMBAT_MODIFIER_TEXT", info.getStealthCombatModifierChange()));
	}

	if (info.getStealthDefenseChange() != 0 && bWithoutWarning)
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_STEALTH_DEFENSE_CHANGE_TEXT", info.getStealthDefenseChange()));
	}

	if (info.getDefenseOnlyChange() != 0)
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_DEFENSE_ONLY_CHANGE_TEXT", info.getDefenseOnlyChange()));
	}

	if (info.getNoInvisibilityChange() != 0 && GC.getGame().isOption(GAMEOPTION_HIDE_AND_SEEK))
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_NO_INVISIBILITY_CHANGE_TEXT", info.getNoInvisibilityChange()));
	}

	if (info.getNoCaptureChange() > 0)
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_ADDS_CANNOT_CAPTURE"));
	}
	else if (info.getNoCaptureChange() < 0)
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_REMOVES_CANNOT_CAPTURE"));
	}

	for (iI = 0; iI < GC.getNumTerrainInfos(); iI++)
	{
		if (info.getWithdrawOnTerrainTypeChange((TerrainTypes)iI) != 0)
		{
			if (bFirstDisplay)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(info.getDescription());
				bFirstDisplay = false;
			}
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_WITHDRAW_ON_TEXT", info.getWithdrawOnTerrainTypeChange((TerrainTypes)iI), CvWString(GC.getTerrainInfo((TerrainTypes)iI).getType()).GetCString(), GC.getTerrainInfo((TerrainTypes)iI).getTextKeyWide()));
		}
	}

	for (iI = 0; iI < GC.getNumFeatureInfos(); iI++)
	{
		if (info.getWithdrawOnFeatureTypeChange((FeatureTypes)iI) != 0)
		{
			if (bFirstDisplay)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(info.getDescription());
				bFirstDisplay = false;
			}
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_WITHDRAW_ON_TEXT", info.getWithdrawOnFeatureTypeChange((FeatureTypes)iI), CvWString(GC.getFeatureInfo((FeatureTypes)iI).getType()).GetCString(), GC.getFeatureInfo((FeatureTypes)iI).getTextKeyWide()));
		}
	}

	//booleans
	if (info.isDefensiveVictoryMove())
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_DV_MOVE_TEXT"));
	}

	if (info.isFreeDrop())
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_FREE_DROP_TEXT"));

		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_DROP_SIGHT_UNSEEN_TEXT"));
	}

	if (info.isOffensiveVictoryMove())
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_OV_MOVE_TEXT"));
	}

	if (info.isOneUp())
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_UNIT_ONEUP_TEXT"));
	}

	if (info.isPillageCulture())
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_CULTURE_PILLAGE_TEXT"));
	}

	if (info.isPillageEspionage())
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_ESPIONAGE_PILLAGE_TEXT"));
	}

	if (info.isPillageMarauder())
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_MARAUDER_PILLAGE_TEXT"));
	}

	if (info.isPillageOnMove())
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_MOVING_PILLAGE_TEXT"));
	}

	if (info.isPillageOnVictory())
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_VICTORY_PILLAGE_TEXT"));
	}

	if (info.isPillageResearch())
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_RESEARCH_PILLAGE_TEXT"));
	}

	if (info.isBlitz())
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_BLITZ_TEXT"));
	}

	if (info.isAmphib())
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		if(info.isSpy())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_RADIATION_TEXT_SPY"));
		}
		else
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_AMPHIB_TEXT"));
		}
	}

	if (info.isRiver())
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_RIVER_ATTACK_TEXT"));
	}

	if (info.isEnemyRoute())
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_ENEMY_ROADS_TEXT"));
	}

	if (info.isAlwaysHeal())
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		if(info.isSpy())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_LOYALTY_TEXT_SPY"));
		}
		else
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_ALWAYS_HEAL_TEXT"));
		}
	}

	if (info.isHillsDoubleMove())
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_HILLS_MOVE_TEXT"));
	}

	if (info.isImmuneToFirstStrikes())
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_IMMUNE_FIRST_STRIKES_TEXT"));
	}

	if (info.isStampedeChange())
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_STAMPEDE_TEXT"));
	}

	if (info.isRemoveStampede())
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_REMOVE_STAMPEDE_TEXT"));
	}

	if (info.getAnimalIgnoresBordersChange() != 0 && !GC.getGame().isOption(GAMEOPTION_ANIMALS_STAY_OUT))
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_ANIMAL_IGNORES_BORDERS_TEXT", info.getAnimalIgnoresBordersChange()));
	}

	int iNoDefensiveBonusChange = info.getNoDefensiveBonusChange();
	if (iNoDefensiveBonusChange != 0)
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		szBuffer.append(NEWLINE);
		if (iNoDefensiveBonusChange > 0)
		{
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_NO_DEFENSIVE_BONUS_CHANGE_POSITIVE_TEXT", iNoDefensiveBonusChange));
		}
		else if (iNoDefensiveBonusChange < 0)
		{
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_NO_DEFENSIVE_BONUS_CHANGE_NEGATIVE_TEXT", iNoDefensiveBonusChange));
		}
	}

	if (info.isOnslaughtChange())
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_ONSLAUGHT_TEXT"));
	}

	if (info.isMakesDamageCold())
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_MAKES_DAMAGE_COLD_TEXT"));
	}

	if (info.isMakesDamageNotCold())
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_MAKES_DAMAGE_NOT_COLD_TEXT"));
	}

	if (info.isAddsColdImmunity())
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_ADDS_COLD_IMMUNITY_TEXT"));
	}

	if (info.isRemovesColdImmunity())
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_REMOVES_COLD_IMMUNITY_TEXT"));
	}

	if (info.isAttackOnlyCitiesAdd())
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_ATTACK_ONLY_CITIES_ADD"));
	}

	if (info.isAttackOnlyCitiesSubtract())
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_ATTACK_ONLY_CITIES_SUBTRACT"));
	}

	if (info.isIgnoreNoEntryLevelAdd())
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_IGNORE_NO_ENTRY_LEVEL_ADD"));
	}

	if (info.isIgnoreNoEntryLevelSubtract())
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_IGNORE_NO_ENTRY_LEVEL_SUBTRACT"));
	}

	if (GC.getGame().isOption(GAMEOPTION_ZONE_OF_CONTROL))
	{
		if (info.isIgnoreZoneofControlAdd())
		{
			if (bFirstDisplay)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(info.getDescription());
				bFirstDisplay = false;
			}
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_IGNORE_ZONE_OF_CONTROL_ADD"));
		}
		if (info.isIgnoreZoneofControlSubtract())
		{
			if (bFirstDisplay)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(info.getDescription());
				bFirstDisplay = false;
			}
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_IGNORE_ZONE_OF_CONTROL_SUBTRACT"));
		}
	}

	if (info.isFliesToMoveAdd())
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_FLIES_TO_MOVE_ADD"));
	}

	if (info.isFliesToMoveSubtract())
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_FLIES_TO_MOVE_SUBTRACT"));
	}

	if (info.isCannotMergeSplit() && GC.getGame().isOption(GAMEOPTION_SIZE_MATTERS))
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_CANNOT_MERGE_SPLIT"));
	}

	if (info.isCanMovePeaks())
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_CAN_MOVE_PEAKS_TEXT"));
	}

	if (info.isCanLeadThroughPeaks())
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_CAN_LEAD_THROUGH_PEAKS_TEXT"));
	}

	if (GC.getGame().isOption(GAMEOPTION_ZONE_OF_CONTROL) && info.isZoneOfControl())
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_ZONE_OF_CONTROL"));
	}

	// Arrays
	if (info.isAnyDomainModifierPercent())
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		for (iI = 0; iI < NUM_DOMAIN_TYPES; ++iI)
		{
			if (info.getDomainModifierPercent(iI) != 0)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_VERSUS_TEXT", info.getDomainModifierPercent(iI), CvWString(GC.getDomainInfo((DomainTypes)iI).getType()), GC.getDomainInfo((DomainTypes)iI).getTextKeyWide()));
			}
		}
	}

	// bool vector with delayed resolution

	if (GC.getGame().isOption(GAMEOPTION_OUTBREAKS_AND_AFFLICTIONS))
	{
		for (iI = 0; iI < info.getNumCureAfflictionChangeTypes(); ++iI)
		{
			if (info.isCureAfflictionChangeType(iI))
			{
				if (bFirstDisplay)
				{
					szBuffer.append(NEWLINE);
					szBuffer.append(info.getDescription());
					bFirstDisplay = false;
				}
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_CURE_AFFLICTION_TEXT", GC.getPromotionLineInfo((PromotionLineTypes)info.getCureAfflictionChangeType(iI)).getTextKeyWide()));
			}
		}
	}

	for (iI = 0; iI < info.getNumTerrainIgnoreDamageChangeTypes(); ++iI)
	{
		if (info.isTerrainIgnoreDamageChangeType(iI))
		{
			if (bFirstDisplay)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(info.getDescription());
				bFirstDisplay = false;
			}
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_IGNORE_TERRAIN_DAMAGE", GC.getTerrainInfo((TerrainTypes)info.getTerrainIgnoreDamageChangeType(iI)).getTextKeyWide()));
		}
	}

	for (iI = 0; iI < info.getNumTerrainDoubleMoveChangeTypes(); ++iI)
	{
		if (info.isTerrainDoubleMoveChangeType(iI))
		{
			if (bFirstDisplay)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(info.getDescription());
				bFirstDisplay = false;
			}
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_DOUBLE_MOVE_TEXT", GC.getTerrainInfo((TerrainTypes)info.getTerrainDoubleMoveChangeType(iI)).getTextKeyWide()));
		}
	}

	for (iI = 0; iI < info.getNumFeatureDoubleMoveChangeTypes(); ++iI)
	{
		if (info.isFeatureDoubleMoveChangeType(iI))
		{
			if (bFirstDisplay)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(info.getDescription());
				bFirstDisplay = false;
			}
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_DOUBLE_MOVE_TEXT", GC.getFeatureInfo((FeatureTypes)info.getFeatureDoubleMoveChangeType(iI)).getTextKeyWide()));
		}
	}

	// int vector utilizing struct with delayed resolution
	if (GC.getGame().isOption(GAMEOPTION_OUTBREAKS_AND_AFFLICTIONS))
	{
		if (info.getNumAfflictionFortitudeChangeModifiers() > 0 )
		{
			if (bFirstDisplay)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(info.getDescription());
				bFirstDisplay = false;
			}
			for (iI = 0; iI < info.getNumAfflictionFortitudeChangeModifiers(); ++iI)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_AFFLICTION_FORTITUDE_CHANGE_MODIFIER_TEXT", info.getAfflictionFortitudeChangeModifier(iI).iModifier, GC.getPromotionLineInfo((PromotionLineTypes)info.getAfflictionFortitudeChangeModifier(iI).ePromotionLine).getTextKeyWide()));
			}
		}

		if (info.getNumAfflictOnAttackChangeTypes() > 0 )
		{
			if (bFirstDisplay)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(info.getDescription());
				bFirstDisplay = false;
			}
			for (iI = 0; iI < info.getNumAfflictOnAttackChangeTypes(); ++iI)
			{
				if (info.getAfflictOnAttackChangeType(iI).eAfflictionLine != NO_PROMOTIONLINE)
				{
					if (info.getAfflictOnAttackChangeType(iI).iImmediate > 0)
					{
						szBuffer.append(NEWLINE);
						szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_AFFLICT_ON_ATTACK_IMMEDIATE_TEXT", info.getAfflictOnAttackChangeType(iI).iProbabilityChange, GC.getPromotionLineInfo(info.getAfflictOnAttackChangeType(iI).eAfflictionLine).getTextKeyWide()));
					}
					else if (info.getAfflictOnAttackChangeType(iI).iImmediate < 0)
					{
						szBuffer.append(NEWLINE);
						szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_AFFLICT_ON_ATTACK_NOT_IMMEDIATE_TEXT", info.getAfflictOnAttackChangeType(iI).iProbabilityChange, GC.getPromotionLineInfo(info.getAfflictOnAttackChangeType(iI).eAfflictionLine).getTextKeyWide()));
					}
					else
					{
						szBuffer.append(NEWLINE);
						szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_AFFLICT_ON_ATTACK_TEXT", info.getAfflictOnAttackChangeType(iI).iProbabilityChange, GC.getPromotionLineInfo(info.getAfflictOnAttackChangeType(iI).eAfflictionLine).getTextKeyWide()));
					}
				}
			}
		}
	}

	//Traps
	for (iI = 0; iI < info.getNumTrapImmunityUnitCombatTypes(); ++iI)
	{
		if (info.isTrapImmunityUnitCombatType(iI))
		{
			if (bFirstDisplay)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(info.getDescription());
				bFirstDisplay = false;
			}
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_TRAP_IMMUNITY_TEXT", GC.getUnitCombatInfo((UnitCombatTypes)info.getTrapImmunityUnitCombatType(iI)).getTextKeyWide()));
		}
	}

	if (info.getNumTrapAvoidanceUnitCombatTypes() > 0 )
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		for (iI = 0; iI < info.getNumTrapAvoidanceUnitCombatTypes(); ++iI)
		{
			if (info.getTrapAvoidanceUnitCombatType(iI).eUnitCombat != NO_UNITCOMBAT)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_TRAP_AVOID_TEXT", info.getTrapAvoidanceUnitCombatType(iI).iModifier, GC.getUnitCombatInfo((UnitCombatTypes)info.getTrapAvoidanceUnitCombatType(iI).eUnitCombat).getTextKeyWide()));
			}
		}
	}

	if (info.getNumTerrainAttackChangeModifiers() > 0 )
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		for (iI = 0; iI < info.getNumTerrainAttackChangeModifiers(); ++iI)
		{
			if (info.getTerrainAttackChangeModifier(iI).eTerrain != NO_TERRAIN)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_UNIT_ATTACK", info.getTerrainAttackChangeModifier(iI).iModifier, GC.getTerrainInfo((TerrainTypes)info.getTerrainAttackChangeModifier(iI).eTerrain).getTextKeyWide()));
			}
		}
	}

	if (info.getNumTerrainDefenseChangeModifiers() > 0 )
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		for (iI = 0; iI < info.getNumTerrainDefenseChangeModifiers(); ++iI)
		{
			if (info.getTerrainDefenseChangeModifier(iI).eTerrain != NO_TERRAIN)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_UNIT_DEFENSE", info.getTerrainDefenseChangeModifier(iI).iModifier, GC.getTerrainInfo((TerrainTypes)info.getTerrainDefenseChangeModifier(iI).eTerrain).getTextKeyWide()));
			}
		}
	}

	if (info.getNumTerrainWorkChangeModifiers() > 0 )
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		for (iI = 0; iI < info.getNumTerrainWorkChangeModifiers(); ++iI)
		{
			if (info.getTerrainWorkChangeModifier(iI).eTerrain != NO_TERRAIN)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_WORK_TEXT", info.getTerrainWorkChangeModifier(iI).iModifier, GC.getTerrainInfo((TerrainTypes)info.getTerrainWorkChangeModifier(iI).eTerrain).getTextKeyWide()));
			}
		}
	}

	if (info.getNumBuildWorkChangeModifiers() > 0 )
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		for (iI = 0; iI < info.getNumBuildWorkChangeModifiers(); ++iI)
		{
			if (info.getBuildWorkChangeModifier(iI).eBuild != NO_BUILD)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_WORK_TEXT", info.getBuildWorkChangeModifier(iI).iModifier, GC.getBuildInfo((BuildTypes)info.getBuildWorkChangeModifier(iI).eBuild).getTextKeyWide()));
			}
		}
	}

	if (info.getNumFeatureAttackChangeModifiers() > 0 )
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		for (iI = 0; iI < info.getNumFeatureAttackChangeModifiers(); ++iI)
		{
			if (info.getFeatureAttackChangeModifier(iI).eFeature != NO_FEATURE)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_UNIT_ATTACK", info.getFeatureAttackChangeModifier(iI).iModifier, GC.getFeatureInfo((FeatureTypes)info.getFeatureAttackChangeModifier(iI).eFeature).getTextKeyWide()));
			}
		}
	}

	if (info.getNumFeatureDefenseChangeModifiers() > 0 )
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		for (iI = 0; iI < info.getNumFeatureDefenseChangeModifiers(); ++iI)
		{
			if (info.getFeatureDefenseChangeModifier(iI).eFeature != NO_FEATURE)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_UNIT_DEFENSE", info.getFeatureDefenseChangeModifier(iI).iModifier, GC.getFeatureInfo((FeatureTypes)info.getFeatureDefenseChangeModifier(iI).eFeature).getTextKeyWide()));
			}
		}
	}

	if (info.getNumFeatureWorkChangeModifiers() > 0 )
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		for (iI = 0; iI < info.getNumFeatureWorkChangeModifiers(); ++iI)
		{
			if (info.getFeatureWorkChangeModifier(iI).eFeature != NO_FEATURE)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_WORK_TEXT", info.getFeatureWorkChangeModifier(iI).iModifier, GC.getFeatureInfo((FeatureTypes)info.getFeatureWorkChangeModifier(iI).eFeature).getTextKeyWide()));
			}
		}
	}

	if (info.getNumUnitCombatChangeModifiers() > 0 )
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		for (iI = 0; iI < info.getNumUnitCombatChangeModifiers(); ++iI)
		{
			if (info.getUnitCombatChangeModifier(iI).eUnitCombat != NO_UNITCOMBAT)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_UNIT_MOD_VS_TYPE", info.getUnitCombatChangeModifier(iI).iModifier, CvWString(GC.getUnitCombatInfo((UnitCombatTypes)info.getUnitCombatChangeModifier(iI).eUnitCombat).getType()).GetCString(), GC.getUnitCombatInfo((UnitCombatTypes)info.getUnitCombatChangeModifier(iI).eUnitCombat).getTextKeyWide()));
			}
		}
	}

	if (info.getNumFlankingStrengthbyUnitCombatTypesChange() > 0 )
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		for (iI = 0; iI < info.getNumFlankingStrengthbyUnitCombatTypesChange(); ++iI)
		{
			if (info.getFlankingStrengthbyUnitCombatTypeChange(iI).eUnitCombat != NO_UNITCOMBAT)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_UNIT_COMBAT_FLANKING_STRIKES", info.getFlankingStrengthbyUnitCombatTypeChange(iI).iModifier, GC.getUnitCombatInfo((UnitCombatTypes)info.getFlankingStrengthbyUnitCombatTypeChange(iI).eUnitCombat).getTextKeyWide()));
			}
		}
	}

	if (info.getNumWithdrawVSUnitCombatTypesChange() > 0 )
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		for (iI = 0; iI < info.getNumWithdrawVSUnitCombatTypesChange(); ++iI)
		{
			if (info.getWithdrawVSUnitCombatTypeChange(iI).eUnitCombat != NO_UNITCOMBAT)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_WITHDRAW_VERSUS_TEXT", info.getWithdrawVSUnitCombatTypeChange(iI).iModifier, CvWString(GC.getUnitCombatInfo((UnitCombatTypes)info.getWithdrawVSUnitCombatTypeChange(iI).eUnitCombat).getType()).GetCString(), GC.getUnitCombatInfo((UnitCombatTypes)info.getWithdrawVSUnitCombatTypeChange(iI).eUnitCombat).getTextKeyWide()));
			}
		}
	}

	if (GC.getGame().isOption(GAMEOPTION_FIGHT_OR_FLIGHT))
	{
		if (info.getNumPursuitVSUnitCombatTypesChange() > 0 )
		{
			if (bFirstDisplay)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(info.getDescription());
				bFirstDisplay = false;
			}
			for (iI = 0; iI < info.getNumPursuitVSUnitCombatTypesChange(); ++iI)
			{
				if (info.getPursuitVSUnitCombatTypeChange(iI).eUnitCombat != NO_UNITCOMBAT)
				{
					szBuffer.append(NEWLINE);
					szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_PURSUIT_VERSUS_TEXT", info.getPursuitVSUnitCombatTypeChange(iI).iModifier, CvWString(GC.getUnitCombatInfo((UnitCombatTypes)info.getPursuitVSUnitCombatTypeChange(iI).eUnitCombat).getType()).GetCString(), GC.getUnitCombatInfo((UnitCombatTypes)info.getPursuitVSUnitCombatTypeChange(iI).eUnitCombat).getTextKeyWide()));
				}
			}
		}
	}

	if (GC.getGame().isOption(GAMEOPTION_HEART_OF_WAR))
	{
		if (info.getNumRepelVSUnitCombatTypesChange() > 0 )
		{
			if (bFirstDisplay)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(info.getDescription());
				bFirstDisplay = false;
			}
			for (iI = 0; iI < info.getNumRepelVSUnitCombatTypesChange(); ++iI)
			{
				if (info.getRepelVSUnitCombatTypeChange(iI).eUnitCombat != NO_UNITCOMBAT)
				{
					szBuffer.append(NEWLINE);
					szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_REPEL_VERSUS_TEXT", info.getRepelVSUnitCombatTypeChange(iI).iModifier, CvWString(GC.getUnitCombatInfo((UnitCombatTypes)info.getRepelVSUnitCombatTypeChange(iI).eUnitCombat).getType()).GetCString(), GC.getUnitCombatInfo((UnitCombatTypes)info.getRepelVSUnitCombatTypeChange(iI).eUnitCombat).getTextKeyWide()));
				}
			}
		}

		if (info.getNumKnockbackVSUnitCombatTypesChange() > 0 )
		{
			if (bFirstDisplay)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(info.getDescription());
				bFirstDisplay = false;
			}
			for (iI = 0; iI < info.getNumKnockbackVSUnitCombatTypesChange(); ++iI)
			{
				if (info.getKnockbackVSUnitCombatTypeChange(iI).eUnitCombat != NO_UNITCOMBAT)
				{
					szBuffer.append(NEWLINE);
					szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_KNOCKBACK_VERSUS_TEXT", info.getKnockbackVSUnitCombatTypeChange(iI).iModifier, CvWString(GC.getUnitCombatInfo((UnitCombatTypes)info.getKnockbackVSUnitCombatTypeChange(iI).eUnitCombat).getType()).GetCString(), GC.getUnitCombatInfo((UnitCombatTypes)info.getKnockbackVSUnitCombatTypeChange(iI).eUnitCombat).getTextKeyWide()));
				}
			}
		}
	}

	if (info.getNumPunctureVSUnitCombatTypesChange() > 0 )
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		for (iI = 0; iI < info.getNumPunctureVSUnitCombatTypesChange(); ++iI)
		{
			if (info.getPunctureVSUnitCombatTypeChange(iI).eUnitCombat != NO_UNITCOMBAT)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_PUNCTURE_VERSUS_TEXT", info.getPunctureVSUnitCombatTypeChange(iI).iModifier, CvWString(GC.getUnitCombatInfo((UnitCombatTypes)info.getPunctureVSUnitCombatTypeChange(iI).eUnitCombat).getType()).GetCString(), GC.getUnitCombatInfo((UnitCombatTypes)info.getPunctureVSUnitCombatTypeChange(iI).eUnitCombat).getTextKeyWide()));
			}
		}
	}

	if (info.getNumArmorVSUnitCombatTypesChange() > 0 )
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		for (iI = 0; iI < info.getNumArmorVSUnitCombatTypesChange(); ++iI)
		{
			if (info.getArmorVSUnitCombatTypeChange(iI).eUnitCombat != NO_UNITCOMBAT)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_ARMOR_VERSUS_TEXT", info.getArmorVSUnitCombatTypeChange(iI).iModifier, CvWString(GC.getUnitCombatInfo((UnitCombatTypes)info.getArmorVSUnitCombatTypeChange(iI).eUnitCombat).getType()).GetCString(), GC.getUnitCombatInfo((UnitCombatTypes)info.getArmorVSUnitCombatTypeChange(iI).eUnitCombat).getTextKeyWide()));
			}
		}
	}

	if (info.getNumDodgeVSUnitCombatTypesChange() > 0 )
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		for (iI = 0; iI < info.getNumDodgeVSUnitCombatTypesChange(); ++iI)
		{
			if (info.getDodgeVSUnitCombatTypeChange(iI).eUnitCombat != NO_UNITCOMBAT)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_DODGE_VERSUS_TEXT", info.getDodgeVSUnitCombatTypeChange(iI).iModifier, CvWString(GC.getUnitCombatInfo((UnitCombatTypes)info.getDodgeVSUnitCombatTypeChange(iI).eUnitCombat).getType()).GetCString(), GC.getUnitCombatInfo((UnitCombatTypes)info.getDodgeVSUnitCombatTypeChange(iI).eUnitCombat).getTextKeyWide()));
			}
		}
	}

	if (info.getNumPrecisionVSUnitCombatTypesChange() > 0 )
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		for (iI = 0; iI < info.getNumPrecisionVSUnitCombatTypesChange(); ++iI)
		{
			if (info.getPrecisionVSUnitCombatTypeChange(iI).eUnitCombat != NO_UNITCOMBAT)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_PRECISION_VERSUS_TEXT", info.getPrecisionVSUnitCombatTypeChange(iI).iModifier, CvWString(GC.getUnitCombatInfo((UnitCombatTypes)info.getPrecisionVSUnitCombatTypeChange(iI).eUnitCombat).getType()).GetCString(), GC.getUnitCombatInfo((UnitCombatTypes)info.getPrecisionVSUnitCombatTypeChange(iI).eUnitCombat).getTextKeyWide()));
			}
		}
	}

	if (info.getNumCriticalVSUnitCombatTypesChange() > 0 )
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		for (iI = 0; iI < info.getNumCriticalVSUnitCombatTypesChange(); ++iI)
		{
			if (info.getCriticalVSUnitCombatTypeChange(iI).eUnitCombat != NO_UNITCOMBAT)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_CRITICAL_VERSUS_TEXT", info.getCriticalVSUnitCombatTypeChange(iI).iModifier, CvWString(GC.getUnitCombatInfo((UnitCombatTypes)info.getCriticalVSUnitCombatTypeChange(iI).eUnitCombat).getType()).GetCString(), GC.getUnitCombatInfo((UnitCombatTypes)info.getCriticalVSUnitCombatTypeChange(iI).eUnitCombat).getTextKeyWide()));
			}
		}
	}

	if (info.getNumRoundStunVSUnitCombatTypesChange() > 0 )
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		for (iI = 0; iI < info.getNumRoundStunVSUnitCombatTypesChange(); ++iI)
		{
			if (info.getRoundStunVSUnitCombatTypeChange(iI).eUnitCombat != NO_UNITCOMBAT)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_ROUND_STUN_VERSUS_TEXT", info.getRoundStunVSUnitCombatTypeChange(iI).iModifier, CvWString(GC.getUnitCombatInfo((UnitCombatTypes)info.getRoundStunVSUnitCombatTypeChange(iI).eUnitCombat).getType()).GetCString(), GC.getUnitCombatInfo((UnitCombatTypes)info.getRoundStunVSUnitCombatTypeChange(iI).eUnitCombat).getTextKeyWide()));
			}
		}
	}


	if (info.getInsidiousnessChange() != 0)
	{
		szBuffer.append(NEWLINE);
		float fValue = (float)info.getInsidiousnessChange();
		{
			szTempBuffer.Format(L"%.1f", fValue/10);
		}
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_INSIDIOUSNESS_TEXT", szTempBuffer.GetCString()));
	}

	if (info.getInvestigationChange() != 0)
	{
		szBuffer.append(NEWLINE);
		float fValue = (float)info.getInvestigationChange();
		{
			szTempBuffer.Format(L"%.1f", fValue/10);
		}
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTION_INVESTIGATION_TEXT", szTempBuffer.GetCString()));
	}
	//Propery Manipulators
	if (info.getPropertyManipulators())
	{
		if (bFirstDisplay)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(info.getDescription());
			bFirstDisplay = false;
		}
		info.getPropertyManipulators()->buildDisplayString(szBuffer);
	}

}

void CvGameTextMgr::setImprovementHelp(CvWStringBuffer &szBuffer, ImprovementTypes eImprovement, FeatureTypes eFeature, bool bCivilopediaText)
{
	if (NO_IMPROVEMENT == eImprovement)
	{
		return;
	}
	CvWString szTempBuffer;
	CvWString szFirstBuffer;
	const PlayerTypes ePlayer = GC.getGame().getActivePlayer();
	const bool bPlayerContext = ePlayer != NO_PLAYER;

	const CvImprovementInfo& info = GC.getImprovementInfo(eImprovement);

	if (!bCivilopediaText)
	{
		szTempBuffer.Format( SETCOLR L"%s" ENDCOLR, TEXT_COLOR("COLOR_HIGHLIGHT_TEXT"), info.getDescription());
		szBuffer.append(szTempBuffer);

		setYieldChangeHelp(szBuffer, L", ", L"", L"", info.getYieldChangeArray(), false, false);

		setYieldChangeHelp(szBuffer, L"", L"", gDLL->getText("TXT_KEY_MISC_WITH_IRRIGATION").c_str(), info.getIrrigatedYieldChangeArray());
		setYieldChangeHelp(szBuffer, L"", L"", gDLL->getText("TXT_KEY_MISC_ON_HILLS").c_str(), info.getHillsYieldChangeArray());
		setYieldChangeHelp(szBuffer, L"", L"", gDLL->getText("TXT_KEY_MISC_ALONG_RIVER").c_str(), info.getRiverSideYieldChangeArray());

		for (int iTech = 0; iTech < GC.getNumTechInfos(); iTech++)
		{
			if (GC.getGame().canEverResearch((TechTypes)iTech))
			{
				for (int iYield = 0; iYield < NUM_YIELD_TYPES; iYield++)
				{
					if (0 != info.getTechYieldChanges(iTech, iYield))
					{
						szBuffer.append(NEWLINE);
						szBuffer.append
						(
							gDLL->getText
							(
								"TXT_KEY_IMPROVEMENT_WITH_TECH",
								info.getTechYieldChanges(iTech, iYield),
								GC.getYieldInfo((YieldTypes)iYield).getChar(),
								GC.getTechInfo((TechTypes)iTech).getTextKeyWide()
							)
						);
					}
				}
			}
		}

		for (int iTrait = 0; iTrait < GC.getNumTraitInfos(); iTrait++)
		{
			const CvTraitInfo& trait = GC.getTraitInfo((TraitTypes)iTrait);

			for (int iYield = 0; iYield < NUM_YIELD_TYPES; iYield++)
			{
				if (trait.getImprovementYieldChange(eImprovement, iYield) != 0)
				{
					szTempBuffer.Format( SETCOLR L"%s" ENDCOLR , TEXT_COLOR("COLOR_MAGENTA"), trait.getDescription());
					szBuffer.append(NEWLINE);
					szBuffer.append(gDLL->getText("TXT_KEY_CIVIC_IMPROVEMENT_YIELD_CHANGE", trait.getImprovementYieldChange(eImprovement, iYield), GC.getYieldInfo((YieldTypes)iYield).getChar()));
					szBuffer.append(szTempBuffer);
				}
				//if (0 != info.getTraitYieldChanges(iTrait, iYield))
				//{
				//	szTempBuffer.Format( SETCOLR L"%s" ENDCOLR , TEXT_COLOR("COLOR_MAGENTA"), trait.getDescription());
				//	szBuffer.append(NEWLINE);
				//	szBuffer.append(gDLL->getText("TXT_KEY_CIVIC_IMPROVEMENT_YIELD_CHANGE", info.getTraitYieldChanges(iTrait, iYield), GC.getYieldInfo((YieldTypes)iYield).getChar()));
				//	szBuffer.append(szTempBuffer);
				//}
			}
		}

		//	Civics
		for (int iYield = 0; iYield < NUM_YIELD_TYPES; iYield++)
		{
			for (int iCivic = 0; iCivic < GC.getNumCivicInfos(); iCivic++)
			{
				const int iChange = GC.getCivicInfo((CivicTypes)iCivic).getImprovementYieldChanges(eImprovement, iYield);
				if (0 != iChange)
				{
					szTempBuffer.Format( SETCOLR L"%s" ENDCOLR , TEXT_COLOR("COLOR_HIGHLIGHT_TEXT"), GC.getCivicInfo((CivicTypes)iCivic).getDescription());
					szBuffer.append(NEWLINE);
					szBuffer.append(gDLL->getText("TXT_KEY_CIVIC_IMPROVEMENT_YIELD_CHANGE", iChange, GC.getYieldInfo((YieldTypes)iYield).getChar()));
					szBuffer.append(szTempBuffer);
				}
			}
		}
	}

	if (info.isRequiresRiverSide())
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_IMPROVEMENT_REQUIRES_RIVER"));
	}

	if (info.isPeakImprovement())
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_IMPROVEMENT_REQUIRES_PEAK"));
	}

	if (info.isCarriesIrrigation())
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_IMPROVEMENT_CARRIES_IRRIGATION"));
	}
	if (bCivilopediaText)
	{
		if (info.isNoFreshWater())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_IMPROVEMENT_NO_BUILD_FRESH_WATER"));
		}
		if (info.isWaterImprovement())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_IMPROVEMENT_BUILD_ONLY_WATER"));
		}
		if (info.isRequiresFlatlands())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_IMPROVEMENT_ONLY_BUILD_FLATLANDS"));
		}
	}

	for (int iI = 0; iI < GC.getNumBuildInfos(); iI++)
	{
		const CvBuildInfo& build = GC.getBuildInfo((BuildTypes)iI);
		if (build.getImprovement() == eImprovement)
		{
			for (int iJ = 0; iJ < build.getNumPrereqBonusTypes(); iJ++)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_BUILD_REQUIRES_BONUS", build.getTextKeyWide(), GC.getBonusInfo((BonusTypes)build.getPrereqBonusType(iJ)).getTextKeyWide()));
			}
		}
	}

	if (info.getImprovementUpgrade() != NO_IMPROVEMENT)
	{
		const int iTurns =
		(
			bPlayerContext
			?
			(
				100 * GC.getGame().getImprovementUpgradeTime(eImprovement)
				/
				GET_PLAYER(ePlayer).getImprovementUpgradeProgressRate(eImprovement)
			)
			:
			info.getUpgradeTime()
		);
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_UPGRADE_TIME", iTurns));

		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_UPGRADES"));

		for (int iI = -1; iI < info.getNumAlternativeImprovementUpgradeTypes(); iI++)
		{
			const ImprovementTypes eUpgradeX =
			(
				iI == -1 ? (ImprovementTypes)info.getImprovementUpgrade()
				:
				(ImprovementTypes)info.getAlternativeImprovementUpgradeType(iI)
			);
			if (iI > -1)
			{
				szBuffer.append(L", ");
			}
			szBuffer.append
			(
				gDLL->getText
				(
					"TXT_KEY_LINK",
					CvWString(GC.getImprovementInfo(eUpgradeX).getType()).GetCString(),
					GC.getImprovementInfo(eUpgradeX).getTextKeyWide()
				)
			);
		}

		if (info.isUpgradeRequiresFortify())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_IMPROVEMENT_FORTIFY_TO_UPGRADE"));
		}
	}

	int iLast = -1;
	for (int iBonus = 0; iBonus < GC.getNumBonusInfos(); iBonus++)
	{
		const int iRand = info.getImprovementBonusDiscoverRand(iBonus);
		if (iRand > 0)
		{
			szFirstBuffer.Format(L"%s%s", NEWLINE, gDLL->getText("TXT_KEY_IMPROVEMENT_CHANCE_DISCOVER").c_str());
			szTempBuffer.Format(L"%c", GC.getBonusInfo((BonusTypes) iBonus).getChar());
			setListHelp(szBuffer, szFirstBuffer, szTempBuffer, L", ", iRand != iLast);
			iLast = iRand;
		}
	}

	if (0 != info.getDefenseModifier())
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_IMPROVEMENT_DEFENSE_MODIFIER", info.getDefenseModifier()));
	}

	if (0 != info.getHealthPercent())
	{
		const int iHealthPercent = info.getHealthPercent();
		szBuffer.append(NEWLINE);
		if (iHealthPercent % 100 == 0)
		{
			szBuffer.append
			(
				CvWString::format
				(
					L"%c%s%d%c%s",
					gDLL->getSymbolID(BULLET_CHAR),
					iHealthPercent > 0 ? L"+" : L"",
					abs(iHealthPercent / 100),
					(
						iHealthPercent > 0
						?
						gDLL->getSymbolID(HEALTHY_CHAR)
						:
						gDLL->getSymbolID(UNHEALTHY_CHAR)
					),
					gDLL->getText("TXT_KEY_MISC_ICON_CHANGE_NEARBY_CITIES_1").GetCString()
				)
			);
		}
		else if (iHealthPercent % 10 == 0)
		{
			szBuffer.append
			(
				CvWString::format
				(
					L"%c%s%.1f%c%s",
					gDLL->getSymbolID(BULLET_CHAR),
					iHealthPercent > 0 ? L"+" : L"",
					abs(iHealthPercent) * 0.01f,
					(
						iHealthPercent > 0
						?
						gDLL->getSymbolID(HEALTHY_CHAR)
						:
						gDLL->getSymbolID(UNHEALTHY_CHAR)
					),
					gDLL->getText("TXT_KEY_MISC_ICON_CHANGE_NEARBY_CITIES_1").GetCString()
				)
			);
		}
		else
		{
			szBuffer.append
			(
				CvWString::format
				(
					L"%c%s%.2f%c%s",
					gDLL->getSymbolID(BULLET_CHAR),
					iHealthPercent > 0 ? L"+" : L"",
					abs(iHealthPercent) * 0.01f,
					(
						iHealthPercent > 0
						?
						gDLL->getSymbolID(HEALTHY_CHAR)
						:
						gDLL->getSymbolID(UNHEALTHY_CHAR)
					),
					gDLL->getText("TXT_KEY_MISC_ICON_CHANGE_NEARBY_CITIES_1").GetCString()
				)
			);
		}
	}
	if (0 != info.getHappiness())
	{
		szBuffer.append(NEWLINE);
		szBuffer.append
		(
			gDLL->getText
			(
				"TXT_KEY_MISC_ICON_CHANGE_NEARBY_CITIES",
				abs(info.getHappiness()),
				(
					info.getHappiness() > 0
					?
					gDLL->getSymbolID(HAPPY_CHAR)
					:
					gDLL->getSymbolID(UNHAPPY_CHAR)
				)
			)
		);
	}
	if (info.isActsAsCity())
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_IMPROVEMENT_DEFENSE_MODIFIER_EXTRA"));
	}

	if (info.getFeatureGrowthProbability() > 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_IMPROVEMENT_MORE_GROWTH"));
	}
	else if (info.getFeatureGrowthProbability() < 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_IMPROVEMENT_LESS_GROWTH"));
	}

	if (info.isBombardable() && (info.getDefenseModifier() > 0))
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_IMPROVEMENT_BOMBARD"));
	}
	if (info.getUniqueRange() > 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_IMPROVEMENT_UNIQUE_RANGE", info.getUniqueRange()));
	}
	if (info.isZOCSource())
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_IMPROVEMENT_IS_ZOC_SOURCE"));
	}
	if (info.getNumFeatureChangeTypes() > 0)
	{
		for (int iI = 0; iI < info.getNumFeatureChangeTypes(); iI++)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_IMPROVEMENT_FEATURE_CHANGE", GC.getFeatureInfo((FeatureTypes)info.getFeatureChangeType(iI)).getTextKeyWide()));
		}
	}
	if (info.getBonusChange() != NO_FEATURE)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_IMPROVEMENT_BONUS_CHANGE", GC.getBonusInfo((BonusTypes)info.getBonusChange()).getTextKeyWide()));
	}
	if (info.isNotOnAnyBonus())
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_IMPROVEMENT_NOT_ON_ANY_BONUS"));
	}
	if (info.isNational())
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_IMPROVEMENT_NATIONAL"));
	}
	if (info.isGlobal())
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_IMPROVEMENT_GLOBAL"));
	}
	if (info.isChangeRemove())
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_IMPROVEMENT_CHANGE_REMOVE"));
	}
	if (info.isCanMoveSeaUnits())
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_IMPROVEMENT_IS_CAN_MOVE_SEA_UNITS"));
	}
	if (info.isUniversalTradeBonusProvider())
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_IMPROVEMENT_IS_UNIVERSAL_BONUS_PROVIDER"));
	}
	if (info.getCulture() > 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_IMPROVEMENT_PLOT_CULTURE", info.getCulture()));
	}
	if (info.getCultureRange() > 0 && info.getCulture() > 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_IMPROVEMENT_CULTURE_RANGE", info.getCultureRange()));
	}
	if (info.getVisibilityChange() > 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_IMPROVEMENT_VISIBILITY_RANGE", info.getVisibilityChange()));
	}
	if (info.getSeeFrom() > 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_IMPROVEMENT_SEE_FROM", info.getSeeFrom()));
	}
	if (info.getPillageGold() > 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_IMPROVEMENT_PILLAGE_YIELDS", info.getPillageGold()));
	}

	if (bPlayerContext && eFeature != NO_FEATURE)
	{
		const CvPlot* pPlot =
		(
			GET_PLAYER(ePlayer).getFocusPlotX() != -1
			?
			GC.getMap().plot(GET_PLAYER(ePlayer).getFocusPlotX(), GET_PLAYER(ePlayer).getFocusPlotY())
			:
			NULL
		);
		if (pPlot != NULL)
		{
			const TeamTypes eTeam = GET_PLAYER(ePlayer).getTeam();
			FAssertMsg(eTeam != NO_TEAM, "eTeam should be valid");
			CvCity* pCity = NULL;
			int iBestProduction = 0;

			for (int iI = 0; iI < GC.getNumBuildInfos(); iI++)
			{
				const CvBuildInfo& build = GC.getBuildInfo((BuildTypes)iI);

				if ((ImprovementTypes)build.getImprovement() == eImprovement
				&& GET_TEAM(eTeam).isHasTech((TechTypes)build.getTechPrereq()))
				{
					if (build.isFeatureRemove(eFeature))
					{
						const int iProduction = pPlot->getFeatureProduction((BuildTypes)iI, eTeam, &pCity);

						if (iProduction >= iBestProduction && iProduction != -1)
						{
							iBestProduction = iProduction;
						}
					}
					else iBestProduction = -1;
				}
			}
			if (iBestProduction >= 0)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_IMPROVEMENT_UPGRADE_DESTROYS_FEATURE", GC.getFeatureInfo(eFeature).getTextKeyWide(), iBestProduction, pCity->getNameKey()));
			}
			else if (iBestProduction == -1)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_IMPROVEMENT_UPGRADE_RETAINS_FEATURE", GC.getFeatureInfo(eFeature).getTextKeyWide()));
			}
		}
	}

	info.getPropertyManipulators()->buildDisplayString(szBuffer);

	if (bCivilopediaText)
	{
		for (int iI = 0; iI < info.getNumMapCategoryTypes(); iI++)
		{
			MapCategoryTypes eMapCategory = (MapCategoryTypes)info.getMapCategoryType(iI);
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_MAP_CATEGORY_PREREQUISITE", GC.getMapCategoryInfo(eMapCategory).getTextKeyWide()));
		}
	}
}

void CvGameTextMgr::setRouteHelp(CvWStringBuffer &szBuffer, RouteTypes eRoute, bool bCivilopediaText)
{
	CvWString szTempBuffer;
	CvWString szFirstBuffer;
	int iI;

	if (NO_ROUTE == eRoute)
	{
		return;
	}

	const int iMoveDenominator = GC.getMOVE_DENOMINATOR();

	const CvRouteInfo& info = GC.getRouteInfo(eRoute);
	if (!bCivilopediaText)
	{
		szTempBuffer.Format(SETCOLR L"%s" ENDCOLR, TEXT_COLOR("COLOR_HIGHLIGHT_TEXT"), info.getDescription());
		szBuffer.append(szTempBuffer);
		setYieldChangeHelp(szBuffer, L", ", L"", L"", info.getYieldChangeArray(), false, false);
	}

	if (info.isSeaTunnel())
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_ROUTE_SEA_TUNNEL"));
	}

	if (info.getMovementCost() != 0)
	{
		szTempBuffer.clear();
		szTempBuffer.Format(L"%.2f%c ", (float)info.getMovementCost() / iMoveDenominator, gDLL->getSymbolID(MOVES_CHAR));
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_ROUTE_MOVEMENT_COST", szTempBuffer.GetCString()));
	}

	if (info.getFlatMovementCost() != 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_ROUTE_FLAT_MOVEMENT_COST", iMoveDenominator / info.getFlatMovementCost()));
	}

	if (info.getPrereqBonus() != NO_BONUS)
	{
		if ((GC.getGame().getActivePlayer() != NO_PLAYER && !GET_PLAYER(GC.getGame().getActivePlayer()).hasBonus((BonusTypes)info.getPrereqBonus())) || GC.getGame().getActivePlayer() == NO_PLAYER)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_ROUTE_REQUIRES_BONUS", GC.getBonusInfo((BonusTypes)info.getPrereqBonus()).getTextKeyWide()));
		}
	}

	if (info.isAnyPrereqOrBonus())
	{
		bool bQualified = true;

		for (iI = 0; iI < GC.getNUM_ROUTE_PREREQ_OR_BONUSES(); iI++)
		{
			BonusTypes eBonusOrPrereq = (BonusTypes)info.getPrereqOrBonus((BonusTypes)iI);
			if (eBonusOrPrereq == NO_BONUS)
				continue;

			if (GC.getGame().getActivePlayer() != NO_PLAYER && GET_PLAYER(GC.getGame().getActivePlayer()).hasBonus(eBonusOrPrereq))
			{
				bQualified = false;
				break;
			}
		}
		if (bQualified)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(BULLET_CHAR);

			for (iI = 0; iI < GC.getNUM_ROUTE_PREREQ_OR_BONUSES(); iI++)
			{
				BonusTypes eBonusOrPrereq = (BonusTypes)info.getPrereqOrBonus((BonusTypes)iI);
				if (eBonusOrPrereq == NO_BONUS)
					continue;

				if (GC.getGame().getActivePlayer() == NO_PLAYER || !GET_PLAYER(GC.getGame().getActivePlayer()).hasBonus(eBonusOrPrereq))
				{
					szBuffer.append(gDLL->getText("TXT_KEY_ROUTE_REQUIRES_BONUS_OR", GC.getBonusInfo(eBonusOrPrereq).getTextKeyWide()));
				}
			}
		}
	}

	if (bCivilopediaText)
	{
		for (int iTech = 0; iTech < GC.getNumTechInfos(); iTech++)
		{
			if (GC.getGame().canEverResearch((TechTypes)iTech))
			{
				if (0 != info.getTechMovementChange(iTech))
				{
					szTempBuffer.clear();
					szTempBuffer.Format(L"%.2f%c ", (float)info.getMovementCost() / iMoveDenominator, gDLL->getSymbolID(MOVES_CHAR));
					szBuffer.append(NEWLINE);
					szBuffer.append(gDLL->getText("TXT_KEY_MOVEMENT_ROUTE_WITH_TECH", szTempBuffer.GetCString(), GC.getTechInfo((TechTypes)iTech).getTextKeyWide()));
				}
			}
		}
	}

	info.getPropertyManipulators()->buildDisplayString(szBuffer);
}


void CvGameTextMgr::getDealString(CvWStringBuffer& szBuffer, CvDeal& deal, PlayerTypes ePlayerPerspective)
{
	PlayerTypes ePlayer1 = deal.getFirstPlayer();
	PlayerTypes ePlayer2 = deal.getSecondPlayer();

	const CLinkList<TradeData>* pListPlayer1 = deal.getFirstTrades();
	const CLinkList<TradeData>* pListPlayer2 = deal.getSecondTrades();

	getDealString(szBuffer, ePlayer1, ePlayer2, pListPlayer1,  pListPlayer2, ePlayerPerspective);
}

void CvGameTextMgr::getDealString(CvWStringBuffer& szBuffer, PlayerTypes ePlayer1, PlayerTypes ePlayer2, const CLinkList<TradeData>* pListPlayer1, const CLinkList<TradeData>* pListPlayer2, PlayerTypes ePlayerPerspective)
{
	if (NO_PLAYER == ePlayer1 || NO_PLAYER == ePlayer2)
	{
		FErrorMsg("Deal needs two parties");
		return;
	}

	CvWStringBuffer szDealOne;
	if (NULL != pListPlayer1 && pListPlayer1->getLength() > 0)
	{
		CLLNode<TradeData>* pTradeNode;
		bool bFirst = true;
		for (pTradeNode = pListPlayer1->head(); pTradeNode; pTradeNode = pListPlayer1->next(pTradeNode))
		{
			CvWStringBuffer szTrade;
			getTradeString(szTrade, pTradeNode->m_data, ePlayer1, ePlayer2);
			setListHelp(szDealOne, L"", szTrade.getCString(), L", ", bFirst);
			bFirst = false;
		}
	}

	CvWStringBuffer szDealTwo;
	if (NULL != pListPlayer2 && pListPlayer2->getLength() > 0)
	{
		CLLNode<TradeData>* pTradeNode;
		bool bFirst = true;
		for (pTradeNode = pListPlayer2->head(); pTradeNode; pTradeNode = pListPlayer2->next(pTradeNode))
		{
			CvWStringBuffer szTrade;
			getTradeString(szTrade, pTradeNode->m_data, ePlayer2, ePlayer1);
			setListHelp(szDealTwo, L"", szTrade.getCString(), L", ", bFirst);
			bFirst = false;
		}
	}

	if (!szDealOne.isEmpty())
	{
		if (!szDealTwo.isEmpty())
		{
			if (ePlayerPerspective == ePlayer1)
			{
				szBuffer.append(gDLL->getText("TXT_KEY_MISC_OUR_DEAL", szDealOne.getCString(), GET_PLAYER(ePlayer2).getNameKey(), szDealTwo.getCString()));
			}
			else if (ePlayerPerspective == ePlayer2)
			{
				szBuffer.append(gDLL->getText("TXT_KEY_MISC_OUR_DEAL", szDealTwo.getCString(), GET_PLAYER(ePlayer1).getNameKey(), szDealOne.getCString()));
			}
			else
			{
				szBuffer.append(gDLL->getText("TXT_KEY_MISC_DEAL", GET_PLAYER(ePlayer1).getNameKey(), szDealOne.getCString(), GET_PLAYER(ePlayer2).getNameKey(), szDealTwo.getCString()));
			}
		}
		else
		{
			if (ePlayerPerspective == ePlayer1)
			{
				szBuffer.append(gDLL->getText("TXT_KEY_MISC_DEAL_ONESIDED_OURS", szDealOne.getCString(), GET_PLAYER(ePlayer2).getNameKey()));
			}
			else if (ePlayerPerspective == ePlayer2)
			{
				szBuffer.append(gDLL->getText("TXT_KEY_MISC_DEAL_ONESIDED_THEIRS", szDealOne.getCString(), GET_PLAYER(ePlayer1).getNameKey()));
			}
			else
			{
				szBuffer.append(gDLL->getText("TXT_KEY_MISC_DEAL_ONESIDED", GET_PLAYER(ePlayer1).getNameKey(), szDealOne.getCString(), GET_PLAYER(ePlayer2).getNameKey()));
			}
		}
	}
	else if (!szDealTwo.isEmpty())
	{
		if (ePlayerPerspective == ePlayer1)
		{
			szBuffer.append(gDLL->getText("TXT_KEY_MISC_DEAL_ONESIDED_THEIRS", szDealTwo.getCString(), GET_PLAYER(ePlayer2).getNameKey()));
		}
		else if (ePlayerPerspective == ePlayer2)
		{
			szBuffer.append(gDLL->getText("TXT_KEY_MISC_DEAL_ONESIDED_OURS", szDealTwo.getCString(), GET_PLAYER(ePlayer1).getNameKey()));
		}
		else
		{
			szBuffer.append(gDLL->getText("TXT_KEY_MISC_DEAL_ONESIDED", GET_PLAYER(ePlayer2).getNameKey(), szDealTwo.getCString(), GET_PLAYER(ePlayer1).getNameKey()));
		}
	}
}

void CvGameTextMgr::getWarplanString(CvWStringBuffer& szString, WarPlanTypes eWarPlan)
{
	switch (eWarPlan)
	{
		case WARPLAN_ATTACKED_RECENT: szString.assign(L"new defensive war"); break;
		case WARPLAN_ATTACKED: szString.assign(L"defensive war"); break;
		case WARPLAN_PREPARING_LIMITED: szString.assign(L"preparing limited war"); break;
		case WARPLAN_PREPARING_TOTAL: szString.assign(L"preparing total war"); break;
		case WARPLAN_LIMITED: szString.assign(L"limited war"); break;
		case WARPLAN_TOTAL: szString.assign(L"total war"); break;
		case WARPLAN_DOGPILE: szString.assign(L"dogpile war"); break;
		case NO_WARPLAN: szString.assign(L"unplanned war"); break;
		default:  szString.assign(L"unknown war"); break;
	}
}

void CvGameTextMgr::getAttitudeString(CvWStringBuffer& szBuffer, PlayerTypes ePlayer, PlayerTypes eTargetPlayer)
{
	CvWString szTempBuffer;
	int iAttitudeChange;
	int iPass;
	int iI;
	CvPlayerAI& kPlayer = GET_PLAYER(ePlayer);
	TeamTypes eTeam = (TeamTypes) kPlayer.getTeam();
	CvTeamAI& kTeam = GET_TEAM(eTeam);

	if (eTargetPlayer == NO_PLAYER)
	{
		FErrorMsg("TargetPlayer must be valid when requesting attitude string")
		return;
	}

	szBuffer.append(gDLL->getText("TXT_KEY_ATTITUDE_TOWARDS", GC.getAttitudeInfo(GET_PLAYER(ePlayer).AI_getAttitude(eTargetPlayer)).getTextKeyWide(), GET_PLAYER(eTargetPlayer).getNameKey()));

	for (int iTeam = 0; iTeam < MAX_TEAMS; iTeam++)
	{
		CvTeam& kLoopTeam = GET_TEAM((TeamTypes)iTeam);
		if (kLoopTeam.isAlive())
		{
			CvTeam& kTargetTeam = GET_TEAM(GET_PLAYER(eTargetPlayer).getTeam());
			if (kTargetTeam.isHasMet((TeamTypes)iTeam))
			{
				if (kTeam.isVassal((TeamTypes)iTeam))
				{
					szBuffer.append(NEWLINE);
					szBuffer.append(gDLL->getText("TXT_KEY_ATTITUDE_VASSAL_OF", kLoopTeam.getName().GetCString()));

					setVassalRevoltHelp(szBuffer, (TeamTypes)iTeam, kTeam.getID());
				}
				else if (kLoopTeam.isVassal(kTeam.getID()))
				{
					szBuffer.append(NEWLINE);
					szBuffer.append(gDLL->getText("TXT_KEY_ATTITUDE_MASTER_OF", kLoopTeam.getName().GetCString()));
				}
			}
		}
	}

	for (iPass = 0; iPass < 2; iPass++)
	{
		iAttitudeChange = kPlayer.AI_getTraitAttitude(eTargetPlayer);
		if ((iPass == 0) ? (iAttitudeChange > 0) : (iAttitudeChange < 0))
		{
			szTempBuffer.Format(SETCOLR L"%s" ENDCOLR, TEXT_COLOR((iAttitudeChange > 0) ? "COLOR_POSITIVE_TEXT" : "COLOR_NEGATIVE_TEXT"), gDLL->getText(((iAttitudeChange > 0) ? "TXT_KEY_MISC_ATTITUDE_TRAIT_GOOD" : "TXT_KEY_MISC_ATTITUDE_TRAIT_BAD"), iAttitudeChange).GetCString());
			szBuffer.append(NEWLINE);
			szBuffer.append(szTempBuffer);
		}

		iAttitudeChange = kPlayer.AI_getCloseBordersAttitude(eTargetPlayer);
		if ((iPass == 0) ? (iAttitudeChange > 0) : (iAttitudeChange < 0))
		{
			szTempBuffer.Format(SETCOLR L"%s" ENDCOLR, TEXT_COLOR((iAttitudeChange > 0) ? "COLOR_POSITIVE_TEXT" : "COLOR_NEGATIVE_TEXT"), gDLL->getText("TXT_KEY_MISC_ATTITUDE_LAND_TARGET", iAttitudeChange).GetCString());
			szBuffer.append(NEWLINE);
			szBuffer.append(szTempBuffer);
		}

		iAttitudeChange = kPlayer.AI_getWarAttitude(eTargetPlayer);
		if ((iPass == 0) ? (iAttitudeChange > 0) : (iAttitudeChange < 0))
		{
			szTempBuffer.Format(SETCOLR L"%s" ENDCOLR, TEXT_COLOR((iAttitudeChange > 0) ? "COLOR_POSITIVE_TEXT" : "COLOR_NEGATIVE_TEXT"), gDLL->getText("TXT_KEY_MISC_ATTITUDE_WAR", iAttitudeChange).GetCString());
			szBuffer.append(NEWLINE);
			szBuffer.append(szTempBuffer);
		}

		iAttitudeChange = kPlayer.AI_getPeaceAttitude(eTargetPlayer);
		if ((iPass == 0) ? (iAttitudeChange > 0) : (iAttitudeChange < 0))
		{
			szTempBuffer.Format(SETCOLR L"%s" ENDCOLR, TEXT_COLOR((iAttitudeChange > 0) ? "COLOR_POSITIVE_TEXT" : "COLOR_NEGATIVE_TEXT"), gDLL->getText("TXT_KEY_MISC_ATTITUDE_PEACE", iAttitudeChange).GetCString());
			szBuffer.append(NEWLINE);
			szBuffer.append(szTempBuffer);
		}

		iAttitudeChange = kPlayer.AI_getSameReligionAttitude(eTargetPlayer);
		if ((iPass == 0) ? (iAttitudeChange > 0) : (iAttitudeChange < 0))
		{
			szTempBuffer.Format(SETCOLR L"%s" ENDCOLR, TEXT_COLOR((iAttitudeChange > 0) ? "COLOR_POSITIVE_TEXT" : "COLOR_NEGATIVE_TEXT"), gDLL->getText("TXT_KEY_MISC_ATTITUDE_SAME_RELIGION", iAttitudeChange).GetCString());
			szBuffer.append(NEWLINE);
			szBuffer.append(szTempBuffer);
		}

		iAttitudeChange = kPlayer.AI_getDifferentReligionAttitude(eTargetPlayer);
		if ((iPass == 0) ? (iAttitudeChange > 0) : (iAttitudeChange < 0))
		{
			szTempBuffer.Format(SETCOLR L"%s" ENDCOLR, TEXT_COLOR((iAttitudeChange > 0) ? "COLOR_POSITIVE_TEXT" : "COLOR_NEGATIVE_TEXT"), gDLL->getText("TXT_KEY_MISC_ATTITUDE_DIFFERENT_RELIGION", iAttitudeChange).GetCString());
			szBuffer.append(NEWLINE);
			szBuffer.append(szTempBuffer);
		}

		iAttitudeChange = kPlayer.AI_getBonusTradeAttitude(eTargetPlayer);
		if ((iPass == 0) ? (iAttitudeChange > 0) : (iAttitudeChange < 0))
		{
			szTempBuffer.Format(SETCOLR L"%s" ENDCOLR, TEXT_COLOR((iAttitudeChange > 0) ? "COLOR_POSITIVE_TEXT" : "COLOR_NEGATIVE_TEXT"), gDLL->getText("TXT_KEY_MISC_ATTITUDE_BONUS_TRADE", iAttitudeChange).GetCString());
			szBuffer.append(NEWLINE);
			szBuffer.append(szTempBuffer);
		}

		iAttitudeChange = kPlayer.AI_getOpenBordersAttitude(eTargetPlayer);
		if ((iPass == 0) ? (iAttitudeChange > 0) : (iAttitudeChange < 0))
		{
			szTempBuffer.Format(SETCOLR L"%s" ENDCOLR, TEXT_COLOR((iAttitudeChange > 0) ? "COLOR_POSITIVE_TEXT" : "COLOR_NEGATIVE_TEXT"), gDLL->getText("TXT_KEY_MISC_ATTITUDE_OPEN_BORDERS", iAttitudeChange).GetCString());
			szBuffer.append(NEWLINE);
			szBuffer.append(szTempBuffer);
		}

		iAttitudeChange = kPlayer.AI_getDefensivePactAttitude(eTargetPlayer);
		if ((iPass == 0) ? (iAttitudeChange > 0) : (iAttitudeChange < 0))
		{
			szTempBuffer.Format(SETCOLR L"%s" ENDCOLR, TEXT_COLOR((iAttitudeChange > 0) ? "COLOR_POSITIVE_TEXT" : "COLOR_NEGATIVE_TEXT"), gDLL->getText("TXT_KEY_MISC_ATTITUDE_DEFENSIVE_PACT", iAttitudeChange).GetCString());
			szBuffer.append(NEWLINE);
			szBuffer.append(szTempBuffer);
		}

		iAttitudeChange = kPlayer.AI_getRivalDefensivePactAttitude(eTargetPlayer);
		if ((iPass == 0) ? (iAttitudeChange > 0) : (iAttitudeChange < 0))
		{
			szTempBuffer.Format(SETCOLR L"%s" ENDCOLR, TEXT_COLOR((iAttitudeChange > 0) ? "COLOR_POSITIVE_TEXT" : "COLOR_NEGATIVE_TEXT"), gDLL->getText("TXT_KEY_MISC_ATTITUDE_RIVAL_DEFENSIVE_PACT", iAttitudeChange).GetCString());
			szBuffer.append(NEWLINE);
			szBuffer.append(szTempBuffer);
		}

		iAttitudeChange = kPlayer.AI_getRivalVassalAttitude(eTargetPlayer);
		if ((iPass == 0) ? (iAttitudeChange > 0) : (iAttitudeChange < 0))
		{
			szTempBuffer.Format(SETCOLR L"%s" ENDCOLR, TEXT_COLOR((iAttitudeChange > 0) ? "COLOR_POSITIVE_TEXT" : "COLOR_NEGATIVE_TEXT"), gDLL->getText("TXT_KEY_MISC_ATTITUDE_RIVAL_VASSAL", iAttitudeChange).GetCString());
			szBuffer.append(NEWLINE);
			szBuffer.append(szTempBuffer);
		}

		iAttitudeChange = kPlayer.AI_getShareWarAttitude(eTargetPlayer);
		if ((iPass == 0) ? (iAttitudeChange > 0) : (iAttitudeChange < 0))
		{
			szTempBuffer.Format(SETCOLR L"%s" ENDCOLR, TEXT_COLOR((iAttitudeChange > 0) ? "COLOR_POSITIVE_TEXT" : "COLOR_NEGATIVE_TEXT"), gDLL->getText("TXT_KEY_MISC_ATTITUDE_SHARE_WAR", iAttitudeChange).GetCString());
			szBuffer.append(NEWLINE);
			szBuffer.append(szTempBuffer);
		}

		iAttitudeChange = kPlayer.AI_getFavoriteCivicAttitude(eTargetPlayer);
		if ((iPass == 0) ? (iAttitudeChange > 0) : (iAttitudeChange < 0))
		{
			szTempBuffer.Format(SETCOLR L"%s" ENDCOLR, TEXT_COLOR((iAttitudeChange > 0) ? "COLOR_POSITIVE_TEXT" : "COLOR_NEGATIVE_TEXT"), gDLL->getText("TXT_KEY_MISC_ATTITUDE_FAVORITE_CIVIC", iAttitudeChange).GetCString());
			szBuffer.append(NEWLINE);
			szBuffer.append(szTempBuffer);
		}

		iAttitudeChange = kPlayer.AI_getTradeAttitude(eTargetPlayer);
		if ((iPass == 0) ? (iAttitudeChange > 0) : (iAttitudeChange < 0))
		{
			szTempBuffer.Format(SETCOLR L"%s" ENDCOLR, TEXT_COLOR((iAttitudeChange > 0) ? "COLOR_POSITIVE_TEXT" : "COLOR_NEGATIVE_TEXT"), gDLL->getText("TXT_KEY_MISC_ATTITUDE_TRADE", iAttitudeChange).GetCString());
			szBuffer.append(NEWLINE);
			szBuffer.append(szTempBuffer);
		}

		iAttitudeChange = kPlayer.AI_getRivalTradeAttitude(eTargetPlayer);
		if ((iPass == 0) ? (iAttitudeChange > 0) : (iAttitudeChange < 0))
		{
			szTempBuffer.Format(SETCOLR L"%s" ENDCOLR, TEXT_COLOR((iAttitudeChange > 0) ? "COLOR_POSITIVE_TEXT" : "COLOR_NEGATIVE_TEXT"), gDLL->getText("TXT_KEY_MISC_ATTITUDE_RIVAL_TRADE", iAttitudeChange).GetCString());
			szBuffer.append(NEWLINE);
			szBuffer.append(szTempBuffer);
		}

		iAttitudeChange = GET_PLAYER(ePlayer).AI_getColonyAttitude(eTargetPlayer);
		if ((iPass == 0) ? (iAttitudeChange > 0) : (iAttitudeChange < 0))
		{
			szTempBuffer.Format(SETCOLR L"%s" ENDCOLR, TEXT_COLOR((iAttitudeChange > 0) ? "COLOR_POSITIVE_TEXT" : "COLOR_NEGATIVE_TEXT"), gDLL->getText("TXT_KEY_MISC_ATTITUDE_FREEDOM", iAttitudeChange).GetCString());
			szBuffer.append(NEWLINE);
			szBuffer.append(szTempBuffer);
		}

		iAttitudeChange = GET_PLAYER(ePlayer).AI_getAttitudeExtra(eTargetPlayer);
		if ((iPass == 0) ? (iAttitudeChange > 0) : (iAttitudeChange < 0))
		{
			szTempBuffer.Format(SETCOLR L"%s" ENDCOLR, TEXT_COLOR((iAttitudeChange > 0) ? "COLOR_POSITIVE_TEXT" : "COLOR_NEGATIVE_TEXT"), gDLL->getText(((iAttitudeChange > 0) ? "TXT_KEY_MISC_ATTITUDE_EXTRA_GOOD" : "TXT_KEY_MISC_ATTITUDE_EXTRA_BAD"), iAttitudeChange).GetCString());
			szBuffer.append(NEWLINE);
			szBuffer.append(szTempBuffer);
		}

		iAttitudeChange = GET_PLAYER(ePlayer).AI_getCivicShareAttitude(eTargetPlayer);
		if ((iPass == 0) ? (iAttitudeChange > 0) : (iAttitudeChange < 0))
		{
			if (GET_PLAYER(ePlayer).AI_getCivicShareAttitude(eTargetPlayer) > 0)
			{
				szTempBuffer.Format(SETCOLR L"%s" ENDCOLR, TEXT_COLOR((iAttitudeChange > 0) ? "COLOR_POSITIVE_TEXT" : "COLOR_NEGATIVE_TEXT"), gDLL->getText("TXT_KEY_MISC_ATTITUDE_CIVIC_SHARE_GOOD", iAttitudeChange).GetCString());
				szBuffer.append(NEWLINE);
				szBuffer.append(szTempBuffer);
			}
			if (GET_PLAYER(ePlayer).AI_getCivicShareAttitude(eTargetPlayer) < 0)
			{
				szTempBuffer.Format(SETCOLR L"%s" ENDCOLR, TEXT_COLOR((iAttitudeChange > 0) ? "COLOR_POSITIVE_TEXT" : "COLOR_NEGATIVE_TEXT"), gDLL->getText("TXT_KEY_MISC_ATTITUDE_CIVIC_SHARE_BAD", iAttitudeChange).GetCString());
				szBuffer.append(NEWLINE);
				szBuffer.append(szTempBuffer);
			}
		}
		iAttitudeChange = GET_PLAYER(ePlayer).AI_getEmbassyAttitude(eTargetPlayer);
		if ((iPass == 0) ? (iAttitudeChange > 0) : (iAttitudeChange < 0))
		{
			if (iAttitudeChange > 0)
			{
				szTempBuffer.Format(SETCOLR L"%s" ENDCOLR, TEXT_COLOR((iAttitudeChange > 0) ? "COLOR_POSITIVE_TEXT" : "COLOR_NEGATIVE_TEXT"), gDLL->getText("TXT_KEY_EMBASSY_DIPLOMACY_BONUS", iAttitudeChange).GetCString());
				szBuffer.append(NEWLINE);
				szBuffer.append(szTempBuffer);
			}
			else if (iAttitudeChange < 0)
			{
				szTempBuffer.Format(SETCOLR L"%s" ENDCOLR, TEXT_COLOR((iAttitudeChange > 0) ? "COLOR_POSITIVE_TEXT" : "COLOR_NEGATIVE_TEXT"), gDLL->getText("TXT_KEY_EMBASSY_DIPLOMACY_MALUS", iAttitudeChange).GetCString());
				szBuffer.append(NEWLINE);
				szBuffer.append(szTempBuffer);
			}
		}
		if (iPass == 0)
		{
			CivicTypes eTargetCivic;
			CivicTypes eCivic;
			int** ppaiCivicAttitudeChanges = new int*[GC.getNumCivicOptionInfos()];
			CvWString** ppaszCivicAttitudeReasons = new CvWString*[GC.getNumCivicOptionInfos()];
			for (int iJ = 0; iJ < GC.getNumCivicOptionInfos(); iJ++)
			{
				ppaiCivicAttitudeChanges[iJ] = new int[GC.getNumCivicOptionInfos()];
				ppaszCivicAttitudeReasons[iJ] = new CvWString[GC.getNumCivicOptionInfos()];
			}
			for (int iJ = 0; iJ < GC.getNumCivicOptionInfos(); iJ++)
			{
				eTargetCivic = GET_PLAYER(eTargetPlayer).getCivics((CivicOptionTypes)iJ);
				for (int iK = 0; iK < GC.getNumCivicOptionInfos(); iK++)
				{
					eCivic = GET_PLAYER(ePlayer).getCivics((CivicOptionTypes)iK);
					ppaiCivicAttitudeChanges[iJ][iK] = GC.getCivicInfo(eCivic).getCivicAttitudeChange(eTargetCivic);
					ppaszCivicAttitudeReasons[iJ][iK] = GC.getCivicInfo(eCivic).getCivicAttitudeReason(eTargetCivic);
				}
			}
			for (int iJ = 0; iJ < GC.getNumCivicOptionInfos(); iJ++)
			{
				for (int iK = 0; iK < GC.getNumCivicOptionInfos(); iK++)
				{
					for (int iL = iK + 1; iL < GC.getNumCivicOptionInfos(); iL++)
					{
						if (ppaszCivicAttitudeReasons[iJ][iK] == ppaszCivicAttitudeReasons[iJ][iL])
						{
							ppaiCivicAttitudeChanges[iJ][iK] += ppaiCivicAttitudeChanges[iJ][iL];
							ppaszCivicAttitudeReasons[iJ][iL].clear();
							ppaiCivicAttitudeChanges[iJ][iL] = 0;
						}
					}
				}
			}
			for (int iJ = 0; iJ < GC.getNumCivicOptionInfos(); iJ++)
			{
				for (int iK = 0; iK < GC.getNumCivicOptionInfos(); iK++)
				{
					if (ppaiCivicAttitudeChanges[iJ][iK] != 0 && !ppaszCivicAttitudeReasons[iJ][iK].empty())
					{
						szBuffer.append(NEWLINE);
						szTempBuffer.Format(SETCOLR L"%s" ENDCOLR, TEXT_COLOR((ppaiCivicAttitudeChanges[iJ][iK] > 0) ? "COLOR_POSITIVE_TEXT" : "COLOR_NEGATIVE_TEXT"), gDLL->getText(ppaszCivicAttitudeReasons[iJ][iK], ppaiCivicAttitudeChanges[iJ][iK]).GetCString());
						szBuffer.append(szTempBuffer);
					}
				}
			}
			for (int iJ = 0; iJ < GC.getNumCivicOptionInfos(); iJ++)
			{
				SAFE_DELETE_ARRAY(ppaiCivicAttitudeChanges[iJ]);
				SAFE_DELETE_ARRAY(ppaszCivicAttitudeReasons[iJ]);
			}
			SAFE_DELETE_ARRAY(ppaiCivicAttitudeChanges);
			SAFE_DELETE_ARRAY(ppaszCivicAttitudeReasons);
		}

		// BEGIN: Show Hidden Attitude Mod 01/22/2010
		if (GC.getDefineINT("SHOW_HIDDEN_ATTITUDE")
			&& getBugOptionBOOL("MiscHover__LeaderheadHiddenAttitude", true, "BUG_LEADERHEAD_HOVER_HIDDEN_ATTITUDE"))
		{
			iAttitudeChange = kPlayer.AI_getBetterRankDifferenceAttitude(eTargetPlayer);
			if ((iPass == 0) ? (iAttitudeChange > 0) : (iAttitudeChange < 0))
			{
				szTempBuffer.Format(SETCOLR L"%s" ENDCOLR, TEXT_COLOR((iAttitudeChange > 0) ? "COLOR_POSITIVE_TEXT" : "COLOR_NEGATIVE_TEXT"), gDLL->getText("TXT_KEY_MISC_ATTITUDE_BETTER_RANK", iAttitudeChange).GetCString());
				szBuffer.append(NEWLINE);
				szBuffer.append(szTempBuffer);
			}

			iAttitudeChange = kPlayer.AI_getWorseRankDifferenceAttitude(eTargetPlayer);
			if ((iPass == 0) ? (iAttitudeChange > 0) : (iAttitudeChange < 0))
			{
				szTempBuffer.Format(SETCOLR L"%s" ENDCOLR, TEXT_COLOR((iAttitudeChange > 0) ? "COLOR_POSITIVE_TEXT" : "COLOR_NEGATIVE_TEXT"), gDLL->getText("TXT_KEY_MISC_ATTITUDE_WORSE_RANK", iAttitudeChange).GetCString());
				szBuffer.append(NEWLINE);
				szBuffer.append(szTempBuffer);
			}

			iAttitudeChange = kPlayer.AI_getLowRankAttitude(eTargetPlayer);
			if ((iPass == 0) ? (iAttitudeChange > 0) : (iAttitudeChange < 0))
			{
				szTempBuffer.Format(SETCOLR L"%s" ENDCOLR, TEXT_COLOR((iAttitudeChange > 0) ? "COLOR_POSITIVE_TEXT" : "COLOR_NEGATIVE_TEXT"), gDLL->getText("TXT_KEY_MISC_ATTITUDE_LOW_RANK", iAttitudeChange).GetCString());
				szBuffer.append(NEWLINE);
				szBuffer.append(szTempBuffer);
			}

			iAttitudeChange = kPlayer.AI_getLostWarAttitude(eTargetPlayer);
			if ((iPass == 0) ? (iAttitudeChange > 0) : (iAttitudeChange < 0))
			{
				szTempBuffer.Format(SETCOLR L"%s" ENDCOLR, TEXT_COLOR((iAttitudeChange > 0) ? "COLOR_POSITIVE_TEXT" : "COLOR_NEGATIVE_TEXT"), gDLL->getText("TXT_KEY_MISC_ATTITUDE_LOST_WAR", iAttitudeChange).GetCString());
				szBuffer.append(NEWLINE);
				szBuffer.append(szTempBuffer);
			}

			iAttitudeChange = kPlayer.AI_getTeamSizeAttitude(eTargetPlayer);
			if ((iPass == 0) ? (iAttitudeChange > 0) : (iAttitudeChange < 0))
			{
				szTempBuffer.Format(SETCOLR L"%s" ENDCOLR, TEXT_COLOR((iAttitudeChange > 0) ? "COLOR_POSITIVE_TEXT" : "COLOR_NEGATIVE_TEXT"), gDLL->getText("TXT_KEY_MISC_ATTITUDE_TEAM_SIZE", iAttitudeChange).GetCString());
				szBuffer.append(NEWLINE);
				szBuffer.append(szTempBuffer);
			}

			iAttitudeChange = kPlayer.AI_getFirstImpressionAttitude(eTargetPlayer);
			if ((iPass == 0) ? (iAttitudeChange > 0) : (iAttitudeChange < 0))
			{
				szTempBuffer.Format(SETCOLR L"%s" ENDCOLR, TEXT_COLOR((iAttitudeChange > 0) ? "COLOR_POSITIVE_TEXT" : "COLOR_NEGATIVE_TEXT"), gDLL->getText("TXT_KEY_MISC_ATTITUDE_FIRST_IMPRESSION", iAttitudeChange).GetCString());
				szBuffer.append(NEWLINE);
				szBuffer.append(szTempBuffer);
			}
		}

		for (iI = 0; iI < NUM_MEMORY_TYPES; ++iI)
		{
			iAttitudeChange = kPlayer.AI_getMemoryAttitude(eTargetPlayer, ((MemoryTypes)iI));
			if ((iPass == 0) ? (iAttitudeChange > 0) : (iAttitudeChange < 0))
			{
				szTempBuffer.Format(SETCOLR L"%s" ENDCOLR, TEXT_COLOR((iAttitudeChange > 0) ? "COLOR_POSITIVE_TEXT" : "COLOR_NEGATIVE_TEXT"), gDLL->getText("TXT_KEY_MISC_ATTITUDE_MEMORY", iAttitudeChange, GC.getMemoryInfo((MemoryTypes)iI).getDescription()).GetCString());
				szBuffer.append(NEWLINE);
				szBuffer.append(szTempBuffer);
			}
		}
	}

	int iWarWeariness = GET_PLAYER(eTargetPlayer).getModifiedWarWearinessPercentAnger(GET_TEAM(GET_PLAYER(eTargetPlayer).getTeam()).getWarWeariness(eTeam) * std::max(0, 100 + kTeam.getEnemyWarWearinessModifier()));
	if (iWarWeariness / 10000 > 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_WAR_WEAR_HELP", iWarWeariness / 10000));
	}
}

void CvGameTextMgr::getEspionageString(CvWStringBuffer& szBuffer, PlayerTypes ePlayer, PlayerTypes eTargetPlayer)
{
	if (!GC.getGame().isOption(GAMEOPTION_NO_ESPIONAGE))
	{
		CvPlayer& kPlayer = GET_PLAYER(ePlayer);
		TeamTypes eTeam = (TeamTypes) kPlayer.getTeam();
		CvTeam& kTeam = GET_TEAM(eTeam);
		CvPlayer& kTargetPlayer = GET_PLAYER(eTargetPlayer);

		szBuffer.append(gDLL->getText("TXT_KEY_ESPIONAGE_AGAINST_PLAYER", kTargetPlayer.getNameKey(), kTeam.getEspionagePointsAgainstTeam(kTargetPlayer.getTeam()), GET_TEAM(kTargetPlayer.getTeam()).getEspionagePointsAgainstTeam(kPlayer.getTeam())));
	}
}

void CvGameTextMgr::getTradeString(CvWStringBuffer& szBuffer, const TradeData& tradeData, PlayerTypes ePlayer1, PlayerTypes ePlayer2)
{
	switch (tradeData.m_eItemType)
	{
	case TRADE_GOLD:
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_GOLD", tradeData.m_iData));
		break;
	case TRADE_GOLD_PER_TURN:
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_GOLD_PER_TURN", tradeData.m_iData));
		break;
	case TRADE_MAPS:
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_WORLD_MAP"));
		break;
	case TRADE_SURRENDER:
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_CAPITULATE"));
		break;
	case TRADE_VASSAL:
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_VASSAL"));
		break;
	case TRADE_OPEN_BORDERS:
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_OPEN_BORDERS"));
		break;
	case TRADE_DEFENSIVE_PACT:
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_DEFENSIVE_PACT"));
		break;
	case TRADE_PERMANENT_ALLIANCE:
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_PERMANENT_ALLIANCE"));
		break;
	case TRADE_PEACE_TREATY:
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_PEACE_TREATY", getTreatyLength()));
		break;
	case TRADE_TECHNOLOGIES:
		szBuffer.assign(CvWString::format(L"%s", GC.getTechInfo((TechTypes)tradeData.m_iData).getDescription()));
		break;
	case TRADE_RESOURCES:
		szBuffer.assign(CvWString::format(L"%s", GC.getBonusInfo((BonusTypes)tradeData.m_iData).getDescription()));
		break;
	case TRADE_CITIES:
		szBuffer.assign(CvWString::format(L"%s", GET_PLAYER(ePlayer1).getCity(tradeData.m_iData)->getName().GetCString()));
		break;
	case TRADE_PEACE:
	case TRADE_WAR:
	case TRADE_CONTACT:
	case TRADE_EMBARGO:
		szBuffer.assign(CvWString::format(L"%s", GET_TEAM((TeamTypes)tradeData.m_iData).getName().GetCString()));
		break;
	case TRADE_CIVIC:
		szBuffer.assign(CvWString::format(L"%s", GC.getCivicInfo((CivicTypes)tradeData.m_iData).getDescription()));
		break;
	case TRADE_RELIGION:
		szBuffer.assign(CvWString::format(L"%s", GC.getReligionInfo((ReligionTypes)tradeData.m_iData).getDescription()));
		break;
	case TRADE_WORKER:
	case TRADE_MILITARY_UNIT:
		szBuffer.assign(CvWString::format(L"%s", GET_PLAYER(ePlayer1).getUnit(tradeData.m_iData)->getName().GetCString()));
		break;
	case TRADE_EMBASSY:
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_EMBASSY"));
		break;
	case TRADE_CORPORATION:
		szBuffer.assign(CvWString::format(L"%s", GC.getCorporationInfo((CorporationTypes)tradeData.m_iData).getDescription()));
		break;
	case TRADE_SECRETARY_GENERAL_VOTE:
		szBuffer.assign(CvWString::format(L"%s", GC.getVoteSourceInfo((VoteSourceTypes)tradeData.m_iData).getDescription()));
		break;
	case TRADE_RITE_OF_PASSAGE:
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_LIMITED_BORDERS"));
		break;
	case TRADE_FREE_TRADE_ZONE:
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_FREE_TRADE_ZONE"));
		break;
	default:
		FAssert(false);
		break;
	}
}

void CvGameTextMgr::setFeatureHelp(CvWStringBuffer &szBuffer, FeatureTypes eFeature, bool bCivilopediaText)
{
	if (NO_FEATURE == eFeature)
	{
		return;
	}
	const CvFeatureInfo& feature = GC.getFeatureInfo(eFeature);

	int aiYields[NUM_YIELD_TYPES];
	if (!bCivilopediaText)
	{
		szBuffer.append(feature.getDescription());

		for (int iI = 0; iI < NUM_YIELD_TYPES; ++iI)
		{
			aiYields[iI] = feature.getYieldChange(iI);
		}
		setYieldChangeHelp(szBuffer, L"", L"", L"", aiYields);
	}
	for (int iI = 0; iI < NUM_YIELD_TYPES; ++iI)
	{
		aiYields[iI] = feature.getRiverYieldChange(iI);
	}
	setYieldChangeHelp(szBuffer, L"", L"", gDLL->getText("TXT_KEY_TERRAIN_NEXT_TO_RIVER"), aiYields);

	for (int iI = 0; iI < NUM_YIELD_TYPES; ++iI)
	{
		aiYields[iI] = feature.getHillsYieldChange(iI);
	}
	setYieldChangeHelp(szBuffer, L"", L"", gDLL->getText("TXT_KEY_TERRAIN_ON_HILLS"), aiYields);

	if (feature.getMovementCost() != 0)
	{
		szBuffer.append(gDLL->getText("TXT_KEY_TERRAIN_MOVEMENT_COST", feature.getMovementCost()));
	}

	CvWString szHealth;
	szHealth.Format(L"%.2f", 0.01f * abs(feature.getHealthPercent()));
	if (feature.getHealthPercent() > 0)
	{
		szBuffer.append(gDLL->getText("TXT_KEY_FEATURE_GOOD_HEALTH", szHealth.GetCString()));
	}
	else if (feature.getHealthPercent() < 0)
	{
		szBuffer.append(gDLL->getText("TXT_KEY_FEATURE_BAD_HEALTH", szHealth.GetCString()));
	}

	if (feature.getDefenseModifier() != 0)
	{
		szBuffer.append(gDLL->getText("TXT_KEY_TERRAIN_DEFENSE_MODIFIER", feature.getDefenseModifier()));
	}

	if (feature.isAddsFreshWater())
	{
		szBuffer.append(gDLL->getText("TXT_KEY_FEATURE_ADDS_FRESH_WATER"));
	}

	if (feature.isImpassable())
	{
		szBuffer.append(gDLL->getText("TXT_KEY_TERRAIN_IMPASSABLE"));
	}

	if (feature.isNoCity())
	{
		szBuffer.append(gDLL->getText("TXT_KEY_TERRAIN_NO_CITIES"));
	}

	if (feature.isNoImprovement())
	{
		szBuffer.append(gDLL->getText("TXT_KEY_FEATURE_NO_IMPROVEMENT"));
	}

	if (feature.getPopDestroys() == -1)
	{
		szBuffer.append(gDLL->getText("TXT_KEY_FEATURE_POP_NEVER_DESTROYED"));
	}

	if (feature.getPopDestroys() > -1 && feature.getPopDestroys() < 2)
	{
		szBuffer.append(gDLL->getText("TXT_KEY_FEATURE_POP_ALWAYS_DESTROYED"));
	}

	if (feature.getPopDestroys() > 1)
	{
		szBuffer.append(gDLL->getText("TXT_KEY_FEATURE_POP_DESTROYS", feature.getPopDestroys()));
	}

	const int iDamage = feature.getTurnDamage();
	if (iDamage > 0)
	{
		szBuffer.append(gDLL->getText("TXT_KEY_TERRAIN_TURN_DAMAGE", iDamage));
	}

	feature.getPropertyManipulators()->buildDisplayString(szBuffer);

	if (bCivilopediaText)
	{
		for (int iI = 0; iI < GC.getFeatureInfo(eFeature).getNumMapCategoryTypes(); iI++)
		{
			MapCategoryTypes eMapCategory = (MapCategoryTypes)GC.getFeatureInfo(eFeature).getMapCategoryType(iI);
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_MAP_CATEGORY_PREREQUISITE", GC.getMapCategoryInfo(eMapCategory).getTextKeyWide()));
		}
	}

}


void CvGameTextMgr::setTerrainHelp(CvWStringBuffer &szBuffer, TerrainTypes eTerrain, bool bCivilopediaText)
{
	if (NO_TERRAIN == eTerrain)
	{
		return;
	}
	const CvTerrainInfo& terrain = GC.getTerrainInfo(eTerrain);

	int aiYields[NUM_YIELD_TYPES];
	if (!bCivilopediaText)
	{
		szBuffer.append(terrain.getDescription());

		for (int iI = 0; iI < NUM_YIELD_TYPES; ++iI)
		{
			aiYields[iI] = terrain.getYield(iI);
		}
		setYieldChangeHelp(szBuffer, L"", L"", L"", aiYields);
	}
	for (int iI = 0; iI < NUM_YIELD_TYPES; ++iI)
	{
		aiYields[iI] = terrain.getRiverYieldChange(iI);
	}
	setYieldChangeHelp(szBuffer, L"", L"", gDLL->getText("TXT_KEY_TERRAIN_NEXT_TO_RIVER"), aiYields);

	for (int iI = 0; iI < NUM_YIELD_TYPES; ++iI)
	{
		aiYields[iI] = terrain.getHillsYieldChange(iI);
	}
	setYieldChangeHelp(szBuffer, L"", L"", gDLL->getText("TXT_KEY_TERRAIN_ON_HILLS"), aiYields);

	if (terrain.getMovementCost() != 0)
	{
		szBuffer.append(gDLL->getText("TXT_KEY_TERRAIN_MOVEMENT_COST", terrain.getMovementCost()));
	}

	if (terrain.getBuildModifier() != 0)
	{
		szBuffer.append(gDLL->getText("TXT_KEY_TERRAIN_BUILD_MODIFIER", terrain.getBuildModifier()));
	}

	if (terrain.getDefenseModifier() != 0)
	{
		szBuffer.append(gDLL->getText("TXT_KEY_TERRAIN_DEFENSE_MODIFIER", terrain.getDefenseModifier()));
	}

	if (terrain.isImpassable())
	{
		szBuffer.append(gDLL->getText("TXT_KEY_TERRAIN_IMPASSABLE"));
	}
	if (!terrain.isFound())
	{
		szBuffer.append(gDLL->getText("TXT_KEY_TERRAIN_NO_CITIES"));
		bool bFirst = true;
		if (terrain.isFoundCoast())
		{
			szBuffer.append(gDLL->getText("TXT_KEY_TERRAIN_COASTAL_CITIES"));
			bFirst = false;
		}
		if (!bFirst)
		{
			szBuffer.append(gDLL->getText("TXT_KEY_OR"));
		}
		if (terrain.isFoundFreshWater())
		{
			szBuffer.append(gDLL->getText("TXT_KEY_TERRAIN_FRESH_WATER_CITIES"));
			bFirst = false;
		}
	}

	if (GC.getGame().isModderGameOption(MODDERGAMEOPTION_TERRAIN_DAMAGE))
	{
		const int iDamage = -terrain.getHealthPercent();
		if (iDamage != 0)
		{
			szBuffer.append(gDLL->getText("TXT_KEY_TERRAIN_TURN_DAMAGE", iDamage));
		}
	}

	terrain.getPropertyManipulators()->buildDisplayString(szBuffer);

	if (bCivilopediaText)
	{
		for (int iI = 0; iI < terrain.getNumMapCategoryTypes(); iI++)
		{
			MapCategoryTypes eMapCategory = (MapCategoryTypes)terrain.getMapCategoryType(iI);
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_MAP_CATEGORY_TERRAIN", GC.getMapCategoryInfo(eMapCategory).getTextKeyWide()));
		}
	}
}

// BUG - Finance Advisor - start
void CvGameTextMgr::buildFinanceSpecialistGoldString(CvWStringBuffer& szBuffer, PlayerTypes ePlayer)
{
	if (NO_PLAYER == ePlayer)
	{
		return;
	}
	CvPlayer& player = GET_PLAYER(ePlayer);

	int* iCounts = new int[GC.getNumSpecialistInfos()];
	for (int iI = 0; iI < GC.getNumSpecialistInfos(); iI++)
	{
		iCounts[iI] = 0;
	}
	int iTotalSpecialists = 0;
	foreach_(const CvCity* pCity, player.cities())
	{
		int iCityGold = 0;
		if (!pCity->isDisorder())
		{
			for (int iI = 0; iI < GC.getNumSpecialistInfos(); iI++)
			{
				iCounts[iI] += pCity->getSpecialistCount((SpecialistTypes)iI) + pCity->getFreeSpecialistCount((SpecialistTypes)iI);

				iCityGold += ((pCity->getSpecialistCount((SpecialistTypes)iI) + pCity->getFreeSpecialistCount((SpecialistTypes)iI))*player.specialistCommerceTimes100((SpecialistTypes)iI, COMMERCE_GOLD))/100;
			}

			iTotalSpecialists += pCity->getSpecialistPopulation() + pCity->getNumGreatPeople();
		}
	}

	bool bFirst = true;
	int iTotal = 0;
	for (int iI = 0; iI < GC.getNumSpecialistInfos(); iI++)
	{
		int iGold = (iCounts[iI] * player.specialistCommerceTimes100((SpecialistTypes)iI, COMMERCE_GOLD));
		if (iGold != 0)
		{
			if (bFirst)
			{
				szBuffer.append(NEWLINE);
				bFirst = false;
			}

			CvWString buf;

			buf.Format(L"%d.%02d",iGold/100, iGold%100);
			szBuffer.append(gDLL->getText("TXT_KEY_BUG_FINANCIAL_ADVISOR_SPECIALIST_GOLD", buf.GetCString(), iCounts[iI], GC.getSpecialistInfo((SpecialistTypes)iI).getDescription()));
			iTotal += iGold;
		}
	}

	szBuffer.append(gDLL->getText("TXT_KEY_BUG_FINANCIAL_ADVISOR_SPECIALIST_TOTAL_GOLD", iTotal/100));
	SAFE_DELETE_ARRAY(iCounts);
}
// BUG - Finance Advisor - end

void CvGameTextMgr::buildFinanceInflationString(CvWStringBuffer& szBuffer, PlayerTypes ePlayer)
{
	if (NO_PLAYER == ePlayer)
	{
		return;
	}
	CvPlayer& kPlayer = GET_PLAYER(ePlayer);

	const int iInflationRate = kPlayer.calculateInflationRate();
	if (iInflationRate != 0)
	{
		int64_t iPreInflation = kPlayer.calculatePreInflatedCosts();
		szBuffer.append(NEWLINE);

		const int iCurrentInflationModifier = kPlayer.getCurrentInflationCostModifier();
		const int iEquilibriumInflationModifier = kPlayer.getEquilibriumInflationCostModifier();
		CvWString szInflationOutlook;

		if (iCurrentInflationModifier > iEquilibriumInflationModifier)
		{
			if (iCurrentInflationModifier * 9/10 > iEquilibriumInflationModifier)
			{
				szInflationOutlook = gDLL->getText("TXT_KEY_INFLATION_OUTLOOK_IMPROVING");
			}
			else szInflationOutlook = gDLL->getText("TXT_KEY_INFLATION_OUTLOOK_STABLE");
		}
		else if (iEquilibriumInflationModifier * 9/10 > iCurrentInflationModifier)
		{
			szInflationOutlook = gDLL->getText("TXT_KEY_INFLATION_OUTLOOK_WORSENING");
		}
		else szInflationOutlook = gDLL->getText("TXT_KEY_INFLATION_OUTLOOK_STABLE");

		szBuffer.append(gDLL->getText("TXT_KEY_FINANCE_ADVISOR_INFLATION_NEW", iPreInflation, iInflationRate, iInflationRate, iPreInflation, (iPreInflation * iInflationRate) / 100, szInflationOutlook.c_str()));

		if (GC.getGame().isOption(GAMEOPTION_ADVANCED_ECONOMY))
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_FINANCE_ADVISOR_SOURCES_OF_INFLATION", kPlayer.getCivicInflation(), kPlayer.getTechInflation(), kPlayer.getBuildingInflation(), kPlayer.getProjectInflation(), kPlayer.getHurriedCount()));
		}
	}
}

void CvGameTextMgr::buildFinanceUnitUpkeepString(CvWStringBuffer& szBuffer, PlayerTypes ePlayer)
{
	if (NO_PLAYER == ePlayer)
	{
		return;
	}
	const CvPlayer& player = GET_PLAYER(ePlayer);

	int iCivicModCivilian = 0;
	int iCivicModMilitary = 0;
	for (int iI = 0; iI < GC.getNumCivicOptionInfos(); ++iI)
	{
		const CivicTypes eCivic = player.getCivics((CivicOptionTypes)iI);
		if (NO_CIVIC != eCivic)
		{
			iCivicModCivilian += GC.getCivicInfo(eCivic).getCivilianUnitUpkeepMod();
			iCivicModMilitary += GC.getCivicInfo(eCivic).getMilitaryUnitUpkeepMod();
		}
	}

	int iTraitModCivilian = 0;
	int iTraitModMilitary = 0;
	for (int iI = 0; iI < GC.getNumTraitInfos(); iI++)
	{
		const TraitTypes eTrait = (TraitTypes) iI;
		if (player.hasTrait(eTrait))
		{
			iTraitModCivilian += GC.getTraitInfo(eTrait).getCivilianUnitUpkeepMod();
			iTraitModMilitary += GC.getTraitInfo(eTrait).getMilitaryUnitUpkeepMod();
		}
	}

	// Civilian section
	const int64_t iUpkeepCivilian100 = player.getUnitUpkeepCivilian100();

	szBuffer.append(gDLL->getText("TXT_KEY_FINANCE_ADVISOR_UNIT_UPKEEP_CIVILIAN", CvWString::format(L"%.2f", iUpkeepCivilian100 / 100.0).GetCString()));

	if (iCivicModCivilian != 0)
	{
		int64_t iCivicCivilian = 0;
		if (iCivicModCivilian > 0)
		{
			iCivicCivilian = iUpkeepCivilian100 * (100 + iCivicModCivilian) / 100 - iUpkeepCivilian100;
		}
		else if (iCivicModCivilian < 0)
		{
			iCivicCivilian = iUpkeepCivilian100 * 100 / (100 - iCivicModCivilian) - iUpkeepCivilian100;
		}

		if (iCivicCivilian != 0)
		{
			szBuffer.append(gDLL->getText("TXT_KEY_FINANCE_ADVISOR_UNIT_UPKEEP_MOD_CIVIC", CvWString::format(L"%.2f", iCivicCivilian / 100.0).GetCString()));
		}
	}
	if (iTraitModCivilian != 0)
	{
		int64_t iTraitCivilian = 0;
		if (iTraitModCivilian > 0)
		{
			iTraitCivilian = iUpkeepCivilian100 * (100 + iTraitModCivilian) / 100 - iUpkeepCivilian100;
		}
		else if (iTraitModCivilian < 0)
		{
			iTraitCivilian = iUpkeepCivilian100 * 100 / (100 - iTraitModCivilian) - iUpkeepCivilian100;
		}

		if (iTraitCivilian != 0)
		{
			szBuffer.append(gDLL->getText("TXT_KEY_FINANCE_ADVISOR_UNIT_UPKEEP_MOD_TRAIT", CvWString::format(L"%.2f", iTraitCivilian / 100.0).GetCString()));
		}
	}
	szBuffer.append(gDLL->getText("TXT_KEY_FINANCE_ADVISOR_UNIT_UPKEEP_FREE", player.getFreeUnitUpkeepCivilian()));

	const int64_t iUpkeepCivilianNet = player.getUnitUpkeepCivilianNet();

	szBuffer.append(gDLL->getText("TXT_KEY_FINANCE_ADVISOR_UNIT_UPKEEP_TOTAL_1", iUpkeepCivilianNet));

	// Military section
	szBuffer.append(NEWLINE);
	const int64_t iUpkeepMilitary100 = player.getUnitUpkeepMilitary100();

	szBuffer.append(gDLL->getText("TXT_KEY_FINANCE_ADVISOR_UNIT_UPKEEP_MILITARY", CvWString::format(L"%.2f", iUpkeepMilitary100 / 100.0).GetCString()));

	if (iCivicModMilitary != 0)
	{
		int64_t iCivicMilitary = 0;
		if (iCivicModMilitary > 0)
		{
			iCivicMilitary = iUpkeepMilitary100 * (100 + iCivicModMilitary) / 100 - iUpkeepMilitary100;
		}
		else if (iCivicModMilitary < 0)
		{
			iCivicMilitary = iUpkeepMilitary100 * 100 / (100 - iCivicModMilitary) - iUpkeepMilitary100;
		}

		if (iCivicMilitary != 0)
		{
			szBuffer.append(gDLL->getText("TXT_KEY_FINANCE_ADVISOR_UNIT_UPKEEP_MOD_CIVIC", CvWString::format(L"%.2f", iCivicMilitary / 100.0).GetCString()));
		}
	}
	if (iTraitModMilitary != 0)
	{
		int64_t iTraitMilitary = 0;
		if (iTraitModMilitary > 0)
		{
			iTraitMilitary = iUpkeepMilitary100 * (100 + iTraitModMilitary) / 100 - iUpkeepMilitary100;
		}
		else if (iTraitModMilitary < 0)
		{
			iTraitMilitary = iUpkeepMilitary100 * 100 / (100 - iTraitModMilitary) - iUpkeepMilitary100;
		}

		if (iTraitMilitary != 0)
		{
			szBuffer.append(gDLL->getText("TXT_KEY_FINANCE_ADVISOR_UNIT_UPKEEP_MOD_TRAIT", CvWString::format(L"%.2f", iTraitMilitary / 100.0).GetCString()));
		}
	}
	szBuffer.append(gDLL->getText("TXT_KEY_FINANCE_ADVISOR_UNIT_UPKEEP_FREE", player.getFreeUnitUpkeepMilitary()));

	const int64_t iUnitUpkeepMilitaryNet = player.getUnitUpkeepMilitaryNet();

	szBuffer.append(gDLL->getText("TXT_KEY_FINANCE_ADVISOR_UNIT_UPKEEP_TOTAL_1", iUnitUpkeepMilitaryNet));

	// End Section
	const int64_t iHandicap = player.getFinalUnitUpkeep() - iUpkeepCivilianNet - iUnitUpkeepMilitaryNet;
	if (iHandicap != 0)
	{
		szBuffer.append(gDLL->getText("TXT_KEY_FINANCE_ADVISOR_UNIT_UPKEEP_HANDICAP_ADJUSTMENT", iHandicap));
	}
	szBuffer.append(gDLL->getText("TXT_KEY_FINANCE_ADVISOR_UNIT_UPKEEP_TOTAL_2", player.getFinalUnitUpkeep()));
}

void CvGameTextMgr::buildFinanceAwaySupplyString(CvWStringBuffer& szBuffer, PlayerTypes ePlayer)
{
	if (NO_PLAYER == ePlayer)
	{
		return;
	}
	CvPlayer& player = GET_PLAYER(ePlayer);

	int iPaidUnits = 0;
	int iBaseCost = 0;
	int iCost = player.calculateUnitSupply(iPaidUnits, iBaseCost);
	int iHandicap = iCost - iBaseCost;

	CvWString szHandicap;
	if (iHandicap != 0)
	{
		szHandicap = gDLL->getText("TXT_KEY_FINANCE_ADVISOR_HANDICAP_COST", iHandicap);
	}

	szBuffer.append(NEWLINE);
	szBuffer.append(gDLL->getText("TXT_KEY_FINANCE_ADVISOR_SUPPLY_COST", iPaidUnits, GC.getDefineINT("INITIAL_FREE_OUTSIDE_UNITS"), iBaseCost, szHandicap.GetCString(), iCost));
}

void CvGameTextMgr::buildFinanceCityMaintString(CvWStringBuffer& szBuffer, PlayerTypes ePlayer)
{
	if (NO_PLAYER == ePlayer)
	{
		return;
	}
	int iBaseMaint = 0;
	int iDistanceMaint = 0;
	int iNumCityMaint = 0;
	int iColonyMaint = 0;
	int iCorporationMaint = 0;
	int iBuildingMaint = 0;

	const CvPlayer& player = GET_PLAYER(ePlayer);

	const int iBase = std::max(0, GC.getEraInfo(player.getCurrentEra()).getInitialCityMaintenancePercent());

	const bool bRebel = player.isRebel();

	foreach_(const CvCity* pLoopCity, player.cities())
	{
		iBaseMaint += iBase;

		if (!pLoopCity->isDisorder() && !pLoopCity->isWeLoveTheKingDay() && (pLoopCity->getPopulation() > 0))
		{
			iDistanceMaint += pLoopCity->calculateDistanceMaintenanceTimes100() * std::max(0, (pLoopCity->getEffectiveMaintenanceModifier() + 100)) / 100;
			iNumCityMaint += pLoopCity->calculateNumCitiesMaintenanceTimes100() * std::max(0, (pLoopCity->getEffectiveMaintenanceModifier() + 100)) / 100;
			iColonyMaint += pLoopCity->calculateColonyMaintenanceTimes100() * std::max(0, (pLoopCity->getEffectiveMaintenanceModifier() + 100)) / 100;
			iCorporationMaint += pLoopCity->calculateCorporationMaintenanceTimes100() * std::max(0, (pLoopCity->getEffectiveMaintenanceModifier() + 100)) / 100;
			iBuildingMaint += pLoopCity->calculateBuildingMaintenanceTimes100() * std::max(0, (pLoopCity->getEffectiveMaintenanceModifier() + 100)) / 100;

			if (bRebel)
			{
				iDistanceMaint /= 2;
				iNumCityMaint /= 2;
				iColonyMaint /= 2;
				iCorporationMaint /= 2;
				iBuildingMaint /= 2;
			}
		}
		if (bRebel)
		{
			iBaseMaint /= 2;
		}
	}

	if (iBaseMaint != 0)
	{
		CvWString szMaint = CvWString::format(L"%d.%02d", iBaseMaint/100, iBaseMaint%100);
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_BASE_MAINTENANCE", szMaint.GetCString()));
	}
	if (iDistanceMaint != 0)
	{
		CvWString szMaint = CvWString::format(L"%d.%02d", iDistanceMaint/100, iDistanceMaint%100);
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_FINANCE_ADVISOR_CITY_MAINT_COST_DISTANCE", szMaint.GetCString()));
	}
	if (iNumCityMaint != 0)
	{
		CvWString szMaint = CvWString::format(L"%d.%02d", iNumCityMaint/100, iNumCityMaint%100);
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_NUM_CITIES_FLOAT", szMaint.GetCString()));
	}
	if (iColonyMaint != 0)
	{
		CvWString szMaint = CvWString::format(L"%d.%02d", iColonyMaint/100, iColonyMaint%100);
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_COLONY_MAINT_FLOAT", szMaint.GetCString()));
	}
	if (iCorporationMaint != 0)
	{
		CvWString szMaint = CvWString::format(L"%d.%02d", iCorporationMaint/100, iCorporationMaint%100);
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_CORPORATION_MAINT_FLOAT", szMaint.GetCString()));
	}
	if (iBuildingMaint != 0)
	{
		CvWString szMaint = CvWString::format(L"%d.%02d", iBuildingMaint/100, iBuildingMaint%100);
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_BUILDING_MAINT_FLOAT", szMaint.GetCString()));
	}
	const int iTotal = player.getTotalMaintenance();
	if (iTotal != 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_FINANCE_ADVISOR_CITY_MAINT_COST_TOTAL", iTotal));
	}
}

void CvGameTextMgr::buildFinanceCivicUpkeepString(CvWStringBuffer& szBuffer, PlayerTypes ePlayer)
{
	if (NO_PLAYER == ePlayer)
	{
		return;
	}
	CvPlayer& player = GET_PLAYER(ePlayer);
	CvWString szCivicOptionCosts;
	for (int iI = 0; iI < GC.getNumCivicOptionInfos(); ++iI)
	{
		CivicTypes eCivic = player.getCivics((CivicOptionTypes)iI);
		if (NO_CIVIC != eCivic)
		{
			CvWString szTemp;
			szTemp.Format(L"%d%c: %s", player.getSingleCivicUpkeep(eCivic), GC.getCommerceInfo(COMMERCE_GOLD).getChar(),  GC.getCivicInfo(eCivic).getDescription());
			szCivicOptionCosts += NEWLINE + szTemp;
		}
	}

	szBuffer.append(NEWLINE);
	szBuffer.append(gDLL->getText("TXT_KEY_FINANCE_ADVISOR_CIVIC_UPKEEP_COST", szCivicOptionCosts.GetCString(), player.getCivicUpkeep()));
}

void CvGameTextMgr::buildFinanceForeignIncomeString(CvWStringBuffer& szBuffer, PlayerTypes ePlayer)
{
	if (NO_PLAYER == ePlayer)
	{
		return;
	}
	CvPlayer& player = GET_PLAYER(ePlayer);

	CvWString szPlayerIncome;
	for (int iI = 0; iI < MAX_PLAYERS; iI++)
	{
		CvPlayer& otherPlayer = GET_PLAYER((PlayerTypes)iI);
		if (otherPlayer.isAlive() && player.getGoldPerTurnByPlayer((PlayerTypes)iI) != 0)
		{
			CvWString szTemp;
			szTemp.Format(L"%d%c: %s", player.getGoldPerTurnByPlayer((PlayerTypes)iI), GC.getCommerceInfo(COMMERCE_GOLD).getChar(), otherPlayer.getCivilizationShortDescription());
			szPlayerIncome += NEWLINE + szTemp;
		}
	}
	if (!szPlayerIncome.empty())
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_FINANCE_ADVISOR_FOREIGN_INCOME", szPlayerIncome.GetCString(), player.getGoldPerTurn()));
	}
}

// BUG - Food Rate Hover - start

/*
	+14 from Worked Tiles
	+2 from Specialists
	+5 from Corporations
	+1 from Buildings
	----------------------- |
	Base Food Produced: 22  |-- only if there are modifiers
	+25% from Buildings	 |
	-----------------------
	Total Food Produced: 27
	=======================
	+16 for Population
	+2 for Health
	-----------------------
	Total Food Consumed: 18
	=======================
	Net Food: +9			or
	Net Food for Settler: 9
	=======================
	* Lighthouse: +3
	* Supermarket: +1
*/
void CvGameTextMgr::setFoodHelp(CvWStringBuffer &szBuffer, CvCity& city)
{
	FAssertMsg(NO_PLAYER != city.getOwner(), "City must have an owner");

	const CvYieldInfo& info = GC.getYieldInfo(YIELD_FOOD);
	bool bNeedSubtotal = false;
	int iBaseRate = 0;
	int i;

	// Worked Tiles
	int iTileFood = 0;
	for (i = 0; i < NUM_CITY_PLOTS; i++)
	{
		if (city.isWorkingPlot(i))
		{
			const CvPlot* pPlot = city.getCityIndexPlot(i);

			if (pPlot != NULL)
			{
				iTileFood += pPlot->getYield(YIELD_FOOD);
			}
		}
	}
	if (iTileFood != 0)
	{
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_HELP_WORKED_TILES_YIELD", iTileFood, info.getChar()));
		iBaseRate += iTileFood;
	}

	// Trade
	int iTradeFood = city.getTradeYield(YIELD_FOOD);
	if (iTradeFood != 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_HELP_SPECIALIST_COMMERCE", iTradeFood, info.getChar(), L"TXT_KEY_HEADING_TRADEROUTE_LIST"));
		iBaseRate += iTradeFood;
		bNeedSubtotal = true;
	}

	// Specialists
	int iSpecialistFood = 0;
	for (i = 0; i < GC.getNumSpecialistInfos(); i++)
	{
		iSpecialistFood += city.specialistYieldTotal((SpecialistTypes)i, YIELD_FOOD);
	}
	if (iSpecialistFood != 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_HELP_SPECIALIST_COMMERCE", iSpecialistFood, info.getChar(), L"TXT_KEY_CONCEPT_SPECIALISTS"));
		iBaseRate += iSpecialistFood;
		bNeedSubtotal = true;
	}

	// Corporations
	int iCorporationFood = city.getCorporationYield(YIELD_FOOD);
	if (iCorporationFood != 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_HELP_CORPORATION_COMMERCE", iCorporationFood, info.getChar()));
		iBaseRate += iCorporationFood;
		bNeedSubtotal = true;
	}

	// Traits
	for (i = 0; i < GC.getNumTraitInfos(); i++)
	{
		TraitTypes eTrait = ((TraitTypes)i);
		if (GET_PLAYER(city.getOwner()).hasTrait(eTrait))
		{
			int iTraitFood = GC.getTraitInfo(eTrait).getYieldChange(YIELD_FOOD);
			if (iTraitFood != 0)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_MISC_HELP_TRAIT_COMMERCE", iTraitFood, info.getChar(), GC.getTraitInfo(eTrait).getDescription()));
				iBaseRate += iTraitFood;
				bNeedSubtotal = true;
			}
		}
	}

	// Buildings
	int iBuildingFood = 0;
	for (i = 0; i < GC.getNumBuildingInfos(); i++)
	{
		const int iCount = city.getNumActiveBuilding((BuildingTypes)i);
		if (iCount > 0)
		{
			const CvBuildingInfo& kBuilding = GC.getBuildingInfo((BuildingTypes)i);
			//Team Project (5)
			if (!city.isReligiouslyDisabledBuilding((BuildingTypes)i))
			{
				iBuildingFood += iCount * (kBuilding.getYieldChange(YIELD_FOOD) + ((kBuilding.getYieldPerPopChange(YIELD_FOOD)*city.getPopulation())/100) + city.getBuildingYieldChange((BuildingTypes)i, YIELD_FOOD) + GET_TEAM(city.getTeam()).getBuildingYieldModifier((BuildingTypes)i, YIELD_FOOD));
			}
		}
	}
	if (iBuildingFood != 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_HELP_BUILDING_COMMERCE", iBuildingFood, info.getChar()));
		iBaseRate += iBuildingFood;
		bNeedSubtotal = true;
	}

	// Base and modifiers (only if there are modifiers since total is always shown)
	if (city.getBaseYieldRateModifier(YIELD_FOOD) != 100)
	{
		szBuffer.append(SEPARATOR);
		szBuffer.append(NEWLINE);
		// shows Base Food and lists all modifiers
		setYieldHelp(szBuffer, city, YIELD_FOOD);
	}
	else
	{
		szBuffer.append(NEWLINE);
	}

	// Total Produced
	int iBaseModifier = city.getBaseYieldRateModifier(YIELD_FOOD);
	int iRate = iBaseModifier * iBaseRate / 100;
	szBuffer.append(gDLL->getText("TXT_KEY_MISC_HELP_TOTAL_FOOD_PRODUCED", iRate));

	// ==========================
	szBuffer.append(DOUBLE_SEPARATOR);

	int iFoodConsumed = 0;

	// Eaten
	int iEatenFood = city.getFoodConsumedByPopulation();
	if (iEatenFood != 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_HELP_EATEN_FOOD", iEatenFood));
		iFoodConsumed += iEatenFood;
	}

	// Wasted
	int iWastedFood = (int)city.foodWastage();
	if (iWastedFood != 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_HELP_WASTED_FOOD", iWastedFood));
		iFoodConsumed += iWastedFood;
	}

	// Health
	int iSpoiledFood = - city.healthRate();
	if (iSpoiledFood != 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_HELP_SPOILED_FOOD", iSpoiledFood));
		iFoodConsumed += iSpoiledFood;
	}

	// Total Consumed
	szBuffer.append(NEWLINE);
	szBuffer.append(gDLL->getText("TXT_KEY_MISC_HELP_TOTAL_FOOD_CONSUMED", iFoodConsumed));

	// ==========================
	szBuffer.append(DOUBLE_SEPARATOR NEWLINE);
	iRate -= iFoodConsumed;

	// Production
	if (city.isFoodProduction() && iRate > 0)
	{
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_HELP_NET_FOOD_PRODUCTION", iRate, city.getProductionNameKey()));
	}
	else
	{
		// cannot starve a size 1 city with no food in
		if (iRate < 0 && city.getPopulation() == 1 && city.getFood() == 0)
		{
			iRate = 0;
		}

		// Net Food
		if (iRate > 0)
		{
			szBuffer.append(gDLL->getText("TXT_KEY_MISC_HELP_NET_FOOD_GROW", iRate));
		}
		else if (iRate < 0)
		{
			szBuffer.append(gDLL->getText("TXT_KEY_MISC_HELP_NET_FOOD_SHRINK", iRate));
		}
		else
		{
			szBuffer.append(gDLL->getText("TXT_KEY_MISC_HELP_NET_FOOD_STAGNATE"));
		}
	}

	// ==========================

// BUG - Building Additional Food - start
	if (city.getOwner() == GC.getGame().getActivePlayer() && getBugOptionBOOL("MiscHover__BuildingAdditionalFood", true, "BUG_BUILDING_ADDITIONAL_FOOD_HOVER"))
	{
		setBuildingAdditionalYieldHelp(szBuffer, city, YIELD_FOOD, DOUBLE_SEPARATOR);
	}
// BUG - Building Additional Food - end
}
// BUG - Food Rate Hover - end

// BUG - Building Additional Yield - start
bool CvGameTextMgr::setBuildingAdditionalYieldHelp(CvWStringBuffer &szBuffer, CvCity& city, YieldTypes eIndex, const CvWString& szStart, bool bStarted)
{
	const CvYieldInfo& info = GC.getYieldInfo(eIndex);

	for (int i = 0; i < GC.getNumBuildingInfos(); i++)
	{
		const BuildingTypes eBuilding = static_cast<BuildingTypes>(i);

		if (city.canConstruct(eBuilding, false, false, false))
		{
			const int iChange = city.getAdditionalYieldByBuilding(eIndex, eBuilding);

			if (iChange != 0)
			{
				if (!bStarted)
				{
					szBuffer.append(szStart);
					bStarted = true;
				}

				CvWString szLabel;
				szLabel.Format(SETCOLR L"%s" ENDCOLR, TEXT_COLOR("COLOR_BUILDING_TEXT"), GC.getBuildingInfo(eBuilding).getDescription());
				setResumableValueChangeHelp(szBuffer, szLabel, L": ", L"", iChange, info.getChar(), false, true);
			}
		}
	}

	return bStarted;
}
// BUG - Building Additional Yield - end

// BUG - Building Additional Commerce - start
bool CvGameTextMgr::setBuildingAdditionalCommerceHelp(CvWStringBuffer &szBuffer, CvCity& city, CommerceTypes eIndex, const CvWString& szStart, bool bStarted)
{
	const CvCommerceInfo& info = GC.getCommerceInfo(eIndex);

	for (int i = 0; i < GC.getNumBuildingInfos(); i++)
	{
		const BuildingTypes eBuilding = static_cast<BuildingTypes>(i);

		if (city.canConstruct(eBuilding, false, false, false))
		{
			int iChange = city.getAdditionalCommerceTimes100ByBuilding(eIndex, eBuilding);
			const int iCommerce = city.getAdditionalYieldByBuilding(YIELD_COMMERCE, eBuilding);
			iChange += iCommerce * GET_PLAYER(city.getOwner()).getCommercePercent(eIndex);

			if (iChange != 0)
			{
				if (!bStarted)
				{
					szBuffer.append(szStart);
					bStarted = true;
				}

				CvWString szLabel;
				szLabel.Format(SETCOLR L"%s" ENDCOLR, TEXT_COLOR("COLOR_BUILDING_TEXT"), GC.getBuildingInfo(eBuilding).getDescription());
				setResumableValueTimes100ChangeHelp(szBuffer, szLabel, L": ", L"", iChange, info.getChar(), true);
			}
		}
	}
	// BUG jdog5000 - need to verify building type is correct for this player to avoid asserts - end

	return bStarted;
}
// BUG - Building Additional Commerce - end

// BUG - Building Saved Maintenance - start
bool CvGameTextMgr::setBuildingSavedMaintenanceHelp(CvWStringBuffer &szBuffer, const CvCity& city, const CvWString& szStart, bool bStarted)
{
	const CvCommerceInfo& info = GC.getCommerceInfo(COMMERCE_GOLD);

	for (int i = 0; i < GC.getNumBuildingInfos(); i++)
	{
		const BuildingTypes eBuilding = static_cast<BuildingTypes>(i);

		if (city.canConstruct(eBuilding, false, false, false))
		{
			const int iChange = -city.getSavedMaintenanceTimes100ByBuilding(eBuilding); //Afforess: saved maintenance is displayed as negative in hover

			if (iChange != 0)
			{
				if (!bStarted)
				{
					szBuffer.append(szStart);
					bStarted = true;
				}

				CvWString szLabel;
				szLabel.Format(SETCOLR L"%s" ENDCOLR, TEXT_COLOR("COLOR_BUILDING_TEXT"), GC.getBuildingInfo(eBuilding).getDescription());
				setResumableValueTimes100ChangeHelp(szBuffer, szLabel, L": ", L"", iChange, info.getChar(), true);
			}
		}
	}

	return bStarted;
}
// BUG - Building Saved Maintenance - end

void CvGameTextMgr::setProductionHelp(CvWStringBuffer &szBuffer, CvCity& city)
{
	FAssertMsg(NO_PLAYER != city.getOwner(), "City must have an owner");

	const bool bIsProcess = city.isProductionProcess();
	const int iPastOverflow = (bIsProcess ? 0 : city.getOverflowProduction());
	if (iPastOverflow != 0)
	{
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_HELP_PROD_OVERFLOW", iPastOverflow));
		szBuffer.append(NEWLINE);
	}

	const int iFromChops = (city.isProductionProcess() ? 0 : city.getFeatureProduction());
	if (iFromChops != 0)
	{
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_HELP_PROD_CHOPS", iFromChops));
		szBuffer.append(NEWLINE);
	}

	const bool bBuildingAdditionalYield = getBugOptionBOOL("MiscHover__BuildingAdditionalProduction", true, "BUG_BUILDING_ADDITIONAL_PRODUCTION_HOVER");
	if (city.getCurrentProductionDifference(ProductionCalc::FoodProduction | ProductionCalc::Overflow) == 0 && !bBuildingAdditionalYield)
	{
		return;
	}

	setYieldHelp(szBuffer, city, YIELD_PRODUCTION);

	const CvPlayer& owner = GET_PLAYER(city.getOwner());

	const int iBaseProduction = city.getModifiedBaseYieldRate(YIELD_PRODUCTION) + iPastOverflow + iFromChops;
	int iBaseModifier = city.getBaseYieldRateModifier(YIELD_PRODUCTION);
	int iMod;

	UnitTypes eUnit = city.getProductionUnit();
	if (NO_UNIT != eUnit)
	{
		const CvUnitInfo& unit = GC.getUnitInfo(eUnit);
		// Trait
		for (int iI = 0; iI < GC.getNumTraitInfos(); ++iI)
		{
			if (owner.hasTrait((TraitTypes)iI))
			{
				CvTraitInfo& kTrait = GC.getTraitInfo((TraitTypes)iI);
				iMod = 0;
				for (int iJ = 0; iJ < kTrait.getNumUnitProductionModifiers(); iJ++)
				{
					if ((UnitTypes)kTrait.getUnitProductionModifier(iJ).eUnit == eUnit)
					{
						iMod += kTrait.getUnitProductionModifier(iJ).iModifier;
						break;
					}
				}
				if (unit.getSpecialUnitType() != NO_SPECIALUNIT)
				{
					for (int iJ = 0; iJ < kTrait.getNumSpecialUnitProductionModifiers(); iJ++)
					{
						if ((SpecialUnitTypes)kTrait.getSpecialUnitProductionModifier(iJ).eSpecialUnit == unit.getSpecialUnitType())
						{
							iMod += kTrait.getSpecialUnitProductionModifier(iJ).iModifier;
							break;
						}
					}
				}
				if (iMod == 100)
				{
					szBuffer.append(NEWLINE);
					szBuffer.append(gDLL->getText("TXT_KEY_DOUBLE_SPEED_TRAIT", kTrait.getTextKeyWide()));
					iBaseModifier += 100;
				}
				else if (iMod != 0)
				{
					szBuffer.append(NEWLINE);
					szBuffer.append(gDLL->getText("TXT_KEY_PRODUCTION_MODIFIER_TRAIT", iMod, kTrait.getTextKeyWide()));
					iBaseModifier += iMod;
				}
			}
		}
		// City and National
		iMod = city.getUnitProductionModifier(eUnit) + owner.getUnitProductionModifier(eUnit);
		if (0 != iMod)
		{
			szBuffer.append(gDLL->getText("TXT_KEY_MISC_HELP_PROD_MOD_FROM", iMod, unit.getTextKeyWide()));
			szBuffer.append(NEWLINE);
			iBaseModifier += iMod;
		}
		if (!unit.isNoNonTypeProdMods())
		{
			// Domain
			iMod = city.getDomainProductionModifier((DomainTypes)unit.getDomainType());
			if (0 != iMod)
			{
				szBuffer.append(gDLL->getText("TXT_KEY_MISC_HELP_PROD_MOD_FROM", iMod, GC.getDomainInfo((DomainTypes)unit.getDomainType()).getTextKeyWide()));
				szBuffer.append(NEWLINE);
				iBaseModifier += iMod;
			}
			// Unit Combat
			if (unit.getUnitCombatType() != NO_UNITCOMBAT)
			{
				iMod = owner.getUnitCombatProductionModifier((UnitCombatTypes)unit.getUnitCombatType()) + city.getUnitCombatProductionModifier((UnitCombatTypes)unit.getUnitCombatType());
				if (0 != iMod)
				{
					szBuffer.append(gDLL->getText("TXT_KEY_MISC_HELP_PROD_MOD_FROM", iMod, GC.getUnitCombatInfo((UnitCombatTypes)unit.getUnitCombatType()).getDescription()));
					szBuffer.append(NEWLINE);
					iBaseModifier += iMod;
				}
				for (int iI = 0; iI < unit.getNumSubCombatTypes(); iI++)
				{
					iMod = owner.getUnitCombatProductionModifier((UnitCombatTypes)unit.getSubCombatType(iI)) + city.getUnitCombatProductionModifier((UnitCombatTypes)unit.getSubCombatType(iI));
					if (0 != iMod)
					{
						szBuffer.append(gDLL->getText("TXT_KEY_MISC_HELP_PROD_MOD_FROM", iMod, GC.getUnitCombatInfo((UnitCombatTypes)unit.getSubCombatType(iI)).getDescription()));
						szBuffer.append(NEWLINE);
						iBaseModifier += iMod;
					}
				}
			}
			// Military
			if (unit.isMilitaryProduction())
			{
				iMod = owner.getMilitaryProductionModifier() + city.getMilitaryProductionModifier();
				if (0 != iMod)
				{
					szBuffer.append(gDLL->getText("TXT_KEY_MISC_HELP_PROD_MILITARY", iMod));
					szBuffer.append(NEWLINE);
					iBaseModifier += iMod;
				}
			}
			// Religion
			if (NO_RELIGION != owner.getStateReligion() && city.isHasReligion(owner.getStateReligion()))
			{
				iMod = owner.getStateReligionUnitProductionModifier();
				if (0 != iMod)
				{
					szBuffer.append(gDLL->getText("TXT_KEY_MISC_HELP_PROD_RELIGION", iMod, GC.getReligionInfo(owner.getStateReligion()).getTextKeyWide()));
					szBuffer.append(NEWLINE);
					iBaseModifier += iMod;
				}
			}
		}
		// Bonus
		for (int iI = 0; iI < GC.getNumBonusInfos(); iI++)
		{
			if (city.hasBonus((BonusTypes)iI))
			{
				iMod = unit.getBonusProductionModifier(iI);
				if (0 != iMod)
				{
					szBuffer.append(gDLL->getText("TXT_KEY_MISC_HELP_PROD_MOD_BONUS", iMod, unit.getTextKeyWide(), GC.getBonusInfo((BonusTypes)iI).getTextKeyWide()));
					szBuffer.append(NEWLINE);
					iBaseModifier += iMod;
				}
			}
		}
	}

	const BuildingTypes eBuilding = city.getProductionBuilding();
	if (NO_BUILDING != eBuilding)
	{
		const CvBuildingInfo& building = GC.getBuildingInfo(eBuilding);

		// Bonus
		for (int i = 0; i < GC.getNumBonusInfos(); i++)
		{
			if (city.hasBonus((BonusTypes)i))
			{
				const int iBonusMod = building.getBonusProductionModifier(i);
				if (0 != iBonusMod)
				{
					szBuffer.append(gDLL->getText("TXT_KEY_MISC_HELP_PROD_MOD_BONUS", iBonusMod, building.getTextKeyWide(), GC.getBonusInfo((BonusTypes)i).getTextKeyWide()));
					szBuffer.append(NEWLINE);
					iBaseModifier += iBonusMod;
				}
			}
		}

		const int iBuildingMod = city.getBuildingProductionModifier(eBuilding) + owner.getBuildingProductionModifier(eBuilding);
		if (0 != iBuildingMod)
		{
			szBuffer.append(gDLL->getText("TXT_KEY_MISC_HELP_PROD_MOD_FROM", iBuildingMod, building.getTextKeyWide()));
			szBuffer.append(NEWLINE);
			iBaseModifier += iBuildingMod;
		}

		// Trait
		int iTraitMod = 0;
		for (int i = 0; i < GC.getNumTraitInfos(); i++)
		{
			iTraitMod = 0;
			const TraitTypes eTrait = static_cast<TraitTypes>(i);
			if (city.hasTrait(eTrait))
			{
				for (int j = 0; j < GC.getTraitInfo(eTrait).getNumBuildingProductionModifiers(); j++)
				{
					if ((BuildingTypes)GC.getTraitInfo(eTrait).getBuildingProductionModifier(j).eBuilding == eBuilding)
					{
						iTraitMod += GC.getTraitInfo(eTrait).getBuildingProductionModifier(j).iModifier;
					}
				}

				if (building.getSpecialBuildingType() != NO_SPECIALBUILDING)
				{
					for (int j = 0; j < GC.getTraitInfo(eTrait).getNumSpecialBuildingProductionModifiers(); j++)
					{
						if ((SpecialBuildingTypes)GC.getTraitInfo(eTrait).getSpecialBuildingProductionModifier(j).eSpecialBuilding == building.getSpecialBuildingType())
						{
							iTraitMod += GC.getTraitInfo(eTrait).getSpecialBuildingProductionModifier(j).iModifier;
						}
					}
				}
				if (0 != iTraitMod)
				{
					szBuffer.append(gDLL->getText("TXT_KEY_MISC_HELP_PROD_TRAIT", iTraitMod, building.getTextKeyWide(), GC.getTraitInfo(eTrait).getTextKeyWide()));
					szBuffer.append(NEWLINE);
					iBaseModifier += iTraitMod;
				}
			}
		}

		// Wonder
		if (isWorldWonder(eBuilding) && NO_PLAYER != city.getOwner())
		{
			const int iWonderMod = owner.getMaxGlobalBuildingProductionModifier();
			if (0 != iWonderMod)
			{
				szBuffer.append(gDLL->getText("TXT_KEY_MISC_HELP_PROD_WONDER", iWonderMod));
				szBuffer.append(NEWLINE);
				iBaseModifier += iWonderMod;
			}
		}

		// Team Wonder
		if (isTeamWonder(eBuilding) && NO_PLAYER != city.getOwner())
		{
			const int iWonderMod = owner.getMaxTeamBuildingProductionModifier();
			if (0 != iWonderMod)
			{
				szBuffer.append(gDLL->getText("TXT_KEY_MISC_HELP_PROD_TEAM_WONDER", iWonderMod));
				szBuffer.append(NEWLINE);
				iBaseModifier += iWonderMod;
			}
		}

		// National Wonder
		if (isNationalWonder(eBuilding) && NO_PLAYER != city.getOwner())
		{
			const int iWonderMod = owner.getMaxPlayerBuildingProductionModifier();
			if (0 != iWonderMod)
			{
				szBuffer.append(gDLL->getText("TXT_KEY_MISC_HELP_PROD_NATIONAL_WONDER", iWonderMod));
				szBuffer.append(NEWLINE);
				iBaseModifier += iWonderMod;
			}
		}

		// Religion
		if (NO_PLAYER != city.getOwner() && NO_RELIGION != owner.getStateReligion())
		{
			if (city.isHasReligion(owner.getStateReligion()))
			{
				const int iReligionMod = owner.getStateReligionBuildingProductionModifier();
				if (0 != iReligionMod)
				{
					szBuffer.append(gDLL->getText("TXT_KEY_MISC_HELP_PROD_RELIGION", iReligionMod, GC.getReligionInfo(owner.getStateReligion()).getTextKeyWide()));
					szBuffer.append(NEWLINE);
					iBaseModifier += iReligionMod;
				}
			}
		}
	}

	const ProjectTypes eProject = city.getProductionProject();
	if (NO_PROJECT != eProject)
	{
		const CvProjectInfo& project = GC.getProjectInfo(eProject);

		// Spaceship
		if (project.isSpaceship())
		{
			int iSpaceshipMod = city.getSpaceProductionModifier();
			if (NO_PLAYER != city.getOwner())
			{
				iSpaceshipMod += owner.getSpaceProductionModifier();
			}
			if (0 != iSpaceshipMod)
			{
				szBuffer.append(gDLL->getText("TXT_KEY_MISC_HELP_PROD_SPACESHIP", iSpaceshipMod));
				szBuffer.append(NEWLINE);
				iBaseModifier += iSpaceshipMod;
			}
		}

		// Bonus
		for (int i = 0; i < GC.getNumBonusInfos(); i++)
		{
			if (city.hasBonus((BonusTypes)i))
			{
				const int iBonusMod = project.getBonusProductionModifier(i);
				if (0 != iBonusMod)
				{
					szBuffer.append(gDLL->getText("TXT_KEY_MISC_HELP_PROD_MOD_BONUS", iBonusMod, project.getTextKeyWide(), GC.getBonusInfo((BonusTypes)i).getTextKeyWide()));
					szBuffer.append(NEWLINE);
					iBaseModifier += iBonusMod;
				}
			}
		}
	}

	// Total
	szBuffer.append(gDLL->getText("TXT_KEY_MISC_HELP_PROD_TOTAL", iBaseModifier-100));
	szBuffer.append(SEPARATOR);
	szBuffer.append(NEWLINE);

	const int iFoodProduction = (city.isFoodProduction() ? std::max(0, (city.getYieldRate(YIELD_FOOD) - city.foodConsumption(true))) : 0);
	if (iFoodProduction > 0)
	{
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_HELP_PROD_FOOD", iFoodProduction, iFoodProduction));
		szBuffer.append(NEWLINE);
	}

	const int iModProduction = iFoodProduction + (iBaseModifier * iBaseProduction) / 100;

	FAssertMsg(iModProduction == city.getCurrentProductionDifference(ProductionCalc::FoodProduction | (!bIsProcess? ProductionCalc::Overflow : ProductionCalc::None)),
		CvString::format("Modified Production (%d) does not match actual value (%d)",
			iModProduction, city.getCurrentProductionDifference(ProductionCalc::FoodProduction | (!bIsProcess? ProductionCalc::Overflow : ProductionCalc::None))).c_str());
	//FAssertMsg(city.getProductionModifier() == (iBaseModifier-100), CvString::format("Real Modifier: %d%%; modifier: %d%%", city.getProductionModifier(), iBaseModifier-100).c_str());

	szBuffer.append(gDLL->getText("TXT_KEY_MISC_HELP_PROD_FINAL_YIELD", iModProduction));

	if (bBuildingAdditionalYield && city.getOwner() == GC.getGame().getActivePlayer())
	{
		setBuildingAdditionalYieldHelp(szBuffer, city, YIELD_PRODUCTION, DOUBLE_SEPARATOR);
	}
}


void CvGameTextMgr::parsePlayerTraits(CvWStringBuffer &szBuffer, PlayerTypes ePlayer)
{
	CvPlayer& kPlayer = GET_PLAYER(ePlayer);
	int iPotentialDisplays = 0;

	for (int iTrait = 0; iTrait < GC.getNumTraitInfos(); iTrait++)
	{
		if (kPlayer.hasTrait((TraitTypes)iTrait))
		{
			iPotentialDisplays++;
		}
	}
	int iDisplayCount = kPlayer.getTraitDisplayCount();

	if (gDLL->shiftKey())
	{
		if (iDisplayCount > iPotentialDisplays)
		{
			kPlayer.setTraitDisplayCount(0);
		}
		else
		{
			kPlayer.changeTraitDisplayCount(1);
		}
	}
	iDisplayCount = kPlayer.getTraitDisplayCount();
	bool bFirst = true;
	const CivilizationTypes eCivilization = kPlayer.getCivilizationType();
	int iCurrentDisplay = 0;

	for (int iTrait = 0; iTrait < GC.getNumTraitInfos(); ++iTrait)
	{
		if (kPlayer.hasTrait((TraitTypes)iTrait))
		{
			iCurrentDisplay++;
			if (bFirst)
			{
				szBuffer.append(L" (");
				bFirst = false;
			}
			else
			{
				szBuffer.append(L", ");
			}
			//May need to add the buttons here?  Not sure. We'll see how this goes.
			if (iCurrentDisplay == iDisplayCount)
			{
				parseTraits(szBuffer, ((TraitTypes)iTrait), eCivilization);
			}
			else
			{
				szBuffer.append(GC.getTraitInfo((TraitTypes)iTrait).getDescription());
			}
			//parseTraits(szBuffer, ((TraitTypes)iTrait), eCivilization, true);
		}
	}

	if (!bFirst)
	{
		szBuffer.append(L")");
	}

	szBuffer.append(NEWLINE);
	szBuffer.append(gDLL->getText("TXT_KEY_MISC_TRAIT_CYCLING_HELP"));

	if (GC.getGame().isOption(GAMEOPTION_LEADERHEAD_LEVELUPS))
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_LEADER_LEVEL", kPlayer.getLeaderHeadLevel()));
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_LEADER_LEVEL_PROGRESS_1", kPlayer.getCulture()));
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_LEADER_LEVEL_PROGRESS_2", kPlayer.getLeaderLevelupNextCultureTotal()));
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_LEADER_LEVEL_PROGRESS_3", kPlayer.getLeaderLevelupCultureToEarn()));
	}
}

void CvGameTextMgr::parsePlayerHasFixedBorders(CvWStringBuffer &szBuffer, PlayerTypes ePlayer)
{
	bool bHasFixedBorders = GET_PLAYER(ePlayer).hasFixedBorders();
	szBuffer.append(gDLL->getText(bHasFixedBorders ? "TXT_KEY_PLAYER_HAS_FIXED_BORDERS" : "TXT_KEY_PLAYER_HAS_NOT_FIXED_BORDERS"));
}

void CvGameTextMgr::parseLeaderHeadHelp(CvWStringBuffer &szBuffer, PlayerTypes eThisPlayer, PlayerTypes eOtherPlayer)
{
	if (NO_PLAYER == eThisPlayer)
	{
		return;
	}

	szBuffer.append(CvWString::format(L"%s", GET_PLAYER(eThisPlayer).getName()));

	parsePlayerTraits(szBuffer, eThisPlayer);

	szBuffer.append(L"\n");

	if ( GC.getGame().isOption(GAMEOPTION_FIXED_BORDERS) )
	{
		parsePlayerHasFixedBorders(szBuffer, eThisPlayer);

		szBuffer.append(L"\n");
	}

// BUG - Leaderhead Relations - start
	PlayerTypes eActivePlayer = GC.getGame().getActivePlayer();
	TeamTypes eThisTeam = GET_PLAYER(eThisPlayer).getTeam();
	CvTeam& kThisTeam = GET_TEAM(eThisTeam);

	if (eOtherPlayer == NO_PLAYER)
	{
		eOtherPlayer = eActivePlayer;
	}
	if (eThisPlayer != eOtherPlayer && kThisTeam.isHasMet(GET_PLAYER(eOtherPlayer).getTeam()))
	{
		getEspionageString(szBuffer, eThisPlayer, eOtherPlayer);

		getAttitudeString(szBuffer, eThisPlayer, eOtherPlayer);

		if (gDLL->ctrlKey())
		{
			getActiveDealsString(szBuffer, eThisPlayer, eOtherPlayer);
		}
	}

	getAllRelationsString(szBuffer, eThisTeam);
// BUG - Leaderhead Relations - end
}


void CvGameTextMgr::getActiveDealsString(CvWStringBuffer &szBuffer, PlayerTypes eThisPlayer, PlayerTypes eOtherPlayer)
{
	int iIndex;
	CvDeal* pDeal = GC.getGame().firstDeal(&iIndex);
	while (NULL != pDeal)
	{
		if ((pDeal->getFirstPlayer() == eThisPlayer && pDeal->getSecondPlayer() == eOtherPlayer)
			|| (pDeal->getFirstPlayer() == eOtherPlayer && pDeal->getSecondPlayer() == eThisPlayer))
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(CvWString::format(L"%c", gDLL->getSymbolID(BULLET_CHAR)));
			getDealString(szBuffer, *pDeal, eThisPlayer);
		}
		pDeal = GC.getGame().nextDeal(&iIndex);
	}
}

// BUG - Leaderhead Relations - start
/*
 * Shows the peace/war/enemy/pact status between eThisTeam and all rivals known to the active player.
 * Relations for the active player are shown first.
 */
void CvGameTextMgr::getAllRelationsString(CvWStringBuffer& szString, TeamTypes eThisTeam)
{
	getActiveTeamRelationsString(szString, eThisTeam);
	getOtherRelationsString(szString, eThisTeam, NO_TEAM, GC.getGame().getActiveTeam());
}

/*
 * Shows the peace/war/enemy/pact status between eThisTeam and the active player.
 */
void CvGameTextMgr::getActiveTeamRelationsString(CvWStringBuffer& szString, TeamTypes eThisTeam)
{
	CvTeamAI& kThisTeam = GET_TEAM(eThisTeam);
	TeamTypes eActiveTeam = GC.getGame().getActiveTeam();
	CvTeamAI& kActiveTeam = GET_TEAM(eActiveTeam);


	if (!kThisTeam.isHasMet(eActiveTeam))
	{
		return;
	}

	if (kThisTeam.isAtWar(eActiveTeam))
	{
		szString.append(NEWLINE);
		szString.append(gDLL->getText(L"TXT_KEY_AT_WAR_WITH_YOU"));
	}
	else if (kThisTeam.isForcePeace(eActiveTeam))
	{
		szString.append(NEWLINE);
		szString.append(gDLL->getText(L"TXT_KEY_PEACE_TREATY_WITH_YOU"));
	}

	if (!kThisTeam.isHuman() && kThisTeam.AI_getWorstEnemy() == eActiveTeam)
	{
		szString.append(NEWLINE);
		szString.append(gDLL->getText(L"TXT_KEY_WORST_ENEMY_IS_YOU"));
	}

	if (kThisTeam.isDefensivePact(eActiveTeam))
	{
		szString.append(NEWLINE);
		szString.append(gDLL->getText(L"TXT_KEY_DEFENSIVE_PACT_WITH_YOU"));
	}

	if (!kThisTeam.isAtWar(eActiveTeam))
	{

		if (kActiveTeam.AI_getWarPlan(eThisTeam) == WARPLAN_PREPARING_TOTAL)
		{
			szString.append(NEWLINE);
			szString.append(gDLL->getText(L"TXT_KEY_WARPLAN_TARGET_OF_YOU"));
		}

		if (GC.getGame().isDebugMode())
		{
			if (kThisTeam.AI_getWarPlan(eActiveTeam) == WARPLAN_PREPARING_TOTAL || kThisTeam.AI_getWarPlan(eActiveTeam) == WARPLAN_TOTAL)
			{
				szString.append(NEWLINE);
				szString.append(gDLL->getText(L"TXT_KEY_WARPLAN_TARGET_IS_YOU"));
			}
			else if (kThisTeam.AI_getWarPlan(eActiveTeam) == WARPLAN_PREPARING_LIMITED || kThisTeam.AI_getWarPlan(eActiveTeam) == WARPLAN_LIMITED)
			{
				szString.append(NEWLINE);
				szString.append(gDLL->getText(L"TXT_KEY_WARPLAN_LIMITED_TARGET_IS_YOU"));
			}
		}
	}
}

/*
 * Shows the peace/war/enemy/pact status between eThisPlayer and eOtherPlayer (both must not be NO_PLAYER).
 * If eOtherTeam is not NO_TEAM, only relations between it and eThisTeam are shown.
 * if eSkipTeam is not NO_TEAM, relations involving it are not shown.
 */
void CvGameTextMgr::getOtherRelationsString(CvWStringBuffer& szString, PlayerTypes eThisPlayer, PlayerTypes eOtherPlayer)
{
	if (eThisPlayer == NO_PLAYER || eOtherPlayer == NO_PLAYER)
	{
		return;
	}

	getOtherRelationsString(szString, GET_PLAYER(eThisPlayer).getTeam(), GET_PLAYER(eOtherPlayer).getTeam(), NO_TEAM);
}

/*
 * Shows the peace/war/enemy/pact status between eThisPlayer and all rivals known to the active player.
 * If eOtherTeam is not NO_TEAM, only relations between it and eThisTeam are shown.
 * if eSkipTeam is not NO_TEAM, relations involving it are not shown.
 */
void CvGameTextMgr::getOtherRelationsString(CvWStringBuffer& szString, TeamTypes eThisTeam, TeamTypes eOtherTeam, TeamTypes eSkipTeam)
{
	if (eThisTeam == NO_TEAM)
	{
		return;
	}

	CvTeamAI& kThisTeam = GET_TEAM(eThisTeam);
	CvWString szWar, szPeace, szEnemy, szPact, szWarPlanTotal, szWarPlanLimited;
	bool bFirstWar = true, bFirstPeace = true, bFirstEnemy = true, bFirstPact = true, bFirstWarPlanTotal = true, bFirstWarPlanLimited = true;

	for (int iTeam = 0; iTeam < MAX_PC_TEAMS; ++iTeam)
	{
		CvTeamAI& kTeam = GET_TEAM((TeamTypes) iTeam);
		if (kTeam.isAlive() && !kTeam.isMinorCiv() && iTeam != eThisTeam && iTeam != eSkipTeam && (eOtherTeam == NO_TEAM || iTeam == eOtherTeam))
		{
			if (kTeam.isHasMet(eThisTeam) && kTeam.isHasMet(GC.getGame().getActiveTeam()))
			{
				if (::atWar((TeamTypes) iTeam, eThisTeam))
				{
					setListHelp(szWar, L"", kTeam.getName().GetCString(), L", ", bFirstWar);
					bFirstWar = false;
				}
				else if (kTeam.isForcePeace(eThisTeam))
				{
					setListHelp(szPeace, L"", kTeam.getName().GetCString(), L", ", bFirstPeace);
					bFirstPeace = false;
				}

				if (!kTeam.isHuman() && kTeam.AI_getWorstEnemy() == eThisTeam)
				{
					setListHelp(szEnemy, L"", kTeam.getName().GetCString(), L", ", bFirstEnemy);
					bFirstEnemy = false;
				}

				if (kTeam.isDefensivePact(eThisTeam))
				{
					setListHelp(szPact, L"", kTeam.getName().GetCString(), L", ", bFirstPact);
					bFirstPact = false;
				}

				//Show own war plans
				if (eThisTeam == GC.getGame().getActiveTeam() || (GC.getGame().isDebugMode() && !(::atWar((TeamTypes) iTeam, eThisTeam))))
				{
					if (kThisTeam.AI_getWarPlan((TeamTypes)iTeam) == WARPLAN_PREPARING_TOTAL || kThisTeam.AI_getWarPlan((TeamTypes)iTeam) == WARPLAN_TOTAL)
					{
						setListHelp(szWarPlanTotal, L"", kTeam.getName().GetCString(), L", ", bFirstWarPlanTotal);
						bFirstWarPlanTotal = false;
					}
					else if (kThisTeam.AI_getWarPlan((TeamTypes)iTeam) == WARPLAN_PREPARING_LIMITED || kThisTeam.AI_getWarPlan((TeamTypes)iTeam) == WARPLAN_LIMITED || kThisTeam.AI_getWarPlan((TeamTypes)iTeam) == WARPLAN_DOGPILE)
					{
						setListHelp(szWarPlanLimited, L"", kTeam.getName().GetCString(), L", ", bFirstWarPlanLimited);
						bFirstWarPlanLimited = false;
					}
				}

			}
		}
	}

	if (!szWar.empty())
	{
		szString.append(NEWLINE);
		szString.append(gDLL->getText(L"TXT_KEY_AT_WAR_WITH", szWar.GetCString()));
	}
	if (!kThisTeam.isHuman())
	{
		TeamTypes eWorstEnemy = kThisTeam.AI_getWorstEnemy();
		if (eWorstEnemy != NO_TEAM && eWorstEnemy != eSkipTeam && (eOtherTeam == NO_TEAM || eWorstEnemy == eOtherTeam) && GET_TEAM(eWorstEnemy).isHasMet(GC.getGame().getActiveTeam()))
		{
			szString.append(NEWLINE);
			szString.append(gDLL->getText(L"TXT_KEY_WORST_ENEMY_IS", GET_TEAM(eWorstEnemy).getName().GetCString()));
		}
	}
	if (!szEnemy.empty())
	{
		szString.append(NEWLINE);
		szString.append(gDLL->getText(L"TXT_KEY_WORST_ENEMY_OF", szEnemy.GetCString()));
	}
	if (!szPeace.empty())
	{
		szString.append(NEWLINE);
		szString.append(gDLL->getText(L"TXT_KEY_PEACE_TREATY_WITH", szPeace.GetCString()));
	}
	if (!szPact.empty())
	{
		szString.append(NEWLINE);
		szString.append(gDLL->getText(L"TXT_KEY_DEFENSIVE_PACT_WITH", szPact.GetCString()));
	}
	if (!szWarPlanTotal.empty())
	{
		szString.append(NEWLINE);
		szString.append(gDLL->getText(L"TXT_KEY_WARPLAN_TARGET_IS", szWarPlanTotal.GetCString()));
	}
	if (!szWarPlanLimited.empty())
	{
		szString.append(NEWLINE);
		szString.append(gDLL->getText(L"TXT_KEY_WARPLAN_LIMITED_TARGET_IS", szWarPlanLimited.GetCString()));
	}
}
// BUG - Leaderhead Relations - end

void CvGameTextMgr::buildHintsList(CvWStringBuffer& szBuffer)
{
	for (int i = 0; i < GC.getNumHints(); i++)
	{
		szBuffer.append(CvWString::format(L"%c%s", gDLL->getSymbolID(BULLET_CHAR), GC.getHints(i).getText()));
		szBuffer.append(NEWLINE);
		szBuffer.append(NEWLINE);
	}
}

void CvGameTextMgr::setCommerceHelp(CvWStringBuffer &szBuffer, CvCity& city, CommerceTypes eCommerceType)
{
	//check if this hover is turned on in the bug options and disable if not.
	bool bBuildingAdditionalCommerce = getBugOptionBOOL("MiscHover__BuildingAdditionalCommerce", true, "BUG_BUILDING_ADDITIONAL_COMMERCE_HOVER");
	if (NO_COMMERCE == eCommerceType || (0 == city.getCommerceRateTimes100(eCommerceType) && !bBuildingAdditionalCommerce))
	{
		return;
	}

	//define commerce info.
	const CvCommerceInfo& info = GC.getCommerceInfo(eCommerceType);

	//ensure we have a player definition - if we don't, disable the help hover
	if (NO_PLAYER == city.getOwner())
	{
		return;
	}
	//define player owner.
	CvPlayer& owner = GET_PLAYER(city.getOwner());
	//define team owner.
	CvTeam& team = GET_TEAM(owner.getTeam());

	//initiate with an exposition on the base commerce yield income total for the city before we start a breakdown
	//Note: should generate a total value as it shows the base and then modifier but not a total - that would be a helpful addition
	setYieldHelp(szBuffer, city, YIELD_COMMERCE);

	//STEP 1 : Slider
	//displays as: slider% of totalCommerce = total base unmodified commerce
	int iBaseCommerceRate = city.getCommerceFromPercent(eCommerceType, city.getYieldRate(YIELD_COMMERCE) * 100);
	CvWString szRate = CvWString::format(L"%d.%02d", iBaseCommerceRate/100, iBaseCommerceRate%100);
	szBuffer.append(gDLL->getText("TXT_KEY_MISC_HELP_SLIDER_PERCENT_FLOAT", owner.getCommercePercent(eCommerceType), city.getYieldRate(YIELD_COMMERCE), szRate.GetCString(), info.getChar()));
	szBuffer.append(NEWLINE);

	//define for a final (and optional) subtotal display that adds up the following value changes
	bool bNeedSubtotal = false;

	//STEP 2 : Commerce Changes from specialists
	//city.getSpecialistCommerce(eCommerceType) = The individual commerce changes introduced by the definitions of the specialists themselves - processed in saved total commerce changes from specialists (Specialist: iCommerceChange) added to the city modified by the player's getSpecialistCommercePercentChanges value (from traits and civics).
	//city.getExtraSpecialistCommerceTotal(eCommerceType) = The commerce changes stemming from the total of sweeping changes to all specialists of a particular type.
	//Ok, yeah, so city.getExtraSpecialistCommerceTotal(eCommerceType) is already totalling the proper # of specialists so to multiply it by the amount of specialists here is redundant.
	//int iSpecialistCommerce = city.getSpecialistCommerce(eCommerceType) + /*(city.getSpecialistPopulation() + city.getNumGreatPeople()) * */city.getExtraSpecialistCommerceTotal(eCommerceType);
	int iSpecialistCommerce = city.getSpecialistCommerce(eCommerceType) + city.getExtraSpecialistCommerceTotal(eCommerceType);
	//Another missing piece is here below, which was part of the confusion.
	//getSpecialistExtraCommerce(eCommerceType) = +/- Commerce for EVERY specialist regardless of type.
	iSpecialistCommerce += ((city.getSpecialistPopulation() + city.getNumGreatPeople()) * owner.getSpecialistExtraCommerce(eCommerceType));
	if (0 != iSpecialistCommerce)
	{
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_HELP_SPECIALIST_COMMERCE", iSpecialistCommerce, info.getChar(), L"TXT_KEY_CONCEPT_SPECIALISTS"));
		szBuffer.append(NEWLINE);
		iBaseCommerceRate += 100 * iSpecialistCommerce;
		bNeedSubtotal = true;
	}

	//STEP 3 : Religion Commerce
	int iReligionCommerce = city.getReligionCommerce(eCommerceType);
	if (0 != iReligionCommerce)
	{
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_HELP_RELIGION_COMMERCE", iReligionCommerce, info.getChar()));
		szBuffer.append(NEWLINE);
		iBaseCommerceRate += 100 * iReligionCommerce;
// BUG - Base Commerce - start
		bNeedSubtotal = true;
// BUG - Base Commerce - end
	}

	//STEP 4 : Corporation Commerce
	int iCorporationCommerce = city.getCorporationCommerce(eCommerceType);
	if (0 != iCorporationCommerce)
	{
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_HELP_CORPORATION_COMMERCE", iCorporationCommerce, info.getChar()));
		szBuffer.append(NEWLINE);
		iBaseCommerceRate += 100 * iCorporationCommerce;
		bNeedSubtotal = true;
	}

	//STEP 5 : Building Commerce Changes
	int iBuildingCommerce = city.getBuildingCommerce(eCommerceType);
	iBuildingCommerce *= 100;
	iBuildingCommerce += city.getBonusCommercePercentChanges(eCommerceType);
	int fBuildingCommerce = iBuildingCommerce/100;
	if (0 != iBuildingCommerce)
	{
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_HELP_BUILDING_COMMERCE", fBuildingCommerce, info.getChar()));
		szBuffer.append(NEWLINE);
		iBaseCommerceRate += iBuildingCommerce;
		bNeedSubtotal = true;
	}

	//STEP 6 : Free City Commerce (player tallied from civics/traits a change value to all cities commerce output)
	int iFreeCityCommerce = owner.getFreeCityCommerce(eCommerceType);
	if (0 != iFreeCityCommerce)
	{
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_HELP_FREE_CITY_COMMERCE", iFreeCityCommerce, info.getChar()));
		szBuffer.append(NEWLINE);
		iBaseCommerceRate += 100 * iFreeCityCommerce;
		bNeedSubtotal = true;
	}

	//STEP 7 : Commerce Attacks
	int iCommerceAttacks = city.getCommerceAttacks(eCommerceType);
	if (0 != iCommerceAttacks)
	{
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_HELP_COMMERE_ATTACKS", iCommerceAttacks, info.getChar()));
		szBuffer.append(NEWLINE);
		iBaseCommerceRate += 100 * iCommerceAttacks;
		bNeedSubtotal = true;
	}

	//STEP 8 : Minted Commerce
	if (eCommerceType == COMMERCE_GOLD)
	{
		int iMintedCommerce = city.getMintedCommerceTimes100() / 100;
		if (0 != iMintedCommerce)
		{
			szBuffer.append(gDLL->getText("TXT_KEY_MISC_HELP_MINTED_COMMERCE", iMintedCommerce, info.getChar()));
			szBuffer.append(NEWLINE);
			bNeedSubtotal = true;
		}
		iBaseCommerceRate += city.getMintedCommerceTimes100();
	}

	//STEP 9 : Golden Age Base Commerce Changes (usually trait driven though it might be interesting to enable this on civics.)
	if (owner.isGoldenAge())
	{
		int iGoldenAgeCommerce = owner.getGoldenAgeCommerce(eCommerceType);
		if (0 != iGoldenAgeCommerce)
		{
			szBuffer.append(gDLL->getText("TXT_KEY_MISC_HELP_GOLDEN_AGE_PLAYER_COMMERCE", iGoldenAgeCommerce, info.getChar()));
			szBuffer.append(NEWLINE);
			bNeedSubtotal = true;
		}
		iBaseCommerceRate += 100 * iGoldenAgeCommerce;
	}

// BUG - Base Commerce - start
	if (bNeedSubtotal && city.getTotalCommerceRateModifier(eCommerceType) != 0 && getBugOptionBOOL("MiscHover__BaseCommerce", true, "BUG_CITY_SCREEN_BASE_COMMERCE_HOVER"))
	{
		CvWString szYield = CvWString::format(L"%d.%02d", iBaseCommerceRate/100, iBaseCommerceRate%100);
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_HELP_COMMERCE_SUBTOTAL_YIELD_FLOAT", info.getTextKeyWide(), szYield.GetCString(), info.getChar()));
		szBuffer.append(NEWLINE);
	}
// BUG - Base Commerce - end
	//Debug check to make sure Base in display matches base in programming
	int iCheckBase = city.getBaseCommerceRateTimes100(eCommerceType);
	FAssertMsg(city.getBaseCommerceRateTimes100(eCommerceType) == iBaseCommerceRate, "Base Commerce rate does not agree with actual value");


	//% MODIFIER TALLY
	//In the city coding the final modifier value appears to be processed in and out and stored on m_totalCommerceRateModifier[eIndex]
	int iModifier = 100;

	//STEP 1 : Bonus Commerce Rate Modifier
	int iBonusCommerce = city.calculateBonusCommerceRateModifier(eCommerceType);
	if (0 != iBonusCommerce)
	{
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_HELP_BONUS_COMMERCE", iBonusCommerce, info.getChar()));
		szBuffer.append(NEWLINE);

		iModifier += iBonusCommerce;
	}

	//STEP 2 : Buildings (split into projects and everything else)
	// Buildings
	int iBuildingMod = city.getCommerceRateModifier(eCommerceType);
	iBuildingMod += city.calculateBuildingCommerceModifier(eCommerceType);

	// return to buildings
	if (0 != iBuildingMod)
	{
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_HELP_YIELD_BUILDINGS", iBuildingMod, info.getChar()));
		szBuffer.append(NEWLINE);
		iModifier += iBuildingMod;
	}

	//STEP 2.5
	//Display projects (AND Player level buildings (Wonders))
	int iProjectMod = owner.getCommerceRateModifierfromBuildings(eCommerceType);
	if (iProjectMod != 0)
	{
		//iBuildingMod -= iProjectMod; Don't think this actually tallies into calculateBuildingCommerceModifier(eIndex);
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_HELP_YIELD_PROJECTS", iProjectMod, info.getChar()));
		szBuffer.append(NEWLINE);
		iModifier += iProjectMod;
	}

	//STEP 3 : Events
	int iEventsModifier = 0;
	iEventsModifier += owner.getCommerceRateModifierfromEvents(eCommerceType);
	if (0 != iEventsModifier)
	{
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_HELP_COMMERCE_EVENTS", iEventsModifier, info.getChar()));
		szBuffer.append(NEWLINE);

		iModifier += iEventsModifier;
	}

	//STEP 4 : Player Level
	int iPlayerLevelModifier = owner.getCommerceRateModifier(eCommerceType);
	int iPlayerLevelCompare = 0;
	//Remove Events - they were included in the above report
	iPlayerLevelModifier -= owner.getCommerceRateModifierfromEvents(eCommerceType);
	//Remove Team and Player level Building Modifiers - they were included in the above report
	iPlayerLevelModifier -= owner.getCommerceRateModifierfromBuildings(eCommerceType);

	// Trait
	for (int i = 0; i < GC.getNumTraitInfos(); i++)
	{
		if (city.hasTrait((TraitTypes)i))
		{
			const CvTraitInfo& trait = GC.getTraitInfo((TraitTypes)i);
			const int iTraitMod = trait.getCommerceModifier(eCommerceType);
			if (0 != iTraitMod)
			{
				szBuffer.append(gDLL->getText("TXT_KEY_MISC_HELP_COMMERCE_TRAIT", iTraitMod, info.getChar(), trait.getTextKeyWide()));
				szBuffer.append(NEWLINE);
				iPlayerLevelCompare += iTraitMod;
			}
		}
	}


	// Civics
	int iCivicMod = 0;
	for (int i = 0; i < GC.getNumCivicOptionInfos(); i++)
	{
		if (NO_CIVIC != owner.getCivics((CivicOptionTypes)i))
		{
			iCivicMod += GC.getCivicInfo(owner.getCivics((CivicOptionTypes)i)).getCommerceModifier(eCommerceType);
		}
	}
	if (0 != iCivicMod)
	{
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_HELP_YIELD_CIVICS", iCivicMod, info.getChar()));
		szBuffer.append(NEWLINE);
		iPlayerLevelCompare += iCivicMod;
	}

	// Techs
	for (int i = 0; i < GC.getNumTechInfos(); i++)
	{
		if (team.isHasTech((TechTypes)i))
		{
			const CvTechInfo& tech = GC.getTechInfo((TechTypes)i);
			const int iTechMod = tech.getCommerceModifier(eCommerceType);
			if (0 != iTechMod)
			{
				szBuffer.append(gDLL->getText("TXT_KEY_MISC_HELP_COMMERCE_TECH", iTechMod, info.getChar(), tech.getTextKeyWide()));
				szBuffer.append(NEWLINE);
				iPlayerLevelCompare += iTechMod;
			}
		}
	}
	iModifier += iPlayerLevelModifier;
	//Debug check to make sure Base in display matches base in progamming
	FAssertMsg(iPlayerLevelModifier == iPlayerLevelCompare, "Player Level Commerce Modifier display does not agree with actual value");

	//STEP 5 : Capital Modifier
	// Capital
	int iCapitalMod = city.isCapital() ? owner.getCapitalCommerceRateModifier(eCommerceType) : 0;
	if (iCapitalMod != 0)
	{
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_HELP_YIELD_CAPITAL", iCapitalMod, info.getChar()));
		szBuffer.append(NEWLINE);
		iModifier += iCapitalMod;
	}

	iModifier = std::max(1, iModifier);

	int iModYield;
	//	Modifiers apply inversely against a negative base to avoid counter-intuitive
	//	situations like intelligence agencies making negative espionag worse
	if ( iBaseCommerceRate > 0 )
	{
		iModYield = (iModifier * iBaseCommerceRate) / 100;
	}
	else
	{
		iModYield = (100 * iBaseCommerceRate) / iModifier;
	}

	int iProductionToCommerce = city.getProductionToCommerceModifier(eCommerceType) * city.getYieldRate(YIELD_PRODUCTION);
	if (0 != iProductionToCommerce)
	{
		if (iProductionToCommerce%100 == 0)
		{
			szBuffer.append(gDLL->getText("TXT_KEY_MISC_HELP_PRODUCTION_TO_COMMERCE", iProductionToCommerce/100, info.getChar()));
			szBuffer.append(NEWLINE);
		}
		else
		{
			szRate = CvWString::format(L"+%d.%02d", iProductionToCommerce/100, iProductionToCommerce%100);
			szBuffer.append(gDLL->getText("TXT_KEY_MISC_HELP_PRODUCTION_TO_COMMERCE_FLOAT", szRate.GetCString(), info.getChar()));
			szBuffer.append(NEWLINE);
		}
		iModYield += iProductionToCommerce;
	}

	if (eCommerceType == COMMERCE_CULTURE && GC.getGame().isOption(GAMEOPTION_NO_ESPIONAGE))
	{
		int iEspionageToCommerce = city.getCommerceRateTimes100(COMMERCE_CULTURE) - iModYield;
		if (0 != iEspionageToCommerce)
		{
			if (iEspionageToCommerce%100 == 0)
			{
				szBuffer.append(gDLL->getText("TXT_KEY_MISC_HELP_COMMERCE_TO_COMMERCE", iEspionageToCommerce/100, info.getChar(), GC.getCommerceInfo(COMMERCE_ESPIONAGE).getChar()));
				szBuffer.append(NEWLINE);
			}
			else
			{
				szRate = CvWString::format(L"+%d.%02d", iEspionageToCommerce/100, iEspionageToCommerce%100);
				szBuffer.append(gDLL->getText("TXT_KEY_MISC_HELP_COMMERCE_TO_COMMERCE_FLOAT", szRate.GetCString(), info.getChar(), GC.getCommerceInfo(COMMERCE_ESPIONAGE).getChar()));
				szBuffer.append(NEWLINE);
			}
			iModYield += iEspionageToCommerce;
		}
	}
	int iCheck = city.getCommerceRateTimes100(eCommerceType);
	FAssertMsg(iModYield == city.getCommerceRateTimes100(eCommerceType), "Commerce yield does not match actual value");

	CvWString szYield = CvWString::format(L"%d.%02d", iModYield/100, std::abs(iModYield%100));
	szBuffer.append(gDLL->getText("TXT_KEY_MISC_HELP_COMMERCE_FINAL_YIELD_FLOAT", info.getTextKeyWide(), szYield.GetCString(), info.getChar()));

// BUG - Building Additional Commerce - start
	if (bBuildingAdditionalCommerce && city.getOwner() == GC.getGame().getActivePlayer())
	{
		setBuildingAdditionalCommerceHelp(szBuffer, city, eCommerceType, DOUBLE_SEPARATOR);
	}
// BUG - Building Additional Commerce - end
}

void CvGameTextMgr::setYieldHelp(CvWStringBuffer &szBuffer, CvCity& city, YieldTypes eYieldType)
{
	FAssertMsg(NO_PLAYER != city.getOwner(), "City must have an owner");

	if (NO_YIELD == eYieldType || NO_PLAYER == city.getOwner())
	{
		return;
	}
	const CvYieldInfo& info = GC.getYieldInfo(eYieldType);
	CvPlayer& owner = GET_PLAYER(city.getOwner());

	const int iBaseProduction = city.getModifiedBaseYieldRate(eYieldType);

	szBuffer.append(gDLL->getText("TXT_KEY_MISC_HELP_BASE_YIELD", info.getTextKeyWide(), iBaseProduction, info.getChar()));
	szBuffer.append(NEWLINE);

	int iTemp;
	int iBaseModifier = 100;
	// Toffer
	// There may be a better way to get the event modifiers isolated, though the only one I can think
	// of is to add a new player and city variable to store the eventModifiers explicitly.
	int iEventModifier = city.getYieldRateModifier(eYieldType) + owner.getYieldRateModifier(eYieldType);
	// Traits
	int iMod = 0;
	for (int iI = 0; iI < GC.getNumTraitInfos(); iI++)
	{
		if (owner.hasTrait((TraitTypes)iI))
		{
			iTemp = GC.getTraitInfo((TraitTypes)iI).getYieldModifier(eYieldType);
			iEventModifier -= iTemp;
			iMod += iTemp;
		}
	}
	if (0 != iMod)
	{
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_HELP_YIELD_TRAITS", iMod, info.getChar()));
		szBuffer.append(NEWLINE);
		iBaseModifier += iMod;
	}
	// Civics
	iMod = 0;
	for (int iI = 0; iI < GC.getNumCivicOptionInfos(); iI++)
	{
		if (NO_CIVIC != owner.getCivics((CivicOptionTypes)iI))
		{
			iTemp = GC.getCivicInfo(owner.getCivics((CivicOptionTypes)iI)).getYieldModifier(eYieldType);
			iEventModifier -= iTemp;
			iMod += iTemp;
		}
	}
	if (0 != iMod)
	{
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_HELP_YIELD_CIVICS", iMod, info.getChar()));
		szBuffer.append(NEWLINE);
		iBaseModifier += iMod;
	}
	// Buildings
	iMod = 0;
	for (int iI = 0; iI < GC.getNumBuildingInfos(); iI++)
	{
		const CvBuildingInfo& infoBuilding = GC.getBuildingInfo((BuildingTypes)iI);
		if (city.getNumBuilding((BuildingTypes)iI) > 0)
		{
			if (city.getNumActiveBuilding((BuildingTypes)iI) > 0)
			{
				iTemp = infoBuilding.getYieldModifier(eYieldType);
				iEventModifier -= iTemp;
				iMod += iTemp;
			}
			iMod += GET_TEAM(city.getTeam()).getBuildingYieldModifier((BuildingTypes)iI, eYieldType);
		}
		for (int iJ = 0; iJ < MAX_PLAYERS; iJ++)
		{
			if (GET_PLAYER((PlayerTypes)iJ).isAlive() && GET_PLAYER((PlayerTypes)iJ).getTeam() == owner.getTeam())
			{
				foreach_(const CvCity* pLoopCity, GET_PLAYER((PlayerTypes)iJ).cities())
				{
					if (pLoopCity->getNumActiveBuilding((BuildingTypes)iI) > 0)
					{
						iTemp = infoBuilding.getGlobalYieldModifier(eYieldType);
						iEventModifier -= iTemp;
						iMod += iTemp;
					}
				}
			}
		}
	}
	if (NULL != city.area())
	{
		iMod += city.area()->getYieldRateModifier(city.getOwner(), eYieldType);
	}
	if (0 != iMod)
	{
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_HELP_YIELD_BUILDINGS", iMod, info.getChar()));
		szBuffer.append(NEWLINE);
		iBaseModifier += iMod;
	}
	// Resources
	iMod = city.getBonusYieldRateModifier(eYieldType);
	if (0 != iMod)
	{
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_HELP_YIELD_BONUS", iMod, info.getChar()));
		szBuffer.append(NEWLINE);
		iBaseModifier += iMod;
	}
	// Power
	if (city.isPower())
	{
		iMod = city.getPowerYieldRateModifier(eYieldType);
		if (0 != iMod)
		{
			szBuffer.append(gDLL->getText("TXT_KEY_MISC_HELP_YIELD_POWER", iMod, info.getChar()));
			szBuffer.append(NEWLINE);
			iBaseModifier += iMod;
		}
	}
	// Capital
	if (city.isCapital())
	{
		iMod = owner.getCapitalYieldRateModifier(eYieldType);
		if (0 != iMod)
		{
			szBuffer.append(gDLL->getText("TXT_KEY_MISC_HELP_YIELD_CAPITAL", iMod, info.getChar()));
			szBuffer.append(NEWLINE);
			iBaseModifier += iMod;
		}
	}
	// Events
	if (iEventModifier != 0)
	{
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_HELP_YIELD_EVENTS", iEventModifier, info.getChar()));
		szBuffer.append(NEWLINE);
		iBaseModifier += iEventModifier;
	}
	FAssertMsg(city.getBaseYieldRateModifier(eYieldType) == iBaseModifier, CvString::format("Total Yield Modifier %d should be %d", city.getBaseYieldRateModifier(eYieldType), iBaseModifier).c_str());
	FAssertMsg(iBaseProduction * std::max(0, iBaseModifier) / 100 == city.getYieldRate(eYieldType), "Yield Modifier in setProductionHelp does not agree with actual value");
}

void CvGameTextMgr::setConvertHelp(CvWStringBuffer& szBuffer, PlayerTypes ePlayer, ReligionTypes eReligion)
{
	CvWString szReligion = L"TXT_KEY_MISC_NO_STATE_RELIGION";

	if (eReligion != NO_RELIGION)
	{
		szReligion = GC.getReligionInfo(eReligion).getTextKeyWide();
	}

	szBuffer.assign(gDLL->getText("TXT_KEY_MISC_CANNOT_CONVERT_TO", szReligion.GetCString()));

	if (GET_PLAYER(ePlayer).isAnarchy())
	{
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_WHILE_IN_ANARCHY"));
	}
	else if (GET_PLAYER(ePlayer).getStateReligion() == eReligion)
	{
		szBuffer.append(L". ");
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_ALREADY_STATE_REL"));
	}
	else if (GET_PLAYER(ePlayer).getConversionTimer() > 0)
	{
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_ANOTHER_REVOLUTION_RECENTLY"));
		szBuffer.append(L". ");
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_WAIT_MORE_TURNS", GET_PLAYER(ePlayer).getConversionTimer()));
	}
}

void CvGameTextMgr::setRevolutionHelp(CvWStringBuffer& szBuffer, PlayerTypes ePlayer)
{
	szBuffer.assign(gDLL->getText("TXT_KEY_MISC_CANNOT_CHANGE_CIVICS"));

	if (GET_PLAYER(ePlayer).isAnarchy())
	{
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_WHILE_IN_ANARCHY"));
	}
	else if (GET_PLAYER(ePlayer).getRevolutionTimer() > 0)
	{
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_ANOTHER_REVOLUTION_RECENTLY"));
		szBuffer.append(L" : ");
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_WAIT_MORE_TURNS", GET_PLAYER(ePlayer).getRevolutionTimer()));
	}
}

void CvGameTextMgr::setVassalRevoltHelp(CvWStringBuffer& szBuffer, TeamTypes eMaster, TeamTypes eVassal)
{
	if (NO_TEAM == eMaster || NO_TEAM == eVassal)
	{
		return;
	}

	if (!GET_TEAM(eVassal).isCapitulated())
	{
		return;
	}

	if (GET_TEAM(eMaster).isParent(eVassal))
	{
		return;
	}

	CvTeam& kMaster = GET_TEAM(eMaster);
	CvTeam& kVassal = GET_TEAM(eVassal);

	int iMasterLand = kMaster.getTotalLand(false);
	int iVassalLand = kVassal.getTotalLand(false);
	if (iMasterLand > 0 && GC.getDefineINT("FREE_VASSAL_LAND_PERCENT") >= 0)
	{
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_VASSAL_LAND_STATS", (iVassalLand * 100) / iMasterLand, GC.getDefineINT("FREE_VASSAL_LAND_PERCENT")));
	}

	int iMasterPop = kMaster.getTotalPopulation(false);
	int iVassalPop = kVassal.getTotalPopulation(false);
	if (iMasterPop > 0 && GC.getDefineINT("FREE_VASSAL_POPULATION_PERCENT") >= 0)
	{
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_VASSAL_POPULATION_STATS", (iVassalPop * 100) / iMasterPop, GC.getDefineINT("FREE_VASSAL_POPULATION_PERCENT")));
	}

	if (GC.getDefineINT("VASSAL_REVOLT_OWN_LOSSES_FACTOR") > 0 && kVassal.getVassalPower() > 0)
	{
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_VASSAL_AREA_LOSS", (iVassalLand * 100) / kVassal.getVassalPower(), GC.getDefineINT("VASSAL_REVOLT_OWN_LOSSES_FACTOR")));
	}

	if (GC.getDefineINT("VASSAL_REVOLT_MASTER_LOSSES_FACTOR") > 0 && kVassal.getMasterPower() > 0)
	{
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_MASTER_AREA_LOSS", (iMasterLand * 100) / kVassal.getMasterPower(), GC.getDefineINT("VASSAL_REVOLT_MASTER_LOSSES_FACTOR")));
	}
}

void CvGameTextMgr::parseGreatPeopleHelp(CvWStringBuffer &szBuffer, CvCity& city)
{
	int iTotalGreatPeopleUnitProgress;
	int iI;

	if (NO_PLAYER == city.getOwner())
	{
		return;
	}
	CvPlayer& owner = GET_PLAYER(city.getOwner());

	szBuffer.assign(gDLL->getText("TXT_KEY_MISC_GREAT_PERSON", city.getGreatPeopleProgress(), owner.greatPeopleThresholdNonMilitary()));

	if (city.getGreatPeopleRate() > 0)
	{
		int iGPPLeft = owner.greatPeopleThresholdNonMilitary() - city.getGreatPeopleProgress();

		if (iGPPLeft > 0)
		{
			int iTurnsLeft = iGPPLeft / city.getGreatPeopleRate();

			if (iTurnsLeft * city.getGreatPeopleRate() <  iGPPLeft)
			{
				iTurnsLeft++;
			}

			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("INTERFACE_CITY_TURNS", std::max(1, iTurnsLeft)));
		}
	}

	iTotalGreatPeopleUnitProgress = 0;

	for (iI = 0; iI < GC.getNumUnitInfos(); ++iI)
	{
		iTotalGreatPeopleUnitProgress += city.getGreatPeopleUnitProgress((UnitTypes)iI);
	}

	if (iTotalGreatPeopleUnitProgress > 0)
	{
		szBuffer.append(SEPARATOR);
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_PROB"));

		std::vector< std::pair<UnitTypes, int> > aUnitProgress;
		int iTotalTruncated = 0;
		for (iI = 0; iI < GC.getNumUnitInfos(); ++iI)
		{
			int iProgress = ((city.getGreatPeopleUnitProgress((UnitTypes)iI) * 100) / iTotalGreatPeopleUnitProgress);
			if (iProgress > 0)
			{
				iTotalTruncated += iProgress;
				aUnitProgress.push_back(std::make_pair((UnitTypes)iI, iProgress));
			}
		}

		if (iTotalTruncated < 100 && !aUnitProgress.empty())
		{
			aUnitProgress[0].second += 100 - iTotalTruncated;
		}

		for (iI = 0; iI < (int)aUnitProgress.size(); iI++)
		{
			szBuffer.append(CvWString::format(L"%s%s - %d%%", NEWLINE, GC.getUnitInfo(aUnitProgress[iI].first).getDescription(), aUnitProgress[iI].second));
		}
	}

// BUG - Building Additional Great People - start
	bool bBuildingAdditionalGreatPeople = getBugOptionBOOL("MiscHover__BuildingAdditionalGreatPeople", true, "BUG_BUILDING_ADDITIONAL_GREAT_PEOPLE_HOVER");
	if (city.getGreatPeopleRate() == 0 && !bBuildingAdditionalGreatPeople)
// BUG - Building Additional Great People - end
	{
		return;
	}

// BUG - Great People Rate Breakdown - start
	if (getBugOptionBOOL("MiscHover__GreatPeopleRateBreakdown", true, "BUG_GREAT_PEOPLE_RATE_BREAKDOWN_HOVER"))
	{
		bool bFirst = true;
		int iRate = 0;
		for (int i = 0; i < GC.getNumSpecialistInfos(); i++)
		{
			int iCount = city.getSpecialistCount((SpecialistTypes)i) + city.getFreeSpecialistCount((SpecialistTypes)i);
			if (iCount > 0)
			{
				iRate += iCount * GC.getSpecialistInfo((SpecialistTypes)i).getGreatPeopleRateChange();
			}
		}
		if (iRate > 0)
		{
			if (bFirst)
			{
				szBuffer.append(SEPARATOR);
				bFirst = false;
			}
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_MISC_HELP_SPECIALIST_COMMERCE", iRate, gDLL->getSymbolID(GREAT_PEOPLE_CHAR), L"TXT_KEY_CONCEPT_SPECIALISTS"));
		}

		iRate = 0;
		for (int i = 0; i < GC.getNumBuildingInfos(); i++)
		{
			int iCount = city.getNumBuilding((BuildingTypes)i);
			if (iCount > 0)
			{
				iRate += iCount * GC.getBuildingInfo((BuildingTypes)i).getGreatPeopleRateChange();
			}
		}
		if (iRate > 0)
		{
			if (bFirst)
			{
				szBuffer.append(SEPARATOR);
				bFirst = false;
			}
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_MISC_HELP_BUILDING_COMMERCE", iRate, gDLL->getSymbolID(GREAT_PEOPLE_CHAR)));
		}
		//Trait Modifier by GP type
		for (int i = 0; i < GC.getNumTraitInfos(); i++)
		{
			iRate = 0;
			if (owner.hasTrait((TraitTypes)i))
			{
				iRate = GC.getTraitInfo((TraitTypes)i).getGreatPeopleRateChange();
				if (iRate > 0)
				{
					if (bFirst)
					{
						szBuffer.append(SEPARATOR);
						bFirst = false;
					}
					szBuffer.append(NEWLINE);
					szBuffer.append(gDLL->getText("TXT_KEY_MISC_HELP_TRAIT_COMMERCE", iRate, gDLL->getSymbolID(GREAT_PEOPLE_CHAR), GC.getTraitInfo((TraitTypes)i).getDescription()));
				}
			}
		}
	}
// BUG - Great People Rate Breakdown - end

	szBuffer.append(SEPARATOR);
	szBuffer.append(NEWLINE);
	szBuffer.append(gDLL->getText("TXT_KEY_MISC_HELP_GREATPEOPLE_BASE_RATE", city.getBaseGreatPeopleRate()));
	szBuffer.append(NEWLINE);

	int iModifier = 100;

	// Buildings
	int iBuildingMod = 0;
	for (int i = 0; i < GC.getNumBuildingInfos(); i++)
	{
		const CvBuildingInfo& infoBuilding = GC.getBuildingInfo((BuildingTypes)i);
		if (city.getNumBuilding((BuildingTypes)i) > 0 && !GET_TEAM(city.getTeam()).isObsoleteBuilding((BuildingTypes)i))
		{
			for (int iLoop = 0; iLoop < city.getNumBuilding((BuildingTypes)i); iLoop++)
			{
				iBuildingMod += infoBuilding.getGreatPeopleRateModifier();
			}
		}
		for (int j = 0; j < MAX_PLAYERS; j++)
		{
			if (GET_PLAYER((PlayerTypes)j).isAlive())
			{
				if (GET_PLAYER((PlayerTypes)j).getTeam() == owner.getTeam())
				{
					foreach_(const CvCity* pLoopCity, GET_PLAYER((PlayerTypes)j).cities())
					{
						if (pLoopCity->getNumBuilding((BuildingTypes)i) > 0 && !GET_TEAM(pLoopCity->getTeam()).isObsoleteBuilding((BuildingTypes)i))
						{
							for (int iLoop = 0; iLoop < pLoopCity->getNumBuilding((BuildingTypes)i); iLoop++)
							{
								iBuildingMod += infoBuilding.getGlobalGreatPeopleRateModifier();
							}
						}
					}
				}
			}
		}
	}
	if (0 != iBuildingMod)
	{
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_HELP_GREATPEOPLE_BUILDINGS", iBuildingMod));
		szBuffer.append(NEWLINE);
		iModifier += iBuildingMod;
	}

	// Civics
	int iCivicMod = 0;
	for (int i = 0; i < GC.getNumCivicOptionInfos(); i++)
	{
		if (NO_CIVIC != owner.getCivics((CivicOptionTypes)i))
		{
			iCivicMod += GC.getCivicInfo(owner.getCivics((CivicOptionTypes)i)).getGreatPeopleRateModifier();
			if (owner.getStateReligion() != NO_RELIGION && city.isHasReligion(owner.getStateReligion()))
			{
				iCivicMod += GC.getCivicInfo(owner.getCivics((CivicOptionTypes)i)).getStateReligionGreatPeopleRateModifier();
			}
		}
	}
	if (0 != iCivicMod)
	{
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_HELP_GREATPEOPLE_CIVICS", iCivicMod));
		szBuffer.append(NEWLINE);
		iModifier += iCivicMod;
	}

	// Trait
	int iTraitMod = 0;
	for (int i = 0; i < GC.getNumTraitInfos(); i++)
	{
		if (owner.hasTrait((TraitTypes)i))
		{
			iTraitMod = 0;
			const CvTraitInfo& trait = GC.getTraitInfo((TraitTypes)i);
			iTraitMod += trait.getGreatPeopleRateModifier();
			if (owner.getStateReligion() != NO_RELIGION && city.isHasReligion(owner.getStateReligion()))
			{
				iTraitMod += trait.getStateReligionGreatPeopleRateModifier();
			}
			if (0 != iTraitMod)
			{
				szBuffer.append(gDLL->getText("TXT_KEY_MISC_HELP_GREATPEOPLE_TRAIT", iTraitMod, trait.getTextKeyWide()));
				szBuffer.append(NEWLINE);
				iModifier += iTraitMod;
			}
		}
	}

	if (owner.isGoldenAge())
	{
		int iGoldenAgeMod = GC.getDefineINT("GOLDEN_AGE_GREAT_PEOPLE_MODIFIER");

		if (0 != iGoldenAgeMod)
		{
			szBuffer.append(gDLL->getText("TXT_KEY_MISC_HELP_GREATPEOPLE_GOLDEN_AGE", iGoldenAgeMod));
			szBuffer.append(NEWLINE);
			iModifier += iGoldenAgeMod;
		}
	}

	int iModGreatPeople = (iModifier * city.getBaseGreatPeopleRate()) / 100;

	FAssertMsg(iModGreatPeople == city.getGreatPeopleRate(), "Great person rate does not match actual value");

	szBuffer.append(gDLL->getText("TXT_KEY_MISC_HELP_GREATPEOPLE_FINAL", iModGreatPeople));

// BUG - Building Additional Great People - start
	if (bBuildingAdditionalGreatPeople && city.getOwner() == GC.getGame().getActivePlayer())
	{
		setBuildingAdditionalGreatPeopleHelp(szBuffer, city, DOUBLE_SEPARATOR);
	}
// BUG - Building Additional Great People - end
}

// BUG - Building Additional Great People - start
bool CvGameTextMgr::setBuildingAdditionalGreatPeopleHelp(CvWStringBuffer &szBuffer, CvCity& city, const CvWString& szStart, bool bStarted)
{
	CvWString szLabel;

	for (int i = 0; i < GC.getNumBuildingInfos(); i++)
	{
		const BuildingTypes eBuilding = static_cast<BuildingTypes>(i);

		if (city.canConstruct(eBuilding, false, false, false))
		{
			const int iChange = city.getAdditionalGreatPeopleRateByBuilding(eBuilding);

			if (iChange != 0)
			{
				if (!bStarted)
				{
					szBuffer.append(szStart);
					bStarted = true;
				}

				szLabel.Format(SETCOLR L"%s" ENDCOLR, TEXT_COLOR("COLOR_BUILDING_TEXT"), GC.getBuildingInfo(eBuilding).getDescription());
				setResumableValueChangeHelp(szBuffer, szLabel, L": ", L"", iChange, gDLL->getSymbolID(GREAT_PEOPLE_CHAR), false, true);
			}
		}
	}

	return bStarted;
}
// BUG - Building Additional Great People - end


void CvGameTextMgr::parseGreatGeneralHelp(CvWStringBuffer &szBuffer, CvPlayer& kPlayer)
{
	szBuffer.append(gDLL->getText("TXT_KEY_MISC_GREAT_MILITARY_PERSON", kPlayer.getCombatExperience(), kPlayer.greatPeopleThresholdMilitary(), GC.getUnitInfo(kPlayer.getGreatGeneralTypetoAssign()).getTextKeyWide()));

	for (int iI = 0; iI < GC.getNumUnitInfos(); iI++)
	{
		UnitTypes eGGType = ((UnitTypes)iI);
		if (kPlayer.getGreatGeneralPointsForType(eGGType) != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_MISC_GREAT_MILITARY_PERSON_BREAKDOWN", GC.getUnitInfo(eGGType).getTextKeyWide(), kPlayer.getGreatGeneralPointsForType(eGGType)));
		}
	}
}


//------------------------------------------------------------------------------------------------

void CvGameTextMgr::buildCityBillboardIconString( CvWStringBuffer& szBuffer, CvCity* pCity)
{
	szBuffer.clear();
/************************************************************************************************/
/* TGA_INDEXATION						  02/18/08								MRGENIE	  */
/*																							  */
/* adding link to resources in the Pedia														*/
/************************************************************************************************/

	CvString szDebugBuffer;
	CvWString szTempBuffer;
/************************************************************************************************/
/* TGA_INDEXATION						  END												  */
/************************************************************************************************/

	// government center icon
	if (pCity->isGovernmentCenter() && !(pCity->isCapital()))
	{
		szBuffer.append(CvWString::format(L"%c", gDLL->getSymbolID(SILVER_STAR_CHAR)));
	}

	// happiness, healthiness, superlative icons
	if (pCity->canBeSelected())
	{
		if (pCity->angryPopulation() > 0)
		{
			szBuffer.append(CvWString::format(L"%c", gDLL->getSymbolID(UNHAPPY_CHAR)));
		}

		if (pCity->healthRate() < 0)
		{
			szBuffer.append(CvWString::format(L"%c", gDLL->getSymbolID(UNHEALTHY_CHAR)));
		}

		if (gDLL->getGraphicOption(GRAPHICOPTION_CITY_DETAIL))
		{
			if (GET_PLAYER(pCity->getOwner()).getNumCities() > 2)
			{
				if (pCity->findYieldRateRank(YIELD_PRODUCTION) == 1)
				{
					szBuffer.append(CvWString::format(L"%c", GC.getYieldInfo(YIELD_PRODUCTION).getChar()));
				}
				if (pCity->findCommerceRateRank(COMMERCE_GOLD) == 1)
				{
					szBuffer.append(CvWString::format(L"%c", GC.getCommerceInfo(COMMERCE_GOLD).getChar()));
				}
				if (pCity->findCommerceRateRank(COMMERCE_RESEARCH) == 1)
				{
					szBuffer.append(CvWString::format(L"%c", GC.getCommerceInfo(COMMERCE_RESEARCH).getChar()));
				}
			}
		}

		if (pCity->isConnectedToCapital())
		{
			if (GET_PLAYER(pCity->getOwner()).countNumCitiesConnectedToCapital() > 1)
			{
				szBuffer.append(CvWString::format(L"%c", gDLL->getSymbolID(TRADE_CHAR)));
			}
		}

// BUG - Airport Icon - start
//Modified by Afforess 4/30/10
		if (getBugOptionBOOL("CityBar__AirportIcons", true, "BUG_CITYBAR_AIRPORT_ICONS"))
		{
			bool bHasAirport = false;
			for (int iBuilding = 0; iBuilding < GC.getNumBuildingInfos(); iBuilding++)
			{
				if (pCity->getNumActiveBuilding((BuildingTypes)iBuilding) > 0)
				{
					//Team Project (5)
					if (!pCity->isReligiouslyDisabledBuilding((BuildingTypes)iBuilding))
					{
						if (GC.getBuildingInfo((BuildingTypes)iBuilding).getAirlift() > 0)
						{
							bHasAirport = true;
							break;
						}
					}
				}
			}
			if (bHasAirport)
			{
				szBuffer.append(CvWString::format(L"%c", gDLL->getSymbolID(AIRPORT_CHAR)));
			}
		}
// BUG - Airport Icon - start
	}

	// religion icons
/************************************************************************************************/
/* TGA_INDEXATION						  02/18/08								MRGENIE	  */
/*																							  */
/* adding link to resources in the Pedia														*/
/************************************************************************************************/
	szDebugBuffer.Format("=== City %S religion icons ===", pCity->getName().GetCString());
	gDLL->logMsg("CvGameTextMgr_buildCityBillboardString.log", szDebugBuffer.c_str());
/************************************************************************************************/
/* TGA_INDEXATION						  END												  */
/************************************************************************************************/
	for (int iI = 0; iI < GC.getNumReligionInfos(); ++iI)
	{
		if (pCity->isHasReligion((ReligionTypes)iI))
		{
			if (pCity->isHolyCity((ReligionTypes)iI))
			{
/************************************************************************************************/
/* TGA_INDEXATION						  02/18/08								MRGENIE	  */
/*																							  */
/* adding link to resources in the Pedia														*/
/************************************************************************************************/
/*
				szBuffer.append(CvWString::format(L"%c", GC.getReligionInfo((ReligionTypes) iI).getHolyCityChar()));
*/
				const CvReligionInfo& pInfo = GC.getReligionInfo((ReligionTypes) iI);
				szDebugBuffer.Format("Religion %s, TGA index %i.", pInfo.getType(), pInfo.getTGAIndex());
				gDLL->logMsg("CvGameTextMgr_buildCityBillboardString.log", szDebugBuffer.c_str());
				szBuffer.append(CvWString::format(L"%c", pInfo.getHolyCityChar()));
			}
			else
			{
/************************************************************************************************/
/* TGA_INDEXATION						  02/18/08								MRGENIE	  */
/*																							  */
/* adding link to resources in the Pedia														*/
/************************************************************************************************/
/*
				szBuffer.append(CvWString::format(L"%c", GC.getReligionInfo((ReligionTypes) iI).getChar()));
*/
				const CvReligionInfo& pInfo = GC.getReligionInfo((ReligionTypes) iI);
				szBuffer.append(CvWString::format(L"%c", pInfo.getChar()));
				if (GC.isXMLLogging())
				{
					szDebugBuffer.Format("Religion %s, TGA index %i.", pInfo.getType(), pInfo.getTGAIndex());
					gDLL->logMsg("CvGameTextMgr_buildCityBillboardString.log", szDebugBuffer.c_str());
				}
/************************************************************************************************/
/* TGA_INDEXATION						  END												  */
/************************************************************************************************/
			}
		}
	}

	// corporation icons
	for (int iI = 0; iI < GC.getNumCorporationInfos(); ++iI)
	{
		if (pCity->isHeadquarters((CorporationTypes)iI))
		{
			if (pCity->isHasCorporation((CorporationTypes)iI))
			{
				szBuffer.append(CvWString::format(L"%c", GC.getCorporationInfo((CorporationTypes) iI).getHeadquarterChar()));
			}
		}
		else
		{
			if (pCity->isActiveCorporation((CorporationTypes)iI))
			{
				szBuffer.append(CvWString::format(L"%c", GC.getCorporationInfo((CorporationTypes) iI).getChar()));
			}
		}
	}

	if (pCity->getTeam() == GC.getGame().getActiveTeam())
	{
		if (pCity->isPower())
		{
			szBuffer.append(CvWString::format(L"%c", gDLL->getSymbolID(POWER_CHAR)));
		}
	}

	// XXX out this in bottom bar???
	if (pCity->isOccupation())
	{
		szBuffer.append(CvWString::format(L" (%c:%d)", gDLL->getSymbolID(OCCUPATION_CHAR), pCity->getOccupationTimer()));
	}

	// defense icon and text
	//if (pCity->getTeam() != GC.getGame().getActiveTeam())
	{
		if (pCity->isVisible(GC.getGame().getActiveTeam(), true))
		{
			int iDefenseModifier = pCity->getDefenseModifier(GC.getGame().selectionListIgnoreBuildingDefense());

			if (iDefenseModifier != 0)
			{
				bool bRed = (iDefenseModifier == pCity->getExtraMinDefense());
				if (!bRed)
				{
					szBuffer.append(CvWString::format(L" %c:%s%d%%", gDLL->getSymbolID(DEFENSE_CHAR), ((iDefenseModifier > 0) ? L"+" : L""), iDefenseModifier));
				}
				else
				{
					szBuffer.append(CvWString::format(SETCOLR L" %c:%s%d%%" ENDCOLR, TEXT_COLOR("COLOR_WARNING_TEXT"), gDLL->getSymbolID(DEFENSE_CHAR), ((iDefenseModifier > 0) ? L"+" : L""), iDefenseModifier));
				}
			}
		}
	}

	if (pCity->getCivilizationType() != GET_PLAYER(pCity->getOwner()).getCivilizationType())
	{
		szBuffer.append(CvWString::format(L" (%s)", GC.getCivilizationInfo(pCity->getCivilizationType()).getShortDescription()));
	}
}

void CvGameTextMgr::buildCityBillboardCityNameString( CvWStringBuffer& szBuffer, CvCity* pCity)
{
	szBuffer.assign(pCity->getName());

	if (pCity->canBeSelected())
	{
		if (gDLL->getGraphicOption(GRAPHICOPTION_CITY_DETAIL))
		{
			if (pCity->foodDifference() > 0)
			{
				int iTurns = pCity->getFoodTurnsLeft();

				if ((iTurns > 1) || !(pCity->AI_isEmphasizeAvoidGrowth()))
				{
					if (iTurns < MAX_INT)
					{
						szBuffer.append(CvWString::format(L" (%d)", iTurns));
					}
				}
			}
// BUG - Starvation Turns - start
			else if (pCity->foodDifference() < 0 && getBugOptionBOOL("CityBar__StarvationTurns", true, "BUG_CITYBAR_STARVATION_TURNS"))
			{
				int iFoodDifference = pCity->foodDifference();
				if (pCity->getFood() + iFoodDifference >= 0)
				{
					int iTurns = pCity->getFood() / -iFoodDifference + 1;
					szBuffer.append(CvWString::format(L" (%d)", iTurns));
				}
				else
				{
					szBuffer.append(L" (!!!)");
				}
			}
// BUG - Starvation Turns - end
		}
	}
}

void CvGameTextMgr::buildCityBillboardProductionString( CvWStringBuffer& szBuffer, CvCity* pCity)
{
	if (pCity->getOrderQueueLength() > 0)
	{
		szBuffer.assign(pCity->getProductionName());

		if (gDLL->getGraphicOption(GRAPHICOPTION_CITY_DETAIL))
		{
			int iTurns = pCity->getProductionTurnsLeft();

			if (iTurns < MAX_INT)
			{
				szBuffer.append(CvWString::format(L" (%d)", iTurns));
			}
		}
	}
	else
	{
		szBuffer.clear();
	}
}


void CvGameTextMgr::buildCityBillboardCitySizeString( CvWStringBuffer& szBuffer, CvCity* pCity, const NiColorA& kColor)
{
#define CAPARAMS(c) (int)((c).r * 255.0f), (int)((c).g * 255.0f), (int)((c).b * 255.0f), (int)((c).a * 255.0f)
	szBuffer.assign(CvWString::format(SETCOLR L"%d" ENDCOLR, CAPARAMS(kColor), pCity->getPopulation()));
#undef CAPARAMS
}

void CvGameTextMgr::getCityBillboardFoodbarColors(CvCity* pCity, std::vector<NiColorA>& aColors)
{
	aColors.resize(NUM_INFOBAR_TYPES);
	aColors[INFOBAR_STORED] = GC.getColorInfo((ColorTypes)(GC.getYieldInfo(YIELD_FOOD).getColorType())).getColor();
	aColors[INFOBAR_RATE] = aColors[INFOBAR_STORED];
	aColors[INFOBAR_RATE].a = 0.5f;
	aColors[INFOBAR_RATE_EXTRA] = GC.getColorInfo((ColorTypes)GC.getInfoTypeForString("COLOR_NEGATIVE_RATE")).getColor();
	aColors[INFOBAR_EMPTY] = GC.getColorInfo((ColorTypes)GC.getInfoTypeForString("COLOR_EMPTY")).getColor();
}

void CvGameTextMgr::getCityBillboardProductionbarColors(CvCity* pCity, std::vector<NiColorA>& aColors)
{
	aColors.resize(NUM_INFOBAR_TYPES);
	aColors[INFOBAR_STORED] = GC.getColorInfo((ColorTypes)(GC.getYieldInfo(YIELD_PRODUCTION).getColorType())).getColor();
	aColors[INFOBAR_RATE] = aColors[INFOBAR_STORED];
	aColors[INFOBAR_RATE].a = 0.5f;
	aColors[INFOBAR_RATE_EXTRA] = GC.getColorInfo((ColorTypes)(GC.getYieldInfo(YIELD_FOOD).getColorType())).getColor();
	aColors[INFOBAR_RATE_EXTRA].a = 0.5f;
	aColors[INFOBAR_EMPTY] = GC.getColorInfo((ColorTypes)GC.getInfoTypeForString("COLOR_EMPTY")).getColor();
}


void CvGameTextMgr::setScoreHelp(CvWStringBuffer &szString, PlayerTypes ePlayer)
{
	if (NO_PLAYER != ePlayer)
	{
		CvPlayer& player = GET_PLAYER(ePlayer);


		int iPop = player.getPopScore();
		int iMaxPop = GC.getGame().getMaxPopulation();
		int iPopScore = 0;
		if (iMaxPop > 0)
		{
			iPopScore = (GC.getDefineINT("SCORE_POPULATION_FACTOR") * iPop) / iMaxPop;
		}
		int iLand = player.getLandScore();
		int iMaxLand = GC.getGame().getMaxLand();
		int iLandScore = 0;
		if (iMaxLand > 0)
		{
			iLandScore = (GC.getDefineINT("SCORE_LAND_FACTOR") * iLand) / iMaxLand;
		}
		int iTech = player.getTechScore();
		int iMaxTech = GC.getGame().getMaxTech();
		int iTechScore = 0;
		if (iMaxTech > 0)
		{
			iTechScore = (GC.getDefineINT("SCORE_TECH_FACTOR") * iTech) / std::max(1, iMaxTech);
		}
		int iWonders = player.getWondersScore();
		int iMaxWonders = GC.getGame().getMaxWonders();
		int iWondersScore = 0;
		if (iMaxWonders > 0)
		{
			iWondersScore = (GC.getDefineINT("SCORE_WONDER_FACTOR") * iWonders) / std::max(1, iMaxWonders);
		}
		int iTotalScore = iPopScore + iLandScore + iTechScore + iWondersScore;
		int iVictoryScore = player.calculateScore(true, true);
		szString.append(gDLL->getText("TXT_KEY_SCORE_BREAKDOWN",
			iPopScore, iPop, iMaxPop, iLandScore, iLand, iMaxLand, iTechScore,
			iTech, iMaxTech, iWondersScore, iWonders, iMaxWonders, iTotalScore, iVictoryScore)
		);
		szString.append(gDLL->getText("TXT_KEY_SCORE_DIFFICULTY_LEVEL", GC.getHandicapInfo(player.getHandicapType()).getTextKeyWide()));
	}
}

void CvGameTextMgr::setEventHelp(CvWStringBuffer& szBuffer, EventTypes eEvent, int iEventTriggeredId, PlayerTypes ePlayer)
{
	if (NO_EVENT == eEvent || NO_PLAYER == ePlayer)
	{
		return;
	}

	const CvEventInfo& kEvent = GC.getEventInfo(eEvent);
	CvPlayer& kActivePlayer = GET_PLAYER(ePlayer);
	const EventTriggeredData* pTriggeredData = kActivePlayer.getEventTriggered(iEventTriggeredId);

	if (NULL == pTriggeredData)
	{
		return;
	}

	CvCity* pCity = kActivePlayer.getCity(pTriggeredData->m_iCityId);
	CvCity* pOtherPlayerCity = NULL;
	CvPlot* pPlot = GC.getMap().plot(pTriggeredData->m_iPlotX, pTriggeredData->m_iPlotY);
	CvUnit* pUnit = kActivePlayer.getUnit(pTriggeredData->m_iUnitId);

	if (NO_PLAYER != pTriggeredData->m_eOtherPlayer)
	{
		pOtherPlayerCity = GET_PLAYER(pTriggeredData->m_eOtherPlayer).getCity(pTriggeredData->m_iOtherPlayerCityId);
	}

	CvWString szCity = gDLL->getText("TXT_KEY_EVENT_THE_CITY");
	if (NULL != pCity && kEvent.isCityEffect())
	{
		szCity = pCity->getNameKey();
	}
	else if (NULL != pOtherPlayerCity && kEvent.isOtherPlayerCityEffect())
	{
		szCity = pOtherPlayerCity->getNameKey();
	}

	CvWString szUnit = gDLL->getText("TXT_KEY_EVENT_THE_UNIT");
	if (NULL != pUnit)
	{
		szUnit = pUnit->getNameKey();
	}

	CvWString szReligion = gDLL->getText("TXT_KEY_EVENT_THE_RELIGION");
	if (NO_RELIGION != pTriggeredData->m_eReligion)
	{
		szReligion = GC.getReligionInfo(pTriggeredData->m_eReligion).getTextKeyWide();
	}

	eventGoldHelp(szBuffer, eEvent, ePlayer, pTriggeredData->m_eOtherPlayer);

	eventTechHelp(szBuffer, eEvent, kActivePlayer.getBestEventTech(eEvent, pTriggeredData->m_eOtherPlayer), ePlayer, pTriggeredData->m_eOtherPlayer);

	if (NO_PLAYER != pTriggeredData->m_eOtherPlayer && NO_BONUS != kEvent.getBonusGift())
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_EVENT_GIFT_BONUS_TO_PLAYER", GC.getBonusInfo((BonusTypes)kEvent.getBonusGift()).getTextKeyWide(), GET_PLAYER(pTriggeredData->m_eOtherPlayer).getNameKey()));
	}

	if (kEvent.getHappy() != 0)
	{
		if (NO_PLAYER != pTriggeredData->m_eOtherPlayer)
		{
			if (kEvent.getHappy() > 0)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_EVENT_HAPPY_FROM_PLAYER", kEvent.getHappy(), kEvent.getHappy(), GET_PLAYER(pTriggeredData->m_eOtherPlayer).getNameKey()));
			}
			else
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_EVENT_HAPPY_TO_PLAYER", -kEvent.getHappy(), -kEvent.getHappy(), GET_PLAYER(pTriggeredData->m_eOtherPlayer).getNameKey()));
			}
		}
		else
		{
			if (kEvent.getHappy() > 0)
			{
				if (kEvent.isCityEffect() || kEvent.isOtherPlayerCityEffect())
				{
					szBuffer.append(NEWLINE);
					szBuffer.append(gDLL->getText("TXT_KEY_EVENT_HAPPY_CITY", kEvent.getHappy(), szCity.GetCString()));
				}
				else
				{
					szBuffer.append(NEWLINE);
					szBuffer.append(gDLL->getText("TXT_KEY_EVENT_HAPPY", kEvent.getHappy()));
				}
			}
			else
			{
				if (kEvent.isCityEffect() || kEvent.isOtherPlayerCityEffect())
				{
					szBuffer.append(NEWLINE);
					szBuffer.append(gDLL->getText("TXT_KEY_EVENT_UNHAPPY_CITY", -kEvent.getHappy(), szCity.GetCString()));
				}
				else
				{
					szBuffer.append(NEWLINE);
					szBuffer.append(gDLL->getText("TXT_KEY_EVENT_UNHAPPY", -kEvent.getHappy()));
				}
			}
		}
	}

	if (kEvent.getHealth() != 0)
	{
		if (NO_PLAYER != pTriggeredData->m_eOtherPlayer)
		{
			if (kEvent.getHealth() > 0)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_EVENT_HEALTH_FROM_PLAYER", kEvent.getHealth(), kEvent.getHealth(), GET_PLAYER(pTriggeredData->m_eOtherPlayer).getNameKey()));
			}
			else
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_EVENT_HEALTH_TO_PLAYER", -kEvent.getHealth(), -kEvent.getHealth(), GET_PLAYER(pTriggeredData->m_eOtherPlayer).getNameKey()));
			}
		}
		else
		{
			if (kEvent.getHealth() > 0)
			{
				if (kEvent.isCityEffect() || kEvent.isOtherPlayerCityEffect())
				{
					szBuffer.append(NEWLINE);
					szBuffer.append(gDLL->getText("TXT_KEY_EVENT_HEALTH_CITY", kEvent.getHealth(), szCity.GetCString()));
				}
				else
				{
					szBuffer.append(NEWLINE);
					szBuffer.append(gDLL->getText("TXT_KEY_EVENT_HEALTH", kEvent.getHealth()));
				}
			}
			else
			{
				if (kEvent.isCityEffect() || kEvent.isOtherPlayerCityEffect())
				{
					szBuffer.append(NEWLINE);
					szBuffer.append(gDLL->getText("TXT_KEY_EVENT_UNHEALTH", -kEvent.getHealth(), szCity.GetCString()));
				}
				else
				{
					szBuffer.append(NEWLINE);
					szBuffer.append(gDLL->getText("TXT_KEY_EVENT_UNHEALTH_CITY", -kEvent.getHealth()));
				}
			}
		}
	}

	if (kEvent.getHurryAnger() != 0)
	{
		if (kEvent.isCityEffect() || kEvent.isOtherPlayerCityEffect())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_EVENT_HURRY_ANGER_CITY", kEvent.getHurryAnger(), szCity.GetCString()));
		}
		else
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_EVENT_HURRY_ANGER", kEvent.getHurryAnger()));
		}
	}

	if (kEvent.getHappyTurns() > 0)
	{
		if (kEvent.isCityEffect() || kEvent.isOtherPlayerCityEffect())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_EVENT_TEMP_HAPPY_CITY", GC.getTEMP_HAPPY(), kEvent.getHappyTurns(), szCity.GetCString()));
		}
		else
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_EVENT_TEMP_HAPPY", GC.getTEMP_HAPPY(), kEvent.getHappyTurns()));
		}
	}

	if (kEvent.getFood() != 0)
	{
		if (kEvent.isCityEffect() || kEvent.isOtherPlayerCityEffect())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_EVENT_FOOD_CITY", kEvent.getFood(), szCity.GetCString()));
		}
		else
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_EVENT_FOOD", kEvent.getFood()));
		}
	}

	if (kEvent.getFoodPercent() != 0)
	{
		if (kEvent.isCityEffect() || kEvent.isOtherPlayerCityEffect())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_EVENT_FOOD_PERCENT_CITY", kEvent.getFoodPercent(), szCity.GetCString()));
		}
		else
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_EVENT_FOOD_PERCENT", kEvent.getFoodPercent()));
		}
	}

	if (kEvent.getRevoltTurns() > 0)
	{
		if (kEvent.isCityEffect() || kEvent.isOtherPlayerCityEffect())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_EVENT_REVOLT_TURNS", kEvent.getRevoltTurns(), szCity.GetCString()));
		}
	}

	if (0 != kEvent.getSpaceProductionModifier())
	{
		if (kEvent.isCityEffect() || kEvent.isOtherPlayerCityEffect())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_EVENT_SPACE_PRODUCTION_CITY", kEvent.getSpaceProductionModifier(), szCity.GetCString()));
		}
		else
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_SPACESHIP_MOD_ALL_CITIES", kEvent.getSpaceProductionModifier()));
		}
	}

	if (kEvent.getMaxPillage() > 0)
	{
		if (kEvent.isCityEffect() || kEvent.isOtherPlayerCityEffect())
		{
			if (kEvent.getMaxPillage() == kEvent.getMinPillage())
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_EVENT_PILLAGE_CITY", kEvent.getMinPillage(), szCity.GetCString()));
			}
			else
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_EVENT_PILLAGE_RANGE_CITY", kEvent.getMinPillage(), kEvent.getMaxPillage(), szCity.GetCString()));
			}
		}
		else
		{
			if (kEvent.getMaxPillage() == kEvent.getMinPillage())
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_EVENT_PILLAGE", kEvent.getMinPillage()));
			}
			else
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_EVENT_PILLAGE_RANGE", kEvent.getMinPillage(), kEvent.getMaxPillage()));
			}
		}
	}

	for (int i = 0; i < GC.getNumSpecialistInfos(); ++i)
	{
		if (kEvent.getFreeSpecialistCount(i) > 0)
		{
			if (kEvent.isCityEffect() || kEvent.isOtherPlayerCityEffect())
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_EVENT_FREE_SPECIALIST", kEvent.getFreeSpecialistCount(i), GC.getSpecialistInfo((SpecialistTypes)i).getTextKeyWide(), szCity.GetCString()));
			}
		}
	}

	if (kEvent.getPopulationChange() != 0)
	{
		if (kEvent.isCityEffect() || kEvent.isOtherPlayerCityEffect())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_EVENT_POPULATION_CHANGE_CITY", kEvent.getPopulationChange(), szCity.GetCString()));
		}
		else
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_EVENT_POPULATION_CHANGE", kEvent.getPopulationChange()));
		}
	}

	if (kEvent.getCulture() != 0)
	{
		if (kEvent.isCityEffect() || kEvent.isOtherPlayerCityEffect())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_EVENT_CULTURE_CITY", kEvent.getCulture(), szCity.GetCString()));
		}
		else
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_EVENT_CULTURE", kEvent.getCulture()));
		}
	}

	if (kEvent.getFreeUnit() != NO_UNIT)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_EVENT_BONUS_UNIT", kEvent.getNumUnits(), GC.getUnitInfo((UnitTypes) kEvent.getFreeUnit()).getTextKeyWide()));
	}

	const BuildingTypes eBuilding = static_cast<BuildingTypes>(kEvent.getBuilding());
	if (eBuilding != NO_BUILDING)
	{
		if (kEvent.getBuildingChange() > 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_EVENT_BONUS_BUILDING", GC.getBuildingInfo(eBuilding).getTextKeyWide()));
		}
		else if (kEvent.getBuildingChange() < 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_EVENT_REMOVE_BUILDING", GC.getBuildingInfo(eBuilding).getTextKeyWide()));
		}
	}

	if (kEvent.getNumBuildingYieldChanges() > 0)
	{
		for (int iBuilding = 0; iBuilding < GC.getNumBuildingInfos(); ++iBuilding)
		{
			const BuildingTypes eBuilding = static_cast<BuildingTypes>(iBuilding);
			if (pCity == NULL || pCity->getNumBuilding(eBuilding) > 0)
			{
				int aiYields[NUM_YIELD_TYPES];
				for (int iYield = 0; iYield < NUM_YIELD_TYPES; ++iYield)
				{
					aiYields[iYield] = kEvent.getBuildingYieldChange(iBuilding, iYield);
				}

				CvWStringBuffer szYield;
				szYield.clear();
				setYieldChangeHelp(szYield, L"", L"", L"", aiYields, false, false);
				if (!szYield.isEmpty())
				{
					szBuffer.append(NEWLINE);
					szBuffer.append(gDLL->getText("TXT_KEY_EVENT_YIELD_CHANGE_BUILDING", GC.getBuildingInfo(eBuilding).getTextKeyWide(), szYield.getCString()));
				}
			}
		}
	}

	if (kEvent.getNumBuildingCommerceChanges() > 0)
	{
		for (int iBuilding = 0; iBuilding < GC.getNumBuildingInfos(); ++iBuilding)
		{
			const BuildingTypes eBuilding = static_cast<BuildingTypes>(iBuilding);
			if (pCity == NULL || pCity->getNumBuilding(eBuilding) > 0)
			{
				int aiCommerces[NUM_COMMERCE_TYPES];
				for (int iCommerce = 0; iCommerce < NUM_COMMERCE_TYPES; ++iCommerce)
				{
					aiCommerces[iCommerce] = kEvent.getBuildingCommerceChange(iBuilding, iCommerce);
				}

				CvWStringBuffer szCommerce;
				szCommerce.clear();
				setCommerceChangeHelp(szCommerce, L"", L"", L"", aiCommerces, false, false);
				if (!szCommerce.isEmpty())
				{
					szBuffer.append(NEWLINE);
					szBuffer.append(gDLL->getText("TXT_KEY_EVENT_YIELD_CHANGE_BUILDING", GC.getBuildingInfo(eBuilding).getTextKeyWide(), szCommerce.getCString()));
				}
			}
		}
	}

	if (kEvent.getNumBuildingHappyChanges() > 0)
	{
		for (int iBuilding = 0; iBuilding < GC.getNumBuildingInfos(); ++iBuilding)
		{
			const BuildingTypes eBuilding = static_cast<BuildingTypes>(iBuilding);
			if (pCity == NULL || pCity->getNumBuilding(eBuilding) > 0)
			{
				const int iHappy = kEvent.getBuildingHappyChange(iBuilding);
				if (iHappy > 0)
				{
					szBuffer.append(NEWLINE);
					szBuffer.append(gDLL->getText("TXT_KEY_EVENT_HAPPY_BUILDING", GC.getBuildingInfo(eBuilding).getTextKeyWide(), iHappy, gDLL->getSymbolID(HAPPY_CHAR)));
				}
				else if (iHappy < 0)
				{
					szBuffer.append(NEWLINE);
					szBuffer.append(gDLL->getText("TXT_KEY_EVENT_HAPPY_BUILDING", GC.getBuildingInfo(eBuilding).getTextKeyWide(), -iHappy, gDLL->getSymbolID(UNHAPPY_CHAR)));
				}
			}
		}
	}

	if (kEvent.getNumBuildingHealthChanges() > 0)
	{
		for (int iBuilding = 0; iBuilding < GC.getNumBuildingInfos(); ++iBuilding)
		{
			const BuildingTypes eBuilding = static_cast<BuildingTypes>(iBuilding);
			if (pCity == NULL || pCity->getNumBuilding(eBuilding) > 0)
			{
				const int iHealth = kEvent.getBuildingHealthChange(iBuilding);
				if (iHealth > 0)
				{
					szBuffer.append(NEWLINE);
					szBuffer.append(gDLL->getText("TXT_KEY_EVENT_HAPPY_BUILDING", GC.getBuildingInfo(eBuilding).getTextKeyWide(), iHealth, gDLL->getSymbolID(HEALTHY_CHAR)));
				}
				else if (iHealth < 0)
				{
					szBuffer.append(NEWLINE);
					szBuffer.append(gDLL->getText("TXT_KEY_EVENT_HAPPY_BUILDING", GC.getBuildingInfo(eBuilding).getTextKeyWide(), -iHealth, gDLL->getSymbolID(UNHEALTHY_CHAR)));
				}
			}
		}
	}

	if (kEvent.getRevolutionIndexChange() != 0)
	{
		if (kEvent.isCityEffect() || kEvent.isOtherPlayerCityEffect())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_EVENT_REVOLUTION_INDEX_CITY"));
		}
		else
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_EVENT_REVOLUTION_INDEX"));
		}
	}

	if (kEvent.getFeatureChange() > 0)
	{
		if (kEvent.getFeature() != NO_FEATURE)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_EVENT_FEATURE_GROWTH", GC.getFeatureInfo((FeatureTypes)kEvent.getFeature()).getTextKeyWide()));
		}
	}
	else if (kEvent.getFeatureChange() < 0)
	{
		if (NULL != pPlot && NO_FEATURE != pPlot->getFeatureType())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_EVENT_FEATURE_REMOVE", GC.getFeatureInfo(pPlot->getFeatureType()).getTextKeyWide()));
		}
	}

	if (kEvent.getImprovementChange() > 0)
	{
		if (kEvent.getImprovement() != NO_IMPROVEMENT)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_EVENT_IMPROVEMENT_GROWTH", GC.getImprovementInfo((ImprovementTypes)kEvent.getImprovement()).getTextKeyWide()));
		}
	}
	else if (kEvent.getImprovementChange() < 0)
	{
		if (NULL != pPlot && NO_IMPROVEMENT != pPlot->getImprovementType())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_EVENT_IMPROVEMENT_REMOVE", GC.getImprovementInfo(pPlot->getImprovementType()).getTextKeyWide()));
		}
	}

	if (kEvent.getBonusChange() > 0)
	{
		if (kEvent.getBonus() != NO_BONUS)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_EVENT_BONUS_GROWTH", GC.getBonusInfo((BonusTypes)kEvent.getBonus()).getTextKeyWide()));
		}
	}
	else if (kEvent.getBonusChange() < 0)
	{
		if (NULL != pPlot && NO_BONUS != pPlot->getBonusType())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_EVENT_BONUS_REMOVE", GC.getBonusInfo(pPlot->getBonusType()).getTextKeyWide()));
		}
	}

	if (kEvent.getRouteChange() > 0)
	{
		if (kEvent.getRoute() != NO_ROUTE)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_EVENT_ROUTE_GROWTH", GC.getRouteInfo((RouteTypes)kEvent.getRoute()).getTextKeyWide()));
		}
	}
	else if (kEvent.getRouteChange() < 0)
	{
		if (NULL != pPlot && NO_ROUTE != pPlot->getRouteType())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_EVENT_ROUTE_REMOVE", GC.getRouteInfo(pPlot->getRouteType()).getTextKeyWide()));
		}
	}

	int aiYields[NUM_YIELD_TYPES];
	for (int i = 0; i < NUM_YIELD_TYPES; ++i)
	{
		aiYields[i] = kEvent.getPlotExtraYield(i);
	}

	CvWStringBuffer szYield;
	setYieldChangeHelp(szYield, L"", L"", L"", aiYields, false, false);
	if (!szYield.isEmpty())
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_EVENT_YIELD_CHANGE_PLOT", szYield.getCString()));
	}

	if (NO_BONUS != kEvent.getBonusRevealed())
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_EVENT_BONUS_REVEALED", GC.getBonusInfo((BonusTypes)kEvent.getBonusRevealed()).getTextKeyWide()));
	}

	if (0 != kEvent.getUnitExperience())
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_EVENT_UNIT_EXPERIENCE", kEvent.getUnitExperience(), szUnit.GetCString()));
	}

	if (0 != kEvent.isDisbandUnit())
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_EVENT_UNIT_DISBAND", szUnit.GetCString()));
	}

	for (int i = 0; i < GC.getNumUnitCombatInfos(); ++i)
	{
		if (NO_PROMOTION != kEvent.getUnitCombatPromotion(i))
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_EVENT_UNIT_COMBAT_PROMOTION", GC.getUnitCombatInfo((UnitCombatTypes)i).getTextKeyWide(), GC.getPromotionInfo((PromotionTypes)kEvent.getUnitCombatPromotion(i)).getTextKeyWide()));
		}
	}

	for (int i = 0; i < GC.getNumUnitInfos(); ++i)
	{
		if (NO_PROMOTION != kEvent.getUnitPromotion(i))
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_EVENT_UNIT_CLASS_PROMOTION", GC.getUnitInfo((UnitTypes) i).getTextKeyWide(), GC.getPromotionInfo((PromotionTypes)kEvent.getUnitPromotion(i)).getTextKeyWide()));
		}
	}

	if (kEvent.getConvertOwnCities() > 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_EVENT_CONVERT_OWN_CITIES", kEvent.getConvertOwnCities(), szReligion.GetCString()));
	}

	if (kEvent.getConvertOtherCities() > 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_EVENT_CONVERT_OTHER_CITIES", kEvent.getConvertOtherCities(), szReligion.GetCString()));
	}

	if (NO_PLAYER != pTriggeredData->m_eOtherPlayer)
	{
		if (kEvent.getAttitudeModifier() > 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_EVENT_ATTITUDE_GOOD", kEvent.getAttitudeModifier(), GET_PLAYER(pTriggeredData->m_eOtherPlayer).getNameKey()));
		}
		else if (kEvent.getAttitudeModifier() < 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_EVENT_ATTITUDE_BAD", kEvent.getAttitudeModifier(), GET_PLAYER(pTriggeredData->m_eOtherPlayer).getNameKey()));
		}

		TeamTypes eWorstEnemy = GET_TEAM(GET_PLAYER(pTriggeredData->m_eOtherPlayer).getTeam()).AI_getWorstEnemy();
		if (NO_TEAM != eWorstEnemy)
		{
			if (kEvent.getTheirEnemyAttitudeModifier() > 0)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_EVENT_ATTITUDE_GOOD", kEvent.getTheirEnemyAttitudeModifier(), GET_TEAM(eWorstEnemy).getName().GetCString()));
			}
			else if (kEvent.getTheirEnemyAttitudeModifier() < 0)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_EVENT_ATTITUDE_BAD", kEvent.getTheirEnemyAttitudeModifier(), GET_TEAM(eWorstEnemy).getName().GetCString()));
			}
		}

		if (kEvent.getEspionagePoints() > 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_EVENT_ESPIONAGE_POINTS", kEvent.getEspionagePoints(), GET_PLAYER(pTriggeredData->m_eOtherPlayer).getNameKey()));
		}
		else if (kEvent.getEspionagePoints() < 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_EVENT_ESPIONAGE_COST", -kEvent.getEspionagePoints()));
		}
	}

	if (kEvent.isGoldenAge())
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_EVENT_GOLDEN_AGE"));
	}

	if (0 != kEvent.getFreeUnitSupport())
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_EVENT_FREE_UNIT_SUPPORT", kEvent.getFreeUnitSupport()));
	}

	if (0 != kEvent.getInflationModifier())
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_EVENT_INFLATION_MODIFIER", kEvent.getInflationModifier()));
	}

	if (kEvent.isDeclareWar())
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_EVENT_DECLARE_WAR", GET_PLAYER(pTriggeredData->m_eOtherPlayer).getCivilizationAdjectiveKey()));
	}

	if (kEvent.getUnitImmobileTurns() > 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_EVENT_IMMOBILE_UNIT", kEvent.getUnitImmobileTurns(), szUnit.GetCString()));
	}

	if (kEvent.isCityEffect())
		kEvent.getProperties()->buildChangesString(szBuffer, &szCity);

	kEvent.getPropertiesAllCities()->buildChangesAllCitiesString(szBuffer);

	if (!CvWString(kEvent.getPythonHelp()).empty())
	{
		CvWString szHelp = Cy::call<CvWString>(PYRandomEventModule, kEvent.getPythonHelp(), Cy::Args() << eEvent << pTriggeredData);
		szBuffer.append(NEWLINE);
		szBuffer.append(szHelp);
	}

	CvWStringBuffer szTemp;
	for (int i = 0; i < GC.getNumEventInfos(); ++i)
	{
		if (0 == kEvent.getAdditionalEventTime(i))
		{
			if (kEvent.getAdditionalEventChance(i) > 0 && kActivePlayer.canDoEvent((EventTypes)i, *pTriggeredData))
			{
				szTemp.clear();
				setEventHelp(szTemp, (EventTypes)i, iEventTriggeredId, ePlayer);

				if (!szTemp.isEmpty())
				{
					szBuffer.append(NEWLINE);
					szBuffer.append(gDLL->getText("TXT_KEY_EVENT_ADDITIONAL_CHANCE", kEvent.getAdditionalEventChance(i), L""));
					szBuffer.append(NEWLINE);
					szBuffer.append(szTemp);
				}
			}
		}
		else
		{
			szTemp.clear();
			setEventHelp(szTemp, (EventTypes)i, iEventTriggeredId, ePlayer);

			if (!szTemp.isEmpty())
			{
				CvWString szDelay = gDLL->getText("TXT_KEY_EVENT_DELAY_TURNS", (GC.getGameSpeedInfo(GC.getGame().getGameSpeedType()).getGrowthPercent() * kEvent.getAdditionalEventTime((EventTypes)i)) / 100);

				if (kEvent.getAdditionalEventChance(i) > 0)
				{
					szBuffer.append(NEWLINE);
					szBuffer.append(gDLL->getText("TXT_KEY_EVENT_ADDITIONAL_CHANCE", kEvent.getAdditionalEventChance(i), szDelay.GetCString()));
				}
				else
				{
					szBuffer.append(NEWLINE);
					szBuffer.append(gDLL->getText("TXT_KEY_EVENT_DELAY", szDelay.GetCString()));
				}

				szBuffer.append(NEWLINE);
				szBuffer.append(szTemp);
			}
		}
	}

	if (NO_TECH != kEvent.getPrereqTech() && !GET_TEAM(kActivePlayer.getTeam()).isHasTech((TechTypes)kEvent.getPrereqTech()))
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_REQUIRES_STRING", CvWString(GC.getTechInfo((TechTypes)(kEvent.getPrereqTech())).getType()).GetCString(), GC.getTechInfo((TechTypes)(kEvent.getPrereqTech())).getTextKeyWide()));
	}

	bool done = false;
	while(!done)
	{
		done = true;
		if(!szBuffer.isEmpty())
		{
			const wchar_t* wideChar = szBuffer.getCString();
			if(wideChar[0] == L'\n')
			{
				CvWString tempString(&wideChar[1]);
				szBuffer.clear();
				szBuffer.append(tempString);
				done = false;
			}
		}
	}
}

void CvGameTextMgr::eventTechHelp(CvWStringBuffer& szBuffer, EventTypes eEvent, TechTypes eTech, PlayerTypes eActivePlayer, PlayerTypes eOtherPlayer)
{
	const CvEventInfo& kEvent = GC.getEventInfo(eEvent);

	if (eTech != NO_TECH)
	{
		if (100 == kEvent.getTechPercent())
		{
			if (NO_PLAYER != eOtherPlayer)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_EVENT_TECH_GAINED_FROM_PLAYER", GC.getTechInfo(eTech).getTextKeyWide(), GET_PLAYER(eOtherPlayer).getNameKey()));
			}
			else
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_EVENT_TECH_GAINED", GC.getTechInfo(eTech).getTextKeyWide()));
			}
		}
		else if (0 != kEvent.getTechPercent())
		{
			CvTeam& kTeam = GET_TEAM(GET_PLAYER(eActivePlayer).getTeam());
			int iBeakers = (kTeam.getResearchCost(eTech) * kEvent.getTechPercent()) / 100;
			if (kEvent.getTechPercent() > 0)
			{
				iBeakers = std::min(kTeam.getResearchLeft(eTech), iBeakers);
			}
			else if (kEvent.getTechPercent() < 0)
			{
				iBeakers = std::max(kTeam.getResearchLeft(eTech) - kTeam.getResearchCost(eTech), iBeakers);
			}

			if (NO_PLAYER != eOtherPlayer)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_EVENT_TECH_GAINED_FROM_PLAYER_PERCENT", iBeakers, GC.getTechInfo(eTech).getTextKeyWide(), GET_PLAYER(eOtherPlayer).getNameKey()));
			}
			else
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_EVENT_TECH_GAINED_PERCENT", iBeakers, GC.getTechInfo(eTech).getTextKeyWide()));
			}
		}
	}
}

void CvGameTextMgr::eventGoldHelp(CvWStringBuffer& szBuffer, EventTypes eEvent, PlayerTypes ePlayer, PlayerTypes eOtherPlayer)
{
	const CvEventInfo& kEvent = GC.getEventInfo(eEvent);
	CvPlayer& kPlayer = GET_PLAYER(ePlayer);

	int iGold1 = kPlayer.getEventCost(eEvent, eOtherPlayer, false);
	int iGold2 = kPlayer.getEventCost(eEvent, eOtherPlayer, true);

	if (iGold1 != iGold2) iGold2 = abs(iGold2);

	if (0 != iGold1 || 0 != iGold2)
	{
		if (iGold1 == iGold2)
		{
			if (NO_PLAYER != eOtherPlayer && kEvent.isGoldToPlayer())
			{
				if (iGold1 > 0)
				{
					szBuffer.append(NEWLINE);
					szBuffer.append(gDLL->getText("TXT_KEY_EVENT_GOLD_FROM_PLAYER", iGold1, GET_PLAYER(eOtherPlayer).getNameKey()));
				}
				else
				{
					szBuffer.append(NEWLINE);
					szBuffer.append(gDLL->getText("TXT_KEY_EVENT_GOLD_TO_PLAYER", -iGold1, GET_PLAYER(eOtherPlayer).getNameKey()));
				}
			}
			else
			{
				if (iGold1 > 0)
				{
					szBuffer.append(NEWLINE);
					szBuffer.append(gDLL->getText("TXT_KEY_EVENT_GOLD_GAINED", iGold1));
				}
				else
				{
					szBuffer.append(NEWLINE);
					szBuffer.append(gDLL->getText("TXT_KEY_EVENT_GOLD_LOST", -iGold1));
				}
			}
		}
		else
		{
			if (NO_PLAYER != eOtherPlayer && kEvent.isGoldToPlayer())
			{
				if (iGold1 > 0)
				{
					szBuffer.append(NEWLINE);
					szBuffer.append(gDLL->getText("TXT_KEY_EVENT_GOLD_RANGE_FROM_PLAYER", iGold1, iGold2, GET_PLAYER(eOtherPlayer).getNameKey()));
				}
				else
				{
					szBuffer.append(NEWLINE);
					szBuffer.append(gDLL->getText("TXT_KEY_EVENT_GOLD_RANGE_TO_PLAYER", -iGold1, -iGold2, GET_PLAYER(eOtherPlayer).getNameKey()));
				}
			}
			else
			{
				if (iGold1 > 0)
				{
					szBuffer.append(NEWLINE);
					szBuffer.append(gDLL->getText("TXT_KEY_EVENT_GOLD_RANGE_GAINED", iGold1, iGold2));
				}
				else
				{
					szBuffer.append(NEWLINE);
					szBuffer.append(gDLL->getText("TXT_KEY_EVENT_GOLD_RANGE_LOST", -iGold1, iGold2));
				}
			}
		}
	}
}

void CvGameTextMgr::setTradeRouteHelp(CvWStringBuffer &szBuffer, int iRoute, CvCity* pCity)
{
	if (NULL != pCity)
	{
		CvCity* pOtherCity = pCity->getTradeCity(iRoute);

		if (NULL != pOtherCity)
		{
			szBuffer.append(pOtherCity->getName());

			int iProfit = pCity->getBaseTradeProfit(pOtherCity);

			szBuffer.append(NEWLINE);
			CvWString szBaseProfit;
			szBaseProfit.Format(L"%d.%02d", iProfit/100, iProfit%100);
			szBuffer.append(gDLL->getText("TXT_KEY_TRADE_ROUTE_HELP_BASE", szBaseProfit.GetCString()));

			int iModifier = 100;
			int iTestValue = pCity->getTradeRouteModifier();
			int iValue = 0;
			int iTradeRouteModifier = 0;
			// getTradeRouteModifier()
			for (int iBuilding = 0; iBuilding < GC.getNumBuildingInfos(); ++iBuilding)
			{
				if (pCity->getNumActiveBuilding((BuildingTypes)iBuilding) > 0 && !pCity->isReligiouslyDisabledBuilding((BuildingTypes)iBuilding))
				{
					iValue = pCity->getNumActiveBuilding((BuildingTypes)iBuilding) * GC.getBuildingInfo((BuildingTypes)iBuilding).getTradeRouteModifier();
					if (0 != iValue)
					{
						szBuffer.append(NEWLINE);
						szBuffer.append(gDLL->getText("TXT_KEY_TRADE_ROUTE_MOD_BUILDING", GC.getBuildingInfo((BuildingTypes)iBuilding).getTextKeyWide(), iValue));
						iTradeRouteModifier += iValue;
					}
				}
			}
			FAssert(iTradeRouteModifier == iTestValue); // Toffer - This one triggers - 21.07.20
			// I can only speculate that replaced/obsolete buildings are not being processed in and out correctly during recalc.

			iModifier += iTradeRouteModifier;

			iValue = pCity->getPopulationTradeModifier();
			if (0 != iValue)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_TRADE_ROUTE_MOD_POPULATION", iValue));
				iModifier += iValue;
			}

			if (pCity->isConnectedToCapital())
			{
				iValue = GC.getDefineINT("CAPITAL_TRADE_MODIFIER");
				if (0 != iValue)
				{
					szBuffer.append(NEWLINE);
					szBuffer.append(gDLL->getText("TXT_KEY_TRADE_ROUTE_MOD_CAPITAL", iValue));
					iModifier += iValue;
				}
			}

			iValue = GET_TEAM(pCity->getTeam()).getTradeModifier();
			if (0 != iValue)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_TRADE_ROUTE_TECH", iValue));
				iModifier += iValue;
			}

			if (NULL != pOtherCity)
			{
				if (pCity->area() != pOtherCity->area())
				{
					iValue = GC.getDefineINT("OVERSEAS_TRADE_MODIFIER");
					if (0 != iValue)
					{
						szBuffer.append(NEWLINE);
						szBuffer.append(gDLL->getText("TXT_KEY_TRADE_ROUTE_MOD_OVERSEAS", iValue));
						iModifier += iValue;
					}
				}

				if (pCity->getTeam() != pOtherCity->getTeam())
				{
					iValue = pCity->getForeignTradeRouteModifier();

					iValue += GET_TEAM(pCity->getTeam()).getForeignTradeModifier();
					iValue += GET_PLAYER(pCity->getOwner()).getForeignTradeRouteModifier();
					for (int iI = 0; iI < GC.getNumCivicOptionInfos(); iI++)
					{
						if (GET_PLAYER(pCity->getOwner()).getCivics((CivicOptionTypes)iI) == GET_PLAYER(pOtherCity->getOwner()).getCivics((CivicOptionTypes)iI))
						{
							if (GET_PLAYER(pCity->getOwner()).getCivics((CivicOptionTypes)iI) != NO_CIVIC)
							{
								iValue += GC.getCivicInfo(GET_PLAYER(pCity->getOwner()).getCivics((CivicOptionTypes)iI)).getSharedCivicTradeRouteModifier();
							}
						}
					}

					if (0 != iValue)
					{
						szBuffer.append(NEWLINE);
						szBuffer.append(gDLL->getText("TXT_KEY_TRADE_ROUTE_MOD_FOREIGN", iValue));
						iModifier += iValue;
					}

					iValue = pCity->getPeaceTradeModifier(pOtherCity->getTeam());
					if (0 != iValue)
					{
						szBuffer.append(NEWLINE);
						szBuffer.append(gDLL->getText("TXT_KEY_TRADE_ROUTE_MOD_PEACE", iValue));
						iModifier += iValue;
					}
				}
			}

			FAssert(pCity->totalTradeModifier(pOtherCity) == iModifier);

			iProfit *= iModifier;

#ifdef _MOD_FRACTRADE
			iProfit /= 100;
			FAssert(iProfit == pCity->calculateTradeProfitTimes100(pOtherCity));
#else
			iProfit /= 10000;
			FAssert(iProfit == pCity->calculateTradeProfit(pOtherCity));
#endif

			szBuffer.append(SEPARATOR);
			szBuffer.append(NEWLINE);

#ifdef _MOD_FRACTRADE
			CvWString szProfit;
			szProfit.Format(L"%d.%02d", iProfit / 100, iProfit % 100);
			szBuffer.append(gDLL->getText("TXT_KEY_TRADE_ROUTE_TOTAL_FRACTIONAL", szProfit.GetCString()));
#else
			szBuffer.append(gDLL->getText("TXT_KEY_TRADE_ROUTE_TOTAL", iProfit));
#endif
		}
	}
}

void CvGameTextMgr::setEspionageCostHelp(CvWStringBuffer &szBuffer, EspionageMissionTypes eMission, PlayerTypes eTargetPlayer, const CvPlot* pPlot, int iExtraData, const CvUnit* pSpyUnit)
{
	CvPlayer& kPlayer = GET_PLAYER(GC.getGame().getActivePlayer());
	const CvEspionageMissionInfo& kMission = GC.getEspionageMissionInfo(eMission);

	//szBuffer.assign(kMission.getDescription());

	int64_t iMissionCost = kPlayer.getEspionageMissionBaseCost(eMission, eTargetPlayer, pPlot, iExtraData, pSpyUnit);

	if (kMission.isDestroyImprovement())
	{
		if (NULL != pPlot && NO_IMPROVEMENT != pPlot->getImprovementType())
		{
			szBuffer.append(gDLL->getText("TXT_KEY_ESPIONAGE_HELP_DESTROY_IMPROVEMENT", GC.getImprovementInfo(pPlot->getImprovementType()).getTextKeyWide()));
			szBuffer.append(NEWLINE);
		}
	}

	if (kMission.getDestroyBuildingCostFactor() > 0)
	{
		BuildingTypes eTargetBuilding = (BuildingTypes)iExtraData;

		if (NULL != pPlot)
		{
			const CvCity* pCity = pPlot->getPlotCity();

			if (NULL != pCity)
			{
				szBuffer.append(gDLL->getText("TXT_KEY_ESPIONAGE_HELP_DESTROY_IMPROVEMENT", GC.getBuildingInfo(eTargetBuilding).getTextKeyWide()));
				szBuffer.append(NEWLINE);
			}
		}
	}

	if (kMission.getDestroyProjectCostFactor() > 0)
	{
		ProjectTypes eTargetProject = (ProjectTypes)iExtraData;

		if (NULL != pPlot)
		{
			const CvCity* pCity = pPlot->getPlotCity();

			if (NULL != pCity)
			{
				szBuffer.append(gDLL->getText("TXT_KEY_ESPIONAGE_HELP_DESTROY_IMPROVEMENT", GC.getProjectInfo(eTargetProject).getTextKeyWide()));
				szBuffer.append(NEWLINE);
			}
		}
	}

	if (kMission.getDestroyProductionCostFactor() > 0)
	{
		if (NULL != pPlot)
		{
			const CvCity* pCity = pPlot->getPlotCity();

			if (NULL != pCity)
			{
				szBuffer.append(gDLL->getText("TXT_KEY_ESPIONAGE_HELP_DESTROY_PRODUCTION", pCity->getProduction()));
				szBuffer.append(NEWLINE);
			}
		}
	}

	if (kMission.getDestroyUnitCostFactor() > 0)
	{
		if (NO_PLAYER != eTargetPlayer)
		{
			int iTargetUnitID = iExtraData;

			const CvUnit* pUnit = GET_PLAYER(eTargetPlayer).getUnit(iTargetUnitID);

			if (NULL != pUnit)
			{
				szBuffer.append(gDLL->getText("TXT_KEY_ESPIONAGE_HELP_DESTROY_UNIT", pUnit->getNameKey()));
				szBuffer.append(NEWLINE);
			}
		}
	}

	if (kMission.getBuyUnitCostFactor() > 0)
	{
		if (NO_PLAYER != eTargetPlayer)
		{
			int iTargetUnitID = iExtraData;

			const CvUnit* pUnit = GET_PLAYER(eTargetPlayer).getUnit(iTargetUnitID);

			if (NULL != pUnit)
			{
				szBuffer.append(gDLL->getText("TXT_KEY_ESPIONAGE_HELP_BRIBE", pUnit->getNameKey()));
				szBuffer.append(NEWLINE);
			}
		}
	}

	if (kMission.getBuyCityCostFactor() > 0)
	{
		if (NULL != pPlot)
		{
			const CvCity* pCity = pPlot->getPlotCity();

			if (NULL != pCity)
			{
				szBuffer.append(gDLL->getText("TXT_KEY_ESPIONAGE_HELP_BRIBE", pCity->getNameKey()));
				szBuffer.append(NEWLINE);
			}
		}
	}

	if (kMission.getCityInsertCultureCostFactor() > 0)
	{
		if (NULL != pPlot)
		{
			const CvCity* pCity = pPlot->getPlotCity();

			if (NULL != pCity && pPlot->getCulture(GC.getGame().getActivePlayer()) > 0)
			{
				int iCultureAmount = kMission.getCityInsertCultureAmountFactor() *  pCity->countTotalCultureTimes100();
				iCultureAmount /= 10000;
				iCultureAmount = std::max(1, iCultureAmount);

				szBuffer.append(gDLL->getText("TXT_KEY_ESPIONAGE_HELP_INSERT_CULTURE", pCity->getNameKey(), iCultureAmount, kMission.getCityInsertCultureAmountFactor()));
				szBuffer.append(NEWLINE);
			}
		}
	}

	if (kMission.getCityPoisonWaterCounter() > 0)
	{
		if (NULL != pPlot)
		{
			const CvCity* pCity = pPlot->getPlotCity();

			if (NULL != pCity)
			{
				szBuffer.append(gDLL->getText("TXT_KEY_ESPIONAGE_HELP_POISON", kMission.getCityPoisonWaterCounter(), gDLL->getSymbolID(UNHEALTHY_CHAR), pCity->getNameKey(), kMission.getCityPoisonWaterCounter()));
				szBuffer.append(NEWLINE);
			}
		}
	}

	if (kMission.getCityUnhappinessCounter() > 0)
	{
		if (NULL != pPlot)
		{
			const CvCity* pCity = pPlot->getPlotCity();

			if (NULL != pCity)
			{
				szBuffer.append(gDLL->getText("TXT_KEY_ESPIONAGE_HELP_POISON", kMission.getCityUnhappinessCounter(), gDLL->getSymbolID(UNHAPPY_CHAR), pCity->getNameKey(), kMission.getCityUnhappinessCounter()));
				szBuffer.append(NEWLINE);
			}
		}
	}

	if (kMission.getCityRevoltCounter() > 0)
	{
		if (NULL != pPlot)
		{
			const CvCity* pCity = pPlot->getPlotCity();

			if (NULL != pCity)
			{
				szBuffer.append(gDLL->getText("TXT_KEY_ESPIONAGE_HELP_REVOLT", pCity->getNameKey(), kMission.getCityRevoltCounter()));
				szBuffer.append(NEWLINE);
			}
		}
	}

	if (kMission.getStealTreasuryTypes() > 0)
	{
		if (NO_PLAYER != eTargetPlayer)
		{
			int64_t iGold = GET_PLAYER(eTargetPlayer).getGold() * kMission.getStealTreasuryTypes() / 100;

			if (NULL != pPlot)
			{
				const CvCity* pCity = pPlot->getPlotCity();

				if (NULL != pCity)
				{
					iGold *= pCity->getPopulation();
					iGold /= std::max(1, GET_PLAYER(eTargetPlayer).getTotalPopulation());
				}
			}

			szBuffer.append(gDLL->getText("TXT_KEY_ESPIONAGE_HELP_STEAL_TREASURY", iGold, GET_PLAYER(eTargetPlayer).getCivilizationAdjectiveKey()));
			szBuffer.append(NEWLINE);
		}
	}

	if (kMission.getBuyTechCostFactor() > 0)
	{
		szBuffer.append(gDLL->getText("TXT_KEY_ESPIONAGE_HELP_STEAL_TECH", GC.getTechInfo((TechTypes)iExtraData).getTextKeyWide()));
		szBuffer.append(NEWLINE);
	}

	if (kMission.getSwitchCivicCostFactor() > 0)
	{
		if (NO_PLAYER != eTargetPlayer)
		{
			szBuffer.append(gDLL->getText("TXT_KEY_ESPIONAGE_HELP_SWITCH_CIVIC", GET_PLAYER(eTargetPlayer).getNameKey(), GC.getCivicInfo((CivicTypes)iExtraData).getTextKeyWide()));
			szBuffer.append(NEWLINE);
		}
	}

	if (kMission.getSwitchReligionCostFactor() > 0)
	{
		if (NO_PLAYER != eTargetPlayer)
		{
			szBuffer.append(gDLL->getText("TXT_KEY_ESPIONAGE_HELP_SWITCH_CIVIC", GET_PLAYER(eTargetPlayer).getNameKey(), GC.getReligionInfo((ReligionTypes)iExtraData).getTextKeyWide()));
			szBuffer.append(NEWLINE);
		}
	}

	if (kMission.getPlayerAnarchyCounter() > 0)
	{
		if (NO_PLAYER != eTargetPlayer)
		{
			int iTurns = (kMission.getPlayerAnarchyCounter() * GC.getGameSpeedInfo(GC.getGame().getGameSpeedType()).getAnarchyPercent()) / 100;
			szBuffer.append(gDLL->getText("TXT_KEY_ESPIONAGE_HELP_ANARCHY", GET_PLAYER(eTargetPlayer).getNameKey(), iTurns));
			szBuffer.append(NEWLINE);
		}
	}

	if (kMission.getCounterespionageNumTurns() > 0 && kMission.getCounterespionageMod() > 0)
	{
		if (NO_PLAYER != eTargetPlayer)
		{
			int iTurns = (kMission.getCounterespionageNumTurns() * GC.getGameSpeedInfo(GC.getGame().getGameSpeedType()).getResearchPercent()) / 100;

			szBuffer.append(gDLL->getText("TXT_KEY_ESPIONAGE_HELP_COUNTERESPIONAGE", kMission.getCounterespionageMod(), GET_PLAYER(eTargetPlayer).getCivilizationAdjectiveKey(), iTurns));
			szBuffer.append(NEWLINE);
		}
	}

	if (kMission.isNuke())
	{
		if (NULL != pPlot)
		{
			const CvCity* pCity = pPlot->getPlotCity();

			if (NULL != pCity)
			{
				szBuffer.append(gDLL->getText("TXT_KEY_ESPIONAGE_HELP_NUKE", pCity->getNameKey()));
				szBuffer.append(NEWLINE);
			}
		}
	}
	if (kMission.isRevolt())
	{
		if (NULL != pPlot)
		{
			const CvCity* pCity = pPlot->getPlotCity();

			if (NULL != pCity)
			{
				szBuffer.append(gDLL->getText("TXT_KEY_ESPIONAGE_HELP_REVOLTUTION", pCity->getNameKey()));
				szBuffer.append(NEWLINE);
			}
		}
	}
	if (kMission.isDisablePower())
	{
		if (NULL != pPlot)
		{
			const CvCity* pCity = pPlot->getPlotCity();

			int iTurns = 6;
			iTurns *= GC.getGameSpeedInfo(GC.getGame().getGameSpeedType()).getTrainPercent();
			iTurns /= 100;

			if (NULL != pCity)
			{
				szBuffer.append(gDLL->getText("TXT_KEY_ESPIONAGE_HELP_POWER", pCity->getNameKey(), iTurns));
				szBuffer.append(NEWLINE);
			}
		}
	}
	if (kMission.getWarWearinessCounter() > 0)
	{
		if (NULL != pPlot)
		{
			const CvCity* pCity = pPlot->getPlotCity();

			if (NULL != pCity)
			{
				szBuffer.append(gDLL->getText("TXT_KEY_ESPIONAGE_HELP_WAR_WEARINESS", pCity->getNameKey(), kMission.getWarWearinessCounter()));
				szBuffer.append(NEWLINE);
			}
		}
	}
	if (kMission.getSabatogeResearchCostFactor() > 0)
	{
		if (NULL != pPlot)
		{
			const CvCity* pCity = pPlot->getPlotCity();

			if (NULL != pCity)
			{
				szBuffer.append(gDLL->getText("TXT_KEY_ESPIONAGE_HELP_SABATOGE_RESEARCH", GET_PLAYER(eTargetPlayer).getNameKey(), GC.getTechInfo(GET_PLAYER(eTargetPlayer).getCurrentResearch()).getTextKeyWide()));
				szBuffer.append(NEWLINE);
			}
		}
	}
	if (kMission.getRemoveReligionsCostFactor() > 0)
	{
		if (NULL != pPlot)
		{
			const CvCity* pCity = pPlot->getPlotCity();

			if (NULL != pCity)
			{
				szBuffer.append(gDLL->getText("TXT_KEY_ESPIONAGE_HELP_REMOVE_RELIGIONS", GC.getReligionInfo((ReligionTypes)iExtraData).getTextKeyWide(), pCity->getNameKey()));
				szBuffer.append(NEWLINE);
			}
		}
	}
	if (kMission.getRemoveCorporationsCostFactor() > 0)
	{
		if (NULL != pPlot)
		{
			const CvCity* pCity = pPlot->getPlotCity();

			if (NULL != pCity)
			{
				szBuffer.append(gDLL->getText("TXT_KEY_ESPIONAGE_HELP_REMOVE_RELIGIONS", GC.getCorporationInfo((CorporationTypes)iExtraData).getTextKeyWide(), pCity->getNameKey()));
				szBuffer.append(NEWLINE);
			}
		}
	}
	szBuffer.append(NEWLINE);
	szBuffer.append(gDLL->getText("TXT_KEY_ESPIONAGE_BASE_COST", iMissionCost));

	if (kPlayer.getEspionageMissionCost(eMission, eTargetPlayer, pPlot, iExtraData, pSpyUnit) > 0)
	{
		int iModifier = 100;
		int iTempModifier = 0;
		CvCity* pCity = NULL;
		if (NULL != pPlot)
		{
			pCity = pPlot->getPlotCity();
		}

		if (pCity != NULL && GC.getEspionageMissionInfo(eMission).isTargetsCity())
		{
			// City Population
			iTempModifier = (GC.getDefineINT("ESPIONAGE_CITY_POP_EACH_MOD") * (pCity->getPopulation() - 1));
			if (0 != iTempModifier)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_ESPIONAGE_POPULATION_MOD", iTempModifier));
				iModifier *= 100 + iTempModifier;
				iModifier /= 100;
			}

			// Trade Route
			if (pCity->isTradeRoute(kPlayer.getID()))
			{
				iTempModifier = GC.getDefineINT("ESPIONAGE_CITY_TRADE_ROUTE_MOD");
				if (0 != iTempModifier)
				{
					szBuffer.append(NEWLINE);
					szBuffer.append(gDLL->getText("TXT_KEY_ESPIONAGE_TRADE_ROUTE_MOD", iTempModifier));
					iModifier *= 100 + iTempModifier;
					iModifier /= 100;
				}
			}

			ReligionTypes eReligion = kPlayer.getStateReligion();
			if (NO_RELIGION != eReligion && pCity->isHasReligion(eReligion))
			{
				iTempModifier = 0;

				if (GET_PLAYER(eTargetPlayer).getStateReligion() != eReligion)
				{
					iTempModifier += GC.getDefineINT("ESPIONAGE_CITY_RELIGION_STATE_MOD");
				}
				if (kPlayer.hasHolyCity(eReligion))
				{
					iTempModifier += GC.getDefineINT("ESPIONAGE_CITY_HOLY_CITY_MOD");
				}
				if (0 != iTempModifier)
				{
					szBuffer.append(NEWLINE);
					szBuffer.append(gDLL->getText("TXT_KEY_ESPIONAGE_RELIGION_MOD", iTempModifier));
					iModifier *= 100 + iTempModifier;
					iModifier /= 100;
				}
			}

			// City's culture affects cost
			iTempModifier = -pCity->getCultureTimes100(kPlayer.getID()) * GC.getDefineINT("ESPIONAGE_CULTURE_MULTIPLIER_MOD")
				/ std::max(1, pCity->getCultureTimes100(eTargetPlayer) + pCity->getCultureTimes100(kPlayer.getID()));

			if (0 != iTempModifier)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_ESPIONAGE_CULTURE_MOD", iTempModifier));
				iModifier *= 100 + iTempModifier;
				iModifier /= 100;
			}

			iTempModifier = pCity->getEspionageDefenseModifier();
			if (0 != iTempModifier)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_ESPIONAGE_DEFENSE_MOD", iTempModifier));
				iModifier *= 100 + iTempModifier;
				iModifier /= 100;
			}
		}

		// Distance mod
		if (pPlot != NULL)
		{
			int iDistance = GC.getMap().maxPlotDistance();

			CvCity* pOurCapital = kPlayer.getCapitalCity();
			if (NULL != pOurCapital)
			{
				if (kMission.isSelectPlot() || kMission.isTargetsCity())
				{
					iDistance = plotDistance(pOurCapital->getX(), pOurCapital->getY(), pPlot->getX(), pPlot->getY());
				}
				else
				{
					CvCity* pTheirCapital = GET_PLAYER(eTargetPlayer).getCapitalCity();
					if (NULL != pTheirCapital)
					{
						iDistance = plotDistance(pOurCapital->getX(), pOurCapital->getY(), pTheirCapital->getX(), pTheirCapital->getY());
					}
				}
			}

			iTempModifier = (iDistance + GC.getMap().maxPlotDistance()) * GC.getDefineINT("ESPIONAGE_DISTANCE_MULTIPLIER_MOD") / GC.getMap().maxPlotDistance() - 100;
			if (0 != iTempModifier)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_ESPIONAGE_DISTANCE_MOD", iTempModifier));
				iModifier *= 100 + iTempModifier;
				iModifier /= 100;
			}
		}

		// Spy presence mission cost alteration
		if (NULL != pSpyUnit)
		{
			iTempModifier = -std::min(5, pSpyUnit->getFortifyTurns() + pSpyUnit->getUpgradeDiscount() / 10) * GC.getDefineINT("ESPIONAGE_EACH_TURN_UNIT_COST_DECREASE");
			if (0 != iTempModifier)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_ESPIONAGE_SPY_STATIONARY_MOD", iTempModifier));
				iModifier *= 100 + iTempModifier;
				iModifier /= 100;
			}
		}

		// My points VS. Your points to mod cost
		iTempModifier = GC.getDefineINT("ESPIONAGE_SPENDING_MULTIPLIER")
			* (GET_TEAM(GET_PLAYER(eTargetPlayer).getTeam()).getEspionagePointsEver() * 2 + GET_TEAM(kPlayer.getTeam()).getEspionagePointsEver())
			/ std::max(
			1, GET_TEAM(GET_PLAYER(eTargetPlayer).getTeam()).getEspionagePointsEver() + 2 * GET_TEAM(kPlayer.getTeam()).getEspionagePointsEver()
			) - 100;

		if (0 != iTempModifier)
		{
			szBuffer.append(SEPARATOR);
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_ESPIONAGE_EP_RATIO_MOD", iTempModifier));
			iModifier *= 100 + iTempModifier;
			iModifier /= 100;
		}

		// Counterespionage Mission Mod
		CvTeam& kTargetTeam = GET_TEAM(GET_PLAYER(eTargetPlayer).getTeam());
		if (kTargetTeam.getCounterespionageModAgainstTeam(kPlayer.getTeam()) > 0)
		{
			iTempModifier = kTargetTeam.getCounterespionageModAgainstTeam(kPlayer.getTeam()) - 100;
			if (0 != iTempModifier)
			{
				szBuffer.append(SEPARATOR);
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_ESPIONAGE_COUNTERESPIONAGE_MOD", iTempModifier));
				iModifier *= 100 + iTempModifier;
				iModifier /= 100;
			}
		}

		if (pCity != NULL)
		{
			if (pCity == GET_PLAYER(pCity->getOwner()).getCapitalCity() && kTargetTeam.isHasEmbassy(kPlayer.getTeam()))
			{
				iTempModifier = -GC.getDefineINT("EMBASSY_ESPIONAGE_MISSION_COST_MODIFIER");
				if (0 != iTempModifier)
				{
					szBuffer.append(SEPARATOR);
					szBuffer.append(NEWLINE);
					szBuffer.append(gDLL->getText("TXT_KEY_ESPIONAGE_EMBASSY_MOD", iTempModifier));
					iModifier *= 100 + iTempModifier;
					iModifier /= 100;
				}
			}
			if (kTargetTeam.isFreeTradeAgreement(kPlayer.getTeam()))
			{
				iTempModifier = -GC.getDefineINT("FREE_TRADE_AGREEMENT_ESPIONAGE_MISSION_COST_MODIFIER");
				if (0 != iTempModifier)
				{
					szBuffer.append(SEPARATOR);
					szBuffer.append(NEWLINE);
					szBuffer.append(gDLL->getText("TXT_KEY_FREE_TRADE_AGREEMENT_MOD", iTempModifier));
					iModifier *= 100 + iTempModifier;
					iModifier /= 100;
				}
			}
		}
		// Toffer - Should add some text for this last part too I guess...
		iModifier += GC.getESPIONAGE_MISSION_COST_END_TOTAL_PERCENT_ADJUSTMENT();

		FAssert(iModifier == kPlayer.getEspionageMissionCostModifier(eMission, eTargetPlayer, pPlot, iExtraData, pSpyUnit));

		iMissionCost *= iModifier;
		iMissionCost /= 100;

		FAssert(iMissionCost == kPlayer.getEspionageMissionCost(eMission, eTargetPlayer, pPlot, iExtraData, pSpyUnit));

		szBuffer.append(SEPARATOR);

		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_ESPIONAGE_COST_TOTAL", iMissionCost));


		if (NULL != pSpyUnit)
		{
			int iInterceptChance = (pSpyUnit->getSpyInterceptPercent(GET_PLAYER(eTargetPlayer).getTeam()) * (100 + kMission.getDifficultyMod())) / 100;

			szBuffer.append(NEWLINE);
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_ESPIONAGE_CHANCE_OF_SUCCESS", std::min(100, std::max(0, 100 - iInterceptChance))));
		}
	}
}

void CvGameTextMgr::getTradeScreenTitleIcon(CvString& szButton, CvWidgetDataStruct& widgetData, PlayerTypes ePlayer)
{
	szButton.clear();

	ReligionTypes eReligion = GET_PLAYER(ePlayer).getStateReligion();
	if (eReligion != NO_RELIGION)
	{
		szButton = GC.getReligionInfo(eReligion).getButton();
		widgetData.m_eWidgetType = WIDGET_HELP_RELIGION;
		widgetData.m_iData1 = eReligion;
		widgetData.m_iData2 = -1;
		widgetData.m_bOption = false;
	}
}

void CvGameTextMgr::getTradeScreenIcons(std::vector< std::pair<CvString, CvWidgetDataStruct> >& aIconInfos, PlayerTypes ePlayer)
{
	aIconInfos.clear();
	for (int i = 0; i < GC.getNumCivicOptionInfos(); i++)
	{
		CivicTypes eCivic = GET_PLAYER(ePlayer).getCivics((CivicOptionTypes)i);
		CvWidgetDataStruct widgetData;
		widgetData.m_eWidgetType = WIDGET_PEDIA_JUMP_TO_CIVIC;
		widgetData.m_iData1 = eCivic;
		widgetData.m_iData2 = -1;
		widgetData.m_bOption = false;
		aIconInfos.push_back(std::make_pair(GC.getCivicInfo(eCivic).getButton(), widgetData));
	}

}

void CvGameTextMgr::getTradeScreenHeader(CvWString& szHeader, PlayerTypes ePlayer, PlayerTypes eOtherPlayer, bool bAttitude)
{
	CvPlayer& kPlayer = GET_PLAYER(ePlayer);
	szHeader.Format(L"%s - %s", CvWString(kPlayer.getName()).GetCString(), CvWString(kPlayer.getCivilizationDescription()).GetCString());
	if (bAttitude)
	{
		szHeader += CvWString::format(L" (%s)", GC.getAttitudeInfo(kPlayer.AI_getAttitude(eOtherPlayer)).getDescription());
	}
}

// BUG - Trade Hover - start
void CvGameTextMgr::buildDomesticTradeString(CvWStringBuffer& szBuffer, PlayerTypes ePlayer)
{
	buildTradeString(szBuffer, ePlayer, NO_PLAYER, true, false, false);
}

void CvGameTextMgr::buildForeignTradeString(CvWStringBuffer& szBuffer, PlayerTypes ePlayer)
{
	buildTradeString(szBuffer, ePlayer, NO_PLAYER, false, true, false);
}

void CvGameTextMgr::buildTradeString(CvWStringBuffer& szBuffer, PlayerTypes ePlayer, PlayerTypes eWithPlayer, bool bDomestic, bool bForeign, bool bHeading)
{
	if (NO_PLAYER == ePlayer)
	{
		return;
	}

	CvPlayer& player = GET_PLAYER(ePlayer);
	if (bHeading)
	{
		if (ePlayer == eWithPlayer)
		{
			szBuffer.append(gDLL->getText("TXT_KEY_BUG_DOMESTIC_TRADE_HEADING"));
		}
		else if (NO_PLAYER != eWithPlayer)
		{
			if (player.canHaveTradeRoutesWith(eWithPlayer))
			{
				szBuffer.append(gDLL->getText("TXT_KEY_BUG_FOREIGN_TRADE_HEADING", GET_PLAYER(eWithPlayer).getNameKey(), GET_PLAYER(eWithPlayer).getCivilizationShortDescription()));
			}
			else
			{
				szBuffer.append(gDLL->getText("TXT_KEY_BUG_CANNOT_TRADE_HEADING", GET_PLAYER(eWithPlayer).getNameKey(), GET_PLAYER(eWithPlayer).getCivilizationShortDescription()));
			}
		}
		else
		{
			szBuffer.append(gDLL->getText("TXT_KEY_BUG_TRADE_HEADING"));
		}
		szBuffer.append(NEWLINE);
	}

	if (NO_PLAYER != eWithPlayer)
	{
		bDomestic = ePlayer == eWithPlayer;
		bForeign = ePlayer != eWithPlayer;

		if (bForeign && !player.canHaveTradeRoutesWith(eWithPlayer))
		{
			CvPlayer& withPlayer = GET_PLAYER(eWithPlayer);
			bool bCanTrade = true;
			if (!GET_PLAYER(eWithPlayer).isAlive())
			{
				szBuffer.append(gDLL->getText("TXT_KEY_BUG_CANNOT_TRADE_DEAD"));
				return;
			}
			if (!player.canTradeNetworkWith(eWithPlayer))
			{
				szBuffer.append(gDLL->getText("TXT_KEY_BUG_CANNOT_TRADE_NETWORK_NOT_CONNECTED"));
				bCanTrade = false;
			}
			if (!GET_TEAM(player.getTeam()).isFreeTrade(withPlayer.getTeam()))
			{
				szBuffer.append(gDLL->getText("TXT_KEY_BUG_CANNOT_TRADE_CLOSED_BORDERS"));
				bCanTrade = false;
			}
			if (player.isNoForeignTrade())
			{
				szBuffer.append(gDLL->getText("TXT_KEY_BUG_CANNOT_TRADE_FOREIGN_YOU"));
				bCanTrade = false;
			}
			if (withPlayer.isNoForeignTrade())
			{
				szBuffer.append(gDLL->getText("TXT_KEY_BUG_CANNOT_TRADE_FOREIGN_THEM"));
				bCanTrade = false;
			}

			if (!bCanTrade)
			{
				return;
			}
		}
	}

	int iDomesticYield = 0;
	int iDomesticRoutes = 0;
	int iForeignYield = 0;
	int iForeignRoutes = 0;

	player.calculateTradeTotals(YIELD_COMMERCE, iDomesticYield, iDomesticRoutes, iForeignYield, iForeignRoutes, eWithPlayer, false);

	int iTotalYield = 0;
	int iTotalRoutes = 0;
	if (bDomestic)
	{
		iTotalYield += iDomesticYield;
		iTotalRoutes += iDomesticRoutes;
	}
	if (bForeign)
	{
		iTotalYield += iForeignYield;
		iTotalRoutes += iForeignRoutes;
	}

	CvWString szYield;
// BUG - Fractional Trade Routes - start
#ifdef _MOD_FRACTRADE
	szYield.Format(L"%d.%02d", iTotalYield / 100, iTotalYield % 100);
#else
	szYield.Format(L"%d", iTotalYield);
#endif
// BUG - Fractional Trade Routes - end
	szBuffer.append(gDLL->getText("TXT_KEY_BUG_TOTAL_TRADE_YIELD", szYield.GetCString()));
	szBuffer.append(gDLL->getText("TXT_KEY_BUG_TOTAL_TRADE_ROUTES", iTotalRoutes));

	if (iTotalRoutes > 0)
	{
// BUG - Fractional Trade Routes - start
#ifdef _MOD_FRACTRADE
		int iAverage = iTotalYield / iTotalRoutes;
#else
		int iAverage = 100 * iTotalYield / iTotalRoutes;
#endif
// BUG - Fractional Trade Routes - end
		CvWString szAverage;
		szAverage.Format(L"%d.%02d", iAverage / 100, iAverage % 100);
		szBuffer.append(gDLL->getText("TXT_KEY_BUG_AVERAGE_TRADE_YIELD", szAverage.GetCString()));
	}
}
// BUG - Trade Hover - end

void CvGameTextMgr::getGlobeLayerName(GlobeLayerTypes eType, int iOption, CvWString& strName)
{
	switch (eType)
	{
	case GLOBE_LAYER_STRATEGY:
		switch(iOption)
		{
		case 0:
			strName = gDLL->getText("TXT_KEY_GLOBELAYER_STRATEGY_VIEW");
			break;
		case 1:
			strName = gDLL->getText("TXT_KEY_GLOBELAYER_STRATEGY_NEW_LINE");
			break;
		case 2:
			strName = gDLL->getText("TXT_KEY_GLOBELAYER_STRATEGY_NEW_SIGN");
			break;
		case 3:
			strName = gDLL->getText("TXT_KEY_GLOBELAYER_STRATEGY_DELETE");
			break;
		case 4:
			strName = gDLL->getText("TXT_KEY_GLOBELAYER_STRATEGY_DELETE_LINES");
			break;
		}
		break;
	case GLOBE_LAYER_UNIT:
		switch(iOption)
		{
		case SHOW_ALL_MILITARY:
			strName = gDLL->getText("TXT_KEY_GLOBELAYER_UNITS_ALLMILITARY");
			break;
		case SHOW_TEAM_MILITARY:
			strName = gDLL->getText("TXT_KEY_GLOBELAYER_UNITS_TEAMMILITARY");
			break;
		case SHOW_ENEMIES_IN_TERRITORY:
			strName = gDLL->getText("TXT_KEY_GLOBELAYER_UNITS_ENEMY_TERRITORY_MILITARY");
			break;
		case SHOW_ENEMIES:
			strName = gDLL->getText("TXT_KEY_GLOBELAYER_UNITS_ENEMYMILITARY");
			break;
		case SHOW_PLAYER_DOMESTICS:
			strName = gDLL->getText("TXT_KEY_GLOBELAYER_UNITS_DOMESTICS");
			break;
		}
		break;
	case GLOBE_LAYER_RESOURCE:
		switch(iOption)
		{
		case SHOW_RESOURCES_ALL:
			strName = gDLL->getText("TXT_KEY_GLOBELAYER_RESOURCES_ALL");
			break;
		case SHOW_RESOURCES_STRATEGIC:
			strName = gDLL->getText("TXT_KEY_GLOBELAYER_RESOURCES_STRATEGIC");
			break;
		case SHOW_RESOURCES_LUXURY:
			strName = gDLL->getText("TXT_KEY_GLOBELAYER_RESOURCES_LUXURY");
			break;
		case SHOW_RESOURCES_PRODUCTION:
			strName = gDLL->getText("TXT_KEY_GLOBELAYER_RESOURCES_PRODUCTION");
			break;
		case SHOW_RESOURCES_GROWTH:
			strName = gDLL->getText("TXT_KEY_GLOBELAYER_RESOURCES_GROWTH");
			break;
		case SHOW_RESOURCES_MISC:
			strName = gDLL->getText("TXT_KEY_GLOBELAYER_RESOURCES_MISC");
			break;
		}
		break;
	case GLOBE_LAYER_DEBUG:
		switch(iOption)
		{
		case 1:
			strName = "Debug info";
			break;
		}
		break;
	case GLOBE_LAYER_RELIGION:
		strName = GC.getReligionInfo((ReligionTypes) iOption).getDescription();
		break;
	case GLOBE_LAYER_CULTURE:
	case GLOBE_LAYER_TRADE:
		// these have no sub-options
		strName.clear();
		break;
	}
}

void CvGameTextMgr::getPlotHelp(CvPlot* pMouseOverPlot, CvCity* pCity, CvPlot* pFlagPlot, bool bAlt, CvWStringBuffer& strHelp)
{
	if (gDLL->getInterfaceIFace()->isCityScreenUp())
	{
		if (pMouseOverPlot != NULL)
		{
			CvCity* pHeadSelectedCity = gDLL->getInterfaceIFace()->getHeadSelectedCity();
			if (pHeadSelectedCity != NULL)
			{
				if (pMouseOverPlot->getWorkingCity() == pHeadSelectedCity)
				{
					if (pMouseOverPlot->isRevealed(GC.getGame().getActiveTeam(), true))
					{
						setPlotHelp(strHelp, pMouseOverPlot);
					}
				}
			}
		}
	}
	else
	{
		if (pCity != NULL)
		{
			setCityBarHelp(strHelp, pCity);
		}
		else if (pFlagPlot != NULL)
		{
			setPlotListHelp(strHelp, pFlagPlot, false, true);
		}
		if (strHelp.isEmpty())
		{
			if (pMouseOverPlot != NULL)
			{
				if ((pMouseOverPlot == gDLL->getInterfaceIFace()->getGotoPlot()) || bAlt)
				{
					if (pMouseOverPlot->isVisiblePotentialEnemyDefender(gDLL->getInterfaceIFace()->getSelectionList()->getHeadUnit()))
					/*if (pMouseOverPlot->isActiveVisible(true))*/
					{

						setCombatPlotHelp(strHelp, pMouseOverPlot);
					}
				}
			}
		}

		if (strHelp.isEmpty())
		{
			if (pMouseOverPlot != NULL)
			{
				if (pMouseOverPlot->isRevealed(GC.getGame().getActiveTeam(), true))
				{
					if (pMouseOverPlot->isActiveVisible(true))
					{
						setPlotListHelp(strHelp, pMouseOverPlot, true, false);

						if (!strHelp.isEmpty())
						{
							strHelp.append(L"\n");
						}
					}

					setPlotHelp(strHelp, pMouseOverPlot);
				}
			}
		}

		if (pMouseOverPlot != NULL)
		{
			if (pMouseOverPlot->isRevealed(GC.getGame().getActiveTeam(), true))
			{
				if (pMouseOverPlot->isActiveVisible(true))
				{
					if (pMouseOverPlot->getTeam() != NO_TEAM)
					{
						if (gDLL->getInterfaceIFace()->getHeadSelectedUnit() != NULL)
						{
							if (GET_TEAM(pMouseOverPlot->getTeam()).isAtWar(gDLL->getInterfaceIFace()->getHeadSelectedUnit()->getTeam()))
							{
								if( !gDLL->getInterfaceIFace()->getHeadSelectedUnit()->canMoveInto(pMouseOverPlot))
								{
									CvWString szTempBuffer;
									szTempBuffer.clear();
									if (pMouseOverPlot->isCity())
									{
										int iMinimumDefenseLevel = MAX_INT;
										BuildingTypes eBestBuilding = NO_BUILDING;
										for (int iI = 0; iI < GC.getNumBuildingInfos(); iI++)
										{
											if (pMouseOverPlot->getPlotCity()->getNumActiveBuilding((BuildingTypes)iI) > 0)
											{
												if (GC.getBuildingInfo((BuildingTypes)iI).getNoEntryDefenseLevel() > 0)
												{
													if (GC.getBuildingInfo((BuildingTypes)iI).getNoEntryDefenseLevel() < iMinimumDefenseLevel)
													{
														iMinimumDefenseLevel = GC.getBuildingInfo((BuildingTypes)iI).getNoEntryDefenseLevel();
														eBestBuilding = (BuildingTypes)iI;
													}
												}
											}
										}
										if (pMouseOverPlot->getPlotCity()->getExtraMinDefense() > iMinimumDefenseLevel)
										{
											iMinimumDefenseLevel = pMouseOverPlot->getPlotCity()->getExtraMinDefense();
										}
										if (pMouseOverPlot->getPlotCity()->getDefenseModifier(false) > iMinimumDefenseLevel && eBestBuilding != NO_BUILDING)
										{
											if (!gDLL->getInterfaceIFace()->getHeadSelectedUnit()->canIgnoreNoEntryLevel())
											{
												szTempBuffer.clear();
												szTempBuffer.append(gDLL->getText("TXT_KEY_PLOT_HOVER_MAX_CITY_DEFENSES", pMouseOverPlot->getPlotCity()->getNameKey(), GC.getBuildingInfo(eBestBuilding).getDescription(), GC.getBuildingInfo(eBestBuilding).getDescription(), iMinimumDefenseLevel));
											}
										}
									}
									else
									{
										if (GC.getGame().isOption(GAMEOPTION_ZONE_OF_CONTROL))
										{
											// Fort ZoC
											const PlayerTypes eDefender = gDLL->getInterfaceIFace()->getHeadSelectedUnit()->plot()->controlsAdjacentZOCSource(gDLL->getInterfaceIFace()->getHeadSelectedUnit()->getTeam());
											if (eDefender != NO_PLAYER)
											{
												const CvPlot* pZoneOfControl = gDLL->getInterfaceIFace()->getHeadSelectedUnit()->plot()->isInFortControl(true, eDefender, gDLL->getInterfaceIFace()->getHeadSelectedUnit()->getOwner());
												const CvPlot* pForwardZoneOfControl = pMouseOverPlot->isInFortControl(true, eDefender, gDLL->getInterfaceIFace()->getHeadSelectedUnit()->getOwner());
												if (pZoneOfControl != NULL && pForwardZoneOfControl != NULL
												&& pZoneOfControl == pMouseOverPlot->isInFortControl(true, eDefender, gDLL->getInterfaceIFace()->getHeadSelectedUnit()->getOwner(), pZoneOfControl))
												{
													szTempBuffer.clear();
													szTempBuffer.append(gDLL->getText("TXT_KEY_PLOT_HOVER_FORT_ZOC"));
												}
											}
											// City ZoC
											if (gDLL->getInterfaceIFace()->getHeadSelectedUnit()->plot()->isInCityZoneOfControl(gDLL->getInterfaceIFace()->getHeadSelectedUnit()->getOwner()) && pMouseOverPlot->isInCityZoneOfControl(gDLL->getInterfaceIFace()->getHeadSelectedUnit()->getOwner()))
											{
												szTempBuffer.clear();
												szTempBuffer.append(gDLL->getText("TXT_KEY_PLOT_HOVER_CITY_ZOC"));
											}
											// Promotion ZoC
											if (gDLL->getInterfaceIFace()->getHeadSelectedUnit()->plot()->isInUnitZoneOfControl(gDLL->getInterfaceIFace()->getHeadSelectedUnit()->getOwner()) && pMouseOverPlot->isInUnitZoneOfControl(gDLL->getInterfaceIFace()->getHeadSelectedUnit()->getOwner()))
											{
												szTempBuffer.clear();
												szTempBuffer.append(gDLL->getText("TXT_KEY_PLOT_HOVER_UNIT_ZOC"));
											}
										}
									}

									if (szTempBuffer != L"")
									{
										strHelp.assign(szTempBuffer);
									}
								}
							}
						}
					}
				}
			}
		}

		InterfaceModeTypes eInterfaceMode = gDLL->getInterfaceIFace()->getInterfaceMode();
		if (eInterfaceMode != INTERFACEMODE_SELECTION)
		{
			CvWString szTempBuffer;
			szTempBuffer.Format(SETCOLR L"%s" ENDCOLR NEWLINE, TEXT_COLOR("COLOR_HIGHLIGHT_TEXT"), GC.getInterfaceModeInfo(eInterfaceMode).getDescription());

			switch (eInterfaceMode)
			{
			case INTERFACEMODE_REBASE:
				getRebasePlotHelp(pMouseOverPlot, szTempBuffer);
				break;

			case INTERFACEMODE_NUKE:
				getNukePlotHelp(pMouseOverPlot, szTempBuffer);
				break;

			case INTERFACEMODE_SHADOW_UNIT:
				{
					CvUnit* pHeadSelectedUnit = gDLL->getInterfaceIFace()->getHeadSelectedUnit();
					if (NULL != pHeadSelectedUnit && pMouseOverPlot != NULL)
					{
						CvUnit* pShadowUnit = pMouseOverPlot->getCenterUnit();
						if (!pHeadSelectedUnit->getGroup()->canDoInterfaceModeAt(eInterfaceMode, pMouseOverPlot))
						{
							strHelp.clear();
							if (pShadowUnit != NULL)
							{
								CvUnit* pLoopShadow = NULL;
								CLLNode<IDInfo>* pUnitShadowNode = NULL;
								int iValidShadowUnits = 0;
								pUnitShadowNode = pMouseOverPlot->headUnitNode();
								while (pUnitShadowNode != NULL)
								{
									pLoopShadow = ::getUnit(pUnitShadowNode->m_data);
									pUnitShadowNode = pMouseOverPlot->nextUnitNode(pUnitShadowNode);
									if (pHeadSelectedUnit->canShadowAt(pMouseOverPlot, pLoopShadow))
									{
										iValidShadowUnits++;
									}
								}
								if (iValidShadowUnits == 0)
								{
									bool bFirst = true;
									if (pShadowUnit->baseMoves() > pHeadSelectedUnit->baseMoves())
									{
										strHelp.append(gDLL->getText("TXT_KEY_CAN_NOT_AUTOMATE_PROTECT_NOT_FAST_ENOUGH", pShadowUnit->getNameKey(), pHeadSelectedUnit->getNameKey(), pShadowUnit->baseMoves(), pShadowUnit->getNameKey()));
										bFirst = false;
									}
									if (pShadowUnit->getTeam() != pHeadSelectedUnit->getTeam())
									{
										if (!bFirst)
											strHelp.append(L"\n");
										strHelp.append(gDLL->getText("TXT_KEY_CAN_NOT_AUTOMATE_PROTECT_DIFFERENT_TEAM", pShadowUnit->getNameKey()));
										bFirst = false;
									}
									if (pShadowUnit == pHeadSelectedUnit)
									{
										if (!bFirst)
											strHelp.append(L"\n");
										strHelp.append(gDLL->getText("TXT_KEY_CAN_NOT_AUTOMATE_PROTECT_YOURSELF"));
										bFirst = false;
									}
								}
							}
						}
					}
				}
				break;

			default:
				break;
			}

			szTempBuffer += strHelp.getCString();
			strHelp.assign(szTempBuffer);
		}
	}
}

void CvGameTextMgr::getRebasePlotHelp(CvPlot* pPlot, CvWString& strHelp)
{
	if (NULL != pPlot)
	{
		CvUnit* pHeadSelectedUnit = gDLL->getInterfaceIFace()->getHeadSelectedUnit();
		if (NULL != pHeadSelectedUnit)
		{
			if (pPlot->isFriendlyCity(*pHeadSelectedUnit, true))
			{
				CvCity* pCity = pPlot->getPlotCity();
				if (NULL != pCity)
				{
					int iNumUnits = pCity->plot()->countNumAirUnits(GC.getGame().getActiveTeam());
					bool bFull = (iNumUnits >= pCity->getAirUnitCapacity(GC.getGame().getActiveTeam()));
					if (GC.getGame().isOption(GAMEOPTION_SIZE_MATTERS))
					{
						iNumUnits = pCity->plot()->countNumAirUnitCargoVolume(GC.getGame().getActiveTeam());
						bFull = (iNumUnits >= pCity->getSMAirUnitCapacity(GC.getGame().getActiveTeam()));
					}

					if (bFull)
					{
						strHelp += CvWString::format(SETCOLR, TEXT_COLOR("COLOR_WARNING_TEXT"));
					}

					if (!GC.getGame().isOption(GAMEOPTION_SIZE_MATTERS))
					{
						strHelp +=  NEWLINE + gDLL->getText("TXT_KEY_CITY_BAR_AIR_UNIT_CAPACITY", iNumUnits, pCity->getAirUnitCapacity(GC.getGame().getActiveTeam()));
					}
					else
					{
						strHelp +=  NEWLINE + gDLL->getText("TXT_KEY_CITY_BAR_AIR_UNIT_CAPACITY", iNumUnits, pCity->getSMAirUnitCapacity(GC.getGame().getActiveTeam()));
					}

					if (bFull)
					{
						strHelp += ENDCOLR;
					}

					strHelp += NEWLINE;
				}
			}
		}
	}
}

void CvGameTextMgr::getNukePlotHelp(CvPlot* pPlot, CvWString& strHelp)
{
	if (NULL != pPlot)
	{
		CvUnit* pHeadSelectedUnit = gDLL->getInterfaceIFace()->getHeadSelectedUnit();

		if (NULL != pHeadSelectedUnit)
		{
			for (int iI = 0; iI < MAX_TEAMS; iI++)
			{
				if (pHeadSelectedUnit->isNukeVictim(pPlot, ((TeamTypes)iI)))
				{
					if (!pHeadSelectedUnit->isEnemy((TeamTypes)iI))
					{
						strHelp +=  NEWLINE + gDLL->getText("TXT_KEY_CANT_NUKE_FRIENDS");
						break;
					}
				}
			}
		}
	}
}

void CvGameTextMgr::getInterfaceCenterText(CvWString& strText)
{
	strText.clear();
	if (!gDLL->getInterfaceIFace()->isCityScreenUp())
	{
		if (GC.getGame().getWinner() != NO_TEAM)
		{
			strText = gDLL->getText("TXT_KEY_MISC_WINS_VICTORY", GET_TEAM(GC.getGame().getWinner()).getName().GetCString(), GC.getVictoryInfo(GC.getGame().getVictory()).getTextKeyWide());
		}
		else if (!(GET_PLAYER(GC.getGame().getActivePlayer()).isAlive()))
		{
			strText = gDLL->getText("TXT_KEY_MISC_DEFEAT");
		}
	}
}

void CvGameTextMgr::getTurnTimerText(CvWString& strText)
{
	strText.clear();
	if (gDLL->getInterfaceIFace()->getShowInterface() == INTERFACE_SHOW || gDLL->getInterfaceIFace()->getShowInterface() == INTERFACE_ADVANCED_START)
	{
		if (GC.getGame().isMPOption(MPOPTION_TURN_TIMER))
		{
			// Get number of turn slices remaining until end-of-turn
			int iTurnSlicesRemaining = GC.getGame().getTurnSlicesRemaining();

			if (iTurnSlicesRemaining > 0)
			{
				// Get number of seconds remaining
				int iTurnSecondsRemaining = ((int)floorf((float)(iTurnSlicesRemaining-1) * ((float)gDLL->getMillisecsPerTurn()/1000.0f)) + 1);
				int iTurnMinutesRemaining = (int)(iTurnSecondsRemaining/60);
				iTurnSecondsRemaining = (iTurnSecondsRemaining%60);
				int iTurnHoursRemaining = (int)(iTurnMinutesRemaining/60);
				iTurnMinutesRemaining = (iTurnMinutesRemaining%60);

				// Display time remaining
				CvWString szTempBuffer;
				szTempBuffer.Format(L"%d:%02d:%02d", iTurnHoursRemaining, iTurnMinutesRemaining, iTurnSecondsRemaining);
				strText += szTempBuffer;
			}
			else
			{
				// Flash zeroes
				if (iTurnSlicesRemaining % 2 == 0)
				{
					// Display 0
					strText+=L"0:00";
				}
			}
		}

		if (GC.getGame().getGameState() == GAMESTATE_ON)
		{
			int iMinVictoryTurns = MAX_INT;
			for (int i = 0; i < GC.getNumVictoryInfos(); ++i)
			{
				TeamTypes eActiveTeam = GC.getGame().getActiveTeam();
				if (NO_TEAM != eActiveTeam)
				{
					int iCountdown = GET_TEAM(eActiveTeam).getVictoryCountdown((VictoryTypes)i);
					if (iCountdown > 0 && iCountdown < iMinVictoryTurns)
					{
						iMinVictoryTurns = iCountdown;
					}
				}
			}

			if (GC.getGame().isOption(GAMEOPTION_ADVANCED_START) && GC.getGame().getElapsedGameTurns() <= getTreatyLength())
			{
				if (!strText.empty())
				{
					strText += L" -- ";
				}

				strText += gDLL->getText("TXT_KEY_MISC_ADVANCED_START_PEACE_REMAINING", getTreatyLength() - GC.getGame().getElapsedGameTurns());
			}
			else if (iMinVictoryTurns < MAX_INT)
			{
				if (!strText.empty())
				{
					strText += L" -- ";
				}

				strText += gDLL->getText("TXT_KEY_MISC_TURNS_LEFT_TO_VICTORY", iMinVictoryTurns);
			}
			else if (GC.getGame().getMaxTurns() > 0)
			{
				if ((GC.getGame().getElapsedGameTurns() >= (GC.getGame().getMaxTurns() - 100)) && (GC.getGame().getElapsedGameTurns() < GC.getGame().getMaxTurns()))
				{
					if (!strText.empty())
					{
						strText += L" -- ";
					}

					strText += gDLL->getText("TXT_KEY_MISC_TURNS_LEFT", (GC.getGame().getMaxTurns() - GC.getGame().getElapsedGameTurns()));
				}
			}
		}
	}
}


void CvGameTextMgr::getFontSymbols(std::vector< std::vector<wchar_t> >& aacSymbols, std::vector<int>& aiMaxNumRows)
{
	aacSymbols.push_back(std::vector<wchar_t>());
	aiMaxNumRows.push_back(1);
	for (int iI = 0; iI < NUM_YIELD_TYPES; iI++)
	{
		aacSymbols[aacSymbols.size() - 1].push_back((wchar_t) GC.getYieldInfo((YieldTypes) iI).getChar());
	}

	aacSymbols.push_back(std::vector<wchar_t>());
	aiMaxNumRows.push_back(2);
	for (int iI = 0; iI < NUM_COMMERCE_TYPES; iI++)
	{
		aacSymbols[aacSymbols.size() - 1].push_back((wchar_t) GC.getCommerceInfo((CommerceTypes) iI).getChar());
	}

	aacSymbols.push_back(std::vector<wchar_t>());
	aiMaxNumRows.push_back(8); // There are 26 rows of 25 icons each from the start of religions to the start of the generic symbols, 23 to the beginning of property symbols
	for (int iI = 0; iI < GC.getNumReligionInfos(); iI++)
	{
		aacSymbols[aacSymbols.size() - 1].push_back((wchar_t) GC.getReligionInfo((ReligionTypes) iI).getChar());
		aacSymbols[aacSymbols.size() - 1].push_back((wchar_t) GC.getReligionInfo((ReligionTypes) iI).getHolyCityChar());
	}
	for (int iI = 0; iI < GC.getNumCorporationInfos(); iI++)
	{
		aacSymbols[aacSymbols.size() - 1].push_back((wchar_t) GC.getCorporationInfo((CorporationTypes) iI).getChar());
		aacSymbols[aacSymbols.size() - 1].push_back((wchar_t) GC.getCorporationInfo((CorporationTypes) iI).getHeadquarterChar());
	}
	// TB: Invisibility symbols
	aacSymbols.push_back(std::vector<wchar_t>());
	aiMaxNumRows.push_back(1); // There is 1 row of 25 icons each from the start of invisibility symbols to the start of the property symbols
	for (int iI = 0; iI < GC.getNumInvisibleInfos(); iI++)
	{
		aacSymbols[aacSymbols.size() - 1].push_back((wchar_t) GC.getInvisibleInfo((InvisibleTypes) iI).getChar());
	}

	// AIAndy: Property symbols
	aacSymbols.push_back(std::vector<wchar_t>());
	aiMaxNumRows.push_back(3); // There are 3 rows of 25 icons each from the start of property symbols to the start of the generic symbols
	for (int iI = 0; iI < GC.getNumPropertyInfos(); iI++)
	{
		aacSymbols[aacSymbols.size() - 1].push_back((wchar_t) GC.getPropertyInfo((PropertyTypes) iI).getChar());
	}

	aacSymbols.push_back(std::vector<wchar_t>());
	aiMaxNumRows.push_back(2);
	for (int iI = 0; iI < MAX_NUM_SYMBOLS; iI++)
	{
		aacSymbols[aacSymbols.size() - 1].push_back((wchar_t) gDLL->getSymbolID(iI));
	}

	aacSymbols.push_back(std::vector<wchar_t>());
	aiMaxNumRows.push_back((GC.getNumBonusInfos() / 25) + 1);
	for (int iI = 0; iI < GC.getNumBonusInfos(); iI++)
	{
		int iChar = GC.getBonusInfo((BonusTypes) iI).getChar();
		aacSymbols[aacSymbols.size() - 1].push_back((wchar_t) iChar);
	}

}

void CvGameTextMgr::assignFontIds(int iFirstSymbolCode, int iPadAmount)
{
	int iCurSymbolID = iFirstSymbolCode;  // first symbol code = 8483
	int i;

	// set yield symbols
	for (i = 0; i < NUM_YIELD_TYPES; i++)
	{
		GC.getYieldInfo((YieldTypes) i).setChar(iCurSymbolID);
		++iCurSymbolID;
	}

	do
	{
		++iCurSymbolID;
	} while (iCurSymbolID % iPadAmount != 0);

	//8500

	// set commerce symbols
	for (i = 0; i < NUM_COMMERCE_TYPES; i++)
	{
		GC.getCommerceInfo((CommerceTypes) i).setChar(iCurSymbolID);
		++iCurSymbolID;
	}

	do
	{
		++iCurSymbolID;
	} while (iCurSymbolID % iPadAmount != 0);

	//8525
	if (NUM_COMMERCE_TYPES < iPadAmount)
	{
		do
		{
			++iCurSymbolID;
		} while (iCurSymbolID % iPadAmount != 0);
	}

	//8550
	for (i = 0; i < GC.getNumReligionInfos(); i++)
	{
		GC.getReligionInfo((ReligionTypes) i).setChar(iCurSymbolID);
		++iCurSymbolID;
		GC.getReligionInfo((ReligionTypes) i).setHolyCityChar(iCurSymbolID);
		++iCurSymbolID;
	}
	//int iRel = i; //138
	//8826
	for (i = 0; i < GC.getNumCorporationInfos(); i++)
	{
		GC.getCorporationInfo((CorporationTypes) i).setChar(iCurSymbolID);
		++iCurSymbolID;
		GC.getCorporationInfo((CorporationTypes) i).setHeadquarterChar(iCurSymbolID);
		++iCurSymbolID;
	}
	//int iCorp = i;//138
	//9102
	do
	{
		++iCurSymbolID;
	} while (iCurSymbolID % iPadAmount != 0);
	//9125
	if (2 * (GC.getNumReligionInfos() + GC.getNumCorporationInfos()) < iPadAmount)
	{
		do
		{
			++iCurSymbolID;
		} while (iCurSymbolID % iPadAmount != 0);
	}

	int iSavePosition=iCurSymbolID;
	int propertyBaseID = iSavePosition;
	// AIAndy: Property symbols
	for (i = 0; i < GC.getNumPropertyInfos(); i++)
	{
		int propertyID = propertyBaseID + GC.getPropertyInfo((PropertyTypes) i).getFontButtonIndex();
		GC.getPropertyInfo((PropertyTypes) i).setChar(propertyID);
		//++iCurSymbolID;
	}

// modified Sephi
// Symbol loading adjusted to WoC.

	// set bonus symbols
	int invisBaseID = iSavePosition -23;
	//++iCurSymbolID;
	for (i = 0; i < GC.getNumInvisibleInfos(); i++)
	{
		int invisID = invisBaseID + GC.getInvisibleInfo((InvisibleTypes)i).getFontButtonIndex();
		GC.getInvisibleInfo((InvisibleTypes) i).setChar(invisID);
		//++iCurSymbolID;
	}

	// set bonus symbols
	int bonusBaseID = iSavePosition + 125;
	//++iCurSymbolID;
	for (i = 0; i < GC.getNumBonusInfos(); i++)
	{
		int bonusID = bonusBaseID + GC.getBonusInfo((BonusTypes) i).getArtInfo()->getFontButtonIndex();
		GC.getBonusInfo((BonusTypes) i).setChar(bonusID);
		//++iCurSymbolID;
	}
	// 9206
	iCurSymbolID=iSavePosition+125;
	iCurSymbolID-=(MAX_NUM_SYMBOLS);
	do
	{
		--iCurSymbolID;
	} while (iCurSymbolID % iPadAmount != 0);

// modified Sephi
	// set extra symbols
	for (i=0; i < MAX_NUM_SYMBOLS; i++)
	{
		gDLL->setSymbolID(i, iCurSymbolID);
		++iCurSymbolID;
	}
} // 9226

void CvGameTextMgr::getCityDataForAS(std::vector<CvWBData>& mapCityList, std::vector<CvWBData>& mapBuildingList, std::vector<CvWBData>& mapAutomateList)
{
	CvPlayer& kActivePlayer = GET_PLAYER(GC.getGame().getActivePlayer());

	CvWString szHelp;
	int iCost = kActivePlayer.getAdvancedStartCityCost(true);
	if (iCost > 0)
	{
		szHelp = gDLL->getText("TXT_KEY_CITY");
		szHelp += gDLL->getText("TXT_KEY_AS_UNREMOVABLE");
		mapCityList.push_back(CvWBData(0, szHelp, ARTFILEMGR.getInterfaceArtInfo("INTERFACE_BUTTONS_CITYSELECTION")->getPath()));
	}

	iCost = kActivePlayer.getAdvancedStartPopCost(true);
	if (iCost > 0)
	{
		szHelp = gDLL->getText("TXT_KEY_WB_AS_POPULATION");
		mapCityList.push_back(CvWBData(1, szHelp, ARTFILEMGR.getInterfaceArtInfo("INTERFACE_ANGRYCITIZEN_TEXTURE")->getPath()));
	}

	iCost = kActivePlayer.getAdvancedStartCultureCost(true);
	if (iCost > 0)
	{
		szHelp = gDLL->getText("TXT_KEY_ADVISOR_CULTURE");
		szHelp += gDLL->getText("TXT_KEY_AS_UNREMOVABLE");
		mapCityList.push_back(CvWBData(2, szHelp, ARTFILEMGR.getInterfaceArtInfo("CULTURE_BUTTON")->getPath()));
	}

	CvWStringBuffer szBuffer;
	for (int i = 0; i < GC.getNumBuildingInfos(); i++)
	{
		const BuildingTypes eBuilding = static_cast<BuildingTypes>(i);
		if (GC.getBuildingInfo(eBuilding).getFreeStartEra() == NO_ERA || GC.getGame().getStartEra() < GC.getBuildingInfo(eBuilding).getFreeStartEra())
		{
			// Building cost -1 denotes unit which may not be purchased
			iCost = kActivePlayer.getAdvancedStartBuildingCost(eBuilding, true);
			if (iCost > 0)
			{
				szBuffer.clear();
				setBuildingHelp(szBuffer, eBuilding);
				mapBuildingList.push_back(CvWBData(eBuilding, szBuffer.getCString(), GC.getBuildingInfo(eBuilding).getButton()));
			}
		}
	}

	szHelp = gDLL->getText("TXT_KEY_ACTION_AUTOMATE_BUILD");
	mapAutomateList.push_back(CvWBData(0, szHelp, ARTFILEMGR.getInterfaceArtInfo("INTERFACE_AUTOMATE")->getPath()));
}

void CvGameTextMgr::getUnitDataForAS(std::vector<CvWBData>& mapUnitList)
{
	CvPlayer& kActivePlayer = GET_PLAYER(GC.getGame().getActivePlayer());

	CvWStringBuffer szBuffer;
	for(int i = 0; i < GC.getNumUnitInfos(); i++)
	{
		// Unit cost less than 1 denotes unit which may not be purchased
		if (kActivePlayer.getAdvancedStartUnitCost((UnitTypes) i, true) > 0)
		{
			szBuffer.clear();
			setUnitHelp(szBuffer, (UnitTypes) i);

			if (GC.getDefineINT("ADVANCED_START_MAX_UNITS_PER_CITY") >= 0 && GC.getUnitInfo((UnitTypes) i).isMilitarySupport())
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_WB_AS_MAX_UNITS_PER_CITY", GC.getDefineINT("ADVANCED_START_MAX_UNITS_PER_CITY")));
			}
			mapUnitList.push_back(CvWBData((UnitTypes) i, szBuffer.getCString(), kActivePlayer.getUnitButton((UnitTypes) i)));
		}
	}
}

void CvGameTextMgr::getImprovementDataForAS(std::vector<CvWBData>& mapImprovementList, std::vector<CvWBData>& mapRouteList)
{
	const CvPlayer& kActivePlayer = GET_PLAYER(GC.getGame().getActivePlayer());

	CvWStringBuffer szBuffer;
	for (int i = 0; i < GC.getNumRouteInfos(); i++)
	{
		const RouteTypes eRoute = (RouteTypes) i;
		if (eRoute != NO_ROUTE)
		{
			// Route cost -1 denotes route which may not be purchased
			const int iCost = kActivePlayer.getAdvancedStartRouteCost(eRoute, true);
			if (iCost > 0)
			{
				szBuffer.clear();
				setRouteHelp(szBuffer, eRoute);
				mapRouteList.push_back(CvWBData(eRoute, szBuffer.getCString(), GC.getRouteInfo(eRoute).getButton()));
			}
		}
	}

	for (int i = 0; i < GC.getNumImprovementInfos(); i++)
	{
		const ImprovementTypes eImprovement = (ImprovementTypes) i;
		if (eImprovement != NO_IMPROVEMENT)
		{
			// Improvement cost -1 denotes Improvement which may not be purchased
			const int iCost = kActivePlayer.getAdvancedStartImprovementCost(eImprovement, true);
			if (iCost > 0)
			{
				szBuffer.clear();
				setImprovementHelp(szBuffer, eImprovement);
				mapImprovementList.push_back(CvWBData(eImprovement, szBuffer.getCString(), GC.getImprovementInfo(eImprovement).getButton()));
			}
		}
	}
}

void CvGameTextMgr::getVisibilityDataForAS(std::vector<CvWBData>& mapVisibilityList)
{
	// Unit cost -1 denotes unit which may not be purchased
	const int iCost = GET_PLAYER(GC.getGame().getActivePlayer()).getAdvancedStartVisibilityCost();
	if (iCost > 0)
	{
		CvWString szHelp = gDLL->getText("TXT_KEY_WB_AS_VISIBILITY");
		szHelp += gDLL->getText("TXT_KEY_AS_UNREMOVABLE", iCost);
		mapVisibilityList.push_back(CvWBData(0, szHelp, ARTFILEMGR.getInterfaceArtInfo("INTERFACE_TECH_LOS")->getPath()));
	}
}

void CvGameTextMgr::getTechDataForAS(std::vector<CvWBData>& mapTechList)
{
	mapTechList.push_back(CvWBData(0, gDLL->getText("TXT_KEY_WB_AS_TECH"), ARTFILEMGR.getInterfaceArtInfo("INTERFACE_BTN_TECH")->getPath()));
}

void CvGameTextMgr::getUnitDataForWB(std::vector<CvWBData>& mapUnitData)
{
	CvWStringBuffer szBuffer;
	for (int i = 0; i < GC.getNumUnitInfos(); i++)
	{
		szBuffer.clear();
		setUnitHelp(szBuffer, (UnitTypes)i);
		mapUnitData.push_back(CvWBData(i, szBuffer.getCString(), GC.getUnitInfo((UnitTypes)i).getButton()));
	}
}

void CvGameTextMgr::getBuildingDataForWB(bool bStickyButton, std::vector<CvWBData>& mapBuildingData)
{
	int iCount = 0;
	if (!bStickyButton)
	{
		mapBuildingData.push_back(CvWBData(iCount++, GC.getMissionInfo(MISSION_FOUND).getDescription(), GC.getMissionInfo(MISSION_FOUND).getButton()));
	}

	CvWStringBuffer szBuffer;
	for (int i=0; i < GC.getNumBuildingInfos(); i++)
	{
		szBuffer.clear();
		setBuildingHelp(szBuffer, (BuildingTypes)i);
		mapBuildingData.push_back(CvWBData(iCount++, szBuffer.getCString(), GC.getBuildingInfo((BuildingTypes)i).getButton()));
	}
}

void CvGameTextMgr::getTerrainDataForWB(std::vector<CvWBData>& mapTerrainData, std::vector<CvWBData>& mapFeatureData, std::vector<CvWBData>& mapPlotData, std::vector<CvWBData>& mapRouteData)
{
	CvWStringBuffer szBuffer;

	for (int i = 0; i < GC.getNumTerrainInfos(); i++)
	{
		if (!GC.getTerrainInfo((TerrainTypes)i).isGraphicalOnly())
		{
			szBuffer.clear();
			setTerrainHelp(szBuffer, (TerrainTypes)i);
			mapTerrainData.push_back(CvWBData(i, szBuffer.getCString(), GC.getTerrainInfo((TerrainTypes)i).getButton()));
		}
	}

	for (int i = 0; i < GC.getNumFeatureInfos(); i++)
	{
		for (int k = 0; k < GC.getFeatureInfo((FeatureTypes)i).getArtInfo()->getNumVarieties(); k++)
		{
			szBuffer.clear();
			setFeatureHelp(szBuffer, (FeatureTypes)i);
			mapFeatureData.push_back(CvWBData(i + GC.getNumFeatureInfos() * k, szBuffer.getCString(), GC.getFeatureInfo((FeatureTypes)i).getArtInfo()->getVariety(k).getVarietyButton()));
		}
	}

	mapPlotData.push_back(CvWBData(0, gDLL->getText("TXT_KEY_WB_PLOT_TYPE_MOUNTAIN"), ARTFILEMGR.getInterfaceArtInfo("WORLDBUILDER_PLOT_TYPE_MOUNTAIN")->getPath()));
	mapPlotData.push_back(CvWBData(1, gDLL->getText("TXT_KEY_WB_PLOT_TYPE_HILL"), ARTFILEMGR.getInterfaceArtInfo("WORLDBUILDER_PLOT_TYPE_HILL")->getPath()));
	mapPlotData.push_back(CvWBData(2, gDLL->getText("TXT_KEY_WB_PLOT_TYPE_PLAINS"), ARTFILEMGR.getInterfaceArtInfo("WORLDBUILDER_PLOT_TYPE_PLAINS")->getPath()));
	mapPlotData.push_back(CvWBData(3, gDLL->getText("TXT_KEY_WB_PLOT_TYPE_OCEAN"), ARTFILEMGR.getInterfaceArtInfo("WORLDBUILDER_PLOT_TYPE_OCEAN")->getPath()));

	for (int i = 0; i < GC.getNumRouteInfos(); i++)
	{
		mapRouteData.push_back(CvWBData(i, GC.getRouteInfo((RouteTypes)i).getDescription(), GC.getRouteInfo((RouteTypes)i).getButton()));
	}
	mapRouteData.push_back(CvWBData(GC.getNumRouteInfos(), gDLL->getText("TXT_KEY_WB_RIVER_PLACEMENT"), ARTFILEMGR.getInterfaceArtInfo("WORLDBUILDER_RIVER_PLACEMENT")->getPath()));
}

void CvGameTextMgr::getTerritoryDataForWB(std::vector<CvWBData>& mapTerritoryData)
{
	for (int i = 0; i < MAX_PLAYERS; i++)
	{
		CvWString szName = gDLL->getText("TXT_KEY_MAIN_MENU_NONE");
		CvString szButton = GC.getCivilizationInfo(GET_PLAYER(BARBARIAN_PLAYER).getCivilizationType()).getButton();

		if (GET_PLAYER((PlayerTypes) i).isEverAlive())
		{
			szName = GET_PLAYER((PlayerTypes)i).getName();
			szButton = GC.getCivilizationInfo(GET_PLAYER((PlayerTypes)i).getCivilizationType()).getButton();
		}
		mapTerritoryData.push_back(CvWBData(i, szName, szButton));
	}
}


void CvGameTextMgr::getTechDataForWB(std::vector<CvWBData>& mapTechData)
{
	CvWStringBuffer szBuffer;
	for (int i=0; i < GC.getNumTechInfos(); i++)
	{
		szBuffer.clear();
		setTechHelp(szBuffer, (TechTypes) i);
		mapTechData.push_back(CvWBData(i, szBuffer.getCString(), GC.getTechInfo((TechTypes) i).getButton()));
	}
}

void CvGameTextMgr::getPromotionDataForWB(std::vector<CvWBData>& mapPromotionData)
{
	CvWStringBuffer szBuffer;
	for (int i=0; i < GC.getNumPromotionInfos(); i++)
	{
		szBuffer.clear();
		setPromotionHelp(szBuffer, (PromotionTypes) i, false);
		mapPromotionData.push_back(CvWBData(i, szBuffer.getCString(), GC.getPromotionInfo((PromotionTypes) i).getButton()));
	}
}

void CvGameTextMgr::getTraitDataForWB(std::vector<CvWBData>& mapTraitData)
{
	CvWStringBuffer szBuffer;
	for (int i=0; i < GC.getNumTraitInfos(); i++)
	{
		szBuffer.clear();
		setTraitHelp(szBuffer, (TraitTypes) i);
		mapTraitData.push_back(CvWBData(i, szBuffer.getCString(), GC.getTraitInfo((TraitTypes) i).getButton()));
	}
}

void CvGameTextMgr::getBonusDataForWB(std::vector<CvWBData>& mapBonusData)
{
	CvWStringBuffer szBuffer;
	for (int i=0; i < GC.getNumBonusInfos(); i++)
	{
		szBuffer.clear();
		setBonusHelp(szBuffer, (BonusTypes)i);
		mapBonusData.push_back(CvWBData(i, szBuffer.getCString(), GC.getBonusInfo((BonusTypes) i).getButton()));
	}
}

void CvGameTextMgr::getImprovementDataForWB(std::vector<CvWBData>& mapImprovementData)
{
	CvWStringBuffer szBuffer;
	for (int i=0; i < GC.getNumImprovementInfos(); i++)
	{
		const CvImprovementInfo& kInfo = GC.getImprovementInfo((ImprovementTypes) i);
		if (!kInfo.isGraphicalOnly())
		{
			szBuffer.clear();
			setImprovementHelp(szBuffer, (ImprovementTypes) i);
			mapImprovementData.push_back(CvWBData(i, szBuffer.getCString(), kInfo.getButton()));
		}
	}
}

void CvGameTextMgr::getRouteDataForWB(std::vector<CvWBData>& mapRouteData)
{
	CvWStringBuffer szBuffer;
	for (int i=0; i < GC.getNumRouteInfos(); i++)
	{
		const CvRouteInfo& kInfo = GC.getRouteInfo((RouteTypes) i);
		if (!kInfo.isGraphicalOnly())
		{
			szBuffer.clear();
			setRouteHelp(szBuffer, (RouteTypes) i);
			mapRouteData.push_back(CvWBData(i, szBuffer.getCString(), kInfo.getButton()));
		}
	}
}

void CvGameTextMgr::getReligionDataForWB(bool bHolyCity, std::vector<CvWBData>& mapReligionData)
{
	for (int i = 0; i < GC.getNumReligionInfos(); ++i)
	{
		const CvReligionInfo& kInfo = GC.getReligionInfo((ReligionTypes) i);
		CvWString strDescription = kInfo.getDescription();
		if (bHolyCity)
		{
			strDescription = gDLL->getText("TXT_KEY_WB_HOLYCITY", strDescription.GetCString());
		}
		mapReligionData.push_back(CvWBData(i, strDescription, kInfo.getButton()));
	}
}


void CvGameTextMgr::getCorporationDataForWB(bool bHeadquarters, std::vector<CvWBData>& mapCorporationData)
{
	for (int i = 0; i < GC.getNumCorporationInfos(); ++i)
	{
		const CvCorporationInfo& kInfo = GC.getCorporationInfo((CorporationTypes) i);
		CvWString strDescription = kInfo.getDescription();
		if (bHeadquarters)
		{
			strDescription = gDLL->getText("TXT_KEY_CORPORATION_HEADQUARTERS", strDescription.GetCString());
		}
		mapCorporationData.push_back(CvWBData(i, strDescription, kInfo.getButton()));
	}
}


void CvGameTextMgr::buildCanPassPeaksString(CvWStringBuffer &szBuffer, TechTypes eTech, bool bList, bool bPlayerContext)
{
	if (GC.getTechInfo(eTech).isCanPassPeaks() && (!bPlayerContext || !(GET_TEAM(GC.getGame().getActiveTeam()).isCanPassPeaks())))
	{
		if (bList)
		{
			szBuffer.append(NEWLINE);
		}
		szBuffer.append(gDLL->getText("TXT_KEY_CAN_PASS_PEAKS"));
	}
}

void CvGameTextMgr::buildMoveFastPeaksString(CvWStringBuffer &szBuffer, TechTypes eTech, bool bList, bool bPlayerContext)
{
	if (GC.getTechInfo(eTech).isMoveFastPeaks() && (!bPlayerContext || !(GET_TEAM(GC.getGame().getActiveTeam()).isMoveFastPeaks())))
	{
		if (bList)
		{
			szBuffer.append(NEWLINE);
		}
		szBuffer.append(gDLL->getText("TXT_KEY_MOVE_FAST_PEAKS"));
	}
}

void CvGameTextMgr::buildCanFoundOnPeaksString(CvWStringBuffer &szBuffer, TechTypes eTech, bool bList, bool bPlayerContext)
{
	if (GC.getTechInfo(eTech).isCanFoundOnPeaks() && (!bPlayerContext || !(GET_TEAM(GC.getGame().getActiveTeam()).isCanFoundOnPeaks())))
	{
		if (bList)
		{
			szBuffer.append(NEWLINE);
		}
		szBuffer.append(gDLL->getText("TXT_KEY_CAN_FOUND_ON_PEAKS"));
	}
}

void CvGameTextMgr::buildCanRebaseAnywhereString(CvWStringBuffer &szBuffer, TechTypes eTech, bool bList, bool bPlayerContext)
{
	if (GC.getDefineINT("MAX_AIRLIFT_RANGE") > 0)
	{
		if (GC.getTechInfo(eTech).isRebaseAnywhere() && (!bPlayerContext || !(GET_TEAM(GC.getGame().getActiveTeam()).isRebaseAnywhere())))
		{
			if (bList)
			{
				szBuffer.append(NEWLINE);
			}
			szBuffer.append(gDLL->getText("TXT_KEY_CAN_REBASE_ANYWHERE"));
		}
	}
}


/*
	+50% from Buildings
	+25% from Wonders
	+10% from resources
	+25% from Civics
	+25% from Culture
	+10% from Terrain
	=======================
	Base Defense: 100%
	=======================
	Percent Siege Damaged: 25%
	Siege Damage 25%
	Current Defense: 75%
	=======================
	Base Bombard Defense: 60%
	=======================
	* Walls: +30%
*/
void CvGameTextMgr::setDefenseHelp(CvWStringBuffer &szBuffer, CvCity& city)
{
	FAssertMsg(NO_PLAYER != city.getOwner(), "City must have an owner");

	int iBaseRate = 0;
	int iI, iJ;

	CvWString szTempBuffer;

	// Buildings
	int iBuildingDefense = 0;
	int iBombardDefense = 0;
	int iWonderDefense = 0;
	int iResourceDefense = 0;
	bool bWonder = false;
	for (iI = 0; iI < GC.getNumBuildingInfos(); iI++)
	{
		const int iCount = city.getNumActiveBuilding((BuildingTypes)iI);
		if (isWorldWonder((BuildingTypes)iI))
			bWonder = true;
		else if (isTeamWonder((BuildingTypes)iI))
			bWonder = true;
		else if (isNationalWonder((BuildingTypes)iI))
			bWonder = true;

		const CvBuildingInfo& kBuilding = GC.getBuildingInfo((BuildingTypes)iI);
		if (iCount > 0 && !bWonder)
		{
			iBuildingDefense += iCount * (kBuilding.getDefenseModifier());
			iBombardDefense += iCount * kBuilding.getBombardDefenseModifier();
			for (iJ = 0; iJ < GC.getNumBonusInfos(); iJ++)
			{
				if (city.hasBonus((BonusTypes)iJ))
				{
					iResourceDefense += kBuilding.getBonusDefenseChanges(iJ);
				}
			}
		}
		else if (iCount > 0)
		{
			iWonderDefense += iCount * (kBuilding.getDefenseModifier());
			iBombardDefense += iCount * kBuilding.getBombardDefenseModifier();
			for (iJ = 0; iJ < GC.getNumBonusInfos(); iJ++)
			{
				if (city.hasBonus((BonusTypes)iJ))
				{
					iResourceDefense += kBuilding.getBonusDefenseChanges(iJ);
				}
			}
		}
		bWonder = false;
	}
	bool bFirst = false;
	if (iBuildingDefense != 0)
	{
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_BUILDING_DEFENSE_HOVER", iBuildingDefense));
		iBaseRate += iBuildingDefense;
		bFirst = true;
	}

	int iCivicDefense = 0;
	for (iJ = 0; iJ < GC.getNumCivicOptionInfos(); iJ++)
	{
		CivicTypes eCivic;
		eCivic = GET_PLAYER(city.getOwner()).getCivics((CivicOptionTypes)iJ);
		if (GC.getCivicInfo(eCivic).getExtraCityDefense() != 0)
		{
			iCivicDefense += GC.getCivicInfo(eCivic).getExtraCityDefense();
		}
	}

	int iTraitDefense = 0;
	for (iJ = 0; iJ < GC.getNumTraitInfos(); iJ++)
	{
		TraitTypes eTrait = ((TraitTypes)iJ);
		if (GET_PLAYER(city.getOwner()).hasTrait(eTrait))
		{
			iBombardDefense += GC.getTraitInfo(eTrait).getBombardDefense();
			if (GC.getTraitInfo(eTrait).getCityDefenseBonus() != 0)
			{
				iTraitDefense += GC.getTraitInfo(eTrait).getCityDefenseBonus();
			}
		}
	}

	iWonderDefense += GET_PLAYER(city.getOwner()).getCityDefenseModifier() - iCivicDefense - iTraitDefense;
	if (iWonderDefense != 0)
	{
		if (bFirst)
			szBuffer.append(NEWLINE);
		else
			bFirst = true;
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_WONDER_DEFENSE_HOVER", iWonderDefense));
		iBaseRate += iWonderDefense;
	}
	if (iResourceDefense != 0)
	{
		if (bFirst)
			szBuffer.append(NEWLINE);
		else
			bFirst = true;
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_RESOURCE_DEFENSE_HOVER", iResourceDefense));
		iBaseRate += iResourceDefense;
	}

	if (iCivicDefense != 0)
	{
		if (bFirst)
			szBuffer.append(NEWLINE);
		else
			bFirst = true;
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_CIVIC_DEFENSE_HOVER", iCivicDefense));
		iBaseRate += iCivicDefense;
	}

	if (iTraitDefense != 0)
	{
		if (bFirst)
			szBuffer.append(NEWLINE);
		else
			bFirst = true;
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_TRAIT_DEFENSE_HOVER", iTraitDefense));
		iBaseRate += iTraitDefense;
	}

	int iCultureDefense = 0;
	iCultureDefense += city.getNaturalDefense();
	iCultureDefense -= iBuildingDefense;
	if (iCultureDefense > 0)
	{
		if (bFirst)
			szBuffer.append(NEWLINE);
		else
			bFirst = true;
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_CULTURE_DEFENSE_HOVER", iCultureDefense));
		iBaseRate += iCultureDefense;
	}

	int iClaimedDefense = city.getTotalDefense(false);
	//TB DEBUG NOTE!!!! The following will often trigger due to the fact that right now buildings that have been replaced are still being
	//instructed to add their defense value.  I'm currently looking into this.  Search for TB DEFENSEBUG to see the place where there's an issue.
	//The problem with this is that the actual .getTotalDefense is tallying those into the picture but the display is not.  If this is an
	//intended performance then we should compile this 'not obsolete but is replaced' defense into a new display line and add it to the total here.
	FAssertMsg(iBaseRate == iClaimedDefense, "City Defense Does Not add up Correctly");

	if (iBaseRate > 0)
	// ==========================
		szBuffer.append(DOUBLE_SEPARATOR);
	if (iBaseRate != 0)
	{
		// If iBaseRate isn't zero we definitely already added stuff above
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_TOTAL_DEFENSE_HOVER", iBaseRate));
	}
	int iTerrainDefense = std::max(0, city.plot()->defenseModifier(GET_PLAYER(city.getOwner()).getTeam(), false, true));
	if (iTerrainDefense != 0)
	{
		if (bFirst)
			szBuffer.append(NEWLINE);
		else
			bFirst = true;
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_TERRAIN_DEFENSE_HOVER", iTerrainDefense));
		iBaseRate += iTerrainDefense;
	}
	if (iBaseRate > 0)
	{
		// ==========================
		szBuffer.append(DOUBLE_SEPARATOR);
	}
	int iDefenseDamagePercent = city.getDefenseDamage();
	if (iDefenseDamagePercent != 0)
	{
		if (bFirst)
			szBuffer.append(NEWLINE);
		else
			bFirst = true;
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_DEFENSE_DAMAGE_PERCENT_HOVER", iDefenseDamagePercent));
	}
	int iDefenseDamage = ((iBaseRate - iTerrainDefense) * city.getDefenseDamage()) / 100;
	if (iDefenseDamage != 0)
	{
		if (bFirst)
			szBuffer.append(NEWLINE);
		else
			bFirst = true;
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_DEFENSE_DAMAGE_HOVER", iDefenseDamage));
	}
	if (iBaseRate != 0)
	{
		// If iBaseRate isn't zero we definitely already added stuff above
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_CURRENT_DEFENSE_HOVER", (iBaseRate - iDefenseDamage)));
	}

	if (city.getExtraMinDefense() != 0)
	{// ==========================
		szBuffer.append(DOUBLE_SEPARATOR);
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_MIN_DEFENSE_HOVER", city.getExtraMinDefense()));
	}

	if (city.getMinimumDefenseLevel() > 0)
	{// ==========================
		szBuffer.append(DOUBLE_SEPARATOR);
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_MINIMUM_DEFENSE_LEVEL_HOVER", city.getMinimumDefenseLevel()));
	}

	if (city.getExtraBuildingDefenseRecoverySpeedModifier() != 0)
	{// ==========================
		szBuffer.append(DOUBLE_SEPARATOR);
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_BUILDING_RECOVERY_HOVER", city.getExtraBuildingDefenseRecoverySpeedModifier(), city.getModifiedBuildingDefenseRecoverySpeedCap()));
	}

	if (city.getExtraCityDefenseRecoverySpeedModifier() != 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_CITY_RECOVERY_HOVER", city.getExtraCityDefenseRecoverySpeedModifier()));
	}

	if (iBombardDefense != 0)
	{// ==========================
		szBuffer.append(DOUBLE_SEPARATOR);
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_BUILDING_BOMBARD_DEFENSE_HOVER", iBombardDefense));
	}

	bFirst = true;
	for (iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
	{
		if (city.getUnitCombatDefenseAgainstModifierTotal((UnitCombatTypes)iI) != 0)
		{
			if (bFirst)
			{
				szBuffer.append(DOUBLE_SEPARATOR);
				bFirst = false;
			}
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_MISC_DEFENSE_AGAINST_UNIT_COMBAT_HOVER", city.getUnitCombatDefenseAgainstModifierTotal((UnitCombatTypes)iI), GC.getUnitCombatInfo((UnitCombatTypes)iI).getTextKeyWide()));
		}
	}

	for (iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
	{
		if (city.getUnitCombatExtraStrength((UnitCombatTypes)iI) != 0)
		{
			if (bFirst)
			{
				szBuffer.append(DOUBLE_SEPARATOR);
				bFirst = false;
			}
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_MISC_DEFENSE_UNIT_COMBAT_HOVER", GC.getUnitCombatInfo((UnitCombatTypes)iI).getTextKeyWide(), city.getUnitCombatExtraStrength((UnitCombatTypes)iI)));
		}
	}

	if (city.getExtraLocalDynamicDefense() != 0)
	{// ==========================
		szBuffer.append(DOUBLE_SEPARATOR);
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_BUILDING_DYNAMIC_DEFENSE_HOVER", city.getExtraLocalDynamicDefense()));
	}

	if (city.getExtraRiverDefensePenalty() != 0)
	{// ==========================
		szBuffer.append(DOUBLE_SEPARATOR);
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_BUILDING_RIVER_DEFENSE_HOVER", city.getExtraRiverDefensePenalty()));
	}

	if (city.getEspionageDefenseModifier() != 0)
	{// ==========================
		szBuffer.append(DOUBLE_SEPARATOR);
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_BUILDING_ESPIONAGE_DEFENSE_HOVER", city.getEspionageDefenseModifier()));
	}

	if (city.getExtraInsidiousness() != 0)
	{// ==========================
		szBuffer.append(DOUBLE_SEPARATOR);
		szBuffer.append(NEWLINE);
		float fValue = (float)city.getExtraInsidiousness();
		{
			szTempBuffer.Format(L"%.1f", fValue/10);
		}
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_BUILDING_INSIDIOUSNESS_HOVER", szTempBuffer.GetCString()));
	}

	if (city.getInvestigationTotal() != 0)
	{// ==========================
		szBuffer.append(DOUBLE_SEPARATOR);
		szBuffer.append(NEWLINE);
		float fValue = (float)city.getInvestigationTotal();
		{
			szTempBuffer.Format(L"%.1f", fValue/10);
		}
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_BUILDING_INVESTIGATION_HOVER", szTempBuffer.GetCString()));
	}

	int iNumCrim = city.plot()->getNumCriminals();
	if (iNumCrim > 0)
	{// ==========================
		szBuffer.append(DOUBLE_SEPARATOR);
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_CRIMINAL_COUNT_DEFENSE_HOVER", iNumCrim));
	}

	if (city.getExtraLocalRepel() != 0)
	{// ==========================
		szBuffer.append(DOUBLE_SEPARATOR);
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_LOCAL_REPEL_HOVER", city.getExtraLocalRepel()));
	}

	for (iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
	{
		if (city.getUnitCombatRepelAgainstModifierTotal((UnitCombatTypes)iI) != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_MISC_REPEL_AGAINST_UNIT_COMBAT_HOVER", city.getUnitCombatRepelAgainstModifierTotal((UnitCombatTypes)iI), GC.getUnitCombatInfo((UnitCombatTypes)iI).getTextKeyWide()));
		}
	}

	for (iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
	{
		if (city.getUnitCombatRepelModifierTotal((UnitCombatTypes)iI) != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_MISC_REPEL_UNIT_COMBAT_HOVER", GC.getUnitCombatInfo((UnitCombatTypes)iI).getTextKeyWide(), city.getUnitCombatRepelModifierTotal((UnitCombatTypes)iI)));
		}
	}

	if (GC.getGame().isOption(GAMEOPTION_ZONE_OF_CONTROL) && city.isZoneOfControl())
	{// ==========================
		szBuffer.append(DOUBLE_SEPARATOR);
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_ZOC_HOVER"));
	}

	int iAdjDmg = city.getAdjacentDamagePercent();
	if (city.getAdjacentDamagePercent())
	{// ==========================
		szBuffer.append(DOUBLE_SEPARATOR);
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_ADJ_DMG_HOVER", iAdjDmg));
	}

	bFirst = true;
	for (int iJ = 0; iJ < GC.getNumBuildingInfos(); iJ++)
	{
		BuildingTypes eBuilding = (BuildingTypes)iJ;
		if (city.getNumActiveBuilding(eBuilding) > 0 && GC.getBuildingInfo(eBuilding).isDamageAttackerCapable())
		{
			if (GC.getBuildingInfo(eBuilding).isDamageAllAttackers())
			{
				if (GC.getBuildingInfo(eBuilding).getDamageAttackerChance() > 0 && GC.getBuildingInfo(eBuilding).getDamageToAttacker() > 0)
				{
					if (bFirst)
					{
						// ==========================
						szBuffer.append(DOUBLE_SEPARATOR);
						bFirst = false;
					}
					if (GC.getBuildingInfo(eBuilding).isDamageToAttackerIgnoresArmor())
					{
						szBuffer.append(NEWLINE);
						szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_DAMAGE_ALL_ATTACKER_ARMOR_EXEMPT", GC.getBuildingInfo(eBuilding).getDamageAttackerChance(), GC.getBuildingInfo(eBuilding).getDamageToAttacker()));
					}
					else
					{
						szBuffer.append(NEWLINE);
						szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_DAMAGE_ALL_ATTACKER", GC.getBuildingInfo(eBuilding).getDamageAttackerChance(), GC.getBuildingInfo(eBuilding).getDamageToAttacker()));
					}
				}
			}
			else
			{
				for (iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
				{
					UnitCombatTypes eUnitCombat = ((UnitCombatTypes)iI);
					if (city.canDamageAttackingUnitCombat(eUnitCombat))
					{
						if (GC.getBuildingInfo(eBuilding).isMayDamageAttackingUnitCombatType(eUnitCombat))
						{
							if (GC.getBuildingInfo(eBuilding).getDamageAttackerChance() > 0 && GC.getBuildingInfo(eBuilding).getDamageToAttacker() > 0)
							{
								if (bFirst)
								{
									// ==========================
									szBuffer.append(DOUBLE_SEPARATOR);
									szBuffer.append(NEWLINE);
									szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_DAMAGE_ATTACKER_START", GC.getUnitCombatInfo(eUnitCombat).getTextKeyWide()));
								}
								else if (!bFirst)
								{
									szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_DAMAGE_ATTACKER_MIDDLE", GC.getUnitCombatInfo(eUnitCombat).getTextKeyWide()));
								}
								bFirst = false;
							}
						}
					}
				}
				if (!bFirst)
				{
					if (GC.getBuildingInfo(eBuilding).isDamageToAttackerIgnoresArmor())
					{
						szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_DAMAGE_ATTACKER_END_ARMOR_EXEMPT", GC.getBuildingInfo(eBuilding).getDamageAttackerChance(), GC.getBuildingInfo(eBuilding).getDamageToAttacker()));
					}
					else
					{
						szBuffer.append(gDLL->getText("TXT_KEY_BUILDING_DAMAGE_ATTACKER_END", GC.getBuildingInfo(eBuilding).getDamageAttackerChance(), GC.getBuildingInfo(eBuilding).getDamageToAttacker()));
					}
				}
			}
		}
	}

	if (city.getOwner() == GC.getGame().getActivePlayer())
	{
		// BUG - Building Additional Defense - start
		if (city.getOwner() == GC.getGame().getActivePlayer() && getBugOptionBOOL("MiscHover__BuildingAdditionalDefense", true, "BUG_BUILDING_ADDITIONAL_DEFENSE_HOVER"))
		{
			setBuildingAdditionalDefenseHelp(szBuffer, city, DOUBLE_SEPARATOR);
		}
	}
}

bool CvGameTextMgr::setBuildingAdditionalDefenseHelp(CvWStringBuffer &szBuffer, const CvCity& city, const CvWString& szStart, bool bStarted)
{
	CvWString szLabel;

	for (int i = 0; i < GC.getNumBuildingInfos(); i++)
	{
		const BuildingTypes eBuilding = static_cast<BuildingTypes>(i);
		if (city.canConstruct(eBuilding, false, false, false))
		{
			const int iChange = city.getAdditionalDefenseByBuilding(eBuilding);
			if (iChange != 0)
			{
				if (!bStarted)
				{
					szBuffer.append(szStart);
					bStarted = true;
				}

				szLabel.Format(SETCOLR L"%s" ENDCOLR, TEXT_COLOR("COLOR_BUILDING_TEXT"), GC.getBuildingInfo(eBuilding).getDescription());
				setResumableValueChangeHelp(szBuffer, szLabel, L": ", L"", iChange, gDLL->getSymbolID(DEFENSE_CHAR), true, true);
			}
		}
	}

	return bStarted;
}

void CvGameTextMgr::setEmploymentHelp(CvWStringBuffer &szBuffer, CvCity& city)
{
	FAssertMsg(NO_PLAYER != city.getOwner(), "City must have an owner");

	bool bFirst = true;
	for (int iI = 0; iI < GC.getNumBuildingInfos(); iI++)
	{
		if (city.getNumActiveBuilding((BuildingTypes)iI) > 0)
		{
			//Team Project (5)
			if (!city.isReligiouslyDisabledBuilding((BuildingTypes)iI))
			{
				if (GC.getBuildingInfo((BuildingTypes)iI).getNumPopulationEmployed() > 0)
				{
					if (!bFirst) szBuffer.append(NEWLINE);
					szBuffer.append(CvWString::format(L"%s: %d %c", GC.getBuildingInfo((BuildingTypes)iI).getDescription(), GC.getBuildingInfo((BuildingTypes)iI).getNumPopulationEmployed(), gDLL->getSymbolID(CITIZEN_CHAR)));
					bFirst = false;
				}
			}
		}
	}

	szBuffer.append(DOUBLE_SEPARATOR);
	szBuffer.append(NEWLINE);
	szBuffer.append(gDLL->getText("TXT_KEY_MISC_TOTAL_EMPLOYED", city.getNumPopulationEmployed()));
	szBuffer.append(CvWString::format(L" %c", gDLL->getSymbolID(CITIZEN_CHAR)));
}

void CvGameTextMgr::buildMaintenanceModifiersString(CvWStringBuffer &szBuffer, TechTypes eTech, bool bList, bool bPlayerContext)
{
	if (GC.getTechInfo(eTech).getMaintenanceModifier() != 0)
	{
		if (bList)
		{
			szBuffer.append(NEWLINE);
		}
		szBuffer.append(gDLL->getText("TXT_KEY_TECH_MAINT_MOD", GC.getTechInfo(eTech).getMaintenanceModifier()));
	}

	if (GC.getTechInfo(eTech).getDistanceMaintenanceModifier() != 0)
	{
		if (bList)
		{
			szBuffer.append(NEWLINE);
		}
		if (GC.getTechInfo(eTech).getDistanceMaintenanceModifier() <= -100)
		{
			szBuffer.append(gDLL->getText("TXT_KEY_TECH_DISTANCE_MAINT"));
		}
		else
		{
			szBuffer.append(gDLL->getText("TXT_KEY_TECH_DISTANCE_MAINT_MOD", GC.getTechInfo(eTech).getDistanceMaintenanceModifier()));
		}
	}

	if (GC.getTechInfo(eTech).getNumCitiesMaintenanceModifier() != 0)
	{
		if (bList)
		{
			szBuffer.append(NEWLINE);
		}
		if (GC.getTechInfo(eTech).getNumCitiesMaintenanceModifier() <= -100)
		{
			szBuffer.append(gDLL->getText("TXT_KEY_TECH_NUM_CITIES_MAINT"));
		}
		else
		{
			szBuffer.append(gDLL->getText("TXT_KEY_TECH_NUM_CITIES_MAINT_MOD", GC.getTechInfo(eTech).getNumCitiesMaintenanceModifier()));
		}
	}

	if (GC.getTechInfo(eTech).getCoastalDistanceMaintenanceModifier() != 0)
	{
		if (bList)
		{
			szBuffer.append(NEWLINE);
		}
		if (GC.getTechInfo(eTech).getCoastalDistanceMaintenanceModifier() <= -100)
		{
			szBuffer.append(gDLL->getText("TXT_KEY_COASTAL_DISTANCE_MAINT"));
		}
		else
		{
			szBuffer.append(gDLL->getText("TXT_KEY_COASTAL_DISTANCE_MAINT_MOD", GC.getTechInfo(eTech).getCoastalDistanceMaintenanceModifier()));
		}
	}
}

void CvGameTextMgr::getGameObjectName(CvWString &szString, GameObjectTypes eObject)
{
	switch (eObject)
	{
		case GAMEOBJECT_GAME:
			szString.append(gDLL->getText("TXT_KEY_GAMEOBJECT_GAME"));
			break;
		case GAMEOBJECT_TEAM:
			szString.append(gDLL->getText("TXT_KEY_GAMEOBJECT_TEAM"));
			break;
		case GAMEOBJECT_PLAYER:
			szString.append(gDLL->getText("TXT_KEY_GAMEOBJECT_PLAYER"));
			break;
		case GAMEOBJECT_CITY:
			szString.append(gDLL->getText("TXT_KEY_GAMEOBJECT_CITY"));
			break;
		case GAMEOBJECT_UNIT:
			szString.append(gDLL->getText("TXT_KEY_GAMEOBJECT_UNIT"));
			break;
		case GAMEOBJECT_PLOT:
			szString.append(gDLL->getText("TXT_KEY_GAMEOBJECT_PLOT"));
			break;
	}
}

void CvGameTextMgr::buildGameObjectRelationString(CvWStringBuffer &szBuffer, GameObjectTypes eObject, RelationTypes eRelation, int iData)
{
	if ((eObject == NO_GAMEOBJECT) || (eRelation == NO_RELATION))
		return;
	CvWString szObject;
	getGameObjectName(szObject, eObject);

	switch (eRelation)
	{
		case RELATION_ASSOCIATED:
			szBuffer.append(szObject);
			break;

		case RELATION_TRADE:
			szBuffer.append(gDLL->getText("TXT_KEY_RELATION_TRADE"));
			break;

		case RELATION_NEAR:
			szBuffer.append(gDLL->getText("TXT_KEY_RELATION_NEAR", szObject.c_str(), iData));
			break;

		case RELATION_SAME_PLOT:
			szBuffer.append(szObject);
			break;

		case RELATION_WORKING:
			if (eObject == GAMEOBJECT_CITY)
			{
				szBuffer.append(gDLL->getText("TXT_KEY_RELATION_WORKING_CITY"));
			}
			else
			{
				szBuffer.append(gDLL->getText("TXT_KEY_RELATION_WORKING_PLOT"));
			}
			break;
	}
}