//---------------------------------------------------------------------------------------
//
//  *****************   Civilization IV   ********************
//
//  FILE:	CvGameTextMgr.cpp
//
//  PURPOSE: Interfaces with GameText XML Files to manage the paths of art files
//
//---------------------------------------------------------------------------------------
//  Copyright (c) 2004 Firaxis Games, Inc. All rights reserved.
//---------------------------------------------------------------------------------------


#include "FProfiler.h"
#include "CvGameCoreUtils.h"
#include "CvGameCoreDLL.h"
#include "CvArea.h"
#include "CvArtFileMgr.h"
#include "CvBuildingInfo.h"
#include "CvBonusInfo.h"
#include "CvCity.h"
#include "CvCityAI.h"
#include "CounterSet.h"
#include "CvDeal.h"
#include "CvGameAI.h"
#include "CvGlobals.h"
#include "CvGameTextMgr.h"
#include "CvImprovementInfo.h"
#include "CvHeritageInfo.h"
#include "CvUnitCombatInfo.h"
#include "CvInfos.h"
#include "CvMap.h"
#include "CvPlayerAI.h"
#include "CvPopupInfo.h"
#include "CvPython.h"
#include "CvSelectionGroup.h"
#include "CvTeamAI.h"
#include "CvUnit.h"
#include "CvXMLLoadUtility.h"
#include "CvDLLInterfaceIFaceBase.h"
#include "CvDLLSymbolIFaceBase.h"
#include "CvDLLUtilityIFaceBase.h"
#include "CvTraitInfo.h"

int shortenID(int iId)
{
	return iId;
}

// For displaying Asserts and error messages
static char* szErrorMsg;


//	Structure to hold aggregate info about an instances of a unit type and owener
//	on a stacked plot
class PlayerUnitInfo
{
public:
	PlayerUnitInfo()
		: m_eOwner(NO_PLAYER)
		, m_eUnitType(NO_UNIT)
		, m_iTotalStrength(0)
		, m_iTotalMaxStrength(0)
		, m_iCount(0)
	{
	}

	PlayerTypes						m_eOwner;
	UnitTypes						m_eUnitType;
	int								m_iTotalStrength;
	int								m_iTotalMaxStrength;
	int								m_iCount;
	std::map<PromotionTypes,int>	m_promotions;
};

//	Hash to provide a key for maps indexed by unit type and owner
#define	PLAYER_UNIT_KEY(ePlayer,eUnitType)	(((ePlayer) << 16) + (eUnitType))

//----------------------------------------------------------------------------
//
//	FUNCTION:	GetInstance()
//
//	PURPOSE:	Get the instance of this class.
//
//----------------------------------------------------------------------------
CvGameTextMgr& CvGameTextMgr::GetInstance()
{
	static CvGameTextMgr gs_GameTextMgr;
	return gs_GameTextMgr;
}

//----------------------------------------------------------------------------
//
//	FUNCTION:	CvGameTextMgr()
//
//	PURPOSE:	Constructor
//
//----------------------------------------------------------------------------
CvGameTextMgr::CvGameTextMgr() : inspectUnitCombatCounters(NULL) { }

CvGameTextMgr::~CvGameTextMgr() { }

//----------------------------------------------------------------------------
//
//	FUNCTION:	Initialize()
//
//	PURPOSE:	Allocates memory
//
//----------------------------------------------------------------------------
void CvGameTextMgr::Initialize()
{
	inspectUnitCombatCounters = new CounterSet();
}

//----------------------------------------------------------------------------
//
//	FUNCTION:	DeInitialize()
//
//	PURPOSE:	Clears memory
//
//----------------------------------------------------------------------------
void CvGameTextMgr::DeInitialize()
{
	SAFE_DELETE(inspectUnitCombatCounters);
}

//----------------------------------------------------------------------------
//
//	FUNCTION:	Reset()
//
//	PURPOSE:	Accesses CvXMLLoadUtility to clean global text memory and
//				reload the XML files
//
//----------------------------------------------------------------------------
void CvGameTextMgr::Reset()
{
	CvXMLLoadUtility pXML;
	pXML.LoadGlobalText();
}


// Returns the current language
int CvGameTextMgr::getCurrentLanguage() const
{
	return gDLL->getCurrentLanguage();
}

void CvGameTextMgr::setYearStr(CvWString& szString, int iGameTurn, bool bSave, CalendarTypes eCalendar, int iStartYear, GameSpeedTypes eSpeed)
{
	int iTurnYear = getTurnYearForGame(iGameTurn, iStartYear, eCalendar, eSpeed);

	setYearStrAC(szString, iTurnYear, bSave);
}

void CvGameTextMgr::setYearStrAC(CvWString& szString, int iTurnYear, bool bSave)
{
	if (iTurnYear < 0)
	{
		if (bSave)
		{
			szString = gDLL->getText("TXT_KEY_TIME_BC_SAVE", CvWString::format(L"%04d", -iTurnYear).GetCString());
		}
		else
		{
			szString = gDLL->getText("TXT_KEY_TIME_BC", -(iTurnYear));
		}
	}
	else if (iTurnYear > 0)
	{
		if (bSave)
		{
			szString = gDLL->getText("TXT_KEY_TIME_AD_SAVE", CvWString::format(L"%04d", iTurnYear).GetCString());
		}
		else
		{
			szString = gDLL->getText("TXT_KEY_TIME_AD", iTurnYear);
		}
	}
	else
	{
		if (bSave)
		{
			szString = gDLL->getText("TXT_KEY_TIME_AD_SAVE", L"0000");
		}
		else
		{
			szString = gDLL->getText("TXT_KEY_TIME_AD", 0);
		}
	}
}


void CvGameTextMgr::setDateStr(CvWString& szString, int iGameTurn, bool bSave, CalendarTypes eCalendar, int iStartYear, GameSpeedTypes eSpeed)
{
	CvWString szYearBuffer;
	CvWString szWeekBuffer;
	CvDate date;
	CvDateIncrement inc;

	setYearStr(szYearBuffer, iGameTurn, bSave, eCalendar, iStartYear, eSpeed);
	const int iyear = date.getDate(iGameTurn, eSpeed).getYear();;

	const int numMonths = std::max(1, GC.getNumMonthInfos());
	const int numSeasons = std::max(1, GC.getNumSeasonInfos());
	const int weeksPerMonth = std::max(1, GC.getDefineINT("WEEKS_PER_MONTHS"));

	if (bSave && iyear < 0)
	{
		eCalendar = CALENDAR_YEARS;
	}

	switch (eCalendar)
	{
	case CALENDAR_DEFAULT:
		if (GC.getGame().getGameTurn() == iGameTurn)
		{
			date = GC.getGame().getCurrentDate();
		}
		else
		{
			date = CvDate::getDate(iGameTurn, eSpeed);
		}
		inc = date.getIncrement(eSpeed);
		if (((0 == inc.m_iIncrementMonth % numMonths) && (inc.m_iIncrementMonth > 0)) || inc.m_iIncrementMonth >= 2 * numMonths)
		{
			// Years
			szString = szYearBuffer;
		}
		else if (inc.m_iIncrementMonth >= 3)
		{
			// Seasons
			if (bSave)
			{
				szString = (szYearBuffer + "-" + GC.getSeasonInfo(date.getSeason()).getDescription());
			}
			else
			{
				szString = (GC.getSeasonInfo(date.getSeason())).getDescription() + CvString(", ") + szYearBuffer;
			}
		}
		else if ((inc.m_iIncrementDay == 0) || (inc.m_iIncrementMonth >= 2))
		{
			// Months
			if (bSave)
			{
				szString = (szYearBuffer + "-" + GC.getMonthInfo((MonthTypes)date.getMonth()).getDescription());
			}
			else
			{
				szString = (GC.getMonthInfo((MonthTypes)date.getMonth()).getDescription() + CvString(", ") + szYearBuffer);
			}
		}
		else
		{
			// Exact date
			szString = gDLL->getText("TXT_KEY_TIME_DATE", szYearBuffer.GetCString(), GC.getMonthInfo((MonthTypes)date.getMonth()).getDescription(), date.getDay());
		}
		break;
	case CALENDAR_NO_SEASONS:
		if (GC.getGame().getGameTurn() == iGameTurn)
		{
			date = GC.getGame().getCurrentDate();
		}
		else
		{
			date = CvDate::getDate(iGameTurn, eSpeed);
		}
		inc = date.getIncrement(eSpeed);
		if (((0 == inc.m_iIncrementMonth % numMonths) && (inc.m_iIncrementMonth > 0)) || inc.m_iIncrementMonth >= 2 * numMonths)
		{
			// Years
			szString = szYearBuffer;
		}
		else if ((inc.m_iIncrementDay == 0) || (inc.m_iIncrementMonth >= 2))
		{
			// Months
			if (bSave)
			{
				szString = (szYearBuffer + "-" + GC.getMonthInfo((MonthTypes)date.getMonth()).getDescription());
			}
			else
			{
				szString = (GC.getMonthInfo((MonthTypes)date.getMonth()).getDescription() + CvString(", ") + szYearBuffer);
			}
		}
		else
		{
			// Exact date
			szString = gDLL->getText("TXT_KEY_TIME_DATE", szYearBuffer.GetCString(), GC.getMonthInfo((MonthTypes)date.getMonth()).getDescription(), date.getDay());
		}
		break;
	case CALENDAR_YEARS:
	case CALENDAR_BI_YEARLY:
		szString = szYearBuffer;
		break;

	case CALENDAR_TURNS:
		szString = gDLL->getText("TXT_KEY_TIME_TURN", (iGameTurn + 1));
		break;

	case CALENDAR_SEASONS:
		if (bSave)
		{
			szString = (szYearBuffer + "-" + GC.getSeasonInfo((SeasonTypes)(iGameTurn % numSeasons)).getDescription());
		}
		else
		{
			szString = (GC.getSeasonInfo((SeasonTypes)(iGameTurn % numSeasons)).getDescription() + CvString(", ") + szYearBuffer);
		}
		break;

	case CALENDAR_MONTHS:
		if (bSave)
		{
			szString = (szYearBuffer + "-" + GC.getMonthInfo((MonthTypes)(iGameTurn % numMonths)).getDescription());
		}
		else
		{
			szString = (GC.getMonthInfo((MonthTypes)(iGameTurn % numMonths)).getDescription() + CvString(", ") + szYearBuffer);
		}
		break;

	case CALENDAR_WEEKS:
		szWeekBuffer = gDLL->getText("TXT_KEY_TIME_WEEK", ((iGameTurn % weeksPerMonth) + 1));
		if (bSave)
		{
			szString = (szYearBuffer + "-" + GC.getMonthInfo((MonthTypes)((iGameTurn / weeksPerMonth) % numMonths)).getDescription() + "-" + szWeekBuffer);
		}
		else
		{
			szString = (szWeekBuffer + ", " + GC.getMonthInfo((MonthTypes)((iGameTurn / weeksPerMonth) % numMonths)).getDescription() + ", " + szYearBuffer);
		}
		break;

	default:
		FErrorMsg("error");
	}

	//FR remove diacritics
	if (bSave)
	{
		szString = remove_diacritics(szString);
		CvString szTemp = "";
		szTemp.Format("%d - ", iGameTurn);
		szString = szTemp + szString;
	}

}


void CvGameTextMgr::setTimeStr(CvWString& szString, int iGameTurn, bool bSave)
{
	setDateStr(szString, iGameTurn, bSave, GC.getGame().getCalendar(), GC.getGame().getStartYear(), GC.getGame().getGameSpeedType());
}


void CvGameTextMgr::setInterfaceTime(CvWString& szString, PlayerTypes ePlayer)
{
	CvWString szTempBuffer;

	if (GET_PLAYER(ePlayer).isGoldenAge())
	{
		szString.Format(L"%c(%d) ", gDLL->getSymbolID(GOLDEN_AGE_CHAR), GET_PLAYER(ePlayer).getGoldenAgeTurns());
	}
	else
	{
		szString.clear();
	}
	setTimeStr(szTempBuffer, GC.getGame().getGameTurn(), false);
	szString += CvWString(szTempBuffer);
}


void CvGameTextMgr::setOOSSeeds(CvWString& szString, PlayerTypes ePlayer)
{
	if (GET_PLAYER(ePlayer).isHumanPlayer())
	{
		int iNetID = GET_PLAYER(ePlayer).getNetID();
		if (gDLL->isConnected(iNetID))
		{
			szString = gDLL->getText("TXT_KEY_PLAYER_OOS", gDLL->GetSyncOOS(iNetID), gDLL->GetOptionsOOS(iNetID));
		}
	}
}

void CvGameTextMgr::setNetStats(CvWString& szString, PlayerTypes ePlayer)
{
	if (ePlayer != GC.getGame().getActivePlayer())
	{
		if (GET_PLAYER(ePlayer).isHumanPlayer())
		{
			if (gDLL->getInterfaceIFace()->isNetStatsVisible())
			{
				int iNetID = GET_PLAYER(ePlayer).getNetID();
				if (gDLL->isConnected(iNetID))
				{
					szString = gDLL->getText("TXT_KEY_MISC_NUM_MS", gDLL->GetLastPing(iNetID));
				}
				else
				{
					szString = gDLL->getText("TXT_KEY_MISC_DISCONNECTED");
				}
			}
		}
		else
		{
			szString = gDLL->getText("TXT_KEY_MISC_AI");
		}
	}
}


void CvGameTextMgr::setEspionageMissionHelp(CvWStringBuffer &szBuffer, const CvUnit* pUnit)
{
	if (pUnit->isSpy())
	{
		const PlayerTypes eOwner =  pUnit->plot()->getOwner();
		if (NO_PLAYER != eOwner && GET_PLAYER(eOwner).getTeam() != pUnit->getTeam())
		{
			if (!pUnit->canEspionage(pUnit->plot()))
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_NO_ESPIONAGE"));

				if (pUnit->hasMoved() || pUnit->isMadeAttack())
				{
					szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_NO_ESPIONAGE_REASON_MOVED"));
				}
				else if (!pUnit->isInvisible(GET_PLAYER(eOwner).getTeam(), false))
				{
					szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_NO_ESPIONAGE_REASON_VISIBLE", GET_PLAYER(eOwner).getNameKey()));
				}
			}
			else if (pUnit->getFortifyTurns() > 0)
			{
				int iModifier = -(pUnit->getFortifyTurns() * GC.getDefineINT("ESPIONAGE_EACH_TURN_UNIT_COST_DECREASE"));
				if (0 != iModifier)
				{
					szBuffer.append(NEWLINE);
					szBuffer.append(gDLL->getText("TXT_KEY_ESPIONAGE_COST", iModifier));
				}
			}
		}
	}
}


void CvGameTextMgr::setUnitHelp(CvWStringBuffer &szString, const CvUnit* pUnit, bool bOneLine, bool bShort, bool bdarkColor)
{
	PROFILE_FUNC();
	const bool bDebugMode = GC.getGame().isDebugMode();

	CvWString szTempBuffer;
	bool bFirst;
	const bool bShift = gDLL->shiftKey();
	const bool bCtrl = gDLL->ctrlKey();
	const bool bAlt = gDLL->altKey();

	const bool bSizeMatters = GC.getGame().isOption(GAMEOPTION_COMBAT_SIZE_MATTERS);
	const bool bHideSeek = GC.getGame().isOption(GAMEOPTION_COMBAT_HIDE_SEEK);

	//In this case, these views mean, in addition to debugging info displays from bShift and bAlt:
	// bShift = Combat Class Modifiers - will need to disable ones that don't have anything to display.
	// bCtrl = On unit base help: Prerequisite and Production Info, Here on Compiled Units: CombatInfo (Prereq and Production info should be standardly available, thus normal view)
	// bAlt = On unit base help: Long List Infos - Civil Info - should be changed from long list to civil info on the base too)
	// bNormalView = default to show but replaced by any of the above - includes unit limit counts
	bool bNormalView = (!bCtrl && !bAlt && !bShift);
	std::string colorString = "COLOR_UNIT_TEXT";
	if (bdarkColor) colorString = "COLOR_BROWN_TEXT";

	szTempBuffer.Format(SETCOLR L"%s" ENDCOLR, TEXT_COLOR(colorString.c_str()), pUnit->getName().GetCString());
	szString.append(szTempBuffer);

	szString.append(L", ");

	if (pUnit->getDomainType() == DOMAIN_AIR)
	{
		if (pUnit->airBaseCombatStr() > 0)
		{
			if (bSizeMatters)
			{
				float fBase = (float)pUnit->airBaseCombatStr();
				fBase /= 100;

				if (pUnit->isInBattle())
				{
					szTempBuffer.Format(L"?/%.2f%c, ", fBase, gDLL->getSymbolID(STRENGTH_CHAR));
				}
				else if (pUnit->isHurt())
				{
					szTempBuffer.Format(L"%.2f/%.2f%c, ", fBase * pUnit->getHP() / ((float)pUnit->getMaxHP()), fBase, gDLL->getSymbolID(STRENGTH_CHAR));
				}
				else
				{
					szTempBuffer.Format(L"%.2f%c, ", fBase, gDLL->getSymbolID(STRENGTH_CHAR));
				}
			}
			else if (pUnit->isInBattle())
			{
				szTempBuffer.Format(L"?/%d%c, ", pUnit->airBaseCombatStr(), gDLL->getSymbolID(STRENGTH_CHAR));
			}
			else if (pUnit->isHurt())
			{
				szTempBuffer.Format(L"%.2f/%d%c, ", (((float)(pUnit->airBaseCombatStr() * pUnit->getHP())) / ((float)(pUnit->getMaxHP()))), pUnit->airBaseCombatStr(), gDLL->getSymbolID(STRENGTH_CHAR));
			}
			else
			{
				szTempBuffer.Format(L"%d%c, ", pUnit->airBaseCombatStr(), gDLL->getSymbolID(STRENGTH_CHAR));
			}
			szString.append(szTempBuffer);
		}
	}
	else if (pUnit->canFight())
	{
		if (bSizeMatters)
		{
			float fBase = pUnit->baseCombatStr() / 100.0f;

			if (pUnit->isInBattle())
			{
				szTempBuffer.Format(L"?/%.2f%c, ", fBase, gDLL->getSymbolID(STRENGTH_CHAR));
			}
			else if (pUnit->isHurt())
			{
				szTempBuffer.Format(L"%.2f/%.2f%c, ", (((float)(fBase * pUnit->getHP())) / ((float)(pUnit->getMaxHP()))), fBase, gDLL->getSymbolID(STRENGTH_CHAR));
			}
			else
			{
				szTempBuffer.Format(L"%.2f%c, ", fBase, gDLL->getSymbolID(STRENGTH_CHAR));
			}
		}
		else if (pUnit->isInBattle())
		{
			szTempBuffer.Format(L"?/%d%c, ", pUnit->baseCombatStr(), gDLL->getSymbolID(STRENGTH_CHAR));
		}
		else if (pUnit->isHurt())
		{
			szTempBuffer.Format(L"%.2f/%d%c, ", (((float)(pUnit->baseCombatStr() * pUnit->getHP())) / ((float)(pUnit->getMaxHP()))), pUnit->baseCombatStr(), gDLL->getSymbolID(STRENGTH_CHAR));
		}
		else
		{
			szTempBuffer.Format(L"%d%c, ", pUnit->baseCombatStr(), gDLL->getSymbolID(STRENGTH_CHAR));
		}
		szString.append(szTempBuffer);
	}

	const int iCurrMoves = pUnit->movesLeft() / GC.getMOVE_DENOMINATOR() + (pUnit->movesLeft() % GC.getMOVE_DENOMINATOR() > 0 ? 1 : 0);
	if (pUnit->baseMoves() == iCurrMoves || pUnit->getTeam() != GC.getGame().getActiveTeam())
	{
		szTempBuffer.Format(L"%d%c", pUnit->baseMoves(), gDLL->getSymbolID(MOVES_CHAR));
	}
	else
	{
		szTempBuffer.Format(L"%d/%d%c", iCurrMoves, pUnit->baseMoves(), gDLL->getSymbolID(MOVES_CHAR));
	}
	szString.append(szTempBuffer);

	if (pUnit->airRange() > 0)
	{
		szString.append(gDLL->getText("TXT_KEY_UNITHELP_AIR_RANGE", pUnit->airRange()));
	}

	if (pUnit->getBuildType() != NO_BUILD)
	{
		szString.append(L", ");
		szTempBuffer.Format(L"%s (%d)", GC.getBuildInfo(pUnit->getBuildType()).getDescription(), pUnit->plot()->getBuildTurnsLeft(pUnit->getBuildType(), 0, 0));
		szString.append(szTempBuffer);
	}

	if (pUnit->getImmobileTimer() > 0)
	{
		szString.append(L", ");
		szString.append(gDLL->getText("TXT_KEY_UNITHELP_IMMOBILE", pUnit->getImmobileTimer()));
	}

	if (bDebugMode && bShift)
	{
		FAssertMsg(pUnit->AI_getUnitAIType() != NO_UNITAI, "pUnit's AI type expected to != NO_UNITAI");
		CvWString unitAIType = GC.getUnitAIInfo(pUnit->AI_getUnitAIType()).getType();
		szTempBuffer.Format(L" (%s)", unitAIType.GetCString());
		szString.append(szTempBuffer);
	}

	if ((bDebugMode || pUnit->getTeam() == GC.getGame().getActiveTeam()) && pUnit->getExperience100() > 0 && !pUnit->isInBattle())
	{
		float fValue = (float)pUnit->getExperience100();
		if (fmod(fValue, 100) == 0)
		{
			szTempBuffer.Format(L"%.0f", fValue/100);
		}
		else if (fmod(fValue, 10) == 0)
		{
			szTempBuffer.Format(L"%.1f", fValue/100);
		}
		else
		{
			szTempBuffer.Format(L"%.2f", fValue/100);
		}
		szString.append(gDLL->getText("TXT_KEY_UNITHELP_XP", szTempBuffer.GetCString(), pUnit->experienceNeeded()));
	}

	{
		UnitCompCommander* commander = pUnit->getCommanderComp();
		if (commander)
		{
			szString.append(gDLL->getText("TXT_KEY_UNITHELP_COMMAND_RANGE", commander->getCommandRange()));
			szString.append(gDLL->getText("TXT_KEY_UNITHELP_COMMAND_POINTS", commander->getControlPointsLeft(), commander->getControlPoints()));
		}
	}

	{
		UnitCompCommodore* commodore = pUnit->getCommodoreComp();
		if (commodore)
		{
			szString.append(gDLL->getText("TXT_KEY_UNITHELP_COMMAND_RANGE", commodore->getCommandRange()));
			szString.append(gDLL->getText("TXT_KEY_UNITHELP_COMMAND_POINTS", commodore->getControlPointsLeft(), commodore->getControlPoints()));
		}
	}

	if (pUnit->getOwner() != GC.getGame().getActivePlayer() && !pUnit->isAnimal() && !pUnit->isHiddenNationality())
	{
		szString.append(L", ");

		// For minor civs, display civ name instead of player name ... to differentiate
		// and help human recognize why they can't contact that player
		const CvPlayer& kPlayer = GET_PLAYER(pUnit->getOwner());
		if (kPlayer.isMinorCiv())
			szTempBuffer.Format(SETCOLR L"%s" ENDCOLR, kPlayer.getPlayerTextColorR(), kPlayer.getPlayerTextColorG(), kPlayer.getPlayerTextColorB(), kPlayer.getPlayerTextColorA(), kPlayer.getCivilizationDescription());
		else
			szTempBuffer.Format(SETCOLR L"%s" ENDCOLR, kPlayer.getPlayerTextColorR(), kPlayer.getPlayerTextColorG(), kPlayer.getPlayerTextColorB(), kPlayer.getPlayerTextColorA(), kPlayer.getName());

		szString.append(szTempBuffer);
	}


	for (int iI = 0; iI < GC.getNumPromotionInfos(); ++iI)
	{
		if (pUnit->isHasPromotion((PromotionTypes)iI) && !pUnit->isPromotionOverriden((PromotionTypes)iI))
		{
			szTempBuffer.Format(L"<img=%S size=16 />", GC.getPromotionInfo((PromotionTypes)iI).getButton());
			szString.append(szTempBuffer);
		}
	}
	if (bAlt && bDebugMode)
	{
		CvSelectionGroup* eGroup = pUnit->getGroup();
		if (eGroup)
		{
			if (pUnit->isGroupHead())
			{
				szString.append(CvWString::format(L"\nLeading "));
			}
			else szString.append(L"\n");

			szTempBuffer.Format(L"Group(%d), %d units", eGroup->getID(), eGroup->getNumUnits());
			szString.append(szTempBuffer);
		}
	}

	if (!bOneLine)
	{
		if (bShift)
		{
			// Handle Counter
			const int iUnitID = pUnit->getID();
			const uint16_t iDisplayCount = inspectUnitCombatCounters->getCount(iUnitID);
			uint16_t iPotentialDisplays = 0;
			for (int iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
			{
				if (pUnit->isHasUnitCombat((UnitCombatTypes)iI) && ++iPotentialDisplays > iDisplayCount)
				{
					break;
				}
			}
			if (iDisplayCount == iPotentialDisplays)
			{
				inspectUnitCombatCounters->setCount(iUnitID, 0);
			}
			else if (iDisplayCount > iPotentialDisplays)
			{
				inspectUnitCombatCounters->setCount(iUnitID, 1);
			}
			else
			{
				inspectUnitCombatCounters->setCount(iUnitID, iDisplayCount + 1);
			}

			// List Unit Combats
			int iCount = 0;
			for (int iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
			{
				const UnitCombatTypes eUnitCombat = static_cast<UnitCombatTypes>(iI);

				if (pUnit->isHasUnitCombat(eUnitCombat))
				{
					if (++iCount == iDisplayCount)
					{
						szString.append(DOUBLE_SEPARATOR);
						szString.append(NEWLINE);
						setUnitCombatHelp(szString, eUnitCombat, false);
						szString.append(DOUBLE_SEPARATOR);
					}
					else
					{
						szString.append(NEWLINE);
						szString.append(GC.getUnitCombatInfo(eUnitCombat).getDescription());
					}
				}
			}
		}
		//Setup Combat Value Displays
		if (bCtrl)
		{

			if (pUnit->hasStealthDefense() && GC.getGame().isOption(GAMEOPTION_COMBAT_WITHOUT_WARNING))
			{
				szString.append(NEWLINE);
				szString.append(gDLL->getText("TXT_KEY_UNITHELP_STEALTH_DEFEND"));
			}

			if (pUnit->noDefensiveBonus())
			{
				szString.append(NEWLINE);
				szString.append(gDLL->getText("TXT_KEY_UNITHELP_NO_DEFENSE_BONUSES"));
			}

			if (pUnit->fortRepelTotal() > 0)
			{
				if (bShort)
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNITHELP_FORT_REPEL_TOTAL_SHORT", pUnit->fortRepelTotal()));
				}
				else
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNITHELP_FORT_REPEL_TOTAL_MODIFIER", pUnit->fortRepelTotal()));
				}
			}

			if (pUnit->overrunTotal() > 0)
			{
				if (bShort)
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNITHELP_OVERRUN_TOTAL_SHORT", pUnit->overrunTotal()));
				}
				else
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNITHELP_OVERRUN_TOTAL_MODIFIER", pUnit->overrunTotal()));
				}
			}

			//Basic Combat Modifiers
			if (pUnit->getExtraCombatPercent() != 0)
			{
				szString.append(NEWLINE);
				szString.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_STRENGTH", pUnit->getExtraCombatPercent()));
			}

			if (pUnit->stealthCombatModifierTotal() != 0 && GC.getGame().isOption(GAMEOPTION_COMBAT_WITHOUT_WARNING))
			{
				szString.append(NEWLINE);
				szString.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_STEALTH_COMBAT_MODIFIER", pUnit->stealthCombatModifierTotal()));
			}

			if (pUnit->attackCombatModifierTotal() != 0)
			{
				if (bShort)
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNITHELP_ATTACK_MODIFIER_SHORT", pUnit->attackCombatModifierTotal()));
				}
				else
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNITHELP_ATTACK_MODIFIER", pUnit->attackCombatModifierTotal()));
				}
			}

			if (pUnit->defenseCombatModifierTotal() != 0)
			{
				if (bShort)
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNITHELP_DEFENSE_MODIFIER_SHORT", pUnit->defenseCombatModifierTotal()));
				}
				else
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNITHELP_DEFENSE_MODIFIER", pUnit->defenseCombatModifierTotal()));
				}
			}

			if (pUnit->cityAttackModifier() == pUnit->cityDefenseModifier())
			{
				if (pUnit->cityAttackModifier() != 0)
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNITHELP_CITY_STRENGTH_MOD", pUnit->cityAttackModifier()));
				}
			}
			else
			{
				if (pUnit->cityAttackModifier() != 0)
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_CITY_ATTACK", pUnit->cityAttackModifier()));
				}

				if (pUnit->cityDefenseModifier() != 0)
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_CITY_DEFENSE", pUnit->cityDefenseModifier()));
				}
			}

			if (pUnit->animalCombatModifier() != 0)
			{
				szString.append(NEWLINE);
				szString.append(gDLL->getText("TXT_KEY_UNITHELP_ANIMAL_COMBAT_MOD", pUnit->animalCombatModifier()));
			}

			if (pUnit->combatModifierPerSizeMoreTotal() != 0)
			{
				szString.append(NEWLINE);
				szString.append(gDLL->getText("TXT_KEY_UNITHELP_COMBAT_MOD_PER_SIZE_MORE", pUnit->combatModifierPerSizeMoreTotal()));
			}

			if (pUnit->combatModifierPerSizeLessTotal() != 0)
			{
				szString.append(NEWLINE);
				szString.append(gDLL->getText("TXT_KEY_UNITHELP_COMBAT_MOD_PER_SIZE_LESS", pUnit->combatModifierPerSizeLessTotal()));
			}

			if (pUnit->combatModifierPerVolumeMoreTotal() != 0)
			{
				szString.append(NEWLINE);
				szString.append(gDLL->getText("TXT_KEY_UNITHELP_COMBAT_MOD_PER_VOLUME_MORE", pUnit->combatModifierPerVolumeMoreTotal()));
			}

			if (pUnit->combatModifierPerVolumeLessTotal() != 0)
			{
				szString.append(NEWLINE);
				szString.append(gDLL->getText("TXT_KEY_UNITHELP_COMBAT_MOD_PER_VOLUME_LESS", pUnit->combatModifierPerVolumeLessTotal()));
			}

			if (pUnit->vsBarbsModifier() > 0)
			{
				if (bShort)
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNITHELP_VSBARBS_MODIFIER_SHORT", pUnit->vsBarbsModifier()));
				}
				else
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNITHELP_VSBARBS_MODIFIER", pUnit->vsBarbsModifier()));
				}
			}

			if (pUnit->religiousCombatModifierTotal(NO_RELIGION, true) != 0)
			{
				if (bShort)
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNITHELP_RELIGIOUS_COMBAT_MODIFIER_SHORT", pUnit->religiousCombatModifierTotal(NO_RELIGION, true)));
				}
				else
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNITHELP_RELIGIOUS_COMBAT_MODIFIER", pUnit->religiousCombatModifierTotal(NO_RELIGION, true)));
				}
			}

			if (pUnit->hillsAttackModifier() == pUnit->hillsDefenseModifier())
			{
				if (pUnit->hillsAttackModifier() != 0)
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNITHELP_HILLS_STRENGTH", pUnit->hillsAttackModifier()));
				}
			}
			else
			{
				if (pUnit->hillsAttackModifier() != 0)
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNITHELP_HILLS_ATTACK", pUnit->hillsAttackModifier()));
				}

				if (pUnit->hillsDefenseModifier() != 0)
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNITHELP_HILLS_DEFENSE", pUnit->hillsDefenseModifier()));
				}
			}
			bFirst = true;
			for (int iI = 0; iI < GC.getNumTerrainInfos(); ++iI)
			{
				if (pUnit->terrainAttackModifier((TerrainTypes)iI) == pUnit->terrainDefenseModifier((TerrainTypes)iI))
				{
					if (pUnit->terrainAttackModifier((TerrainTypes)iI) != 0)
					{
						if (!bFirst)
						{
							szString.append(gDLL->getText("TXT_KEY_COMMA"));
						}
						if (bFirst)
						{
							szString.append(NEWLINE);
							bFirst = false;
						}
						szString.append(gDLL->getText("TXT_KEY_UNITHELP_STRENGTH", pUnit->terrainAttackModifier((TerrainTypes)iI), GC.getTerrainInfo((TerrainTypes) iI).getTextKeyWide()));
					}
				}
				else
				{
					if (pUnit->terrainAttackModifier((TerrainTypes)iI) != 0)
					{
						if (!bFirst)
						{
							szString.append(gDLL->getText("TXT_KEY_COMMA"));
						}
						if (bFirst)
						{
							szString.append(NEWLINE);
							bFirst = false;
						}
						szString.append(gDLL->getText("TXT_KEY_UNITHELP_ATTACK", pUnit->terrainAttackModifier((TerrainTypes)iI), GC.getTerrainInfo((TerrainTypes) iI).getTextKeyWide()));
					}

					if (pUnit->terrainDefenseModifier((TerrainTypes)iI) != 0)
					{
						if (!bFirst)
						{
							szString.append(gDLL->getText("TXT_KEY_COMMA"));
						}
						if (bFirst)
						{
							szString.append(NEWLINE);
							bFirst = false;
						}
						szString.append(gDLL->getText("TXT_KEY_UNITHELP_DEFENSE", pUnit->terrainDefenseModifier((TerrainTypes)iI), GC.getTerrainInfo((TerrainTypes) iI).getTextKeyWide()));
					}
				}
			}

			bFirst = true;
			for (int iI = 0; iI < GC.getNumFeatureInfos(); ++iI)
			{
				if (pUnit->featureAttackModifier((FeatureTypes)iI) == pUnit->featureDefenseModifier((FeatureTypes)iI))
				{
					if (pUnit->featureAttackModifier((FeatureTypes)iI) != 0)
					{
						if (!bFirst)
						{
							szString.append(gDLL->getText("TXT_KEY_COMMA"));
						}
						if (bFirst)
						{
							szString.append(NEWLINE);
							bFirst = false;
						}
						szString.append(gDLL->getText("TXT_KEY_UNITHELP_STRENGTH", pUnit->featureAttackModifier((FeatureTypes)iI), GC.getFeatureInfo((FeatureTypes) iI).getTextKeyWide()));
					}
				}
				else
				{
					if (pUnit->featureAttackModifier((FeatureTypes)iI) != 0)
					{
						if (!bFirst)
						{
							szString.append(gDLL->getText("TXT_KEY_COMMA"));
						}
						if (bFirst)
						{
							szString.append(NEWLINE);
							bFirst = false;
						}
						szString.append(gDLL->getText("TXT_KEY_UNITHELP_ATTACK", pUnit->featureAttackModifier((FeatureTypes)iI), GC.getFeatureInfo((FeatureTypes) iI).getTextKeyWide()));
					}

					if (pUnit->featureDefenseModifier((FeatureTypes)iI) != 0)
					{
						if (!bFirst)
						{
							szString.append(gDLL->getText("TXT_KEY_COMMA"));
						}
						if (bFirst)
						{
							szString.append(NEWLINE);
							bFirst = false;
						}
						szString.append(gDLL->getText("TXT_KEY_UNITHELP_DEFENSE", pUnit->featureDefenseModifier((FeatureTypes)iI), GC.getFeatureInfo((FeatureTypes) iI).getTextKeyWide()));
					}
				}
			}

			for (int iI = 0; iI < NUM_DOMAIN_TYPES; ++iI)
			{
				if (pUnit->domainModifier((DomainTypes)iI) != 0)
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNITHELP_MOD_VS_TYPE", pUnit->domainModifier((DomainTypes)iI), CvWString(GC.getDomainInfo((DomainTypes)iI).getType()).GetCString(), GC.getDomainInfo((DomainTypes)iI).getTextKeyWide()));
				}
			}

			bFirst = true;
			foreach_(const STD_PAIR(UnitTypes, int)& modifier, pUnit->getUnitInfo().getUnitAttackModifiers())
			{
				if (!bFirst)
				{
					szString.append(gDLL->getText("TXT_KEY_COMMA"));
				}
				else
				{
					szString.append(NEWLINE);
					bFirst = false;
				}

				szString.append(
					gDLL->getText(
						modifier.second == pUnit->getUnitInfo().getUnitDefenseModifiers().getValue(modifier.first) ? "TXT_KEY_UNITHELP_MOD_VS_TYPE" : "TXT_KEY_UNITHELP_ATTACK_MOD_VS_CLASS",
						modifier.second, CvWString(GC.getUnitInfo(modifier.first).getType()).c_str(), GC.getUnitInfo(modifier.first).getTextKeyWide()
					)
				);
			}
			foreach_(const STD_PAIR(UnitTypes, int)& modifier, pUnit->getUnitInfo().getUnitDefenseModifiers())
			{
				if (!bFirst)
				{
					szString.append(gDLL->getText("TXT_KEY_COMMA"));
				}
				else
				{
					szString.append(NEWLINE);
					bFirst = false;
				}
				szString.append(gDLL->getText("TXT_KEY_UNITHELP_DEFENSE_MOD_VS_CLASS", modifier.second,
					CvWString(GC.getUnitInfo(modifier.first).getType()).c_str(), GC.getUnitInfo(modifier.first).getTextKeyWide()));
			}

			bFirst = true;
			for (int iI = 0; iI < GC.getNumUnitCombatInfos(); ++iI)
			{
				if (pUnit->unitCombatModifier((UnitCombatTypes)iI) != 0)
				{
					if (!bFirst)
					{
						szString.append(gDLL->getText("TXT_KEY_COMMA"));
					}
					if (bFirst)
					{
						szString.append(NEWLINE);
						bFirst = false;
					}
					szString.append(gDLL->getText("TXT_KEY_UNITHELP_MOD_VS_TYPE", pUnit->unitCombatModifier((UnitCombatTypes)iI), CvWString(GC.getUnitCombatInfo((UnitCombatTypes) iI).getType()).GetCString(), GC.getUnitCombatInfo((UnitCombatTypes) iI).getTextKeyWide()));
				}
			}

			//Advanced Combat Modifiers
			//Armor
			if (pUnit->armorTotal() > 0)
			{
				if (bShort)
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNITHELP_ARMOR_TOTAL_SHORT", pUnit->armorTotal()));
				}
				else
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNITHELP_ARMOR_TOTAL_MODIFIER", pUnit->armorTotal()));
				}
			}

			bFirst = true;
			for (int iI = 0; iI < GC.getNumUnitCombatInfos(); ++iI)
			{
				if (pUnit->armorVSUnitCombatTotal((UnitCombatTypes)iI) != 0)
				{
					if (!bFirst)
					{
						szString.append(gDLL->getText("TXT_KEY_COMMA"));
					}
					if (bFirst)
					{
						szString.append(NEWLINE);
						bFirst = false;
					}
					szString.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_ARMOR_VERSUS", pUnit->armorVSUnitCombatTotal((UnitCombatTypes)iI), CvWString(GC.getUnitCombatInfo((UnitCombatTypes) iI).getType()).GetCString(), GC.getUnitCombatInfo((UnitCombatTypes) iI).getTextKeyWide()));
				}
			}

			//puncture
			if (pUnit->punctureTotal() > 0)
			{
				if (bShort)
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNITHELP_PUNCTURE_TOTAL_SHORT", pUnit->punctureTotal()));
				}
				else
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNITHELP_PUNCTURE_TOTAL_MODIFIER", pUnit->punctureTotal()));
				}
			}

			bFirst = true;
			for (int iI = 0; iI < GC.getNumUnitCombatInfos(); ++iI)
			{
				if (pUnit->punctureVSUnitCombatTotal((UnitCombatTypes)iI) != 0)
				{
					if (!bFirst)
					{
						szString.append(gDLL->getText("TXT_KEY_COMMA"));
					}
					if (bFirst)
					{
						szString.append(NEWLINE);
						bFirst = false;
					}
					szString.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_PUNCTURE_VERSUS", pUnit->punctureVSUnitCombatTotal((UnitCombatTypes)iI), CvWString(GC.getUnitCombatInfo((UnitCombatTypes) iI).getType()).GetCString(), GC.getUnitCombatInfo((UnitCombatTypes) iI).getTextKeyWide()));
				}
			}

			//damage
			if (pUnit->damageModifierTotal() != 0)
			{
				if (bShort)
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNITHELP_DAMAGE_MODIFIER_TOTAL_SHORT", pUnit->damageModifierTotal()));
				}
				else
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNITHELP_DAMAGE_MODIFIER_TOTAL_MODIFIER", pUnit->damageModifierTotal()));
				}
			}

			//dodge
			int idodge = (pUnit->dodgeTotal() - 100);
			if (idodge != 0)
			{
				if (bShort)
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNITHELP_DODGE_TOTAL_SHORT", idodge));
				}
				else
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNITHELP_DODGE_TOTAL_MODIFIER", idodge));
				}
			}

			bFirst = true;
			for (int iI = 0; iI < GC.getNumUnitCombatInfos(); ++iI)
			{
				if (pUnit->dodgeVSUnitCombatTotal((UnitCombatTypes)iI) != 0)
				{
					if (!bFirst)
					{
						szString.append(gDLL->getText("TXT_KEY_COMMA"));
					}
					if (bFirst)
					{
						szString.append(NEWLINE);
						bFirst = false;
					}
					szString.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_DODGE_VERSUS", pUnit->dodgeVSUnitCombatTotal((UnitCombatTypes)iI), CvWString(GC.getUnitCombatInfo((UnitCombatTypes) iI).getType()).GetCString(), GC.getUnitCombatInfo((UnitCombatTypes) iI).getTextKeyWide()));
				}
			}

			//precision
			int iprecision = (pUnit->precisionTotal() - 100);
			if (iprecision != 0)
			{
				if (bShort)
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNITHELP_PRECISION_TOTAL_SHORT", iprecision));
				}
				else
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNITHELP_PRECISION_TOTAL_MODIFIER", iprecision));
				}
			}

			bFirst = true;
			for (int iI = 0; iI < GC.getNumUnitCombatInfos(); ++iI)
			{
				if (pUnit->precisionVSUnitCombatTotal((UnitCombatTypes)iI) != 0)
				{
					if (!bFirst)
					{
						szString.append(gDLL->getText("TXT_KEY_COMMA"));
					}
					if (bFirst)
					{
						szString.append(NEWLINE);
						bFirst = false;
					}
					szString.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_PRECISION_VERSUS", pUnit->precisionVSUnitCombatTotal((UnitCombatTypes)iI), CvWString(GC.getUnitCombatInfo((UnitCombatTypes) iI).getType()).GetCString(), GC.getUnitCombatInfo((UnitCombatTypes) iI).getTextKeyWide()));
				}
			}

			//Withdrawal
			if (pUnit->combatLimit() < GC.getMAX_HIT_POINTS() && pUnit->canAttack())
			{
				szString.append(NEWLINE);
				szString.append(gDLL->getText("TXT_KEY_UNITHELP_COMBAT_LIMIT", (100 * pUnit->combatLimit()) / GC.getMAX_HIT_POINTS()));
			}

			if (pUnit->withdrawalProbability() > 0)
			{
				if(pUnit->isSpy())
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNITHELP_ESCAPE_SPY", pUnit->withdrawalProbability()));
				}
				else
				{
					if (bShort)
					{
						szString.append(NEWLINE);
						szString.append(gDLL->getText("TXT_KEY_UNITHELP_WITHDRAWL_PROBABILITY_SHORT", pUnit->withdrawalProbability()));
					}
					else
					{
						szString.append(NEWLINE);
						szString.append(gDLL->getText("TXT_KEY_UNITHELP_WITHDRAWL_PROBABILITY", pUnit->withdrawalProbability()));
					}
				}
			}

			if (pUnit->earlyWithdrawTotal() > 0)
			{
				if (bShort)
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNITHELP_EARLY_WITHDRAW_TOTAL_SHORT", pUnit->earlyWithdrawTotal()));
				}
				else
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNITHELP_EARLY_WITHDRAW_TOTAL", pUnit->earlyWithdrawTotal()));
				}
			}

			if (pUnit->withdrawAdjperAttTotal() > 0)
			{
				if (bShort)
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNITHELP_REFLEXES_TOTAL_SHORT", pUnit->withdrawAdjperAttTotal()));
				}
				else
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNITHELP_REFLEXES_TOTAL", pUnit->withdrawAdjperAttTotal()));
				}
			}

			if (pUnit->withdrawAdjperAttTotal() < 0)
			{
				if (bShort)
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNITHELP_FRAYS_TOTAL_SHORT", pUnit->withdrawAdjperAttTotal()));
				}
				else
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNITHELP_FRAYS_TOTAL", pUnit->withdrawAdjperAttTotal()));
				}
			}

			bFirst = true;
			for (int iI = 0; iI < GC.getNumUnitCombatInfos(); ++iI)
			{
				if (pUnit->withdrawVSUnitCombatTotal((UnitCombatTypes)iI) != 0)
				{
					if (!bFirst)
					{
						szString.append(gDLL->getText("TXT_KEY_COMMA"));
					}
					if (bFirst)
					{
						szString.append(NEWLINE);
						bFirst = false;
					}
					szString.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_WITHDRAW_VERSUS", pUnit->withdrawVSUnitCombatTotal((UnitCombatTypes)iI), CvWString(GC.getUnitCombatInfo((UnitCombatTypes) iI).getType()).GetCString(), GC.getUnitCombatInfo((UnitCombatTypes) iI).getTextKeyWide()));
				}
			}

			bFirst = true;
			for (int iI = 0; iI < GC.getNumTerrainInfos(); ++iI)
			{
				if (pUnit->withdrawOnTerrainTotal((TerrainTypes)iI) != 0)
				{
					if (!bFirst)
					{
						szString.append(gDLL->getText("TXT_KEY_COMMA"));
					}
					if (bFirst)
					{
						szString.append(NEWLINE);
						bFirst = false;
					}
					szString.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_WITHDRAW_ON", pUnit->withdrawOnTerrainTotal((TerrainTypes)iI), CvWString(GC.getTerrainInfo((TerrainTypes) iI).getType()).GetCString(), GC.getTerrainInfo((TerrainTypes) iI).getTextKeyWide()));
				}
			}

			bFirst = true;
			for (int iI = 0; iI < GC.getNumFeatureInfos(); ++iI)
			{
				if (pUnit->withdrawOnFeatureTotal((FeatureTypes)iI) != 0)
				{
					if (!bFirst)
					{
						szString.append(gDLL->getText("TXT_KEY_COMMA"));
					}
					if (bFirst)
					{
						szString.append(NEWLINE);
						bFirst = false;
					}
					szString.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_WITHDRAW_ON", pUnit->withdrawOnFeatureTotal((FeatureTypes)iI), CvWString(GC.getFeatureInfo((FeatureTypes) iI).getType()).GetCString(), GC.getFeatureInfo((FeatureTypes) iI).getTextKeyWide()));
				}
			}
			/*
			//Escape
			if (pUnit->escapeModifier() != 0)
			{
				szString.append(NEWLINE);
				szString.append(gDLL->getText("TXT_KEY_UNITHELP_ESCAPE_PLAN_MOD", pUnit->escapeModifier()));
			}
			*/
			//Pursuit
			if (pUnit->pursuitProbability() > 0)
			{
				if (bShort)
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNITHELP_PURSUIT_PROBABILITY_SHORT", pUnit->pursuitProbability()));
				}
				else
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNITHELP_PURSUIT_PROBABILITY", pUnit->pursuitProbability()));
				}
			}

			bFirst = true;
			for (int iI = 0; iI < GC.getNumUnitCombatInfos(); ++iI)
			{
				if (pUnit->pursuitVSUnitCombatTotal((UnitCombatTypes)iI) != 0)
				{
					if (!bFirst)
					{
						szString.append(gDLL->getText("TXT_KEY_COMMA"));
					}
					if (bFirst)
					{
						szString.append(NEWLINE);
						bFirst = false;
					}
					szString.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_PURSUIT_VERSUS", pUnit->pursuitVSUnitCombatTotal((UnitCombatTypes)iI), CvWString(GC.getUnitCombatInfo((UnitCombatTypes) iI).getType()).GetCString(), GC.getUnitCombatInfo((UnitCombatTypes) iI).getTextKeyWide()));
				}
			}

			//Repel
			if (pUnit->repelTotal() > 0)
			{
				if (bShort)
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNITHELP_REPEL_TOTAL_SHORT", pUnit->repelTotal()));
				}
				else
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNITHELP_REPEL_TOTAL_MODIFIER", pUnit->repelTotal()));
				}
			}

			bFirst = true;
			for (int iI = 0; iI < GC.getNumUnitCombatInfos(); ++iI)
			{
				if (pUnit->repelVSUnitCombatTotal((UnitCombatTypes)iI) != 0)
				{
					if (!bFirst)
					{
						szString.append(gDLL->getText("TXT_KEY_COMMA"));
					}
					if (bFirst)
					{
						szString.append(NEWLINE);
						bFirst = false;
					}
					szString.append(gDLL->getText("TXT_KEY_UNITHELP_MOD_VS_TYPE", pUnit->repelVSUnitCombatTotal((UnitCombatTypes)iI), CvWString(GC.getUnitCombatInfo((UnitCombatTypes) iI).getType()).GetCString(), GC.getUnitCombatInfo((UnitCombatTypes) iI).getTextKeyWide()));
				}
			}

			if (pUnit->repelRetriesTotal() > 0)
			{
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNITHELP_REPEL_RETRIES_TOTAL", pUnit->repelRetriesTotal()));
				}
			}

			//Knockback
			if (pUnit->knockbackTotal() > 0)
			{
				if (bShort)
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNITHELP_KNOCKBACK_TOTAL_SHORT", pUnit->knockbackTotal()));
				}
				else
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNITHELP_KNOCKBACK_TOTAL_MODIFIER", pUnit->knockbackTotal()));
				}
			}

			bFirst = true;
			for (int iI = 0; iI < GC.getNumUnitCombatInfos(); ++iI)
			{
				if (pUnit->knockbackVSUnitCombatTotal((UnitCombatTypes)iI) != 0)
				{
					if (!bFirst)
					{
						szString.append(gDLL->getText("TXT_KEY_COMMA"));
					}
					if (bFirst)
					{
						szString.append(NEWLINE);
						bFirst = false;
					}
					szString.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_KNOCKBACK_VERSUS", pUnit->knockbackVSUnitCombatTotal((UnitCombatTypes)iI), CvWString(GC.getUnitCombatInfo((UnitCombatTypes) iI).getType()).GetCString(), GC.getUnitCombatInfo((UnitCombatTypes) iI).getTextKeyWide()));
				}
			}

			if (pUnit->knockbackRetriesTotal() > 0)
			{
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNITHELP_KNOCKBACK_RETRIES_TOTAL", pUnit->knockbackRetriesTotal()));
				}
			}

			//Unyielding
			if (pUnit->unyieldingTotal() > 0)
			{
				if (bShort)
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNITHELP_UNYIELDING_TOTAL_SHORT", pUnit->unyieldingTotal()));
				}
				else
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNITHELP_UNYIELDING_TOTAL_MODIFIER", pUnit->unyieldingTotal()));
				}
			}

			//Movement pertaining to Combat
			//Blitz
			if (pUnit->isBlitz())
			{
				szString.append(NEWLINE);
				szString.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_BLITZ"));
			}

			//Stampede
			if (pUnit->canStampede())
			{
				if (bShort)
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNITHELP_STAMPEDE_SHORT"));
				}
				else
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNITHELP_STAMPEDE_LONG"));
				}
			}

			//Onslaught
			if (pUnit->canOnslaught())
			{
				if (bShort)
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNITHELP_ONSLAUGHT_SHORT"));
				}
				else
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNITHELP_ONSLAUGHT_LONG"));
				}
			}

			//Amphibious
			if (pUnit->isAmphib())
			{
				if(pUnit->isSpy())
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_RADIATION_SPY"));
				}
				else
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_AMPHIB"));
				}
			}

			//River
			if (pUnit->isRiver())
			{
				szString.append(NEWLINE);
				szString.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_RIVER_ATTACK"));
			}

			//First Strikes
			if (pUnit->maxFirstStrikes() > 0)
			{
				if (pUnit->firstStrikes() == pUnit->maxFirstStrikes())
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNITHELP_FIRST_STRIKES", pUnit->firstStrikes()));
				}
				else
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNITHELP_FIRST_STRIKE_CHANCES", pUnit->firstStrikes(), pUnit->maxFirstStrikes()));
				}
			}

			if (pUnit->stealthStrikesTotal() > 0 && GC.getGame().isOption(GAMEOPTION_COMBAT_WITHOUT_WARNING))
			{
				szString.append(NEWLINE);
				szString.append(gDLL->getText("TXT_KEY_UNITHELP_STEALTH_STRIKES", pUnit->stealthStrikesTotal()));
			}

			//Immunity to First Strikes
			if (pUnit->immuneToFirstStrikes())
			{
				szString.append(NEWLINE);
				szString.append(gDLL->getText("TXT_KEY_UNITHELP_FIRST_STRIKES_IMMUNE"));
			}

			//Siege
			if (pUnit->breakdownChanceTotal() > 0)
			{
				szString.append(NEWLINE);
				szString.append(gDLL->getText("TXT_KEY_UNITHELP_BREAKDOWN_CHANCE", pUnit->breakdownChanceTotal()));
			}
			if (pUnit->breakdownDamageTotal() > 0)
			{
				szString.append(NEWLINE);
				szString.append(gDLL->getText("TXT_KEY_UNITHELP_BREAKDOWN_DAMAGE", pUnit->breakdownDamageTotal()));
			}
			if (pUnit->canAttackOnlyCities())
			{
				szString.append(NEWLINE);
				szString.append(gDLL->getText("TXT_KEY_UNITHELP_CAN_ONLY_ATTACK_CITIES"));
			}
			if (pUnit->canIgnoreNoEntryLevel())
			{
				szString.append(NEWLINE);
				szString.append(gDLL->getText("TXT_KEY_UNITHELP_CAN_ALWAYS_ATTACK_CITIES"));
			}

			//Bombard
			if(GC.isDCM_RANGE_BOMBARD())
			{
				if (pUnit->getDCMBombRange() > 0 || pUnit->getDCMBombAccuracy() > 0)
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_IS_DCM_BOMBARD"));
				}
				if (pUnit->getDCMBombRange() > 0)
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_IS_RANGE_BOMBARD", pUnit->getDCMBombRange()));
				}
				if (pUnit->getDCMBombAccuracy() > 0)
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_IS_ACCURACY_BOMBARD", pUnit->getDCMBombAccuracy()));
				}
				if (pUnit->rBombardDamage() > 0)
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_RANGED_BOMBARD_DAMAGE", pUnit->rBombardDamage()));
				}
				if (pUnit->rBombardDamageLimit() > 0)
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_RANGED_BOMBARD_DAMAGE_LIMIT", pUnit->rBombardDamageLimit()));
				}
				if (pUnit->rBombardDamageMaxUnits() > 0)
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_RANGED_BOMBARD_DAMAGE_MAX_UNITS", pUnit->rBombardDamageMaxUnits()));
				}
			}

			if (pUnit->getBombardRate() > 0)
			{
				if (bShort)
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNITHELP_BOMBARD_RATE_SHORT", ((pUnit->getBombardRate() * 100) / GC.getMAX_CITY_DEFENSE_DAMAGE())));
				}
				else
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNITHELP_BOMBARD_RATE", ((pUnit->getBombardRate() * 100) / GC.getMAX_CITY_DEFENSE_DAMAGE())));
				}
			}

			//Collateral
			if (pUnit->collateralDamage() > 0)
			{
				szString.append(NEWLINE);
				if (pUnit->getExtraCollateralDamage() == 0)
				{
					szString.append(gDLL->getText("TXT_KEY_UNITHELP_COLLATERAL_DAMAGE_REVDCM", 100 * pUnit->getUnitInfo().getCollateralDamageLimit() / GC.getMAX_HIT_POINTS(), pUnit->getUnitInfo().getCollateralDamageMaxUnits()));
				}
				else
				{
					szString.append(gDLL->getText("TXT_KEY_UNITHELP_COLLATERAL_DAMAGE_EXTRA", pUnit->getExtraCollateralDamage()));
				}
			}

			//Flanking
			bFirst = true;
			foreach_(const STD_PAIR(UnitTypes, int)& modifier, pUnit->getUnitInfo().getFlankingStrikeUnits())
			{
				if (modifier.second > 0)
				{
					if (bFirst)
					{
						szString.append(NEWLINE);
						bFirst = false;
					}
					else
					{
						szString.append(L", ");
					}

					szString.append(gDLL->getText("TXT_KEY_UNITHELP_COMBAT_FLANKING_STRIKES", modifier.second, GC.getUnitInfo(modifier.first).getDescription()));
				}
			}

			int iFlank = 0;
			for (int iI = 0; iI < GC.getNumUnitCombatInfos(); ++iI)
			{
				iFlank = pUnit->flankingStrengthbyUnitCombatTotal((UnitCombatTypes)iI);
				if (iFlank > 0)
				{
					if (bFirst)
					{
						szString.append(NEWLINE);
						bFirst = false;
					}
					else
					{
						szString.append(L", ");
					}

					szString.append(gDLL->getText("TXT_KEY_UNITHELP_COMBAT_FLANKING_STRIKES", iFlank, GC.getUnitCombatInfo((UnitCombatTypes)iI).getDescription()));
				}
			}

			//Interception and Evasion
			if (pUnit->currInterceptionProbability() > 0)
			{
				if(pUnit->isSpy())
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNITHELP_INTERCEPT_AIRCRAFT_SPY", pUnit->currInterceptionProbability()));
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNITHELP_INTERCEPT_AIRCRAFT_SPY_COUNTER", pUnit->currInterceptionProbability() * 5));
				}
				else
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNITHELP_INTERCEPT_AIRCRAFT", pUnit->currInterceptionProbability()));
				}
			}

			if (pUnit->evasionProbability() > 0)
			{
				if(pUnit->isSpy())
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNITHELP_EVADE_INTERCEPTION_SPY", pUnit->evasionProbability()));
				}
				else
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNITHELP_EVADE_INTERCEPTION", pUnit->evasionProbability()));
				}
			}

			if (GC.isDCM_FIGHTER_ENGAGE())
			{
				if (GC.getUnitInfo(pUnit->getUnitType()).getDCMFighterEngage())
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_IS_FIGHTER_ENGAGE"));
				}
			}

			//Surround and Destroy
			if (GC.getGame().isOption(GAMEOPTION_COMBAT_SURROUND_DESTROY))
			{
				if (pUnit->unnerveTotal() > 0)
				{
					if (bShort)
					{
						szString.append(NEWLINE);
						szString.append(gDLL->getText("TXT_KEY_UNITHELP_UNNERVE_TOTAL_SHORT", pUnit->unnerveTotal()));
					}
					else
					{
						szString.append(NEWLINE);
						szString.append(gDLL->getText("TXT_KEY_UNITHELP_UNNERVE_TOTAL", pUnit->unnerveTotal()));
					}
				}

				if (pUnit->encloseTotal() > 0)
				{
					if (bShort)
					{
						szString.append(NEWLINE);
						szString.append(gDLL->getText("TXT_KEY_UNITHELP_ENCLOSE_TOTAL_SHORT", pUnit->encloseTotal()));
					}
					else
					{
						szString.append(NEWLINE);
						szString.append(gDLL->getText("TXT_KEY_UNITHELP_ENCLOSE_TOTAL", pUnit->encloseTotal()));
					}
				}
				if (pUnit->lungeTotal() > 0)
				{
					if (bShort)
					{
						szString.append(NEWLINE);
						szString.append(gDLL->getText("TXT_KEY_UNITHELP_LUNGE_TOTAL_SHORT", pUnit->lungeTotal()));
					}
					else
					{
						szString.append(NEWLINE);
						szString.append(gDLL->getText("TXT_KEY_UNITHELP_LUNGE_TOTAL", pUnit->lungeTotal()));
					}
				}
				if (pUnit->dynamicDefenseTotal() > 0)
				{
					if (bShort)
					{
						szString.append(NEWLINE);
						szString.append(gDLL->getText("TXT_KEY_UNITHELP_DYNAMIC_DEFENSE_TOTAL_SHORT", pUnit->dynamicDefenseTotal()));
					}
					else
					{
						szString.append(NEWLINE);
						szString.append(gDLL->getText("TXT_KEY_UNITHELP_DYNAMIC_DEFENSE_TOTAL", pUnit->dynamicDefenseTotal()));
					}
				}
			}

			//Power Shots
			if (pUnit->powerShotsTotal() > 0)
			{
				if (bShort)
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNITHELP_POWER_SHOTS_TOTAL_SHORT", pUnit->powerShotsTotal()));
				}
				else
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNITHELP_POWER_SHOTS_TOTAL_MODIFIER", pUnit->powerShotsTotal()));
				}
			}

			if (pUnit->powerShotCombatModifierTotal() != 0)
			{
				if (bShort)
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNITHELP_POWER_SHOT_COMBAT_MODIFIER_TOTAL_SHORT", pUnit->powerShotCombatModifierTotal()));
				}
				else
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNITHELP_POWER_SHOT_COMBAT_MODIFIER_TOTAL_MODIFIER", pUnit->powerShotCombatModifierTotal()));
				}
			}

			if (pUnit->powerShotPunctureModifierTotal() != 0)
			{
				if (bShort)
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNITHELP_POWER_SHOT_PUNCTURE_MODIFIER_TOTAL_SHORT", pUnit->powerShotPunctureModifierTotal()));
				}
				else
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNITHELP_POWER_SHOT_PUNCTURE_MODIFIER_TOTAL_MODIFIER", pUnit->powerShotPunctureModifierTotal()));
				}
			}

			if (pUnit->powerShotPrecisionModifierTotal() != 0)
			{
				if (bShort)
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNITHELP_POWER_SHOT_PRECISION_MODIFIER_TOTAL_SHORT", pUnit->powerShotPrecisionModifierTotal()));
				}
				else
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNITHELP_POWER_SHOT_PRECISION_MODIFIER_TOTAL_MODIFIER", pUnit->powerShotPrecisionModifierTotal()));
				}
			}

			if (pUnit->powerShotCriticalModifierTotal() != 0)
			{
				if (bShort)
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNITHELP_POWER_SHOT_CRITICAL_MODIFIER_TOTAL_SHORT", pUnit->powerShotCriticalModifierTotal()));
				}
				else
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNITHELP_POWER_SHOT_CRITICAL_MODIFIER_TOTAL_MODIFIER", pUnit->powerShotCriticalModifierTotal()));
				}
			}

			//Stuns and afflictions
				//Critical
			if (pUnit->criticalModifierTotal() != 0)
			{
				if (bShort)
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNITHELP_CRITICAL_MODIFIER_TOTAL_SHORT", pUnit->criticalModifierTotal()));
				}
				else
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNITHELP_CRITICAL_MODIFIER_TOTAL_MODIFIER", pUnit->criticalModifierTotal()));
				}
			}

			bFirst = true;
			for (int iI = 0; iI < GC.getNumUnitCombatInfos(); ++iI)
			{
				if (pUnit->criticalVSUnitCombatTotal((UnitCombatTypes)iI) != 0)
				{
					if (!bFirst)
					{
						szString.append(gDLL->getText("TXT_KEY_COMMA"));
					}
					if (bFirst)
					{
						szString.append(NEWLINE);
						bFirst = false;
					}
					szString.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_CRITICAL_VERSUS", pUnit->criticalVSUnitCombatTotal((UnitCombatTypes)iI), CvWString(GC.getUnitCombatInfo((UnitCombatTypes)iI).getType()).GetCString(), GC.getUnitCombatInfo((UnitCombatTypes) iI).getTextKeyWide()));
				}
			}
			//Stun
			if (pUnit->roundStunProbTotal() != 0)
			{
				if (bShort)
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNITHELP_ROUND_STUN_TOTAL_MODIFIER_SHORT", pUnit->roundStunProbTotal()));
				}
				else
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNITHELP_ROUND_STUN_TOTAL_MODIFIER", pUnit->roundStunProbTotal()));
				}
			}

			bFirst = true;
			for (int iI = 0; iI < GC.getNumUnitCombatInfos(); ++iI)
			{
				if (pUnit->roundStunVSUnitCombatTotal((UnitCombatTypes)iI) != 0)
				{
					if (!bFirst)
					{
						szString.append(gDLL->getText("TXT_KEY_COMMA"));
					}
					if (bFirst)
					{
						szString.append(NEWLINE);
						bFirst = false;
					}
					szString.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_ROUND_STUN_VERSUS", pUnit->roundStunVSUnitCombatTotal((UnitCombatTypes)iI), CvWString(GC.getUnitCombatInfo((UnitCombatTypes)iI).getType()).GetCString(), GC.getUnitCombatInfo((UnitCombatTypes) iI).getTextKeyWide()));
				}
			}
			//Traps

			int iValue = 0;
			bFirst = true;
			for (int iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
			{
				UnitCombatTypes eTrapUnitCombat = (UnitCombatTypes)iI;
				iValue = pUnit->trapDisableUnitCombatTotal(eTrapUnitCombat);
				if (iValue != 0)
				{
					if (!bFirst)
					{
						szString.append(gDLL->getText("TXT_KEY_COMMA"));
					}
					if (bFirst)
					{
						szString.append(NEWLINE);
						bFirst = false;
					}
					szString.append(gDLL->getText("TXT_KEY_UNITHELP_TRAP_DISABLE_TYPE", iValue, CvWString(GC.getUnitCombatInfo(eTrapUnitCombat).getType()).GetCString(), GC.getUnitCombatInfo(eTrapUnitCombat).getTextKeyWide()));
				}
			}
			iValue = 0;
			bFirst = true;
			for (int iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
			{
				UnitCombatTypes eTrapUnitCombat = (UnitCombatTypes)iI;
				iValue = pUnit->trapAvoidanceUnitCombatTotal(eTrapUnitCombat);
				if (iValue != 0)
				{
					if (!bFirst)
					{
						szString.append(gDLL->getText("TXT_KEY_COMMA"));
					}
					if (bFirst)
					{
						szString.append(NEWLINE);
						bFirst = false;
					}
					szString.append(gDLL->getText("TXT_KEY_UNITHELP_TRAP_AVOID_TYPE", iValue, CvWString(GC.getUnitCombatInfo(eTrapUnitCombat).getType()).GetCString(), GC.getUnitCombatInfo(eTrapUnitCombat).getTextKeyWide()));
				}
			}
			iValue = 0;
			bFirst = true;
			for (int iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
			{
				UnitCombatTypes eTrapUnitCombat = (UnitCombatTypes)iI;
				iValue = pUnit->trapTriggerUnitCombatTotal(eTrapUnitCombat);
				if (iValue != 0)
				{
					if (!bFirst)
					{
						szString.append(gDLL->getText("TXT_KEY_COMMA"));
					}
					if (bFirst)
					{
						szString.append(NEWLINE);
						bFirst = false;
					}
					szString.append(gDLL->getText("TXT_KEY_UNITHELP_TRAP_TRIGGER_TYPE", iValue, CvWString(GC.getUnitCombatInfo(eTrapUnitCombat).getType()).GetCString(), GC.getUnitCombatInfo(eTrapUnitCombat).getTextKeyWide()));
				}
			}
			bFirst = true;
			for (int iI = 0; iI < GC.getNumPromotionInfos(); iI++)
			{
				PromotionTypes eTrapPromo = (PromotionTypes)iI;
				if (pUnit->hasTrapSetWithPromotion(eTrapPromo))
				{
					if (iValue != 0)
					{
						if (!bFirst)
						{
							szString.append(gDLL->getText("TXT_KEY_COMMA"));
						}
						if (bFirst)
						{
							szString.append(NEWLINE);
							bFirst = false;
						}
						szString.append(gDLL->getText("TXT_KEY_UNITHELP_TRAP_PROMOTION_TYPE", GC.getPromotionInfo(eTrapPromo).getTextKeyWide()));
					}
				}
			}
			bFirst = true;
			for (int iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
			{
				UnitCombatTypes eTrapUnitCombat = (UnitCombatTypes)iI;
				if (pUnit->hasTrapImmunityUnitCombat(eTrapUnitCombat))
				{
					if (iValue != 0)
					{
						if (!bFirst)
						{
							szString.append(gDLL->getText("TXT_KEY_COMMA"));
						}
						if (bFirst)
						{
							szString.append(NEWLINE);
							bFirst = false;
						}
						szString.append(gDLL->getText("TXT_KEY_UNITHELP_TRAP_IMMUNE_TYPE", GC.getUnitCombatInfo(eTrapUnitCombat).getTextKeyWide()));
					}
				}
			}
			int iTrapMin = pUnit->trapDamageMinTotal();
			int iTrapMax = pUnit->trapDamageMaxTotal();
			if (iTrapMax > 0)
			{
				szString.append(NEWLINE);
				szString.append(gDLL->getText("TXT_KEY_UNITHELP_TRAP_DAMAGE", iTrapMin, iTrapMax));
			}

			int iNumTriggers = pUnit->trapNumTriggers();
			int iNumTriggersRemaining = pUnit->trapNumTriggersRemaining();
			if (iNumTriggers > 0 && iNumTriggersRemaining > 0)
			{
				szString.append(NEWLINE);
				szString.append(gDLL->getText("TXT_KEY_UNITHELP_TRAP_NUM_ACTIVE_TRIGGERS", iNumTriggers, iNumTriggersRemaining));
			}

			if (pUnit->isTriggerBeforeAttack())
			{
				szString.append(NEWLINE);
				szString.append(gDLL->getText("TXT_KEY_UNITHELP_TRAP_TRIGGER_BEFORE_ATTACK"));
			}

			int iComplexity = pUnit->trapComplexityTotal();
			if (iComplexity > 0)
			{
				szString.append(NEWLINE);
				szString.append(gDLL->getText("TXT_KEY_UNITHELP_TRAP_COMPLEXITY", iComplexity));
			}

#ifdef OUTBREAKS_AND_AFFLICTIONS
			//Afflict On Attack
			for (int iI = 0; iI < GC.getNumPromotionLineInfos(); ++iI)
			{
				if (pUnit->hasAfflictOnAttackType((PromotionLineTypes)iI))
				{
					int iProbability = pUnit->getAfflictOnAttackTypeProbability((PromotionLineTypes)iI);
					if (pUnit->isAfflictOnAttackTypeImmediate((PromotionLineTypes)iI))
					{
						szString.append(NEWLINE);
						szString.append(gDLL->getText("TXT_KEY_AFFLICT_ON_ATTACK_IMMEDIATE", iProbability, GC.getPromotionLineInfo((PromotionLineTypes) iI).getDescription()));
					}
					else
					{
						szString.append(NEWLINE);
						szString.append(gDLL->getText("TXT_KEY_AFFLICT_ON_ATTACK", iProbability, GC.getPromotionLineInfo((PromotionLineTypes) iI).getDescription()));
					}
				}
			}
#endif
			if (pUnit->poisonProbabilityModifierTotal() > 0)
			{
				if (bShort)
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNITHELP_POISON_PROB_MOD_TOTAL_MODIFIER_SHORT", pUnit->poisonProbabilityModifierTotal()));
				}
				else
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNITHELP_POISON_PROB_MOD_TOTAL_MODIFIER", pUnit->poisonProbabilityModifierTotal()));
				}
			}

			if (pUnit->poisonProbabilityModifierTotal() < 0)
			{
				if (bShort)
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNITHELP_POISON_PROB_NEG_TOTAL_MODIFIER_SHORT", pUnit->poisonProbabilityModifierTotal()));
				}
				else
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNITHELP_POISON_PROB_NEG_TOTAL_MODIFIER", pUnit->poisonProbabilityModifierTotal()));
				}
			}
			//Cold Dmg
			if (pUnit->dealsColdDamage())
			{
				if (bShort)
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNITHELP_DEALS_COLD_DAMAGE_SHORT"));
				}
				else
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNITHELP_DEALS_COLD_DAMAGE_TOTAL"));
				}
			}

			//Str Per
			if (pUnit->strAdjperRndTotal() > 0)
			{
				if (bShort)
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNITHELP_RAGE_TOTAL_SHORT", pUnit->strAdjperRndTotal()));
				}
				else
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNITHELP_RAGE_TOTAL", pUnit->strAdjperRndTotal()));
				}
			}

			if (pUnit->strAdjperRndTotal() < 0)
			{
				if (bShort)
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNITHELP_FATIGUE_TOTAL_SHORT", pUnit->strAdjperRndTotal()));
				}
				else
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNITHELP_FATIGUE_TOTAL", pUnit->strAdjperRndTotal()));
				}
			}

			if (pUnit->strAdjperAttTotal() > 0)
			{
				if (bShort)
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNITHELP_RAMPAGE_TOTAL_SHORT", pUnit->strAdjperAttTotal()));
				}
				else
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNITHELP_RAMPAGE_TOTAL", pUnit->strAdjperAttTotal()));
				}
			}

			if (pUnit->strAdjperAttTotal() < 0)
			{
				if (bShort)
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNITHELP_TIRING_TOTAL_SHORT", pUnit->strAdjperAttTotal()));
				}
				else
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNITHELP_TIRING_TOTAL", pUnit->strAdjperAttTotal()));
				}
			}

			if (pUnit->strAdjperDefTotal() > 0)
			{
				if (bShort)
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNITHELP_DETERMINATION_TOTAL_SHORT", pUnit->strAdjperDefTotal()));
				}
				else
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNITHELP_DETERMINATION_TOTAL", pUnit->strAdjperDefTotal()));
				}
			}

			if (pUnit->strAdjperDefTotal() < 0)
			{
				if (bShort)
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNITHELP_DEMORALIZATION_TOTAL_SHORT", pUnit->strAdjperDefTotal()));
				}
				else
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNITHELP_DEMORALIZATION_TOTAL", pUnit->strAdjperDefTotal()));
				}
			}
		}

		//Setup Civil Displays
		if (bAlt)
		{
			if (pUnit->workRate(true) != 0)
			{
				szString.append(NEWLINE);
				szString.append(gDLL->getText("TXT_KEY_TEMP_WORK_RATE", pUnit->workRate(true)));
			}
			if (pUnit->revoltProtectionTotal() != 0)
			{
				szString.append(NEWLINE);
				szString.append(gDLL->getText("TXT_KEY_TEMP_REVOLT_PROTECTION", pUnit->revoltProtectionTotal()));
			}
			//Cargo
			if (pUnit->cargoSpace() > 0)
			{
				if (bSizeMatters)
				{
					if (pUnit->getTeam() == GC.getGame().getActiveTeam())
					{
						szTempBuffer = NEWLINE + gDLL->getText("TXT_KEY_UNITHELP_CARGO_SPACE", pUnit->SMgetCargo(), pUnit->cargoSpace());
					}
					else
					{
						szTempBuffer = NEWLINE + gDLL->getText("TXT_KEY_UNITHELP_CARGO_SPACE_FOREIGN", pUnit->cargoSpace());
					}
				}
				else if (pUnit->getTeam() == GC.getGame().getActiveTeam())
				{
					szTempBuffer = NEWLINE + gDLL->getText("TXT_KEY_UNITHELP_CARGO_SPACE", pUnit->getCargo(), pUnit->cargoSpace());
				}
				else
				{
					szTempBuffer = NEWLINE + gDLL->getText("TXT_KEY_UNITHELP_CARGO_SPACE_FOREIGN", pUnit->cargoSpace());
				}
				szString.append(szTempBuffer);

				if (pUnit->getSpecialCargo() != NO_SPECIALUNIT)
				{
					szString.append(gDLL->getText("TXT_KEY_UNITHELP_CARRIES", GC.getSpecialUnitInfo(pUnit->getSpecialCargo()).getTextKeyWide()));
				}
			}
			if (bSizeMatters)
			{
				szString.append(NEWLINE);
				szString.append(gDLL->getText("TXT_KEY_UNITHELP_CARGO_SIZE_MATTERS", pUnit->SMCargoVolume()));
			}
			//Healing
			if (pUnit->hasNoSelfHeal())
			{
				szString.append(NEWLINE);
				szString.append(gDLL->getText("TXT_KEY_UNITHELP_SELF_HEAL_NONE"));
			}

			if (pUnit->isAlwaysHeal())
			{
				//TSHEEP Display Spy Messages Differently
				if(pUnit->isSpy())
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_LOYALTY_SPY"));
				}
				else
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_ALWAYS_HEAL"));
				}
			}

			if (pUnit->getSelfHealModifierTotal() != 0)
			{
				szString.append(NEWLINE);
				szString.append(gDLL->getText("TXT_KEY_UNITHELP_SELF_HEAL", pUnit->getSelfHealModifierTotal()));
			}

			if (pUnit->getExtraEnemyHeal() != 0)
			{
				if(pUnit->isSpy())
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_INSTIGATE_SPY", pUnit->getExtraEnemyHeal()));
				}
				else
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_HEALS_EXTRA", pUnit->getExtraEnemyHeal()) + gDLL->getText("TXT_KEY_PROMOTIONHELP_ENEMY_LANDS"));
				}
			}

			if (pUnit->getExtraNeutralHeal() != 0)
			{
				if(pUnit->isSpy())
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_INSTIGATE2_SPY", pUnit->getExtraNeutralHeal()));
				}
				else
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_HEALS_EXTRA", pUnit->getExtraNeutralHeal()) + gDLL->getText("TXT_KEY_PROMOTIONHELP_NEUTRAL_LANDS"));
				}
			}

			if (pUnit->getExtraFriendlyHeal() != 0)
			{
				if(pUnit->isSpy())
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_POISON_SPY", pUnit->getExtraFriendlyHeal()));
				}
				else
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_HEALS_EXTRA", pUnit->getExtraFriendlyHeal()) + gDLL->getText("TXT_KEY_PROMOTIONHELP_FRIENDLY_LANDS"));
				}
			}

			{
				const int iNumHealSupp = pUnit->getNumHealSupportTotal();
				if (iNumHealSupp > 0)
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNITHELP_NUM_HEAL_SUPPORT", iNumHealSupp, pUnit->getHealSupportRemaining()));
				}
			}

			if (pUnit->getSameTileHeal() != 0)
			{
				szString.append(NEWLINE);
				szString.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_HEALS_SAME", pUnit->getSameTileHeal()) + gDLL->getText("TXT_KEY_PROMOTIONHELP_DAMAGE_TURN"));
			}

			if (pUnit->getAdjacentTileHeal() != 0)
			{
				szString.append(NEWLINE);
				szString.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_HEALS_ADJACENT", pUnit->getAdjacentTileHeal()) + gDLL->getText("TXT_KEY_PROMOTIONHELP_DAMAGE_TURN"));
			}

			if (pUnit->getHealUnitCombatCount() > 0)
			{
				for (int iI = GC.getNumUnitCombatInfos() - 1; iI > -1; iI--)
				{
					const int i0 = pUnit->getHealUnitCombatTypeTotal((UnitCombatTypes)iI);

					if (i0 > 0)
					{
						szString.append(NEWLINE);
						szString.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_HEALS_UNITCOMBAT_SAME", GC.getUnitCombatInfo((UnitCombatTypes)iI).getTextKeyWide(), i0) + gDLL->getText("TXT_KEY_PROMOTIONHELP_DAMAGE_TURN"));
					}
					const int i1 = pUnit->getHealUnitCombatTypeAdjacentTotal((UnitCombatTypes)iI);

					if (i1 > 0)
					{
						szString.append(NEWLINE);
						szString.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_HEALS_UNITCOMBAT_ADJACENT", GC.getUnitCombatInfo((UnitCombatTypes)iI).getTextKeyWide(), i1) + gDLL->getText("TXT_KEY_PROMOTIONHELP_DAMAGE_TURN"));
					}
				}
			}
			/*
			//Establish
			if (pUnit->establishModifier() != 0)
			{
				szString.append(NEWLINE);
				szString.append(gDLL->getText("TXT_KEY_UNITHELP_HEALING_HQ_MOD", pUnit->establishModifier()));
			}
			*/
			if (pUnit->getVictoryAdjacentHeal() != 0)
			{
				szString.append(NEWLINE);
				szString.append(gDLL->getText("TXT_KEY_UNITHELP_VICTORY_ADJACENT", pUnit->getVictoryHeal(), pUnit->getVictoryStackHeal(), pUnit->getVictoryAdjacentHeal()));
			}

			if ((pUnit->getVictoryStackHeal() != 0) && (pUnit->getVictoryAdjacentHeal() == 0))
			{
				szString.append(NEWLINE);
				szString.append(gDLL->getText("TXT_KEY_UNITHELP_VICTORY_STACK", pUnit->getVictoryHeal(), pUnit->getVictoryStackHeal()));
			}

			if ((pUnit->getVictoryHeal() != 0) && (pUnit->getVictoryStackHeal() == 0))
			{
				szString.append(NEWLINE);
				szString.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_VICTORY_HEAL", pUnit->getVictoryHeal()));
			}

#ifdef OUTBREAKS_AND_AFFLICTIONS
			//Curing, resisting and overcoming afflictions
			for (int iI = 0; iI <GC.getNumPromotionLineInfos(); iI++)
			{
				PromotionLineTypes eAfflictionLine = ((PromotionLineTypes)iI);
				if (pUnit->getUnitAfflictionTolerance(eAfflictionLine) > 0)
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNITHELP_AFFLICTION_TOLERANCE_POSITIVE", pUnit->getUnitAfflictionTolerance(eAfflictionLine), GC.getPromotionLineInfo(eAfflictionLine).getDescription()));
				}

				if (pUnit->getUnitAfflictionTolerance(eAfflictionLine) < 0)
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNITHELP_AFFLICTION_TOLERANCE_NEGATIVE", pUnit->getUnitAfflictionTolerance(eAfflictionLine), GC.getPromotionLineInfo(eAfflictionLine).getDescription()));
				}

				if (pUnit->getFortitudeModifierTypeAmount(eAfflictionLine) > 0)
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNITHELP_FORTITUDE_MODIFIER_POSITIVE", pUnit->getFortitudeModifierTypeAmount(eAfflictionLine), GC.getPromotionLineInfo(eAfflictionLine).getDescription()));
				}

				if (pUnit->getFortitudeModifierTypeAmount(eAfflictionLine) < 0)
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNITHELP_FORTITUDE_MODIFIER_NEGATIVE", pUnit->getFortitudeModifierTypeAmount(eAfflictionLine), GC.getPromotionLineInfo(eAfflictionLine).getDescription()));
				}

				if (pUnit->hasAfflictionLine(eAfflictionLine))
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNITHELP_CHANCE_TO_OVERCOME", GC.getPromotionLineInfo(eAfflictionLine).getDescription(), pUnit->getChancetoOvercome(eAfflictionLine)));
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNITHELP_CHANCE_OF_WORSENING", GC.getPromotionLineInfo(eAfflictionLine).getDescription(), pUnit->getChancetoContract(eAfflictionLine)));
				}
			}

			for (int iI = 0; iI < GC.getNumPropertyInfos(); iI++)
			{
				PropertyTypes eProperty = ((PropertyTypes)iI);
				int iAidTotal = pUnit->aidTotal(eProperty);
				if (iAidTotal > 0)
				{
					if (bShort)
					{
						szString.append(NEWLINE);
						szString.append(gDLL->getText("TXT_KEY_UNITHELP_AID_TOTAL_SHORT", GC.getPropertyInfo(eProperty).getDescription(), iAidTotal));
					}
					else
					{
						szString.append(NEWLINE);
						szString.append(gDLL->getText("TXT_KEY_UNITHELP_AID_TOTAL_MODIFIER", GC.getPropertyInfo(eProperty).getDescription(), iAidTotal));
					}
				}
			}

			for (int iI = 0; iI < GC.getNumPromotionLineInfos(); ++iI)
			{
				if (pUnit->hasCureAfflictionType((PromotionLineTypes)iI))
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_CURE_AFFLICTION", GC.getPromotionLineInfo((PromotionLineTypes) iI).getDescription()));
				}
			}
#endif
			//Extra Lives
			if (pUnit->isOneUp())
			{
				szString.append(NEWLINE);
				szString.append(gDLL->getText("TXT_KEY_UNITHELP_ONEUP", pUnit->getOneUpCount()));
			}

			if (pUnit->getSurvivorChance() != 0)
			{
				szString.append(NEWLINE);
				szString.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_SURVIVOR", pUnit->getSurvivorChance()));
			}

#ifdef OUTBREAKS_AND_AFFLICTIONS
			//Resistances
				//Fortitude
			if (pUnit->fortitudeTotal() > 0)
			{
				if (bShort)
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNITHELP_FORTITUDE_TOTAL_SHORT", pUnit->fortitudeTotal()));
				}
				else
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNITHELP_FORTITUDE_TOTAL_MODIFIER", pUnit->fortitudeTotal()));
				}
			}
#endif
				//Endurance
			if (pUnit->enduranceTotal() != 0)
			{
				if (bShort)
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNITHELP_ENDURANCE_TOTAL_SHORT", pUnit->enduranceTotal()));
				}
				else
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNITHELP_ENDURANCE_TOTAL_MODIFIER", pUnit->enduranceTotal()));
				}
			}
				//Immunity to Cold
			if (pUnit->hasImmunitytoColdDamage())
			{
				szString.append(NEWLINE);
				szString.append(gDLL->getText("TXT_KEY_UNITHELP_IMMUNITY_TO_COLD_DAMAGE"));
			}
				//Collateral Resistance
			for (int iI = 0; iI < GC.getNumUnitCombatInfos(); ++iI)
			{
				if (pUnit->getUnitInfo().getUnitCombatCollateralImmune(iI))
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNITHELP_COLLATERAL_IMMUNE", CvWString(GC.getUnitCombatInfo((UnitCombatTypes)iI).getType()).GetCString(), GC.getUnitCombatInfo((UnitCombatTypes)iI).getTextKeyWide()));
				}
			}

			if (pUnit->getCollateralDamageProtection() > 0)
			{
				szString.append(NEWLINE);
				szString.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_COLLATERAL_PROTECTION", pUnit->getCollateralDamageProtection()));
			}

			//Map Interaction Mods
			if (pUnit->isUpgradeAnywhere())
			{
				szString.append(NEWLINE);
				szString.append(gDLL->getText("TXT_KEY_UPGRADE_ANYWHERE"));
			}

			if (pUnit->isExcile())
			{
				szString.append(NEWLINE);
				szString.append(gDLL->getText("TXT_KEY_EXCILE"));
			}

			if (pUnit->isPassage())
			{
				szString.append(NEWLINE);
				szString.append(gDLL->getText("TXT_KEY_PASSAGE"));
			}

			if (pUnit->isNoNonOwnedCityEntry())
			{
				szString.append(NEWLINE);
				szString.append(gDLL->getText("TXT_KEY_NO_NON_OWNED_CITY"));
			}

			if (pUnit->isBarbCoExist())
			{
				szString.append(NEWLINE);
				szString.append(gDLL->getText("TXT_KEY_UNITHELP_BARB_COEXIST"));
			}

			if (pUnit->isBlendIntoCity())
			{
				szString.append(NEWLINE);
				szString.append(gDLL->getText("TXT_KEY_UNITHELP_BLEND_INTO_CITY"));
			}

			if (pUnit->isNoCapture())
			{
				szString.append(NEWLINE);
				szString.append(gDLL->getText("TXT_KEY_UNITHELP_CANNOT_CAPTURE"));
			}

			//Capture interactions
			if (pUnit->captureProbabilityTotal() > 0)
			{
				szString.append(NEWLINE);
				szString.append(gDLL->getText("TXT_KEY_UNITHELP_CAPTURE_PROBABILITY_MODIFIER", pUnit->captureProbabilityTotal()));
			}

			if (pUnit->captureResistanceTotal() > 0)
			{
				szString.append(NEWLINE);
				szString.append(gDLL->getText("TXT_KEY_UNITHELP_CAPTURE_RESISTANCE_MODIFIER", pUnit->captureResistanceTotal()));
			}

			if (pUnit->isAssassin())
			{
				szString.append(NEWLINE);
				szString.append(gDLL->getText("TXT_KEY_UNITHELP_ASSASSIN"));
			}

			//Taunt
			if (pUnit->tauntTotal() > 0)
			{
				szString.append(NEWLINE);
				szString.append(gDLL->getText("TXT_KEY_UNITHELP_TAUNT", pUnit->tauntTotal()));
			}

			if (pUnit->getInsidiousnessTotal() != 0)
			{
				szString.append(NEWLINE);
				float fValue = (float)pUnit->getInsidiousnessTotal();
				{
					szTempBuffer.Format(L"%.1f", fValue/10);
				}
				szString.append(gDLL->getText("TXT_KEY_INSIDIOUSNESS", szTempBuffer.GetCString()));
			}

			if (pUnit->getInvestigationTotal() != 0)
			{
				szString.append(NEWLINE);
				float fValue = (float)pUnit->getInvestigationTotal();
				{
					szTempBuffer.Format(L"%.1f", fValue/10);
				}
				szString.append(gDLL->getText("TXT_KEY_INVESTIGATION", szTempBuffer.GetCString()));
			}

			//Targeting and Defending vs types
			szTempBuffer.clear();
			bFirst = true;
			for (int iI = 0; iI < pUnit->getUnitInfo().getNumTargetUnits(); ++iI)
			{
				const UnitTypes eUnitX = (UnitTypes) pUnit->getUnitInfo().getTargetUnit(iI);

				if (bFirst)
				{
					bFirst = false;
				}
				else
				{
					szTempBuffer += L", ";
				}

				szTempBuffer += CvWString::format(L"<link=%s>%s</link>", CvWString(GC.getUnitInfo(eUnitX).getType()).GetCString(), GC.getUnitInfo(eUnitX).getDescription());
			}

			if (!bFirst)
			{
				szString.append(NEWLINE);
				szString.append(gDLL->getText("TXT_KEY_UNITHELP_TARGETS_UNIT_FIRST", szTempBuffer.GetCString()));
			}

			szTempBuffer.clear();
			bFirst = true;
			for (int iI = 0; iI < pUnit->getUnitInfo().getNumDefendAgainstUnits(); ++iI)
			{
				const UnitTypes eUnitX = (UnitTypes)pUnit->getUnitInfo().getDefendAgainstUnit(iI);
				if (bFirst)
				{
					bFirst = false;
				}
				else
				{
					szTempBuffer += L", ";
				}
				szTempBuffer += CvWString::format(L"<link=%s>%s</link>", CvWString(GC.getUnitInfo(eUnitX).getType()).GetCString(), GC.getUnitInfo(eUnitX).getDescription());
			}

			if (!bFirst)
			{
				szString.append(NEWLINE);
				szString.append(gDLL->getText("TXT_KEY_UNITHELP_DEFENDS_UNIT_FIRST", szTempBuffer.GetCString()));
			}

			szTempBuffer.clear();
			bFirst = true;
			for (int iI = 0; iI < GC.getNumUnitCombatInfos(); ++iI)
			{
				if (pUnit->getUnitInfo().getTargetUnitCombat(iI) || pUnit->hasTargetUnitCombat((UnitCombatTypes)iI))
				{
					if (bFirst)
					{
						bFirst = false;
					}
					else
					{
						szTempBuffer += L", ";
					}

					szTempBuffer += CvWString::format(L"<link=%s>%s</link>", CvWString(GC.getUnitCombatInfo((UnitCombatTypes)iI).getType()).GetCString(), GC.getUnitCombatInfo((UnitCombatTypes)iI).getDescription());
				}
			}

			if (!bFirst)
			{
				szString.append(NEWLINE);
				szString.append(gDLL->getText("TXT_KEY_UNITHELP_TARGETS_UNIT_FIRST", szTempBuffer.GetCString()));
			}

			szTempBuffer.clear();
			bFirst = true;
			for (int iI = 0; iI < GC.getNumUnitCombatInfos(); ++iI)
			{
				if (pUnit->getUnitInfo().getDefenderUnitCombat(iI))
				{
					if (bFirst)
					{
						bFirst = false;
					}
					else
					{
						szTempBuffer += L", ";
					}

					szTempBuffer += CvWString::format(L"<link=%s>%s</link>", CvWString(GC.getUnitCombatInfo((UnitCombatTypes)iI).getType()).GetCString(), GC.getUnitCombatInfo((UnitCombatTypes)iI).getDescription());
				}
			}

			if (!bFirst)
			{
				szString.append(NEWLINE);
				szString.append(gDLL->getText("TXT_KEY_UNITHELP_DEFENDS_UNIT_FIRST", szTempBuffer.GetCString()));
			}

			//Pillaging
			if (pUnit->isPillageResearch())
			{
				szString.append(NEWLINE);
				szString.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_RESEARCH_PILLAGE"));
			}

			if (pUnit->isPillageEspionage())
			{
				szString.append(NEWLINE);
				szString.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_ESPIONAGE_PILLAGE"));
			}

			if (pUnit->isPillageMarauder())
			{
				szString.append(NEWLINE);
				szString.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_MARAUDER_PILLAGE"));
			}

			if (pUnit->isPillageOnMove())
			{
				szString.append(NEWLINE);
				szString.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_MOVING_PILLAGE"));
			}

			if (pUnit->isPillageOnVictory())
			{
				szString.append(NEWLINE);
				szString.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_VICTORY_PILLAGE"));
			}

			//Celebrity
			if (pUnit->getCelebrityHappy() != 0)
			{
				szString.append(NEWLINE);
				szString.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_CELEBRITY", pUnit->getCelebrityHappy()));
			}

			//Worker details
			for (int iI = 0; iI < GC.getNumTerrainInfos(); iI++)
			{
				if (pUnit->terrainWorkPercent((TerrainTypes)iI) > 0)
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_WORK", pUnit->terrainWorkPercent((TerrainTypes)iI), GC.getTerrainInfo((TerrainTypes)iI).getTextKeyWide()));
				}
			}
			for (int iI = 0; iI < GC.getNumFeatureInfos(); iI++)
			{
				if (pUnit->featureWorkPercent((FeatureTypes)iI) > 0)
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_WORK", pUnit->featureWorkPercent((FeatureTypes)iI), GC.getFeatureInfo((FeatureTypes)iI).getTextKeyWide()));
				}
			}
			for (int iI = 0; iI < GC.getNumBuildInfos(); iI++)
			{
				if (pUnit->buildWorkPercent((BuildTypes)iI) > 0)
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_WORK", pUnit->buildWorkPercent((BuildTypes)iI), GC.getBuildInfo((BuildTypes)iI).getTextKeyWide()));
				}
			}

			if (pUnit->isWorker())
			{
				if (pUnit->hillsWorkModifier() > 0)
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_HILLS_WORK", pUnit->hillsWorkModifier()));
				}
				if (pUnit->peaksWorkModifier() > 0)
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_PEAKS_WORK", pUnit->peaksWorkModifier()));
				}
			}

			//Strength in Numbers offered support
#ifdef STRENGTH_IN_NUMBERS
			if (GC.getGame().isOption(GAMEOPTION_COMBAT_STRENGTH_IN_NUMBERS))
			{
				if (pUnit->frontSupportPercentTotal() > 0)
				{
					if (bShort)
					{
						szString.append(NEWLINE);
						szString.append(gDLL->getText("TXT_KEY_UNITHELP_FRONT_SUPPORT_PERCENT_TOTAL_SHORT", pUnit->frontSupportPercentTotal()));
					}
					else
					{
						szString.append(NEWLINE);
						szString.append(gDLL->getText("TXT_KEY_UNITHELP_FRONT_SUPPORT_PERCENT_TOTAL", pUnit->frontSupportPercentTotal()));
					}
				}
				if (pUnit->shortRangeSupportPercentTotal() > 0)
				{
					if (bShort)
					{
						szString.append(NEWLINE);
						szString.append(gDLL->getText("TXT_KEY_UNITHELP_SHORT_RANGE_SUPPORT_PERCENT_TOTAL_SHORT", pUnit->shortRangeSupportPercentTotal()));
					}
					else
					{
						szString.append(NEWLINE);
						szString.append(gDLL->getText("TXT_KEY_UNITHELP_SHORT_RANGE_SUPPORT_PERCENT_TOTAL", pUnit->shortRangeSupportPercentTotal()));
					}
				}
				if (pUnit->mediumRangeSupportPercentTotal() > 0)
				{
					if (bShort)
					{
						szString.append(NEWLINE);
						szString.append(gDLL->getText("TXT_KEY_UNITHELP_MEDIUM_RANGE_SUPPORT_PERCENT_TOTAL_SHORT", pUnit->mediumRangeSupportPercentTotal()));
					}
					else
					{
						szString.append(NEWLINE);
						szString.append(gDLL->getText("TXT_KEY_UNITHELP_MEDIUM_RANGE_SUPPORT_PERCENT_TOTAL", pUnit->mediumRangeSupportPercentTotal()));
					}
				}
				if (pUnit->longRangeSupportPercentTotal() > 0)
				{
					if (bShort)
					{
						szString.append(NEWLINE);
						szString.append(gDLL->getText("TXT_KEY_UNITHELP_LONG_RANGE_SUPPORT_PERCENT_TOTAL_SHORT", pUnit->longRangeSupportPercentTotal()));
					}
					else
					{
						szString.append(NEWLINE);
						szString.append(gDLL->getText("TXT_KEY_UNITHELP_LONG_RANGE_SUPPORT_PERCENT_TOTAL", pUnit->longRangeSupportPercentTotal()));
					}
				}
				if (pUnit->flankSupportPercentTotal() > 0)
				{
					if (bShort)
					{
						szString.append(NEWLINE);
						szString.append(gDLL->getText("TXT_KEY_UNITHELP_FLANK_SUPPORT_PERCENT_TOTAL_SHORT", pUnit->flankSupportPercentTotal()));
					}
					else
					{
						szString.append(NEWLINE);
						szString.append(gDLL->getText("TXT_KEY_UNITHELP_FLANK_SUPPORT_PERCENT_TOTAL", pUnit->flankSupportPercentTotal()));
					}
				}
			}
#endif // STRENGTH_IN_NUMBERS

			//Property Manipulators
			pUnit->getPropertiesConst()->buildDisplayString(szString);
			pUnit->getUnitInfo().getPropertyManipulators()->buildDisplayString(szString);
			for (int iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
			{
				if (pUnit->isHasUnitCombat((UnitCombatTypes)iI))
				{
					if (GC.getUnitCombatInfo((UnitCombatTypes)iI).getPropertyManipulators()->getNumInteractions() > 0
						|| GC.getUnitCombatInfo((UnitCombatTypes)iI).getPropertyManipulators()->getNumPropagators() > 0
						|| GC.getUnitCombatInfo((UnitCombatTypes)iI).getPropertyManipulators()->getNumSources() > 0)
					{
						szString.append(NEWLINE);
						szString.append(gDLL->getText("TXT_KEY_UNITHELP_MODIFIER_PROPERTY_MANIP", GC.getUnitCombatInfo((UnitCombatTypes)iI).getDescription()));
						GC.getUnitCombatInfo((UnitCombatTypes)iI).getPropertyManipulators()->buildDisplayString(szString);
					}
				}
			}
			for (int iI = 0; iI < GC.getNumPromotionInfos(); iI++)
			{
				if (pUnit->isHasPromotion((PromotionTypes)iI))
				{
					if (GC.getPromotionInfo((PromotionTypes)iI).getPropertyManipulators()->getNumInteractions() > 0
						|| GC.getPromotionInfo((PromotionTypes)iI).getPropertyManipulators()->getNumPropagators() > 0
						|| GC.getPromotionInfo((PromotionTypes)iI).getPropertyManipulators()->getNumSources() > 0)
					{
						szString.append(NEWLINE);
						szString.append(gDLL->getText("TXT_KEY_UNITHELP_MODIFIER_PROPERTY_MANIP", GC.getPromotionInfo((PromotionTypes)iI).getDescription()));
						GC.getPromotionInfo((PromotionTypes)iI).getPropertyManipulators()->buildDisplayString(szString);
					}
				}
			}


			//Costs
			if (pUnit->costModifierTotal() > 0)
			{
				if (bShort)
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNITHELP_COST_MODIFIER_TOTAL_SHORT", pUnit->costModifierTotal()));
				}
				else
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNITHELP_COST_MODIFIER_TOTAL_MODIFIER", pUnit->costModifierTotal()));
				}
			}
		}

		//Setup Miscellaneous Pertinent displays
		if (bNormalView)
		{

#ifdef ENABLE_ROLES_HOVER
			const CvPlayer& kPlayer = GET_PLAYER(pUnit->getOwner());
			UnitAITypes eUnitAI = pUnit->AI_getUnitAIType();
			if (eUnitAI != NO_UNITAI)
			{
				szString.append(NEWLINE);
				CvWString szStringUnitAi = "";
				getUnitAIString(szStringUnitAi, eUnitAI);
				MissionAITypes eMissionAI = pUnit->getGroup()->AI_getMissionAIType();
				CvWString MissionInfos = "";
				if (eMissionAI != NO_MISSIONAI)
				{
					MissionInfos = MissionAITypeToDescription(eMissionAI);
				}
				else if (pUnit->isAutomated())
				{
					AutomateTypes eAutomateAI = pUnit->getGroup()->getAutomateType();
					MissionInfos = AutomateTypeToDescription(eAutomateAI);
				}
				szString.append(gDLL->getText("TXT_KEY_UNITHELP_ROLE", szStringUnitAi.GetCString(), MissionInfos.GetCString()));
			}
#endif
			//Max HP
			if (pUnit->canFight())
			{
				if (pUnit->getMaxHP() != 100)
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNITHELP_MAX_HP", pUnit->getMaxHP()));
				}
				if (pUnit->isHurt())
				{
					const int iNumHealAsTypes = GC.getUnitInfo(pUnit->getUnitType()).getNumHealAsTypes();
					for (int iI = 0; iI < iNumHealAsTypes; iI++)
					{
						const UnitCombatTypes eHealAsTypes = (UnitCombatTypes)GC.getUnitInfo(pUnit->getUnitType()).getHealAsType(iI);
						const int iHealAsDamage = pUnit->getHealAsDamage((UnitCombatTypes)GC.getUnitInfo(pUnit->getUnitType()).getHealAsType(iI));
						const int iHealTurns = pUnit->healTurnsAsType(pUnit->plot(), eHealAsTypes);
						if (iHealAsDamage > 0)
						{
							szString.append(NEWLINE);
							if (iHealTurns == MAX_INT)
							{
								szString.append(gDLL->getText("TXT_KEY_UNITHELP_DAMAGE_BY_UNITCOMBAT_NOHEAL",
								GC.getUnitCombatInfo(eHealAsTypes).getTextKeyWide(), iHealAsDamage));
							}
							else
							{
								szString.append(gDLL->getText("TXT_KEY_UNITHELP_DAMAGE_BY_UNITCOMBAT",
									GC.getUnitCombatInfo(eHealAsTypes).getTextKeyWide(), iHealAsDamage, iHealTurns));
							}
						}
					}
				}
			}
			//Fortification
			if (pUnit->fortifyModifier() != 0)
			{
				szString.append(NEWLINE);
				szString.append(gDLL->getText("TXT_KEY_UNITHELP_FORTIFIED", pUnit->fortifyModifier()));
			}

			if (pUnit->isMilitaryBranch())
			{
				szString.append(NEWLINE);
				szString.append(gDLL->getText("TXT_KEY_UNITHELP_BRANCH_MILITARY"));
			}
			else
			{
				szString.append(NEWLINE);
				szString.append(gDLL->getText("TXT_KEY_UNITHELP_BRANCH_CIVILIAN"));
			}

			if (pUnit->getUpkeep100() > 0)
			{
				szTempBuffer = CvWString::format(L"%.2f", pUnit->getUpkeep100() / 100.0);
				szString.append(NEWLINE);
				szString.append(gDLL->getText("TXT_KEY_UNITHELP_UPKEEP", szTempBuffer.GetCString()));
			}

			setEspionageMissionHelp(szString, pUnit);

			//Current Cold Damage
			if (pUnit->getColdDamage() > 0)
			{
				if (bShort)
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNITHELP_COLD_DAMAGE_SHORT", pUnit->getColdDamage()));
				}
				else
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNITHELP_COLD_DAMAGE_TOTAL", pUnit->getColdDamage()));
				}
			}
			// isSpy
			if (pUnit->isSpy())
			{
				szString.append(NEWLINE);
				szString.append(gDLL->getText("TXT_KEY_UNITHELP_IS_SPY"));
			}
			if (!bShort)
			{
				//Nuclear
				if (pUnit->nukeRange() >= 0)
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNITHELP_CAN_NUKE"));
				}

				//Invisibility/Visibility
				if (pUnit->alwaysInvisible())
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNITHELP_INVISIBLE_ALL"));
				}

				if (!bHideSeek)
				{
					if (pUnit->getInvisibleType() != NO_INVISIBLE)
					{
						szString.append(NEWLINE);
						szString.append(gDLL->getText("TXT_KEY_UNITHELP_INVISIBLE_MOST"));
					}

					for (int iI = 0; iI < pUnit->getNumSeeInvisibleTypes(); iI++)
					{
						if (pUnit->getSeeInvisibleType(iI) != pUnit->getInvisibleType())
						{
							szString.append(NEWLINE);
							szString.append(gDLL->getText("TXT_KEY_UNITHELP_SEE_INVISIBLE", GC.getInvisibleInfo(pUnit->getSeeInvisibleType(iI)).getChar()));
						}
					}
				}
				else // GAMEOPTION_COMBAT_HIDE_SEEK
				{
					bool bFirst = true;
					for (int iJ = 0; iJ < GC.getNumInvisibleInfos(); iJ++)
					{
						const InvisibleTypes eTypeX = static_cast<InvisibleTypes>(iJ);

						if (GC.getInvisibleInfo(eTypeX).isIntrinsic() && !GC.getGame().isOption(GAMEOPTION_COMBAT_SIZE_MATTERS))
						{
							continue;
						}
						const int iSpotIntensity = pUnit->visibilityIntensityTotal(eTypeX);
						if (iSpotIntensity > 0 || GC.getInvisibleInfo(eTypeX).isIntrinsic())
						{
							if (bFirst)
							{
								szString.append(NEWLINE);
								szString.append(gDLL->getText("TXT_BULLET_S1_COLON_SPACE", L"TXT_WORD_SPOT"));
								bFirst = false;
							}
							else
							{
								szString.append(L", ");
							}
							szString.append(CvWString::format(L"%d%c", iSpotIntensity, GC.getInvisibleInfo(eTypeX).getChar()));
						}
					}
					bFirst = true;
					for (int iI = 0; iI < GC.getNumInvisibleInfos(); iI++)
					{
						if (pUnit->visibilityIntensityRangeTotal((InvisibleTypes)iI) != 0)
						{
							if (!bFirst)
							{
								szString.append(gDLL->getText("TXT_KEY_COMMA"));
							}
							if (bFirst)
							{
								szString.append(NEWLINE);
								bFirst = false;
							}
							szString.append(gDLL->getText("TXT_KEY_UNITHELP_INVISIBILITY_SPOT_RANGE_VALUE", pUnit->visibilityIntensityRangeTotal((InvisibleTypes)iI), GC.getInvisibleInfo((InvisibleTypes) iI).getChar()));
						}
					}
					bFirst = true;
					for (int iI = 0; iI < GC.getNumInvisibleInfos(); iI++)
					{
						if (pUnit->visibilityIntensitySameTileTotal((InvisibleTypes)iI) != 0)
						{
							if (!bFirst)
							{
								szString.append(gDLL->getText("TXT_KEY_COMMA"));
							}
							if (bFirst)
							{
								szString.append(NEWLINE);
								bFirst = false;
							}
							szString.append(gDLL->getText("TXT_KEY_UNITHELP_INVISIBILITY_SPOT_SAME_TILE_VALUE", pUnit->visibilityIntensitySameTileTotal((InvisibleTypes)iI), GC.getInvisibleInfo((InvisibleTypes) iI).getChar()));
						}
					}
					bFirst = true;
					for (int iI = 0; iI < GC.getNumInvisibleInfos(); iI++)
					{
						if (!pUnit->isNegatesInvisible((InvisibleTypes)iI))
						{
							if (pUnit->invisibilityIntensityTotal((InvisibleTypes)iI) != 0 && !pUnit->isNeverInvisible())
							{
								if (!bFirst)
								{
									szString.append(gDLL->getText("TXT_KEY_COMMA"));
								}
								if (bFirst)
								{
									szString.append(NEWLINE);
									bFirst = false;
								}
								szString.append(gDLL->getText("TXT_KEY_UNITHELP_INVISIBILITY_VEIL_VALUE", pUnit->invisibilityIntensityTotal((InvisibleTypes)iI), GC.getInvisibleInfo((InvisibleTypes) iI).getChar()));
							}
						}
						else
						{
							szString.append(NEWLINE);
							szString.append(gDLL->getText("TXT_KEY_UNITHELP_INVISIBILITY_VEIL_NEGATED", CvWString(GC.getInvisibleInfo((InvisibleTypes)iI).getType()).GetCString(), GC.getInvisibleInfo((InvisibleTypes) iI).getChar()));
						}
					}
					if (pUnit->isNeverInvisible())
					{
						szString.append(NEWLINE);
						szString.append(gDLL->getText("TXT_KEY_UNITHELP_ALWAYS_VISIBLE"));
					}
				}

				if (pUnit->getExtraVisibilityRange() != 0)
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_VISIBILITY", pUnit->getExtraVisibilityRange()));
				}

				//Movement
				if (pUnit->canMoveImpassable())
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNITHELP_CAN_MOVE_IMPASSABLE"));
				}

				if (pUnit->flatMovementCost())
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNITHELP_FLAT_MOVEMENT"));
				}

				if (pUnit->ignoreTerrainCost())
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNITHELP_IGNORE_TERRAIN"));
				}

				if (pUnit->isEnemyRoute())
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_ENEMY_ROADS"));
				}

				if (pUnit->isHillsDoubleMove())
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_HILLS_MOVE"));
				}

				if (pUnit->isCanMovePeaks())
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_CAN_MOVE_PEAKS"));
				}

				if (pUnit->isCanLeadThroughPeaks())
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_CAN_LEAD_THROUGH_PEAKS"));
				}

				for (int iI = 0; iI < GC.getNumTerrainInfos(); ++iI)
				{
					if (pUnit->isTerrainDoubleMove((TerrainTypes)iI))
					{
						szString.append(NEWLINE);
						szString.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_DOUBLE_MOVE", GC.getTerrainInfo((TerrainTypes) iI).getTextKeyWide()));
					}
				}

				for (int iI = 0; iI < GC.getNumFeatureInfos(); ++iI)
				{
					if (pUnit->isFeatureDoubleMove((FeatureTypes)iI))
					{
						szString.append(NEWLINE);
						szString.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_DOUBLE_MOVE", GC.getFeatureInfo((FeatureTypes) iI).getTextKeyWide()));
					}
				}

				if (pUnit->getExtraMoveDiscount() != 0)
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_MOVE_DISCOUNT", -(pUnit->getExtraMoveDiscount())));
				}

				szTempBuffer.clear();
				szTempBuffer.Format(L"%s%s ", NEWLINE, gDLL->getText("TXT_KEY_UNITHELP_CAN_ONLY_TRAVERSE").GetCString());
				for (int iI = 0; iI < GC.getNumRouteInfos(); ++iI)
				{
					if (pUnit->getUnitInfo().getPassableRouteNeeded(iI))
					{
						CvWString szRoute;
						szRoute.Format(L"<link=%s>%s</link>", CvWString(GC.getRouteInfo((RouteTypes)iI).getType()).GetCString(), GC.getRouteInfo((RouteTypes)iI).getDescription());
						setListHelp(szString, szTempBuffer, szRoute, L", ", bFirst);
						bFirst = false;
					}
				}

				if (pUnit->isDefensiveVictoryMove())
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_DV_MOVE"));
				}

				if (pUnit->isOffensiveVictoryMove())
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_OV_MOVE"));
				}

				if (pUnit->canIgnoreZoneofControl())
				{
					if (bShort)
					{
						szString.append(NEWLINE);
						szString.append(gDLL->getText("TXT_KEY_UNITHELP_IGNORE_ZONE_OF_CONTROL_SHORT"));
					}
					else
					{
						szString.append(NEWLINE);
						szString.append(gDLL->getText("TXT_KEY_UNITHELP_IGNORE_ZONE_OF_CONTROL_LONG"));
					}
				}

				if (pUnit->canFliesToMove())
				{
					if (bShort)
					{
						szString.append(NEWLINE);
						szString.append(gDLL->getText("TXT_KEY_UNITHELP_FLIES_TO_MOVE_SHORT"));
					}
					else
					{
						szString.append(NEWLINE);
						szString.append(gDLL->getText("TXT_KEY_UNITHELP_FLIES_TO_MOVE_LONG"));
					}
				}

				if (pUnit->isAnimal() && pUnit->canAnimalIgnoresBorders())
				{
					if (bShort)
					{
						szString.append(NEWLINE);
						szString.append(gDLL->getText("TXT_KEY_UNITHELP_ANIMAL_IGNORES_BORDERS_SHORT"));
					}
					else
					{
						szString.append(NEWLINE);
						szString.append(gDLL->getText("TXT_KEY_UNITHELP_ANIMAL_IGNORES_BORDERS_LONG"));
					}
				}

				if (pUnit->getUnitInfo().isNoRevealMap())
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNITHELP_VISIBILITY_MOVE_RANGE"));
				}

				//Paradrop
				if (pUnit->getDropRange() > 0)
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_UNITHELP_PARADROP_RANGE", pUnit->getDropRange()));
				}

				if (pUnit->isFreeDrop() && !pUnit->hasCannotMergeSplit())
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_FREE_DROP"));

					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_DROP_SIGHT_UNSEEN"));
				}

				//Experience
				if (pUnit->getExperiencePercent() != 0)
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_EXPERIENCE_PERCENT", pUnit->getExperiencePercent()));
				}

				//Misc
				if (!CvWString(pUnit->getUnitInfo().getHelp()).empty())
				{
					szString.append(NEWLINE);
					szString.append(pUnit->getUnitInfo().getHelp());
				}
			}
			foreach_(const MapCategoryTypes eMapCategory, pUnit->getUnitInfo().getMapCategories())
			{
				szString.append(NEWLINE);
				szString.append(gDLL->getText("TXT_KEY_MAP_CATEGORY_PREREQUISITE", GC.getMapCategoryInfo(eMapCategory).getTextKeyWide()));
			}
		}

		if (bShift && bDebugMode)
		{
			CvWString unitAIType = GC.getUnitAIInfo(pUnit->AI_getUnitAIType()).getType();
			szTempBuffer.Format(L"\nUnitAI Type = %s.", unitAIType.GetCString());
			szString.append(szTempBuffer);
			szTempBuffer.Format(L"\nSacrifice Value = %d.", pUnit->AI_sacrificeValue(NULL));
			szString.append(szTempBuffer);
		}
	}
	if (bNormalView && !bShort)
	{
		if (pUnit->getBuildUpType() != NO_PROMOTIONLINE)
		{
			szString.append(NEWLINE);
			szString.append(gDLL->getText("TXT_BULLET_S1", GC.getPromotionLineInfo(pUnit->getBuildUpType()).getDescription()));
		}
		//Outcome Missions
		CvOutcomeListMerged mergedList;
		mergedList.addOutcomeList(pUnit->getUnitInfo().getKillOutcomeList());

		for (int iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
		{
			if (pUnit->isHasUnitCombat((UnitCombatTypes)iI))
			{
				UnitCombatTypes eCombat = (UnitCombatTypes)iI;
				mergedList.addOutcomeList(GC.getUnitCombatInfo(eCombat).getKillOutcomeList());
			}
		}

		if (!mergedList.isEmpty())
		{
			CvUnit* pSelectedUnit = gDLL->getInterfaceIFace()->getHeadSelectedUnit();

			if (pSelectedUnit && mergedList.isPossible(*pSelectedUnit))
			{
				szString.append(NEWLINE);
				szString.append(gDLL->getText("TXT_KEY_UNITHELP_ANIMAL_ON_KILL"));
				szString.append(":");
				mergedList.buildDisplayString(szString, *pSelectedUnit);
			}
		}
	}

	if (!bShort && !bOneLine)
	{
		if (!bCtrl)
		{
			szString.append(NEWLINE);
			szTempBuffer.Format( SETCOLR L"%s" ENDCOLR, TEXT_COLOR("COLOR_UNIT_TEXT"), gDLL->getText("TXT_TB_UNIT_VIEW_1").c_str());
			szString.append(szTempBuffer);
		}
		if (!bAlt)
		{
			szString.append(NEWLINE);
			szTempBuffer.Format( SETCOLR L"%s" ENDCOLR, TEXT_COLOR("COLOR_UNIT_TEXT"), gDLL->getText("TXT_TB_UNIT_VIEW_2").c_str());
			szString.append(szTempBuffer);
		}
		if (!bShift)
		{
			szString.append(NEWLINE);
			szTempBuffer.Format( SETCOLR L"%s" ENDCOLR, TEXT_COLOR("COLOR_UNIT_TEXT"), gDLL->getText("TXT_TB_UNIT_VIEW_3").c_str());
			szString.append(szTempBuffer);
		}
	}
}


void CvGameTextMgr::setPlotListHelp(CvWStringBuffer &szString, CvPlot* pPlot, bool bOneLine, bool bShort)
{
	PROFILE_FUNC();

	const bool bDebugMode = GC.getGame().isDebugMode();

	// if debug and ctrl, display grouping info instead
	if (bDebugMode && gDLL->ctrlKey())
	{
		if (pPlot->isVisible(GC.getGame().getActiveTeam(), bDebugMode))
		{
			CvWString szTempString;

			foreach_(const CvUnit* pHeadUnit, pPlot->units())
			{
				// is this unit the head of a group, not cargo, and visible?
				if (pHeadUnit->isGroupHead() && !pHeadUnit->isCargo() && !pHeadUnit->isInvisible(GC.getGame().getActiveTeam(), bDebugMode))
				{
					// head unit name and unitai
					szString.append(CvWString::format(SETCOLR L"%s" ENDCOLR, 255,190,0,255, pHeadUnit->getName().GetCString()));
					szString.append(CvWString::format(L" (%d)", shortenID(pHeadUnit->getID())));
					getUnitAIString(szTempString, pHeadUnit->AI_getUnitAIType());
					szString.append(CvWString::format(SETCOLR L" %s " ENDCOLR, GET_PLAYER(pHeadUnit->getOwner()).getPlayerTextColorR(), GET_PLAYER(pHeadUnit->getOwner()).getPlayerTextColorG(), GET_PLAYER(pHeadUnit->getOwner()).getPlayerTextColorB(), GET_PLAYER(pHeadUnit->getOwner()).getPlayerTextColorA(), szTempString.GetCString()));

					// group
					CvSelectionGroup* pHeadGroup = pHeadUnit->getGroup();
					FAssertMsg(pHeadGroup, "unit has NULL group");
					szString.append(CvWString::format(L"\nGroup:%d [%d units", shortenID(pHeadGroup->getID()), pHeadGroup->getNumUnits()));
					if (pHeadGroup->getNumUnits() > 1)
					{
						if( pHeadGroup->getCargo() > 0 )
						{
							szString.append(CvWString::format(L" + %d cargo", pHeadGroup->getCargo()));
						}
						szString.append(CvWString::format(L"]"));

						// get average damage
						int iAverageDamage = 0;
						foreach_(const CvUnit* pLoopUnit, pHeadGroup->units())
						{
							iAverageDamage += pLoopUnit->getDamage() * 100 / pLoopUnit->getMaxHP();
						}
						iAverageDamage /= pHeadGroup->getNumUnits();
						if (iAverageDamage > 0)
						{
							szString.append(CvWString::format(L" %d%%", 100 - iAverageDamage));
						}
					}

					if( pHeadGroup->isStranded() )
					{
						szString.append(CvWString::format(SETCOLR L"\n***STRANDED***" ENDCOLR, TEXT_COLOR("COLOR_RED")));
					}

					if( !gDLL->altKey() )
					{
						// mission ai
						MissionAITypes eMissionAI = pHeadGroup->AI_getMissionAIType();
						if (eMissionAI != NO_MISSIONAI)
						{
							getMissionAIString(szTempString, eMissionAI);
							szString.append(CvWString::format(SETCOLR L"\n%s" ENDCOLR, TEXT_COLOR("COLOR_HIGHLIGHT_TEXT"), szTempString.GetCString()));
						}

						// mission
						MissionTypes eMissionType = (MissionTypes) pHeadGroup->getMissionType(0);
						if (eMissionType != NO_MISSION)
						{
							getMissionTypeString(szTempString, eMissionType);
							szString.append(CvWString::format(SETCOLR L"\n%s" ENDCOLR, TEXT_COLOR("COLOR_HIGHLIGHT_TEXT"), szTempString.GetCString()));
						}

						// mission unit
						CvUnit* pMissionUnit = pHeadGroup->AI_getMissionAIUnit();
						if (pMissionUnit && (eMissionAI != NO_MISSIONAI || eMissionType != NO_MISSION))
						{
							// mission unit
							szString.append(L"\n to ");
							szString.append(CvWString::format(SETCOLR L"%s" ENDCOLR, GET_PLAYER(pMissionUnit->getOwner()).getPlayerTextColorR(), GET_PLAYER(pMissionUnit->getOwner()).getPlayerTextColorG(), GET_PLAYER(pMissionUnit->getOwner()).getPlayerTextColorB(), GET_PLAYER(pMissionUnit->getOwner()).getPlayerTextColorA(), pMissionUnit->getName().GetCString()));
							szString.append(CvWString::format(L"(%d) G:%d", shortenID(pMissionUnit->getID()), shortenID(pMissionUnit->getGroupID())));
							getUnitAIString(szTempString, pMissionUnit->AI_getUnitAIType());
							szString.append(CvWString::format(SETCOLR L" %s" ENDCOLR, GET_PLAYER(pMissionUnit->getOwner()).getPlayerTextColorR(), GET_PLAYER(pMissionUnit->getOwner()).getPlayerTextColorG(), GET_PLAYER(pMissionUnit->getOwner()).getPlayerTextColorB(), GET_PLAYER(pMissionUnit->getOwner()).getPlayerTextColorA(), szTempString.GetCString()));
						}

						// mission plot
						if (eMissionAI != NO_MISSIONAI || eMissionType != NO_MISSION)
						{
							// first try the plot from the missionAI
							CvPlot* pMissionPlot = pHeadGroup->AI_getMissionAIPlot();

							// if MissionAI does not have a plot, get one from the mission itself
							if (!pMissionPlot && eMissionType != NO_MISSION)
							{
								switch (eMissionType)
								{
									case MISSION_MOVE_TO:
									case MISSION_ROUTE_TO:
									{
										pMissionPlot =  GC.getMap().plot(pHeadGroup->getMissionData1(0), pHeadGroup->getMissionData2(0));
										break;
									}
									case MISSION_MOVE_TO_UNIT:
									{
										if (pMissionUnit)
										{
											pMissionPlot = pMissionUnit->plot();
										}
										break;
									}
								}
							}

							if (pMissionPlot)
							{
								szString.append(CvWString::format(L"\n [%d,%d]", pMissionPlot->getX(), pMissionPlot->getY()));

								CvCity* pCity = pMissionPlot->getWorkingCity();
								if (pCity)
								{
									szString.append(L" (");

									if (!pMissionPlot->isCity())
									{
										DirectionTypes eDirection = estimateDirection(dxWrap(pMissionPlot->getX() - pCity->getX()), dyWrap(pMissionPlot->getY() - pCity->getY()));

										getDirectionTypeString(szTempString, eDirection);
										szString.append(CvWString::format(L"%s of ", szTempString.GetCString()));
									}
									szString.append(CvWString::format(SETCOLR L"%s" ENDCOLR L")", GET_PLAYER(pCity->getOwner()).getPlayerTextColorR(), GET_PLAYER(pCity->getOwner()).getPlayerTextColorG(), GET_PLAYER(pCity->getOwner()).getPlayerTextColorB(), GET_PLAYER(pCity->getOwner()).getPlayerTextColorA(), pCity->getName().GetCString()));
								}
								else
								{
									if (pMissionPlot != pPlot)
									{
										DirectionTypes eDirection = estimateDirection(dxWrap(pMissionPlot->getX() - pPlot->getX()), dyWrap(pMissionPlot->getY() - pPlot->getY()));

										getDirectionTypeString(szTempString, eDirection);
										szString.append(CvWString::format(L" (%s)", szTempString.GetCString()));
									}

									PlayerTypes eMissionPlotOwner = pMissionPlot->getOwner();
									if (eMissionPlotOwner != NO_PLAYER)
									{
										szString.append(CvWString::format(L", " SETCOLR L"%s" ENDCOLR, GET_PLAYER(eMissionPlotOwner).getPlayerTextColorR(), GET_PLAYER(eMissionPlotOwner).getPlayerTextColorG(), GET_PLAYER(eMissionPlotOwner).getPlayerTextColorB(), GET_PLAYER(eMissionPlotOwner).getPlayerTextColorA(), GET_PLAYER(eMissionPlotOwner).getName()));
									}
								}
							}
						}

						// activity
						const ActivityTypes eActivityType = (ActivityTypes) pHeadGroup->getActivityType();
						if (eActivityType != NO_ACTIVITY)
						{
							getActivityTypeString(szTempString, eActivityType);
							szString.append(CvWString::format(SETCOLR L"\n%s" ENDCOLR, TEXT_COLOR("COLOR_HIGHLIGHT_TEXT"), szTempString.GetCString()));
						}
					}

					if( !gDLL->altKey() && !gDLL->shiftKey() )
					{
						// display cargo for head unit
						std::vector<CvUnit*> aCargoUnits;
						pHeadUnit->getCargoUnits(aCargoUnits);
						foreach_(const CvUnit* pCargoUnit, aCargoUnits)
						{
							if (!pCargoUnit->isInvisible(GC.getGame().getActiveTeam(), bDebugMode))
							{
								// name and unitai
								szString.append(CvWString::format(SETCOLR L"\n %s" ENDCOLR, TEXT_COLOR("COLOR_ALT_HIGHLIGHT_TEXT"), pCargoUnit->getName().GetCString()));
								szString.append(CvWString::format(L"(%d)", shortenID(pCargoUnit->getID())));
								getUnitAIString(szTempString, pCargoUnit->AI_getUnitAIType());
								szString.append(CvWString::format(SETCOLR L" %s " ENDCOLR, GET_PLAYER(pCargoUnit->getOwner()).getPlayerTextColorR(), GET_PLAYER(pCargoUnit->getOwner()).getPlayerTextColorG(), GET_PLAYER(pCargoUnit->getOwner()).getPlayerTextColorB(), GET_PLAYER(pCargoUnit->getOwner()).getPlayerTextColorA(), szTempString.GetCString()));
							}
						}

						// display grouped units
						foreach_(const CvUnit* pUnit, pPlot->units())
						{
							// is this unit not head, in head's group and visible?
							if (pUnit != pHeadUnit && pUnit->getGroupID() == pHeadUnit->getGroupID() && !pUnit->isInvisible(GC.getGame().getActiveTeam(), bDebugMode))
							{
								FAssertMsg(!pUnit->isCargo(), "unit is cargo but head unit is not cargo");
								// name and unitai
								szString.append(CvWString::format(SETCOLR L"\n-%s" ENDCOLR, TEXT_COLOR("COLOR_UNIT_TEXT"), pUnit->getName().GetCString()));
								szString.append(CvWString::format(L" (%d)", shortenID(pUnit->getID())));
								getUnitAIString(szTempString, pUnit->AI_getUnitAIType());
								szString.append(CvWString::format(SETCOLR L" %s " ENDCOLR, GET_PLAYER(pUnit->getOwner()).getPlayerTextColorR(), GET_PLAYER(pUnit->getOwner()).getPlayerTextColorG(), GET_PLAYER(pUnit->getOwner()).getPlayerTextColorB(), GET_PLAYER(pUnit->getOwner()).getPlayerTextColorA(), szTempString.GetCString()));

								// display cargo for loop unit
								std::vector<CvUnit*> aLoopCargoUnits;
								pUnit->getCargoUnits(aLoopCargoUnits);
								foreach_(const CvUnit* pCargoUnit, aLoopCargoUnits)
								{
									if (!pCargoUnit->isInvisible(GC.getGame().getActiveTeam(), bDebugMode))
									{
										// name and unitai
										szString.append(CvWString::format(SETCOLR L"\n %s" ENDCOLR, TEXT_COLOR("COLOR_ALT_HIGHLIGHT_TEXT"), pCargoUnit->getName().GetCString()));
										szString.append(CvWString::format(L"(%d)", shortenID(pCargoUnit->getID())));
										getUnitAIString(szTempString, pCargoUnit->AI_getUnitAIType());
										szString.append(CvWString::format(SETCOLR L" %s " ENDCOLR, GET_PLAYER(pCargoUnit->getOwner()).getPlayerTextColorR(), GET_PLAYER(pCargoUnit->getOwner()).getPlayerTextColorG(), GET_PLAYER(pCargoUnit->getOwner()).getPlayerTextColorB(), GET_PLAYER(pCargoUnit->getOwner()).getPlayerTextColorA(), szTempString.GetCString()));
									}
								}
							}
						}
					}

					if( !gDLL->altKey() )
					{
						if( pPlot->getTeam() == NO_TEAM || GET_TEAM(pHeadGroup->getTeam()).isAtWar(pPlot->getTeam()) )
						{
							szString.append(NEWLINE);
							CvWString szTempBuffer;

							//AI strategies
							if (GET_PLAYER(pHeadGroup->getOwner()).AI_isDoStrategy(AI_STRATEGY_DAGGER))
							{
								szTempBuffer.Format(L"Dagger, ");
								szString.append(szTempBuffer);
							}
							if (GET_PLAYER(pHeadGroup->getOwner()).AI_isDoStrategy(AI_STRATEGY_CRUSH))
							{
								szTempBuffer.Format(L"Crush, ");
								szString.append(szTempBuffer);
							}
							if (GET_PLAYER(pHeadGroup->getOwner()).AI_isDoStrategy(AI_STRATEGY_ALERT1))
							{
								szTempBuffer.Format(L"Alert1, ");
								szString.append(szTempBuffer);
							}
							if (GET_PLAYER(pHeadGroup->getOwner()).AI_isDoStrategy(AI_STRATEGY_ALERT2))
							{
								szTempBuffer.Format(L"Alert2, ");
								szString.append(szTempBuffer);
							}
							if (GET_PLAYER(pHeadGroup->getOwner()).AI_isDoStrategy(AI_STRATEGY_TURTLE))
							{
								szTempBuffer.Format(L"Turtle, ");
								szString.append(szTempBuffer);
							}
							if (GET_PLAYER(pHeadGroup->getOwner()).AI_isDoStrategy(AI_STRATEGY_LAST_STAND))
							{
								szTempBuffer.Format(L"Last Stand, ");
								szString.append(szTempBuffer);
							}
							if (GET_PLAYER(pHeadGroup->getOwner()).AI_isDoStrategy(AI_STRATEGY_FINAL_WAR))
							{
								szTempBuffer.Format(L"FinalWar, ");
								szString.append(szTempBuffer);
							}
							if (GET_PLAYER(pHeadGroup->getOwner()).AI_isDoStrategy(AI_STRATEGY_GET_BETTER_UNITS))
							{
								szTempBuffer.Format(L"GetBetterUnits, ");
								szString.append(szTempBuffer);
							}
							if (GET_PLAYER(pHeadGroup->getOwner()).AI_isDoStrategy(AI_STRATEGY_FASTMOVERS))
							{
								szTempBuffer.Format(L"FastMovers, ");
								szString.append(szTempBuffer);
							}
							if (GET_PLAYER(pHeadGroup->getOwner()).AI_isDoStrategy(AI_STRATEGY_LAND_BLITZ))
							{
								szTempBuffer.Format(L"LandBlitz, ");
								szString.append(szTempBuffer);
							}
							if (GET_PLAYER(pHeadGroup->getOwner()).AI_isDoStrategy(AI_STRATEGY_AIR_BLITZ))
							{
								szTempBuffer.Format(L"AirBlitz, ");
								szString.append(szTempBuffer);
							}
 							if (GET_PLAYER(pHeadGroup->getOwner()).AI_isDoStrategy(AI_STRATEGY_OWABWNW))
							{
								szTempBuffer.Format(L"OWABWNW, ");
								szString.append(szTempBuffer);
							}
							if (GET_PLAYER(pHeadGroup->getOwner()).AI_isDoStrategy(AI_STRATEGY_PRODUCTION))
							{
								szTempBuffer.Format(L"Production, ");
								szString.append(szTempBuffer);
							}
							if (GET_PLAYER(pHeadGroup->getOwner()).AI_isDoStrategy(AI_STRATEGY_MISSIONARY))
							{
								szTempBuffer.Format(L"Missionary, ");
								szString.append(szTempBuffer);
							}
							if (GET_PLAYER(pHeadGroup->getOwner()).AI_isDoStrategy(AI_STRATEGY_BIG_ESPIONAGE))
							{
								szTempBuffer.Format(L"BigEspionage, ");
								szString.append(szTempBuffer);
							}
							if (GET_PLAYER(pHeadGroup->getOwner()).isPushReligiousVictory())
							{
								szTempBuffer.Format(L"Religious Victory, ");
								szString.append(szTempBuffer);
							}
							else if (GET_PLAYER(pHeadGroup->getOwner()).isConsiderReligiousVictory())
							{
								szTempBuffer.Format(L"Considers Religious Victory, ");
								szString.append(szTempBuffer);
							}

							//Area battle plans.
							if (pPlot->area()->getAreaAIType(pHeadGroup->getTeam()) == AREAAI_OFFENSIVE)
							{
								szTempBuffer.Format(L"\n Area AI = OFFENSIVE");
							}
							else if (pPlot->area()->getAreaAIType(pHeadGroup->getTeam()) == AREAAI_DEFENSIVE)
							{
								szTempBuffer.Format(L"\n Area AI = DEFENSIVE");
							}
							else if (pPlot->area()->getAreaAIType(pHeadGroup->getTeam()) == AREAAI_MASSING)
							{
								szTempBuffer.Format(L"\n Area AI = MASSING");
							}
							else if (pPlot->area()->getAreaAIType(pHeadGroup->getTeam()) == AREAAI_ASSAULT)
							{
								szTempBuffer.Format(L"\n Area AI = ASSAULT");
							}
							else if (pPlot->area()->getAreaAIType(pHeadGroup->getTeam()) == AREAAI_ASSAULT_MASSING)
							{
								szTempBuffer.Format(L"\n Area AI = ASSAULT_MASSING");
							}
							else if (pPlot->area()->getAreaAIType(pHeadGroup->getTeam()) == AREAAI_NEUTRAL)
							{
								szTempBuffer.Format(L"\n Area AI = NEUTRAL");
							}

							CvCity* pTargetCity = pPlot->area()->getTargetCity(pHeadGroup->getOwner());
							if( pTargetCity )
							{
								szString.append(CvWString::format(L"\nTarget City: %s (%d)", pTargetCity->getName().c_str(), pTargetCity->getOwner()));
							}
							else
							{
								szString.append(CvWString::format(L"\nTarget City: None"));
							}

							if (gDLL->shiftKey())
							{
								szString.append(CvWString::format(L"\n\nTarget City values:\n"));

								for (int iPlayer = 0; iPlayer < MAX_PLAYERS; iPlayer++)
								{
									if (GET_TEAM(pHeadGroup->getTeam()).AI_getWarPlan(GET_PLAYER((PlayerTypes)iPlayer).getTeam()) != NO_WARPLAN
									&&  pPlot->area()->getCitiesPerPlayer((PlayerTypes)iPlayer) > 0)
									{
										foreach_(CvCity* pLoopCity, GET_PLAYER((PlayerTypes)iPlayer).cities() | filtered(CvCity::fn::area() == pPlot->area()))
										{
											if (GC.getMap().calculatePathDistance(pPlot, pLoopCity->plot()) < 20)
											{
												szString.append(
													CvWString::format(
														L"\n%s : %d + rand %d",
														pLoopCity->getName().c_str(),
														GET_PLAYER(pHeadGroup->getOwner()).AI_targetCityValue(pLoopCity,false,true),
														pLoopCity->getPopulation() / 2
													)
												);
											}
										}
									}
								}
							}
						}
					}
					// double space non-empty groups
					if (pHeadGroup->getNumUnits() > 1 || pHeadUnit->hasCargo())
					{
						szString.append(NEWLINE);
					}
					szString.append(NEWLINE);
				}
			}
		}
		return;
	}

	std::vector<CvUnit *> plotUnits;

	GC.getGame().getPlotUnits(pPlot, plotUnits);

	int iNumVisibleUnits = 0;
	if (pPlot->isVisible(GC.getGame().getActiveTeam(), bDebugMode))
	{
		iNumVisibleUnits = algo::count_if(pPlot->units(), !bind(&CvUnit::isInvisible, _1, GC.getGame().getActiveTeam(), bDebugMode, true));
	}

	if (iNumVisibleUnits > 0)
	{
		const CvUnit* centerUnit = pPlot->getCenterUnit(bDebugMode);

		if (centerUnit)
		{
			setUnitHelp(szString, centerUnit, iNumVisibleUnits > 12, true);
		}

		if (iNumVisibleUnits > 1)
		{
			std::map<int,PlayerUnitInfo> a_units;
			int iCount = 0;
			for (int iI = 0; iI < iNumVisibleUnits && iI < (int) plotUnits.size(); iI++)
			{
				CvUnit* unitX = plotUnits[iI];

				if (unitX && unitX != centerUnit)
				{
					std::map<int,PlayerUnitInfo>::iterator itr = a_units.find(PLAYER_UNIT_KEY(unitX->getOwner(), unitX->getUnitType()));

					if ( itr == a_units.end() )
					{
						PlayerUnitInfo newInfo;

						itr = a_units.insert(std::make_pair(PLAYER_UNIT_KEY(unitX->getOwner(), unitX->getUnitType()), newInfo)).first;
						itr->second.m_eOwner = unitX->getOwner();
						itr->second.m_eUnitType = unitX->getUnitType();
					}

					if ( (itr->second.m_iCount)++ == 0 )
					{
						iCount++;
					}
					int iBase = (DOMAIN_AIR == unitX->getDomainType() ? unitX->airBaseCombatStr() : unitX->baseCombatStr());
					if (iBase > 0 && unitX->getMaxHP() > 0)
					{
						itr->second.m_iTotalMaxStrength += 100 * iBase;
						itr->second.m_iTotalStrength += (100 * iBase * unitX->getHP()) / unitX->getMaxHP();
					}

					for (int iJ = GC.getNumPromotionInfos() - 1; iJ > -1; iJ--)
					{
						if (unitX->isHasPromotion((PromotionTypes)iJ))
						{
							std::map<PromotionTypes,int>::iterator promoItr = itr->second.m_promotions.find((PromotionTypes)iJ);

							if ( promoItr == itr->second.m_promotions.end() )
							{
								itr->second.m_promotions.insert(std::make_pair((PromotionTypes)iJ,1));
							}
							else
							{
								(promoItr->second)++;
							}
						}
					}
				}
			}

			bool bFirst = true;
			for (std::map<int, PlayerUnitInfo>::const_iterator itr = a_units.begin(); itr != a_units.end(); ++itr)
			{
				const CvPlayer& kPlayer = GET_PLAYER(itr->second.m_eOwner);
				const CvUnitInfo& kUnit = GC.getUnitInfo(itr->second.m_eUnitType);

				if (iCount < 5 || bFirst)
				{
					szString.append(NEWLINE);
					bFirst = false;
				}
				else
				{
					szString.append(L", ");
				}
				CvWString szUnitName;

				szUnitName.clear();
				if (kPlayer.getCivilizationType() != NO_CIVILIZATION
				&& kUnit.getCivilizationName(kPlayer.getCivilizationType())
				&& !CvWString(kUnit.getCivilizationName(kPlayer.getCivilizationType())).empty())
				{
					szUnitName = gDLL->getText(kUnit.getCivilizationName(kPlayer.getCivilizationType()));
				}
				if (szUnitName.empty())
				{
					szUnitName = kUnit.getDescription();
				}
				szString.append(CvWString::format(SETCOLR L"%s" ENDCOLR, TEXT_COLOR("COLOR_UNIT_TEXT"), szUnitName.c_str()));

				szString.append(CvWString::format(L" (%d)", itr->second.m_iCount));

				if (GC.getGame().isOption(GAMEOPTION_COMBAT_SIZE_MATTERS))
				{
					if (itr->second.m_iTotalMaxStrength > 0)
					{
						float iBase = ((float)itr->second.m_iTotalMaxStrength / (float)itr->second.m_iCount) / 10000;
						float iCurrent = ((float)itr->second.m_iTotalStrength / (float)itr->second.m_iCount) / 10000;
						if (iBase == iCurrent)
						{
							szString.append(CvWString::format(L" %.1f", iBase));
						}
						else
						{
							szString.append(CvWString::format(L" %.1f/%.1f", iCurrent, iBase));
						}
						szString.append(CvWString::format(L"%c", gDLL->getSymbolID(STRENGTH_CHAR)));
					}
				}
				else if (itr->second.m_iTotalMaxStrength > 0)
				{
					int iBase = (itr->second.m_iTotalMaxStrength / itr->second.m_iCount) / 100;
					int iCurrent = (itr->second.m_iTotalStrength / itr->second.m_iCount) / 100;
					int iCurrent100 = (itr->second.m_iTotalStrength / itr->second.m_iCount) % 100;

					if (0 != iCurrent100)
					{
						szString.append(CvWString::format(L" %d.%02d/%d", iCurrent, iCurrent100, iBase));
					}
					else if (iBase == iCurrent)
					{
						szString.append(CvWString::format(L" %d", iBase));
					}
					else
					{
						szString.append(CvWString::format(L" %d/%d", iCurrent, iBase));
					}
					szString.append(CvWString::format(L"%c", gDLL->getSymbolID(STRENGTH_CHAR)));
				}

				if (kPlayer.getID() != GC.getGame().getActivePlayer() && !kUnit.isHiddenNationality())
				{
					szString.append(L", ");

					// For minor civs, display civ name instead of player name ... to differentiate
					// and help human recognize why they can't contact that player
					if (kPlayer.isMinorCiv())
					{
						szString.append(CvWString::format(SETCOLR L"%s" ENDCOLR, kPlayer.getPlayerTextColorR(), kPlayer.getPlayerTextColorG(), kPlayer.getPlayerTextColorB(), kPlayer.getPlayerTextColorA(), kPlayer.getCivilizationDescription()));
					}
					else
					{
						szString.append(CvWString::format(SETCOLR L"%s" ENDCOLR, kPlayer.getPlayerTextColorR(), kPlayer.getPlayerTextColorG(), kPlayer.getPlayerTextColorB(), kPlayer.getPlayerTextColorA(), kPlayer.getName()));
					}
				}
			}
		}
	}
}

namespace {
	void addModifierIfValid(CvWStringBuffer& szString, int modifier, const char* const txt)
	{
		if (modifier != 0)
		{
			szString.append(NEWLINE);
			szString.append(gDLL->getText(txt, modifier));
		}
	}

	void addModifierWithInfoIfValid(CvWStringBuffer& szString, int modifier, const char* const txt, const CvInfoBase& info)
	{
		if (modifier != 0)
		{
			szString.append(NEWLINE);
			szString.append(gDLL->getText(txt, modifier, info.getTextKeyWide()));
		}
	}

	void addCombatModifierHint(CvWStringBuffer& szString, int base, int coeff, const char* const txt)
	{
		if (base != 0 && coeff > 0)
		{
			addModifierIfValid(szString, base * coeff, txt);
		}
	}

	typedef  int (CvUnit::* GetCombatModifierFn)(UnitCombatTypes combatType) const;

	void addCombatTypeModifierHints(CvWStringBuffer& szString, const CvUnit* defender, const CvUnit* attacker, GetCombatModifierFn modifierFn, const char* const txt)
	{
		for (int iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
		{
			UnitCombatTypes eUnitCombatType = static_cast<UnitCombatTypes>(iI);
			if (defender->isHasUnitCombat(eUnitCombatType))
			{
				int modifier = (attacker->*(modifierFn))(eUnitCombatType);
				if (modifier != 0)
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText(txt, modifier, GC.getUnitCombatInfo(eUnitCombatType).getTextKeyWide()));
				}
			}
		}
	}
}

// Returns true if help was given...
bool CvGameTextMgr::setCombatPlotHelp(CvWStringBuffer& szString, CvPlot* pPlot, bool bAssassinate)
{
	PROFILE_FUNC();

	if (gDLL->getInterfaceIFace()->getLengthSelectionList() == 0)
	{
		return false;
	}
	// Note that due to the large amount of extra content added to this function (setCombatPlotHelp),
	//	this should never be used in any function that needs to be called repeatedly (e.g. hundreds of times) quickly.
	// It is fine for a human player mouse-over (which is what it is used for).
	CvSelectionGroup* group = gDLL->getInterfaceIFace()->getSelectionList();

	switch (group->getDomainType())
	{
		case DOMAIN_SEA:
		{
			if (!pPlot->isWater() && !group->canMoveAllTerrain())
			{
				return false;
			}
			break;
		}
		case DOMAIN_AIR:
		{
			break;
		}
		case DOMAIN_LAND:
		{
			if (pPlot->isWater() && !pPlot->isSeaTunnel() && !group->canMoveAllTerrain())
			{
				return false;
			}
			break;
		}
		case DOMAIN_IMMOBILE:
		{
			return false;
		}
		default:
		{
			FErrorMsg("error");
			return false;
		}
	}

	CvUnit* pAttacker;

	if (GC.getGame().getActivePlayer() != NO_PLAYER)
	{
		pAttacker = GET_PLAYER(GC.getGame().getActivePlayer()).getUnit(GET_PLAYER(GC.getGame().getActivePlayer()).getAmbushingUnit());
	}
	if (!pAttacker)
	{
		const bool bIgnoreMadeAttack = !group->canAttackNow();
		int iOdds;
		pAttacker = group->AI_getBestGroupAttacker(pPlot, false, iOdds, false, NULL, bAssassinate, false, bIgnoreMadeAttack);

		if (!pAttacker)
		{
			pAttacker = group->AI_getBestGroupAttacker(pPlot, false, iOdds, true, NULL, bAssassinate, false, bIgnoreMadeAttack);
		}
	}

	if (pAttacker)
	{
		int iI;
		int iModifier;

		CvWString szTempBuffer2;
		CvWString szTempBuffer;
		CvWString szOffenseOdds;
		CvWString szDefenseOdds;

		UnitCombatTypes eUnitCombatType;

		bool bStealthAttack = false;
		bool bStealthDefense = false;
		bool bIsSamePlot = false;
		bool bTBView = gDLL->ctrlKey();
		bool bSINView = gDLL->altKey();

		int iView = gDLL->shiftKey() ? 2 : 1;

		if (getBugOptionBOOL("ACO__SwapViews", false, "ACO_SWAP_VIEWS"))
		{
			iView = 3 - iView; //swaps 1 and 2.
		}

		CvUnit* pDefender = pPlot->getBestDefender(NO_PLAYER, pAttacker->getOwner(), pAttacker, !gDLL->altKey(), NO_TEAM == pAttacker->getDeclareWarMove(pPlot), false, bAssassinate);

		if (pDefender && pDefender != pAttacker && pDefender->canDefend(pPlot) && ((pAttacker->canAttack(*pDefender) || pAttacker->canAmbush(*pDefender, bAssassinate))))
		{
			bool bAttackerInvisible = pAttacker->isInvisible(GET_PLAYER(pDefender->getOwner()).getTeam(), false, false);
			if (GC.getGame().isOption(GAMEOPTION_COMBAT_WITHOUT_WARNING))
			{
				if (bAttackerInvisible || bIsSamePlot)
				{
					bStealthAttack = true;
				}
				if (bStealthAttack && bIsSamePlot && !bAttackerInvisible)
				{
					bStealthDefense = true;
				}
			}

			if (pAttacker->getDomainType() != DOMAIN_AIR)
			{
				//TB Combat Mod begin
#ifdef STRENGTH_IN_NUMBERS
				CvUnit* paFIUnit = pAttacker->getAttackerFirstFrontSupportingUnit();
				CvUnit* paFIIUnit = pAttacker->getAttackerSecondFrontSupportingUnit();
				CvUnit* paSRIUnit = pAttacker->getAttackerFirstShortRangeSupportingUnit();
				CvUnit* paSRIIUnit = pAttacker->getAttackerSecondShortRangeSupportingUnit();
				CvUnit* paMRIUnit = pAttacker->getAttackerFirstMediumRangeSupportingUnit();
				CvUnit* paMRIIUnit = pAttacker->getAttackerSecondMediumRangeSupportingUnit();
				CvUnit* paLRIUnit = pAttacker->getAttackerFirstLongRangeSupportingUnit();
				CvUnit* paLRIIUnit = pAttacker->getAttackerSecondLongRangeSupportingUnit();
				CvUnit* paFLIUnit = pAttacker->getAttackerFirstFlankSupportingUnit();
				CvUnit* paFLIIUnit = pAttacker->getAttackerSecondFlankSupportingUnit();
				CvUnit* pdFIUnit = pDefender->getDefenderFirstFrontSupportingUnit();
				CvUnit* pdFIIUnit = pDefender->getDefenderSecondFrontSupportingUnit();
				CvUnit* pdSRIUnit = pDefender->getDefenderFirstShortRangeSupportingUnit();
				CvUnit* pdSRIIUnit = pDefender->getDefenderSecondShortRangeSupportingUnit();
				CvUnit* pdMRIUnit = pDefender->getDefenderFirstMediumRangeSupportingUnit();
				CvUnit* pdMRIIUnit = pDefender->getDefenderSecondMediumRangeSupportingUnit();
				CvUnit* pdLRIUnit = pDefender->getDefenderFirstLongRangeSupportingUnit();
				CvUnit* pdLRIIUnit = pDefender->getDefenderSecondLongRangeSupportingUnit();
				CvUnit* pdFLIUnit = pDefender->getDefenderFirstFlankSupportingUnit();
				CvUnit* pdFLIIUnit = pDefender->getDefenderSecondFlankSupportingUnit();
#endif // STRENGTH_IN_NUMBERS
				if (!bSINView)
				{
					if (pAttacker->isBreakdownCombat(pPlot))
					{

						CvCity* tCity = pPlot->getPlotCity();
						int iDefenderRepel = pDefender->repelVSOpponentProbTotal(pAttacker);
						int iAttackerUnyielding = pAttacker->unyieldingTotal();

						int AdjustedRepelstep1 = iDefenderRepel - iAttackerUnyielding;
						int AdjustedRepelstep2 = ((AdjustedRepelstep1 > 100) ? 100 : AdjustedRepelstep1);
						int AdjustedRepel = ((AdjustedRepelstep2 < 0) ? 0 : AdjustedRepelstep2);

						int iChance = pAttacker->breakdownChanceTotal();
						int iTrueChance = std::max(5, (iChance - AdjustedRepel));

						int iBombardDefMod = std::max(0, (100 - tCity->getBuildingBombardDefense()));
						int iNormalDamage = pAttacker->breakdownDamageTotal();
						int iTrueDamage = (iNormalDamage * iBombardDefMod) / 100;

						szTempBuffer.Format(SETCOLR L"%s %d%%" ENDCOLR,
							TEXT_COLOR("COLOR_RED"), gDLL->getText("TXT_KEY_COMBAT_BREAKDOWN_EFFECTS").c_str(), iTrueChance, iTrueDamage);
						szString.append(szTempBuffer.GetCString());
						szString.append(NEWLINE);
					}
				}

				if (!bSINView || !(GC.getGame().isOption(GAMEOPTION_COMBAT_STRENGTH_IN_NUMBERS)))
				{
					//TB Combat Mod end
					const int iCombatOdds = getCombatOdds(pAttacker, pDefender);

					if (pAttacker->combatLimit(pDefender) >= pDefender->getMaxHP())
					{
						if (iCombatOdds > 999)
						{
							szTempBuffer = L"&gt; 99.9";
						}
						else if (iCombatOdds < 1)
						{
							szTempBuffer = L"&lt; 0.1";
						}
						else
						{
							szTempBuffer.Format(L"%.1f", iCombatOdds / 10.0f);
						}
						if (!getBugOptionBOOL("ACO__Enabled", true, "ACO_ENABLED") || getBugOptionBOOL("ACO__ForceOriginalOdds", false, "ACO_FORCE_ORIGINAL_ODDS"))
						{
							szString.append(gDLL->getText("TXT_KEY_COMBAT_PLOT_ODDS", szTempBuffer.GetCString()));
						}
					}

					//TB Combat Mods Begin
					int iDefenderDodge = pDefender->dodgeVSOpponentProbTotal(pAttacker);
					int iDefenderPrecision = pDefender->precisionVSOpponentProbTotal(pAttacker);
					int iAttackerDodge = pAttacker->dodgeVSOpponentProbTotal(pDefender);
					int iAttackerPrecision = pAttacker->precisionVSOpponentProbTotal(pDefender);
					int iAttackerHitModifier = iAttackerPrecision - iDefenderDodge;
					int iDefenderHitModifier = iDefenderPrecision - iAttackerDodge;

					int iAttackArmorTotal = pAttacker->armorVSOpponentProbTotal(pDefender);
					int iDefendPunctureTotal = pDefender->punctureVSOpponentProbTotal(pAttacker);
					int iAttackPunctureTotal = pAttacker->punctureVSOpponentProbTotal(pDefender);
					int iDefendArmorTotal = pDefender->armorVSOpponentProbTotal(pAttacker);

					int iUnmodifiedDefenderArmor = (iDefendArmorTotal - iAttackPunctureTotal);
					int iUnmodifiedAttackerArmor = (iAttackArmorTotal - iDefendPunctureTotal);
					int iModifiedDefenderArmorZero = (iUnmodifiedDefenderArmor < 0 ? 0 : iUnmodifiedDefenderArmor);
					int iModifiedAttackerArmorZero = (iUnmodifiedAttackerArmor < 0 ? 0 : iUnmodifiedAttackerArmor);
					int iModifiedDefenderArmor = (iModifiedDefenderArmorZero > 95 ? 95 : iModifiedDefenderArmorZero);
					int iModifiedAttackerArmor = (iModifiedAttackerArmorZero > 95 ? 95 : iModifiedAttackerArmorZero);

					int iDefenderArmor = (100 - iModifiedDefenderArmor);
					int iAttackerArmor = (100 - iModifiedAttackerArmor);

					const int iAttackerStrength = pAttacker->currCombatStr(NULL, NULL);
					const int iAttackerFirepower = pAttacker->currFirepower(NULL, NULL);
					const int iDefenderStrength = std::max(1, pDefender->currCombatStr(pPlot, pAttacker));
					const int iDefenderFirepower = std::max(1, pDefender->currFirepower(pPlot, pAttacker));

					FAssert(iAttackerStrength + iDefenderStrength > 0);
					FAssert(iAttackerFirepower + iDefenderFirepower > 0);

					int iStrengthFactor = (iAttackerFirepower + iDefenderFirepower + 1) / 2;

					int iDefendDamageModifierTotal = pDefender->damageModifierTotal();
					int iAttackDamageModifierTotal = pAttacker->damageModifierTotal();

					int iDamageToAttackerBase = ((GC.getCOMBAT_DAMAGE() * (iDefenderFirepower + iStrengthFactor)) / std::max(1, (iAttackerFirepower + iStrengthFactor)));
					int iDamageToDefenderBase = ((GC.getCOMBAT_DAMAGE() * (iAttackerFirepower + iStrengthFactor)) / std::max(1, (iDefenderFirepower + iStrengthFactor)));
					int iDamageToAttackerModified = iDamageToAttackerBase + ((iDamageToAttackerBase * iDefendDamageModifierTotal) / 100);
					int iDamageToDefenderModified = iDamageToDefenderBase + ((iDamageToDefenderBase * iAttackDamageModifierTotal) / 100);
					int iDamageToAttackerArmor = (iDamageToAttackerModified * iAttackerArmor) / 100;
					int iDamageToDefenderArmor = (iDamageToDefenderModified * iDefenderArmor) / 100;
					int iDamageToAttacker = std::max(1, iDamageToAttackerArmor);
					int iDamageToDefender = std::max(1, iDamageToDefenderArmor);
					int iNeededRoundsAttacker = (pDefender->getHP() - pDefender->getMaxHP() + pAttacker->combatLimit(pDefender) - (((pAttacker->combatLimit(pDefender)) >= pDefender->getMaxHP()) ? 1 : 0)) / iDamageToDefender + 1;

					int iAttackerBaseCriticalChance = pAttacker->criticalVSOpponentProbTotal(pDefender);
					int iDefenderBaseCriticalChance = pDefender->criticalVSOpponentProbTotal(pAttacker);
					int iAttackerCriticalChance = (((iDamageToDefender * 100) * iAttackerBaseCriticalChance) / 100);
					int iDefenderCriticalChance = (((iDamageToDefender * 100) * iAttackerBaseCriticalChance) / 100);
					int iAttackerEndurance = pAttacker->enduranceTotal();
					int iDefenderEndurance = pDefender->enduranceTotal();

					int iNeededRoundsDefender = (pAttacker->getHP() + iDamageToAttacker - 1) / iDamageToAttacker;

					//  Determine Attack Withdraw odds
					int iAttackerWithdraw = pAttacker->withdrawVSOpponentProbTotal(pDefender, pPlot);
					int iDefenderPursuit = pDefender->pursuitVSOpponentProbTotal(pAttacker);
					int iAttackerEarly = pAttacker->earlyWithdrawTotal();
					int AdjustedAttWithdrawalstep1 = iAttackerWithdraw - iDefenderPursuit;
					int AdjustedAttWithdrawalstep2 = ((AdjustedAttWithdrawalstep1 > 100) ? 100 : AdjustedAttWithdrawalstep1);
					int AdjustedAttWithdrawal = ((AdjustedAttWithdrawalstep2 < 0) ? 0 : AdjustedAttWithdrawalstep2);

					int expectedrndcnt = iNeededRoundsDefender;
					int expectedrnds = ((expectedrndcnt * iAttackerEarly) / 100);

					int y = AdjustedAttWithdrawal;
					int z = AdjustedAttWithdrawal;
					int Time;
					for (Time = 0; Time < expectedrnds; ++Time)
					{
						z += ((AdjustedAttWithdrawal * y) / 100);
						y = ((AdjustedAttWithdrawal * y) / 100);
					}

					int EvaluatedAttWithdrawOdds = z;

					//  Determine Attack Knockback odds
					int iAttackerKnockback = pAttacker->knockbackVSOpponentProbTotal(pDefender);
					int iDefenderUnyielding = pDefender->unyieldingTotal();
					int iAttackerKnockbackTries = pAttacker->knockbackRetriesTotal() + 1;

					int AdjustedKnockbackstep1 = iAttackerKnockback - iDefenderUnyielding;
					int AdjustedKnockbackstep2 = ((AdjustedKnockbackstep1 > 100) ? 100 : AdjustedKnockbackstep1);
					int AdjustedKnockback = ((AdjustedKnockbackstep2 < 0) ? 0 : AdjustedKnockbackstep2);

					y = AdjustedKnockback;
					z = AdjustedKnockback;

					for (Time = 0; Time < iAttackerKnockbackTries; ++Time)
					{
						z += ((AdjustedKnockback * y) / 100);
						y = ((AdjustedKnockback * y) / 100);
					}

					int EvaluatedKnockbackOdds = z;

					//  Determine Defensive Withdrawal odds
					int iDefenderWithdraw = pDefender->withdrawVSOpponentProbTotal(pAttacker, pPlot);
					int iAttackerPursuit = pAttacker->pursuitVSOpponentProbTotal(pDefender);
					int iDefenderEarly = pDefender->earlyWithdrawTotal();
					int AdjustedDefWithdrawalstep1 = iDefenderWithdraw - iAttackerPursuit;
					int AdjustedDefWithdrawalstep2 = ((AdjustedDefWithdrawalstep1 > 100) ? 100 : AdjustedDefWithdrawalstep1);
					int AdjustedDefWithdrawal = ((AdjustedDefWithdrawalstep2 < 0) ? 0 : AdjustedDefWithdrawalstep2);

					expectedrndcnt = iNeededRoundsAttacker;
					expectedrnds = ((expectedrndcnt * iDefenderEarly) / 100);

					y = AdjustedDefWithdrawal;
					z = AdjustedDefWithdrawal;

					for (Time = 0; Time < expectedrnds; ++Time)
					{
						z += ((AdjustedDefWithdrawal * y) / 100);
						y = ((AdjustedDefWithdrawal * y) / 100);
					}

					int EvaluatedDefWithdrawalOdds = z;

					// Fortify, Repel Odds
					int iDefenderFortifyTotal = pDefender->fortifyModifier();
					int iDefenderRepel = pDefender->repelVSOpponentProbTotal(pAttacker);
					int iDefenderFortRepel = pDefender->fortifyRepelModifier();
					int iRepelAttempts = (pDefender->repelRetriesTotal() + 1);
					int iAttackerOverrun = pAttacker->overrunTotal();
					int iAttackerUnyielding = pAttacker->unyieldingTotal();
					int iFortRepellessOverrun = iDefenderFortRepel - iAttackerOverrun;
					int iFortRepelZero = (iFortRepellessOverrun < 0 ? 0 : iFortRepellessOverrun);
					int iFortRepelTotal = (iFortRepelZero > 100 ? 100 : iFortRepelZero);
					int iDefenderRepelwithFortRepel = iDefenderRepel + iFortRepelTotal;
					int iRepelwithUnyielding = iDefenderRepelwithFortRepel - iAttackerUnyielding;
					int iRepelZero = (iRepelwithUnyielding < 0 ? 0 : iRepelwithUnyielding);
					int iRepelTotal = (iRepelZero > 100 ? 100 : iRepelZero);
					int iFortifylessOverrun = iDefenderFortifyTotal - iAttackerOverrun;
					int iFortifyTotal = (iFortifylessOverrun < 0 ? 0 : iFortifylessOverrun);

					y = iRepelTotal;
					z = iRepelTotal;

					for (Time = 0; Time < iRepelAttempts; ++Time)
					{
						z += ((iRepelTotal * y) / 100);
						y = ((iRepelTotal * y) / 100);
					}

					int EvaluatedRepelOdds = z;

					int iWithdrawal = 0;
					// TB Combat Mod for combat limit withdrawal odds:
					if (pAttacker->combatLimit(pDefender) < pDefender->getMaxHP())
					{
						iWithdrawal += (100 - iDefenderPursuit) * iCombatOdds;
					}
					// TB Combat Mod next line adjusted for approximate pursuit and early withdrawal

					iWithdrawal += std::min(100, EvaluatedAttWithdrawOdds) * (1000 - iCombatOdds);

					if (iWithdrawal > 0 || pAttacker->combatLimit(pDefender) < pDefender->getMaxHP())
					{
						if (iWithdrawal > 99900)
						{
							szTempBuffer = L"&gt; 99.9";
						}
						else if (iWithdrawal < 100)
						{
							szTempBuffer = L"&lt; 0.1";
						}
						else
						{
							szTempBuffer.Format(L"%.1f", iWithdrawal / 1000.0f);
						}
						szString.append(NEWLINE);
						szString.append(gDLL->getText("TXT_KEY_COMBAT_PLOT_ODDS_RETREAT", szTempBuffer.GetCString()));
					}

					int iDefWithdrawal = 0;
					iDefWithdrawal += std::min(100, EvaluatedDefWithdrawalOdds) * (1000 - iCombatOdds);

					if (iDefWithdrawal > 0 && GC.getGame().isModderGameOption(MODDERGAMEOPTION_DEFENDER_WITHDRAW))
					{
						if (iDefWithdrawal > 99900)
						{
							szTempBuffer = L"&gt; 99.9";
						}
						else if (iDefWithdrawal < 100)
						{
							szTempBuffer = L"&lt; 0.1";
						}
						else
						{
							szTempBuffer.Format(L"%.1f", iDefWithdrawal / 1000.0f);
						}
						szString.append(NEWLINE);
						szString.append(gDLL->getText("TXT_KEY_COMBAT_PLOT_ODDS_DEFENDER_RETREAT", szTempBuffer.GetCString()));
					}

					int iRepelOdds = 0;
					iRepelOdds += std::min(100, EvaluatedRepelOdds) * (1000 - iCombatOdds);

					if (iRepelOdds > 0)
					{
						if (iRepelOdds > 99900)
						{
							szTempBuffer = L"&gt; 99.9";
						}
						else if (iRepelOdds < 100)
						{
							szTempBuffer = L"&lt; 0.1";
						}
						else
						{
							szTempBuffer.Format(L"%.1f", iRepelOdds / 1000.0f);
						}
						szString.append(NEWLINE);
						szString.append(gDLL->getText("TXT_KEY_COMBAT_PLOT_ODDS_REPEL", szTempBuffer.GetCString()));
					}

					int iKnockbackOdds = 0;
					iKnockbackOdds += std::min(100, EvaluatedKnockbackOdds) * (1000 - iCombatOdds);

					if (iKnockbackOdds > 0)
					{
						if (iKnockbackOdds > 99900)
						{
							szTempBuffer = L"&gt; 99.9";
						}
						else if (iKnockbackOdds < 100)
						{
							szTempBuffer = L"&lt; 0.1";
						}
						else
						{
							szTempBuffer.Format(L"%.1f", iKnockbackOdds / 1000.0f);
						}
						szString.append(NEWLINE);
						szString.append(gDLL->getText("TXT_KEY_COMBAT_PLOT_ODDS_KNOCKBACK", szTempBuffer.GetCString()));

					}
					szString.append(NEWLINE);

					//TB Display Mod Begin
					if (bTBView)
					{
						//TB Combat Mods (Armor Compare)
						//Defender's dodge is better than attacker's precision
						if (iAttackerHitModifier < 0)
						{
							if (iAttackerPrecision != 0)
							{
								szTempBuffer.Format(SETCOLR L"%s %d%%" ENDCOLR,
									TEXT_COLOR("COLOR_RED"), gDLL->getText("TXT_KEY_COMBAT_ARMOR_COMPARE_ATTACKER_PRECISION").c_str(), iAttackerPrecision);
								szString.append(NEWLINE);
								szString.append(szTempBuffer.GetCString());
							}
							if (iDefenderDodge != 0)
							{
								szTempBuffer.Format(SETCOLR L"- %s %d%%" ENDCOLR,
									TEXT_COLOR("COLOR_RED"), gDLL->getText("TXT_KEY_COMBAT_ARMOR_COMPARE_DEFENDER_DODGE").c_str(), iDefenderDodge);
								szString.append(NEWLINE);
								szString.append(szTempBuffer.GetCString());
							}
							szTempBuffer.Format(SETCOLR L"= %s %d%%" ENDCOLR,
								TEXT_COLOR("COLOR_RED"), gDLL->getText("TXT_KEY_COMBAT_ARMOR_COMPARE_ATTACKER_HIT_MODIFIER").c_str(), iAttackerHitModifier);
							szString.append(NEWLINE);
							szString.append(szTempBuffer.GetCString());
						}
						//Attacker's precision is higher than defender's dodge
						if (iAttackerHitModifier > 0)
						{
							if (iAttackerPrecision != 0)
							{
								szTempBuffer.Format(SETCOLR L"%s %d%%" ENDCOLR,
									TEXT_COLOR("COLOR_GREEN"), gDLL->getText("TXT_KEY_COMBAT_ARMOR_COMPARE_ATTACKER_PRECISION").c_str(), iAttackerPrecision);
								szString.append(NEWLINE);
								szString.append(szTempBuffer.GetCString());
							}
							if (iDefenderDodge != 0)
							{
								szTempBuffer.Format(SETCOLR L"- %s %d%%" ENDCOLR,
									TEXT_COLOR("COLOR_GREEN"), gDLL->getText("TXT_KEY_COMBAT_ARMOR_COMPARE_DEFENDER_DODGE").c_str(), iDefenderDodge);
								szString.append(NEWLINE);
								szString.append(szTempBuffer.GetCString());
							}
							szTempBuffer.Format(SETCOLR L"= +%s %d%%" ENDCOLR,
								TEXT_COLOR("COLOR_GREEN"), gDLL->getText("TXT_KEY_COMBAT_ARMOR_COMPARE_ATTACKER_HIT_MODIFIER").c_str(), iAttackerHitModifier);
							szString.append(NEWLINE);
							szString.append(szTempBuffer.GetCString());
						}
						//Defender's precision is higher than attacker's dodge
						if (iDefenderHitModifier > 0)
						{
							if (iDefenderPrecision != 0)
							{
								szTempBuffer.Format(SETCOLR L"%s %d%%" ENDCOLR,
									TEXT_COLOR("COLOR_RED"), gDLL->getText("TXT_KEY_COMBAT_ARMOR_COMPARE_DEFENDER_PRECISION").c_str(), iDefenderPrecision);
								szString.append(NEWLINE);
								szString.append(szTempBuffer.GetCString());
							}
							if (iAttackerDodge != 0)
							{
								szTempBuffer.Format(SETCOLR L"- %s %d%%" ENDCOLR,
									TEXT_COLOR("COLOR_RED"), gDLL->getText("TXT_KEY_COMBAT_ARMOR_COMPARE_ATTACKER_DODGE").c_str(), iAttackerDodge);
								szString.append(NEWLINE);
								szString.append(szTempBuffer.GetCString());
							}
							szTempBuffer.Format(SETCOLR L"= +%s %d%%" ENDCOLR,
								TEXT_COLOR("COLOR_RED"), gDLL->getText("TXT_KEY_COMBAT_ARMOR_COMPARE_DEFENDER_HIT_MODIFIER").c_str(), iDefenderHitModifier);
							szString.append(NEWLINE);
							szString.append(szTempBuffer.GetCString());
						}
						//Defender's precision is lower than attacker's dodge
						if (iDefenderHitModifier < 0)
						{
							if (iDefenderPrecision != 0)
							{
								szTempBuffer.Format(SETCOLR L"%s %d%%" ENDCOLR,
									TEXT_COLOR("COLOR_GREEN"), gDLL->getText("TXT_KEY_COMBAT_ARMOR_COMPARE_DEFENDER_PRECISION").c_str(), iDefenderPrecision);
								szString.append(NEWLINE);
								szString.append(szTempBuffer.GetCString());
							}
							if (iAttackerDodge != 0)
							{
								szTempBuffer.Format(SETCOLR L"- %s %d%%" ENDCOLR,
									TEXT_COLOR("COLOR_GREEN"), gDLL->getText("TXT_KEY_COMBAT_ARMOR_COMPARE_ATTACKER_DODGE").c_str(), iAttackerDodge);
								szString.append(NEWLINE);
								szString.append(szTempBuffer.GetCString());
							}
							szTempBuffer.Format(SETCOLR L"= -%s %d%%" ENDCOLR,
								TEXT_COLOR("COLOR_GREEN"), gDLL->getText("TXT_KEY_COMBAT_ARMOR_COMPARE_DEFENDER_HIT_MODIFIER").c_str(), iDefenderHitModifier);
							szString.append(NEWLINE);
							szString.append(szTempBuffer.GetCString());
						}

						if (iModifiedAttackerArmor > 0)
						{
							szTempBuffer.Format(SETCOLR L"%s %d%%" ENDCOLR,
								TEXT_COLOR("COLOR_GREEN"), gDLL->getText("TXT_KEY_COMBAT_ARMOR_COMPARE_ATTACKER_ARMOR").c_str(), iAttackArmorTotal);
							szString.append(NEWLINE);
							szString.append(szTempBuffer.GetCString());
							if (iDefendPunctureTotal > 0)
							{
								szTempBuffer.Format(SETCOLR L"%s %d" ENDCOLR,
									TEXT_COLOR("COLOR_GREEN"), gDLL->getText("TXT_KEY_COMBAT_ARMOR_COMPARE_DEFENDER_PUNCTURE").c_str(), iDefendPunctureTotal);
								szString.append(NEWLINE);
								szString.append(szTempBuffer.GetCString());
								szTempBuffer.Format(SETCOLR L"%s %d%%" ENDCOLR,
									TEXT_COLOR("COLOR_GREEN"), gDLL->getText("TXT_KEY_COMBAT_ARMOR_COMPARE_TOTAL_ATTACKER_ARMOR").c_str(), iModifiedAttackerArmor);
								szString.append(NEWLINE);
								szString.append(szTempBuffer.GetCString());
							}
						}

						if (iModifiedDefenderArmor > 0)
						{
							szTempBuffer.Format(SETCOLR L"%s %d%%" ENDCOLR,
								TEXT_COLOR("COLOR_RED"), gDLL->getText("TXT_KEY_COMBAT_ARMOR_COMPARE_DEFENDER_ARMOR").c_str(), iDefendArmorTotal);
							szString.append(NEWLINE);
							szString.append(szTempBuffer.GetCString());
							if (iAttackPunctureTotal > 0)
							{
								szTempBuffer.Format(SETCOLR L"%s %d" ENDCOLR,
									TEXT_COLOR("COLOR_RED"), gDLL->getText("TXT_KEY_COMBAT_ARMOR_COMPARE_ATTACKER_PUNCTURE").c_str(), iAttackPunctureTotal);
								szString.append(NEWLINE);
								szString.append(szTempBuffer.GetCString());
								szTempBuffer.Format(SETCOLR L"%s %d%%" ENDCOLR,
									TEXT_COLOR("COLOR_RED"), gDLL->getText("TXT_KEY_COMBAT_ARMOR_COMPARE_TOTAL_DEFENDER_ARMOR").c_str(), iModifiedDefenderArmor);
								szString.append(NEWLINE);
								szString.append(szTempBuffer.GetCString());
							}
						}

						if (iAttackDamageModifierTotal > 0)
						{
							szTempBuffer.Format(SETCOLR L"%s" ENDCOLR,
								TEXT_COLOR("COLOR_GREEN"), gDLL->getText("TXT_KEY_COMBAT_ATTACKER_DAMAGE_MODIFIER").c_str(), iAttackDamageModifierTotal);
							szString.append(NEWLINE);
							szString.append(szTempBuffer.GetCString());
						}

						if (iAttackDamageModifierTotal < 0)
						{
							szTempBuffer.Format(SETCOLR L"%s" ENDCOLR,
								TEXT_COLOR("COLOR_RED"), gDLL->getText("TXT_KEY_COMBAT_ATTACKER_DAMAGE_MODIFIER").c_str(), iAttackDamageModifierTotal);
							szString.append(NEWLINE);
							szString.append(szTempBuffer.GetCString());
						}

						if (iDefendDamageModifierTotal > 0)
						{
							szTempBuffer.Format(SETCOLR L"%s" ENDCOLR,
								TEXT_COLOR("COLOR_RED"), gDLL->getText("TXT_KEY_COMBAT_DEFENDER_DAMAGE_MODIFIER").c_str(), iDefendDamageModifierTotal);
							szString.append(NEWLINE);
							szString.append(szTempBuffer.GetCString());
						}

						if (iDefendDamageModifierTotal < 0)
						{
							szTempBuffer.Format(SETCOLR L"%s" ENDCOLR,
								TEXT_COLOR("COLOR_GREEN"), gDLL->getText("TXT_KEY_COMBAT_DEFENDER_DAMAGE_MODIFIER").c_str(), iDefendDamageModifierTotal);
							szString.append(NEWLINE);
							szString.append(szTempBuffer.GetCString());
						}
						//TB Combat Mods Withdraw odds

						if (EvaluatedAttWithdrawOdds > 0)
						{
							szTempBuffer.Format(SETCOLR L"%s %d%%" ENDCOLR,
								TEXT_COLOR("COLOR_GREEN"), gDLL->getText("TXT_KEY_COMBAT_WITHDRAW_ODDS_ATTACKER_WITHDRAWAL").c_str(), iAttackerWithdraw);
							szString.append(NEWLINE);
							szString.append(szTempBuffer.GetCString());

							if (pAttacker->currentWithdrawAdjperAttTotal() > 0)
							{
								szTempBuffer.Format(SETCOLR L"(%s +%d%%)" ENDCOLR,
									TEXT_COLOR("COLOR_GREEN"), gDLL->getText("TXT_KEY_COMBAT_WITHDRAW_ODDS_ATTACKER_REFLEXES").c_str(), pAttacker->currentWithdrawAdjperAttTotal());
								szString.append(NEWLINE);
								szString.append(szTempBuffer.GetCString());
							}

							if (pAttacker->currentWithdrawAdjperAttTotal() < 0)
							{
								szTempBuffer.Format(SETCOLR L"(%s -%d%%)" ENDCOLR,
									TEXT_COLOR("COLOR_RED"), gDLL->getText("TXT_KEY_COMBAT_WITHDRAW_ODDS_ATTACKER_FRAYED").c_str(), pAttacker->currentWithdrawAdjperAttTotal());
								szString.append(NEWLINE);
								szString.append(szTempBuffer.GetCString());
							}

							if (iDefenderPursuit > 0)
							{
								szTempBuffer.Format(SETCOLR L"%s -%d%%" ENDCOLR,
									TEXT_COLOR("COLOR_RED"), gDLL->getText("TXT_KEY_COMBAT_WITHDRAW_ODDS_DEFENDER_PURSUIT").c_str(), iDefenderPursuit);
								szString.append(NEWLINE);
								szString.append(szTempBuffer.GetCString());
								szTempBuffer.Format(SETCOLR L"%s %d%%" ENDCOLR,
									TEXT_COLOR("COLOR_GREEN"), gDLL->getText("TXT_KEY_COMBAT_WITHDRAW_ODDS_PER_ROUND_ATTEMPTED").c_str(), AdjustedAttWithdrawal);
								szString.append(NEWLINE);
								szString.append(szTempBuffer.GetCString());
							}
							if (iAttackerEarly > 0)
							{
								szTempBuffer.Format(SETCOLR L"%s %d%%" ENDCOLR,
									TEXT_COLOR("COLOR_GREEN"), gDLL->getText("TXT_KEY_COMBAT_WITHDRAW_ODDS_ATTACKER_EARLY_WITHDRAW").c_str(), iAttackerEarly);
								szString.append(NEWLINE);
								szString.append(szTempBuffer.GetCString());
							}
						}

						if (EvaluatedDefWithdrawalOdds > 0 && (GC.getGame().isModderGameOption(MODDERGAMEOPTION_DEFENDER_WITHDRAW)))
						{
							szTempBuffer.Format(SETCOLR L"%s %d%%" ENDCOLR,
								TEXT_COLOR("COLOR_RED"), gDLL->getText("TXT_KEY_COMBAT_WITHDRAW_ODDS_DEFENDER_WITHDRAWAL").c_str(), iDefenderWithdraw);
							szString.append(NEWLINE);
							szString.append(szTempBuffer.GetCString());
							if (iAttackerPursuit > 0)
							{
								szTempBuffer.Format(SETCOLR L"%s %d" ENDCOLR,
									TEXT_COLOR("COLOR_GREEN"), gDLL->getText("TXT_KEY_COMBAT_WITHDRAW_ODDS_ATTACKER_PURSUIT").c_str(), iAttackerPursuit);
								szString.append(NEWLINE);
								szString.append(szTempBuffer.GetCString());
								szTempBuffer.Format(SETCOLR L"%s %d%%" ENDCOLR,
									TEXT_COLOR("COLOR_RED"), gDLL->getText("TXT_KEY_COMBAT_WITHDRAW_ODDS_WITHDRAW_PER_ROUND").c_str(), AdjustedDefWithdrawal);
								szString.append(NEWLINE);
								szString.append(szTempBuffer.GetCString());
							}
							if (iDefenderEarly > 0)
							{
								szTempBuffer.Format(SETCOLR L"%s %d%" ENDCOLR,
									TEXT_COLOR("COLOR_RED"), gDLL->getText("TXT_KEY_COMBAT_WITHDRAW_ODDS_DEFENDER_EARLY_WITHDRAW").c_str(), iDefenderEarly);
								szString.append(NEWLINE);
								szString.append(szTempBuffer.GetCString());
							}
						}
						//TB Combat Mods (Fortification Compare)

						if (iDefenderFortifyTotal > 0)
						{
							szTempBuffer.Format(SETCOLR L"%s %d%%" ENDCOLR,
								TEXT_COLOR("COLOR_RED"), gDLL->getText("TXT_KEY_COMBAT_FORTIFICATION_COMPARE_DEFENDER_FORTIFICATION").c_str(), iDefenderFortifyTotal);
							szString.append(NEWLINE);
							szString.append(szTempBuffer.GetCString());

							if (iDefenderFortRepel > 0)
							{
								szTempBuffer.Format(SETCOLR L"%s %d%" ENDCOLR,
									TEXT_COLOR("COLOR_RED"), gDLL->getText("TXT_KEY_COMBAT_FORTIFICATION_COMPARE_FORTIFIED_REPEL").c_str(), iDefenderFortRepel);
								szString.append(NEWLINE);
								szString.append(szTempBuffer.GetCString());
							}

							if (iAttackerOverrun > 0)
							{
								szTempBuffer.Format(SETCOLR L"%s %d%" ENDCOLR,
									TEXT_COLOR("COLOR_GREEN"), gDLL->getText("TXT_KEY_COMBAT_FORTIFICATION_COMPARE_ATTACKER_OVERRUN").c_str(), iAttackerOverrun);
								szString.append(NEWLINE);
								szString.append(szTempBuffer.GetCString());
							}
						}
						if (iDefenderRepel > 0)
						{
							szTempBuffer.Format(SETCOLR L"%s %d%" ENDCOLR,
								TEXT_COLOR("COLOR_RED"), gDLL->getText("TXT_KEY_COMBAT_FORTIFICATION_COMPARE_DEFENDER_REPEL").c_str(), iDefenderRepel);
							szString.append(NEWLINE);
							szString.append(szTempBuffer.GetCString());
							if (iAttackerUnyielding > 0)
							{
								szTempBuffer.Format(SETCOLR L"%s %d" ENDCOLR,
									TEXT_COLOR("COLOR_GREEN"), gDLL->getText("TXT_KEY_COMBAT_FORTIFICATION_COMPARE_ATTACKER_UNYIELDING").c_str(), iAttackerUnyielding);
								szString.append(NEWLINE);
								szString.append(szTempBuffer.GetCString());
								szTempBuffer.Format(SETCOLR L"%s %d%" ENDCOLR,
									TEXT_COLOR("COLOR_RED"), gDLL->getText("TXT_KEY_COMBAT_FORTIFICATION_COMPARE_TOTAL_REPEL").c_str(), iRepelTotal);
								szString.append(NEWLINE);
								szString.append(szTempBuffer.GetCString());
							}
						}
						if ((iFortifyTotal) > 0 && (iAttackerOverrun > 0))
						{
							szTempBuffer.Format(SETCOLR L"%s %d%" ENDCOLR,
								TEXT_COLOR("COLOR_RED"), gDLL->getText("TXT_KEY_COMBAT_FORTIFICATION_COMPARE_TOTAL_FORTIFICATION").c_str(), iFortifyTotal);
							szString.append(NEWLINE);
							szString.append(szTempBuffer.GetCString());
						}

						//TB Combat Odds Knockback
						if (iAttackerKnockback > 0)
						{
							szTempBuffer.Format(SETCOLR L"%s %d%" ENDCOLR,
								TEXT_COLOR("COLOR_GREEN"), gDLL->getText("TXT_KEY_COMBAT_KNOCKBACK_ATTACKER_KNOCKBACK").c_str(), iAttackerKnockback);
							szString.append(NEWLINE);
							szString.append(szTempBuffer.GetCString());
							if (iDefenderUnyielding > 0)
							{
								szTempBuffer.Format(SETCOLR L"%s %d" ENDCOLR,
									TEXT_COLOR("COLOR_RED"), gDLL->getText("TXT_KEY_COMBAT_KNOCKBACK_DEFENDER_UNYIELDING").c_str(), iDefenderUnyielding);
								szString.append(NEWLINE);
								szString.append(szTempBuffer.GetCString());
								szTempBuffer.Format(SETCOLR L"%s %d%" ENDCOLR,
									TEXT_COLOR("COLOR_GREEN"), gDLL->getText("TXT_KEY_COMBAT_KNOCKBACK_TOTAL_KNOCKBACK").c_str(), AdjustedKnockback);
								szString.append(NEWLINE);
								szString.append(szTempBuffer.GetCString());
							}
						}

						//TB Combat Odds Round Stuns
						int iAttackerRoundStunProb = pAttacker->roundStunProbTotal();
						int iAttackerTotalAfterVS = pAttacker->roundStunVSOpponentProbTotal(pDefender);
						int iAttackerVSCombatClass = iAttackerTotalAfterVS - iAttackerRoundStunProb;
						int iElectricalMod = 0;
						if (iAttackerRoundStunProb > 0 /*|| bAttackerDealsElectricalDamage*/)
						{
							szTempBuffer.Format(SETCOLR L"%s" ENDCOLR,
								TEXT_COLOR("COLOR_BLUE"), gDLL->getText("TXT_KEY_COMBAT_ROUND_STUN_START").c_str());
							szString.append(NEWLINE);
							szString.append(szTempBuffer.GetCString());
							szTempBuffer.Format(SETCOLR L"%s %d%" ENDCOLR,
								TEXT_COLOR("COLOR_GREEN"), gDLL->getText("TXT_KEY_COMBAT_ROUND_STUN_TOTAL_ATTACKER_ROUND_STUN").c_str(), iAttackerRoundStunProb);
							szString.append(NEWLINE);
							szString.append(szTempBuffer.GetCString());
							if (iAttackerVSCombatClass != 0)
							{
								szTempBuffer.Format(SETCOLR L"%s %d" ENDCOLR,
									TEXT_COLOR("COLOR_GREEN"), gDLL->getText("TXT_KEY_COMBAT_ROUND_STUN_VS_DEFENDER_COMBAT_CLASS").c_str(), iAttackerVSCombatClass);
								szString.append(NEWLINE);
								szString.append(szTempBuffer.GetCString());
							}
							if (iAttackerCriticalChance != 0)
							{
								szTempBuffer.Format(SETCOLR L"%s %d%" ENDCOLR,
									TEXT_COLOR("COLOR_GREEN"), gDLL->getText("TXT_KEY_COMBAT_ROUND_STUN_PLUS_CRITICAL").c_str(), iAttackerCriticalChance);
								szString.append(NEWLINE);
								szString.append(szTempBuffer.GetCString());
							}
							//if (bAttackerDealsElectricalDamage)
							//{
							//iElectricalMod = 100;
							//szTempBuffer.Format(SETCOLR L"%s %d%" ENDCOLR,
							//				TEXT_COLOR("COLOR_GREEN"), gDLL->getText("TXT_KEY_COMBAT_ROUND_STUN_PLUS_ELECTRICAL").c_str(), iElectricalMod);
							//szString.append(NEWLINE);
						//	szString.append(szTempBuffer.GetCString());
							//}
							int iDefenderEnduranceModifier = iDefenderEndurance * 10;
							if (iDefenderEndurance != 0)
							{
								szTempBuffer.Format(SETCOLR L"%s %d%" ENDCOLR,
									TEXT_COLOR("COLOR_RED"), gDLL->getText("TXT_KEY_COMBAT_ROUND_STUN_ATTACKER_MINUS_DEFENDER_ENDURANCE").c_str(), iDefenderEnduranceModifier);
								szString.append(NEWLINE);
								szString.append(szTempBuffer.GetCString());
							}
							int iAttackerRoundStunTotal = iAttackerTotalAfterVS + iAttackerCriticalChance + iElectricalMod - iDefenderEnduranceModifier;
							szTempBuffer.Format(SETCOLR L"%s %d%" ENDCOLR,
								TEXT_COLOR("COLOR_RED"), gDLL->getText("TXT_KEY_COMBAT_ROUND_STUN_ATTACKER_GRAND_TOTAL").c_str(), iAttackerRoundStunTotal);
							szString.append(NEWLINE);
							szString.append(szTempBuffer.GetCString());
						}

						int iDefenderRoundStunProb = pDefender->roundStunProbTotal();
						int iDefenderTotalAfterVS = pDefender->roundStunVSOpponentProbTotal(pAttacker);
						int iDefenderVSCombatClass = iDefenderTotalAfterVS - iDefenderRoundStunProb;
						iElectricalMod = 0;
						if (iDefenderRoundStunProb > 0 /*|| bAttackerDealsElectricalDamage*/)
						{
							szTempBuffer.Format(SETCOLR L"%s" ENDCOLR,
								TEXT_COLOR("COLOR_BLUE"), gDLL->getText("TXT_KEY_COMBAT_ROUND_STUN_START").c_str());
							szString.append(NEWLINE);
							szString.append(szTempBuffer.GetCString());
							szTempBuffer.Format(SETCOLR L"%s %d%" ENDCOLR,
								TEXT_COLOR("COLOR_RED"), gDLL->getText("TXT_KEY_COMBAT_ROUND_STUN_TOTAL_DEFENDER_ROUND_STUN").c_str(), iDefenderRoundStunProb);
							szString.append(NEWLINE);
							szString.append(szTempBuffer.GetCString());
							if (iDefenderVSCombatClass != 0)
							{
								szTempBuffer.Format(SETCOLR L"%s %d" ENDCOLR,
									TEXT_COLOR("COLOR_RED"), gDLL->getText("TXT_KEY_COMBAT_ROUND_STUN_VS_ATTACKER_COMBAT_CLASS").c_str(), iDefenderVSCombatClass);
								szString.append(NEWLINE);
								szString.append(szTempBuffer.GetCString());
							}
							if (iDefenderCriticalChance != 0)
							{
								szTempBuffer.Format(SETCOLR L"%s %d%" ENDCOLR,
									TEXT_COLOR("COLOR_RED"), gDLL->getText("TXT_KEY_COMBAT_ROUND_STUN_PLUS_CRITICAL").c_str(), iDefenderCriticalChance);
								szString.append(NEWLINE);
								szString.append(szTempBuffer.GetCString());
							}
							//if (bDefenderDealsElectricalDamage)
							//{
							//iElectricalMod = 100;
							//szTempBuffer.Format(SETCOLR L"%s %d%" ENDCOLR,
							//				TEXT_COLOR("COLOR_RED"), gDLL->getText("TXT_KEY_COMBAT_ROUND_STUN_PLUS_ELECTRICAL").c_str(), iElectricalMod);
							//szString.append(NEWLINE);
						//	szString.append(szTempBuffer.GetCString());
							//}
							int iAttackerEnduranceModifier = iAttackerEndurance * 10;
							if (iAttackerEndurance != 0)
							{
								szTempBuffer.Format(SETCOLR L"%s %d%" ENDCOLR,
									TEXT_COLOR("COLOR_GREEN"), gDLL->getText("TXT_KEY_COMBAT_ROUND_STUN_DEFENDER_MINUS_ATTACKER_ENDURANCE").c_str(), iAttackerEnduranceModifier);
								szString.append(NEWLINE);
								szString.append(szTempBuffer.GetCString());
							}
							int iDefenderRoundStunTotal = iDefenderTotalAfterVS + iDefenderCriticalChance + iElectricalMod - iAttackerEnduranceModifier;
							szTempBuffer.Format(SETCOLR L"%s %d%" ENDCOLR,
								TEXT_COLOR("COLOR_RED"), gDLL->getText("TXT_KEY_COMBAT_ROUND_STUN_DEFENDER_GRAND_TOTAL").c_str(), iDefenderRoundStunTotal);
							szString.append(NEWLINE);
							szString.append(szTempBuffer.GetCString());
						}


						if (pAttacker->strAdjperRndTotal() > 0)
						{
							szTempBuffer.Format(SETCOLR L"%s +%d%%" ENDCOLR,
								TEXT_COLOR("COLOR_GREEN"), gDLL->getText("TXT_KEY_COMBAT_ADJUST_RAGE_PER_ROUND").c_str(), pAttacker->strAdjperRndTotal());
							szString.append(NEWLINE);
							szString.append(szTempBuffer.GetCString());
						}

						if (pAttacker->strAdjperRndTotal() < 0)
						{
							szTempBuffer.Format(SETCOLR L"%s -%d%%" ENDCOLR,
								TEXT_COLOR("COLOR_RED"), gDLL->getText("TXT_KEY_COMBAT_ADJUST_FATIGUE_PER_ROUND").c_str(), pAttacker->strAdjperRndTotal());
							szString.append(NEWLINE);
							szString.append(szTempBuffer.GetCString());
						}

						if (pAttacker->canStampede())
						{
							szTempBuffer.Format(SETCOLR L"%s" ENDCOLR,
								TEXT_COLOR("COLOR_BLUE"), gDLL->getText("TXT_KEY_COMBAT_FIGHT_TO_DEATH").c_str());
							szString.append(NEWLINE);
							szString.append(szTempBuffer.GetCString());
						}

						if (pAttacker->canOnslaught())
						{
							szTempBuffer.Format(SETCOLR L"%s" ENDCOLR,
								TEXT_COLOR("COLOR_BLUE"), gDLL->getText("TXT_KEY_COMBAT_ATTACK_UNTIL_DAMAGED").c_str());
							szString.append(NEWLINE);
							szString.append(szTempBuffer.GetCString());
						}

						if (pAttacker->dealsColdDamage())
						{
							szTempBuffer.Format(SETCOLR L"%s" ENDCOLR,
								TEXT_COLOR("COLOR_GREEN"), gDLL->getText("TXT_KEY_COMBAT_ATTACKER_COLD_DAMAGE").c_str());
							szString.append(NEWLINE);
							szString.append(szTempBuffer.GetCString());
						}

						if (pDefender->dealsColdDamage())
						{
							szTempBuffer.Format(SETCOLR L"%s" ENDCOLR,
								TEXT_COLOR("COLOR_RED"), gDLL->getText("TXT_KEY_COMBAT_DEFENDER_COLD_DAMAGE").c_str());
							szString.append(NEWLINE);
							szString.append(szTempBuffer.GetCString());
						}

#ifdef OUTBREAKS_AND_AFFLICTIONS
						for (iI = 0; iI < GC.getNumPromotionLineInfos(); ++iI)
						{
							PromotionLineTypes ePoisonLine = (PromotionLineTypes)iI;
							if (pAttacker->hasAfflictOnAttackType(ePoisonLine))
							{
								int iAttackerPoisonProb = pAttacker->getAfflictOnAttackTypeProbability(ePoisonLine);
								bool iAttackerImmediate = pAttacker->isAfflictOnAttackTypeImmediate(ePoisonLine);
								int iDefenderFortitude = pDefender->fortitudeTotal();
								int iAttackerTotalPoisonProb = std::max(0, (iAttackerPoisonProb - iDefenderFortitude - pDefender->getUnitAfflictionTolerance(ePoisonLine)));
								szTempBuffer.Format(SETCOLR L"%s %s" ENDCOLR,
									TEXT_COLOR("COLOR_GREEN"), gDLL->getText("TXT_KEY_COMBAT_ATTACKER_MAY_AFFLICT").c_str(), GC.getPromotionInfo((PromotionTypes)iI).getDescription());
								szTempBuffer.Format(SETCOLR L"%d% %s" ENDCOLR,
									TEXT_COLOR("COLOR_GREEN"), iAttackerPoisonProb, gDLL->getText("TXT_KEY_COMBAT_MAY_AFFLICT2").c_str());
								if (pDefender->getUnitAfflictionTolerance(ePoisonLine) > 0)
								{
									szTempBuffer.Format(SETCOLR L"- %s %d%" ENDCOLR,
										TEXT_COLOR("COLOR_GREEN"), gDLL->getText("TXT_KEY_COMBAT_TOLERANCE").c_str(), pDefender->getUnitAfflictionTolerance(ePoisonLine));
									szString.append(szTempBuffer.GetCString());
								}
								if (iDefenderFortitude > 0)
								{
									szTempBuffer.Format(SETCOLR L"%d% %s" ENDCOLR,
										TEXT_COLOR("COLOR_GREEN"), iDefenderFortitude, gDLL->getText("TXT_KEY_COMBAT_MAY_AFFLICT3").c_str());
									szTempBuffer.Format(SETCOLR L"%d%" ENDCOLR,
										TEXT_COLOR("COLOR_GREEN"), iAttackerTotalPoisonProb);
								}
								szString.append(NEWLINE);
								if (iAttackerImmediate)
								{
									szTempBuffer.Format(SETCOLR L"%s" ENDCOLR,
										TEXT_COLOR("COLOR_GREEN"), gDLL->getText("TXT_KEY_COMBAT_MAY_AFFLICT_IMMEDIATE").c_str());
								}
								else
								{
									szTempBuffer.Format(SETCOLR L"%s" ENDCOLR,
										TEXT_COLOR("COLOR_GREEN"), gDLL->getText("TXT_KEY_COMBAT_MAY_AFFLICT_DELAYED").c_str());
								}

								szString.append(NEWLINE);
								szString.append(szTempBuffer.GetCString());
							}

							if (pDefender->hasAfflictOnAttackType(ePoisonLine))
							{
								int iDefenderPoisonProb = pDefender->getAfflictOnAttackTypeProbability(ePoisonLine);
								bool iDefenderImmediate = pDefender->isAfflictOnAttackTypeImmediate(ePoisonLine);
								int iAttackerFortitude = pAttacker->fortitudeTotal();
								int iDefenderTotalPoisonProb = std::max(0, (iDefenderPoisonProb - iAttackerFortitude - pAttacker->getUnitAfflictionTolerance(ePoisonLine)));
								szTempBuffer.Format(SETCOLR L"%s %s" ENDCOLR,
									TEXT_COLOR("COLOR_RED"), gDLL->getText("TXT_KEY_COMBAT_DEFENDER_MAY_AFFLICT").c_str(), GC.getPromotionInfo((PromotionTypes)iI).getDescription());
								szTempBuffer.Format(SETCOLR L"%d% %s" ENDCOLR,
									TEXT_COLOR("COLOR_RED"), iDefenderPoisonProb, gDLL->getText("TXT_KEY_COMBAT_MAY_AFFLICT2").c_str());
								if (pAttacker->getUnitAfflictionTolerance(ePoisonLine) > 0)
								{
									szTempBuffer.Format(SETCOLR L"- %s %d%" ENDCOLR,
										TEXT_COLOR("COLOR_RED"), gDLL->getText("TXT_KEY_COMBAT_TOLERANCE").c_str(), pAttacker->getUnitAfflictionTolerance(ePoisonLine));
									szString.append(szTempBuffer.GetCString());
								}
								if (iAttackerFortitude > 0)
								{
									szTempBuffer.Format(SETCOLR L"%d% %s" ENDCOLR,
										TEXT_COLOR("COLOR_RED"), iAttackerFortitude, gDLL->getText("TXT_KEY_COMBAT_MAY_AFFLICT3").c_str());
									szTempBuffer.Format(SETCOLR L"%d%" ENDCOLR,
										TEXT_COLOR("COLOR_RED"), iDefenderTotalPoisonProb);
								}
								szString.append(NEWLINE);
								if (iDefenderImmediate)
								{
									szTempBuffer.Format(SETCOLR L"%s" ENDCOLR,
										TEXT_COLOR("COLOR_RED"), gDLL->getText("TXT_KEY_COMBAT_MAY_AFFLICT_IMMEDIATE").c_str());
								}
								else
								{
									szTempBuffer.Format(SETCOLR L"%s" ENDCOLR,
										TEXT_COLOR("COLOR_RED"), gDLL->getText("TXT_KEY_COMBAT_MAY_AFFLICT_DELAYED").c_str());
								}

								szString.append(NEWLINE);
								szString.append(szTempBuffer.GetCString());
							}

							if (pAttacker->hasAfflictionLine(ePoisonLine) && GC.getPromotionLineInfo(ePoisonLine).getCommunicability() > 0 && !GC.getPromotionLineInfo(ePoisonLine).isNoSpreadonBattle())
							{
								szTempBuffer.Format(SETCOLR L"%s %s" ENDCOLR,
									TEXT_COLOR("COLOR_GREEN"), gDLL->getText("TXT_KEY_COMBAT_ATTACKER_MAY_AFFLICT").c_str(), GC.getPromotionLineInfo(ePoisonLine).getDescription());
								szString.append(NEWLINE);
								szString.append(szTempBuffer.GetCString());
								szTempBuffer.Format(SETCOLR L"%s %d%" ENDCOLR,
									TEXT_COLOR("COLOR_GREEN"), gDLL->getText("TXT_KEY_COMBAT_BASE_CHANCE").c_str(), GC.getPromotionLineInfo(ePoisonLine).getCommunicability());
								szString.append(szTempBuffer.GetCString());
								if (pDefender->fortitudeTotal() > 0)
								{
									szTempBuffer.Format(SETCOLR L"- %s %d%" ENDCOLR,
										TEXT_COLOR("COLOR_GREEN"), gDLL->getText("TXT_KEY_COMBAT_FORTITUDE").c_str(), pDefender->fortitudeTotal());
									szString.append(szTempBuffer.GetCString());
								}
								//if (pDefender->aidVolume(pDefender->plot()) > 0)
								//{
								//	szTempBuffer.Format(SETCOLR L"- %s %d%" ENDCOLR,
								//					TEXT_COLOR("COLOR_GREEN"), gDLL->getText("TXT_KEY_COMBAT_AID_PRESENT").c_str(), pDefender->aidVolume(pDefender->plot()));
								//	szString.append(szTempBuffer.GetCString());
								//}
								if (pDefender->getUnitAfflictionTolerance(ePoisonLine) > 0)
								{
									szTempBuffer.Format(SETCOLR L"- %s %d%" ENDCOLR,
										TEXT_COLOR("COLOR_GREEN"), gDLL->getText("TXT_KEY_COMBAT_TOLERANCE").c_str(), pDefender->getUnitAfflictionTolerance(ePoisonLine));
									szString.append(szTempBuffer.GetCString());
								}
								if (pDefender->getContractChanceChange(ePoisonLine) > 0)
								{
									int iDefenderMiscMods = pDefender->getFortitudeModifierTypeAmount(ePoisonLine) + pDefender->getContractChanceChange(ePoisonLine);
									szTempBuffer.Format(SETCOLR L"- %s %d%" ENDCOLR,
										TEXT_COLOR("COLOR_GREEN"), gDLL->getText("TXT_KEY_COMBAT_MISC_MODS").c_str(), iDefenderMiscMods);
									szString.append(szTempBuffer.GetCString());
								}
								if (pDefender->fortitudeTotal() > 0/* || pDefender->aidVolume(pDefender->plot()) > 0*/)
								{
									int iTotalCommunicabilityChance = GC.getPromotionLineInfo(ePoisonLine).getCommunicability() - pDefender->fortitudeTotal() /*- pDefender->aidVolume(pDefender->plot())*/;
									szTempBuffer.Format(SETCOLR L"= %d%" ENDCOLR,
										TEXT_COLOR("COLOR_GREEN"), iTotalCommunicabilityChance);
									szString.append(szTempBuffer.GetCString());
								}
								szString.append(NEWLINE);
							}

							if (pDefender->hasAfflictionLine(ePoisonLine) && GC.getPromotionLineInfo(ePoisonLine).getCommunicability() > 0 && !GC.getPromotionLineInfo(ePoisonLine).isNoSpreadonBattle())
							{
								szTempBuffer.Format(SETCOLR L"%s %s" ENDCOLR,
									TEXT_COLOR("COLOR_RED"), gDLL->getText("TXT_KEY_COMBAT_DEFENDER_MAY_AFFLICT").c_str(), GC.getPromotionLineInfo(ePoisonLine).getDescription());
								szString.append(NEWLINE);
								szString.append(szTempBuffer.GetCString());
								szTempBuffer.Format(SETCOLR L"%s %d%" ENDCOLR,
									TEXT_COLOR("COLOR_RED"), gDLL->getText("TXT_KEY_COMBAT_BASE_CHANCE").c_str(), GC.getPromotionLineInfo(ePoisonLine).getCommunicability());
								szString.append(szTempBuffer.GetCString());
								if (pAttacker->fortitudeTotal() > 0)
								{
									szTempBuffer.Format(SETCOLR L"- %s %d%" ENDCOLR,
										TEXT_COLOR("COLOR_RED"), gDLL->getText("TXT_KEY_COMBAT_FORTITUDE").c_str(), pAttacker->fortitudeTotal());
									szString.append(szTempBuffer.GetCString());
								}
								//if (pAttacker->aidVolume(pDefender->plot()) > 0)
								//{
								//	szTempBuffer.Format(SETCOLR L"- %s %d%" ENDCOLR,
								//					TEXT_COLOR("COLOR_RED"), gDLL->getText("TXT_KEY_COMBAT_AID_PRESENT").c_str(), pAttacker->aidVolume(pAttacker->plot()));
								//	szString.append(szTempBuffer.GetCString());
								//}
								if (pAttacker->getUnitAfflictionTolerance(ePoisonLine) > 0)
								{
									szTempBuffer.Format(SETCOLR L"- %s %d%" ENDCOLR,
										TEXT_COLOR("COLOR_RED"), gDLL->getText("TXT_KEY_COMBAT_TOLERANCE").c_str(), pAttacker->getUnitAfflictionTolerance(ePoisonLine));
									szString.append(szTempBuffer.GetCString());
								}
								if (pAttacker->getContractChanceChange(ePoisonLine) > 0)
								{
									int iAttackerMiscMods = pAttacker->getFortitudeModifierTypeAmount(ePoisonLine) + pAttacker->getContractChanceChange(ePoisonLine);
									szTempBuffer.Format(SETCOLR L"- %s %d%" ENDCOLR,
										TEXT_COLOR("COLOR_RED"), gDLL->getText("TXT_KEY_COMBAT_MISC_MODS").c_str(), iAttackerMiscMods);
									szString.append(szTempBuffer.GetCString());
								}
								if (pAttacker->fortitudeTotal() > 0 /*|| pAttacker->aidVolume(pAttacker->plot()) > 0*/)
								{
									int iTotalCommunicabilityChance = GC.getPromotionLineInfo(ePoisonLine).getCommunicability() - pAttacker->fortitudeTotal()/* - pAttacker->aidVolume(pAttacker->plot())*/;
									szTempBuffer.Format(SETCOLR L"= %d%" ENDCOLR,
										TEXT_COLOR("COLOR_RED"), iTotalCommunicabilityChance);
									szString.append(szTempBuffer.GetCString());
								}
								szString.append(NEWLINE);
							}
						}
#endif
						if (iAttackerCriticalChance > 0)
						{
							if (iAttackerBaseCriticalChance != 0)
							{
								szTempBuffer.Format(SETCOLR L"%s %d%%" ENDCOLR,
									TEXT_COLOR("COLOR_GREEN"), gDLL->getText("TXT_KEY_COMBAT_ATTACKER_CRITICAL_MODIFIER").c_str(), iAttackerBaseCriticalChance);
								szString.append(NEWLINE);
								szString.append(szTempBuffer.GetCString());

							}
							szTempBuffer.Format(SETCOLR L"%s %.1f%%" ENDCOLR,
								TEXT_COLOR("COLOR_GREEN"), gDLL->getText("TXT_KEY_COMBAT_ATTACKER_CHANCE_CRITICAL").c_str(), iAttackerCriticalChance / 10000.00f);
							szString.append(NEWLINE);
							szString.append(szTempBuffer.GetCString());
						}

						if (iDefenderCriticalChance > 0)
						{
							if (iDefenderBaseCriticalChance != 0)
							{
								szTempBuffer.Format(SETCOLR L"%s %d%%" ENDCOLR,
									TEXT_COLOR("COLOR_RED"), gDLL->getText("TXT_KEY_COMBAT_DEFENDER_CRITICAL_MODIFIER").c_str(), iDefenderBaseCriticalChance);
								szString.append(NEWLINE);
								szString.append(szTempBuffer.GetCString());
							}
							szTempBuffer.Format(SETCOLR L"%s %.1f%%" ENDCOLR,
								TEXT_COLOR("COLOR_RED"), gDLL->getText("TXT_KEY_COMBAT_DEFENDER_CHANCE_CRITICAL").c_str(), iDefenderCriticalChance / 10000.00f);
							szString.append(NEWLINE);
							szString.append(szTempBuffer.GetCString());
						}

						if (pAttacker->powerShotsTotal() > 0)
						{
							int iAttackerPowerShots = pAttacker->powerShotsTotal();
							int iAttackerPowerShotCombat = pAttacker->powerShotCombatModifierTotal();
							int iAttackerPowerShotPuncture = pAttacker->powerShotPunctureModifierTotal();
							int iAttackerPowerShotPrecision = pAttacker->powerShotPrecisionModifierTotal();
							int iAttackerPowerShotCritical = pAttacker->powerShotCriticalModifierTotal();
							szTempBuffer.Format(SETCOLR L"%s %d" ENDCOLR,
								TEXT_COLOR("COLOR_GREEN"), gDLL->getText("TXT_KEY_COMBAT_ATTACKER_POWER_SHOTS").c_str(), iAttackerPowerShots);
							szString.append(NEWLINE);
							szString.append(szTempBuffer.GetCString());

							if (iAttackerPowerShotCombat != 0)
							{
								szTempBuffer.Format(SETCOLR L"%s %d%%" ENDCOLR,
									TEXT_COLOR("COLOR_GREEN"), gDLL->getText("TXT_KEY_COMBAT_ATTACKER_POWER_SHOTS_COMBAT_MODIFIER").c_str(), iAttackerPowerShotCombat);
								szString.append(NEWLINE);
								szString.append(szTempBuffer.GetCString());

							}
							if (iAttackerPowerShotPuncture != 0)
							{
								szTempBuffer.Format(SETCOLR L"%s %d%%" ENDCOLR,
									TEXT_COLOR("COLOR_GREEN"), gDLL->getText("TXT_KEY_COMBAT_ATTACKER_POWER_SHOTS_PUNCTURE_MODIFIER").c_str(), iAttackerPowerShotPuncture);
								szString.append(NEWLINE);
								szString.append(szTempBuffer.GetCString());
							}
							if (iAttackerPowerShotPrecision != 0)
							{
								szTempBuffer.Format(SETCOLR L"%s %d%%" ENDCOLR,
									TEXT_COLOR("COLOR_GREEN"), gDLL->getText("TXT_KEY_COMBAT_ATTACKER_POWER_SHOTS_PRECISION_MODIFIER").c_str(), iAttackerPowerShotPrecision);
								szString.append(NEWLINE);
								szString.append(szTempBuffer.GetCString());
							}
							if (iAttackerPowerShotCritical != 0)
							{
								szTempBuffer.Format(SETCOLR L"%s %d%%" ENDCOLR,
									TEXT_COLOR("COLOR_GREEN"), gDLL->getText("TXT_KEY_COMBAT_ATTACKER_POWER_SHOTS_CRITICAL_MODIFIER").c_str(), iAttackerPowerShotCritical);
								szString.append(NEWLINE);
								szString.append(szTempBuffer.GetCString());

							}
						}
						if (pDefender->powerShotsTotal() > 0)
						{
							int iDefenderPowerShots = pDefender->powerShotsTotal();
							int iDefenderPowerShotCombat = pDefender->powerShotCombatModifierTotal();
							int iDefenderPowerShotPuncture = pDefender->powerShotPunctureModifierTotal();
							int iDefenderPowerShotPrecision = pDefender->powerShotPrecisionModifierTotal();
							int iDefenderPowerShotCritical = pDefender->powerShotCriticalModifierTotal();
							szTempBuffer.Format(SETCOLR L"%s %d" ENDCOLR,
								TEXT_COLOR("COLOR_RED"), gDLL->getText("TXT_KEY_COMBAT_DEFENDER_POWER_SHOTS").c_str(), iDefenderPowerShots);
							szString.append(NEWLINE);
							szString.append(szTempBuffer.GetCString());

							if (iDefenderPowerShotCombat != 0)
							{
								szTempBuffer.Format(SETCOLR L"%s %d%%" ENDCOLR,
									TEXT_COLOR("COLOR_RED"), gDLL->getText("TXT_KEY_COMBAT_DEFENDER_POWER_SHOTS_COMBAT_MODIFIER").c_str(), iDefenderPowerShotCombat);
								szString.append(NEWLINE);
								szString.append(szTempBuffer.GetCString());

							}
							if (iDefenderPowerShotPuncture != 0)
							{
								szTempBuffer.Format(SETCOLR L"%s %d%%" ENDCOLR,
									TEXT_COLOR("COLOR_RED"), gDLL->getText("TXT_KEY_COMBAT_DEFENDER_POWER_SHOTS_PUNCTURE_MODIFIER").c_str(), iDefenderPowerShotPuncture);
								szString.append(NEWLINE);
								szString.append(szTempBuffer.GetCString());

							}
							if (iDefenderPowerShotPrecision != 0)
							{
								szTempBuffer.Format(SETCOLR L"%s %d%%" ENDCOLR,
									TEXT_COLOR("COLOR_RED"), gDLL->getText("TXT_KEY_COMBAT_DEFENDER_POWER_SHOTS_PRECISION_MODIFIER").c_str(), iDefenderPowerShotPrecision);
								szString.append(NEWLINE);
								szString.append(szTempBuffer.GetCString());

							}
							if (iDefenderPowerShotCritical != 0)
							{
								szTempBuffer.Format(SETCOLR L"%s %d%%" ENDCOLR,
									TEXT_COLOR("COLOR_RED"), gDLL->getText("TXT_KEY_COMBAT_DEFENDER_POWER_SHOTS_CRITICAL_MODIFIER").c_str(), iDefenderPowerShotCritical);
								szString.append(NEWLINE);
								szString.append(szTempBuffer.GetCString());
							}
						}

#ifdef STRENGTH_IN_NUMBERS
						if (GC.getGame().isOption(GAMEOPTION_COMBAT_STRENGTH_IN_NUMBERS))
						{
							if (pAttacker->getAttackerSupportValue() > 0)
							{
								int iAttackerSupport = pAttacker->getAttackerSupportValue();
								szTempBuffer.Format(SETCOLR L"%s +%d" ENDCOLR,
									TEXT_COLOR("COLOR_GREEN"), gDLL->getText("TXT_KEY_COMBAT_TOTAL_ATTACKER_SUPPORT").c_str(), iAttackerSupport);
								szString.append(NEWLINE);
								szString.append(szTempBuffer.GetCString());
							}
							if (pDefender->getDefenderSupportValue(pAttacker) > 0)
							{
								int iDefenderSupport = pDefender->getDefenderSupportValue(pAttacker);
								szTempBuffer.Format(SETCOLR L"%s +%d" ENDCOLR,
									TEXT_COLOR("COLOR_RED"), gDLL->getText("TXT_KEY_COMBAT_TOTAL_DEFENDER_SUPPORT").c_str(), iDefenderSupport);
								szString.append(NEWLINE);
								szString.append(szTempBuffer.GetCString());
							}
						}
#endif // STRENGTH_IN_NUMBERS

						if (pAttacker->currentStrAdjperAttTotal() > 0)
						{
							iModifier = pAttacker->currentStrAdjperAttTotal();
							if (iModifier > 0)
							{
								szString.append(gDLL->getText("TXT_KEY_COLOR_POSITIVE"));
								szString.append(L' ');
								szString.append(NEWLINE);
								szString.append(gDLL->getText("TXT_KEY_COMBAT_RAMPAGE", iModifier));
							}
						}
						if (pAttacker->currentStrAdjperAttTotal() < 0)
						{
							iModifier = pAttacker->currentStrAdjperAttTotal();
							if (iModifier < 0)
							{
								szString.append(gDLL->getText("TXT_KEY_COLOR_NEGATIVE"));
								szString.append(L' ');
								szString.append(NEWLINE);
								szString.append(gDLL->getText("TXT_KEY_COMBAT_TIRES", iModifier));
							}
						}

						if (pAttacker->currentStrAdjperDefTotal() > 0)
						{
							iModifier = pAttacker->currentStrAdjperDefTotal();
							if (iModifier > 0)
							{
								szString.append(gDLL->getText("TXT_KEY_COLOR_POSITIVE"));
								szString.append(L' ');
								szString.append(NEWLINE);
								szString.append(gDLL->getText("TXT_KEY_COMBAT_DETERMINATION", iModifier));
							}
						}

						if (pAttacker->currentStrAdjperDefTotal() < 0)
						{
							iModifier = pAttacker->currentStrAdjperDefTotal();
							if (iModifier < 0)
							{
								szString.append(gDLL->getText("TXT_KEY_COLOR_NEGATIVE"));
								szString.append(L' ');
								szString.append(NEWLINE);
								szString.append(gDLL->getText("TXT_KEY_COMBAT_DEMORALIZATION", iModifier));
							}
						}
					}
					else if (!bTBView && getBugOptionBOOL("ACO__Enabled", true, "ACO_ENABLED")) // PieceOfMind - ADVANCED COMBAT ODDS - 3/11/09 - v2.0
					{
						szString.append(NEWLINE);

						//Change this to true when you need to spot errors, particular in the expected hit points calculations
						bool ACO_debug = getBugOptionBOOL("ACO__Debug", false, "ACO_DEBUG");

						/** phungus sart **/
						int iAttackerExperienceModifier = 0;
						int iDefenderExperienceModifier = 0;
						for (int ePromotion = 0; ePromotion < GC.getNumPromotionInfos(); ++ePromotion)
						{
							if (pAttacker->isHasPromotion((PromotionTypes)ePromotion) && GC.getPromotionInfo((PromotionTypes)ePromotion).getExperiencePercent() != 0)
							{
								iAttackerExperienceModifier += GC.getPromotionInfo((PromotionTypes)ePromotion).getExperiencePercent();
							}
						}

						for (int ePromotion = 0; ePromotion < GC.getNumPromotionInfos(); ++ePromotion)
						{
							if (pDefender->isHasPromotion((PromotionTypes)ePromotion) && GC.getPromotionInfo((PromotionTypes)ePromotion).getExperiencePercent() != 0)
							{
								iDefenderExperienceModifier += GC.getPromotionInfo((PromotionTypes)ePromotion).getExperiencePercent();
							}
						}
						/** phungus end **/ //thanks to phungus420



						/** Many thanks to DanF5771 for some of these calculations! **/
						//TB Combat Mods begin
						int iDefenderInitialOdds = ((GC.getCOMBAT_DIE_SIDES() * iDefenderStrength) / (iAttackerStrength + iDefenderStrength));
						int iDefenderHitOdds = std::max(5, iDefenderInitialOdds - ((iDefenderHitModifier * iDefenderInitialOdds) / 100));

						int iAttackerInitialOdds = GC.getCOMBAT_DIE_SIDES() - iDefenderInitialOdds;
						int iAttackerHitOdds = std::max(5, iAttackerInitialOdds - ((iAttackerHitModifier * iAttackerInitialOdds) / 100));

						int iDefenderOdds = ((iDefenderHitOdds - iAttackerHitOdds) + 1000) / 2;
						int iAttackerOdds = ((iAttackerHitOdds - iDefenderHitOdds) + 1000) / 2;
						//int iDefenderOdds = ((GC.getDefineINT("COMBAT_DIE_SIDES") * iDefenderStrength) / (iAttackerStrength + iDefenderStrength));
						//int iAttackerOdds = GC.getDefineINT("COMBAT_DIE_SIDES") - iDefenderOdds;
						//TB Combat Mods end

						// Barbarian related code.
						if (getBugOptionBOOL("ACO__IgnoreBarbFreeWins", false, "ACO_IGNORE_BARB_FREE_WINS"))//Are we not going to ignore barb free wins?  If not, skip this section...
						{
							if (pDefender->isHominid())
							{
								//defender is barbarian
								if (!GET_PLAYER(pAttacker->getOwner()).isHominid() && GET_PLAYER(pAttacker->getOwner()).getWinsVsBarbs() < GC.getHandicapInfo(GET_PLAYER(pAttacker->getOwner()).getHandicapType()).getFreeWinsVsBarbs())
								{
									//attacker is not barb and attacker player has free wins left
									//I have assumed in the following code only one of the units (attacker and defender) can be a barbarian
									iDefenderOdds = std::min((10 * GC.getCOMBAT_DIE_SIDES()) / 100, iDefenderOdds);
									iAttackerOdds = std::max((90 * GC.getCOMBAT_DIE_SIDES()) / 100, iAttackerOdds);
									szTempBuffer.Format(SETCOLR L"%d\n" ENDCOLR,
										TEXT_COLOR("COLOR_HIGHLIGHT_TEXT"), GC.getHandicapInfo(GET_PLAYER(pAttacker->getOwner()).getHandicapType()).getFreeWinsVsBarbs() - GET_PLAYER(pAttacker->getOwner()).getWinsVsBarbs());
									szString.append(gDLL->getText("TXT_ACO_BARBFREEWINSLEFT"));
									szString.append(szTempBuffer.GetCString());
								}
							}
							else if (pAttacker->isHominid())
							{
								//attacker is barbarian
								if (!GET_PLAYER(pDefender->getOwner()).isHominid() && GET_PLAYER(pDefender->getOwner()).getWinsVsBarbs() < GC.getHandicapInfo(GET_PLAYER(pDefender->getOwner()).getHandicapType()).getFreeWinsVsBarbs())
								{
									//defender is not barbarian and defender has free wins left and attacker is barbarian
									iAttackerOdds = std::min((10 * GC.getCOMBAT_DIE_SIDES()) / 100, iAttackerOdds);
									iDefenderOdds = std::max((90 * GC.getCOMBAT_DIE_SIDES()) / 100, iDefenderOdds);
									szTempBuffer.Format(SETCOLR L"%d\n" ENDCOLR,
										TEXT_COLOR("COLOR_HIGHLIGHT_TEXT"), GC.getHandicapInfo(GET_PLAYER(pDefender->getOwner()).getHandicapType()).getFreeWinsVsBarbs() - GET_PLAYER(pDefender->getOwner()).getWinsVsBarbs());
									szString.append(gDLL->getText("TXT_ACO_BARBFREEWINSLEFT"));
									szString.append(szTempBuffer.GetCString());
								}
							}
						}

						//XP calculations
						int iAttackerWithdrawalProbability = pAttacker->withdrawVSOpponentProbTotal(pDefender, pPlot) - pDefender->pursuitVSOpponentProbTotal(pAttacker);
						int iCombatLimitWithdrawalProbability = 100 - pDefender->pursuitVSOpponentProbTotal(pAttacker);
						int iWithdrawXP = pAttacker->getExperiencefromWithdrawal(iAttackerWithdrawalProbability) / 100; //thanks to phungus420

						int iExperience;
						if (pAttacker->combatLimit() < 100)
						{
							iExperience = pAttacker->getExperiencefromWithdrawal(iCombatLimitWithdrawalProbability) / 100;
						}
						else
						{
							iExperience = (pAttacker->attackXPValue() * iDefenderStrength) / iAttackerStrength;
							iExperience = range(iExperience, GC.getMIN_EXPERIENCE_PER_COMBAT(), GC.getMAX_EXPERIENCE_PER_COMBAT());
						}

						const int iDefExperienceKill =
						(
							range(
								pDefender->defenseXPValue() * iAttackerStrength / iDefenderStrength,
								GC.getMIN_EXPERIENCE_PER_COMBAT(),
								GC.getMAX_EXPERIENCE_PER_COMBAT()
							)
						);
						int iBonusAttackerXP = iExperience * iAttackerExperienceModifier / 100;
						int iBonusDefenderXP = iDefExperienceKill * iDefenderExperienceModifier / 100;
						int iBonusWithdrawXP = pAttacker->getExperiencefromWithdrawal(iAttackerWithdrawalProbability) * iAttackerExperienceModifier;

						// Toffer - Note: Doesn't take into account that some units ignore this limit.
						if (pDefender->isNPC())
						{
							const int iPotential =
							(
								(
									pDefender->isAnimal()
									?
									GC.getANIMAL_MAX_XP_VALUE()
									:
									GC.getBARBARIAN_MAX_XP_VALUE()
								)
								- pAttacker->getExperience()
							);
							if (iPotential > 0)
							{
								iExperience = range(iExperience, 0, iPotential);
								iWithdrawXP = range(iWithdrawXP, 0, iPotential);

								iBonusAttackerXP = range(iBonusAttackerXP, 0, std::max(0, iPotential - iExperience));
								iBonusWithdrawXP = range(iBonusWithdrawXP, 0, std::max(0, iPotential - iWithdrawXP));
							}
							else
							{
								iExperience = 0;
								iWithdrawXP = 0;
								iBonusAttackerXP = 0;
								iBonusWithdrawXP = 0;
							}
						}
						//int iNeededRoundsAttacker = (pDefender->getHP() - pDefender->getMaxHP() + pAttacker->combatLimit() - (((pAttacker->combatLimit())==pDefender->getMaxHP())?1:0))/iDamageToDefender + 1;
						//The extra term introduced here was to account for the incorrect way it treated units that had combatLimits.
						//A catapult that deals 25HP per round, and has a combatLimit of 75HP must deal four successful hits before it kills the warrior -not 3.  This is proved in the way CvUnit::resolvecombat works
						// The old formula (with just a plain -1 instead of a conditional -1 or 0) was incorrectly saying three.

						// int iNeededRoundsDefender = (pAttacker->getHP() + iDamageToAttacker - 1 ) / iDamageToAttacker;  //this is idential to the following line
						// int iNeededRoundsDefender = (pAttacker->getHP() - 1)/iDamageToAttacker + 1;

						//szTempBuffer.Format(L"iNeededRoundsAttacker = %d\niNeededRoundsDefender = %d",iNeededRoundsAttacker,iNeededRoundsDefender);
						//szString.append(NEWLINE);szString.append(szTempBuffer.GetCString());
						//szTempBuffer.Format(L"pDefender->getHP = %d\n-pDefender->getMaxHP = %d\n + pAttacker->combatLimit = %d\n - 1 if\npAttackercomBatlimit equals pDefender->getMaxHP\n=(%d == %d)\nall over iDamageToDefender = %d\n+1 = ...",
						//pDefender->getHP(),pDefender->getMaxHP(),pAttacker->combatLimit(),pAttacker->combatLimit(),pDefender->getMaxHP(),iDamageToDefender);
						//szString.append(NEWLINE);szString.append(szTempBuffer.GetCString());

						int iDefenderHitLimit = pDefender->getMaxHP() - pAttacker->combatLimit(pDefender);

						//NOW WE CALCULATE SOME INTERESTING STUFF :)

						float E_HP_Att = 0.0f;//expected damage dealt to attacker
						float E_HP_Def = 0.0f;
						float E_HP_Att_Withdraw; //Expected hitpoints for attacker if attacker withdraws (not the same as retreat)
						float E_HP_Att_Victory; //Expected hitpoints for attacker if attacker kills defender
						int E_HP_Att_Retreat = (pAttacker->getHP()) - (iNeededRoundsDefender - 1) * iDamageToAttacker;//this one is predetermined easily
						float E_HP_Def_Withdraw;
						float E_HP_Def_Defeat; // if attacker dies
						//Note E_HP_Def is the same for if the attacker withdraws or dies

						float AttackerUnharmed;
						float DefenderUnharmed;

						AttackerUnharmed = getCombatOddsSpecific(pAttacker, pDefender, 0, iNeededRoundsAttacker);
						DefenderUnharmed = getCombatOddsSpecific(pAttacker, pDefender, iNeededRoundsDefender, 0);
						DefenderUnharmed += getCombatOddsSpecific(pAttacker, pDefender, iNeededRoundsDefender - 1, 0);//attacker withdraws or retreats

						float prob_bottom_Att_HP; // The probability the attacker exits combat with min HP
						float prob_bottom_Def_HP; // The probability the defender exits combat with min HP

						if (ACO_debug)
						{
							szTempBuffer.Format(L"E[HP ATTACKER]");
							//szString.append(NEWLINE);
							szString.append(szTempBuffer.GetCString());
						}
						// already covers both possibility of defender not being killed AND being killed
						for (int n_A = 0; n_A < iNeededRoundsDefender; n_A++)
						{
							//prob_attack[n_A] = getCombatOddsSpecific(pAttacker,pDefender,n_A,iNeededRoundsAttacker);
							E_HP_Att += ((pAttacker->getHP()) - n_A * iDamageToAttacker) * getCombatOddsSpecific(pAttacker, pDefender, n_A, iNeededRoundsAttacker);

							if (ACO_debug)
							{
								szTempBuffer.Format(L"+%d * %.2f%%  (Def %d) (%d:%d)",
									((pAttacker->getHP()) - n_A * iDamageToAttacker), 100.0f * getCombatOddsSpecific(pAttacker, pDefender, n_A, iNeededRoundsAttacker), iDefenderHitLimit, n_A, iNeededRoundsAttacker);
								szString.append(NEWLINE);
								szString.append(szTempBuffer.GetCString());
							}
						}
						E_HP_Att_Victory = E_HP_Att;//NOT YET NORMALISED
						E_HP_Att_Withdraw = E_HP_Att;//NOT YET NORMALIZED
						prob_bottom_Att_HP = getCombatOddsSpecific(pAttacker, pDefender, iNeededRoundsDefender - 1, iNeededRoundsAttacker);
						if ((pAttacker->withdrawVSOpponentProbTotal(pDefender, pPlot) - pDefender->pursuitVSOpponentProbTotal(pAttacker)) > 0)
						{
							// if withdraw odds involved
							if (ACO_debug)
							{
								szTempBuffer.Format(L"Attacker retreat odds");
								szString.append(NEWLINE);
								szString.append(szTempBuffer.GetCString());
							}
							for (int n_D = 0; n_D < iNeededRoundsAttacker; n_D++)
							{
								E_HP_Att += ((pAttacker->getHP()) - (iNeededRoundsDefender - 1) * iDamageToAttacker) * getCombatOddsSpecific(pAttacker, pDefender, iNeededRoundsDefender - 1, n_D);
								prob_bottom_Att_HP += getCombatOddsSpecific(pAttacker, pDefender, iNeededRoundsDefender - 1, n_D);
								if (ACO_debug)
								{
									szTempBuffer.Format(L"+%d * %.2f%%  (Def %d) (%d:%d)",
										((pAttacker->getHP()) - (iNeededRoundsDefender - 1) * iDamageToAttacker), 100.0f * getCombatOddsSpecific(pAttacker, pDefender, iNeededRoundsDefender - 1, n_D), (pDefender->getHP()) - n_D * iDamageToDefender, iNeededRoundsDefender - 1, n_D);
									szString.append(NEWLINE);
									szString.append(szTempBuffer.GetCString());
								}
							}
						}
						// finished with the attacker HP I think.

						if (ACO_debug)
						{
							szTempBuffer.Format(L"E[HP DEFENDER]\nOdds that attacker dies or retreats");
							szString.append(NEWLINE);
							szString.append(szTempBuffer.GetCString());
						}
						for (int n_D = 0; n_D < iNeededRoundsAttacker; n_D++)
						{
							//prob_defend[n_D] = getCombatOddsSpecific(pAttacker,pDefender,iNeededRoundsDefender,n_D);//attacker dies
							//prob_defend[n_D] += getCombatOddsSpecific(pAttacker,pDefender,iNeededRoundsDefender-1,n_D);//attacker retreats
							E_HP_Def += ((pDefender->getHP()) - n_D * iDamageToDefender) * (getCombatOddsSpecific(pAttacker, pDefender, iNeededRoundsDefender, n_D) + getCombatOddsSpecific(pAttacker, pDefender, iNeededRoundsDefender - 1, n_D));
							if (ACO_debug)
							{
								szTempBuffer.Format(L"+%d * %.2f%%  (Att 0 or %d) (%d:%d)",
									((pDefender->getHP()) - n_D * iDamageToDefender), 100.0f * (getCombatOddsSpecific(pAttacker, pDefender, iNeededRoundsDefender, n_D) + getCombatOddsSpecific(pAttacker, pDefender, iNeededRoundsDefender - 1, n_D)), (pAttacker->getHP()) - (iNeededRoundsDefender - 1) * iDamageToAttacker, iNeededRoundsDefender, n_D);
								szString.append(NEWLINE);
								szString.append(szTempBuffer.GetCString());
							}
						}
						prob_bottom_Def_HP = getCombatOddsSpecific(pAttacker, pDefender, iNeededRoundsDefender, iNeededRoundsAttacker - 1);
						//prob_bottom_Def_HP += getCombatOddsSpecific(pAttacker,pDefender,iNeededRoundsDefender-1,iNeededRoundsAttacker-1);
						E_HP_Def_Defeat = E_HP_Def;
						E_HP_Def_Withdraw = 0.0f;

						if (pAttacker->combatLimit(pDefender) < (pDefender->getMaxHP()))//if attacker has a combatLimit (eg. catapult)
						{
							if (pAttacker->combatLimit(pDefender) == iDamageToDefender * (iNeededRoundsAttacker - 1))
							{
								//Then we have an odd situation because the last successful hit by an attacker will do 0 damage, and doing either iNeededRoundsAttacker or iNeededRoundsAttacker-1 will cause the same damage
								if (ACO_debug)
								{
									szTempBuffer.Format(L"Odds that attacker withdraws at combatLimit (abnormal)");
									szString.append(NEWLINE);
									szString.append(szTempBuffer.GetCString());
								}
								for (int n_A = 0; n_A < iNeededRoundsDefender; n_A++)
								{
									//prob_defend[iNeededRoundsAttacker-1] += getCombatOddsSpecific(pAttacker,pDefender,n_A,iNeededRoundsAttacker);//this is the defender at the combatLimit
									E_HP_Def += (float)iDefenderHitLimit * getCombatOddsSpecific(pAttacker, pDefender, n_A, iNeededRoundsAttacker);
									//should be the same as
									//E_HP_Def += ( (pDefender->getHP()) - (iNeededRoundsAttacker-1)*iDamageToDefender) * getCombatOddsSpecific(pAttacker,pDefender,n_A,iNeededRoundsAttacker);
									E_HP_Def_Withdraw += (float)iDefenderHitLimit * getCombatOddsSpecific(pAttacker, pDefender, n_A, iNeededRoundsAttacker);
									prob_bottom_Def_HP += getCombatOddsSpecific(pAttacker, pDefender, n_A, iNeededRoundsAttacker);
									if (ACO_debug)
									{
										szTempBuffer.Format(L"+%d * %.2f%%  (Att %d) (%d:%d)",
											iDefenderHitLimit, 100.0f * getCombatOddsSpecific(pAttacker, pDefender, n_A, iNeededRoundsAttacker), 100 - n_A * iDamageToAttacker, n_A, iNeededRoundsAttacker);
										szString.append(NEWLINE);
										szString.append(szTempBuffer.GetCString());
									}
								}
							}
							else // normal situation
							{
								if (ACO_debug)
								{
									szTempBuffer.Format(L"Odds that attacker withdraws at combatLimit (normal)", pAttacker->combatLimit(pDefender));
									szString.append(NEWLINE);
									szString.append(szTempBuffer.GetCString());
								}

								for (int n_A = 0; n_A < iNeededRoundsDefender; n_A++)
								{

									E_HP_Def += (float)iDefenderHitLimit * getCombatOddsSpecific(pAttacker, pDefender, n_A, iNeededRoundsAttacker);
									E_HP_Def_Withdraw += (float)iDefenderHitLimit * getCombatOddsSpecific(pAttacker, pDefender, n_A, iNeededRoundsAttacker);
									prob_bottom_Def_HP += getCombatOddsSpecific(pAttacker, pDefender, n_A, iNeededRoundsAttacker);
									if (ACO_debug)
									{
										szTempBuffer.Format(L"+%d * %.2f%%  (Att %d) (%d:%d)",
											iDefenderHitLimit, 100.0f * getCombatOddsSpecific(pAttacker, pDefender, n_A, iNeededRoundsAttacker), GC.getMAX_HIT_POINTS() - n_A * iDamageToAttacker, n_A, iNeededRoundsAttacker);
										szString.append(NEWLINE);
										szString.append(szTempBuffer.GetCString());
									}
								}//for
							}//else
						}
						if (ACO_debug)
						{
							szString.append(NEWLINE);
						}

						float Scaling_Factor = 1.6f;//how many pixels per 1% of odds

						float AttackerKillOdds = 0.0f;
						float PullOutOdds = 0.0f;//Withdraw odds
						float RetreatOdds = 0.0f;
						float DefenderKillOdds = 0.0f;

						float CombatRatio = ((float)(pAttacker->currCombatStr(NULL, NULL))) / ((float)(pDefender->currCombatStr(pPlot, pAttacker)));
						// THE ALL-IMPORTANT COMBATRATIO

						float AttXP = (pAttacker->attackXPValue()) / CombatRatio;
						float DefXP = (pDefender->defenseXPValue()) * CombatRatio;// These two values are simply for the Unrounded XP display

						// General odds
						if (pAttacker->combatLimit(pDefender) >= pDefender->getMaxHP()) //ie. we can kill the defender... I hope this is the most general form
						{
							//float AttackerKillOdds = 0.0f;
							for (int n_A = 0; n_A < iNeededRoundsDefender; n_A++)
							{
								AttackerKillOdds += getCombatOddsSpecific(pAttacker, pDefender, n_A, iNeededRoundsAttacker);
							}//for
						}
						else
						{
							// else we cannot kill the defender (eg. catapults attacking)
							for (int n_A = 0; n_A < iNeededRoundsDefender; n_A++)
							{
								PullOutOdds += getCombatOddsSpecific(pAttacker, pDefender, n_A, iNeededRoundsAttacker);
							}//for
						}
						//TB Combat Mods - next line adjusted for pursuit
						if ((pAttacker->withdrawVSOpponentProbTotal(pDefender, pPlot) - pDefender->pursuitVSOpponentProbTotal(pAttacker)) > 0)
						{
							for (int n_D = 0; n_D < iNeededRoundsAttacker; n_D++)
							{
								RetreatOdds += getCombatOddsSpecific(pAttacker, pDefender, iNeededRoundsDefender - 1, n_D);
							}//for
						}
						for (int n_D = 0; n_D < iNeededRoundsAttacker; n_D++)
						{
							DefenderKillOdds += getCombatOddsSpecific(pAttacker, pDefender, iNeededRoundsDefender, n_D);
						}//for
						//DefenderKillOdds = 1.0f - (AttackerKillOdds + RetreatOdds + PullOutOdds);//this gives slight negative numbers sometimes, I think



						if (iView & getBugOptionINT("ACO__ShowSurvivalOdds", 3, "ACO_SHOW_SURVIVAL_ODDS"))
						{
							szTempBuffer.Format(L"%.2f%%", 100.0f * (AttackerKillOdds + RetreatOdds + PullOutOdds));
							szTempBuffer2.Format(L"%.2f%%", 100.0f * (RetreatOdds + PullOutOdds + DefenderKillOdds));
							szString.append(gDLL->getText("TXT_ACO_SURVIVALODDS"));
							szString.append(NEWLINE);
							szString.append(gDLL->getText("TXT_ACO_VS", szTempBuffer.GetCString(), szTempBuffer2.GetCString()));
							szString.append(NEWLINE);
						}
						//TB Combat Mods - next line adjusted for pursuit
						if ((pAttacker->withdrawVSOpponentProbTotal(pDefender, pPlot) - pDefender->pursuitVSOpponentProbTotal(pAttacker)) >= 100)
						{
							// a rare situation indeed (TB - not so unlikely now that withdrawal has become unlimited, held in check by pursuit

							szString.append(NEWLINE);
							szString.append(gDLL->getText("TXT_ACO_SURVIVALGUARANTEED"));
						}

						//CvWString szTempBuffer2; // moved to elsewhere in the code (earlier)
						//CvWString szBuffer; // duplicate

						float prob1 = 100.0f * (AttackerKillOdds + PullOutOdds);//up to win odds
						float prob2 = prob1 + 100.0f * RetreatOdds;//up to retreat odds

						int pixels_left = 199;// 1 less than 200 to account for right end bar
						int pixels;
						int fullBlocks;
						int lastBlock;

						pixels = (2 * ((int)(prob1 + 0.5))) - 1;  // 1% per pixel // subtracting one to account for left end bar
						fullBlocks = pixels / 10;
						lastBlock = pixels % 10;

						szString.append(L"<img=Art/ACO/green_bar_left_end.dds>");
						for (int i = 0; i < fullBlocks; ++i)
						{
							szString.append(L"<img=Art/ACO/green_bar_10.dds>");
							pixels_left -= 10;
						}
						if (lastBlock > 0)
						{
							szTempBuffer2.Format(L"<img=Art/ACO/green_bar_%d.dds>", lastBlock);
							szString.append(szTempBuffer2);
							pixels_left -= lastBlock;
						}


						pixels = 2 * ((int)(prob2 + 0.5)) - (pixels + 1);//the number up to the next one...
						fullBlocks = pixels / 10;
						lastBlock = pixels % 10;
						for (int i = 0; i < fullBlocks; ++i)
						{
							szString.append(L"<img=Art/ACO/yellow_bar_10.dds>");
							pixels_left -= 10;
						}
						if (lastBlock > 0)
						{
							szTempBuffer2.Format(L"<img=Art/ACO/yellow_bar_%d.dds>", lastBlock);
							szString.append(szTempBuffer2);
							pixels_left -= lastBlock;
						}

						fullBlocks = pixels_left / 10;
						lastBlock = pixels_left % 10;
						for (int i = 0; i < fullBlocks; ++i)
						{
							szString.append(L"<img=Art/ACO/red_bar_10.dds>");
						}
						if (lastBlock > 0)
						{
							szTempBuffer2.Format(L"<img=Art/ACO/red_bar_%d.dds>", lastBlock);
							szString.append(szTempBuffer2);
						}

						szString.append(L"<img=Art/ACO/red_bar_right_end.dds> ");


						szString.append(NEWLINE);
						if (pAttacker->combatLimit(pDefender) >= pDefender->getMaxHP())
						{
							szTempBuffer.Format(L": " SETCOLR L"%.2f%% " L"%d" ENDCOLR,
								TEXT_COLOR("COLOR_POSITIVE_TEXT"), 100.0f * AttackerKillOdds, iExperience);
							szString.append(gDLL->getText("TXT_ACO_VICTORY"));
							szString.append(szTempBuffer.GetCString());
							if (iAttackerExperienceModifier > 0)
							{
								szTempBuffer.Format(SETCOLR L"+%d" ENDCOLR, TEXT_COLOR("COLOR_HIGHLIGHT_TEXT"), iBonusAttackerXP);
								szString.append(szTempBuffer.GetCString());
							}

							szString.append(gDLL->getText("TXT_KEY_COLOR_POSITIVE"));
							szString.append(gDLL->getText("TXT_ACO_XP"));
							szString.append(gDLL->getText("TXT_KEY_COLOR_REVERT"));
							szString.append("  (");
							szString.append(gDLL->getText("TXT_KEY_COLOR_POSITIVE"));
							szTempBuffer.Format(L"%.1f",
								E_HP_Att_Victory / AttackerKillOdds);
							szString.append(szTempBuffer.GetCString());
							szString.append(gDLL->getText("TXT_ACO_HP"));
							szString.append(gDLL->getText("TXT_KEY_COLOR_REVERT"));
						}
						else
						{
							const int iWithdr = pAttacker->withdrawVSOpponentProbTotal(pDefender, pPlot) - pDefender->pursuitVSOpponentProbTotal(pAttacker);
							szTempBuffer.Format(
								L": " SETCOLR L"%.2f%% " L"%.2f" ENDCOLR,
								TEXT_COLOR("COLOR_POSITIVE_TEXT"), 100.0f * PullOutOdds,
								pAttacker->getExperiencefromWithdrawal(iWithdr) / 100.0f
							);
							//iExperience,TEXT_COLOR("COLOR_POSITIVE_TEXT"), E_HP_Att_Victory/AttackerKillOdds);
							szString.append(gDLL->getText("TXT_ACO_WITHDRAW"));
							szString.append(szTempBuffer.GetCString());
							if (iAttackerExperienceModifier > 0)
							{
								szTempBuffer.Format(SETCOLR L"+%d" ENDCOLR, TEXT_COLOR("COLOR_HIGHLIGHT_TEXT"), iBonusWithdrawXP);
								szString.append(szTempBuffer.GetCString());
							}

							szString.append(gDLL->getText("TXT_KEY_COLOR_POSITIVE"));
							szString.append(gDLL->getText("TXT_ACO_XP"));
							szString.append(gDLL->getText("TXT_KEY_COLOR_REVERT"));
							szString.append("  (");
							szString.append(gDLL->getText("TXT_KEY_COLOR_POSITIVE"));
							szTempBuffer.Format(L"%.1f", E_HP_Att_Withdraw / PullOutOdds);
							szString.append(szTempBuffer.GetCString());
							szString.append(gDLL->getText("TXT_ACO_HP"));
							szString.append(gDLL->getText("TXT_KEY_COLOR_REVERT"));
							szString.append(",");
							szString.append(gDLL->getText("TXT_KEY_COLOR_NEGATIVE"));
							szTempBuffer.Format(L"%d", iDefenderHitLimit);
							szString.append(szTempBuffer.GetCString());
							szString.append(gDLL->getText("TXT_ACO_HP"));
							szString.append(gDLL->getText("TXT_KEY_COLOR_REVERT"));
						}
						szString.append(")");

						if (iDefenderOdds == 0)
						{
							szString.append(gDLL->getText("TXT_ACO_GUARANTEEDNODEFENDERHIT"));
							DefenderKillOdds = 0.0f;
						}
						//TB Combat Mods - next line adjusted for pursuit
						if ((pAttacker->withdrawVSOpponentProbTotal(pDefender, pPlot) - pDefender->pursuitVSOpponentProbTotal(pAttacker)) > 0)//if there are retreat odds
						{
							int iWithdr = pAttacker->withdrawVSOpponentProbTotal(pDefender, pPlot) - pDefender->pursuitVSOpponentProbTotal(pAttacker);
							szString.append(NEWLINE);
							szTempBuffer.Format(
								L": " SETCOLR L"%.2f%% " ENDCOLR SETCOLR L"%.2f" ENDCOLR,
								TEXT_COLOR("COLOR_UNIT_TEXT"), 100.0f * RetreatOdds, TEXT_COLOR("COLOR_POSITIVE_TEXT"),
								pAttacker->getExperiencefromWithdrawal(iWithdr) / 100.0f
							);
							szString.append(gDLL->getText("TXT_ACO_RETREAT"));
							szString.append(szTempBuffer.GetCString());
							if (iAttackerExperienceModifier > 0)
							{
								szTempBuffer.Format(SETCOLR L"+%d" ENDCOLR, TEXT_COLOR("COLOR_HIGHLIGHT_TEXT"), iBonusWithdrawXP);
								szString.append(szTempBuffer.GetCString());
							}
							szString.append(gDLL->getText("TXT_KEY_COLOR_POSITIVE"));
							szString.append(gDLL->getText("TXT_ACO_XP"));
							szString.append(gDLL->getText("TXT_KEY_COLOR_REVERT"));
							szString.append("  (");
							szTempBuffer.Format(SETCOLR L"%d" ENDCOLR,
								TEXT_COLOR("COLOR_UNIT_TEXT"), E_HP_Att_Retreat);
							szString.append(szTempBuffer.GetCString());
							szString.append(gDLL->getText("TXT_ACO_HP_NEUTRAL"));
							szString.append(")");
							//szString.append(gDLL->getText("TXT_KEY_COLOR_REVERT"));
						}

						szString.append(NEWLINE);
						szTempBuffer.Format(L": " SETCOLR L"%.2f%% " L"%d" ENDCOLR, TEXT_COLOR("COLOR_NEGATIVE_TEXT"), 100.0f * DefenderKillOdds, iDefExperienceKill);
						szString.append(gDLL->getText("TXT_ACO_DEFEAT"));
						szString.append(szTempBuffer.GetCString());
						if (iDefenderExperienceModifier > 0)
						{
							szTempBuffer.Format(SETCOLR L"+%d" ENDCOLR, TEXT_COLOR("COLOR_HIGHLIGHT_TEXT"), iBonusDefenderXP);
							szString.append(szTempBuffer.GetCString());
						}
						szString.append(gDLL->getText("TXT_KEY_COLOR_NEGATIVE"));
						szString.append(gDLL->getText("TXT_ACO_XP"));
						szString.append(gDLL->getText("TXT_KEY_COLOR_REVERT"));
						szString.append("  (");
						szString.append(gDLL->getText("TXT_KEY_COLOR_NEGATIVE"));
						szTempBuffer.Format(L"%.1f",
							(iDefenderOdds != 0 ? E_HP_Def_Defeat / (RetreatOdds + DefenderKillOdds) : 0.0));
						szString.append(szTempBuffer.GetCString());
						szString.append(gDLL->getText("TXT_ACO_HP"));
						szString.append(gDLL->getText("TXT_KEY_COLOR_REVERT"));
						szString.append(")");


						float HP_percent_cutoff = 0.5f; // Probabilities lower than this (in percent) will not be shown individually for the HP detail section.
						if (!getBugOptionBOOL("ACO__MergeShortBars", true, "ACO_MERGE_SHORT_BARS"))
						{
							HP_percent_cutoff = 0.0f;
						}
						int first_combined_HP_Att = 0;
						int first_combined_HP_Def = 0;
						int last_combined_HP;
						float combined_HP_sum = 0.0f;
						BOOL bIsCondensed = false;



						//START ATTACKER DETAIL HP HERE
						// Individual bars for each attacker HP outcome.
						if (iView & getBugOptionINT("ACO__ShowAttackerHealthBars", 2, "ACO_SHOW_ATTACKER_HEALTH_BARS"))
						{
							for (int n_A = 0; n_A < iNeededRoundsDefender - 1; n_A++)
							{
								float prob = 100.0f * getCombatOddsSpecific(pAttacker, pDefender, n_A, iNeededRoundsAttacker);
								if (prob > HP_percent_cutoff || n_A == 0)
								{
									if (bIsCondensed) // then we need to print the prev ones
									{
										int pixels = (int)(Scaling_Factor * combined_HP_sum + 0.5);  // 1% per pixel
										int fullBlocks = (pixels) / 10;
										int lastBlock = (pixels) % 10;
										//if(pixels>=2) {szString.append(L"<img=Art/ACO/green_bar_left_end.dds>");}
										szString.append(NEWLINE);
										szString.append(L"<img=Art/ACO/green_bar_left_end.dds>");
										for (int iI = 0; iI < fullBlocks; ++iI)
										{
											szString.append(L"<img=Art/ACO/green_bar_10.dds>");
										}
										if (lastBlock > 0)
										{
											szTempBuffer2.Format(L"<img=Art/ACO/green_bar_%d.dds>", lastBlock);
											szString.append(szTempBuffer2);
										}
										szString.append(L"<img=Art/ACO/green_bar_right_end.dds>");
										szString.append(L" ");

										szString.append(gDLL->getText("TXT_KEY_COLOR_POSITIVE"));
										if (last_combined_HP != first_combined_HP_Att)
										{
											szTempBuffer.Format(L"%d", last_combined_HP);
											szString.append(szTempBuffer.GetCString());
											szString.append(gDLL->getText("TXT_ACO_HP"));
											szString.append(gDLL->getText("-"));
										}

										szTempBuffer.Format(L"%d", first_combined_HP_Att);
										szString.append(szTempBuffer.GetCString());
										szString.append(gDLL->getText("TXT_ACO_HP"));
										szString.append(gDLL->getText("TXT_KEY_COLOR_REVERT"));
										szTempBuffer.Format(L" %.2f%%", combined_HP_sum);
										szString.append(szTempBuffer.GetCString());

										bIsCondensed = false;//resetting
										combined_HP_sum = 0.0f;//resetting this variable
										last_combined_HP = 0;
									}

									szString.append(NEWLINE);
									int pixels = (int)(Scaling_Factor * prob + 0.5);  // 1% per pixel
									int fullBlocks = (pixels) / 10;
									int lastBlock = (pixels) % 10;
									szString.append(L"<img=Art/ACO/green_bar_left_end.dds>");
									for (int iI = 0; iI < fullBlocks; ++iI)
									{
										szString.append(L"<img=Art/ACO/green_bar_10.dds>");
									}
									if (lastBlock > 0)
									{
										szTempBuffer2.Format(L"<img=Art/ACO/green_bar_%d.dds>", lastBlock);
										szString.append(szTempBuffer2);
									}
									szString.append(L"<img=Art/ACO/green_bar_right_end.dds>");
									szString.append(L" ");

									szString.append(gDLL->getText("TXT_KEY_COLOR_POSITIVE"));
									szTempBuffer.Format(L"%d",
										((pAttacker->getHP()) - n_A * iDamageToAttacker));
									szString.append(szTempBuffer.GetCString());
									szString.append(gDLL->getText("TXT_ACO_HP"));
									szString.append(gDLL->getText("TXT_KEY_COLOR_REVERT"));
									szTempBuffer.Format(L" %.2f%%",
										prob);
									szString.append(szTempBuffer.GetCString());
								}
								else // we add to the condensed list
								{
									bIsCondensed = true;
									first_combined_HP_Att = std::max(first_combined_HP_Att, ((pAttacker->getHP()) - n_A * iDamageToAttacker));
									last_combined_HP = ((pAttacker->getHP()) - n_A * iDamageToAttacker);
									combined_HP_sum += prob;
								}
							}

							if (bIsCondensed) // then we need to print the prev ones
							{
								szString.append(NEWLINE);
								int pixels = (int)(Scaling_Factor * combined_HP_sum + 0.5);  // 1% per pixel
								int fullBlocks = (pixels) / 10;
								int lastBlock = (pixels) % 10;

								szString.append(L"<img=Art/ACO/green_bar_left_end.dds>");
								for (int iI = 0; iI < fullBlocks; ++iI)
								{
									szString.append(L"<img=Art/ACO/green_bar_10.dds>");
								}
								if (lastBlock > 0)
								{
									szTempBuffer2.Format(L"<img=Art/ACO/green_bar_%d.dds>", lastBlock);
									szString.append(szTempBuffer2);
								}

								szString.append(L"<img=Art/ACO/green_bar_right_end.dds>");
								szString.append(L" ");

								szString.append(gDLL->getText("TXT_KEY_COLOR_POSITIVE"));
								if (last_combined_HP != first_combined_HP_Att)
								{
									szTempBuffer.Format(L"%d", last_combined_HP);
									szString.append(szTempBuffer.GetCString());
									szString.append(gDLL->getText("TXT_ACO_HP"));
									szString.append(gDLL->getText("-"));
								}
								szTempBuffer.Format(L"%d", first_combined_HP_Att);
								szString.append(szTempBuffer.GetCString());
								szString.append(gDLL->getText("TXT_ACO_HP"));
								szString.append(gDLL->getText("TXT_KEY_COLOR_REVERT"));
								szTempBuffer.Format(L" %.2f%%", combined_HP_sum);
								szString.append(szTempBuffer.GetCString());

								bIsCondensed = false;//resetting
								combined_HP_sum = 0.0f;//resetting this variable
								last_combined_HP = 0;
							}
							// At the moment I am not allowing the lowest Attacker HP value to be condensed, as it would be confusing if it includes retreat odds
							// I may include this in the future though, but probably only if retreat odds are zero.

							float prob_victory = 100.0f * getCombatOddsSpecific(pAttacker, pDefender, iNeededRoundsDefender - 1, iNeededRoundsAttacker);
							float prob_retreat = 100.0f * RetreatOdds;

							szString.append(NEWLINE);
							int green_pixels = (int)(Scaling_Factor * prob_victory + 0.5);
							int yellow_pixels = (int)(Scaling_Factor * (prob_retreat + prob_victory) + 0.5) - green_pixels;//makes the total length of the bar more accurate - more important than the length of the pieces
							green_pixels += 1;//we put an extra 2 on every one of the bar pixel counts
							if (yellow_pixels >= 1)
							{
								yellow_pixels += 1;
							}
							else
							{
								green_pixels += 1;
							}
							szString.append(L"<img=Art/ACO/green_bar_left_end.dds>");
							green_pixels--;

							green_pixels--;//subtracting off the right end
							int fullBlocks = green_pixels / 10;
							int lastBlock = green_pixels % 10;
							for (int iI = 0; iI < fullBlocks; ++iI)
							{
								szString.append(L"<img=Art/ACO/green_bar_10.dds>");
							}//for
							if (lastBlock > 0)
							{
								szTempBuffer2.Format(L"<img=Art/ACO/green_bar_%d.dds>", lastBlock);
								szString.append(szTempBuffer2);
							}//if
							if (yellow_pixels >= 1)// then there will at least be a right end yellow pixel
							{
								yellow_pixels--;//subtracting off right end
								fullBlocks = yellow_pixels / 10;
								lastBlock = yellow_pixels % 10;
								for (int iI = 0; iI < fullBlocks; ++iI)
								{
									szString.append(L"<img=Art/ACO/yellow_bar_10.dds>");
								}//for
								if (lastBlock > 0)
								{
									szTempBuffer2.Format(L"<img=Art/ACO/yellow_bar_%d.dds>", lastBlock);
									szString.append(szTempBuffer2);
								}
								szString.append(L"<img=Art/ACO/yellow_bar_right_end.dds>");
								//finished
							}
							else
							{
								szString.append(L"<img=Art/ACO/green_bar_right_end.dds>");
								//finished
							}//else if

							szString.append(L" ");
							szString.append(gDLL->getText("TXT_KEY_COLOR_POSITIVE"));
							szTempBuffer.Format(L"%d", ((pAttacker->getHP()) - (iNeededRoundsDefender - 1) * iDamageToAttacker));
							szString.append(szTempBuffer.GetCString());
							szString.append(gDLL->getText("TXT_ACO_HP"));
							szString.append(gDLL->getText("TXT_KEY_COLOR_REVERT"));
							szTempBuffer.Format(L" %.2f%%", prob_victory + prob_retreat);
							szString.append(szTempBuffer.GetCString());
						}
						//END ATTACKER DETAIL HP HERE



						//START DEFENDER DETAIL HP HERE
						first_combined_HP_Def = pDefender->getHP();
						if (iView & getBugOptionINT("ACO__ShowDefenderHealthBars", 2, "ACO_SHOW_DEFENDER_HEALTH_BARS"))
						{
							float prob = 0.0f;
							int def_HP;
							for (int n_D = iNeededRoundsAttacker; n_D >= 1; n_D--)//
							{
								if (pAttacker->combatLimit(pDefender) >= pDefender->getMaxHP())// a unit with a combat limit
								{
									if (n_D == iNeededRoundsAttacker)
									{
										n_D--;//we don't need to do HP for when the unit is dead.
									}
								}

								def_HP = std::max((pDefender->getHP()) - n_D * iDamageToDefender, (pDefender->getMaxHP() - pAttacker->combatLimit(pDefender)));

								if ((pDefender->getMaxHP() - pAttacker->combatLimit(pDefender)) == pDefender->getHP() - (n_D - 1) * iDamageToDefender)
								{
									// if abnormal
									if (n_D == iNeededRoundsAttacker)
									{
										n_D--;
										def_HP = (pDefender->getMaxHP() - pAttacker->combatLimit(pDefender));
										prob += 100.0f * PullOutOdds;
										prob += 100.0f * (getCombatOddsSpecific(pAttacker, pDefender, iNeededRoundsDefender, n_D) + (getCombatOddsSpecific(pAttacker, pDefender, iNeededRoundsDefender - 1, n_D)));
									}
								}
								else
								{
									//not abnormal
									if (n_D == iNeededRoundsAttacker)
									{
										prob += 100.0f * PullOutOdds;
									}
									else
									{
										prob += 100.0f * (getCombatOddsSpecific(pAttacker, pDefender, iNeededRoundsDefender, n_D) + (getCombatOddsSpecific(pAttacker, pDefender, iNeededRoundsDefender - 1, n_D)));
									}
								}

								if (prob > HP_percent_cutoff || (pAttacker->combatLimit(pDefender) < pDefender->getMaxHP() && (n_D == iNeededRoundsAttacker)))
								{
									if (bIsCondensed) // then we need to print the prev ones
									{
										szString.append(NEWLINE);

										int pixels = (int)(Scaling_Factor * combined_HP_sum + 0.5);  // 1% per pixel
										int fullBlocks = (pixels) / 10;
										int lastBlock = (pixels) % 10;
										szString.append(L"<img=Art/ACO/red_bar_left_end.dds>");
										for (int iI = 0; iI < fullBlocks; ++iI)
										{
											szString.append(L"<img=Art/ACO/red_bar_10.dds>");
										}
										if (lastBlock > 0)
										{
											szTempBuffer2.Format(L"<img=Art/ACO/red_bar_%d.dds>", lastBlock);
											szString.append(szTempBuffer2);
										}
										szString.append(L"<img=Art/ACO/red_bar_right_end.dds>");
										szString.append(L" ");
										szString.append(gDLL->getText("TXT_KEY_COLOR_NEGATIVE"));
										szTempBuffer.Format(L"%dHP", first_combined_HP_Def);
										szString.append(szTempBuffer.GetCString());
										szString.append(gDLL->getText("TXT_ACO_HP"));
										if (first_combined_HP_Def != last_combined_HP)
										{
											szString.append("-");
											szTempBuffer.Format(L"%d", last_combined_HP);
											szString.append(szTempBuffer.GetCString());
											szString.append(gDLL->getText("TXT_ACO_HP"));
										}
										szString.append(gDLL->getText("TXT_KEY_COLOR_REVERT"));
										szTempBuffer.Format(L" %.2f%%",
											combined_HP_sum);
										szString.append(szTempBuffer.GetCString());

										bIsCondensed = false;//resetting
										combined_HP_sum = 0.0f;//resetting this variable
									}

									szString.append(NEWLINE);
									int pixels = (int)(Scaling_Factor * prob + 0.5);  // 1% per pixel
									int fullBlocks = (pixels) / 10;
									int lastBlock = (pixels) % 10;
									//if(pixels>=2) // this is now guaranteed by the way we define number of pixels
									//{
									szString.append(L"<img=Art/ACO/red_bar_left_end.dds>");
									for (int iI = 0; iI < fullBlocks; ++iI)
									{
										szString.append(L"<img=Art/ACO/red_bar_10.dds>");
									}
									if (lastBlock > 0)
									{
										szTempBuffer2.Format(L"<img=Art/ACO/red_bar_%d.dds>", lastBlock);
										szString.append(szTempBuffer2);
									}
									szString.append(L"<img=Art/ACO/red_bar_right_end.dds>");
									//}
									szString.append(L" ");

									szTempBuffer.Format(SETCOLR L"%d" ENDCOLR,
										TEXT_COLOR("COLOR_NEGATIVE_TEXT"), def_HP);
									szString.append(szTempBuffer.GetCString());
									szString.append(gDLL->getText("TXT_KEY_COLOR_NEGATIVE"));
									szString.append(gDLL->getText("TXT_ACO_HP"));
									szString.append(gDLL->getText("TXT_KEY_COLOR_REVERT"));
									szTempBuffer.Format(L" %.2f%%", prob);
									szString.append(szTempBuffer.GetCString());
								}
								else
								{
									bIsCondensed = true;
									first_combined_HP_Def = (std::min(first_combined_HP_Def, def_HP));
									last_combined_HP = std::max(((pDefender->getHP()) - n_D * iDamageToDefender), pDefender->getMaxHP() - pAttacker->combatLimit(pDefender));
									combined_HP_sum += prob;
								}
								prob = 0.0f;
							}//for n_D


							if (bIsCondensed && iNeededRoundsAttacker > 1) // then we need to print the prev ones
								// the reason we need iNeededRoundsAttacker to be greater than 1 is that if it's equal to 1 then we end up with the defender detailed HP bar show up twice, because it will also get printed below
							{
								szString.append(NEWLINE);
								int pixels = (int)(Scaling_Factor * combined_HP_sum + 0.5);  // 1% per pixel
								int fullBlocks = (pixels) / 10;
								int lastBlock = (pixels) % 10;
								//if(pixels>=2) {szString.append(L"<img=Art/ACO/green_bar_left_end.dds>");}
								szString.append(L"<img=Art/ACO/red_bar_left_end.dds>");
								for (int iI = 0; iI < fullBlocks; ++iI)
								{
									szString.append(L"<img=Art/ACO/red_bar_10.dds>");
								}
								if (lastBlock > 0)
								{
									szTempBuffer2.Format(L"<img=Art/ACO/red_bar_%d.dds>", lastBlock);
									szString.append(szTempBuffer2);
								}
								szString.append(L"<img=Art/ACO/red_bar_right_end.dds>");
								szString.append(L" ");
								szString.append(gDLL->getText("TXT_KEY_COLOR_NEGATIVE"));
								szTempBuffer.Format(L"%d", first_combined_HP_Def);
								szString.append(szTempBuffer.GetCString());
								szString.append(gDLL->getText("TXT_ACO_HP"));
								if (first_combined_HP_Def != last_combined_HP)
								{
									szTempBuffer.Format(L"-%d", last_combined_HP);
									szString.append(szTempBuffer.GetCString());
									szString.append(gDLL->getText("TXT_ACO_HP"));
								}
								szString.append(gDLL->getText("TXT_KEY_COLOR_REVERT"));
								szTempBuffer.Format(L" %.2f%%", combined_HP_sum);
								szString.append(szTempBuffer.GetCString());

								bIsCondensed = false;//resetting
								combined_HP_sum = 0.0f;//resetting this variable
							}

							//print the unhurt value...always

							prob = 100.0f * (getCombatOddsSpecific(pAttacker, pDefender, iNeededRoundsDefender, 0) + (getCombatOddsSpecific(pAttacker, pDefender, iNeededRoundsDefender - 1, 0)));
							int pixels = (int)(Scaling_Factor * prob + 0.5);  // 1% per pixel
							int fullBlocks = (pixels) / 10;
							int lastBlock = (pixels) % 10;

							szString.append(NEWLINE);
							szString.append(L"<img=Art/ACO/red_bar_left_end.dds>");
							for (int iI = 0; iI < fullBlocks; ++iI)
							{
								szString.append(L"<img=Art/ACO/red_bar_10.dds>");
							}
							if (lastBlock > 0)
							{
								szTempBuffer2.Format(L"<img=Art/ACO/red_bar_%d.dds>", lastBlock);
								szString.append(szTempBuffer2);
							}
							szString.append(L"<img=Art/ACO/red_bar_right_end.dds>");
							szString.append(L" ");
							szString.append(gDLL->getText("TXT_KEY_COLOR_NEGATIVE"));
							szTempBuffer.Format(L"%d", pDefender->getHP());
							szString.append(szTempBuffer.GetCString());
							szString.append(gDLL->getText("TXT_ACO_HP"));
							szString.append(gDLL->getText("TXT_KEY_COLOR_REVERT"));
							szTempBuffer.Format(L" %.2f%%", prob);
							szString.append(szTempBuffer.GetCString());
						}
						//END DEFENDER DETAIL HP HERE

						szString.append(NEWLINE);

						if (iView & getBugOptionINT("ACO__ShowBasicInfo", 3, "ACO_SHOW_BASIC_INFO"))
						{
							szTempBuffer.Format(SETCOLR L"%d" ENDCOLR L", " SETCOLR L"%d " ENDCOLR,
								TEXT_COLOR("COLOR_POSITIVE_TEXT"), iDamageToDefender, TEXT_COLOR("COLOR_NEGATIVE_TEXT"), iDamageToAttacker);
							szString.append(NEWLINE);
							szString.append(szTempBuffer.GetCString());
							szString.append(gDLL->getText("TXT_ACO_HP"));
							szString.append(" ");
							szString.append(gDLL->getText("TXT_ACO_MULTIPLY"));
							szTempBuffer.Format(L" " SETCOLR L"%d" ENDCOLR L", " SETCOLR L"%d " ENDCOLR,
								TEXT_COLOR("COLOR_POSITIVE_TEXT"), iNeededRoundsAttacker, TEXT_COLOR("COLOR_NEGATIVE_TEXT"),
								iNeededRoundsDefender);
							szString.append(szTempBuffer.GetCString());
							szString.append(gDLL->getText("TXT_ACO_HITSAT"));
							szTempBuffer.Format(SETCOLR L" %.1f%%" ENDCOLR,
								TEXT_COLOR("COLOR_POSITIVE_TEXT"), float(iAttackerOdds) * 100.0f / float(GC.getDefineINT("COMBAT_DIE_SIDES")));
							szString.append(szTempBuffer.GetCString());
						}
						if (!(iView & getBugOptionINT("ACO__ShowExperienceRange", 2, "ACO_SHOW_EXPERIENCE_RANGE")) || (pAttacker->combatLimit(pDefender) < pDefender->getMaxHP())) //medium and high only
						{
							if (iView & getBugOptionINT("ACO__ShowBasicInfo", 3, "ACO_SHOW_BASIC_INFO"))
							{
								szTempBuffer.Format(L". R=" SETCOLR L"%.2f" ENDCOLR,
									TEXT_COLOR("COLOR_HIGHLIGHT_TEXT"), CombatRatio);
								szString.append(szTempBuffer.GetCString());
							}
						}
						else
						{
							//we do an XP range display
							//This should hopefully now work for any max and min XP values.

							if (pAttacker->combatLimit(pDefender) == pDefender->getMaxHP())
							{
								FAssert(GC.getMAX_EXPERIENCE_PER_COMBAT() > GC.getMIN_EXPERIENCE_PER_COMBAT()); //ensuring the differences is at least 1
								int size = GC.getMAX_EXPERIENCE_PER_COMBAT() - GC.getMIN_EXPERIENCE_PER_COMBAT();
								float* CombatRatioThresholds = new float[size];

								for (int i = 0; i < size; i++) //setup the array
								{
									CombatRatioThresholds[i] = (float)pAttacker->attackXPValue() / (float)(GC.getMAX_EXPERIENCE_PER_COMBAT() - i);
									//For standard game, this is the list created:
									//  {4/10, 4/9, 4/8,
									//   4/7, 4/6, 4/5,
									//   4/4, 4/3, 4/2}
								}
								for (int i = size - 1; i >= 0; i--) // find which range we are in
								{
									//starting at i = 8, going through to i = 0
									if (CombatRatio > CombatRatioThresholds[i])
									{

										if (i == (size - 1))//highest XP value already
										{
											szString.append(NEWLINE);
											szTempBuffer.Format(L"(%.2f:%d",
												CombatRatioThresholds[i], GC.getMIN_EXPERIENCE_PER_COMBAT() + 1);
											szString.append(szTempBuffer.GetCString());
											szString.append(gDLL->getText("TXT_ACO_XP"));
											szTempBuffer.Format(L"), (R=" SETCOLR L"%.2f" ENDCOLR L":%d",
												TEXT_COLOR("COLOR_HIGHLIGHT_TEXT"), CombatRatio, iExperience);
											szString.append(szTempBuffer.GetCString());
											szString.append(gDLL->getText("TXT_ACO_XP"));
											szString.append(")");
										}
										else // normal situation
										{
											szString.append(NEWLINE);
											szTempBuffer.Format(L"(%.2f:%d",
												CombatRatioThresholds[i], GC.getMAX_EXPERIENCE_PER_COMBAT() - i);
											szString.append(szTempBuffer.GetCString());
											szString.append(gDLL->getText("TXT_ACO_XP"));
											szTempBuffer.Format(L"), (R=" SETCOLR L"%.2f" ENDCOLR L":%d",
												TEXT_COLOR("COLOR_HIGHLIGHT_TEXT"), CombatRatio, GC.getMAX_EXPERIENCE_PER_COMBAT() - (i + 1));
											szString.append(szTempBuffer.GetCString());
											szString.append(gDLL->getText("TXT_ACO_XP"));
											szTempBuffer.Format(L"), (>%.2f:%d",
												CombatRatioThresholds[i + 1], GC.getMAX_EXPERIENCE_PER_COMBAT() - (i + 2));
											szString.append(szTempBuffer.GetCString());
											szString.append(gDLL->getText("TXT_ACO_XP"));
											szString.append(")");
										}
										break;

									}
									else//very rare (ratio less than or equal to 0.4)
									{
										if (i == 0)//maximum XP
										{
											szString.append(NEWLINE);
											szTempBuffer.Format(L"(R=" SETCOLR L"%.2f" ENDCOLR L":%d",
												TEXT_COLOR("COLOR_POSITIVE_TEXT"), CombatRatio, GC.getMAX_EXPERIENCE_PER_COMBAT());
											szString.append(szTempBuffer.GetCString());

											szTempBuffer.Format(L"), (>%.2f:%d",
												CombatRatioThresholds[i], GC.getMAX_EXPERIENCE_PER_COMBAT() - 1);
											szString.append(szTempBuffer.GetCString());
											szString.append(gDLL->getText("TXT_ACO_XP"));
											szString.append(")");
											break;
										}//if
									}// else if
								}//for
								delete[] CombatRatioThresholds;
								//throw away the array
							}//if
						} // else if
						//Finished Showing XP range display


						if (iView & getBugOptionINT("ACO__ShowAverageHealth", 2, "ACO_SHOW_AVERAGE_HEALTH"))
						{
							szTempBuffer.Format(L"%.1f", E_HP_Att);
							szTempBuffer2.Format(L"%.1f", E_HP_Def);
							szString.append(gDLL->getText("TXT_ACO_AVERAGEHP"));
							szString.append(gDLL->getText("TXT_ACO_VS", szTempBuffer.GetCString(), szTempBuffer2.GetCString()));
						}

						if (iView & getBugOptionINT("ACO__ShowUnharmedOdds", 2, "ACO_SHOW_UNHARMED_ODDS"))
						{
							szTempBuffer.Format(L"%.2f%%", 100.0f * AttackerUnharmed);
							szTempBuffer2.Format(L"%.2f%%", 100.0f * DefenderUnharmed);
							szString.append(gDLL->getText("TXT_ACO_UNHARMED"));
							szString.append(gDLL->getText("TXT_ACO_VS", szTempBuffer.GetCString(), szTempBuffer2.GetCString()));
						}

						if (iView & getBugOptionINT("ACO__ShowUnroundedExperience", 0, "ACO_SHOW_UNROUNDED_EXPERIENCE"))
						{
							szTempBuffer.Format(L"%.2f", AttXP);
							szTempBuffer2.Format(L"%.2f", DefXP);
							szString.append(gDLL->getText("TXT_ACO_UNROUNDEDXP"));
							szString.append(gDLL->getText("TXT_ACO_VS", szTempBuffer.GetCString(), szTempBuffer2.GetCString()));
						}

						szString.append(NEWLINE);
						if (iView & getBugOptionINT("ACO__ShowShiftInstructions", 1, "ACO_SHOW_SHIFT_INSTRUCTIONS"))
						{
							szString.append(gDLL->getText("TXT_ACO_PRESSSHIFT"));
							szString.append(NEWLINE);
						}
						//TB Display Mod begin
						szString.append(gDLL->getText("TXT_TB_PRESSCTRL"));
						szString.append(NEWLINE);
						if (GC.getGame().isOption(GAMEOPTION_COMBAT_STRENGTH_IN_NUMBERS))
						{
							szString.append(gDLL->getText("TXT_TB_PRESSALT_STR"));
							szString.append(NEWLINE);
						}
						//TB Display Mod end

						szString.append(NEWLINE);

						szTempBuffer.Format(L"%.2f",
							((pAttacker->getDomainType() == DOMAIN_AIR) ? pAttacker->airCurrCombatStrFloat(pDefender) : pAttacker->currCombatStrFloat(NULL, NULL)));

						if (pAttacker->isHurt())
						{
							szTempBuffer.append(L" (");
							szTempBuffer.append(gDLL->getText("TXT_ACO_INJURED_HP",
								pAttacker->getHP(),
								pAttacker->getMaxHP()));
							szTempBuffer.append(L")");
						}


						szTempBuffer2.Format(L"%.2f",
							pDefender->currCombatStrFloat(pPlot, pAttacker)
						);

						if (pDefender->isHurt())
						{
							szTempBuffer2.append(L" (");
							szTempBuffer2.append(gDLL->getText("TXT_ACO_INJURED_HP",
								pDefender->getHP(),
								pDefender->getMaxHP()));
							szTempBuffer2.append(L")");
						}

						szString.append(gDLL->getText("TXT_ACO_VS", szTempBuffer.GetCString(), szTempBuffer2.GetCString()));

						if (((!(pDefender->immuneToFirstStrikes())) && (pAttacker->maxFirstStrikes() > 0)) || (pAttacker->maxCombatStr(NULL, NULL) != pAttacker->baseCombatStr() * 100))
						{
							//if attacker uninjured strength is not the same as base strength (i.e. modifiers are in effect) or first strikes exist, then
							if (getBugOptionBOOL("ACO__ShowModifierLabels", false, "ACO_SHOW_MODIFIER_LABELS"))
							{
								szString.append(gDLL->getText("TXT_ACO_ATTACKMODIFIERS"));
							}
						}//if

						if ((iView & getBugOptionINT("ACO__ShowAttackerInfo", 0, "ACO_SHOW_ATTACKER_INFO")))
						{
							szString.append(NEWLINE);
							setUnitHelp(szString, pAttacker, true, true);
						}



						szString.append(gDLL->getText("TXT_KEY_COLOR_POSITIVE"));
						szString.append(L' ');//XXX

						if (!bStealthAttack && !bStealthDefense && pAttacker->maxFirstStrikes() > 0 && !pDefender->immuneToFirstStrikes())
						{
							if (pAttacker->firstStrikes() == pAttacker->maxFirstStrikes())
							{
								szString.append(NEWLINE);
								szString.append(gDLL->getText("TXT_KEY_UNITHELP_FIRST_STRIKES", pAttacker->firstStrikes()));
							}
							else
							{
								szString.append(NEWLINE);
								szString.append(gDLL->getText("TXT_KEY_UNITHELP_FIRST_STRIKE_CHANCES", pAttacker->firstStrikes(), pAttacker->maxFirstStrikes()));
							}
						}
						if (bStealthAttack)
						{
							if (pAttacker->stealthStrikesTotal() > 0)
							{
								szString.append(NEWLINE);
								szString.append(gDLL->getText("TXT_KEY_UNITHELP_NUM_STEALTH_STRIKES_ATTACK", pAttacker->stealthStrikesTotal()));
							}
							if (pAttacker->stealthCombatModifierTotal() > 0)
							{
								szString.append(NEWLINE);
								szString.append(gDLL->getText("TXT_KEY_UNITHELP_STEALTH_COMBAT_ATTACK", pAttacker->stealthCombatModifierTotal()));
							}
						}


						iModifier = pAttacker->getExtraCombatPercent();

						if (iModifier != 0)
						{
							szString.append(NEWLINE);
							szString.append(gDLL->getText("TXT_KEY_COMBAT_PLOT_EXTRA_STRENGTH", iModifier));
						}

						szString.append(gDLL->getText("TXT_KEY_COLOR_REVERT"));
						szString.append(L' ');//XXX

						if (((!(pAttacker->immuneToFirstStrikes())) && (pDefender->maxFirstStrikes() > 0)) || (pDefender->maxCombatStr(pPlot, pAttacker) != pDefender->baseCombatStr() * 100) || bStealthDefense)
						{
							//if attacker uninjured strength is not the same as base strength (i.e. modifiers are in effect) or first strikes exist, then
							if (getBugOptionBOOL("ACO__ShowModifierLabels", false, "ACO_SHOW_MODIFIER_LABELS"))
							{
								szString.append(gDLL->getText("TXT_ACO_DEFENSEMODIFIERS"));
							}
						}

						if (iView & getBugOptionINT("ACO__ShowDefenderInfo", 3, "ACO_SHOW_DEFENDER_INFO"))
						{
							szString.append(NEWLINE);
							setUnitHelp(szString, pDefender, true, true);
						}

						if (iView & getBugOptionINT("ACO__ShowDefenseModifiers", 3, "ACO_SHOW_DEFENSE_MODIFIERS"))
						{
							//if defense modifiers are enabled - recommend leaving this on unless Total defense Modifier is enabled
							szString.append(gDLL->getText("TXT_KEY_COLOR_NEGATIVE"));

							szString.append(L' ');//XXX

							if (!bStealthAttack && !bStealthDefense && pDefender->maxFirstStrikes() > 0 && !pAttacker->immuneToFirstStrikes())
							{
								if (pDefender->firstStrikes() == pDefender->maxFirstStrikes())
								{
									szString.append(NEWLINE);
									szString.append(gDLL->getText("TXT_KEY_UNITHELP_FIRST_STRIKES", pDefender->firstStrikes()));
								}
								else
								{
									szString.append(NEWLINE);
									szString.append(gDLL->getText("TXT_KEY_UNITHELP_FIRST_STRIKE_CHANCES", pDefender->firstStrikes(), pDefender->maxFirstStrikes()));
								}
							}
							if (bStealthDefense)
							{
								if (pDefender->stealthStrikesTotal() > 0)
								{
									szString.append(NEWLINE);
									szString.append(gDLL->getText("TXT_KEY_UNITHELP_NUM_STEALTH_STRIKES_DEFENSE", pDefender->stealthStrikesTotal()));
								}
								if (pDefender->stealthCombatModifierTotal() > 0)
								{
									szString.append(NEWLINE);
									szString.append(gDLL->getText("TXT_KEY_UNITHELP_STEALTH_COMBAT_DEFENSE", pDefender->stealthCombatModifierTotal()));
								}
							}

							if (!(pAttacker->isRiver()))
							{
								if (pAttacker->plot()->isRiverCrossing(directionXY(pAttacker->plot(), pPlot)))
								{
									iModifier = GC.getRIVER_ATTACK_MODIFIER();

									if (iModifier != 0)
									{
										szString.append(NEWLINE);
										szString.append(gDLL->getText("TXT_KEY_COMBAT_PLOT_RIVER_MOD", -(iModifier)));
									}
								}
							}

							if (!(pAttacker->isAmphib()))
							{
								if (!(pPlot->isWater()) && pAttacker->plot()->isWater())
								{
									iModifier = GC.getAMPHIB_ATTACK_MODIFIER();

									if (iModifier != 0)
									{
										szString.append(NEWLINE);
										szString.append(gDLL->getText("TXT_KEY_COMBAT_PLOT_AMPHIB_MOD", -(iModifier)));
									}
								}
							}

							iModifier = pDefender->getExtraCombatPercent();

							if (iModifier != 0)
							{
								szString.append(NEWLINE);
								szString.append(gDLL->getText("TXT_KEY_COMBAT_PLOT_EXTRA_STRENGTH", iModifier));
							}
							//TB Combat Mods Begin
							if (pDefender->defenseCombatModifierTotal() != 0)
							{
								iModifier = pDefender->defenseCombatModifierTotal();

								if (iModifier != 0)
								{
									szString.append(NEWLINE);
									szString.append(gDLL->getText("TXT_KEY_COMBAT_DEFENSE_MODIFIER", iModifier));
								}
							}

							if (pDefender->isHominid())
							{
								iModifier = pAttacker->vsBarbsModifier();

								if (iModifier != 0)
								{
									szString.append(NEWLINE);
									szString.append(gDLL->getText("TXT_KEY_COMBAT_VSBARBS", iModifier));
								}
							}

							iModifier = pDefender->unitDefenseModifier(pAttacker->getUnitType());

							if (iModifier != 0)
							{
								szString.append(NEWLINE);
								szString.append(gDLL->getText("TXT_KEY_COMBAT_PLOT_MOD_VS_TYPE", iModifier, GC.getUnitInfo(pAttacker->getUnitType()).getTextKeyWide()));
							}

							for (iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
							{
								if (pAttacker->isHasUnitCombat((UnitCombatTypes)iI))
								{
									eUnitCombatType = ((UnitCombatTypes)iI);
									iModifier = pDefender->unitCombatModifier(eUnitCombatType);
									if (iModifier != 0)
									{
										szString.append(NEWLINE);
										szString.append(gDLL->getText("TXT_KEY_COMBAT_PLOT_MOD_VS_TYPE", iModifier, GC.getUnitCombatInfo(eUnitCombatType).getTextKeyWide()));
									}
								}
							}

							for (iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
							{
								if (pAttacker->isHasUnitCombat((UnitCombatTypes)iI))
								{
									eUnitCombatType = ((UnitCombatTypes)iI);
									iModifier = pDefender->withdrawVSUnitCombatTotal(eUnitCombatType);
									if (iModifier != 0)
									{
										szString.append(NEWLINE);
										szString.append(gDLL->getText("TXT_KEY_COMBAT_PLOT_WITHDRAW_VS_TYPE", iModifier, GC.getUnitCombatInfo(eUnitCombatType).getTextKeyWide()));
									}
								}
							}

							for (iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
							{
								if (pAttacker->isHasUnitCombat((UnitCombatTypes)iI))
								{
									eUnitCombatType = ((UnitCombatTypes)iI);
									iModifier = pDefender->pursuitVSUnitCombatTotal(eUnitCombatType);
									if (iModifier != 0)
									{
										szString.append(NEWLINE);
										szString.append(gDLL->getText("TXT_KEY_COMBAT_PLOT_PURSUIT_VS_TYPE", iModifier, GC.getUnitCombatInfo(eUnitCombatType).getTextKeyWide()));
									}
								}
							}

							for (iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
							{
								if (pAttacker->isHasUnitCombat((UnitCombatTypes)iI))
								{
									eUnitCombatType = ((UnitCombatTypes)iI);
									iModifier = pDefender->repelVSUnitCombatTotal(eUnitCombatType);
									if (iModifier != 0)
									{
										szString.append(NEWLINE);
										szString.append(gDLL->getText("TXT_KEY_COMBAT_PLOT_REPEL_VS_TYPE", iModifier, GC.getUnitCombatInfo(eUnitCombatType).getTextKeyWide()));
									}
								}
							}

							for (iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
							{
								if (pAttacker->isHasUnitCombat((UnitCombatTypes)iI))
								{
									eUnitCombatType = ((UnitCombatTypes)iI);
									iModifier = pDefender->knockbackVSUnitCombatTotal(eUnitCombatType);
									if (iModifier != 0)
									{
										szString.append(NEWLINE);
										szString.append(gDLL->getText("TXT_KEY_COMBAT_PLOT_KNOCKBACK_VS_TYPE", iModifier, GC.getUnitCombatInfo(eUnitCombatType).getTextKeyWide()));
									}
								}
							}

							for (iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
							{
								if (pAttacker->isHasUnitCombat((UnitCombatTypes)iI))
								{
									eUnitCombatType = ((UnitCombatTypes)iI);
									iModifier = pDefender->punctureVSUnitCombatTotal(eUnitCombatType);
									if (iModifier != 0)
									{
										szString.append(NEWLINE);
										szString.append(gDLL->getText("TXT_KEY_COMBAT_PLOT_PUNCTURE_VS_TYPE", iModifier, GC.getUnitCombatInfo(eUnitCombatType).getTextKeyWide()));
									}
								}
							}

							for (iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
							{
								if (pAttacker->isHasUnitCombat((UnitCombatTypes)iI))
								{
									eUnitCombatType = ((UnitCombatTypes)iI);
									iModifier = pDefender->armorVSUnitCombatTotal(eUnitCombatType);
									if (iModifier != 0)
									{
										szString.append(NEWLINE);
										szString.append(gDLL->getText("TXT_KEY_COMBAT_PLOT_ARMOR_VS_TYPE", iModifier, GC.getUnitCombatInfo(eUnitCombatType).getTextKeyWide()));
									}
								}
							}

							for (iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
							{
								if (pAttacker->isHasUnitCombat((UnitCombatTypes)iI))
								{
									eUnitCombatType = ((UnitCombatTypes)iI);
									iModifier = pDefender->dodgeVSUnitCombatTotal(eUnitCombatType);
									if (iModifier != 0)
									{
										szString.append(NEWLINE);
										szString.append(gDLL->getText("TXT_KEY_COMBAT_PLOT_DODGE_VS_TYPE", iModifier, GC.getUnitCombatInfo(eUnitCombatType).getTextKeyWide()));
									}
								}
							}

							for (iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
							{
								if (pAttacker->isHasUnitCombat((UnitCombatTypes)iI))
								{
									eUnitCombatType = ((UnitCombatTypes)iI);
									iModifier = pDefender->precisionVSUnitCombatTotal(eUnitCombatType);
									if (iModifier != 0)
									{
										szString.append(NEWLINE);
										szString.append(gDLL->getText("TXT_KEY_COMBAT_PLOT_PRECISION_VS_TYPE", iModifier, GC.getUnitCombatInfo(eUnitCombatType).getTextKeyWide()));
									}
								}
							}

							for (iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
							{
								if (pAttacker->isHasUnitCombat((UnitCombatTypes)iI))
								{
									eUnitCombatType = ((UnitCombatTypes)iI);
									iModifier = pDefender->criticalVSUnitCombatTotal(eUnitCombatType);
									if (iModifier != 0)
									{
										szString.append(NEWLINE);
										szString.append(gDLL->getText("TXT_KEY_COMBAT_PLOT_CRITICAL_VS_TYPE", iModifier, GC.getUnitCombatInfo(eUnitCombatType).getTextKeyWide()));
									}
								}
							}

							for (iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
							{
								if (pAttacker->isHasUnitCombat((UnitCombatTypes)iI))
								{
									eUnitCombatType = ((UnitCombatTypes)iI);
									iModifier = pDefender->roundStunVSUnitCombatTotal(eUnitCombatType);
									if (iModifier != 0)
									{
										szString.append(NEWLINE);
										szString.append(gDLL->getText("TXT_KEY_COMBAT_PLOT_ROUND_STUN_VS_TYPE", iModifier, GC.getUnitCombatInfo(eUnitCombatType).getTextKeyWide()));
									}
								}
							}

							//TB SubCombat Mod End
							iModifier = pDefender->domainModifier(pAttacker->getDomainType());

							if (iModifier != 0)
							{
								szString.append(NEWLINE);
								szString.append(gDLL->getText("TXT_KEY_COMBAT_PLOT_MOD_VS_TYPE", iModifier, GC.getDomainInfo(pAttacker->getDomainType()).getTextKeyWide()));
							}

							if (!(pDefender->noDefensiveBonus()))
							{
								iModifier = pPlot->defenseModifier(pDefender->getTeam(), pAttacker ? pAttacker->ignoreBuildingDefense() : true);

								if (iModifier != 0)
								{
									szString.append(NEWLINE);
									szString.append(gDLL->getText("TXT_KEY_COMBAT_PLOT_TILE_MOD", iModifier));
								}
							}
							//TB Combat Mods (Fortification) Originally iModifier = pDefender->fortifyModifier() only.
							int iFort = pDefender->fortifyModifier();
							int iOverrun = pAttacker->overrunTotal();
							int iOverrunHundred = (iOverrun > 100 ? 100 : iOverrun);
							int iOverrunTotal = 100 - (iOverrunHundred < 0 ? 0 : iOverrunHundred);
							int iFortModTotal = (iFort * iOverrunTotal) / 100;
							iModifier = iFortModTotal;
							//TB Display Mod Begin
							if (!bTBView && iModifier != 0)
							{
								szString.append(NEWLINE);
								szString.append(gDLL->getText("TXT_KEY_COMBAT_PLOT_FORTIFY_MOD", iModifier));
							}

							if (bTBView && iFort > 0)
							{
								szString.append(NEWLINE);
								szTempBuffer.Format(SETCOLR L"Fortification Mod: %d%" ENDCOLR,
									TEXT_COLOR("COLOR_RED"), iFort);
								szString.append(szTempBuffer.GetCString());
								if (iOverrun > 0)
								{
									szString.append(NEWLINE);
									szTempBuffer.Format(SETCOLR L"Attacker Overrun: %d" ENDCOLR,
										TEXT_COLOR("COLOR_RED"), iOverrun);
									szString.append(NEWLINE);
									szString.append(szTempBuffer.GetCString());
									szTempBuffer.Format(SETCOLR L"Total Fortification: %d%" ENDCOLR,
										TEXT_COLOR("COLOR_RED"), iModifier);
									szString.append(szTempBuffer.GetCString());
								}
							}
							//TB Display Mod end
							//TB Combat Mods end
							if (pPlot->isCity(true, pDefender->getTeam()) && pAttacker->plot() != pPlot)
							{
								iModifier = pDefender->cityDefenseModifier();

								if (iModifier != 0)
								{
									szString.append(NEWLINE);
									szString.append(gDLL->getText("TXT_KEY_COMBAT_PLOT_CITY_MOD", iModifier));
								}
							}

							if (pPlot->isHills())
							{
								iModifier = pDefender->hillsDefenseModifier();

								if (iModifier != 0)
								{
									szString.append(NEWLINE);
									szString.append(gDLL->getText("TXT_KEY_COMBAT_PLOT_HILLS_MOD", iModifier));
								}
							}

							if (pPlot->getFeatureType() != NO_FEATURE)
							{
								iModifier = pDefender->featureDefenseModifier(pPlot->getFeatureType());

								if (iModifier != 0)
								{
									szString.append(NEWLINE);
									szString.append(gDLL->getText("TXT_KEY_COMBAT_PLOT_UNIT_MOD", iModifier, GC.getFeatureInfo(pPlot->getFeatureType()).getTextKeyWide()));
								}
							}

							iModifier = pDefender->terrainDefenseModifier(pPlot->getTerrainType());

							if (iModifier != 0)
							{
								szString.append(NEWLINE);
								szString.append(gDLL->getText("TXT_KEY_COMBAT_PLOT_UNIT_MOD", iModifier, GC.getTerrainInfo(pPlot->getTerrainType()).getTextKeyWide()));
							}

							szString.append(gDLL->getText("TXT_KEY_COLOR_REVERT"));

							szString.append(L' ');//XXX

							szString.append(gDLL->getText("TXT_KEY_COLOR_POSITIVE"));

							szString.append(L' ');//XXX


							iModifier = pAttacker->unitAttackModifier(pDefender->getUnitType());

							if (iModifier != 0)
							{
								szString.append(NEWLINE);
								szString.append(gDLL->getText("TXT_KEY_COMBAT_PLOT_MOD_VS_TYPE", -iModifier, GC.getUnitInfo(pDefender->getUnitType()).getTextKeyWide()));
							}
							//TB Combat Mods Begin
							if (pAttacker->attackCombatModifierTotal() != 0)
							{
								iModifier = pAttacker->attackCombatModifierTotal();

								if (iModifier != 0)
								{
									szString.append(NEWLINE);
									szString.append(gDLL->getText("TXT_KEY_COMBAT_ATTACK_MODIFIER", iModifier));
								}
							}

							int iOffset = 0;
							int iPerTotal = 0;
							iOffset = pDefender->sizeRank() - pAttacker->sizeRank();
							if (pAttacker->combatModifierPerSizeMoreTotal() != 0 && iOffset > 0)
							{
								iPerTotal = pAttacker->combatModifierPerSizeMoreTotal() * iOffset;
								iModifier = -iPerTotal;

								if (iModifier != 0)
								{
									szString.append(NEWLINE);
									szString.append(gDLL->getText("TXT_KEY_COMBAT_ATTACK_FROM_SIZE_MODIFIER", iModifier));
								}
							}

							iOffset = 0;
							iPerTotal = 0;
							iOffset = pDefender->groupRank() - pAttacker->groupRank();
							if (pAttacker->combatModifierPerVolumeMoreTotal() != 0 && iOffset > 0)
							{
								iPerTotal = pAttacker->combatModifierPerVolumeMoreTotal() * iOffset;
								iModifier = -iPerTotal;

								if (iModifier != 0)
								{
									szString.append(NEWLINE);
									szString.append(gDLL->getText("TXT_KEY_COMBAT_ATTACK_FROM_VOLUME_MODIFIER", iModifier));
								}
							}

							iOffset = 0;
							iPerTotal = 0;
							iOffset = pDefender->sizeRank() - pAttacker->sizeRank();
							if (pAttacker->combatModifierPerSizeLessTotal() != 0 && iOffset < 0)
							{
								iPerTotal = pAttacker->combatModifierPerSizeLessTotal() * -iOffset;
								iModifier = -iPerTotal;

								if (iModifier != 0)
								{
									szString.append(NEWLINE);
									szString.append(gDLL->getText("TXT_KEY_COMBAT_ATTACK_FROM_SIZE_MODIFIER", iModifier));
								}
							}

							iOffset = 0;
							iPerTotal = 0;
							iOffset = pDefender->groupRank() - pAttacker->groupRank();
							if (pAttacker->combatModifierPerVolumeLessTotal() != 0 && iOffset < 0)
							{
								iPerTotal = pAttacker->combatModifierPerVolumeLessTotal() * -iOffset;
								iModifier = -iPerTotal;

								if (iModifier != 0)
								{
									szString.append(NEWLINE);
									szString.append(gDLL->getText("TXT_KEY_COMBAT_ATTACK_FROM_VOLUME_MODIFIER", iModifier));
								}
							}

							if (pAttacker->isHominid())
							{
								iModifier = pDefender->vsBarbsModifier();

								if (iModifier != 0)
								{
									szString.append(NEWLINE);
									szString.append(gDLL->getText("TXT_KEY_COMBAT_VSBARBS", iModifier));
								}
							}

							for (iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
							{
								if (pDefender->isHasUnitCombat((UnitCombatTypes)iI))
								{
									eUnitCombatType = ((UnitCombatTypes)iI);
									iModifier = pAttacker->unitCombatModifier(eUnitCombatType);
									if (iModifier != 0)
									{
										szString.append(NEWLINE);
										szString.append(gDLL->getText("TXT_KEY_COMBAT_PLOT_MOD_VS_TYPE", iModifier, GC.getUnitCombatInfo(eUnitCombatType).getTextKeyWide()));
									}
								}
							}

							for (iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
							{
								if (pDefender->isHasUnitCombat((UnitCombatTypes)iI))
								{
									eUnitCombatType = ((UnitCombatTypes)iI);
									iModifier = pAttacker->withdrawVSUnitCombatTotal(eUnitCombatType);
									if (iModifier != 0)
									{
										szString.append(NEWLINE);
										szString.append(gDLL->getText("TXT_KEY_COMBAT_PLOT_WITHDRAW_VS_TYPE", iModifier, GC.getUnitCombatInfo(eUnitCombatType).getTextKeyWide()));
									}
								}
							}

							for (iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
							{
								if (pDefender->isHasUnitCombat((UnitCombatTypes)iI))
								{
									eUnitCombatType = ((UnitCombatTypes)iI);
									iModifier = pAttacker->pursuitVSUnitCombatTotal(eUnitCombatType);
									if (iModifier != 0)
									{
										szString.append(NEWLINE);
										szString.append(gDLL->getText("TXT_KEY_COMBAT_PLOT_PURSUIT_VS_TYPE", iModifier, GC.getUnitCombatInfo(eUnitCombatType).getTextKeyWide()));
									}
								}
							}

							for (iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
							{
								if (pDefender->isHasUnitCombat((UnitCombatTypes)iI))
								{
									eUnitCombatType = ((UnitCombatTypes)iI);
									iModifier = pAttacker->repelVSUnitCombatTotal(eUnitCombatType);
									if (iModifier != 0)
									{
										szString.append(NEWLINE);
										szString.append(gDLL->getText("TXT_KEY_COMBAT_PLOT_REPEL_VS_TYPE", iModifier, GC.getUnitCombatInfo(eUnitCombatType).getTextKeyWide()));
									}
								}
							}

							for (iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
							{
								if (pDefender->isHasUnitCombat((UnitCombatTypes)iI))
								{
									eUnitCombatType = ((UnitCombatTypes)iI);
									iModifier = pAttacker->knockbackVSUnitCombatTotal(eUnitCombatType);
									if (iModifier != 0)
									{
										szString.append(NEWLINE);
										szString.append(gDLL->getText("TXT_KEY_COMBAT_PLOT_KNOCKBACK_VS_TYPE", iModifier, GC.getUnitCombatInfo(eUnitCombatType).getTextKeyWide()));
									}
								}
							}

							for (iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
							{
								if (pDefender->isHasUnitCombat((UnitCombatTypes)iI))
								{
									eUnitCombatType = ((UnitCombatTypes)iI);
									iModifier = pAttacker->punctureVSUnitCombatTotal(eUnitCombatType);
									if (iModifier != 0)
									{
										szString.append(NEWLINE);
										szString.append(gDLL->getText("TXT_KEY_COMBAT_PLOT_PUNCTURE_VS_TYPE", iModifier, GC.getUnitCombatInfo(eUnitCombatType).getTextKeyWide()));
									}
								}
							}

							for (iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
							{
								if (pDefender->isHasUnitCombat((UnitCombatTypes)iI))
								{
									eUnitCombatType = ((UnitCombatTypes)iI);
									iModifier = pAttacker->armorVSUnitCombatTotal(eUnitCombatType);
									if (iModifier != 0)
									{
										szString.append(NEWLINE);
										szString.append(gDLL->getText("TXT_KEY_COMBAT_PLOT_ARMOR_VS_TYPE", iModifier, GC.getUnitCombatInfo(eUnitCombatType).getTextKeyWide()));
									}
								}
							}

							for (iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
							{
								if (pDefender->isHasUnitCombat((UnitCombatTypes)iI))
								{
									eUnitCombatType = ((UnitCombatTypes)iI);
									iModifier = pAttacker->dodgeVSUnitCombatTotal(eUnitCombatType);
									if (iModifier != 0)
									{
										szString.append(NEWLINE);
										szString.append(gDLL->getText("TXT_KEY_COMBAT_PLOT_DODGE_VS_TYPE", iModifier, GC.getUnitCombatInfo(eUnitCombatType).getTextKeyWide()));
									}
								}
							}

							for (iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
							{
								if (pDefender->isHasUnitCombat((UnitCombatTypes)iI))
								{
									eUnitCombatType = ((UnitCombatTypes)iI);
									iModifier = pAttacker->precisionVSUnitCombatTotal(eUnitCombatType);
									if (iModifier != 0)
									{
										szString.append(NEWLINE);
										szString.append(gDLL->getText("TXT_KEY_COMBAT_PLOT_PRECISION_VS_TYPE", iModifier, GC.getUnitCombatInfo(eUnitCombatType).getTextKeyWide()));
									}
								}
							}

							for (iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
							{
								if (pDefender->isHasUnitCombat((UnitCombatTypes)iI))
								{
									eUnitCombatType = ((UnitCombatTypes)iI);
									iModifier = pAttacker->criticalVSUnitCombatTotal(eUnitCombatType);
									if (iModifier != 0)
									{
										szString.append(NEWLINE);
										szString.append(gDLL->getText("TXT_KEY_COMBAT_PLOT_CRITICAL_VS_TYPE", iModifier, GC.getUnitCombatInfo(eUnitCombatType).getTextKeyWide()));
									}
								}
							}

							for (iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
							{
								if (pDefender->isHasUnitCombat((UnitCombatTypes)iI))
								{
									eUnitCombatType = ((UnitCombatTypes)iI);
									iModifier = pAttacker->roundStunVSUnitCombatTotal(eUnitCombatType);
									if (iModifier != 0)
									{
										szString.append(NEWLINE);
										szString.append(gDLL->getText("TXT_KEY_COMBAT_PLOT_ROUND_STUN_VS_TYPE", iModifier, GC.getUnitCombatInfo(eUnitCombatType).getTextKeyWide()));
									}
								}
							}
							//TB SubCombat Mod End
							iModifier = pAttacker->domainModifier(pDefender->getDomainType());

							if (iModifier != 0)
							{
								szString.append(NEWLINE);
								szString.append(gDLL->getText("TXT_KEY_COMBAT_PLOT_MOD_VS_TYPE", -iModifier, GC.getDomainInfo(pDefender->getDomainType()).getTextKeyWide()));
							}

							if (pPlot->isCity(true, pDefender->getTeam()))
							{
								iModifier = pAttacker->cityAttackModifier();

								if (iModifier != 0)
								{
									szString.append(NEWLINE);
									szString.append(gDLL->getText("TXT_KEY_COMBAT_PLOT_CITY_MOD", -iModifier));
								}
							}

							if (pPlot->isHills())
							{
								iModifier = pAttacker->hillsAttackModifier();

								if (iModifier != 0)
								{
									szString.append(NEWLINE);
									szString.append(gDLL->getText("TXT_KEY_COMBAT_PLOT_HILLS_MOD", -iModifier));
								}
							}

							if (pPlot->getFeatureType() != NO_FEATURE)
							{
								iModifier = pAttacker->featureAttackModifier(pPlot->getFeatureType());

								if (iModifier != 0)
								{
									szString.append(NEWLINE);
									szString.append(gDLL->getText("TXT_KEY_COMBAT_PLOT_UNIT_MOD", -iModifier, GC.getFeatureInfo(pPlot->getFeatureType()).getTextKeyWide()));
								}
							}
							else
							{
								iModifier = pAttacker->terrainAttackModifier(pPlot->getTerrainType());

								if (iModifier != 0)
								{
									szString.append(NEWLINE);
									szString.append(gDLL->getText("TXT_KEY_COMBAT_PLOT_UNIT_MOD", -iModifier, GC.getTerrainInfo(pPlot->getTerrainType()).getTextKeyWide()));
								}
							}

							iModifier = pAttacker->getKamikazePercent();
							if (iModifier != 0)
							{
								szString.append(NEWLINE);
								szString.append(gDLL->getText("TXT_KEY_COMBAT_KAMIKAZE_MOD", -iModifier));
							}

							if (GC.getGame().isOption(GAMEOPTION_COMBAT_SURROUND_DESTROY))
							{
								//TB Combat Mods (S&D promos)
								int iSurround = pAttacker->surroundedDefenseModifier(pPlot, pDefender);
								int iDynamicDefense = pDefender->dynamicDefenseTotal();
								int iDynamicDefenseModifier = ((iSurround * iDynamicDefense) / 100);
								int iSurroundTotalstepone = iSurround - iDynamicDefenseModifier;
								int iSurroundTotal = (iSurroundTotalstepone < 0 ? 0 : iSurroundTotalstepone);

								iModifier = iSurroundTotal;
								if (iModifier != 0)
								{
									szString.append(NEWLINE);
									szString.append(gDLL->getText("TXT_KEY_COMBAT_SURROUNDED_DEFENSE_MOD", -iModifier));
								}
							}

							if (pDefender->isAnimal())
							{
								iModifier = -GC.getHandicapInfo(GC.getGame().getHandicapType()).getAnimalCombatModifier();

								iModifier += pAttacker->getUnitInfo().getAnimalCombatModifier();

								if (iModifier != 0)
								{
									szString.append(NEWLINE);
									szString.append(gDLL->getText("TXT_KEY_UNITHELP_ANIMAL_COMBAT_MOD", -iModifier));
								}
							}

							if (pDefender->isHominid())
							{
								iModifier = -GC.getHandicapInfo(GC.getGame().getHandicapType()).getBarbarianCombatModifier();

								if (iModifier != 0)
								{
									szString.append(NEWLINE);
									szString.append(gDLL->getText("TXT_KEY_UNITHELP_BARBARIAN_COMBAT_MOD", -iModifier));
								}
							}
						}//if

						szString.append(gDLL->getText("TXT_KEY_COLOR_REVERT"));

						szString.append(L' ');//XXX

						if (iView & getBugOptionINT("ACO__ShowTotalDefenseModifier", 2, "ACO_SHOW_TOTAL_DEFENSE_MODIFIER"))
						{
							const int iMaxCombatStr = pDefender->maxCombatStr(pPlot, pAttacker);

							if (iMaxCombatStr > pDefender->baseCombatStr() * 100) // modifier is positive
							{
								szTempBuffer.Format(
									SETCOLR L"%d%%" ENDCOLR, TEXT_COLOR("COLOR_NEGATIVE_TEXT"),
									iMaxCombatStr / pDefender->baseCombatStr() - 100
								);
							}
							else if (iMaxCombatStr != 0) // modifier is negative
							{
								szTempBuffer.Format(
									SETCOLR L"%d%%" ENDCOLR, TEXT_COLOR("COLOR_POSITIVE_TEXT"),
									100 - pDefender->baseCombatStr() * 100 / iMaxCombatStr
								);
							}
							szString.append(gDLL->getText("TXT_ACO_TOTALDEFENSEMODIFIER"));
							szString.append(szTempBuffer.GetCString());
						}
					}
					/** What follows in the "else" block, is the original code **/
					else
					{
						//ACO is not enabled
						szOffenseOdds.Format(L"%.2f", ((pAttacker->getDomainType() == DOMAIN_AIR) ? pAttacker->airCurrCombatStrFloat(pDefender) : pAttacker->currCombatStrFloat(NULL, NULL)));
						szDefenseOdds.Format(L"%.2f", pDefender->currCombatStrFloat(pPlot, pAttacker));
						szString.append(NEWLINE);
						szString.append(gDLL->getText("TXT_KEY_COMBAT_PLOT_ODDS_VS", szOffenseOdds.GetCString(), szDefenseOdds.GetCString()));

						szString.append(L' ');//XXX

						szString.append(gDLL->getText("TXT_KEY_COLOR_POSITIVE"));

						szString.append(L' ');//XXX

						addModifierIfValid(szString, pAttacker->getExtraCombatPercent(), "TXT_KEY_COMBAT_PLOT_EXTRA_STRENGTH");
						addModifierWithInfoIfValid(szString, pAttacker->unitAttackModifier(pDefender->getUnitType()), "TXT_KEY_COMBAT_PLOT_MOD_VS_TYPE", GC.getUnitInfo(pDefender->getUnitType()));

						//TB Combat Mods Begin
						addModifierIfValid(szString, pDefender->defenseCombatModifierTotal(), "TXT_KEY_COMBAT_DEFENSE_MODIFIER");
						addCombatModifierHint(szString, pDefender->combatModifierPerSizeMoreTotal(), pAttacker->sizeRank() - pDefender->sizeRank(), "TXT_KEY_COMBAT_ATTACK_FROM_SIZE_MODIFIER");
						addCombatModifierHint(szString, pDefender->combatModifierPerVolumeMoreTotal(), pAttacker->groupRank() - pDefender->groupRank(), "TXT_KEY_COMBAT_ATTACK_FROM_VOLUME_MODIFIER");
						addCombatModifierHint(szString, pDefender->combatModifierPerSizeLessTotal(), pDefender->sizeRank() - pAttacker->sizeRank(), "TXT_KEY_COMBAT_ATTACK_FROM_SIZE_MODIFIER");
						addCombatModifierHint(szString, pDefender->combatModifierPerVolumeLessTotal(), pDefender->groupRank() - pAttacker->groupRank(), "TXT_KEY_COMBAT_ATTACK_FROM_VOLUME_MODIFIER");
						if (pDefender->isHominid())
						{
							addModifierIfValid(szString, pAttacker->vsBarbsModifier(), "TXT_KEY_COMBAT_VSBARBS");
						}
						addCombatTypeModifierHints(szString, pDefender, pAttacker, &CvUnit::unitCombatModifier, "TXT_KEY_COMBAT_PLOT_MOD_VS_TYPE");
						addCombatTypeModifierHints(szString, pDefender, pAttacker, &CvUnit::withdrawVSUnitCombatTotal, "TXT_KEY_COMBAT_PLOT_WITHDRAW_VS_TYPE");
						addCombatTypeModifierHints(szString, pDefender, pAttacker, &CvUnit::pursuitVSUnitCombatTotal, "TXT_KEY_COMBAT_PLOT_PURSUIT_VS_TYPE");
						addCombatTypeModifierHints(szString, pDefender, pAttacker, &CvUnit::repelVSUnitCombatTotal, "TXT_KEY_COMBAT_PLOT_REPEL_VS_TYPE");
						addCombatTypeModifierHints(szString, pDefender, pAttacker, &CvUnit::knockbackVSUnitCombatTotal, "TXT_KEY_COMBAT_PLOT_KNOCKBACK_VS_TYPE");
						addCombatTypeModifierHints(szString, pDefender, pAttacker, &CvUnit::punctureVSUnitCombatTotal, "TXT_KEY_COMBAT_PLOT_PUNCTURE_VS_TYPE");
						addCombatTypeModifierHints(szString, pDefender, pAttacker, &CvUnit::armorVSUnitCombatTotal, "TXT_KEY_COMBAT_PLOT_ARMOR_VS_TYPE");
						addCombatTypeModifierHints(szString, pDefender, pAttacker, &CvUnit::dodgeVSUnitCombatTotal, "TXT_KEY_COMBAT_PLOT_DODGE_VS_TYPE");
						addCombatTypeModifierHints(szString, pDefender, pAttacker, &CvUnit::precisionVSUnitCombatTotal, "TXT_KEY_COMBAT_PLOT_PRECISION_VS_TYPE");
						addCombatTypeModifierHints(szString, pDefender, pAttacker, &CvUnit::criticalVSUnitCombatTotal, "TXT_KEY_COMBAT_PLOT_CRITICAL_VS_TYPE");
						addCombatTypeModifierHints(szString, pDefender, pAttacker, &CvUnit::roundStunVSUnitCombatTotal, "TXT_KEY_COMBAT_PLOT_ROUND_STUN_VS_TYPE");
						//TB SubCombat Mod End

						addModifierWithInfoIfValid(szString, pAttacker->domainModifier(pDefender->getDomainType()), "TXT_KEY_COMBAT_PLOT_MOD_VS_TYPE", GC.getDomainInfo(pDefender->getDomainType()));

						if (pPlot->isCity(true, pDefender->getTeam()))
						{
							addModifierIfValid(szString, pAttacker->cityAttackModifier(), "TXT_KEY_COMBAT_PLOT_CITY_MOD");
						}
						if (pPlot->isHills())
						{
							addModifierIfValid(szString, pAttacker->hillsAttackModifier(), "TXT_KEY_COMBAT_PLOT_HILLS_MOD");
						}
						if (pPlot->getFeatureType() != NO_FEATURE)
						{
							addModifierWithInfoIfValid(szString, pAttacker->featureAttackModifier(pPlot->getFeatureType()), "TXT_KEY_COMBAT_PLOT_UNIT_MOD", GC.getFeatureInfo(pPlot->getFeatureType()));
						}
						else
						{
							addModifierWithInfoIfValid(szString, pAttacker->terrainAttackModifier(pPlot->getTerrainType()), "TXT_KEY_COMBAT_PLOT_UNIT_MOD", GC.getTerrainInfo(pPlot->getTerrainType()));
						}

						addModifierIfValid(szString, pAttacker->getKamikazePercent(), "TXT_KEY_COMBAT_KAMIKAZE_MOD");

						if (GC.getGame().isOption(GAMEOPTION_COMBAT_SURROUND_DESTROY))
						{
							//TB Combat Mods (S&D promos)
							int iSurround = pAttacker->surroundedDefenseModifier(pPlot, pDefender);
							int iDynamicDefense = pDefender->dynamicDefenseTotal();
							int iDynamicDefenseModifier = ((iSurround * iDynamicDefense) / 100);
							int iSurroundTotalstepone = iSurround - iDynamicDefenseModifier;
							int iSurroundTotal = (iSurroundTotalstepone < 0 ? 0 : iSurroundTotalstepone);

							iModifier = iSurroundTotal;
							if (iModifier != 0)
							{
								szString.append(NEWLINE);
								szString.append(gDLL->getText("TXT_KEY_COMBAT_SURROUNDED_DEFENSE_MOD", iModifier));
							}
						}

						if (pDefender->isAnimal())
						{
							iModifier = -GC.getHandicapInfo(GC.getGame().getHandicapType()).getAnimalCombatModifier();

							iModifier += pAttacker->getUnitInfo().getAnimalCombatModifier();

							if (iModifier != 0)
							{
								szString.append(NEWLINE);
								szString.append(gDLL->getText("TXT_KEY_UNITHELP_ANIMAL_COMBAT_MOD", iModifier));
							}
						}

						if (pDefender->isHominid())
						{
							iModifier = -GC.getHandicapInfo(GC.getGame().getHandicapType()).getBarbarianCombatModifier();

							if (iModifier != 0)
							{
								szString.append(NEWLINE);
								szString.append(gDLL->getText("TXT_KEY_UNITHELP_BARBARIAN_COMBAT_MOD", iModifier));
							}
						}

						if (!pDefender->immuneToFirstStrikes() && pAttacker->maxFirstStrikes() > 0)
						{
							if (pAttacker->firstStrikes() == pAttacker->maxFirstStrikes())
							{
								szString.append(NEWLINE);
								szString.append(gDLL->getText("TXT_KEY_UNITHELP_FIRST_STRIKES", pAttacker->firstStrikes()));
							}
							else
							{
								szString.append(NEWLINE);
								szString.append(gDLL->getText("TXT_KEY_UNITHELP_FIRST_STRIKE_CHANCES", pAttacker->firstStrikes(), pAttacker->maxFirstStrikes()));
							}
						}

						if (pAttacker->isHurt())
						{
							szString.append(NEWLINE);
							szString.append(gDLL->getText("TXT_KEY_COMBAT_PLOT_HP", pAttacker->getHP(), pAttacker->getMaxHP()));
						}

						szString.append(gDLL->getText("TXT_KEY_COLOR_REVERT"));

						szString.append(L' ');//XXX

						szString.append(gDLL->getText("TXT_KEY_COLOR_NEGATIVE"));

						szString.append(L' ');//XXX

						if (!(pAttacker->isRiver()))
						{
							if (pAttacker->plot()->isRiverCrossing(directionXY(pAttacker->plot(), pPlot)))
							{
								iModifier = GC.getRIVER_ATTACK_MODIFIER();

								if (iModifier != 0)
								{
									szString.append(NEWLINE);
									szString.append(gDLL->getText("TXT_KEY_COMBAT_PLOT_RIVER_MOD", -(iModifier)));
								}
							}
						}

						if (!(pAttacker->isAmphib()))
						{
							if (!(pPlot->isWater()) && pAttacker->plot()->isWater())
							{
								iModifier = GC.getAMPHIB_ATTACK_MODIFIER();

								if (iModifier != 0)
								{
									szString.append(NEWLINE);
									szString.append(gDLL->getText("TXT_KEY_COMBAT_PLOT_AMPHIB_MOD", -(iModifier)));
								}
							}
						}

						iModifier = pDefender->getExtraCombatPercent();

						if (iModifier != 0)
						{
							szString.append(NEWLINE);
							szString.append(gDLL->getText("TXT_KEY_COMBAT_PLOT_EXTRA_STRENGTH", iModifier));
						}

						iModifier = pDefender->unitDefenseModifier(pAttacker->getUnitType());

						if (iModifier != 0)
						{
							szString.append(NEWLINE);
							szString.append(gDLL->getText("TXT_KEY_COMBAT_PLOT_MOD_VS_TYPE", iModifier, GC.getUnitInfo(pAttacker->getUnitType()).getTextKeyWide()));
						}
						//TB Combat Mods Begin

						if (pAttacker->attackCombatModifierTotal() != 0)
						{
							iModifier = pAttacker->attackCombatModifierTotal();

							if (iModifier != 0)
							{
								szString.append(NEWLINE);
								szString.append(gDLL->getText("TXT_KEY_COMBAT_DEFENSE_MODIFIER", iModifier));
							}
						}

						if (pAttacker->isHominid())
						{
							iModifier = pDefender->vsBarbsModifier();
							if (iModifier != 0)
							{
								szString.append(NEWLINE);
								szString.append(gDLL->getText("TXT_KEY_COMBAT_VSBARBS", iModifier));
							}
						}

						for (iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
						{
							if (pAttacker->isHasUnitCombat((UnitCombatTypes)iI))
							{
								eUnitCombatType = ((UnitCombatTypes)iI);
								iModifier = pDefender->unitCombatModifier(eUnitCombatType);
								if (iModifier != 0)
								{
									szString.append(NEWLINE);
									szString.append(gDLL->getText("TXT_KEY_COMBAT_PLOT_MOD_VS_TYPE", iModifier, GC.getUnitCombatInfo(eUnitCombatType).getTextKeyWide()));
								}
							}
						}

						for (iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
						{
							if (pAttacker->isHasUnitCombat((UnitCombatTypes)iI))
							{
								eUnitCombatType = ((UnitCombatTypes)iI);
								iModifier = pDefender->withdrawVSUnitCombatTotal(eUnitCombatType);
								if (iModifier != 0)
								{
									szString.append(NEWLINE);
									szString.append(gDLL->getText("TXT_KEY_COMBAT_PLOT_WITHDRAW_VS_TYPE", iModifier, GC.getUnitCombatInfo(eUnitCombatType).getTextKeyWide()));
								}
							}
						}

						for (iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
						{
							if (pAttacker->isHasUnitCombat((UnitCombatTypes)iI))
							{
								eUnitCombatType = ((UnitCombatTypes)iI);
								iModifier = pDefender->pursuitVSUnitCombatTotal(eUnitCombatType);
								if (iModifier != 0)
								{
									szString.append(NEWLINE);
									szString.append(gDLL->getText("TXT_KEY_COMBAT_PLOT_PURSUIT_VS_TYPE", iModifier, GC.getUnitCombatInfo(eUnitCombatType).getTextKeyWide()));
								}
							}
						}

						for (iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
						{
							if (pAttacker->isHasUnitCombat((UnitCombatTypes)iI))
							{
								eUnitCombatType = ((UnitCombatTypes)iI);
								iModifier = pDefender->repelVSUnitCombatTotal(eUnitCombatType);
								if (iModifier != 0)
								{
									szString.append(NEWLINE);
									szString.append(gDLL->getText("TXT_KEY_COMBAT_PLOT_REPEL_VS_TYPE", iModifier, GC.getUnitCombatInfo(eUnitCombatType).getTextKeyWide()));
								}
							}
						}

						for (iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
						{
							if (pAttacker->isHasUnitCombat((UnitCombatTypes)iI))
							{
								eUnitCombatType = ((UnitCombatTypes)iI);
								iModifier = pDefender->knockbackVSUnitCombatTotal(eUnitCombatType);
								if (iModifier != 0)
								{
									szString.append(NEWLINE);
									szString.append(gDLL->getText("TXT_KEY_COMBAT_PLOT_KNOCKBACK_VS_TYPE", iModifier, GC.getUnitCombatInfo(eUnitCombatType).getTextKeyWide()));
								}
							}
						}

						for (iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
						{
							if (pAttacker->isHasUnitCombat((UnitCombatTypes)iI))
							{
								eUnitCombatType = ((UnitCombatTypes)iI);
								iModifier = pDefender->punctureVSUnitCombatTotal(eUnitCombatType);
								if (iModifier != 0)
								{
									szString.append(NEWLINE);
									szString.append(gDLL->getText("TXT_KEY_COMBAT_PLOT_PUNCTURE_VS_TYPE", iModifier, GC.getUnitCombatInfo(eUnitCombatType).getTextKeyWide()));
								}
							}
						}

						for (iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
						{
							if (pAttacker->isHasUnitCombat((UnitCombatTypes)iI))
							{
								eUnitCombatType = ((UnitCombatTypes)iI);
								iModifier = pDefender->armorVSUnitCombatTotal(eUnitCombatType);
								if (iModifier != 0)
								{
									szString.append(NEWLINE);
									szString.append(gDLL->getText("TXT_KEY_COMBAT_PLOT_ARMOR_VS_TYPE", iModifier, GC.getUnitCombatInfo(eUnitCombatType).getTextKeyWide()));
								}
							}
						}

						for (iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
						{
							if (pAttacker->isHasUnitCombat((UnitCombatTypes)iI))
							{
								eUnitCombatType = ((UnitCombatTypes)iI);
								iModifier = pDefender->dodgeVSUnitCombatTotal(eUnitCombatType);
								if (iModifier != 0)
								{
									szString.append(NEWLINE);
									szString.append(gDLL->getText("TXT_KEY_COMBAT_PLOT_DODGE_VS_TYPE", iModifier, GC.getUnitCombatInfo(eUnitCombatType).getTextKeyWide()));
								}
							}
						}

						for (iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
						{
							if (pAttacker->isHasUnitCombat((UnitCombatTypes)iI))
							{
								eUnitCombatType = ((UnitCombatTypes)iI);
								iModifier = pDefender->precisionVSUnitCombatTotal(eUnitCombatType);
								if (iModifier != 0)
								{
									szString.append(NEWLINE);
									szString.append(gDLL->getText("TXT_KEY_COMBAT_PLOT_PRECISION_VS_TYPE", iModifier, GC.getUnitCombatInfo(eUnitCombatType).getTextKeyWide()));
								}
							}
						}

						for (iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
						{
							if (pAttacker->isHasUnitCombat((UnitCombatTypes)iI))
							{
								eUnitCombatType = ((UnitCombatTypes)iI);
								iModifier = pDefender->criticalVSUnitCombatTotal(eUnitCombatType);
								if (iModifier != 0)
								{
									szString.append(NEWLINE);
									szString.append(gDLL->getText("TXT_KEY_COMBAT_PLOT_CRITICAL_VS_TYPE", iModifier, GC.getUnitCombatInfo(eUnitCombatType).getTextKeyWide()));
								}
							}
						}

						for (iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
						{
							if (pAttacker->isHasUnitCombat((UnitCombatTypes)iI))
							{
								eUnitCombatType = ((UnitCombatTypes)iI);
								iModifier = pDefender->roundStunVSUnitCombatTotal(eUnitCombatType);
								if (iModifier != 0)
								{
									szString.append(NEWLINE);
									szString.append(gDLL->getText("TXT_KEY_COMBAT_PLOT_ROUND_STUN_VS_TYPE", iModifier, GC.getUnitCombatInfo(eUnitCombatType).getTextKeyWide()));
								}
							}
						}
						//TB SubCombat Mod End
						iModifier = pDefender->domainModifier(pAttacker->getDomainType());

						if (iModifier != 0)
						{
							szString.append(NEWLINE);
							szString.append(gDLL->getText("TXT_KEY_COMBAT_PLOT_MOD_VS_TYPE", iModifier, GC.getDomainInfo(pAttacker->getDomainType()).getTextKeyWide()));
						}

						if (!(pDefender->noDefensiveBonus()))
						{
							iModifier = pPlot->defenseModifier(pDefender->getTeam(), pAttacker ? pAttacker->ignoreBuildingDefense() : true);

							if (iModifier != 0)
							{
								szString.append(NEWLINE);
								szString.append(gDLL->getText("TXT_KEY_COMBAT_PLOT_TILE_MOD", iModifier));
							}
						}
						//TB Combat Mods (Fortification) Originally iModifier = pDefender->fortifyModifier() only.
						int iFort = pDefender->fortifyModifier();
						int iOverrun = pAttacker->overrunTotal();
						int iOverrunHundred = (iOverrun > 100 ? 100 : iOverrun);
						int iOverrunTotal = 100 - (iOverrunHundred < 0 ? 0 : iOverrunHundred);
						int iFortModTotal = (iFort * iOverrunTotal) / 100;
						iModifier = iFortModTotal;
						//TB Display Mod begin
						if (!bTBView && iModifier != 0)
						{
							szString.append(NEWLINE);
							szString.append(gDLL->getText("TXT_KEY_COMBAT_PLOT_FORTIFY_MOD", iModifier));
						}

						if (bTBView && iFort > 0)
						{
							szString.append(NEWLINE);
							szTempBuffer.Format(SETCOLR L"Fortification Mod: %d%" ENDCOLR,
								TEXT_COLOR("COLOR_RED"), iFort);
							szString.append(szTempBuffer.GetCString());
							if (iOverrun > 0)
							{
								szString.append(NEWLINE);
								szTempBuffer.Format(SETCOLR L"Attacker Overrun: %d" ENDCOLR,
									TEXT_COLOR("COLOR_RED"), iOverrun);
								szString.append(NEWLINE);
								szString.append(szTempBuffer.GetCString());
								szTempBuffer.Format(SETCOLR L"Total Fortification: %d%" ENDCOLR,
									TEXT_COLOR("COLOR_RED"), iModifier);
								szString.append(szTempBuffer.GetCString());
							}
						}
						//TB Display Mod end
						//TB Combat Mods end

						if (pPlot->isCity(true, pDefender->getTeam()) && pAttacker->plot() != pPlot)
						{
							iModifier = pDefender->cityDefenseModifier();

							if (iModifier != 0)
							{
								szString.append(NEWLINE);
								szString.append(gDLL->getText("TXT_KEY_COMBAT_PLOT_CITY_MOD", iModifier));
							}
						}

						if (pPlot->isHills())
						{
							iModifier = pDefender->hillsDefenseModifier();

							if (iModifier != 0)
							{
								szString.append(NEWLINE);
								szString.append(gDLL->getText("TXT_KEY_COMBAT_PLOT_HILLS_MOD", iModifier));
							}
						}

						if (pPlot->getFeatureType() != NO_FEATURE)
						{
							iModifier = pDefender->featureDefenseModifier(pPlot->getFeatureType());

							if (iModifier != 0)
							{
								szString.append(NEWLINE);
								szString.append(gDLL->getText("TXT_KEY_COMBAT_PLOT_UNIT_MOD", iModifier, GC.getFeatureInfo(pPlot->getFeatureType()).getTextKeyWide()));
							}
						}
						else
						{
							iModifier = pDefender->terrainDefenseModifier(pPlot->getTerrainType());

							if (iModifier != 0)
							{
								szString.append(NEWLINE);
								szString.append(gDLL->getText("TXT_KEY_COMBAT_PLOT_UNIT_MOD", iModifier, GC.getTerrainInfo(pPlot->getTerrainType()).getTextKeyWide()));
							}
						}

						if (!pAttacker->immuneToFirstStrikes() && pDefender->maxFirstStrikes() > 0)
						{
							if (pDefender->firstStrikes() == pDefender->maxFirstStrikes())
							{
								szString.append(NEWLINE);
								szString.append(gDLL->getText("TXT_KEY_UNITHELP_FIRST_STRIKES", pDefender->firstStrikes()));
							}
							else
							{
								szString.append(NEWLINE);
								szString.append(gDLL->getText("TXT_KEY_UNITHELP_FIRST_STRIKE_CHANCES", pDefender->firstStrikes(), pDefender->maxFirstStrikes()));
							}
						}

						if (pDefender->isHurt())
						{
							szString.append(NEWLINE);
							szString.append(gDLL->getText("TXT_KEY_COMBAT_PLOT_HP", pDefender->getHP(), pDefender->getMaxHP()));
						}
					}
					szString.append(gDLL->getText("TXT_KEY_COLOR_REVERT"));

					if (GC.getGame().isDebugMode())
					{
						szTempBuffer.Format(L"\nStack Compare Value = %d", group->AI_compareStacks(pPlot));
						szString.append(szTempBuffer);

						if (pPlot->getPlotCity())
						{
							szTempBuffer.Format(L"\nBombard turns = %d", group->getBombardTurns(pPlot->getPlotCity()));
							szString.append(szTempBuffer);
						}

						int iOurStrengthDefense = GET_PLAYER(GC.getGame().getActivePlayer()).AI_getOurPlotStrength(pPlot, 1, true, false);
						int iOurStrengthOffense = GET_PLAYER(GC.getGame().getActivePlayer()).AI_getOurPlotStrength(pPlot, 1, false, false);
						szTempBuffer.Format(L"\nPlot Strength(Ours)= d%d, o%d", iOurStrengthDefense, iOurStrengthOffense);
						szString.append(szTempBuffer);
						int iEnemyStrengthDefense = GET_PLAYER(GC.getGame().getActivePlayer()).AI_getEnemyPlotStrength(pPlot, 1, true, false);
						int iEnemyStrengthOffense = GET_PLAYER(GC.getGame().getActivePlayer()).AI_getEnemyPlotStrength(pPlot, 1, false, false);
						szTempBuffer.Format(L"\nPlot Strength(Enemy)= d%d, o%d", iEnemyStrengthDefense, iEnemyStrengthOffense);
						szString.append(szTempBuffer);
					}
				}
#ifdef STRENGTH_IN_NUMBERS
				//Strength in Numbers extended alternative display
				else if (bSINView && GC.getGame().isOption(GAMEOPTION_COMBAT_STRENGTH_IN_NUMBERS))
				{
					CvPlot* aPlot = pAttacker->plot();
					CvUnit* paFIUnit = pAttacker->getAttackerFirstFrontSupportingUnit();
					CvUnit* paFIIUnit = pAttacker->getAttackerSecondFrontSupportingUnit();
					CvUnit* paSRIUnit = pAttacker->getAttackerFirstShortRangeSupportingUnit();
					CvUnit* paSRIIUnit = pAttacker->getAttackerSecondShortRangeSupportingUnit();
					CvUnit* paMRIUnit = pAttacker->getAttackerFirstMediumRangeSupportingUnit();
					CvUnit* paMRIIUnit = pAttacker->getAttackerSecondMediumRangeSupportingUnit();
					CvUnit* paLRIUnit = pAttacker->getAttackerFirstLongRangeSupportingUnit();
					CvUnit* paLRIIUnit = pAttacker->getAttackerSecondLongRangeSupportingUnit();
					CvUnit* paFLIUnit = pAttacker->getAttackerFirstFlankSupportingUnit();
					CvUnit* paFLIIUnit = pAttacker->getAttackerSecondFlankSupportingUnit();
					CvUnit* pdFIUnit = pDefender->getDefenderFirstFrontSupportingUnit();
					CvUnit* pdFIIUnit = pDefender->getDefenderSecondFrontSupportingUnit();
					CvUnit* pdSRIUnit = pDefender->getDefenderFirstShortRangeSupportingUnit();
					CvUnit* pdSRIIUnit = pDefender->getDefenderSecondShortRangeSupportingUnit();
					CvUnit* pdMRIUnit = pDefender->getDefenderFirstMediumRangeSupportingUnit();
					CvUnit* pdMRIIUnit = pDefender->getDefenderSecondMediumRangeSupportingUnit();
					CvUnit* pdLRIUnit = pDefender->getDefenderFirstLongRangeSupportingUnit();
					CvUnit* pdLRIIUnit = pDefender->getDefenderSecondLongRangeSupportingUnit();
					CvUnit* pdFLIUnit = pDefender->getDefenderFirstFlankSupportingUnit();
					CvUnit* pdFLIIUnit = pDefender->getDefenderSecondFlankSupportingUnit();
					//TB Combat Mod end
					if (pAttacker->getAttackerSupportValue() > 0)
					{
						if (pAttacker->getAttackerFirstFrontSupportValue(aPlot, pPlot, pDefender) > 0)
						{
							szString.append(NEWLINE);
							szString.append(gDLL->getText("TXT_KEY_FIRST_FRONT_SUPPORT", paFIUnit->getDescription().c_str(), pAttacker->getAttackerFirstFrontSupportValue(aPlot, pPlot, pDefender)));
						}
						if (pAttacker->getAttackerSecondFrontSupportValue(aPlot, pPlot, pDefender) > 0)
						{
							szString.append(NEWLINE);
							szString.append(gDLL->getText("TXT_KEY_SECOND_FRONT_SUPPORT", paFIIUnit->getDescription().c_str(), pAttacker->getAttackerSecondFrontSupportValue(aPlot, pPlot, pDefender)));
						}
						if (pAttacker->getAttackerFirstShortRangeSupportValue(aPlot, pPlot, pDefender) > 0)
						{
							szString.append(NEWLINE);
							szString.append(gDLL->getText("TXT_KEY_FIRST_SHORT_RANGE_SUPPORT", paSRIUnit->getDescription().c_str(), pAttacker->getAttackerFirstShortRangeSupportValue(aPlot, pPlot, pDefender)));
						}
						if (pAttacker->getAttackerSecondShortRangeSupportValue(aPlot, pPlot, pDefender) > 0)
						{
							szString.append(NEWLINE);
							szString.append(gDLL->getText("TXT_KEY_SECOND_SHORT_RANGE_SUPPORT", paSRIIUnit->getDescription().c_str(), pAttacker->getAttackerSecondShortRangeSupportValue(aPlot, pPlot, pDefender)));
						}
						if (pAttacker->getAttackerFirstMediumRangeSupportValue(aPlot, pPlot, pDefender) > 0)
						{
							szString.append(NEWLINE);
							szString.append(gDLL->getText("TXT_KEY_FIRST_MEDIUM_RANGE_SUPPORT", paMRIUnit->getDescription().c_str(), pAttacker->getAttackerFirstMediumRangeSupportValue(aPlot, pPlot, pDefender)));
						}
						if (pAttacker->getAttackerSecondMediumRangeSupportValue(aPlot, pPlot, pDefender) > 0)
						{
							szString.append(NEWLINE);
							szString.append(gDLL->getText("TXT_KEY_SECOND_MEDIUM_RANGE_SUPPORT", paMRIIUnit->getDescription().c_str(), pAttacker->getAttackerSecondMediumRangeSupportValue(aPlot, pPlot, pDefender)));
						}
						if (pAttacker->getAttackerFirstLongRangeSupportValue(aPlot, pPlot, pDefender) > 0)
						{
							szString.append(NEWLINE);
							szString.append(gDLL->getText("TXT_KEY_FIRST_LONG_RANGE_SUPPORT", paLRIUnit->getDescription().c_str(), pAttacker->getAttackerFirstLongRangeSupportValue(aPlot, pPlot, pDefender)));
						}
						if (pAttacker->getAttackerSecondLongRangeSupportValue(aPlot, pPlot, pDefender) > 0)
						{
							szString.append(NEWLINE);
							szString.append(gDLL->getText("TXT_KEY_SECOND_LONG_RANGE_SUPPORT", paLRIIUnit->getDescription().c_str(), pAttacker->getAttackerSecondLongRangeSupportValue(aPlot, pPlot, pDefender)));
						}
						if (pAttacker->getAttackerFirstFlankSupportValue(aPlot, pPlot, pDefender) > 0)
						{
							szString.append(NEWLINE);
							szString.append(gDLL->getText("TXT_KEY_FIRST_FLANK_SUPPORT", paFLIUnit->getDescription().c_str(), pAttacker->getAttackerFirstFlankSupportValue(aPlot, pPlot, pDefender)));
						}
						if (pAttacker->getAttackerSecondFlankSupportValue(aPlot, pPlot, pDefender) > 0)
						{
							szString.append(NEWLINE);
							szString.append(gDLL->getText("TXT_KEY_SECOND_FLANK_SUPPORT", paFLIIUnit->getDescription().c_str(), pAttacker->getAttackerSecondFlankSupportValue(aPlot, pPlot, pDefender)));
						}
						int iAttackerSupport = pAttacker->getAttackerSupportValue();
						szString.append(NEWLINE);
						szTempBuffer.Format(SETCOLR L"Total Attacker Support: +%d Strength" ENDCOLR,
							TEXT_COLOR("COLOR_GREEN"), iAttackerSupport);
						szString.append(NEWLINE);
						szString.append(szTempBuffer.GetCString());
					}

					if (pDefender->getDefenderSupportValue(pAttacker) > 0)
					{
						if (pDefender->getDefenderFirstFrontSupportValue(pAttacker, pPlot) > 0)
						{
							szString.append(NEWLINE);
							szString.append(gDLL->getText("TXT_KEY_FIRST_FRONT_SUPPORT", pdFIUnit->getDescription().c_str(), pDefender->getDefenderFirstFrontSupportValue(pAttacker, pPlot)));
						}
						if (pDefender->getDefenderSecondFrontSupportValue(pAttacker, pPlot) > 0)
						{
							szString.append(NEWLINE);
							szString.append(gDLL->getText("TXT_KEY_SECOND_FRONT_SUPPORT", pdFIIUnit->getDescription().c_str(), pDefender->getDefenderSecondFrontSupportValue(pAttacker, pPlot)));
						}
						if (pDefender->getDefenderFirstShortRangeSupportValue(pAttacker, pPlot) > 0)
						{
							szString.append(NEWLINE);
							szString.append(gDLL->getText("TXT_KEY_FIRST_SHORT_RANGE_SUPPORT", pdSRIUnit->getDescription().c_str(), pDefender->getDefenderFirstShortRangeSupportValue(pAttacker, pPlot)));
						}
						if (pDefender->getDefenderSecondShortRangeSupportValue(pAttacker, pPlot) > 0)
						{
							szString.append(NEWLINE);
							szString.append(gDLL->getText("TXT_KEY_SECOND_SHORT_RANGE_SUPPORT", pdSRIIUnit->getDescription().c_str(), pDefender->getDefenderSecondShortRangeSupportValue(pAttacker, pPlot)));
						}
						if (pDefender->getDefenderFirstMediumRangeSupportValue(pAttacker, pPlot) > 0)
						{
							szString.append(NEWLINE);
							szString.append(gDLL->getText("TXT_KEY_FIRST_MEDIUM_RANGE_SUPPORT", pdMRIUnit->getDescription().c_str(), pDefender->getDefenderFirstMediumRangeSupportValue(pAttacker, pPlot)));
						}
						if (pDefender->getDefenderSecondMediumRangeSupportValue(pAttacker, pPlot) > 0)
						{
							szString.append(NEWLINE);
							szString.append(gDLL->getText("TXT_KEY_SECOND_MEDIUM_RANGE_SUPPORT", pdMRIIUnit->getDescription().c_str(), pDefender->getDefenderSecondMediumRangeSupportValue(pAttacker, pPlot)));
						}
						if (pDefender->getDefenderFirstLongRangeSupportValue(pAttacker, pPlot) > 0)
						{
							szString.append(NEWLINE);
							szString.append(gDLL->getText("TXT_KEY_FIRST_LONG_RANGE_SUPPORT", pdLRIUnit->getDescription().c_str(), pDefender->getDefenderFirstLongRangeSupportValue(pAttacker, pPlot)));
						}
						if (pDefender->getDefenderSecondLongRangeSupportValue(pAttacker, pPlot) > 0)
						{
							szString.append(NEWLINE);
							szString.append(gDLL->getText("TXT_KEY_SECOND_LONG_RANGE_SUPPORT", pdLRIIUnit->getDescription().c_str(), pDefender->getDefenderSecondLongRangeSupportValue(pAttacker, pPlot)));
						}
						if (pDefender->getDefenderFirstFlankSupportValue(pAttacker, pPlot) > 0)
						{
							szString.append(NEWLINE);
							szString.append(gDLL->getText("TXT_KEY_FIRST_FLANK_SUPPORT", pdFLIUnit->getDescription().c_str(), pDefender->getDefenderFirstFlankSupportValue(pAttacker, pPlot)));
						}
						if (pDefender->getDefenderSecondFlankSupportValue(pAttacker, pPlot) > 0)
						{
							szString.append(NEWLINE);
							szString.append(gDLL->getText("TXT_KEY_SECOND_FLANK_SUPPORT", pdFLIIUnit->getDescription().c_str(), pDefender->getDefenderSecondFlankSupportValue(pAttacker, pPlot)));
						}
						int iDefenderSupport = pDefender->getDefenderSupportValue(pAttacker);
						szString.append(NEWLINE);
						szTempBuffer.Format(SETCOLR L"Total Defender Support: +%d Strength" ENDCOLR,
							TEXT_COLOR("COLOR_RED"), iDefenderSupport);
						szString.append(NEWLINE);
						szString.append(szTempBuffer.GetCString());
					}
				}
#endif // STRENGTH_IN_NUMBERS
			}
			return true;
		}
	}

	return false;
}

// Returns true if help was given...
bool CvGameTextMgr::setMinimalCombatPlotHelp(CvWStringBuffer& szString, CvPlot* pPlot, bool bAssassinate)
{
	PROFILE_FUNC();

	if (gDLL->getInterfaceIFace()->getLengthSelectionList() == 0)
		return false;

	CvSelectionGroup* group = gDLL->getInterfaceIFace()->getSelectionList();

	switch (group->getDomainType())
	{
	case DOMAIN_SEA:
		if (!pPlot->isWater() && !group->canMoveAllTerrain())
			return false;
		break;
	case DOMAIN_LAND:
		if (pPlot->isWater() && !pPlot->isSeaTunnel() && !group->canMoveAllTerrain())
			return false;
		break;
	case DOMAIN_IMMOBILE:
		return false;
	default:
		FErrorMsg("error");
		return false;
	}

	CvUnit* pAttacker = nullptr;
	if (GC.getGame().getActivePlayer() != NO_PLAYER)
	{
		pAttacker = GET_PLAYER(GC.getGame().getActivePlayer()).getUnit(GET_PLAYER(GC.getGame().getActivePlayer()).getAmbushingUnit());
	}
	if (!pAttacker)
	{
		int iOdds;
		const bool bIgnoreMadeAttack = !group->canAttackNow();
		pAttacker = group->AI_getBestGroupAttacker(pPlot, false, iOdds, false, NULL, bAssassinate, false, bIgnoreMadeAttack);

		if (!pAttacker)
			pAttacker = group->AI_getBestGroupAttacker(pPlot, false, iOdds, true, NULL, bAssassinate, false, bIgnoreMadeAttack);
		}

	if (!pAttacker)
		return false;

	CvUnit* pDefender = pPlot->getBestDefender(NO_PLAYER, pAttacker->getOwner(), pAttacker, true, NO_TEAM == pAttacker->getDeclareWarMove(pPlot), false, bAssassinate);

	if (!pDefender || pDefender == pAttacker || !pDefender->canDefend(pPlot) || !(pAttacker->canAttack(*pDefender) || pAttacker->canAmbush(*pDefender, bAssassinate)))
		return false;

	// Show attacker and defender info
	CvWString unitStr;
	szString.append(gDLL->getText("TXT_ACO_ATTACKER"));
							szString.append(NEWLINE);
							setUnitHelp(szString, pAttacker, true, true, true);
							szString.append(NEWLINE);
	szString.append(gDLL->getText("TXT_ACO_CIBLE"));
							szString.append(NEWLINE);
							setUnitHelp(szString, pDefender, true, true, true);
							//szString.append(NEWLINE);
	// Calculate combat odds
	const int iCombatOdds = getCombatOdds(pAttacker, pDefender);

	szString.append(NEWLINE);
	//TB Combat Mods Begin
	int iDefenderDodge = pDefender->dodgeVSOpponentProbTotal(pAttacker);
	int iDefenderPrecision = pDefender->precisionVSOpponentProbTotal(pAttacker);
	int iAttackerDodge = pAttacker->dodgeVSOpponentProbTotal(pDefender);
	int iAttackerPrecision = pAttacker->precisionVSOpponentProbTotal(pDefender);
	int iAttackerHitModifier = iAttackerPrecision - iDefenderDodge;
	int iDefenderHitModifier = iDefenderPrecision - iAttackerDodge;

	int iAttackArmorTotal = pAttacker->armorVSOpponentProbTotal(pDefender);
	int iDefendPunctureTotal = pDefender->punctureVSOpponentProbTotal(pAttacker);
	int iAttackPunctureTotal = pAttacker->punctureVSOpponentProbTotal(pDefender);
	int iDefendArmorTotal = pDefender->armorVSOpponentProbTotal(pAttacker);

	int iUnmodifiedDefenderArmor = (iDefendArmorTotal - iAttackPunctureTotal);
	int iUnmodifiedAttackerArmor = (iAttackArmorTotal - iDefendPunctureTotal);
	int iModifiedDefenderArmorZero = (iUnmodifiedDefenderArmor < 0 ? 0 : iUnmodifiedDefenderArmor);
	int iModifiedAttackerArmorZero = (iUnmodifiedAttackerArmor < 0 ? 0 : iUnmodifiedAttackerArmor);
	int iModifiedDefenderArmor = (iModifiedDefenderArmorZero > 95 ? 95 : iModifiedDefenderArmorZero);
	int iModifiedAttackerArmor = (iModifiedAttackerArmorZero > 95 ? 95 : iModifiedAttackerArmorZero);

	int iDefenderArmor = (100 - iModifiedDefenderArmor);
	int iAttackerArmor = (100 - iModifiedAttackerArmor);
	const int iAttackerStrength = pAttacker->currCombatStr(NULL, NULL);
	const int iAttackerFirepower = pAttacker->currFirepower(NULL, NULL);
	const int iDefenderStrength = std::max(1, pDefender->currCombatStr(pPlot, pAttacker));
	const int iDefenderFirepower = std::max(1, pDefender->currFirepower(pPlot, pAttacker));

	FAssert(iAttackerStrength + iDefenderStrength > 0);
	FAssert(iAttackerFirepower + iDefenderFirepower > 0);

	int iStrengthFactor = (iAttackerFirepower + iDefenderFirepower + 1) / 2;

	int iDefendDamageModifierTotal = pDefender->damageModifierTotal();
	int iAttackDamageModifierTotal = pAttacker->damageModifierTotal();

	int iDamageToAttackerBase = ((GC.getCOMBAT_DAMAGE() * (iDefenderFirepower + iStrengthFactor)) / std::max(1, (iAttackerFirepower + iStrengthFactor)));
	int iDamageToDefenderBase = ((GC.getCOMBAT_DAMAGE() * (iAttackerFirepower + iStrengthFactor)) / std::max(1, (iDefenderFirepower + iStrengthFactor)));
	int iDamageToAttackerModified = iDamageToAttackerBase + ((iDamageToAttackerBase * iDefendDamageModifierTotal) / 100);
	int iDamageToDefenderModified = iDamageToDefenderBase + ((iDamageToDefenderBase * iAttackDamageModifierTotal) / 100);
	int iDamageToAttackerArmor = (iDamageToAttackerModified * iAttackerArmor) / 100;
	int iDamageToDefenderArmor = (iDamageToDefenderModified * iDefenderArmor) / 100;
	int iDamageToAttacker = std::max(1, iDamageToAttackerArmor);
	int iDamageToDefender = std::max(1, iDamageToDefenderArmor);
	int iNeededRoundsAttacker = (pDefender->getHP() - pDefender->getMaxHP() + pAttacker->combatLimit(pDefender) - (((pAttacker->combatLimit(pDefender)) >= pDefender->getMaxHP()) ? 1 : 0)) / iDamageToDefender + 1;

	int iAttackerBaseCriticalChance = pAttacker->criticalVSOpponentProbTotal(pDefender);
	int iDefenderBaseCriticalChance = pDefender->criticalVSOpponentProbTotal(pAttacker);
	int iAttackerCriticalChance = (((iDamageToDefender * 100) * iAttackerBaseCriticalChance) / 100);
	int iDefenderCriticalChance = (((iDamageToDefender * 100) * iAttackerBaseCriticalChance) / 100);
	int iAttackerEndurance = pAttacker->enduranceTotal();
	int iDefenderEndurance = pDefender->enduranceTotal();

	int iNeededRoundsDefender = (pAttacker->getHP() + iDamageToAttacker - 1) / iDamageToAttacker;

	//  Determine Attack Withdraw odds
	int iAttackerWithdraw = pAttacker->withdrawVSOpponentProbTotal(pDefender, pPlot);
	int iDefenderPursuit = pDefender->pursuitVSOpponentProbTotal(pAttacker);
	int iAttackerEarly = pAttacker->earlyWithdrawTotal();
	int AdjustedAttWithdrawalstep1 = iAttackerWithdraw - iDefenderPursuit;
	int AdjustedAttWithdrawalstep2 = ((AdjustedAttWithdrawalstep1 > 100) ? 100 : AdjustedAttWithdrawalstep1);
	int AdjustedAttWithdrawal = ((AdjustedAttWithdrawalstep2 < 0) ? 0 : AdjustedAttWithdrawalstep2);

	int expectedrndcnt = iNeededRoundsDefender;
	int expectedrnds = ((expectedrndcnt * iAttackerEarly) / 100);

	float Scaling_Factor = 1.6f;//how many pixels per 1% of odds

	float AttackerKillOdds = 0.0f;
	float PullOutOdds = 0.0f;//Withdraw odds
	float RetreatOdds = 0.0f;
	float DefenderKillOdds = 0.0f;

	float CombatRatio = ((float)(pAttacker->currCombatStr(NULL, NULL))) / ((float)(pDefender->currCombatStr(pPlot, pAttacker)));
	// THE ALL-IMPORTANT COMBATRATIO

	float AttXP = (pAttacker->attackXPValue()) / CombatRatio;
	float DefXP = (pDefender->defenseXPValue()) * CombatRatio;// These two values are simply for the Unrounded XP display

	// General odds
	if (pAttacker->combatLimit(pDefender) >= pDefender->getMaxHP()) //ie. we can kill the defender... I hope this is the most general form
	{
		//float AttackerKillOdds = 0.0f;
		for (int n_A = 0; n_A < iNeededRoundsDefender; n_A++)
		{
			AttackerKillOdds += getCombatOddsSpecific(pAttacker, pDefender, n_A, iNeededRoundsAttacker);
		}//for
	}
	else
	{
		// else we cannot kill the defender (eg. catapults attacking)
		for (int n_A = 0; n_A < iNeededRoundsDefender; n_A++)
		{
			PullOutOdds += getCombatOddsSpecific(pAttacker, pDefender, n_A, iNeededRoundsAttacker);
		}//for
	}
	//TB Combat Mods - next line adjusted for pursuit
	if ((pAttacker->withdrawVSOpponentProbTotal(pDefender, pPlot) - pDefender->pursuitVSOpponentProbTotal(pAttacker)) > 0)
	{
		for (int n_D = 0; n_D < iNeededRoundsAttacker; n_D++)
		{
			RetreatOdds += getCombatOddsSpecific(pAttacker, pDefender, iNeededRoundsDefender - 1, n_D);
		}//for
	}
	for (int n_D = 0; n_D < iNeededRoundsAttacker; n_D++)
	{
		DefenderKillOdds += getCombatOddsSpecific(pAttacker, pDefender, iNeededRoundsDefender, n_D);
	}//for
	//DefenderKillOdds = 1.0f - (AttackerKillOdds + RetreatOdds + PullOutOdds);//this gives slight negative numbers sometimes, I think


	float prob_victory = 100.0f * getCombatOddsSpecific(pAttacker, pDefender, iNeededRoundsDefender - 1, iNeededRoundsAttacker);
	float prob_retreat = 100.0f * RetreatOdds;



	CvWString szTempBuffer2;
	float prob1 = 100.0f * (AttackerKillOdds + PullOutOdds);//up to win odds
	float prob2 = prob1 + 100.0f * RetreatOdds;//up to retreat odds

	int pixels_left = 199;// 1 less than 200 to account for right end bar
	int pixels;
	int fullBlocks;
	int lastBlock;

	pixels = (2 * ((int)(prob1 + 0.5))) - 1;  // 1% per pixel // subtracting one to account for left end bar
	fullBlocks = pixels / 10;
	lastBlock = pixels % 10;

	szString.append(L"<img=Art/ACO/green_bar_left_end.dds>");
	for (int i = 0; i < fullBlocks; ++i)
	{
		szString.append(L"<img=Art/ACO/green_bar_10.dds>");
		pixels_left -= 10;
	}
	if (lastBlock > 0)
	{
		szTempBuffer2.Format(L"<img=Art/ACO/green_bar_%d.dds>", lastBlock);
		szString.append(szTempBuffer2);
		pixels_left -= lastBlock;
	}


	pixels = 2 * ((int)(prob2 + 0.5)) - (pixels + 1);//the number up to the next one...
	fullBlocks = pixels / 10;
	lastBlock = pixels % 10;
	for (int i = 0; i < fullBlocks; ++i)
	{
		szString.append(L"<img=Art/ACO/yellow_bar_10.dds>");
		pixels_left -= 10;
	}
	if (lastBlock > 0)
	{
		szTempBuffer2.Format(L"<img=Art/ACO/yellow_bar_%d.dds>", lastBlock);
		szString.append(szTempBuffer2);
		pixels_left -= lastBlock;
	}

	fullBlocks = pixels_left / 10;
	lastBlock = pixels_left % 10;
	for (int i = 0; i < fullBlocks; ++i)
	{
		szString.append(L"<img=Art/ACO/red_bar_10.dds>");
	}
	if (lastBlock > 0)
	{
		szTempBuffer2.Format(L"<img=Art/ACO/red_bar_%d.dds>", lastBlock);
		szString.append(szTempBuffer2);
	}

	szString.append(L"<img=Art/ACO/red_bar_right_end.dds> ");





	CvWString szTempBuffer;
	//TB Combat Mod end
	szString.append(NEWLINE);
	if (pAttacker->combatLimit(pDefender) >= pDefender->getMaxHP())
	{
		if (iCombatOdds > 999)
		{
			szTempBuffer = L"&gt; 99.9";
		}
		else if (iCombatOdds < 1)
		{
			szTempBuffer = L"&lt; 0.1";
		}
		else
		{
			szTempBuffer.Format(L"%.1f", iCombatOdds / 10.0f);
		}
		szString.append(gDLL->getText("TXT_KEY_COMBAT_PLOT_ODDS", szTempBuffer.GetCString()));
	}

	return true;
}



bool CvGameTextMgr::setAssassinatePlotHelp(CvWStringBuffer& szString, CvPlot* pPlot, CvUnit* pAttacker, CvUnit* pDefender)
{
	PROFILE_FUNC();
	bool bAssassinate = true;
	if (gDLL->getInterfaceIFace()->getLengthSelectionList() == 0)
		return false;

	CvSelectionGroup* group = gDLL->getInterfaceIFace()->getSelectionList();

	switch (group->getDomainType())
	{
	case DOMAIN_SEA:
		if (!pPlot->isWater() && !group->canMoveAllTerrain())
			return false;
		break;
	case DOMAIN_LAND:
		if (pPlot->isWater() && !pPlot->isSeaTunnel() && !group->canMoveAllTerrain())
			return false;
		break;
	case DOMAIN_IMMOBILE:
		return false;
	default:
		FErrorMsg("error");
		return false;
	}

	if (GC.getGame().getActivePlayer() != NO_PLAYER)
	{
		pAttacker = GET_PLAYER(GC.getGame().getActivePlayer()).getUnit(GET_PLAYER(GC.getGame().getActivePlayer()).getAmbushingUnit());
	}
	if (!pAttacker)
	{
		int iOdds;
		const bool bIgnoreMadeAttack = !group->canAttackNow();
		pAttacker = group->AI_getBestGroupAttacker(pPlot, false, iOdds, false, NULL, bAssassinate, false, bIgnoreMadeAttack);

		if (!pAttacker)
			pAttacker = group->AI_getBestGroupAttacker(pPlot, false, iOdds, true, NULL, bAssassinate, false, bIgnoreMadeAttack);
	}

	if (!pAttacker)
		return false;

	if (!pDefender || pDefender == pAttacker || !pDefender->canDefend(pPlot) || !(pAttacker->canAttack(*pDefender) || pAttacker->canAmbush(*pDefender, bAssassinate)))
		return false;

	// Show attacker and defender info
	CvWString unitStr;
	//szString.append(gDLL->getText("TXT_ACO_ATTACKER"));
	//szString.append(NEWLINE);
	//setUnitHelp(szString, pAttacker, true, true);
	//szString.append(NEWLINE);
	szString.append(gDLL->getText("TXT_ACO_CIBLE"));
	szString.append(NEWLINE);
	setUnitHelp(szString, pDefender, true, true, true);
	// Calculate combat odds
	const int iCombatOdds = getCombatOdds(pAttacker, pDefender);

	szString.append(NEWLINE);
	//TB Combat Mods Begin
	int iDefenderDodge = pDefender->dodgeVSOpponentProbTotal(pAttacker);
	int iDefenderPrecision = pDefender->precisionVSOpponentProbTotal(pAttacker);
	int iAttackerDodge = pAttacker->dodgeVSOpponentProbTotal(pDefender);
	int iAttackerPrecision = pAttacker->precisionVSOpponentProbTotal(pDefender);
	int iAttackerHitModifier = iAttackerPrecision - iDefenderDodge;
	int iDefenderHitModifier = iDefenderPrecision - iAttackerDodge;

	int iAttackArmorTotal = pAttacker->armorVSOpponentProbTotal(pDefender);
	int iDefendPunctureTotal = pDefender->punctureVSOpponentProbTotal(pAttacker);
	int iAttackPunctureTotal = pAttacker->punctureVSOpponentProbTotal(pDefender);
	int iDefendArmorTotal = pDefender->armorVSOpponentProbTotal(pAttacker);

	int iUnmodifiedDefenderArmor = (iDefendArmorTotal - iAttackPunctureTotal);
	int iUnmodifiedAttackerArmor = (iAttackArmorTotal - iDefendPunctureTotal);
	int iModifiedDefenderArmorZero = (iUnmodifiedDefenderArmor < 0 ? 0 : iUnmodifiedDefenderArmor);
	int iModifiedAttackerArmorZero = (iUnmodifiedAttackerArmor < 0 ? 0 : iUnmodifiedAttackerArmor);
	int iModifiedDefenderArmor = (iModifiedDefenderArmorZero > 95 ? 95 : iModifiedDefenderArmorZero);
	int iModifiedAttackerArmor = (iModifiedAttackerArmorZero > 95 ? 95 : iModifiedAttackerArmorZero);

	int iDefenderArmor = (100 - iModifiedDefenderArmor);
	int iAttackerArmor = (100 - iModifiedAttackerArmor);
	const int iAttackerStrength = pAttacker->currCombatStr(NULL, NULL);
	const int iAttackerFirepower = pAttacker->currFirepower(NULL, NULL);
	const int iDefenderStrength = std::max(1, pDefender->currCombatStr(pPlot, pAttacker));
	const int iDefenderFirepower = std::max(1, pDefender->currFirepower(pPlot, pAttacker));

	FAssert(iAttackerStrength + iDefenderStrength > 0);
	FAssert(iAttackerFirepower + iDefenderFirepower > 0);

	int iStrengthFactor = (iAttackerFirepower + iDefenderFirepower + 1) / 2;

	int iDefendDamageModifierTotal = pDefender->damageModifierTotal();
	int iAttackDamageModifierTotal = pAttacker->damageModifierTotal();

	int iDamageToAttackerBase = ((GC.getCOMBAT_DAMAGE() * (iDefenderFirepower + iStrengthFactor)) / std::max(1, (iAttackerFirepower + iStrengthFactor)));
	int iDamageToDefenderBase = ((GC.getCOMBAT_DAMAGE() * (iAttackerFirepower + iStrengthFactor)) / std::max(1, (iDefenderFirepower + iStrengthFactor)));
	int iDamageToAttackerModified = iDamageToAttackerBase + ((iDamageToAttackerBase * iDefendDamageModifierTotal) / 100);
	int iDamageToDefenderModified = iDamageToDefenderBase + ((iDamageToDefenderBase * iAttackDamageModifierTotal) / 100);
	int iDamageToAttackerArmor = (iDamageToAttackerModified * iAttackerArmor) / 100;
	int iDamageToDefenderArmor = (iDamageToDefenderModified * iDefenderArmor) / 100;
	int iDamageToAttacker = std::max(1, iDamageToAttackerArmor);
	int iDamageToDefender = std::max(1, iDamageToDefenderArmor);
	int iNeededRoundsAttacker = (pDefender->getHP() - pDefender->getMaxHP() + pAttacker->combatLimit(pDefender) - (((pAttacker->combatLimit(pDefender)) >= pDefender->getMaxHP()) ? 1 : 0)) / iDamageToDefender + 1;

	int iAttackerBaseCriticalChance = pAttacker->criticalVSOpponentProbTotal(pDefender);
	int iDefenderBaseCriticalChance = pDefender->criticalVSOpponentProbTotal(pAttacker);
	int iAttackerCriticalChance = (((iDamageToDefender * 100) * iAttackerBaseCriticalChance) / 100);
	int iDefenderCriticalChance = (((iDamageToDefender * 100) * iAttackerBaseCriticalChance) / 100);
	int iAttackerEndurance = pAttacker->enduranceTotal();
	int iDefenderEndurance = pDefender->enduranceTotal();

	int iNeededRoundsDefender = (pAttacker->getHP() + iDamageToAttacker - 1) / iDamageToAttacker;

	//  Determine Attack Withdraw odds
	int iAttackerWithdraw = pAttacker->withdrawVSOpponentProbTotal(pDefender, pPlot);
	int iDefenderPursuit = pDefender->pursuitVSOpponentProbTotal(pAttacker);
	int iAttackerEarly = pAttacker->earlyWithdrawTotal();
	int AdjustedAttWithdrawalstep1 = iAttackerWithdraw - iDefenderPursuit;
	int AdjustedAttWithdrawalstep2 = ((AdjustedAttWithdrawalstep1 > 100) ? 100 : AdjustedAttWithdrawalstep1);
	int AdjustedAttWithdrawal = ((AdjustedAttWithdrawalstep2 < 0) ? 0 : AdjustedAttWithdrawalstep2);

	int expectedrndcnt = iNeededRoundsDefender;
	int expectedrnds = ((expectedrndcnt * iAttackerEarly) / 100);

	float Scaling_Factor = 1.6f;//how many pixels per 1% of odds

	float AttackerKillOdds = 0.0f;
	float PullOutOdds = 0.0f;//Withdraw odds
	float RetreatOdds = 0.0f;
	float DefenderKillOdds = 0.0f;

	float CombatRatio = ((float)(pAttacker->currCombatStr(NULL, NULL))) / ((float)(pDefender->currCombatStr(pPlot, pAttacker)));
	// THE ALL-IMPORTANT COMBATRATIO

	float AttXP = (pAttacker->attackXPValue()) / CombatRatio;
	float DefXP = (pDefender->defenseXPValue()) * CombatRatio;// These two values are simply for the Unrounded XP display

	// General odds
	if (pAttacker->combatLimit(pDefender) >= pDefender->getMaxHP()) //ie. we can kill the defender... I hope this is the most general form
	{
		//float AttackerKillOdds = 0.0f;
		for (int n_A = 0; n_A < iNeededRoundsDefender; n_A++)
		{
			AttackerKillOdds += getCombatOddsSpecific(pAttacker, pDefender, n_A, iNeededRoundsAttacker);
		}//for
	}
	else
	{
		// else we cannot kill the defender (eg. catapults attacking)
		for (int n_A = 0; n_A < iNeededRoundsDefender; n_A++)
		{
			PullOutOdds += getCombatOddsSpecific(pAttacker, pDefender, n_A, iNeededRoundsAttacker);
		}//for
	}
	//TB Combat Mods - next line adjusted for pursuit
	if ((pAttacker->withdrawVSOpponentProbTotal(pDefender, pPlot) - pDefender->pursuitVSOpponentProbTotal(pAttacker)) > 0)
	{
		for (int n_D = 0; n_D < iNeededRoundsAttacker; n_D++)
		{
			RetreatOdds += getCombatOddsSpecific(pAttacker, pDefender, iNeededRoundsDefender - 1, n_D);
		}//for
	}
	for (int n_D = 0; n_D < iNeededRoundsAttacker; n_D++)
	{
		DefenderKillOdds += getCombatOddsSpecific(pAttacker, pDefender, iNeededRoundsDefender, n_D);
	}//for
	//DefenderKillOdds = 1.0f - (AttackerKillOdds + RetreatOdds + PullOutOdds);//this gives slight negative numbers sometimes, I think


	float prob_victory = 100.0f * getCombatOddsSpecific(pAttacker, pDefender, iNeededRoundsDefender - 1, iNeededRoundsAttacker);
	float prob_retreat = 100.0f * RetreatOdds;
	CvWString szTempBuffer2;

	float prob1 = 100.0f * (AttackerKillOdds + PullOutOdds);//up to win odds
	float prob2 = prob1 + 100.0f * RetreatOdds;//up to retreat odds

	int pixels_left = 199;// 1 less than 200 to account for right end bar
	int pixels;
	int fullBlocks;
	int lastBlock;

	pixels = (2 * ((int)(prob1 + 0.5))) - 1;  // 1% per pixel // subtracting one to account for left end bar
	fullBlocks = pixels / 10;
	lastBlock = pixels % 10;

	szString.append(L"<img=Art/ACO/green_bar_left_end.dds>");
	for (int i = 0; i < fullBlocks; ++i)
	{
		szString.append(L"<img=Art/ACO/green_bar_10.dds>");
		pixels_left -= 10;
	}
	if (lastBlock > 0)
	{
		szTempBuffer2.Format(L"<img=Art/ACO/green_bar_%d.dds>", lastBlock);
		szString.append(szTempBuffer2);
		pixels_left -= lastBlock;
	}


	pixels = 2 * ((int)(prob2 + 0.5)) - (pixels + 1);//the number up to the next one...
	fullBlocks = pixels / 10;
	lastBlock = pixels % 10;
	for (int i = 0; i < fullBlocks; ++i)
	{
		szString.append(L"<img=Art/ACO/yellow_bar_10.dds>");
		pixels_left -= 10;
	}
	if (lastBlock > 0)
	{
		szTempBuffer2.Format(L"<img=Art/ACO/yellow_bar_%d.dds>", lastBlock);
		szString.append(szTempBuffer2);
		pixels_left -= lastBlock;
	}

	fullBlocks = pixels_left / 10;
	lastBlock = pixels_left % 10;
	for (int i = 0; i < fullBlocks; ++i)
	{
		szString.append(L"<img=Art/ACO/red_bar_10.dds>");
	}
	if (lastBlock > 0)
	{
		szTempBuffer2.Format(L"<img=Art/ACO/red_bar_%d.dds>", lastBlock);
		szString.append(szTempBuffer2);
	}

	szString.append(L"<img=Art/ACO/red_bar_right_end.dds> ");




	CvWString szTempBuffer;
	//TB Combat Mod end
	szString.append(NEWLINE);
	if (pAttacker->combatLimit(pDefender) >= pDefender->getMaxHP())
	{
		if (iCombatOdds > 999)
		{
			szTempBuffer = L"&gt; 99.9";
		}
		else if (iCombatOdds < 1)
		{
			szTempBuffer = L"&lt; 0.1";
		}
		else
		{
			szTempBuffer.Format(L"%.1f", iCombatOdds / 10.0f);
		}
		szString.append(gDLL->getText("TXT_KEY_COMBAT_PLOT_ODDS", szTempBuffer.GetCString()));
	}

	return true;
}


// DO NOT REMOVE - needed for font testing - Moose
void createTestFontString(CvWStringBuffer& szString)
{
	PROFILE_EXTRA_FUNC();
	int iI;
	for (iI=0;iI<NUM_YIELD_TYPES;++iI)
		szString.append(CvWString::format(L"%c", GC.getYieldInfo((YieldTypes) iI).getChar()));

	szString.append(L"\n");
	for (iI=0;iI<NUM_COMMERCE_TYPES;++iI)
		szString.append(CvWString::format(L"%c", GC.getCommerceInfo((CommerceTypes) iI).getChar()));
	szString.append(L"\n");
	for (iI = 0; iI < GC.getNumReligionInfos(); ++iI)
	{
		szString.append(CvWString::format(L"%c", GC.getReligionInfo((ReligionTypes) iI).getChar()));
		szString.append(CvWString::format(L"%c", GC.getReligionInfo((ReligionTypes) iI).getHolyCityChar()));
	}
	szString.append(L"\n");
	for (iI = 0; iI < GC.getNumCorporationInfos(); ++iI)
	{
		szString.append(CvWString::format(L"%c%d", GC.getCorporationInfo((CorporationTypes) iI).getChar(), GC.getCorporationInfo((CorporationTypes) iI).getChar()));
		szString.append(CvWString::format(L"%c%d", GC.getCorporationInfo((CorporationTypes) iI).getHeadquarterChar(), GC.getCorporationInfo((CorporationTypes) iI).getHeadquarterChar()));
	}
	szString.append(L"\n");
	for (iI = 0; iI < GC.getNumPropertyInfos(); ++iI)
	{
		szString.append(CvWString::format(L"%c%d", GC.getPropertyInfo((PropertyTypes) iI).getChar(), GC.getPropertyInfo((PropertyTypes) iI).getChar()));
	}
	szString.append(L"\n");
	for (iI = 0; iI < GC.getNumBonusInfos(); ++iI)
		szString.append(CvWString::format(L"%c%d", GC.getBonusInfo((BonusTypes) iI).getChar(), GC.getBonusInfo((BonusTypes) iI).getChar()));
	szString.append(L"\n");
	for (iI=0; iI<MAX_NUM_SYMBOLS; ++iI)
		szString.append(CvWString::format(L"%c%d", gDLL->getSymbolID(iI), gDLL->getSymbolID(iI)));
}

void CvGameTextMgr::setPlotHelp(CvWStringBuffer& szString, CvPlot* pPlot)
{
	PROFILE_FUNC();

	if (GC.getDefineINT("TEST_GAMEFONTS"))
	{
		createTestFontString(szString);
		return;
	}
	const PlayerTypes eActivePlayer = GC.getGame().getActivePlayer();

	CvWString szTempBuffer;

	const bool bDebug = GC.getGame().isDebugMode();
	const bool bShift = gDLL->shiftKey();
	const bool bAlt = gDLL->altKey();
	const bool bCtrl = gDLL->ctrlKey();

	const TeamTypes eActiveTeam = GC.getGame().getActiveTeam();
	const TeamTypes ePlotTeam = pPlot->getTeam();
	const CvTeamAI* plotTeam = ePlotTeam > -1 ? &GET_TEAM(ePlotTeam) : NULL;
	const PlayerTypes ePlotOwner = pPlot->getOwner();

	if (bDebug && (bCtrl || bShift || bAlt))
	{
		szString.append(CvWString::format(L"X %d, Y %d", pPlot->getX(), pPlot->getY()));
		szString.append(NEWLINE);
		if (bCtrl)
		{
			if (ePlotOwner != NO_PLAYER)
			{
				const int iPlotDanger = GET_PLAYER(ePlotOwner).AI_getPlotDanger(pPlot, 2);
				if (iPlotDanger > 0)
				{
					szString.append(CvWString::format(L"\nPlot Danger = %d", iPlotDanger));
				}
			}

			CvCity* pPlotCity = pPlot->getPlotCity();
			if (pPlotCity)
			{
				const PlayerTypes ePlayer = ePlotOwner;
				const CvPlayerAI& pPlayer = GET_PLAYER(ePlayer);

				szString.append(CvWString::format(L"\n\nRevIndex:%d, ", pPlotCity->getRevolutionIndex()));
				szString.append(CvWString::format(L"Avg:%d, ", pPlotCity->getRevIndexAverage()));
				szString.append(CvWString::format(L"Local:%d, ", pPlotCity->getLocalRevIndex()));
				szString.append(CvWString::format(L"Reinf:%d", pPlotCity->getReinforcementCounter()));
				szString.append(CvWString::format(L"\nRevIdxAnger:%d, ", pPlotCity->getRevIndexPercentAnger()));
				szString.append(CvWString::format(L"ReqAnger:%d, ", pPlotCity->getRevRequestPercentAnger()));
				szString.append(CvWString::format(L"RevSucHappy:%d\n", pPlotCity->getRevSuccessHappiness()));

				const int iCityDefenders = pPlot->plotCount(PUF_canDefendGroupHead, -1, -1, NULL, ePlayer, NO_TEAM, PUF_isCityAIType);
				const int iAttackGroups = pPlot->plotCount(PUF_isUnitAIType, UNITAI_ATTACK, -1, NULL, ePlayer);
				szString.append(CvWString::format(L"\nDefenders [D+A]/N ([%d + %d] / %d)", iCityDefenders, iAttackGroups, pPlotCity->AI_neededDefenders()));

				szString.append(CvWString::format(L"\nFloating Defenders H/N (%d / %d)",
					pPlayer.AI_getTotalFloatingDefenders(pPlotCity->area()), pPlayer.AI_getTotalFloatingDefendersNeeded(pPlotCity->area())));

				szString.append(CvWString::format(L"\nAir Defenders H/N (%d / %d)",
					pPlotCity->plot()->plotCount(PUF_canAirDefend, -1, -1, NULL, pPlotCity->getOwner(), NO_TEAM, PUF_isDomainType, DOMAIN_AIR), pPlotCity->AI_neededAirDefenders()));

				szString.append(CvWString::format(L"\nThreat C/P (%d / %d)", pPlotCity->AI_cityThreat(), pPlayer.AI_getTotalAreaCityThreat(pPlotCity->area())));

				bool bFirst = true;
				for (int iI = 0; iI < MAX_PC_PLAYERS; iI++)
				{
					if (iI == ePlayer) continue;

					if (!GET_PLAYER((PlayerTypes)iI).isAlive()) continue;

					const TeamTypes eTeamX = GET_PLAYER((PlayerTypes)iI).getTeam();

					if (pPlotCity->isCapital())
					{
						const int iPlayerCloseness = pPlayer.AI_playerCloseness((PlayerTypes)iI, DEFAULT_PLAYER_CLOSENESS);

						if (plotTeam->isHasMet(eTeamX) || iPlayerCloseness != 0)
						{
							if (bFirst)
							{
								bFirst = false;

								szString.append(CvWString::format(L"\n\nCloseness + War: (in %d wars)", plotTeam->getAtWarCount(true)));
							}
							szString.append(CvWString::format(L"\n%s(%d) : %d ", GET_PLAYER((PlayerTypes)iI).getName(), DEFAULT_PLAYER_CLOSENESS,
								pPlotCity->AI_playerCloseness((PlayerTypes)iI, DEFAULT_PLAYER_CLOSENESS)));

							szString.append(CvWString::format(L" [%d, ", iPlayerCloseness));

							if (ePlotTeam != eTeamX)
							{
								szString.append(CvWString::format(L"%d]", plotTeam->AI_teamCloseness(eTeamX, DEFAULT_PLAYER_CLOSENESS)));

								if (plotTeam->isHasMet(eTeamX) && plotTeam->AI_getAttitude(eTeamX) != ATTITUDE_FRIENDLY)
								{
									const int iStartWarVal = plotTeam->AI_startWarVal(eTeamX);

									if (plotTeam->isAtWar(eTeamX))
									{
										szString.append(CvWString::format(L"\n   At War:   "));
									}
									else if (plotTeam->AI_getWarPlan(eTeamX) != NO_WARPLAN)
									{
										szString.append(CvWString::format(L"\n   Plan. War:"));
									}
									else if (!plotTeam->canDeclareWar(eTeamX))
									{
										szString.append(CvWString::format(L"\n   Can't War:"));
									}
									else
									{
										szString.append(CvWString::format(L"\n   No War:   "));
									}

									if (iStartWarVal > 1200)
									{
										szString.append(CvWString::format(SETCOLR L" %d" ENDCOLR, TEXT_COLOR("COLOR_RED"), iStartWarVal));
									}
									else if (iStartWarVal > 600)
									{
										szString.append(CvWString::format(SETCOLR L" %d" ENDCOLR, TEXT_COLOR("COLOR_YELLOW"), iStartWarVal));
									}
									else
									{
										szString.append(CvWString::format(L" %d", iStartWarVal));
									}
									szString.append(CvWString::format(L" (%d", plotTeam->AI_calculatePlotWarValue(eTeamX)));
									szString.append(CvWString::format(L", %d", plotTeam->AI_calculateBonusWarValue(eTeamX)));
									szString.append(CvWString::format(L", %d", plotTeam->AI_calculateCapitalProximity(eTeamX)));
									szString.append(CvWString::format(L", %4s", GC.getAttitudeInfo(plotTeam->AI_getAttitude(eTeamX)).getDescription(0)));
									szString.append(CvWString::format(L", %d%%)", 100-plotTeam->AI_noWarAttitudeProb(plotTeam->AI_getAttitude(eTeamX))));
								}
							}
							else
							{
								szString.append(CvWString::format(L"-]"));
							}
						}
					}
					else
					{
						const int iCloseness = pPlotCity->AI_playerCloseness((PlayerTypes)iI, DEFAULT_PLAYER_CLOSENESS);
						if (iCloseness != 0)
						{
							if (bFirst)
							{
								bFirst = false;

								szString.append(CvWString::format(L"\n\nCloseness:"));
							}
							szString.append(CvWString::format(L"\n%s(%d) : %d ", GET_PLAYER((PlayerTypes)iI).getName(), DEFAULT_PLAYER_CLOSENESS, iCloseness));
							szString.append(CvWString::format(L" [%d, ", pPlayer.AI_playerCloseness((PlayerTypes)iI, DEFAULT_PLAYER_CLOSENESS)));

							ePlotTeam != eTeamX ?
								szString.append(CvWString::format(L"%d]", plotTeam->AI_teamCloseness(eTeamX, DEFAULT_PLAYER_CLOSENESS)))
								:
								szString.append(CvWString::format(L"-]"));
						}
					}
				}
				szString.append(CvWString::format(L"\n\nWorkers H/N (%d , %d)", pPlotCity->getNumWorkers(), pPlotCity->AI_getWorkersNeeded()));
				szString.append(CvWString::format(L"\n\nWorkboats Needed = %d", pPlotCity->AI_neededSeaWorkers()));

				int iAreaSiteBestValue = 0;
				const int iNumAreaCitySites = pPlayer.AI_getNumAreaCitySites(pPlot->getArea(), iAreaSiteBestValue);
				int iOtherSiteBestValue = 0;
				const int iNumOtherCitySites = (
					pPlot->waterArea()
					?
					pPlayer.AI_getNumAdjacentAreaCitySites(pPlot->waterArea()->getID(), pPlot->getArea(), iOtherSiteBestValue)
					:
					0
				);

				szString.append(CvWString::format(L"\n\nArea Sites = %d (%d)", iNumAreaCitySites, iAreaSiteBestValue));
				szString.append(CvWString::format(L"\nOther Sites = %d (%d)", iNumOtherCitySites, iOtherSiteBestValue));
			}
			else if (ePlotOwner != NO_PLAYER)
			{
				if (bShift && !bAlt && !pPlot->headUnitNode())
				{
					bool bFirst = true;
					for (int iI = 0; iI < GC.getNumTechInfos(); iI++)
					{
						if (GC.getTechInfo((TechTypes)iI).getEra() <= GET_PLAYER(ePlotOwner).getCurrentEra() + 1)
						{
							const int iPathLength = GET_PLAYER(ePlotOwner).findPathLength(((TechTypes)iI), false);

							if (iPathLength <= 3 && !plotTeam->isHasTech((TechTypes)iI))
							{
								if (bFirst)
								{
									szString.append(CvWString::format(L"Name (TreePathLength) = Value (building, unit)"));
									bFirst = false;
								}
								bool bDummy;
								szString.append(CvWString::format(L"\n%s (%d) = %d (bld:%d, unt:%d)", GC.getTechInfo((TechTypes)iI).getDescription(), iPathLength,
									GET_PLAYER(ePlotOwner).AI_techValue((TechTypes)iI, 1, false, false),
									GET_PLAYER(ePlotOwner).AI_techBuildingValue((TechTypes)iI, 1, bDummy),
									GET_PLAYER(ePlotOwner).AI_techUnitValue((TechTypes)iI, 1, bDummy)));
							}
						}
					}
				}
				else if (bAlt && !bShift)
				{
					if (pPlot->isHasPathToEnemyCity(ePlotTeam))
					{
						szString.append(CvWString::format(L"\nCan reach an enemy city\n\n"));
					}
					else
					{
						szString.append(CvWString::format(L"\nNo reachable enemy cities\n\n"));
					}
					for (int iI = 0; iI < MAX_PLAYERS; iI++)
					{
						if (GET_PLAYER((PlayerTypes)iI).isAlive())
						{
							if (pPlot->isHasPathToPlayerCity(ePlotTeam, (PlayerTypes) iI))
							{
								szString.append(CvWString::format(SETCOLR L"Can reach %s city" ENDCOLR, TEXT_COLOR("COLOR_GREEN"), GET_PLAYER((PlayerTypes)iI).getName()));
							}
							else
							{
								szString.append(CvWString::format(SETCOLR L"Cannot reach any %s city" ENDCOLR, TEXT_COLOR("COLOR_NEGATIVE_TEXT"), GET_PLAYER((PlayerTypes)iI).getName()));
							}

							if (plotTeam->isAtWar(GET_PLAYER((PlayerTypes)iI).getTeam()))
							{
								szString.append(CvWString::format(L" (enemy)"));
							}
							szString.append(CvWString::format(L"\n"));
						}

					}
				}
				else if (bShift && bAlt)
				{
					szString.append(CvWString::format(SETCOLR L"\nStrategic values:" ENDCOLR, TEXT_COLOR("COLOR_UNIT_TEXT")));
					szString.append(CvWString::format(L"choke: %d, canal:%d", pPlot->getChokeValue(), pPlot->getCanalValue()));
					szString.append(NEWLINE);

					bool bFirst = true;
					for (int iI = 0; iI < MAX_PLAYERS; iI++)
					{
						const PlayerTypes ePlayer = (PlayerTypes)iI;
						const CvPlayerAI& kPlayer = GET_PLAYER(ePlayer);

						if (kPlayer.isAlive())
						{
							int iActualFoundValue = pPlot->getFoundValue(ePlayer);
							int iCalcFoundValue = kPlayer.AI_foundValue(pPlot->getX(), pPlot->getY(), -1, false);
							int iStartingFoundValue = kPlayer.AI_foundValue(pPlot->getX(), pPlot->getY(), -1, true);
							int iBestAreaFoundValue = pPlot->area()->getBestFoundValue(ePlayer);
							int iCitySiteBestValue;
							int iNumAreaCitySites = kPlayer.AI_getNumAreaCitySites(pPlot->getArea(), iCitySiteBestValue);

							if ((iActualFoundValue > 0 || iCalcFoundValue > 0 || iStartingFoundValue > 0)
								|| ((ePlotOwner == iI) && (iBestAreaFoundValue > 0)))
							{
								if (bFirst)
								{
									szString.append(CvWString::format(SETCOLR L"\nFound Values:" ENDCOLR, TEXT_COLOR("COLOR_UNIT_TEXT")));
									bFirst = false;
								}

								szString.append(NEWLINE);

								bool bIsRevealed = pPlot->isRevealed(kPlayer.getTeam(), false);

								szString.append(CvWString::format(SETCOLR, TEXT_COLOR(bIsRevealed ? (((iActualFoundValue > 0) && (iActualFoundValue == iBestAreaFoundValue)) ? "COLOR_UNIT_TEXT" : "COLOR_ALT_HIGHLIGHT_TEXT") : "COLOR_HIGHLIGHT_TEXT")));

								if (!bIsRevealed)
								{
									szString.append(CvWString::format(L"("));
								}

								szString.append(CvWString::format(L"%s: %d", kPlayer.getName(), iActualFoundValue));

								if (!bIsRevealed)
								{
									szString.append(CvWString::format(L")"));
								}

								szString.append(CvWString::format(ENDCOLR));

								if (iCalcFoundValue > 0 || iStartingFoundValue > 0)
								{
									szTempBuffer.Format(L" (%d,%ds)", iCalcFoundValue, iStartingFoundValue);
									szString.append(szTempBuffer);
								}

								int iDeadlockCount = kPlayer.AI_countDeadlockedBonuses(pPlot);
								if (iDeadlockCount > 0)
								{
									szTempBuffer.Format(L", " SETCOLR L"d=%d" ENDCOLR, TEXT_COLOR("COLOR_NEGATIVE_TEXT"), iDeadlockCount);
									szString.append(szTempBuffer);
								}

								if (kPlayer.AI_isPlotCitySite(pPlot))
								{
									szTempBuffer.Format(L", " SETCOLR L"X" ENDCOLR, TEXT_COLOR("COLOR_UNIT_TEXT"));
									szString.append(szTempBuffer);
								}

								if ((iBestAreaFoundValue > 0) || (iNumAreaCitySites > 0))
								{
									int iBestFoundValue = kPlayer.findBestFoundValue();

									szTempBuffer.Format(L"\n  Area Best = %d, Best = %d, Sites = %d", iBestAreaFoundValue, iBestFoundValue, iNumAreaCitySites);
									szString.append(szTempBuffer);
								}
							}
						}
					}
				}
				else if (!pPlot->headUnitNode())
				{
					std::vector<UnitAITypes> vecUnitAIs;

					if( pPlot->getFeatureType() != NO_FEATURE )
					{
						szString.append(CvWString::format(L"Defense unit AIs:\n"));
						vecUnitAIs.push_back(UNITAI_CITY_DEFENSE);
						vecUnitAIs.push_back(UNITAI_COUNTER);
						vecUnitAIs.push_back(UNITAI_CITY_COUNTER);
					}
					else
					{
						szString.append(CvWString::format(L"Attack unit AIs:\n"));
						vecUnitAIs.push_back(UNITAI_ATTACK);
						vecUnitAIs.push_back(UNITAI_ATTACK_CITY);
						vecUnitAIs.push_back(UNITAI_COUNTER);
					}

					const CvCity* pCloseCity = GC.getMap().findCity(pPlot->getX(), pPlot->getY(), ePlotOwner, NO_TEAM, true);

					if (pCloseCity)
					{
						foreach_(const UnitAITypes unitAI, vecUnitAIs)
						{
							CvWString szTempString;
							getUnitAIString(szTempString, unitAI);
							szString.append(CvWString::format(L"\n  %s  ", szTempString.GetCString()));
							for (int iJ = 0; iJ < GC.getNumUnitInfos(); iJ++)
							{
								if (pCloseCity->canTrain((UnitTypes)iJ))
								{
									const int iValue = GET_PLAYER(ePlotOwner).AI_unitValue((UnitTypes)iJ, unitAI, pPlot->area());
									if (iValue > 0)
									{
										szString.append(CvWString::format(L"\n %s = %d", GC.getUnitInfo((UnitTypes)iJ).getDescription(), iValue));
									}
								}
							}
						}
					}
				}
			}
			if (bShift && bAlt)
			{
				szString.append(CvWString::format(SETCOLR L"\nStrategic values:" ENDCOLR, TEXT_COLOR("COLOR_UNIT_TEXT")));
				szString.append(CvWString::format(L" choke=%d, canal=%d", pPlot->getChokeValue(), pPlot->getCanalValue()));
				szString.append(NEWLINE);

				for (int iJ = 0; iJ < GC.getNumInvisibleInfos(); iJ++)
				{
					InvisibleTypes eInvisible = (InvisibleTypes)iJ;
					for (int iK = 0; iK < MAX_TEAMS; iK++)
					{
						TeamTypes eTeam = (TeamTypes)iK;
						const int iSpotIntensity = pPlot->getHighestPlotTeamVisibilityIntensity(eInvisible, eTeam);
						if (iSpotIntensity != 0)
						{
							szString.append(CvWString::format(L"InvisibleType: %s, TeamID:%d, Int:%d", GC.getInvisibleInfo(eInvisible).getTextKeyWide(), iK, iSpotIntensity));
							szString.append(NEWLINE);
						}
					}
				}
			}
			return;
		}
		else if (bShift && !bAlt)
		{
			szString.append(CvWString::format(L"\n%s - Lat %d, Long %d",
				GC.getTerrainInfo(pPlot->getTerrainType()).getDescription(), pPlot->getLatitude(), pPlot->getLongitude()));

			szString.append(CvWString::format(L"\nArea %d", pPlot->getArea()));

			if (pPlot->getPlotGroup(eActivePlayer))
			{
				szString.append(CvWString::format(L", plot group %d", pPlot->getPlotGroup(eActivePlayer)->getID()));
			}
			CvCity* pWorkingCity = pPlot->getWorkingCity();

			if (!pWorkingCity && ePlotOwner != NO_PLAYER)
			{
				const int iCulture = GC.getInfoTypeForString("BONUSCLASS_CULTURE");
				const int iProduce = GC.getInfoTypeForString("BONUSCLASS_MANUFACTURED");
				const int iGenmod = GC.getInfoTypeForString("BONUSCLASS_GENMODS");
				const int iWonder = GC.getInfoTypeForString("BONUSCLASS_WONDER");
				bool bFirst = true;
				for (int iI = 0; iI < GC.getNumBonusInfos(); ++iI)
				{
					if (pPlot->isPlotGroupConnectedBonus(ePlotOwner, ((BonusTypes)iI))
					&& GC.getBonusInfo((BonusTypes)iI).getBonusClassType() != iCulture
					&& GC.getBonusInfo((BonusTypes)iI).getBonusClassType() != iProduce
					&& GC.getBonusInfo((BonusTypes)iI).getBonusClassType() != iGenmod
					&& GC.getBonusInfo((BonusTypes)iI).getBonusClassType() != iWonder)
					{
						if (bFirst)
						{
							szString.append(CvWString::format(L"\nAI Bonus Value: %s=%d",
								GC.getBonusInfo((BonusTypes)iI).getDescription(), GET_PLAYER(ePlotOwner).AI_bonusVal((BonusTypes)iI)));
							bFirst = false;
						}
						else
						{
							szString.append(CvWString::format(L", %s=%d",
								GC.getBonusInfo((BonusTypes)iI).getDescription(), GET_PLAYER(ePlotOwner).AI_bonusVal((BonusTypes)iI)));
						}
					}
				}
			}
			bool bNS = true;
			if (pPlot->getRiverNSDirection() == CARDINALDIRECTION_NORTH)
			{
				szString.append(L"\nRiver Flow: N");
			}
			else if (pPlot->getRiverNSDirection() == CARDINALDIRECTION_SOUTH)
			{
				szString.append(L"\nRiver Flow: S");
			}
			else bNS = false;

			if (pPlot->getRiverWEDirection() == CARDINALDIRECTION_WEST)
			{
				if (bNS) szString.append(L"W");
				else szString.append(L"\nRiver Flow: W");
			}
			else if (pPlot->getRiverWEDirection() == CARDINALDIRECTION_EAST)
			{
				if (bNS) szString.append(L"E");
				else szString.append(L"\nRiver Flow: E");
			}

			if (pPlot->getRouteType() != NO_ROUTE)
			{
				szString.append(CvWString::format(L"\nRoute: %s", GC.getRouteInfo(pPlot->getRouteType()).getDescription()));

				if (pPlot->getRouteSymbol())
				{
					szString.append(CvWString::format(L", Connections: %i", gDLL->getRouteIFace()->getConnectionMask(pPlot->getRouteSymbol())));
				}
			}
			else if (pPlot->getRouteSymbol())
			{ // Don't think this can happen, but we probably want to know about it if it does.
				szString.append(CvWString::format(L"\nConnection: %i", gDLL->getRouteIFace()->getConnectionMask(pPlot->getRouteSymbol())));
			}

			for (int iI = 0; iI < MAX_PLAYERS; iI++)
			{
				if (GET_PLAYER((PlayerTypes)iI).isAlive() && pPlot->getDangerCount((PlayerTypes)iI) > 0)
				{
					szTempBuffer.Format(L"\n%s Danger: %d", GET_PLAYER((PlayerTypes)iI).getName(), pPlot->getDangerCount((PlayerTypes)iI));
					szString.append(szTempBuffer);
				}
			}
			int iActualFoundValue = pPlot->getFoundValue(eActivePlayer);
			int iCalcFoundValue = GET_PLAYER(eActivePlayer).AI_foundValue(pPlot->getX(), pPlot->getY(), -1, false);
			int iStartingFoundValue = GET_PLAYER(eActivePlayer).AI_foundValue(pPlot->getX(), pPlot->getY(), -1, true);

			szTempBuffer.Format(L"\nFound Value: %d, (%d, %d)", iActualFoundValue, iCalcFoundValue, iStartingFoundValue);
			szString.append(szTempBuffer);

			CvCity* pCity = GC.getMap().findCity(pPlot->getX(), pPlot->getY(), ePlotOwner, NO_TEAM, false);
			if (pCity)
			{
				int iFoodMultiplier = 0;
				int iProductionMultiplier = 0;
				int iCommerceMultiplier = 0;
				int iDesiredFoodChange = 0;
				pCity->AI_getYieldMultipliers(iFoodMultiplier, iProductionMultiplier, iCommerceMultiplier, iDesiredFoodChange );

				szString.append(CvWString::format(L"\n\n%s yield multipliers:\n  * Food %d, Prod %d, Com %d\n  * Desired Food Change %d",
					pCity->getName().c_str(), iFoodMultiplier, iProductionMultiplier, iCommerceMultiplier, iDesiredFoodChange));

				if (pPlot->isImprovementUpgradable())
				{
					const ImprovementTypes eImprovement = pPlot->getImprovementType();
					szString.append(CvWString::format(L"\nCurrent improvement value: %d\n",
						pCity->AI_getImprovementValue(pPlot, eImprovement, iFoodMultiplier, iProductionMultiplier, iCommerceMultiplier, iDesiredFoodChange)));

					ImprovementTypes eUpgrade = GC.getImprovementInfo(eImprovement).getImprovementUpgrade();
					bool bValid = pPlot->canHaveImprovement(eUpgrade, pCity->getTeam(), false, true);

					szString.append(CvWString::format(L"AI improvement upgrade values:\nMain: %s%s = %d", GC.getImprovementInfo(eUpgrade).getDescription(), bValid ? L"" : L" (False)",
						pCity->AI_getImprovementValue(pPlot, eUpgrade, iFoodMultiplier, iProductionMultiplier, iCommerceMultiplier, iDesiredFoodChange)));

					for (int iI = 0; iI < GC.getImprovementInfo(eImprovement).getNumAlternativeImprovementUpgradeTypes(); ++iI)
					{
						eUpgrade = (ImprovementTypes)GC.getImprovementInfo(eImprovement).getAlternativeImprovementUpgradeType(iI);
						bool bValid = pPlot->canHaveImprovement(eUpgrade, pCity->getTeam(), false, true);
						szString.append(CvWString::format(L"\n  * %s%s = %d", GC.getImprovementInfo(eUpgrade).getDescription(), bValid ? L"" : L" (False)",
							pCity->AI_getImprovementValue(pPlot, eUpgrade, iFoodMultiplier, iProductionMultiplier, iCommerceMultiplier, iDesiredFoodChange)));
					}
				}
				if (pWorkingCity)
				{
					szString.append(NEWLINE);
					szTempBuffer.Format(L"\nTarget pop: %d, (%d good tiles)", pWorkingCity->AI_getTargetSize(), pWorkingCity->AI_getGoodTileCount() );
					szString.append(szTempBuffer);

					const int iPlotIndex = pWorkingCity->getCityPlotIndex(pPlot);
					const BuildTypes eBestBuild = pWorkingCity->AI_getBestBuild(iPlotIndex);

					if (NO_BUILD != eBestBuild)
					{
						szString.append(CvWString::format(L"\nBest Build: %s (%d)", GC.getBuildInfo(eBestBuild).getDescription(), pWorkingCity->AI_getBestBuildValue(iPlotIndex)));
					}
				}
			}
			szTempBuffer.Format(L"\nStack Str: land=%d(%d), sea=%d(%d), air=%d(%d)",
				pPlot->AI_sumStrength(NO_PLAYER, NO_PLAYER, DOMAIN_LAND, StrengthFlags::None),
				pPlot->AI_sumStrength(NO_PLAYER, NO_PLAYER, DOMAIN_LAND, StrengthFlags::DefensiveBonuses),
				pPlot->AI_sumStrength(NO_PLAYER, NO_PLAYER, DOMAIN_SEA, StrengthFlags::None),
				pPlot->AI_sumStrength(NO_PLAYER, NO_PLAYER, DOMAIN_SEA, StrengthFlags::DefensiveBonuses),
				pPlot->AI_sumStrength(NO_PLAYER, NO_PLAYER, DOMAIN_AIR, StrengthFlags::None),
				pPlot->AI_sumStrength(NO_PLAYER, NO_PLAYER, DOMAIN_AIR, StrengthFlags::DefensiveBonuses));
			szString.append(szTempBuffer);
		}
		else if (!bShift && bAlt)
		{
			if (pPlot->isOwned())
			{
				szTempBuffer.Format(L"\nThis player has %d area cities", pPlot->area()->getCitiesPerPlayer(ePlotOwner));
				szString.append(szTempBuffer);
				for (int iI = 0; iI < GC.getNumReligionInfos(); ++iI)
				{
					int iNeededMissionaries = GET_PLAYER(ePlotOwner).AI_neededMissionaries(pPlot->area(), ((ReligionTypes)iI));
					if (iNeededMissionaries > 0)
					{
						szTempBuffer.Format(L"\nNeeded %c missionaries = %d", GC.getReligionInfo((ReligionTypes)iI).getChar(), iNeededMissionaries);
						szString.append(szTempBuffer);
					}
				}

				int iNeededExplorers = GET_PLAYER(ePlotOwner).AI_neededExplorers(pPlot->area());
				int iHasExplorers = GET_PLAYER(ePlotOwner).AI_totalAreaUnitAIs(pPlot->area(), UNITAI_EXPLORE);
				if (iNeededExplorers > 0)
				{
					szTempBuffer.Format(L"\nNeeded explorers = %d (has %d)", iNeededExplorers, iHasExplorers);
					szString.append(szTempBuffer);
				}

				int iNeededHunters = GET_PLAYER(ePlotOwner).AI_neededHunters(pPlot->area());
				int iHasHunters = GET_PLAYER(ePlotOwner).AI_totalAreaUnitAIs(pPlot->area(), UNITAI_HUNTER);
				if (iNeededHunters > 0)
				{
					szTempBuffer.Format(L"\nNeeded hunters = %d (has %d)", iNeededHunters, iHasHunters);
					szString.append(szTempBuffer);
				}

				int iOurDefense = GET_PLAYER(ePlotOwner).AI_getOurPlotStrength(pPlot, 0, true, false);
				int iEnemyOffense = GET_PLAYER(ePlotOwner).AI_getEnemyPlotStrength(pPlot, 2, false, false);
				if (iEnemyOffense > 0)
				{
					szString.append(CvWString::format(SETCOLR L"\nDanger: %.2f (%d/%d)" ENDCOLR, TEXT_COLOR("COLOR_NEGATIVE_TEXT"),
						(iEnemyOffense * 1.0f) / std::max(1, iOurDefense), iEnemyOffense, iOurDefense));
				}

				CvCity* pCity = pPlot->getPlotCity();
				if (pCity)
				{
					szTempBuffer.Format(L"\n\nCulture Pressure Value = %d", pCity->AI_calculateCulturePressure());
					szString.append(szTempBuffer);

					szTempBuffer.Format(L"\nWater World Percent = %d", pCity->AI_calculateWaterWorldPercent());
					szString.append(szTempBuffer);

					const CvPlayerAI& kPlayer = GET_PLAYER(pCity->getOwner());
					const int64_t iUnitUpkeep = kPlayer.getFinalUnitUpkeep();
					int64_t iTotalCosts = kPlayer.calculatePreInflatedCosts();
					int64_t iUnitCostPercentage = iUnitUpkeep * 100 / std::max<int64_t>(1, iTotalCosts);
					szString.append(CvWString::format(L"\nUnit cost percentage: %I64d (%I64d / %I64d)", iUnitCostPercentage, iUnitUpkeep, iTotalCosts));

					szString.append(CvWString::format(L"\nUpgrade all units: %d gold", kPlayer.AI_goldToUpgradeAllUnits()));

					szString.append(CvWString::format(L"\n\nRanks:"));
					szString.append(CvWString::format(L"\nPopulation:%d", pCity->findPopulationRank()));

					szString.append(CvWString::format(L"\nFood:%d(%d), ", pCity->findYieldRateRank(YIELD_FOOD), pCity->findBaseYieldRateRank(YIELD_FOOD)));
					szString.append(CvWString::format(L"Prod:%d(%d), ", pCity->findYieldRateRank(YIELD_PRODUCTION), pCity->findBaseYieldRateRank(YIELD_PRODUCTION)));
					szString.append(CvWString::format(L"Commerce:%d(%d)", pCity->findYieldRateRank(YIELD_COMMERCE), pCity->findBaseYieldRateRank(YIELD_COMMERCE)));

					szString.append(CvWString::format(L"\nGold:%d, ", pCity->findCommerceRateRank(COMMERCE_GOLD)));
					szString.append(CvWString::format(L"Research:%d, ", pCity->findCommerceRateRank(COMMERCE_RESEARCH)));
					szString.append(CvWString::format(L"Culture:%d", pCity->findCommerceRateRank(COMMERCE_CULTURE)));

					szString.append(CvWString::format(L"\nMilitary Rank:%d", pCity->AI_getMilitaryProductionRateRank()));
					if (pCity->AI_isMilitaryProductionCity())
						szString.append(CvWString::format(L"\nIs Military Production City"));
					szString.append(CvWString::format(L"\nNaval Military Rank:%d", pCity->AI_getNavalMilitaryProductionRateRank()));
					if (pCity->AI_isNavalMilitaryProductionCity())
						szString.append(CvWString::format(L"\nIs Naval Military Production City"));
				}
				szString.append(NEWLINE);

				szTempBuffer.Format(L"Stability Index: %d, Trend: %d",GET_PLAYER(ePlotOwner).getStabilityIndex(),GET_PLAYER(ePlotOwner).getStabilityIndex()-GET_PLAYER(ePlotOwner).getStabilityIndexAverage());
				szString.append(szTempBuffer);
				szString.append(NEWLINE);

				//AI strategies
				if (GET_PLAYER(ePlotOwner).AI_isDoStrategy(AI_STRATEGY_DAGGER))
				{
					szTempBuffer.Format(L"Dagger, ");
					szString.append(szTempBuffer);
				}
				if (GET_PLAYER(ePlotOwner).AI_isDoStrategy(AI_STRATEGY_CRUSH))
				{
					szTempBuffer.Format(L"Crush, ");
					szString.append(szTempBuffer);
				}
				if (GET_PLAYER(ePlotOwner).AI_isDoStrategy(AI_STRATEGY_ALERT1))
				{
					szTempBuffer.Format(L"Alert1, ");
					szString.append(szTempBuffer);
				}
				if (GET_PLAYER(ePlotOwner).AI_isDoStrategy(AI_STRATEGY_ALERT2))
				{
					szTempBuffer.Format(L"Alert2, ");
					szString.append(szTempBuffer);
				}
				if (GET_PLAYER(ePlotOwner).AI_isDoStrategy(AI_STRATEGY_TURTLE))
				{
					szTempBuffer.Format(L"Turtle, ");
					szString.append(szTempBuffer);
				}
				if (GET_PLAYER(ePlotOwner).AI_isDoStrategy(AI_STRATEGY_LAST_STAND))
				{
					szTempBuffer.Format(L"LastStand, ");
					szString.append(szTempBuffer);
				}
				if (GET_PLAYER(ePlotOwner).AI_isDoStrategy(AI_STRATEGY_FINAL_WAR))
				{
					szTempBuffer.Format(L"FinalWar, ");
					szString.append(szTempBuffer);
				}
				if (GET_PLAYER(ePlotOwner).AI_isDoStrategy(AI_STRATEGY_GET_BETTER_UNITS))
				{
					szTempBuffer.Format(L"GetBetterUnits, ");
					szString.append(szTempBuffer);
				}
				if (GET_PLAYER(ePlotOwner).AI_isDoStrategy(AI_STRATEGY_FASTMOVERS))
				{
					szTempBuffer.Format(L"FastMovers, ");
					szString.append(szTempBuffer);
				}
				if (GET_PLAYER(ePlotOwner).AI_isDoStrategy(AI_STRATEGY_LAND_BLITZ))
				{
					szTempBuffer.Format(L"LandBlitz, ");
					szString.append(szTempBuffer);
				}
				if (GET_PLAYER(ePlotOwner).AI_isDoStrategy(AI_STRATEGY_AIR_BLITZ))
				{
					szTempBuffer.Format(L"AirBlitz, ");
					szString.append(szTempBuffer);
				}
				if (GET_PLAYER(ePlotOwner).AI_isDoStrategy(AI_STRATEGY_OWABWNW))
				{
					szTempBuffer.Format(L"OWABWNW, ");
					szString.append(szTempBuffer);
				}
				if (GET_PLAYER(ePlotOwner).AI_isDoStrategy(AI_STRATEGY_PRODUCTION))
				{
					szTempBuffer.Format(L"Production, ");

					szString.append(szTempBuffer);
				}
				if (GET_PLAYER(ePlotOwner).AI_isDoStrategy(AI_STRATEGY_MISSIONARY))
				{
					szTempBuffer.Format(L"Missionary, ");
					szString.append(szTempBuffer);
				}
				if (GET_PLAYER(ePlotOwner).AI_isDoStrategy(AI_STRATEGY_BIG_ESPIONAGE))
				{
					szTempBuffer.Format(L"BigEspionage, ");
					szString.append(szTempBuffer);
				}

				//Area battle plans.
				if (pPlot->area()->getAreaAIType(ePlotTeam) == AREAAI_OFFENSIVE)
				{
					szTempBuffer.Format(L"\n Area AI = OFFENSIVE");
				}
				else if (pPlot->area()->getAreaAIType(ePlotTeam) == AREAAI_DEFENSIVE)
				{
					szTempBuffer.Format(L"\n Area AI = DEFENSIVE");
				}
				else if (pPlot->area()->getAreaAIType(ePlotTeam) == AREAAI_MASSING)
				{
					szTempBuffer.Format(L"\n Area AI = MASSING");
				}
				else if (pPlot->area()->getAreaAIType(ePlotTeam) == AREAAI_ASSAULT)
				{
					szTempBuffer.Format(L"\n Area AI = ASSAULT");
				}
				else if (pPlot->area()->getAreaAIType(ePlotTeam) == AREAAI_ASSAULT_MASSING)
				{
					szTempBuffer.Format(L"\n Area AI = ASSAULT_MASSING");
				}
				else if (pPlot->area()->getAreaAIType(ePlotTeam) == AREAAI_NEUTRAL)
				{
					szTempBuffer.Format(L"\n Area AI = NEUTRAL");
				}

				szString.append(szTempBuffer);
				{
					const int iNumRealWars = plotTeam->getAtWarCount(true);
					if (iNumRealWars != 0)
					{
						szString.append(CvWString::format(L"\n\nNum Wars: %d + %d minor", iNumRealWars, plotTeam->getAtWarCount(false) - iNumRealWars));
					}
				}
				szString.append(CvWString::format(L"\nWarplans:"));

				for (int iI = 0; iI < MAX_PC_TEAMS; ++iI)
				{
					const TeamTypes eTeamX = static_cast<TeamTypes>(iI);
					const CvTeam& teamX = GET_TEAM(eTeamX);

					if (teamX.isAlive())
					{
						if (plotTeam->AI_getWarPlan(eTeamX) == WARPLAN_ATTACKED)
						{
							szString.append(CvWString::format(L"\n%s: ATTACKED", teamX.getName().c_str()));
						}
						else if (plotTeam->AI_getWarPlan(eTeamX) == WARPLAN_ATTACKED_RECENT)
						{
							szString.append(CvWString::format(L"\n%s: ATTACKED_RECENT", teamX.getName().c_str()));
						}
						else if (plotTeam->AI_getWarPlan(eTeamX) == WARPLAN_PREPARING_LIMITED)
						{
							szString.append(CvWString::format(L"\n%s: PREP_LIM", teamX.getName().c_str()));
						}
						else if (plotTeam->AI_getWarPlan(eTeamX) == WARPLAN_PREPARING_TOTAL)
						{
							szString.append(CvWString::format(L"\n%s: PREP_TOTAL", teamX.getName().c_str()));
						}
						else if (plotTeam->AI_getWarPlan(eTeamX) == WARPLAN_LIMITED)
						{
							szString.append(CvWString::format(L"\n%s: LIMITED", teamX.getName().c_str()));
						}
						else if (plotTeam->AI_getWarPlan(eTeamX) == WARPLAN_TOTAL)
						{
							szString.append(CvWString::format(L"\n%s: TOTAL", teamX.getName().c_str()));
						}
						else if (plotTeam->AI_getWarPlan(eTeamX) == WARPLAN_DOGPILE)
						{
							szString.append(CvWString::format(L"\n%s: DOGPILE", teamX.getName().c_str()));
						}
						else if (plotTeam->AI_getWarPlan(eTeamX) == NO_WARPLAN && plotTeam->isAtWar(eTeamX))
						{
							szString.append(CvWString::format(SETCOLR L"\n%s: NO_WARPLAN!" ENDCOLR, TEXT_COLOR("COLOR_WARNING_TEXT"), teamX.getName().c_str()));
						}
					}

					if (ePlotTeam != eTeamX && (plotTeam->isMinorCiv() || plotTeam->isNPC()) && !plotTeam->isAtWar(eTeamX))
					{
						szString.append(CvWString::format(SETCOLR L"\n%s: minor/npc not at war!" ENDCOLR, TEXT_COLOR("COLOR_WARNING_TEXT"), teamX.getName().c_str()));
					}
				}

				CvCity* pTargetCity = pPlot->area()->getTargetCity(ePlotOwner);
				if( pTargetCity )
				{
					szString.append(CvWString::format(L"\nTarget City: %s", pTargetCity->getName().c_str()));
				}
				else
				{
					szString.append(CvWString::format(L"\nTarget City: None"));
				}
			}
		}
		else if (bShift && bAlt)
		{
			CvCity*	pCity = pPlot->getWorkingCity();
			if (pCity)
			{
				// some functions we want to call are not in CvCity, worse some are protected, so made us a friend
				CvCityAI* pCityAI = static_cast<CvCityAI*>(pCity);

				bool bAvoidGrowth = pCity->AI_avoidGrowth();
				bool bIgnoreGrowth = pCityAI->AI_ignoreGrowth();

				// if we over the city, then do an array of all the plots
				if (pPlot->getPlotCity())
				{
					// check avoid growth
					if (bAvoidGrowth || bIgnoreGrowth)
					{
						// red color
						szString.append(CvWString::format(SETCOLR, TEXT_COLOR("COLOR_NEGATIVE_TEXT")));

						if (bAvoidGrowth)
						{
							szString.append(CvWString::format(L"AvoidGrowth"));

							if (bIgnoreGrowth)
								szString.append(CvWString::format(L", "));
						}

						if (bIgnoreGrowth)
							szString.append(CvWString::format(L"IgnoreGrowth"));

						// end color
						szString.append(CvWString::format( ENDCOLR L"\n" ));
					}

					// if control key is down, ignore food
					bool bIgnoreFood = gDLL->ctrlKey();

					// line one is: blank, 20, 9, 10, blank
					setCityPlotYieldValueString(szString, pCity, -1, bAvoidGrowth, bIgnoreGrowth, bIgnoreFood);
					setCityPlotYieldValueString(szString, pCity, 20, bAvoidGrowth, bIgnoreGrowth, bIgnoreFood);
					setCityPlotYieldValueString(szString, pCity, 9, bAvoidGrowth, bIgnoreGrowth, bIgnoreFood);
					setCityPlotYieldValueString(szString, pCity, 10, bAvoidGrowth, bIgnoreGrowth, bIgnoreFood);
					szString.append(L"\n");

					// line two is: 19, 8, 1, 2, 11
					setCityPlotYieldValueString(szString, pCity, 19, bAvoidGrowth, bIgnoreGrowth, bIgnoreFood);
					setCityPlotYieldValueString(szString, pCity, 8, bAvoidGrowth, bIgnoreGrowth, bIgnoreFood);
					setCityPlotYieldValueString(szString, pCity, 1, bAvoidGrowth, bIgnoreGrowth, bIgnoreFood);
					setCityPlotYieldValueString(szString, pCity, 2, bAvoidGrowth, bIgnoreGrowth, bIgnoreFood);
					setCityPlotYieldValueString(szString, pCity, 11, bAvoidGrowth, bIgnoreGrowth, bIgnoreFood);
					szString.append(L"\n");

					// line three is: 18, 7, 0, 3, 12
					setCityPlotYieldValueString(szString, pCity, 18, bAvoidGrowth, bIgnoreGrowth, bIgnoreFood);
					setCityPlotYieldValueString(szString, pCity, 7, bAvoidGrowth, bIgnoreGrowth, bIgnoreFood);
					setCityPlotYieldValueString(szString, pCity, 0, bAvoidGrowth, bIgnoreGrowth, bIgnoreFood);
					setCityPlotYieldValueString(szString, pCity, 3, bAvoidGrowth, bIgnoreGrowth, bIgnoreFood);
					setCityPlotYieldValueString(szString, pCity, 12, bAvoidGrowth, bIgnoreGrowth, bIgnoreFood);
					szString.append(L"\n");

					// line four is: 17, 6, 5, 4, 13
					setCityPlotYieldValueString(szString, pCity, 17, bAvoidGrowth, bIgnoreGrowth, bIgnoreFood);
					setCityPlotYieldValueString(szString, pCity, 6, bAvoidGrowth, bIgnoreGrowth, bIgnoreFood);
					setCityPlotYieldValueString(szString, pCity, 5, bAvoidGrowth, bIgnoreGrowth, bIgnoreFood);
					setCityPlotYieldValueString(szString, pCity, 4, bAvoidGrowth, bIgnoreGrowth, bIgnoreFood);
					setCityPlotYieldValueString(szString, pCity, 13, bAvoidGrowth, bIgnoreGrowth, bIgnoreFood);
					szString.append(L"\n");

					// line five is: blank, 16, 15, 14, blank
					setCityPlotYieldValueString(szString, pCity, -1, bAvoidGrowth, bIgnoreGrowth, bIgnoreFood);
					setCityPlotYieldValueString(szString, pCity, 16, bAvoidGrowth, bIgnoreGrowth, bIgnoreFood);
					setCityPlotYieldValueString(szString, pCity, 15, bAvoidGrowth, bIgnoreGrowth, bIgnoreFood);
					setCityPlotYieldValueString(szString, pCity, 14, bAvoidGrowth, bIgnoreGrowth, bIgnoreFood);

					// show specialist values too
					for (int iI = 0; iI < GC.getNumSpecialistInfos(); ++iI)
					{
						int iMaxThisSpecialist = pCity->getMaxSpecialistCount((SpecialistTypes) iI);
						int iSpecialistCount = pCity->getSpecialistCount((SpecialistTypes) iI);
						bool bUsingSpecialist = (iSpecialistCount > 0);
						bool bIsDefaultSpecialist = (iI == GC.getDefineINT("DEFAULT_SPECIALIST"));

						// can this city have any of this specialist?
						if (iMaxThisSpecialist > 0 || bIsDefaultSpecialist)
						{
							// start color
							if (pCity->getForceSpecialistCount((SpecialistTypes) iI) > 0)
								szString.append(CvWString::format(L"\n" SETCOLR, TEXT_COLOR("COLOR_NEGATIVE_TEXT")));
							else if (bUsingSpecialist)
								szString.append(CvWString::format(L"\n" SETCOLR, TEXT_COLOR("COLOR_ALT_HIGHLIGHT_TEXT")));
							else
								szString.append(CvWString::format(L"\n" SETCOLR, TEXT_COLOR("COLOR_HIGHLIGHT_TEXT")));

							// add name
							szString.append(GC.getSpecialistInfo((SpecialistTypes) iI).getDescription());

							// end color
							szString.append(CvWString::format( ENDCOLR ));

							// add usage
							szString.append(CvWString::format(L": (%d/%d) ", iSpecialistCount, iMaxThisSpecialist));

							// add value
							int iValue = pCityAI->AI_specialistValue(((SpecialistTypes) iI), bAvoidGrowth, /*bRemove*/ bUsingSpecialist);
							setYieldValueString(szString, iValue, /*bActive*/ bUsingSpecialist);
						}
					}
					int iFood = GET_PLAYER(pCity->getOwner()).AI_averageYieldMultiplier(YIELD_FOOD);
					int iHammer = GET_PLAYER(pCity->getOwner()).AI_averageYieldMultiplier(YIELD_PRODUCTION);
					int iCommerce = GET_PLAYER(pCity->getOwner()).AI_averageYieldMultiplier(YIELD_COMMERCE);

					szString.append(CvWString::format(L"\nPlayer avg:	   (f%d, h%d, c%d)", iFood, iHammer, iCommerce));

					iFood = pCity->AI_yieldMultiplier(YIELD_FOOD);
					iHammer = pCity->AI_yieldMultiplier(YIELD_PRODUCTION);
					iCommerce = pCity->AI_yieldMultiplier(YIELD_COMMERCE);

					szString.append(CvWString::format(L"\nCity yield mults: (f%d, h%d, c%d)", iFood, iHammer, iCommerce));

					iFood = pCityAI->AI_specialYieldMultiplier(YIELD_FOOD);
					iHammer = pCityAI->AI_specialYieldMultiplier(YIELD_PRODUCTION);
					iCommerce = pCityAI->AI_specialYieldMultiplier(YIELD_COMMERCE);

					szString.append(CvWString::format(L"\nCity spec mults:  (f%d, h%d, c%d)", iFood, iHammer, iCommerce));

					szString.append(CvWString::format(L"\nExchange"));
					for (int iI = 0; iI < NUM_COMMERCE_TYPES; ++iI)
					{
						iCommerce = GET_PLAYER(pCity->getOwner()).AI_averageCommerceExchange((CommerceTypes)iI);
						szTempBuffer.Format(L", %d%c", iCommerce, GC.getCommerceInfo((CommerceTypes) iI).getChar());
						szString.append(szTempBuffer);
					}

					szString.append(CvWString::format(L"\nAvg mults"));
					for (int iI = 0; iI < NUM_COMMERCE_TYPES; ++iI)
					{
						iCommerce = GET_PLAYER(pCity->getOwner()).AI_averageCommerceMultiplier((CommerceTypes)iI);
						szTempBuffer.Format(L", %d%c", iCommerce, GC.getCommerceInfo((CommerceTypes) iI).getChar());
						szString.append(szTempBuffer);
					}

					if (GET_PLAYER(pCity->getOwner()).AI_isFinancialTrouble())
					{
						szTempBuffer.Format(L"$$$!!!");
						szString.append(szTempBuffer);
					}
				}
				else
				{
					bool bWorkingPlot = pCity->isWorkingPlot(pPlot);

					if (bWorkingPlot)
						szTempBuffer.Format( SETCOLR L"%s is working" ENDCOLR, TEXT_COLOR("COLOR_ALT_HIGHLIGHT_TEXT"), pCity->getName().GetCString());
					else
						szTempBuffer.Format( SETCOLR L"%s not working" ENDCOLR, TEXT_COLOR("COLOR_HIGHLIGHT_TEXT"), pCity->getName().GetCString());
					szString.append(szTempBuffer);

					int iValue = pCityAI->AI_plotValue(pPlot, bAvoidGrowth, /*bRemove*/ bWorkingPlot, /*bIgnoreFood*/ false, bIgnoreGrowth);
					int iJuggleValue = pCityAI->AI_plotValue(pPlot, bAvoidGrowth, /*bRemove*/ bWorkingPlot, false, bIgnoreGrowth, true);
					int iMagicValue = pCityAI->AI_getPlotMagicValue(pPlot, pCityAI->healthRate() == 0);

					szTempBuffer.Format(L"\nvalue = %d\njuggle value = %d\nmagic value = %d", iValue, iJuggleValue, iMagicValue);
					szString.append(szTempBuffer);
				}
			}

			// calc some bonus info
			const BonusTypes eBonus = pPlot->getBonusType();
			if (eBonus != NO_BONUS)
			{
				szString.append(CvWString::format(L"\n%s values:", GC.getBonusInfo(eBonus).getDescription()));

				for (int iPlayerIndex = 0; iPlayerIndex < MAX_PLAYERS; iPlayerIndex++)
				{
					CvPlayerAI& kLoopPlayer = GET_PLAYER((PlayerTypes) iPlayerIndex);
					if (kLoopPlayer.isAlive())
					{
						BonusTypes eNonObsBonus = pPlot->getNonObsoleteBonusType(kLoopPlayer.getTeam());
						if (eNonObsBonus != NO_BONUS)
						{
							szString.append(CvWString::format(L"\n %s: %d", kLoopPlayer.getName(), kLoopPlayer.AI_bonusVal(eNonObsBonus)));
						}
						else
						{
							szString.append(CvWString::format(L"\n %s: unknown (%d)", kLoopPlayer.getName(), kLoopPlayer.AI_bonusVal(eBonus)));
						}
					}
				}
			}
		}
		else
		{
			if (ePlotOwner != NO_PLAYER)
			{
				const CvPlayer& pOwner = GET_PLAYER(ePlotOwner);

				szTempBuffer.Format(
					SETCOLR L"%s: %s" ENDCOLR,
					pOwner.getPlayerTextColorR(), pOwner.getPlayerTextColorG(), pOwner.getPlayerTextColorB(), pOwner.getPlayerTextColorA(),
					gDLL->getText("TXT_KEY_MISC_OWNER").GetCString(), pOwner.getCivilizationShortDescription()
				);
				{
					const CvCity* pWorkingCity = pPlot->getWorkingCity();

					if (pWorkingCity && pWorkingCity->getOwner() == eActivePlayer)
					{
						szTempBuffer.append(L", ");

						if (pWorkingCity->isWorkingPlot(pPlot))
						{
							szTempBuffer.append(CvWString::format(SETCOLR L"%s" ENDCOLR, TEXT_COLOR("COLOR_HIGHLIGHT_TEXT"), pWorkingCity->getName().GetCString()));
						}
						else
						{
							szTempBuffer.append(CvWString::format(L"%s", pWorkingCity->getName().GetCString()));
						}
					}
				}
				szString.append(szTempBuffer);
				szString.append(
					CvWString::format(
						L"\n%d%% " SETCOLR L"%s" ENDCOLR L" (%d",
						pPlot->calculateCulturePercent(ePlotOwner),
						pOwner.getPlayerTextColorR(), pOwner.getPlayerTextColorG(), pOwner.getPlayerTextColorB(), pOwner.getPlayerTextColorA(),
						pOwner.getCivilizationAdjective(), pPlot->getCulture(ePlotOwner)
					)
				);

				const int iRate = pPlot->getCultureRateLastTurn(ePlotOwner);
				if (iRate > 0)
				{
					szString.append(CvWString::format(L" + %d)\n", iRate));
				}
				else if (iRate < 0)
				{
					szString.append(CvWString::format(L" - %d)\n", -iRate));
				}
				else
				{
					szString.append(L")\n");
				}
				if (!pPlot->isInCultureRangeOfCityByPlayer(ePlotOwner))
				{
					szString.append(gDLL->getText("TXT_KEY_BULLET"));
					szString.append(gDLL->getText("TXT_KEY_MISC_NO_CITY_INFLUENCE", pOwner.getCivilizationAdjective()));
					szString.append(NEWLINE);
				}
			}
			for (int iI = 0; iI < MAX_PLAYERS; iI++)
			{
				const PlayerTypes ePlayerX = static_cast<PlayerTypes>(iI);
				if ((ePlotOwner == NO_PLAYER || ePlayerX != ePlotOwner) && pPlot->getCulture(ePlayerX) > 0)
				{
					const CvPlayer& playerX = GET_PLAYER(ePlayerX);
					szString.append(
						CvWString::format(
							L"%d%% " SETCOLR L"%s" ENDCOLR L" (%d",
							pPlot->calculateCulturePercent(ePlayerX),
							playerX.getPlayerTextColorR(), playerX.getPlayerTextColorG(), playerX.getPlayerTextColorB(), playerX.getPlayerTextColorA(),
							playerX.getCivilizationAdjective(), pPlot->getCulture(ePlayerX)
						)
					);

					const int iRate = pPlot->getCultureRateLastTurn(ePlayerX);
					if (iRate > 0)
					{
						szString.append(CvWString::format(L" + %d)\n", iRate));
					}
					else if (iRate < 0)
					{
						szString.append(CvWString::format(L" - %d)\n", -iRate));
					}
					else
					{
						szString.append(L")\n");
					}
					if (!pPlot->isInCultureRangeOfCityByPlayer(ePlayerX))
					{
						szString.append(gDLL->getText("TXT_KEY_BULLET"));
						szString.append(gDLL->getText("TXT_KEY_MISC_NO_CITY_INFLUENCE", playerX.getCivilizationAdjective()));
						szString.append(NEWLINE);
					}
				}
			}
		}
	}
	else
	{
		const PlayerTypes eRevealOwner = pPlot->getRevealedOwner(eActiveTeam, true);

		if (pPlot->isActiveVisible(true))
		{
			if (eRevealOwner != NO_PLAYER)
			{
				const CvPlayer& pOwner = GET_PLAYER(eRevealOwner);

				szTempBuffer.Format(SETCOLR L"%s: %s" ENDCOLR,
					pOwner.getPlayerTextColorR(), pOwner.getPlayerTextColorG(), pOwner.getPlayerTextColorB(), pOwner.getPlayerTextColorA(),
					gDLL->getText("TXT_KEY_MISC_OWNER").GetCString(), pOwner.getCivilizationShortDescription());

				if (getBugOptionBOOL("MiscHover__PlotWorkingCity", true, "BUG_PLOT_HOVER_WORKING_CITY"))
				{
					const CvCity* pWorkingCity = pPlot->getWorkingCity();

					if (pWorkingCity && pWorkingCity->getOwner() == eActivePlayer)
					{
						szTempBuffer.append(L", ");

						if (pWorkingCity->isWorkingPlot(pPlot))
						{
							szTempBuffer.append(CvWString::format(SETCOLR L"%s" ENDCOLR, TEXT_COLOR("COLOR_HIGHLIGHT_TEXT"), pWorkingCity->getName().GetCString()));
						}
						else
						{
							szTempBuffer.append(CvWString::format(L"%s", pWorkingCity->getName().GetCString()));
						}
					}
				}
				szString.append(szTempBuffer);
				szString.append(
					CvWString::format(
						L"\n%d%% " SETCOLR L"%s" ENDCOLR L" (%d", pPlot->calculateCulturePercent(eRevealOwner),
						pOwner.getPlayerTextColorR(), pOwner.getPlayerTextColorG(), pOwner.getPlayerTextColorB(), pOwner.getPlayerTextColorA(),
						pOwner.getCivilizationAdjective(), pPlot->getCulture(eRevealOwner)
					)
				);

				const int iRate = pPlot->getCultureRateLastTurn(ePlotOwner);
				if (iRate > 0)
				{
					szString.append(CvWString::format(L" + %d)\n", iRate));
				}
				else if (iRate < 0)
				{
					szString.append(CvWString::format(L" - %d)\n", -iRate));
				}
				else
				{
					szString.append(L")\n");
				}
				if (!pPlot->isInCultureRangeOfCityByPlayer(ePlotOwner))
				{
					szString.append(gDLL->getText("TXT_KEY_BULLET"));
					szString.append(gDLL->getText("TXT_KEY_MISC_NO_CITY_INFLUENCE", pOwner.getCivilizationAdjective()));
					szString.append(NEWLINE);
				}
			}
			for (int iI = 0; iI < MAX_PLAYERS; iI++)
			{
				const PlayerTypes ePlayerX = static_cast<PlayerTypes>(iI);
				if ((eRevealOwner == NO_PLAYER || ePlayerX != eRevealOwner) && pPlot->getCulture(ePlayerX) > 0)
				{
					const CvPlayer& playerX = GET_PLAYER(ePlayerX);
					if (playerX.isAlive())
					{
						szString.append(CvWString::format(L"%d%% " SETCOLR L"%s" ENDCOLR L" (%d", pPlot->calculateCulturePercent(ePlayerX),
							playerX.getPlayerTextColorR(), playerX.getPlayerTextColorG(), playerX.getPlayerTextColorB(), playerX.getPlayerTextColorA(),
							playerX.getCivilizationAdjective(), pPlot->getCulture(ePlayerX)));
					}

					const int iRate = pPlot->getCultureRateLastTurn(ePlayerX);
					if (iRate > 0)
					{
						szString.append(CvWString::format(L" + %d)\n", iRate));
					}
					else if (iRate < 0)
					{
						szString.append(CvWString::format(L" - %d)\n", -iRate));
					}
					else
					{
						szString.append(L")\n");
					}
					if (!pPlot->isInCultureRangeOfCityByPlayer(ePlayerX))
					{
						szString.append(gDLL->getText("TXT_KEY_BULLET"));
						szString.append(gDLL->getText("TXT_KEY_MISC_NO_CITY_INFLUENCE", playerX.getCivilizationAdjective()));
						szString.append(NEWLINE);
					}
				}
			}
		}
		else if (eRevealOwner != NO_PLAYER)
		{
			szTempBuffer.Format(SETCOLR L"%s" ENDCOLR, GET_PLAYER(eRevealOwner).getPlayerTextColorR(), GET_PLAYER(eRevealOwner).getPlayerTextColorG(), GET_PLAYER(eRevealOwner).getPlayerTextColorB(), GET_PLAYER(eRevealOwner).getPlayerTextColorA(), GET_PLAYER(eRevealOwner).getCivilizationDescription());
			szString.append(szTempBuffer);
			szString.append(NEWLINE);
		}

		if (GC.getGame().isOption(GAMEOPTION_COMBAT_HIDE_SEEK))
		{
			bool bFirst = true;

			for (int iJ = 0; iJ < GC.getNumInvisibleInfos(); iJ++)
			{
				const InvisibleTypes eTypeX = static_cast<InvisibleTypes>(iJ);

				if (!pPlot->isSpotterInSight(eActiveTeam, eTypeX)
				|| GC.getInvisibleInfo(eTypeX).isIntrinsic() && !GC.getGame().isOption(GAMEOPTION_COMBAT_SIZE_MATTERS))
				{
					continue;
				}
				const int iSpotIntensity = pPlot->getHighestPlotTeamVisibilityIntensity(eTypeX, eActiveTeam);

				if (iSpotIntensity > 0 || GC.getInvisibleInfo(eTypeX).isIntrinsic())
				{
					if (bFirst)
					{
						szString.append(gDLL->getText("TXT_KEY_S1_COLON_SPACE", L"TXT_WORD_SPOT"));
						bFirst = false;
					}
					else
					{
						szString.append(L", ");
					}
					szString.append(CvWString::format(L"%d%c", iSpotIntensity, GC.getInvisibleInfo(eTypeX).getChar()));
				}
			}
			if (!bFirst)
			{
				szString.append(NEWLINE);
			}
		}
		const int iDefenseModifier = pPlot->defenseModifier(eRevealOwner != NO_PLAYER ? GET_PLAYER(eRevealOwner).getTeam() : NO_TEAM, true, true);
		if (iDefenseModifier != 0)
		{
			szString.append(gDLL->getText("TXT_KEY_PLOT_BONUS", iDefenseModifier));
			szString.append(NEWLINE);
		}

		if (pPlot->getTerrainType() != NO_TERRAIN)
		{
			if (pPlot->isPeak())
			{
				szString.append(gDLL->getText("TXT_WORD_PEAK"));
				szString.append(L"/");
			}
			else if (pPlot->isWater())
			{
				szTempBuffer.Format(SETCOLR, TEXT_COLOR("COLOR_WATER_TEXT"));
				szString.append(szTempBuffer);
			}
			else if (pPlot->isHills())
			{
				szString.append(gDLL->getText("TXT_WORD_HILL"));
				szString.append(L"/");
			}

			if (pPlot->getFeatureType() != NO_FEATURE)
			{
				szTempBuffer.Format(L"%s/", GC.getFeatureInfo(pPlot->getFeatureType()).getDescription());
				szString.append(szTempBuffer);
			}

			szString.append(GC.getTerrainInfo(pPlot->getTerrainType()).getDescription());

			if (pPlot->isWater())
			{
				szString.append(ENDCOLR);
			}
		}

		if (pPlot->hasYield())
		{
			for (int iI = 0; iI < NUM_YIELD_TYPES; ++iI)
			{
				const int iYield = pPlot->calculateYield(((YieldTypes)iI), true);

				if (iYield != 0)
				{
					szTempBuffer.Format(L", %d%c", iYield, GC.getYieldInfo((YieldTypes) iI).getChar());
					szString.append(szTempBuffer);
				}
			}
		}

		if (pPlot->isFreshWater() && !pPlot->isWater())
		{
			szString.append(NEWLINE);
			szString.append(gDLL->getText("TXT_KEY_PLOT_FRESH_WATER"));
		}

		if (pPlot->isImpassable(eActiveTeam))
		{
			szString.append(NEWLINE);
			szString.append(gDLL->getText("TXT_KEY_PLOT_IMPASSABLE"));
		}
		else
		{
			int iMovementCost = GC.getTerrainInfo(pPlot->getTerrainType()).getMovementCost();

			if (pPlot->getFeatureType() != NO_FEATURE)
			{
				iMovementCost += GC.getFeatureInfo(pPlot->getFeatureType()).getMovementCost();
			}

			if (pPlot->isHills())
			{
				iMovementCost += GC.getHILLS_EXTRA_MOVEMENT();
			}

			if (pPlot->isAsPeak())
			{
				if (!GET_TEAM(eActiveTeam).isMoveFastPeaks())
				{
					iMovementCost += GC.getPEAK_EXTRA_MOVEMENT();
				}
				iMovementCost += 3;
			}

			if (iMovementCost != 0)
			{
				szString.append(gDLL->getText("TXT_KEY_PLOT_MOVEMENT_COST", iMovementCost));
			}
		}

		if (pPlot->getRevealedRouteType(eActiveTeam, true) != NO_ROUTE)
		{
			const RouteTypes eRouteType = pPlot->getRevealedRouteType(eActiveTeam, true);
			const CvRouteInfo& eRoute = GC.getRouteInfo(eRouteType);
			const int iRouteCost = eRoute.getMovementCost() + GET_TEAM(eActiveTeam).getRouteChange(eRouteType);

			szTempBuffer.clear();
			szTempBuffer.Format(L"%.2f%c ", (float)iRouteCost / GC.getMOVE_DENOMINATOR(), gDLL->getSymbolID(MOVES_CHAR));

			szString.append(gDLL->getText("TXT_KEY_PLOT_ROUTE_MOVEMENT_COST", szTempBuffer.GetCString(), eRoute.getDescription()));
		}

		{
			const BonusTypes eBonus = bDebug ? pPlot->getBonusType() : pPlot->getBonusType(eActiveTeam);

			if (eBonus != NO_BONUS)
			{
				const CvBonusInfo& bonus = GC.getBonusInfo(eBonus);

				szTempBuffer.Format(L"%c " SETCOLR L"%s" ENDCOLR, bonus.getChar(), TEXT_COLOR("COLOR_HIGHLIGHT_TEXT"), bonus.getDescription());
				szString.append(NEWLINE);
				szString.append(szTempBuffer);

				if (bonus.getHealth() != 0)
				{
					szTempBuffer.Format(L", +%d%c", abs(bonus.getHealth()), bonus.getHealth() > 0 ? gDLL->getSymbolID(HEALTHY_CHAR) : gDLL->getSymbolID(UNHEALTHY_CHAR));
					szString.append(szTempBuffer);
				}

				if (bonus.getHappiness() != 0)
				{
					szTempBuffer.Format(L", +%d%c", abs(bonus.getHappiness()), bonus.getHappiness() > 0 ? gDLL->getSymbolID(HAPPY_CHAR) : gDLL->getSymbolID(UNHAPPY_CHAR));
					szString.append(szTempBuffer);
				}

				if (!GET_TEAM(eActiveTeam).isHasTech((TechTypes)bonus.getTechCityTrade()))
				{
					szString.append(gDLL->getText("TXT_KEY_PLOT_RESEARCH", GC.getTechInfo((TechTypes)bonus.getTechCityTrade()).getTextKeyWide()));
				}

				if (ePlotOwner == eActivePlayer
				&& (pPlot->getImprovementType() == NO_IMPROVEMENT || !bonus.isProvidedByImprovementType(pPlot->getImprovementType())))
				{
					bool bKnowsValid = false;
					TechTypes eMostRecentObsoletingTech = NO_TECH;
					int iMostRecentX = 0;
					TechTypes eClosestUnlockingTech = NO_TECH;
					int iClosestX = MAX_INT;

					for (int iI = bonus.getNumProvidedByImprovementTypes() - 1; iI > -1; iI--)
					{
						const ImprovementTypes eTypeX = bonus.getProvidedByImprovementType(iI);

						if (pPlot->canHaveImprovement(eTypeX, eActiveTeam, true))
						{
							const CvImprovementInfo& improvement = GC.getImprovementInfo(eTypeX);

							foreach_(const BuildTypes& eBuild, improvement.getBuildTypes())
							{
								const CvBuildInfo& kBuild = GC.getBuildInfo(eBuild);

								const TechTypes eObsoleteTech = kBuild.getObsoleteTech();

								if (eObsoleteTech != NO_TECH && GET_TEAM(eActiveTeam).isHasTech(eObsoleteTech))
								{
									if (GC.getTechInfo(eObsoleteTech).getGridX() > iMostRecentX)
									{
										iMostRecentX = GC.getTechInfo(eObsoleteTech).getGridX();
										eMostRecentObsoletingTech = eObsoleteTech;
									}
									continue;
								}
								const TechTypes eTechPrereq = kBuild.getTechPrereq();

								if (eTechPrereq == NO_TECH || GET_TEAM(eActiveTeam).isHasTech(eTechPrereq))
								{
									if (!bKnowsValid)
									{
										szString.append(gDLL->getText("TXT_KEY_PLOT_REQUIRES", improvement.getTextKeyWide()));
										bKnowsValid = true;
									}
									else
									{
										szString.append(gDLL->getText("TXT_KEY_PLOT_REQUIRES_OR", improvement.getTextKeyWide()));
									}
									for (int iK = 0; iK < NUM_YIELD_TYPES; iK++)
									{
										const int iYieldChange = improvement.getImprovementBonusYield(eBonus, iK) + improvement.getYieldChange(iK);
										if (iYieldChange != 0)
										{
											iYieldChange > 0 ?
												szTempBuffer.Format(L"+%d%c", iYieldChange, GC.getYieldInfo((YieldTypes)iK).getChar())
												:
												szTempBuffer.Format(L"%d%c", iYieldChange, GC.getYieldInfo((YieldTypes)iK).getChar());

											setListHelp(szString, L"\n", szTempBuffer, L", ", true);
											szString.append(gDLL->getText("TXT_KEY_BONUSHELP_WITH_IMPROVEMENT", improvement.getTextKeyWide()));
										}
									}
									break;
								}
								if (GET_PLAYER(eActivePlayer).canResearch(eTechPrereq, false) && iClosestX > GC.getTechInfo(eTechPrereq).getGridX())
								{
									iClosestX = GC.getTechInfo(eTechPrereq).getGridX();
									eClosestUnlockingTech = eTechPrereq;
								}
							}
						}
					}
					if (!bKnowsValid)
					{
						if (eClosestUnlockingTech != NO_TECH)
						{
							szString.append(gDLL->getText("TXT_KEY_PLOT_RESEARCH", GC.getTechInfo(eClosestUnlockingTech).getTextKeyWide()));
						}
						else if (eMostRecentObsoletingTech != NO_TECH)
						{
							szString.append(gDLL->getText("TXT_KEY_BUILDINGHELP_OBSOLETE_WITH",
								CvWString(GC.getTechInfo(eMostRecentObsoletingTech).getType()).GetCString(),
								GC.getTechInfo(eMostRecentObsoletingTech).getTextKeyWide()));
						}
					}
				}
				else if (!(pPlot->isBonusNetwork(eActiveTeam)))
				{
					szString.append(gDLL->getText("TXT_KEY_PLOT_REQUIRES_ROUTE"));
				}

				GC.getBonusInfo(eBonus).getPropertyManipulators()->buildDisplayString(szString);

				if (!CvWString(bonus.getHelp()).empty())
				{
					szString.append(NEWLINE);
					szString.append(bonus.getHelp());
				}
			}
		}

		{
			const ImprovementTypes eImprovement = pPlot->getRevealedImprovementType(eActiveTeam, true);

			if (eImprovement != NO_IMPROVEMENT)
			{
				const CvImprovementInfo& impInfo = GC.getImprovementInfo(eImprovement);
				szString.append(NEWLINE);
				szString.append(impInfo.getDescription());

				for (int iI = 0; iI < NUM_YIELD_TYPES; ++iI)
				{
					if (impInfo.getIrrigatedYieldChange(iI) != 0)
					{
						(
							pPlot->isIrrigationAvailable()
							?
							szString.append(gDLL->getText("TXT_KEY_PLOT_IRRIGATED"))
							:
							szString.append(gDLL->getText("TXT_KEY_PLOT_NOT_IRRIGATED"))
						);
						break;
					}
				}
				if (pPlot->isImprovementUpgradable() && (ePlotTeam == eActiveTeam || bDebug && ePlotTeam != NO_TEAM))
				{
					bool bOpenParenthesis = false;
					bool bImpUpgList = false;
					szTempBuffer.clear();
					for (int iI = -1; iI < impInfo.getNumAlternativeImprovementUpgradeTypes(); iI++)
					{
						const ImprovementTypes eUpgradeX =
						(
							iI == -1 ? impInfo.getImprovementUpgrade()
							:
							(ImprovementTypes)impInfo.getAlternativeImprovementUpgradeType(iI)
						);
						if (pPlot->canHaveImprovement(eUpgradeX, ePlotTeam, false, true))
						{
							if (!bImpUpgList)
							{
								szTempBuffer.append(CvWString::format(L" (%s", GC.getImprovementInfo(eUpgradeX).getDescription()));
								bImpUpgList = true;
							}
							else
							{
								szTempBuffer.append(CvWString::format(L", %s", GC.getImprovementInfo(eUpgradeX).getDescription()));
							}
						}
					}
					if (pPlot->getImprovementUpgradeProgress() >= 100*GC.getGame().getImprovementUpgradeTime(eImprovement))
					{
						szString.append(gDLL->getText("TXT_KEY_IMPROVEMENTHELP_UPGRADE_FROZEN"));
					}
					else if (!bImpUpgList)
					{
						szString.append(gDLL->getText("TXT_KEY_IMPROVEMENTHELP_UPGRADE_BLOCKED"));
					}
					else
					{
						const bool bUpgrading =
						(
							impInfo.isUpgradeRequiresFortify()
							?
							algo::any_of
							(
								pPlot->units(),
								CvUnit::fn::getFortifyTurns() > 0
								&&
								CvUnit::fn::getTeam() == ePlotTeam
								&&
								CvUnit::fn::canDefend()
							)
							:
							pPlot->isBeingWorked()
						);

						if (pPlot->getImprovementUpgradeProgress() > 0 || bUpgrading)
						{
							bOpenParenthesis = true;
							szString.append
							(
								gDLL->getText
								(
									"TXT_KEY_IMPROVEMENTHELP_UPGRADE_TURNS",
									pPlot->getUpgradeTimeLeft(eImprovement, eRevealOwner)
								)
							);
						}
						if (!bUpgrading)
						{
							if (impInfo.isUpgradeRequiresFortify())
							{
								szString.append(gDLL->getText("TXT_KEY_IMPROVEMENTHELP_UPGRADE_NEED_GARRISON"));
							}
							else if (pPlot->isWithinTeamCityRadius(ePlotTeam))
							{
								szString.append(gDLL->getText("TXT_KEY_IMPROVEMENTHELP_UPGRADE_NEED_WORK"));
							}
						}
					}
					if (bImpUpgList)
					{
						szString.append(szTempBuffer.append(L")"));
						if (bOpenParenthesis) szString.append(L")");
					}
				}
			}
		}

		if (bDebug || GET_TEAM(eActiveTeam).isMapCentering()
		&& getBugOptionBOOL("MiscHover__LatLongCoords", true, "BUG_PLOT_HOVER_LAT_LONG"))
		{
			bool bWest = false;
			int iLong = pPlot->getLongitudeMinutes();
			if (iLong < 0)
			{
				iLong = -iLong;
				bWest = true;
			}
			szString.append(NEWLINE);
			szString.append(gDLL->getText("TXT_KEY_LATLONG", iLong / 60, iLong % 60));
			(
				bWest
				?
				szString.append(gDLL->getText("TXT_KEY_LATLONG_WEST"))
				:
				szString.append(gDLL->getText("TXT_KEY_LATLONG_EAST"))
			);
			bool bSouth = false;
			int iLat = pPlot->getLatitudeMinutes();
			if (iLat < 0)
			{
				iLat = -iLat;
				bSouth = true;
			}
			szString.append(L", ");
			szString.append(gDLL->getText("TXT_KEY_LATLONG", iLat / 60, iLat % 60));
			(
				bSouth
				?
				szString.append(gDLL->getText("TXT_KEY_LATLONG_SOUTH"))
				:
				szString.append(gDLL->getText("TXT_KEY_LATLONG_NORTH"))
			);
		}

		if (pPlot->getLandmarkType() != NO_LANDMARK && GC.getGame().isOption(GAMEOPTION_MAP_PERSONALIZED))
		{
			szString.append(CvWString::format(SETCOLR, TEXT_COLOR("COLOR_HIGHLIGHT_TEXT")));
			szString.append(NEWLINE);
			szString.append(pPlot->getLandmarkMessage());
			szString.append(CvWString::format(ENDCOLR));
		}

		/* Toffer - Text is missing...

		if (getBugOptionBOOL("MiscHover__PlotRecommendedBuild", true, "BUG_PLOT_HOVER_RECOMMENDED_BUILD"))
		{
			CvCity* pWorkingCity = pPlot->getWorkingCity();

			if (pWorkingCity && pWorkingCity->getOwner() == eActivePlayer)
			{
				BuildTypes eBestBuild = pWorkingCity->AI_getBestBuild(pWorkingCity->getCityPlotIndex(pPlot));

				if (eBestBuild != NO_BUILD)
				{
					const CvBuildInfo& kBestBuild = GC.getBuildInfo(eBestBuild);

					if (pPlot->getImprovementType() != NO_IMPROVEMENT && pPlot->getImprovementType() == kBestBuild.getImprovement())
					{
						eBestBuild = NO_BUILD;
					}
					else if (kBestBuild.getRoute() != NO_ROUTE && (pPlot->isWater() || kBestBuild.getRoute() == pPlot->getRouteType()))
					{
						eBestBuild = NO_BUILD;
					}
					// Koshling - no need to test obsolete build here - AI_getBestBuild() only retruns things it can actually build
				}
				if (eBestBuild != NO_BUILD)
				{
					// Toffer - some text should be added here...
				}
			}
		}
		*/

		if (pPlot->hasAnyBuildProgress() && getBugOptionBOOL("MiscHover__PartialBuilds", true, "BUG_PLOT_HOVER_PARTIAL_BUILDS"))
		{
			for (int iI = 0; iI < GC.getNumBuildInfos(); iI++)
			{
				if (pPlot->getBuildProgress((BuildTypes)iI) > 0 && pPlot->canBuild((BuildTypes)iI, eActivePlayer))
				{
					const int iTurns = pPlot->getBuildTurnsLeft((BuildTypes)iI, eActivePlayer);

					if (iTurns > 0 && iTurns < MAX_INT)
					{
						szString.append(NEWLINE);
						szString.append(GC.getBuildInfo((BuildTypes)iI).getDescription());
						szString.append(L": ");
						szString.append(gDLL->getText("TXT_KEY_ACTION_NUM_TURNS", iTurns));
					}
				}
			}
		}

		if (bDebug)
		{
			bool bFirst = true;
			for (int iI = 0; iI < MAX_TEAMS; ++iI)
			{
				if (pPlot->getBlockadedCount((TeamTypes)iI) > 0 && GET_TEAM((TeamTypes)iI).isAlive())
				{
					if (bFirst)
					{
						szString.append(CvWString::format(SETCOLR, TEXT_COLOR("COLOR_NEGATIVE_TEXT")));
						szString.append(NEWLINE);
						szString.append(gDLL->getText("TXT_KEY_PLOT_BLOCKADED"));
						szString.append(CvWString::format(ENDCOLR));

						szString.append(CvWString::format(L"Teams:"));
						bFirst = false;
					}
					szString.append(CvWString::format(L" %s,", GET_TEAM((TeamTypes)iI).getName().c_str()));
				}
			}
		}
		else if (pPlot->getBlockadedCount(eActiveTeam) > 0)
		{
			szString.append(CvWString::format(SETCOLR, TEXT_COLOR("COLOR_NEGATIVE_TEXT")));
			szString.append(NEWLINE);
			szString.append(gDLL->getText("TXT_KEY_PLOT_BLOCKADED"));
			szString.append(CvWString::format(ENDCOLR));
		}
	}

	const int iDamage = pPlot->getTotalTurnDamage();
	if (iDamage > 0)
	{
		szString.append(CvWString::format(SETCOLR, TEXT_COLOR("COLOR_NEGATIVE_TEXT")));
		szString.append(NEWLINE);
		szString.append(gDLL->getText("TXT_KEY_PLOT_DAMAGE", iDamage));
		// TB - Combat Mod
		if (GC.getTerrainInfo(pPlot->getTerrainType()).isColdDamage())
		{
			szString.append(gDLL->getText("TXT_KEY_PLOT_DAMAGE_IS_COLD"));
		}
		// ! TB
		szString.append(CvWString::format(ENDCOLR));
	}
	else if (iDamage < 0)
	{
		szString.append(CvWString::format(SETCOLR, TEXT_COLOR("COLOR_POSITIVE_TEXT")));
		szString.append(NEWLINE);
		szString.append(gDLL->getText("TXT_KEY_PLOT_DAMAGE", iDamage));
		szString.append(CvWString::format(ENDCOLR));
	}

	pPlot->getProperties()->buildDisplayString(szString);

	foreach_(const MapCategoryTypes eMapCategory, GC.getTerrainInfo(pPlot->getTerrainType()).getMapCategories())
	{
		szString.append(NEWLINE);
		szString.append(gDLL->getText("TXT_KEY_MAP_CATEGORY_TERRAIN", GC.getMapCategoryInfo(eMapCategory).getTextKeyWide()));
	}
}


void CvGameTextMgr::setCityPlotYieldValueString(CvWStringBuffer& szString, CvCity* pCity, int iIndex, bool bAvoidGrowth, bool bIgnoreGrowth, bool bIgnoreFood) const
{
	PROFILE_FUNC();

	CvPlot* pPlot = NULL;

	if (iIndex >= 0 && iIndex < NUM_CITY_PLOTS)
		pPlot = pCity->getCityIndexPlot(iIndex);

	if (pPlot && pPlot->getWorkingCity() == pCity)
	{
		CvCityAI* pCityAI = static_cast<CvCityAI*>(pCity);
		bool bWorkingPlot = pCity->isWorkingPlot(iIndex);

		int iValue = pCityAI->AI_plotValue(pPlot, bAvoidGrowth, /*bRemove*/ bWorkingPlot, bIgnoreFood, bIgnoreGrowth);

		setYieldValueString(szString, iValue, /*bActive*/ bWorkingPlot);
	}
	else
		setYieldValueString(szString, 0, /*bActive*/ false, /*bMakeWhitespace*/ true);
}

void CvGameTextMgr::setYieldValueString(CvWStringBuffer &szString, int iValue, bool bActive, bool bMakeWhitespace) const
{
	PROFILE_FUNC();

	static bool bUseFloats = false;

	if (bActive)
		szString.append(CvWString::format(SETCOLR, TEXT_COLOR("COLOR_ALT_HIGHLIGHT_TEXT")));
	else
		szString.append(CvWString::format(SETCOLR, TEXT_COLOR("COLOR_HIGHLIGHT_TEXT")));

	if (!bMakeWhitespace)
	{
		if (bUseFloats)
		{
			float fValue = ((float) iValue) / 10000;
			szString.append(CvWString::format(L"%2.3f " ENDCOLR, fValue));
		}
		else
			szString.append(CvWString::format(L"%05d  " ENDCOLR, iValue/10));
	}
	else
		szString.append(CvWString::format(L"		   " ENDCOLR));
}

void CvGameTextMgr::setCityBarHelp(CvWStringBuffer &szString, CvCity* pCity)
{
	PROFILE_FUNC();

	CvWString szTempBuffer;
	CvWString szTempBuffer2;
	bool bFirst;
	int iFoodDifference;
	int iProductionDiffNoFood;
	int iProductionDiffJustFood;
	int iRate;
	int iI;
	// BUG - Base Production and Commerce - start
	bool bBaseValues = (gDLL->ctrlKey() && getBugOptionBOOL("CityBar__BaseValues", true, "BUG_CITYBAR_BASE_VALUES"));
	// BUG - Base Production and Commerce - end

	FAssert(pCity->isInViewport());

	iFoodDifference = pCity->foodDifference();

	szString.append(pCity->getName());

	// BUG - Health - start
	if (getBugOptionBOOL("CityBar__Health", true, "BUG_CITYBAR_HEALTH"))
	{
		iRate = pCity->goodHealth() - pCity->badHealth();
		if (iRate > 0)
		{
			szTempBuffer.Format(L", %d %c", iRate, gDLL->getSymbolID(HEALTHY_CHAR));
			szString.append(szTempBuffer);
		}
		else if (iRate < 0)
		{
			szTempBuffer.Format(L", %d %c", -iRate, gDLL->getSymbolID(UNHEALTHY_CHAR));
			szString.append(szTempBuffer);
		}
	}
	// BUG - Health - end

	// BUG - Happiness - start
	if (getBugOptionBOOL("CityBar__Happiness", true, "BUG_CITYBAR_HAPPINESS"))
	{
		if (pCity->isDisorder())
		{
			int iAngryPop = pCity->angryPopulation();
			if (iAngryPop > 0)
			{
				szTempBuffer.Format(L", %d %c", iAngryPop, gDLL->getSymbolID(ANGRY_POP_CHAR));
				szString.append(szTempBuffer);
			}
		}
		else
		{
			iRate = pCity->happyLevel() - pCity->unhappyLevel();
			if (iRate > 0)
			{
				szTempBuffer.Format(L", %d %c", iRate, gDLL->getSymbolID(HAPPY_CHAR));
				szString.append(szTempBuffer);
			}
			else if (iRate < 0)
			{
				szTempBuffer.Format(L", %d %c", -iRate, gDLL->getSymbolID(UNHAPPY_CHAR));
				szString.append(szTempBuffer);
			}
		}
	}
	// BUG - Happiness - end

	// BUG - Hurry Anger Turns - start
	if (getBugOptionBOOL("CityBar__HurryAnger", true, "BUG_CITYBAR_HURRY_ANGER") && pCity->getOwner() == GC.getGame().getActivePlayer())
	{
		iRate = pCity->getHurryAngerTimer();
		if (iRate > 0)
		{
			int iPop = ((iRate - 1) / pCity->flatHurryAngerLength() + 1) * GC.getDefineINT("HURRY_POP_ANGER");
			szTempBuffer.Format(L" (%d %c %d)", iPop, gDLL->getSymbolID(ANGRY_POP_CHAR), iRate);
			szString.append(szTempBuffer);
		}
	}
	// BUG - Anger Anger Turns - end

	// BUG - Draft Anger Turns - start
	if (getBugOptionBOOL("CityBar__DraftAnger", true, "BUG_CITYBAR_DRAFT_ANGER") && pCity->getOwner() == GC.getGame().getActivePlayer())
	{
		iRate = pCity->getConscriptAngerTimer();
		if (iRate > 0)
		{
			int iPop = ((iRate - 1) / pCity->flatConscriptAngerLength() + 1) * GC.getDefineINT("CONSCRIPT_POP_ANGER");
			szTempBuffer.Format(L" (%d %c %d)", iPop, gDLL->getSymbolID(CITIZEN_CHAR), iRate);
			szString.append(szTempBuffer);
		}
	}
	// BUG - Draft Anger Turns - end

	// BUG - Food Assist - start
	if ((iFoodDifference != 0 || !pCity->isFoodProduction()) && getBugOptionBOOL("CityBar__FoodAssist", true, "BUG_CITYBAR_FOOD_ASSIST"))
	{
		if (iFoodDifference > 0)
		{
			szString.append(gDLL->getText("TXT_KEY_CITY_BAR_FOOD_GROW", iFoodDifference, pCity->getFood(), pCity->growthThreshold(), pCity->getFoodTurnsLeft()));
		}
		else if (iFoodDifference == 0)
		{
			szString.append(gDLL->getText("TXT_KEY_CITY_BAR_FOOD_STAGNATE", pCity->getFood(), pCity->growthThreshold()));
		}
		else if (pCity->getFood() + iFoodDifference >= 0)
		{
			int iTurnsToStarve = pCity->getFood() / -iFoodDifference + 1;
			szString.append(gDLL->getText("TXT_KEY_CITY_BAR_FOOD_SHRINK", iFoodDifference, pCity->getFood(), pCity->growthThreshold(), iTurnsToStarve));
		}
		else
		{
			szString.append(gDLL->getText("TXT_KEY_CITY_BAR_FOOD_STARVE", iFoodDifference, pCity->getFood(), pCity->growthThreshold()));
		}
	}
	else
	{
		// unchanged
		if (iFoodDifference <= 0)
		{
			szString.append(gDLL->getText("TXT_KEY_CITY_BAR_GROWTH", pCity->getFood(), pCity->growthThreshold()));
		}
		else
		{
			szString.append(gDLL->getText("TXT_KEY_CITY_BAR_FOOD_GROWTH", iFoodDifference, pCity->getFood(), pCity->growthThreshold(), pCity->getFoodTurnsLeft()));
		}
	}
	// BUG - Food Assist - end

	if (pCity->getProductionNeeded() != MAX_INT)
	{
		// BUG - Base Production - start
		int iBaseProductionDiffNoFood;
		if (bBaseValues)
		{
			//TB Traits begin
			iBaseProductionDiffNoFood = pCity->getBaseYieldRate(YIELD_PRODUCTION) + pCity->getExtraYield(YIELD_PRODUCTION);
			//TB Traits end
		}
		else
		{
			iBaseProductionDiffNoFood = pCity->getCurrentProductionDifference(ProductionCalc::None);
		}
		// BUG - Base Production - end

		iProductionDiffNoFood = pCity->getCurrentProductionDifference(ProductionCalc::Overflow);
		iProductionDiffJustFood = (pCity->getCurrentProductionDifference(ProductionCalc::FoodProduction | ProductionCalc::Overflow) - iProductionDiffNoFood);

		if (iProductionDiffJustFood > 0)
		{
			// BUG - Base Production - start
			if ((iProductionDiffNoFood != iBaseProductionDiffNoFood) && getBugOptionBOOL("CityBar__BaseProduction", true, "BUG_CITYBAR_BASE_PRODUCTION"))
			{
				szString.append(gDLL->getText("TXT_KEY_CITY_BAR_FOOD_HAMMER_PRODUCTION_WITH_BASE", iProductionDiffJustFood, iProductionDiffNoFood, pCity->getProductionName(), pCity->getProductionProgress(), pCity->getProductionNeeded(), pCity->getProductionTurnsLeft(), iBaseProductionDiffNoFood));
			}
			else
			{
				// unchanged
				szString.append(gDLL->getText("TXT_KEY_CITY_BAR_FOOD_HAMMER_PRODUCTION", iProductionDiffJustFood, iProductionDiffNoFood, pCity->getProductionName(), pCity->getProductionProgress(), pCity->getProductionNeeded(), pCity->getProductionTurnsLeft()));
			}
			// BUG - Base Production - end
		}
		else if (iProductionDiffNoFood > 0)
		{
			// BUG - Base Production - start
			if ((iProductionDiffNoFood != iBaseProductionDiffNoFood) && getBugOptionBOOL("CityBar__BaseProduction", true, "BUG_CITYBAR_BASE_PRODUCTION"))
			{
				szString.append(gDLL->getText("TXT_KEY_CITY_BAR_HAMMER_PRODUCTION_WITH_BASE", iProductionDiffNoFood, pCity->getProductionName(), pCity->getProductionProgress(), pCity->getProductionNeeded(), pCity->getProductionTurnsLeft(), iBaseProductionDiffNoFood));
			}
			else
			{
				// unchanged
				szString.append(gDLL->getText("TXT_KEY_CITY_BAR_HAMMER_PRODUCTION", iProductionDiffNoFood, pCity->getProductionName(), pCity->getProductionProgress(), pCity->getProductionNeeded(), pCity->getProductionTurnsLeft()));
			}
			// BUG - Base Production - end
		}
		else
		{
			szString.append(gDLL->getText("TXT_KEY_CITY_BAR_PRODUCTION", pCity->getProductionName(), pCity->getProductionProgress(), pCity->getProductionNeeded()));
		}

		// BUG - Building Actual Effects - start
		if (pCity->getOwner() == GC.getGame().getActivePlayer() && getBugOptionBOOL("CityBar__BuildingActualEffects", true, "BUG_CITYBAR_BUILDING_ACTUAL_EFFECTS"))
		{
			if (pCity->isProductionBuilding())
			{
				BuildingTypes eBuilding = pCity->getProductionBuilding();
				CvWString szStart;

				szStart.Format(NEWLINE L"<img=%S size=24></img>", GC.getBuildingInfo(eBuilding).getButton());
				setBuildingActualEffects(szString, szStart, eBuilding, pCity, false);
			}
		}
	// BUG - Building Actual Effects - end
	}
	// BUG - Base Production - start
	else if (getBugOptionBOOL("CityBar__BaseProduction", true, "BUG_CITYBAR_BASE_PRODUCTION"))
	{
		int iOverflow = pCity->getOverflowProduction();
		int iBaseProductionDiffNoFood;
		if (bBaseValues)
		{
			//TB Traits begin
			iBaseProductionDiffNoFood = pCity->getBaseYieldRate(YIELD_PRODUCTION) + pCity->getExtraYield(YIELD_PRODUCTION);
			//TB Traits end
		}
		else
		{
			iBaseProductionDiffNoFood = pCity->getCurrentProductionDifference(ProductionCalc::Overflow);
		}
		if (iOverflow > 0 || iBaseProductionDiffNoFood > 0)
		{
			if (iOverflow > 0)
			{
				szString.append(gDLL->getText("TXT_KEY_CITY_BAR_BASE_PRODUCTION_WITH_OVERFLOW", iOverflow, iBaseProductionDiffNoFood));
			}
			else
			{
				szString.append(gDLL->getText("TXT_KEY_CITY_BAR_BASE_PRODUCTION", iBaseProductionDiffNoFood));
			}
		}
	}
	// BUG - Base Production - end

	// BUG - Hurry Assist - start
	if (getBugOptionBOOL("CityBar__HurryAssist", true, "BUG_CITYBAR_HURRY_ASSIST") && pCity->getOwner() == GC.getGame().getActivePlayer())
	{
		bool bFirstHurry = true;
		for (iI = 0; iI < GC.getNumHurryInfos(); iI++)
		{
			if (pCity->canHurry((HurryTypes)iI))
			{
				if (bFirstHurry)
				{
					szString.append(NEWLINE);
					szString.append("Hurry:");
					bFirstHurry = false;
				}
				bFirst = true;
				szString.append(L" (");
				const int iPopulation = pCity->hurryPopulation((HurryTypes)iI);
				if (iPopulation > 0)
				{
					szTempBuffer.Format(L"%d %c", -iPopulation, gDLL->getSymbolID(CITIZEN_CHAR));
					setListHelp(szString, NULL, szTempBuffer, L", ", bFirst);
					bFirst = false;
				}
				const int64_t iGold = pCity->getHurryGold((HurryTypes)iI);
				if (iGold > 0)
				{
					szTempBuffer.Format(L"%I64d %c", -iGold, GC.getCommerceInfo(COMMERCE_GOLD).getChar());
					setListHelp(szString, NULL, szTempBuffer, L", ", bFirst);
					bFirst = false;
				}
				int iOverflowProduction = 0;
				int iOverflowGold = 0;
				if (pCity->hurryOverflow((HurryTypes)iI, &iOverflowProduction, &iOverflowGold, getBugOptionBOOL("CityBar__HurryAssistIncludeCurrent", false, "BUG_CITYBAR_HURRY_ASSIST_INCLUDE_CURRENT")))
				{
					if (iOverflowProduction > 0)
					{
						szTempBuffer.Format(L"%d %c", iOverflowProduction, GC.getYieldInfo(YIELD_PRODUCTION).getChar());
						setListHelp(szString, NULL, szTempBuffer, L", ", bFirst);
						bFirst = false;
					}
					if (iOverflowGold > 0)
					{
						szTempBuffer.Format(L"%d %c", iOverflowGold, GC.getCommerceInfo(COMMERCE_GOLD).getChar());
						setListHelp(szString, NULL, szTempBuffer, L", ", bFirst);
						bFirst = false;
					}
				}
				szString.append(L")");
			}
		}
	}
	// BUG - Hurry Assist - end

	// BUG - Trade Detail - start
	if (getBugOptionBOOL("CityBar__TradeDetail", true, "BUG_CITYBAR_TRADE_DETAIL"))
	{
		int iTotalTrade = 0;
		int iDomesticTrade = 0;
		int iDomesticRoutes = 0;
		int iForeignTrade = 0;
		int iForeignRoutes = 0;

		// BUG - Fractional Trade Routes - start
#ifdef _MOD_FRACTRADE
		bool bFractions = true;
#else
		bool bFractions = bBaseValues;
#endif
		// BUG - Fractional Trade Routes - end

		pCity->calculateTradeTotals(YIELD_COMMERCE, iDomesticTrade, iDomesticRoutes, iForeignTrade, iForeignRoutes, NO_PLAYER, !bFractions, bBaseValues);
		iTotalTrade = iDomesticTrade + iForeignTrade;

		bFirst = true;
		if (iTotalTrade != 0)
		{
			if (bFractions)
			{
				szTempBuffer.Format(L"%c: %d.%02d %c", gDLL->getSymbolID(TRADE_CHAR), iTotalTrade / 100, iTotalTrade % 100, GC.getYieldInfo(YIELD_COMMERCE).getChar());
			}
			else
			{
				szTempBuffer.Format(L"%c: %d %c", gDLL->getSymbolID(TRADE_CHAR), iTotalTrade, GC.getYieldInfo(YIELD_COMMERCE).getChar());
			}
			setListHelp(szString, NEWLINE, szTempBuffer, L", ", bFirst);
			bFirst = false;
		}
		if (iDomesticTrade != 0)
		{
			if (bFractions)
			{
				szTempBuffer.Format(L"%c: %d.%02d %c", gDLL->getSymbolID(STAR_CHAR), iDomesticTrade / 100, iDomesticTrade % 100, GC.getYieldInfo(YIELD_COMMERCE).getChar());
			}
			else
			{
				szTempBuffer.Format(L"%c: %d %c", gDLL->getSymbolID(STAR_CHAR), iDomesticTrade, GC.getYieldInfo(YIELD_COMMERCE).getChar());
			}
			setListHelp(szString, NEWLINE, szTempBuffer, L", ", bFirst);
			bFirst = false;
		}
		if (iForeignTrade != 0)
		{
			if (bFractions)
			{
				szTempBuffer.Format(L"%c: %d.%02d %c", gDLL->getSymbolID(SILVER_STAR_CHAR), iForeignTrade / 100, iForeignTrade % 100, GC.getYieldInfo(YIELD_COMMERCE).getChar());
			}
			else
			{
				szTempBuffer.Format(L"%c: %d %c", gDLL->getSymbolID(SILVER_STAR_CHAR), iForeignTrade, GC.getYieldInfo(YIELD_COMMERCE).getChar());
			}
			setListHelp(szString, NEWLINE, szTempBuffer, L", ", bFirst);
			bFirst = false;
		}
	}
	// BUG - Trade Detail - end

	bFirst = true;

	// BUG - Commerce - start
	if (getBugOptionBOOL("CityBar__Commerce", true, "BUG_CITYBAR_COMMERCE"))
	{
		if (bBaseValues)
		{
			//TB Traits begin
			iRate = pCity->getBaseYieldRate(YIELD_COMMERCE) + pCity->getExtraYield(YIELD_COMMERCE);
			//TB Traits end
		}
		else
		{
			iRate = pCity->getYieldRate(YIELD_COMMERCE);
		}
		if (iRate != 0)
		{
			szTempBuffer.Format(L"%d %c", iRate, GC.getYieldInfo(YIELD_COMMERCE).getChar());
			setListHelp(szString, NEWLINE, szTempBuffer, L", ", bFirst);
			bFirst = false;
		}
	}
	// BUG - Commerce - end

	for (iI = 0; iI < NUM_COMMERCE_TYPES; ++iI)
	{
		// BUG - Base Values - start
		if (bBaseValues)
		{
			iRate = pCity->getBaseCommerceRateTimes100((CommerceTypes)iI);
		}
		else
		{
			// unchanged
			iRate = pCity->getCommerceRateTimes100((CommerceTypes)iI);
		}
		// BUG - Base Values - end

		if (iRate != 0)
		{
			szTempBuffer.Format(L"%d.%02d %c", iRate/100, iRate%100, GC.getCommerceInfo((CommerceTypes)iI).getChar());
			setListHelp(szString, NEWLINE, szTempBuffer, L", ", bFirst);
			bFirst = false;
		}
	}

	// BUG - Base Values - start
	if (bBaseValues)
	{
		iRate = pCity->getBaseGreatPeopleRate();
	}
	else
	{
		// unchanged
		iRate = pCity->getGreatPeopleRate();
	}
	// BUG - Base Values - end

	if (iRate != 0)
	{
		szTempBuffer.Format(L"%d%c", iRate, gDLL->getSymbolID(GREAT_PEOPLE_CHAR));
		setListHelp(szString, NEWLINE, szTempBuffer, L", ", bFirst);
		bFirst = false;
	}

	if (!bFirst)
	{
		szString.append(gDLL->getText("TXT_KEY_PER_TURN"));
	}

	szString.append(NEWLINE);
	szString.append(gDLL->getText("INTERFACE_CITY_MAINTENANCE"));

	int iMaintenance = bBaseValues ? pCity->calculateBaseMaintenanceTimes100() : pCity->getMaintenanceTimes100();

	szString.append(CvWString::format(L" -%d.%02d %c", iMaintenance/100, iMaintenance%100, GC.getCommerceInfo(COMMERCE_GOLD).getChar()));

	{
		const bool bBuildingIconBUG = getBugOptionBOOL("CityBar__BuildingIcons", true, "BUG_CITYBAR_BUILDING_ICONS");
		bFirst = true;
		foreach_(const BuildingTypes eType, pCity->getHasBuildings())
		{
			if (isWorldWonder(eType) || isNationalWonder(eType))
			{
				if (bBuildingIconBUG)
				{
					if (bFirst)
					{
						szString.append(NEWLINE);
						bFirst = false;
					}
					szTempBuffer.Format(L"<img=%S size=24></img>", GC.getBuildingInfo(eType).getButton());
					szString.append(szTempBuffer);
				}
				else
				{
					setListHelp(szString, NEWLINE, GC.getBuildingInfo(eType).getDescription(), L", ", bFirst);
					bFirst = false;
				}
			}
		}
	}

	{
		const int iThreshold = pCity->getCultureThreshold();
		if (iThreshold > 0)
		{
			szString.append(
				gDLL->getText(
					"TXT_KEY_CITY_BAR_CULTURE",
					pCity->getCulture(pCity->getOwner()), iThreshold,
					GC.getCultureLevelInfo(pCity->getCultureLevel()).getTextKeyWide(),
					GC.getCultureLevelInfo(pCity->getCultureLevel()).getLevel()
				)
			);
			const int iCultureRate = pCity->getCommerceRateTimes100(COMMERCE_CULTURE);
			if (iCultureRate > 0)
			{
				// all values are *100
				const int iCultureLeft = 100 * iThreshold - pCity->getCultureTimes100(pCity->getOwner());
				const int iCultureTurns = (iCultureLeft + iCultureRate - 1) / iCultureRate;
				szString.append(L" ");
				szString.append(gDLL->getText("INTERFACE_CITY_TURNS", iCultureTurns));
			}
		}
		else
		{
			szString.append(
				gDLL->getText(
					"TXT_KEY_CITY_BAR_CULTURE_MAX",
					pCity->getCulture(pCity->getOwner()),
					GC.getCultureLevelInfo(pCity->getCultureLevel()).getTextKeyWide(),
					GC.getCultureLevelInfo(pCity->getCultureLevel()).getLevel()
				)
			);
		}
	}

	// BUG - Great Person Turns - start
	int iGppRate = pCity->getGreatPeopleRate();
	if (iGppRate > 0 && getBugOptionBOOL("CityBar__GreatPersonTurns", true, "BUG_CITYBAR_GREAT_PERSON_TURNS"))
	{
		int iGpp = pCity->getGreatPeopleProgress();
		int iGppTotal = GET_PLAYER(pCity->getOwner()).greatPeopleThresholdNonMilitary();
		szString.append(gDLL->getText("TXT_KEY_CITY_BAR_GREAT_PEOPLE", iGpp, iGppTotal));
		int iGppLeft = iGppTotal - iGpp;
		int iGppTurns = (iGppLeft + iGppRate - 1) / iGppRate;
		szString.append(L" ");
		szString.append(gDLL->getText("INTERFACE_CITY_TURNS", iGppTurns));
	}
	else
	{
		// unchanged
		if (pCity->getGreatPeopleProgress() > 0)
		{
			szString.append(gDLL->getText("TXT_KEY_CITY_BAR_GREAT_PEOPLE", pCity->getGreatPeopleProgress(), GET_PLAYER(pCity->getOwner()).greatPeopleThresholdNonMilitary()));
		}
	}
	// BUG - Great Person Turns - end

	// BUG - Specialists - start
	if (getBugOptionBOOL("CityBar__Specialists", true, "BUG_CITYBAR_SPECIALISTS"))
	{
		// regular specialists
		bFirst = true;
		for (int iI = 0; iI < GC.getNumSpecialistInfos(); ++iI)
		{
			const int iCount = pCity->getSpecialistCount((SpecialistTypes)iI);
			if (iCount > 0)
			{
				if (bFirst)
				{
					szString.append(NEWLINE);
				}
				const CvSpecialistInfo& kSpecialistInfo = GC.getSpecialistInfo((SpecialistTypes)iI);
				//for (int iJ = 0; iJ < iCount; ++iJ)
				//{
				if (!bFirst)
				{
					szString.append(gDLL->getText("TXT_KEY_COMMA", iCount));
				}
				szTempBuffer.Format(L"<img=%S size=24></img>", kSpecialistInfo.getButton());
				szString.append(szTempBuffer);
				szString.append(gDLL->getText("TXT_KEY_INTERFACE_CITY_BAR_SPECIALIST_ADDENDUM", iCount));
				if (bFirst)
				{
					bFirst = false;
				}

				//}
			}
		}

		// free specialists (ToA, GL) and settled great people
		bFirst = true;
		for (int iI = 0; iI < GC.getNumSpecialistInfos(); ++iI)
		{
			const int iCount = pCity->getFreeSpecialistCount((SpecialistTypes)iI);
			if (iCount > 0)
			{
				if (bFirst)
				{
					szString.append(NEWLINE);
				}
				const CvSpecialistInfo& kSpecialistInfo = GC.getSpecialistInfo((SpecialistTypes)iI);
				//for (int iJ = 0; iJ < iCount; ++iJ)
				//{
				if (!bFirst)
				{
					szString.append(gDLL->getText("TXT_KEY_COMMA", iCount));
				}
				szTempBuffer.Format(L"<img=%S size=24></img>", kSpecialistInfo.getButton());
				szString.append(szTempBuffer);
				szString.append(gDLL->getText("TXT_KEY_INTERFACE_CITY_BAR_SPECIALIST_ADDENDUM", iCount));
				if (bFirst)
				{
					bFirst = false;
				}

				//}
			}
		}
	}
	// BUG - Specialists - end

	int iNumUnits = pCity->plot()->countNumAirUnits(GC.getGame().getActiveTeam());
	if (GC.getGame().isOption(GAMEOPTION_COMBAT_SIZE_MATTERS))
	{
		iNumUnits = pCity->plot()->countNumAirUnitCargoVolume(GC.getGame().getActiveTeam());
		if (pCity->getSMAirUnitCapacity(GC.getGame().getActiveTeam()) > 0 && iNumUnits > 0)
		{
			szString.append(NEWLINE);
			szString.append(gDLL->getText("TXT_KEY_CITY_BAR_AIR_UNIT_CAPACITY", iNumUnits, pCity->getSMAirUnitCapacity(GC.getGame().getActiveTeam())));
		}
	}
	else if (pCity->getAirUnitCapacity(GC.getGame().getActiveTeam()) > 0 && iNumUnits > 0)
	{
		szString.append(NEWLINE);
		szString.append(gDLL->getText("TXT_KEY_CITY_BAR_AIR_UNIT_CAPACITY", iNumUnits, pCity->getAirUnitCapacity(GC.getGame().getActiveTeam())));
	}

	// BUG - Revolt Chance - start
	if (getBugOptionBOOL("CityBar__RevoltChance", true, "BUG_CITYBAR_REVOLT_CHANCE"))
	{
		const PlayerTypes eCulturalOwner = pCity->plot()->calculateCulturalOwner();

		if (eCulturalOwner != NO_PLAYER)
		{
			if (GET_PLAYER(eCulturalOwner).getTeam() != pCity->getTeam())
			{
				int iNetRevoltRisk100 = pCity->netRevoltRisk100(eCulturalOwner);
				int iOriginal100 = pCity->baseRevoltRisk100(eCulturalOwner);
				int iSpeedAdjustment = GC.getREVOLT_TEST_PROB() * 100 /
					GC.getGameSpeedInfo(GC.getGame().getGameSpeedType()).getSpeedPercent();
				int iGarrison = pCity->unitRevoltRiskModifier(eCulturalOwner);

				if (iNetRevoltRisk100 > 0)
				{
					szString.append(NEWLINE);
					szString.append(gDLL->getText("TXT_KEY_MISC_CHANCE_OF_REVOLT",
						CvWString::format(L"" SETCOLR L"%.2f%%" ENDCOLR, TEXT_COLOR("COLOR_HIGHLIGHT_TEXT"), ((float)iNetRevoltRisk100*iSpeedAdjustment)/10000).GetCString(),
						CvWString::format(L"" SETCOLR L"%.1f%%" ENDCOLR, TEXT_COLOR("COLOR_HIGHLIGHT_TEXT"), (float)iOriginal100/100).GetCString(),
						CvWString::format(L"" SETCOLR L"%d%%" ENDCOLR, TEXT_COLOR("COLOR_HIGHLIGHT_TEXT"), iSpeedAdjustment).GetCString(),
						CvWString::format(L"" SETCOLR L"%d%%" ENDCOLR, TEXT_COLOR("COLOR_HIGHLIGHT_TEXT"), iGarrison).GetCString()
					));
				}
			}
		}
	}
	// BUG - Revolt Chance - end

	// Citybar revolution info
	if (GC.getGame().isOption(GAMEOPTION_UNSUPPORTED_REVOLUTION))
	{
		szString.append(NEWLINE);
		szString.append(L"<img=Art/Interface/Buttons/revbtn.dds size=23></img>");
		szString.append(CvWString::format(L":%d", pCity->getRevolutionIndex()));
		szString.append(NEWLINE);
	}

	pCity->getProperties()->buildDisplayString(szString);

	// BUG - Hide UI Instructions - start
	if (!getBugOptionBOOL("CityBar__HideInstructions", true, "BUG_CITYBAR_HIDE_INSTRUCTIONS"))
	{
		if (getBugOptionBOOL("CityBar__BaseValues", true, "BUG_CITYBAR_BASE_VALUES"))
		{
			szString.append(gDLL->getText("TXT_KEY_CITY_BAR_CTRL_BASE_VALUES"));
		}
		// unchanged
		szString.append(gDLL->getText("TXT_KEY_CITY_BAR_SELECT", pCity->getNameKey()));
		szString.append(gDLL->getText("TXT_KEY_CITY_BAR_SELECT_CTRL"));
		szString.append(gDLL->getText("TXT_KEY_CITY_BAR_SELECT_ALT"));
	}
	// BUG - Hide UI Instructions - end
}

void CvGameTextMgr::parseBuildUp(CvWStringBuffer &szHelpString, PromotionLineTypes ePromotionLine, CivilizationTypes eCivilization)
{
	// TB Traits
	PROFILE_FUNC();
	CvWString szTempBuffer;
	CvWString szText;

	// Trait Name
	szText = GC.getPromotionLineInfo(ePromotionLine).getDescription();
	szTempBuffer.Format(NEWLINE SETCOLR L"%s" ENDCOLR, TEXT_COLOR("COLOR_ALT_HIGHLIGHT_TEXT"), szText.GetCString());
	szHelpString.append(szTempBuffer);

	if (!CvWString(GC.getPromotionLineInfo(ePromotionLine).getHelp()).empty())
	{
		szHelpString.append(NEWLINE);
		szHelpString.append(GC.getPromotionLineInfo(ePromotionLine).getHelp());
	}
}

void CvGameTextMgr::parseTraits(CvWStringBuffer &szHelpString, TraitTypes eTrait, bool bDawnOfMan, bool bEffectsOnly)
{
	// TB Traits
	PROFILE_FUNC();

	const CvTraitInfo& kTrait = GC.getTraitInfo(eTrait);

	if (!bEffectsOnly)
	{
		// Trait Name
		CvWString name;
		if (bDawnOfMan)
		{
			name.Format(L"%s", kTrait.getDescription());
		}
		else name.Format(SETCOLR L"%s" ENDCOLR, TEXT_COLOR("COLOR_ALT_HIGHLIGHT_TEXT"), kTrait.getDescription());

		szHelpString.append(name);
	}
	if (bDawnOfMan) return;

	int iLast;
	std::vector<int> iIterationValues;

	if (!CvWString(kTrait.getHelp()).empty())
	{
		szHelpString.append(kTrait.getHelp());
	}
	//Negative Trait denotation
	if (kTrait.isNegativeTrait())
	{
		szHelpString.append(NEWLINE);
		szHelpString.append(gDLL->getText("TXT_KEY_TRAITHELP_NEGATIVE"));
	}
	//Negative Trait denotation
	if (kTrait.isCivilizationTrait())
	{
		szHelpString.append(NEWLINE);
		szHelpString.append(gDLL->getText("TXT_KEY_TRAITHELP_CIVILIZATION"));
	}
	//On Game Option denotation
	for (int i = 0; i < GC.getNumGameOptionInfos(); i++)
	{
		if (kTrait.isOnGameOption(i))
		{
			szHelpString.append(NEWLINE);
			szHelpString.append(gDLL->getText("TXT_KEY_TRAITHELP_ON_GAME_OPTION", GC.getGameOptionInfo((GameOptionTypes)i).getDescription()));
		}
	}
	//Not On Game Option denotation
	for (int i = 0; i < GC.getNumGameOptionInfos(); i++)
	{
		if (kTrait.isNotOnGameOption(i))
		{
			szHelpString.append(NEWLINE);
			szHelpString.append(gDLL->getText("TXT_KEY_TRAITHELP_NOT_ON_GAME_OPTION", GC.getGameOptionInfo((GameOptionTypes)i).getDescription()));
		}
	}

	//Leaderhead Levelup option prereq notations
	if (GC.getGame().isOption(GAMEOPTION_LEADER_DEVELOPING))
	{
		if (kTrait.getPromotionLine() != NO_PROMOTIONLINE)
		{
			szHelpString.append(NEWLINE);
			szHelpString.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_LINE", GC.getPromotionLineInfo((PromotionLineTypes)kTrait.getPromotionLine()).getDescription()));

			if (kTrait.getLinePriority() > 0)
			{
				szHelpString.append(NEWLINE);
				szHelpString.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_LINE_PRIORITY", kTrait.getLinePriority()));
			}
		}
		if (GC.getGame().getActivePlayer() != NO_PLAYER
		&& !GET_PLAYER(GC.getGame().getActivePlayer()).canLearnTrait(eTrait))
		{
			bool bHasBegun = false;
			const int iNumTraits = GC.getNumTraitInfos();
			for (int iI = 0; iI < iNumTraits; iI++)
			{
				const TraitTypes eTraitX = static_cast<TraitTypes>(iI);

				if (GET_PLAYER(GC.getGame().getActivePlayer()).hasTrait(eTraitX)
				|| GC.getTraitInfo(eTraitX).getPromotionLine() == NO_PROMOTIONLINE
				|| kTrait.getPromotionLine() != GC.getTraitInfo(eTraitX).getPromotionLine())
				{
					continue;
				}
				if (kTrait.getLinePriority() > 1)
				{
					if (GC.getTraitInfo(eTraitX).getLinePriority() < kTrait.getLinePriority()
					&&  GC.getTraitInfo(eTraitX).getLinePriority() > 0)
					{
						if (!bHasBegun)
						{
							bHasBegun = true;
							szHelpString.append(NEWLINE);
							szHelpString.append(gDLL->getText("TXT_KEY_TRAITHELP_PREREQ_BEGIN", GC.getTraitInfo(eTraitX).getTextKeyWide()));
						}
						else szHelpString.append(gDLL->getText("TXT_KEY_TRAITHELP_PREREQ_AND_ENTRY", GC.getTraitInfo(eTraitX).getTextKeyWide()));
					}
				}
				else if (kTrait.getLinePriority() < 1)
				{
					if (GC.getTraitInfo(eTraitX).getLinePriority() > kTrait.getLinePriority()
					&&  GC.getTraitInfo(eTraitX).getLinePriority() < 0)
					{
						if (!bHasBegun)
						{
							bHasBegun = true;
							szHelpString.append(NEWLINE);
							szHelpString.append(gDLL->getText("TXT_KEY_TRAITHELP_PREREQ_BEGIN", GC.getTraitInfo(eTraitX).getTextKeyWide()));
						}
						else szHelpString.append(gDLL->getText("TXT_KEY_TRAITHELP_PREREQ_AND_ENTRY", GC.getTraitInfo(eTraitX).getTextKeyWide()));
					}
				}
			}

			if (kTrait.getPrereqTrait() != NO_TRAIT
			&& GET_PLAYER(GC.getGame().getActivePlayer()).hasTrait(kTrait.getPrereqTrait()))
			{
				if (!bHasBegun)
				{
					bHasBegun = true;
					szHelpString.append(NEWLINE);
					szHelpString.append(gDLL->getText("TXT_KEY_TRAITHELP_PREREQ_BEGIN", GC.getTraitInfo(kTrait.getPrereqTrait()).getTextKeyWide()));
				}
				else szHelpString.append(gDLL->getText("TXT_KEY_TRAITHELP_PREREQ_AND_ENTRY", GC.getTraitInfo(kTrait.getPrereqTrait()).getTextKeyWide()));
			}
			if (
				kTrait.getPrereqOrTrait1() != NO_TRAIT
			&& !GET_PLAYER(GC.getGame().getActivePlayer()).hasTrait(kTrait.getPrereqOrTrait1())
			&&
				(
					kTrait.getPrereqOrTrait2() == NO_TRAIT
				||  !GET_PLAYER(GC.getGame().getActivePlayer()).hasTrait(kTrait.getPrereqOrTrait2())
				)
			)
			{
				if (!bHasBegun)
				{
					szHelpString.append(NEWLINE);
					szHelpString.append(gDLL->getText("TXT_KEY_TRAITHELP_PREREQ_BEGIN", GC.getTraitInfo(kTrait.getPrereqOrTrait1()).getTextKeyWide()));
				}
				else szHelpString.append(gDLL->getText("TXT_KEY_TRAITHELP_PREREQ_AND_ENTRY", GC.getTraitInfo(kTrait.getPrereqOrTrait1()).getTextKeyWide()));

				if (kTrait.getPrereqOrTrait2() != NO_TRAIT)
				{
					szHelpString.append(
						gDLL->getText(
							"TXT_KEY_TRAITHELP_PREREQ_OR_ENTRY",
							GC.getTraitInfo(kTrait.getPrereqOrTrait2()).getTextKeyWide(),
							GC.getTraitInfo(kTrait.getPrereqOrTrait1()).getTextKeyWide()
						)
					);
				}
			}
		}
		if (kTrait.getLinePriority() == 0
		&& !kTrait.isCivilizationTrait()
		&& !kTrait.isBarbarianSelectionOnly())
		{
			szHelpString.append(NEWLINE);
			szHelpString.append(gDLL->getText("TXT_KEY_TRAITHELP_DISABLED_ON"));
		}
	}
	else if (kTrait.getLinePriority() != 0)
	{
		szHelpString.append(NEWLINE);
		szHelpString.append(gDLL->getText("TXT_KEY_TRAITHELP_DISABLED_OFF"));
	}

	for (int iI = 0; iI < kTrait.getNumDisallowedTraitTypes(); iI++)
	{
		const TraitTypes eDisallowedTrait = kTrait.isDisallowedTraitType(iI).eTrait;
		if (eDisallowedTrait != NO_TRAIT)
		{
			szHelpString.append(NEWLINE);
			szHelpString.append(gDLL->getText("TXT_KEY_TRAITHELP_DISALLOWED", GC.getTraitInfo(eDisallowedTrait).getTextKeyWide()));
		}
	}

	if (kTrait.getPromotionLine() != NO_PROMOTIONLINE && GC.getGame().getActiveTeam() != NO_TEAM)
	{
		if (GC.getPromotionLineInfo((PromotionLineTypes)kTrait.getPromotionLine()).getPrereqTech() != NO_TECH)
		{
			if (!GET_TEAM(GC.getGame().getActiveTeam()).isHasTech(GC.getPromotionLineInfo((PromotionLineTypes)kTrait.getPromotionLine()).getPrereqTech()))
			{
				szHelpString.append(NEWLINE);
				szHelpString.append(gDLL->getText("TXT_KEY_TRAITHELP_TECH_PREREQ", GC.getTechInfo(GC.getPromotionLineInfo((PromotionLineTypes)kTrait.getPromotionLine()).getPrereqTech()).getTextKeyWide()));
			}
		}
	}

	if (kTrait.getPrereqTech() != NO_TECH && GC.getGame().getActiveTeam() != NO_TEAM)
	{
		if (!GET_TEAM(GC.getGame().getActiveTeam()).isHasTech(kTrait.getPrereqTech()))
		{
			szHelpString.append(NEWLINE);
			szHelpString.append(gDLL->getText("TXT_KEY_TRAITHELP_TECH_PREREQ", GC.getTechInfo(kTrait.getPrereqTech()).getTextKeyWide()));
		}
	}

	// iHealth
	if (kTrait.getHealth() != 0)
	{
		int iHealth = kTrait.getHealth();
		szHelpString.append(NEWLINE);
		szHelpString.append(gDLL->getText("TXT_KEY_BULLET"));
		CvWString txt0;
		txt0.Format(L" +%d%c", abs(iHealth), ((iHealth > 0) ? gDLL->getSymbolID(HEALTHY_CHAR): gDLL->getSymbolID(UNHEALTHY_CHAR)));
		szHelpString.append(txt0);
		szHelpString.append(gDLL->getText("TXT_KEY_PER_CITY"));
	}

	// iHappiness
	if (kTrait.getHappiness() != 0)
	{
		int iHappy = kTrait.getHappiness();
		szHelpString.append(NEWLINE);
		szHelpString.append(gDLL->getText("TXT_KEY_BULLET"));
		CvWString txt0;
		txt0.Format(L" +%d%c", abs(iHappy), ((iHappy > 0) ? gDLL->getSymbolID(HAPPY_CHAR): gDLL->getSymbolID(UNHAPPY_CHAR)));
		szHelpString.append(txt0);
		szHelpString.append(gDLL->getText("TXT_KEY_PER_CITY"));
	}

	//	Largest City Happiness
	if (kTrait.getLargestCityHappiness() != 0)
	{
		szHelpString.append(NEWLINE);
		// Use absolute value with unhappy face
		szHelpString.append(gDLL->getText("TXT_KEY_CIVICHELP_LARGEST_CITIES_HAPPINESS", abs(kTrait.getLargestCityHappiness()), ((kTrait.getLargestCityHappiness() > 0) ? gDLL->getSymbolID(HAPPY_CHAR) : gDLL->getSymbolID(UNHAPPY_CHAR)), GC.getWorldInfo(GC.getMap().getWorldSize()).getTargetNumCities()));
	}

	// State Religion Happiness
	if (kTrait.getStateReligionHappiness() != 0)
	{
		szHelpString.append(NEWLINE);
		szHelpString.append(gDLL->getText("TXT_KEY_CIVICHELP_RELIGION_HAPPINESS", abs(kTrait.getStateReligionHappiness()), ((kTrait.getStateReligionHappiness() > 0) ? gDLL->getSymbolID(HAPPY_CHAR) : gDLL->getSymbolID(UNHAPPY_CHAR))));
	}

	// Every religion happiness
	if (kTrait.getNonStateReligionHappiness() != 0)
	{
		szHelpString.append(NEWLINE);
		szHelpString.append(gDLL->getText("TXT_KEY_CIVICHELP_NON_STATE_REL_HAPPINESS_AMBIGUOUS", abs(kTrait.getNonStateReligionHappiness()), ((kTrait.getNonStateReligionHappiness() > 0) ? gDLL->getSymbolID(HAPPY_CHAR) : gDLL->getSymbolID(UNHAPPY_CHAR))));
	}

	//	Happiness per military unit
	if (kTrait.getHappyPerMilitaryUnit() != 0)
	{
		szHelpString.append(NEWLINE);
		szHelpString.append(gDLL->getText("TXT_KEY_CIVICHELP_UNIT_HAPPINESS", abs(kTrait.getHappyPerMilitaryUnit()), ((kTrait.getHappyPerMilitaryUnit() > 0) ? gDLL->getSymbolID(HAPPY_CHAR) : gDLL->getSymbolID(UNHAPPY_CHAR))));
	}

	// Extra Happiness by Bonuses
	foreach_(const BonusModifier& pair, kTrait.getBonusHappinessChanges())
	{
		if (algo::none_of_equal(iIterationValues, pair.second))
		{
			iIterationValues.push_back(pair.second);
		}
	}
	foreach_(const int itrValue, iIterationValues)
	{
		bool bFirst = true;
		foreach_(const BonusModifier& pair, kTrait.getBonusHappinessChanges())
		{
			if (pair.second == itrValue)
			{
				const CvBonusInfo& kTempBonus = GC.getBonusInfo(pair.first);
				if (bFirst)
				{
					szHelpString.append(NEWLINE);
					szHelpString.append(
						gDLL->getText(
							"TXT_KEY_TRAITHELP_BONUS_HAPPINESS_CHANGE_FIRST",
							pair.second,
							pair.second > 0 ? gDLL->getSymbolID(HAPPY_CHAR) : gDLL->getSymbolID(UNHAPPY_CHAR),
							CvWString(kTempBonus.getType()).c_str(), kTempBonus.getTextKeyWide()
						)
					);
					bFirst = false;
				}
				else szHelpString.append(gDLL->getText("TXT_KEY_TRAITHELP_BONUS_HAPPINESS_CHANGE_ADDITIONAL", CvWString(kTempBonus.getType()).c_str(), kTempBonus.getTextKeyWide()));
			}
		}
		szHelpString.append(gDLL->getText("TXT_KEY_TRAITHELP_BONUS_HAPPINESS_CHANGE_END"));
	}
	iIterationValues.clear();

	//	War Weariness
	if (kTrait.getWarWearinessAccumulationModifier() != 0)
	{
		szHelpString.append(NEWLINE);
		szHelpString.append(gDLL->getText("TXT_KEY_CIVICHELP_EXTRA_WAR_WEARINESS", kTrait.getWarWearinessAccumulationModifier()));
	}

	if (kTrait.getEnemyWarWearinessModifier() != 0)
	{
		szHelpString.append(NEWLINE);
		szHelpString.append(gDLL->getText("TXT_KEY_BUILDINGHELP_ENEMY_WAR_WEAR", kTrait.getEnemyWarWearinessModifier()));
	}

	// Yield % Modifiers
	setYieldChangeHelp(szHelpString, L"", L"", gDLL->getText("TXT_KEY_CIVICHELP_IN_ALL_CITIES").GetCString(), kTrait.getYieldModifierArray(), true);

	// ExtraYieldThresholds
	for (int iI = 0; iI < NUM_YIELD_TYPES; ++iI)
	{
		if (kTrait.getExtraYieldThreshold(iI) > 0)
		{
			szHelpString.append(NEWLINE);
			szHelpString.append(gDLL->getText("TXT_KEY_TRAITHELP_EXTRA_YIELD_THRESHOLDS", GC.getYieldInfo((YieldTypes) iI).getChar(), kTrait.getExtraYieldThreshold(iI), GC.getYieldInfo((YieldTypes) iI).getChar()));
		}
		if (kTrait.getLessYieldThreshold(iI) > 0)
		{
			szHelpString.append(NEWLINE);
			szHelpString.append(gDLL->getText("TXT_KEY_TRAITHELP_LESS_YIELD_THRESHOLDS", GC.getYieldInfo((YieldTypes) iI).getChar(), kTrait.getLessYieldThreshold(iI), GC.getYieldInfo((YieldTypes) iI).getChar()));
		}
		// Yield Base Change
		if (kTrait.getYieldChange(iI) != 0)
		{
			szHelpString.append(NEWLINE);
			szHelpString.append(gDLL->getText("TXT_KEY_TRAITHELP_YIELD_CHANGES", kTrait.getYieldChange(iI), GC.getYieldInfo((YieldTypes)iI).getChar(), "YIELD"));
		}
		// Trade Yield Modifiers
		if (kTrait.getTradeYieldModifier(iI) != 0)
		{
			szHelpString.append(NEWLINE);
			szHelpString.append(gDLL->getText("TXT_KEY_TRAITHELP_TRADE_YIELD_MODIFIERS", kTrait.getTradeYieldModifier(iI), GC.getYieldInfo((YieldTypes) iI).getChar(), "YIELD"));
		}
	}
	//SeaPlotYieldChanges
	setYieldChangeHelp(szHelpString, gDLL->getText("TXT_KEY_BUILDINGHELP_WATER_PLOTS_ALL_CITIES").GetCString(), L": ", L"", kTrait.getSeaPlotYieldChangesArray(), false, true);

	//GoldenAgeYieldChanges
	setYieldChangeHelp(szHelpString, gDLL->getText("TXT_KEY_GOLDEN_AGE_YIELD").GetCString(), L": ", L"", kTrait.getGoldenAgeYieldChangesArray(), false, true);

	//	Specialist Base Yield
	setYieldChangeHelp(szHelpString, L"", L"", gDLL->getText("TXT_KEY_CIVICHELP_PER_SPECIALIST").GetCString(), kTrait.getSpecialistExtraYieldArray(), false, true);

	//Individual Base specialist yield changes
	if (kTrait.isAnySpecialistYieldChanges())
	{
		for (int iI = 0; iI < GC.getNumSpecialistInfos(); ++iI)
		{
			CvWString txt0 = (
				gDLL->getText(
					"TXT_KEY_BUILDINGHELP_FROM_IN_ALL_CITIES",
					CvWString(GC.getSpecialistInfo((SpecialistTypes)iI).getType()).GetCString(),
					GC.getSpecialistInfo((SpecialistTypes)iI).getTextKeyWide()
				)
			);
			setYieldChangeHelp(szHelpString, L"", L"", txt0, kTrait.getSpecialistYieldChangeArray(iI), false, true);
		}
	}

	//	Capital % Yield Modifiers
	setYieldChangeHelp(szHelpString, L"", L"", gDLL->getText("TXT_KEY_CIVICHELP_IN_CAPITAL").GetCString(), kTrait.getCapitalYieldModifierArray(), true, true);

	// Improvement Yield Changes
	for (int iI = 0; iI < NUM_YIELD_TYPES; ++iI)
	{
		const YieldTypes eYield = ((YieldTypes)iI);
		iLast = 0;

		for (int iJ = 0; iJ < GC.getNumImprovementInfos(); iJ++)
		{
			const ImprovementTypes eImprovement = ((ImprovementTypes)iJ);
			if (kTrait.getImprovementYieldChange(eImprovement,eYield) !=0)
			{
				CvWString txt0;
				txt0.Format(
					L"%s%s", NEWLINE,
					gDLL->getText(
						"TXT_KEY_CIVICHELP_IMPROVEMENT_YIELD_CHANGE",
						kTrait.getImprovementYieldChange(eImprovement,eYield),
						GC.getYieldInfo(eYield).getChar()
					).c_str()
				);
				CvWString txt1;
				txt1.Format(L"<link=%s>%s</link>", CvWString(GC.getImprovementInfo(eImprovement).getType()).GetCString(), GC.getImprovementInfo(eImprovement).getDescription());

				setListHelp(szHelpString, txt0.GetCString(), txt1.GetCString(), L", ", (kTrait.getImprovementYieldChange(eImprovement,eYield) != iLast));
				iLast = kTrait.getImprovementYieldChange(eImprovement,eYield);
			}
		}
	}

	// CommerceChanges
	for (int iI = 0; iI < NUM_COMMERCE_TYPES; ++iI)
	{
		// Commerce Base Change
		if (kTrait.getCommerceChange(iI) != 0)
		{
			szHelpString.append(NEWLINE);
			szHelpString.append(gDLL->getText("TXT_KEY_TRAITHELP_COMMERCE_CHANGES", kTrait.getCommerceChange(iI), GC.getCommerceInfo((CommerceTypes) iI).getChar(), "COMMERCE"));
		}

		if (kTrait.getCommerceModifier(iI) != 0)
		{
			szHelpString.append(NEWLINE);
			szHelpString.append(gDLL->getText("TXT_KEY_TRAITHELP_COMMERCE_MODIFIERS", kTrait.getCommerceModifier(iI), GC.getCommerceInfo((CommerceTypes) iI).getChar(), "COMMERCE"));
		}
	}

	// Golden Age Commerce
	{
		const int* aList = kTrait.getGoldenAgeCommerceChangesArray();
		if (aList)
		{
			listCommerceChange(szHelpString, CvWString::format(L"\n%c%s: ", gDLL->getSymbolID(BULLET_CHAR), gDLL->getText("TXT_KEY_GOLDEN_AGE_YIELD").c_str()), L"", aList);
		}
	}

	// Specialist Base Commerce
	{
		const int* aList = kTrait.getSpecialistExtraCommerceArray();
		if (aList)
		{
			listCommerceChange(szHelpString, CvWString::format(L"\n%c", gDLL->getSymbolID(BULLET_CHAR)), gDLL->getText("TXT_KEY_CIVICHELP_PER_SPECIALIST").GetCString(), aList);
		}
	}

	//Individual Base specialist commerce changes
	if (kTrait.isAnySpecialistCommerceChanges())
	{
		for (int iI = 0; iI < GC.getNumSpecialistInfos(); ++iI)
		{
			const int* aList = kTrait.getSpecialistCommerceChangeArray(iI);
			if (aList)
			{
				listCommerceChange(
					szHelpString, CvWString::format(L"\n%c", gDLL->getSymbolID(BULLET_CHAR)),
					gDLL->getText(
						"TXT_KEY_BUILDINGHELP_FROM_IN_ALL_CITIES",
						CvWString(GC.getSpecialistInfo((SpecialistTypes) iI).getType()).GetCString(),
						GC.getSpecialistInfo((SpecialistTypes) iI).getTextKeyWide()
					),
					aList, true
				);
			}
		}
	}

	// Capital % Commerce Modifiers
	{
		const int* aList = kTrait.getCapitalCommerceModifierArray();
		if (aList)
		{
			listCommerceChange(szHelpString, CvWString::format(L"\n%c", gDLL->getSymbolID(BULLET_CHAR)), gDLL->getText("TXT_KEY_CIVICHELP_IN_CAPITAL").GetCString(), aList, true);
		}
	}

	// Non-State Religion Commerce
	if (kTrait.isNonStateReligionCommerce() != 0)
	{
		szHelpString.append(NEWLINE);
		szHelpString.append(gDLL->getText("TXT_KEY_TRAITHELP_NONSTATE_RELIGIOUS_COMMERCE"));
	}

	//SPECIALISTS && GP PTS
	//	Free specialists
	if (kTrait.getFreeSpecialist() != 0)
	{
		szHelpString.append(NEWLINE);
		szHelpString.append(gDLL->getText("TXT_KEY_CIVICHELP_FREE_SPECIALISTS", kTrait.getFreeSpecialist()));
	}

	//	Era Advance Free specialists
	if (kTrait.getEraAdvanceFreeSpecialistType() != NO_SPECIALIST)
	{
		szHelpString.append(NEWLINE);
		szHelpString.append(gDLL->getText("TXT_KEY_CIVICHELP_ERA_ADVANCE_FREE_SPECIALIST", GC.getSpecialistInfo((SpecialistTypes)kTrait.getEraAdvanceFreeSpecialistType()).getTextKeyWide()));
	}

	//	State Religion Great People Modifier...
	if (kTrait.getStateReligionGreatPeopleRateModifier() != 0)
	{
		szHelpString.append(NEWLINE);
		szHelpString.append(gDLL->getText("TXT_KEY_CIVICHELP_GREAT_PEOPLE_MOD_STATE_RELIGION", kTrait.getStateReligionGreatPeopleRateModifier(), gDLL->getSymbolID(RELIGION_CHAR)));
	}

	// iGreatPeopleRateModifier
	if (kTrait.getGreatPeopleRateModifier() != 0)
	{
		szHelpString.append(NEWLINE);
		szHelpString.append(gDLL->getText("TXT_KEY_TRAITHELP_GREAT_PEOPLE_MODIFIER", kTrait.getGreatPeopleRateModifier()));
	}

	// iGreatGeneralRateModifier
	if (kTrait.getGreatGeneralRateModifier() != 0)
	{
		szHelpString.append(NEWLINE);
		szHelpString.append(gDLL->getText("TXT_KEY_TRAITHELP_GREAT_GENERAL_MODIFIER", kTrait.getGreatGeneralRateModifier()));
	}

	if (kTrait.getDomesticGreatGeneralRateModifier() != 0)
	{
		szHelpString.append(NEWLINE);
		szHelpString.append(gDLL->getText("TXT_KEY_DOMESTIC_GREAT_GENERAL_MODIFIER_C2C", kTrait.getDomesticGreatGeneralRateModifier()));
	}

	if (kTrait.getGreatPeopleRateChange() != 0)
	{
		szHelpString.append(NEWLINE);
		szHelpString.append(gDLL->getText("TXT_KEY_BULLET"));
		CvWString txt0;
		txt0.Format(L"%s%d%c", ((kTrait.getGreatPeopleRateChange() > 0) ? L"+" : L""), kTrait.getGreatPeopleRateChange(), gDLL->getSymbolID(GREAT_PEOPLE_CHAR));
		szHelpString.append(txt0);

		if (kTrait.getGreatPeopleUnitType() > -1)
		{
			txt0.Format(L" (%s)", GC.getUnitInfo((UnitTypes)kTrait.getGreatPeopleUnitType()).getDescription());
			szHelpString.append(txt0);
		}
	}

	// Free Specialists on Wonders
	if (kTrait.isFreeSpecialistperNationalWonder())
	{
		szHelpString.append(NEWLINE);
		szHelpString.append(gDLL->getText("TXT_KEY_TRAITHELP_FREE_SPEC_NW"));
	}
	if (kTrait.isFreeSpecialistperWorldWonder())
	{
		szHelpString.append(NEWLINE);
		szHelpString.append(gDLL->getText("TXT_KEY_TRAITHELP_FREE_SPEC_WW"));
	}
	if (kTrait.isFreeSpecialistperTeamProject())
	{
		szHelpString.append(NEWLINE);
		szHelpString.append(gDLL->getText("TXT_KEY_TRAITHELP_FREE_SPEC_TP"));
	}


	if (kTrait.getHurryCostModifier() != 0)
	{
		szHelpString.append(NEWLINE);
		szHelpString.append(gDLL->getText("TXT_KEY_BUILDINGHELP_HURRY_MOD", kTrait.getHurryCostModifier()));
	}

	if (kTrait.getHurryAngerModifier() != 0)
	{
		szHelpString.append(NEWLINE);
		szHelpString.append(gDLL->getText("TXT_KEY_BUILDINGHELP_HURRY_ANGER_MOD", kTrait.getHurryAngerModifier()));
	}

	//	State Religion Building Production Modifier
	if (kTrait.getStateReligionBuildingProductionModifier() != 0)
	{
		szHelpString.append(NEWLINE);
		szHelpString.append(gDLL->getText("TXT_KEY_CIVICHELP_STATE_REL_BUILDING", kTrait.getStateReligionBuildingProductionModifier()));
	}

	// Wonder Production Effects
	if ((kTrait.getMaxGlobalBuildingProductionModifier() != 0)
		|| (kTrait.getMaxTeamBuildingProductionModifier() != 0)
		|| (kTrait.getMaxPlayerBuildingProductionModifier() != 0))
	{
		if (kTrait.getMaxGlobalBuildingProductionModifier() == kTrait.getMaxTeamBuildingProductionModifier()
		&& kTrait.getMaxGlobalBuildingProductionModifier() == kTrait.getMaxPlayerBuildingProductionModifier())
		{
			szHelpString.append(NEWLINE);
			szHelpString.append(gDLL->getText("TXT_KEY_TRAITHELP_WONDER_PRODUCTION_MODIFIER", kTrait.getMaxGlobalBuildingProductionModifier()));
		}
		else
		{
			if (kTrait.getMaxGlobalBuildingProductionModifier() != 0)
			{
				szHelpString.append(NEWLINE);
				szHelpString.append(gDLL->getText("TXT_KEY_TRAITHELP_WORLD_WONDER_PRODUCTION_MODIFIER", kTrait.getMaxGlobalBuildingProductionModifier()));
			}

			if (kTrait.getMaxTeamBuildingProductionModifier() != 0)
			{
				szHelpString.append(NEWLINE);
				szHelpString.append(gDLL->getText("TXT_KEY_TRAITHELP_TEAM_WONDER_PRODUCTION_MODIFIER", kTrait.getMaxTeamBuildingProductionModifier()));
			}

			if (kTrait.getMaxPlayerBuildingProductionModifier() != 0)
			{
				szHelpString.append(NEWLINE);
				szHelpString.append(gDLL->getText("TXT_KEY_TRAITHELP_NATIONAL_WONDER_PRODUCTION_MODIFIER", kTrait.getMaxPlayerBuildingProductionModifier()));
			}
		}
	}

	// Free Civilian units upkeep
	if (kTrait.getFreeUnitUpkeepCivilian() != 0)
	{
		szHelpString.append(NEWLINE);
		szHelpString.append(gDLL->getText("TXT_KEY_HELPTEXT_UNIT_UPKEEP_FREE_CIVILIAN", kTrait.getFreeUnitUpkeepCivilian()));
	}
	if (kTrait.getFreeUnitUpkeepCivilianPopPercent() != 0)
	{
		if (GC.getGame().getActivePlayer() != NO_PLAYER)
		{
			int iValue = 0;
			int iMod = kTrait.getFreeUnitUpkeepCivilianPopPercent();
			if (iMod > 0)
			{
				iValue = GET_PLAYER(GC.getGame().getActivePlayer()).getTotalPopulation() * (100 + iMod);
			}
			else if (iMod < 0)
			{
				iValue =
					GET_PLAYER(GC.getGame().getActivePlayer()).getTotalPopulation() -
					GET_PLAYER(GC.getGame().getActivePlayer()).getTotalPopulation() * 100 / (100 - iMod);
			}
			szHelpString.append(NEWLINE);
			szHelpString.append(gDLL->getText("TXT_KEY_HELPTEXT_UNIT_UPKEEP_FREE_CIVILIAN_PER_POP", iMod));
			szHelpString.append(gDLL->getText("TXT_KEY_HELPTEXT_UNIT_UPKEEP_FREE_PER_POP", CvWString::format(L"%.2f", iValue / 100.0).GetCString()));
		}
		else
		{
			szHelpString.append(NEWLINE);
			szHelpString.append(gDLL->getText("TXT_KEY_HELPTEXT_UNIT_UPKEEP_FREE_CIVILIAN_PER_POP", kTrait.getFreeUnitUpkeepCivilianPopPercent()));
		}
	}
	// Free Military unit upkeep
	if (kTrait.getFreeUnitUpkeepMilitary() != 0)
	{
		szHelpString.append(NEWLINE);
		szHelpString.append(gDLL->getText("TXT_KEY_HELPTEXT_UNIT_UPKEEP_FREE_MILITARY", kTrait.getFreeUnitUpkeepMilitary()));
	}
	if (kTrait.getFreeUnitUpkeepMilitaryPopPercent() != 0)
	{
		if (GC.getGame().getActivePlayer() != NO_PLAYER)
		{
			int iValue = 0;
			int iMod = kTrait.getFreeUnitUpkeepMilitaryPopPercent();
			if (iMod > 0)
			{
				iValue = GET_PLAYER(GC.getGame().getActivePlayer()).getTotalPopulation() * (100 + iMod);
			}
			else if (iMod < 0)
			{
				iValue =
					GET_PLAYER(GC.getGame().getActivePlayer()).getTotalPopulation() -
					GET_PLAYER(GC.getGame().getActivePlayer()).getTotalPopulation() * 100 / (100 - iMod);
			}
			szHelpString.append(NEWLINE);
			szHelpString.append(gDLL->getText("TXT_KEY_HELPTEXT_UNIT_UPKEEP_FREE_MILITARY_PER_POP",  iMod));
			szHelpString.append(gDLL->getText("TXT_KEY_HELPTEXT_UNIT_UPKEEP_FREE_PER_POP", CvWString::format(L"%.2f", iValue / 100.0).GetCString()));
		}
		else
		{
			szHelpString.append(NEWLINE);
			szHelpString.append(gDLL->getText("TXT_KEY_HELPTEXT_UNIT_UPKEEP_FREE_MILITARY_PER_POP", kTrait.getFreeUnitUpkeepMilitaryPopPercent()));
		}
	}

	//	Free military units base
	if (kTrait.getFreeUnitUpkeepMilitary() != 0)
	{
		szHelpString.append(NEWLINE);
		szHelpString.append(gDLL->getText("TXT_KEY_HELPTEXT_UNIT_UPKEEP_FREE_MILITARY", kTrait.getFreeUnitUpkeepMilitary()));
	}

	//	Free Military units population percent
	if (kTrait.getFreeUnitUpkeepMilitaryPopPercent() != 0)
	{
		szHelpString.append(NEWLINE);
		szHelpString.append(gDLL->getText("TXT_KEY_TRAITHELP_FREE_UNIT_UPKEEP_MILITARY_PER_100_POP", kTrait.getFreeUnitUpkeepMilitaryPopPercent()));
	}

	if (kTrait.getCivilianUnitUpkeepMod() != 0)
	{
		szHelpString.append(NEWLINE);
		szHelpString.append(gDLL->getText("TXT_KEY_HELPTEXT_UNIT_UPKEEP_MOD_CIVILIAN", kTrait.getCivilianUnitUpkeepMod()));
	}
	if (kTrait.getMilitaryUnitUpkeepMod() != 0)
	{
		szHelpString.append(NEWLINE);
		szHelpString.append(gDLL->getText("TXT_KEY_HELPTEXT_UNIT_UPKEEP_MOD_MILITARY", kTrait.getMilitaryUnitUpkeepMod()));
	}

	//  Unit Upgrade Cost modifier
	if (kTrait.getUnitUpgradePriceModifier() != 0)
	{
		szHelpString.append(NEWLINE);
		szHelpString.append(gDLL->getText("TXT_KEY_BUILDINGHELP_UNIT_UPGRADE_COST_MOD", kTrait.getUnitUpgradePriceModifier()));
	}

	//	Conscription
	if (kTrait.getMaxConscript() != 0)
	{
		szHelpString.append(NEWLINE);
		szHelpString.append(gDLL->getText("TXT_KEY_CIVICHELP_CONSCRIPTION_CHANGE", kTrait.getMaxConscript()));
	}

	//	Military units produced with food
	if (kTrait.isMilitaryFoodProduction())
	{
		szHelpString.append(NEWLINE);
		szHelpString.append(gDLL->getText("TXT_KEY_CIVICHELP_MILITARY_FOOD"));
	}

	if (kTrait.isUpgradeAnywhere() != 0)
	{
		szHelpString.append(NEWLINE);
		szHelpString.append(gDLL->getText("TXT_KEY_CAN_UPGRADE_ANYWHERE"));

	}

	if (GC.getGame().isOption(GAMEOPTION_RELIGION_INQUISITIONS)
	&& kTrait.isAllowsInquisitions())
	{
		szHelpString.append(NEWLINE);
		szHelpString.append(gDLL->getText("TXT_KEY_CIVICHELP_ALLOW_INQUISITONS"));
	}

	//Global Air Unit Capacity
	if (kTrait.getGlobalAirUnitCapacity() != 0)
	{
		szHelpString.append(NEWLINE);
		szHelpString.append(gDLL->getText("TXT_KEY_TRAITHELP_AIR_UNIT_CAPACITY", kTrait.getGlobalAirUnitCapacity()));
	}

	//Flight Range
	if (kTrait.getFlightOperationRange() != 0)
	{
		szHelpString.append(NEWLINE);
		szHelpString.append(gDLL->getText("TXT_KEY_TRAITHELP_FLIGHT_RANGE", kTrait.getFlightOperationRange()));
	}

	//Missile Cargo Space
	if (kTrait.getMissileCargoSpace() != 0)
	{
		szHelpString.append(NEWLINE);
		szHelpString.append(gDLL->getText("TXT_KEY_TRAITHELP_MISSILE_CARGO_SPACE", kTrait.getMissileCargoSpace()));
	}

	//Missile Range
	if (kTrait.getMissileRange() != 0)
	{
		szHelpString.append(NEWLINE);
		szHelpString.append(gDLL->getText("TXT_KEY_TRAITHELP_MISSILE_RANGE", kTrait.getMissileRange()));
	}

	//Naval Cargo Space
	if (kTrait.getNavalCargoSpace() != 0)
	{
		szHelpString.append(NEWLINE);
		szHelpString.append(gDLL->getText("TXT_KEY_TRAITHELP_NAVAL_CARGO_SPACE", kTrait.getNavalCargoSpace()));
	}

	//Capture Probabilities
	if (kTrait.getNationalCaptureProbabilityModifier() != 0)
	{
		szHelpString.append(NEWLINE);
		szHelpString.append(gDLL->getText("TXT_KEY_NATIONAL_CAPTURE_PROBABILITY_MODIFIER", kTrait.getNationalCaptureProbabilityModifier()));
	}
	if (kTrait.getNationalCaptureResistanceModifier() != 0)
	{
		szHelpString.append(NEWLINE);
		szHelpString.append(gDLL->getText("TXT_KEY_NATIONAL_CAPTURE_RESISTANCE_MODIFIER", kTrait.getNationalCaptureResistanceModifier()));
	}

	// Draft On Capture
	if (kTrait.isDraftsOnCityCapture())
	{
		szHelpString.append(NEWLINE);
		szHelpString.append(gDLL->getText("TXT_KEY_TRAITHELP_DRAFT_ON_CAPTURE"));
	}

	// Extra Goody
	if (kTrait.isExtraGoody())
	{
		szHelpString.append(NEWLINE);
		szHelpString.append(gDLL->getText("TXT_KEY_TRAITHELP_EXTRA_GOODY"));
	}

	//Free Promotions by UnitCombat
	for (int iI = 0; iI < GC.getNumPromotionInfos(); ++iI)
	{
		for (int iJ = 0; iJ < GC.getNumUnitCombatInfos(); iJ++)
		{
			if (kTrait.isFreePromotionUnitCombats(iI, iJ))
			{
				CvWString txt0;
				txt0.Format(
					L"%s%s", NEWLINE,
					gDLL->getText(
						"TXT_KEY_TRAITHELP_FREE_PROMOTION_UNITCOMBAT",
						CvWString(GC.getPromotionInfo((PromotionTypes)iI).getType()).GetCString(),
						GC.getPromotionInfo((PromotionTypes)iI).getDescription()
					).c_str()
				);
				CvWString txt1;
				txt1.Format(L"<link=%s>%s</link>", CvWString(GC.getUnitCombatInfo((UnitCombatTypes)iJ).getType()).GetCString(), GC.getUnitCombatInfo((UnitCombatTypes)iJ).getDescription());

				setListHelp(szHelpString, txt0, txt1, L", ", iI != iLast);
				iLast = iI;
			}
		}
	}

	// iLevelExperienceModifier
	if (kTrait.getLevelExperienceModifier() != 0)
	{
		szHelpString.append(NEWLINE);
		szHelpString.append(gDLL->getText("TXT_KEY_TRAITHELP_CIVIC_LEVEL_MODIFIER", kTrait.getLevelExperienceModifier()));
	}

	//	Free Experience
	if (kTrait.getFreeExperience() != 0)
	{
		szHelpString.append(NEWLINE);
		szHelpString.append(gDLL->getText("TXT_KEY_CIVICHELP_FREE_XP", kTrait.getFreeExperience()));
	}

	// Free Experience by Unit Combat
	for (int iI = 0; iI < kTrait.getNumUnitCombatFreeExperiences(); iI++)
	{
		const int iMod = kTrait.getUnitCombatFreeExperience(iI).iModifier;
		if (iMod != 0 && algo::none_of_equal(iIterationValues, iMod))
		{
			iIterationValues.push_back(iMod);
		}
	}
	foreach_(const int itrValue, iIterationValues)
	{
		bool bFirst = true;
		for (int iI = 0; iI < kTrait.getNumUnitCombatFreeExperiences(); iI++)
		{
			const int iMod = kTrait.getUnitCombatFreeExperience(iI).iModifier;
			if (iMod == itrValue)
			{
				const UnitCombatTypes eTempUnitCombat = kTrait.getUnitCombatFreeExperience(iI).eUnitCombat;
				if (bFirst)
				{
					szHelpString.append(NEWLINE);
					szHelpString.append(gDLL->getText("TXT_KEY_TRAITHELP_UNIT_COMBAT_FREE_XP_FIRST", iMod, CvWString(GC.getUnitCombatInfo(eTempUnitCombat).getType()).GetCString(), GC.getUnitCombatInfo(eTempUnitCombat).getTextKeyWide()));
					bFirst = false;
				}
				else szHelpString.append(gDLL->getText("TXT_KEY_TRAITHELP_UNIT_COMBAT_FREE_XP_ADDITIONAL", CvWString(GC.getUnitCombatInfo(eTempUnitCombat).getType()).GetCString(), GC.getUnitCombatInfo(eTempUnitCombat).getTextKeyWide()));
			}
		}
		szHelpString.append(gDLL->getText("TXT_KEY_TRAITHELP_UNIT_COMBAT_FREE_XP_END"));
	}
	iIterationValues.clear();

	//	State Religion Free Experience
	if (kTrait.getStateReligionFreeExperience() != 0)
	{
		szHelpString.append(NEWLINE);
		szHelpString.append(gDLL->getText("TXT_KEY_CIVICHELP_STATE_REL_FREE_XP", kTrait.getStateReligionFreeExperience()));
	}

	//	Experience in Borders
	if (0 != kTrait.getExpInBorderModifier())
	{
		szHelpString.append(NEWLINE);
		szHelpString.append(gDLL->getText("TXT_KEY_CIVICHELP_EXPERIENCE_IN_BORDERS", kTrait.getExpInBorderModifier()));
	}

	foreach_(const DomainModifier2& pair, kTrait.getDomainFreeExperience())
	{
		szHelpString.append(NEWLINE);
		szHelpString.append(gDLL->getText("TXT_KEY_BUILDINGHELP_FREE_XP", GC.getDomainInfo(pair.first).getTextKeyWide(), pair.second));
	}

	//	Capital XP Modifier
	if (kTrait.getCapitalXPModifier() != 0)
	{
		szHelpString.append(NEWLINE);
		szHelpString.append(gDLL->getText("TXT_KEY_TRAITHELP_CAPITAL_XP_MODIFIER", kTrait.getCapitalXPModifier()));
	}

	//	Holy City of State Religion XP Modifier
	if (kTrait.getHolyCityofStateReligionXPModifier() != 0)
	{
		szHelpString.append(NEWLINE);
		szHelpString.append(gDLL->getText("TXT_KEY_TRAITHELP_HOLY_CITY_STATE_REL_XP_MODIFIER", kTrait.getHolyCityofStateReligionXPModifier()));
	}

	//	Holy City of Non State Religion XP Modifier
	if (kTrait.getHolyCityofNonStateReligionXPModifier() != 0)
	{
		szHelpString.append(NEWLINE);
		szHelpString.append(gDLL->getText("TXT_KEY_TRAITHELP_HOLY_CITY_NON_STATE_REL_XP_MODIFIER", kTrait.getHolyCityofNonStateReligionXPModifier()));
	}

	// Unit Class Production Mods
	iLast = 0;
	for (int iI = 0; iI < GC.getNumUnitInfos(); ++iI)
	{
		if (!isWorldUnit((UnitTypes)iI))
		{
			for (int j = 0; j < kTrait.getNumUnitProductionModifiers(); j++)
			{
				if (kTrait.getUnitProductionModifier(j).eUnit == iI
				&&  kTrait.getUnitProductionModifier(j).iModifier != 0)
				{
					CvWString szText = gDLL->getText("TXT_KEY_TRAITHELP_PRODUCTION_MODIFIER", kTrait.getUnitProductionModifier(j).iModifier);

					CvWString szUnit;

					szUnit.Format(L"<link=%s>%s</link>", CvWString(GC.getUnitInfo((UnitTypes)iI).getType()).GetCString(), GC.getUnitInfo((UnitTypes)iI).getDescription());
					setListHelp(szHelpString, szText.GetCString(), szUnit, L", ", (kTrait.getUnitProductionModifier(j).iModifier != iLast));
					iLast = kTrait.getUnitProductionModifier(j).iModifier;
				}
			}
		}
	}

	// Increase SpecialUnit Production Speeds
	iLast = 0;
	for (int iI = 0; iI < GC.getNumSpecialUnitInfos(); ++iI)
	{
		const SpecialUnitTypes eSpecialUnit = ((SpecialUnitTypes)iI);
		for (int j = 0; j < kTrait.getNumSpecialUnitProductionModifiers(); j++)
		{
			if ((SpecialUnitTypes)kTrait.getSpecialUnitProductionModifier(j).eSpecialUnit == eSpecialUnit)
			{
				CvWString szText = gDLL->getText("TXT_KEY_TRAITHELP_PRODUCTION_MODIFIER", kTrait.getSpecialUnitProductionModifier(j).iModifier);

				setListHelp(szHelpString, szText.GetCString(), GC.getSpecialUnitInfo(eSpecialUnit).getDescription(), L", ", (kTrait.getSpecialUnitProductionModifier(j).iModifier != iLast));
				iLast = kTrait.getSpecialUnitProductionModifier(j).iModifier;
			}
		}
	}

	//	Military unit production modifier
	if (kTrait.getMilitaryProductionModifier() != 0)
	{
		szHelpString.append(NEWLINE);
		szHelpString.append(gDLL->getText("TXT_KEY_CIVICHELP_MILITARY_PRODUCTION", kTrait.getMilitaryProductionModifier()));
	}

	// unit production modifier by Unit Combat
	for (int iI = 0; iI < kTrait.getNumUnitCombatProductionModifiers(); iI++)
	{
		const int iMod = kTrait.getUnitCombatProductionModifier(iI).iModifier;
		if (iMod != 0 && algo::none_of_equal(iIterationValues, iMod))
		{
			iIterationValues.push_back(kTrait.getUnitCombatProductionModifier(iI).iModifier);
		}
	}
	foreach_(const int itrValue, iIterationValues)
	{
		bool bFirst = true;
		for (int iI = 0; iI < kTrait.getNumUnitCombatProductionModifiers(); iI++)
		{
			const int iMod = kTrait.getUnitCombatProductionModifier(iI).iModifier;
			if (iMod == itrValue)
			{
				const UnitCombatTypes eTempUnitCombat = kTrait.getUnitCombatProductionModifier(iI).eUnitCombat;
				if (bFirst)
				{
					szHelpString.append(NEWLINE);
					szHelpString.append(gDLL->getText("TXT_KEY_TRAITHELP_UNIT_PRODUCTION_FIRST", iMod, CvWString(GC.getUnitCombatInfo(eTempUnitCombat).getType()).GetCString(), GC.getUnitCombatInfo(eTempUnitCombat).getTextKeyWide()));
					bFirst = false;
				}
				else szHelpString.append(gDLL->getText("TXT_KEY_TRAITHELP_UNIT_PRODUCTION_ADDITIONAL", CvWString(GC.getUnitCombatInfo(eTempUnitCombat).getType()).GetCString(), GC.getUnitCombatInfo(eTempUnitCombat).getTextKeyWide()));
			}
		}
		szHelpString.append(gDLL->getText("TXT_KEY_TRAITHELP_UNIT_PRODUCTION_END"));
	}
	iIterationValues.clear();

	foreach_(const DomainModifier2& pair, kTrait.getDomainProductionModifiers())
	{
		szHelpString.append(NEWLINE);
		szHelpString.append(gDLL->getText("TXT_KEY_BUILDINGHELP_BUILDS_FASTER_DOMAIN", GC.getDomainInfo(pair.first).getTextKeyWide(), pair.second));
	}

	//	State Religion Unit Production Modifier
	if (kTrait.getStateReligionUnitProductionModifier() != 0)
	{
		szHelpString.append(NEWLINE);
		szHelpString.append(gDLL->getText("TXT_KEY_CIVICHELP_STATE_REL_TRAIN", kTrait.getStateReligionUnitProductionModifier()));
	}

	// iMaxAnarchy
	if (kTrait.getMaxAnarchy() != -1)
	{
		if (kTrait.getMaxAnarchy() == 0)
		{
			szHelpString.append(NEWLINE);
			szHelpString.append(gDLL->getText("TXT_KEY_TRAITHELP_NO_ANARCHY"));
		}
		else
		{
			szHelpString.append(NEWLINE);
			szHelpString.append(gDLL->getText("TXT_KEY_TRAITHELP_MAX_ANARCHY", kTrait.getMaxAnarchy()));
		}
	}

	if (kTrait.getMinAnarchy() > 1)
	{
		szHelpString.append(NEWLINE);
		szHelpString.append(gDLL->getText("TXT_KEY_TRAITHELP_MIN_ANARCHY", kTrait.getMinAnarchy()));
	}

	if (kTrait.getCivicAnarchyTimeModifier() != 0)
	{
		szHelpString.append(NEWLINE);
		szHelpString.append(gDLL->getText("TXT_KEY_CIVICHELP_ANARCHY_CHANGE", kTrait.getCivicAnarchyTimeModifier()));
	}

	if (kTrait.getReligiousAnarchyTimeModifier() != 0)
	{
		szHelpString.append(NEWLINE);
		szHelpString.append(gDLL->getText("TXT_KEY_RELIGIOUS_ANARCHY_CHANGE", kTrait.getReligiousAnarchyTimeModifier()));
	}

	//	Trade routes
	if (kTrait.getTradeRoutes() != 0)
	{
		szHelpString.append(NEWLINE);
		szHelpString.append(gDLL->getText("TXT_KEY_CIVICHELP_TRADE_ROUTES", kTrait.getTradeRoutes()));
	}

	if (kTrait.getCoastalTradeRoutes() != 0)
	{
		szHelpString.append(NEWLINE);
		szHelpString.append(gDLL->getText("TXT_KEY_BUILDINGHELP_COASTAL_TRADE_ROUTES", kTrait.getCoastalTradeRoutes()));
	}

	//	Maximum Trade routes
	if (kTrait.getMaxTradeRoutesChange() != 0)
	{
		szHelpString.append(NEWLINE);
		szHelpString.append(gDLL->getText("TXT_KEY_TRAITHELP_MAX_TRADE_ROUTES", kTrait.getMaxTradeRoutesChange()));
	}

	if (kTrait.getForeignTradeRouteModifier() != 0)
	{
		szHelpString.append(NEWLINE);
		szHelpString.append(gDLL->getText("TXT_KEY_CIVICHELP_FOREIGN_TRADE_ROUTE_MOD", kTrait.getForeignTradeRouteModifier()));
	}

	//CITY DEFENSE
	if (kTrait.getCityDefenseBonus() != 0)
	{
		szHelpString.append(NEWLINE);
		szHelpString.append(gDLL->getText("TXT_KEY_CIVICHELP_CITY_DEFENSE_MOD", kTrait.getCityDefenseBonus()));
	}

	if (kTrait.getEspionageDefense() != 0)
	{
		szHelpString.append(NEWLINE);
		szHelpString.append(gDLL->getText("TXT_KEY_MISC_TRAIT_ESPIONAGE_DEFENSE", kTrait.getEspionageDefense()));
	}

	if (kTrait.getBombardDefense() != 0)
	{
		szHelpString.append(NEWLINE);
		szHelpString.append(gDLL->getText("TXT_KEY_TRAITHELP_BOMBARD_DEFENSE_MOD", -kTrait.getBombardDefense()));
	}

	if (kTrait.isFreedomFighter())
	{
		szHelpString.append(NEWLINE);
		szHelpString.append(gDLL->getText("TXT_KEY_FREEDOM_FIGHTER"));
	}

	if (kTrait.getFreedomFighterChange() != 0)
	{
		szHelpString.append(NEWLINE);
		szHelpString.append(gDLL->getText("TXT_KEY_FREEDOM_FIGHTER_CHANGE", kTrait.getFreedomFighterChange()));
	}

	//	Diplomatic Modifier
	if (kTrait.getAttitudeModifier() > 0)
	{
		szHelpString.append(NEWLINE);
		szHelpString.append(gDLL->getText("TXT_KEY_TRAITHELP_ATTITUDE_MODIFIER_POSITIVE", kTrait.getAttitudeModifier()));
	}

	if (kTrait.getAttitudeModifier() < 0)
	{
		szHelpString.append(NEWLINE);
		szHelpString.append(gDLL->getText("TXT_KEY_TRAITHELP_ATTITUDE_MODIFIER_NEGATIVE", kTrait.getAttitudeModifier()));
	}

	//RELIGION SPREADS
	if (kTrait.getStateReligionSpreadProbabilityModifier() != 0)
	{
		szHelpString.append(NEWLINE);
		szHelpString.append(gDLL->getText("TXT_KEY_TRAITHELP_STATE_REL_SPREAD_MODIFIER", kTrait.getStateReligionSpreadProbabilityModifier()));
	}

	if (kTrait.getNonStateReligionSpreadProbabilityModifier() != 0)
	{
		szHelpString.append(NEWLINE);
		szHelpString.append(gDLL->getText("TXT_KEY_TRAITHELP_NON_STATE_REL_SPREAD_MODIFIER", kTrait.getNonStateReligionSpreadProbabilityModifier()));
	}

	if (GC.getGame().isOption(GAMEOPTION_RELIGION_DISABLING))
	{
		// All Religions active
		if (kTrait.isAllReligionsActive())
		{
			szHelpString.append(NEWLINE);
			szHelpString.append(gDLL->getText("TXT_KEY_ALL_RELIGIONS_ACTIVE"));
		}

		if (kTrait.isBansNonStateReligions())
		{
			szHelpString.append(NEWLINE);
			szHelpString.append(gDLL->getText("TXT_KEY_BANS_NON_STATE_RELIGIONS"));
		}
	}

	//	Golden Age Modifier
	if (kTrait.getGoldenAgeDurationModifier() != 0)
	{
		szHelpString.append(NEWLINE);
		szHelpString.append(gDLL->getText("TXT_KEY_BUILDINGHELP_GOLDENAGE_MOD", kTrait.getGoldenAgeDurationModifier()));
	}

	//	Golden Age On Birth of GP
	if (kTrait.getGoldenAgeonBirthofGreatPeopleType() != NO_UNIT)
	{
		szHelpString.append(NEWLINE);
		szHelpString.append(gDLL->getText("TXT_KEY_TRAITHELP_GOLDEN_AGE_ON_BIRTH_OF_GP_TYPE", GC.getUnitInfo((UnitTypes)kTrait.getGoldenAgeonBirthofGreatPeopleType()).getTextKeyWide()));
	}

	// Populationgrowthratepercentage
	if (kTrait.getGlobalPopulationgrowthratepercentage() > 0)
	{
		szHelpString.append(NEWLINE);
		szHelpString.append(gDLL->getText("TXT_KEY_BUILDINGHELP_CITY_SLOW_GROWTH_SPEED", kTrait.getGlobalPopulationgrowthratepercentage()));
	}
	else if (kTrait.getGlobalPopulationgrowthratepercentage() < 0)
	{
		szHelpString.append(NEWLINE);
		szHelpString.append(gDLL->getText("TXT_KEY_BUILDINGHELP_CITY_FAST_GROWTH_SPEED", kTrait.getGlobalPopulationgrowthratepercentage()));
	}

	// City Start Population Bonus
	if (kTrait.getBonusPopulationinNewCities() != 0)
	{
		szHelpString.append(NEWLINE);
		szHelpString.append(gDLL->getText("TXT_KEY_TRAITHELP_CITY_START_POPULATION", kTrait.getBonusPopulationinNewCities()));
	}

	// City Start Culture
	if (kTrait.getCityStartCulture() != 0)
	{
		szHelpString.append(NEWLINE);
		szHelpString.append(gDLL->getText("TXT_KEY_TRAITHELP_CITY_START_CULTURE", kTrait.getCityStartCulture()));
	}

	// City Start State Religion
	if (kTrait.isCitiesStartwithStateReligion())
	{
		szHelpString.append(NEWLINE);
		szHelpString.append(gDLL->getText("TXT_KEY_TRAITHELP_CITY_START_STATE_RELIGION"));
	}

	//REVOLUTIONS
	if (GC.getGame().isOption(GAMEOPTION_UNSUPPORTED_REVOLUTION))
	{
		if (GC.getGame().getActivePlayer() != NO_PLAYER && GET_PLAYER(GC.getGame().getActivePlayer()).isModderOption(MODDEROPTION_SHOW_REV_EFFECTS))
		{
			//  Revolution Local Civic Index Modifiers
			if (0 != kTrait.getRevIdxLocal())
			{
				if ( kTrait.getRevIdxLocal() > 0 )
				{
					szHelpString.append(NEWLINE);
					szHelpString.append(gDLL->getText("TXT_KEY_CIVICHELP_REV_INDEX_LOCAL_PENALTY", kTrait.getRevIdxLocal()));
				}
				if ( kTrait.getRevIdxLocal() < 0 )
				{
					szHelpString.append(NEWLINE);
					szHelpString.append(gDLL->getText("TXT_KEY_CIVICHELP_REV_INDEX_LOCAL_BONUS", abs(kTrait.getRevIdxLocal())));
				}
			}

			//  Revolution National Civic Index Modifiers
			if (0 != kTrait.getRevIdxNational())
			{
				if ( kTrait.getRevIdxNational() > 0 )
				{
					szHelpString.append(NEWLINE);
					szHelpString.append(gDLL->getText("TXT_KEY_CIVICHELP_REV_INDEX_NATIONAL_PENALTY", kTrait.getRevIdxNational()));
				}
				if ( kTrait.getRevIdxNational() < 0 )
				{
					szHelpString.append(NEWLINE);
					szHelpString.append(gDLL->getText("TXT_KEY_CIVICHELP_REV_INDEX_NATIONAL_BONUS", abs(kTrait.getRevIdxNational())));
				}
			}

			//  Revolution Good Holy City Modifier
			if (0 != kTrait.getRevIdxHolyCityGood())
			{
				szHelpString.append(NEWLINE);
				szHelpString.append(gDLL->getText("TXT_KEY_CIVICHELP_REV_GOOD_HOLY_CITY", kTrait.getRevIdxHolyCityGood()));
			}

			//  Revolution Bad Holy City Modifier
			if (0 != kTrait.getRevIdxHolyCityBad())
			{
				szHelpString.append(NEWLINE);
				szHelpString.append(gDLL->getText("TXT_KEY_CIVICHELP_REV_BAD_HOLY_CITY", kTrait.getRevIdxHolyCityBad()));
			}

			//  Revolution Nationality Modifier
			if (0 != kTrait.getRevIdxNationalityMod())
			{
				if (kTrait.getRevIdxNationalityMod() < 0)
				{
					szHelpString.append(NEWLINE);
					CvWString txt0;
					txt0.Format(L"%.0f", 100 * kTrait.getRevIdxNationalityMod());
					szHelpString.append(gDLL->getText("TXT_KEY_CIVICHELP_REV_NATIONALITY_REDUCTION_MOD", txt0.GetCString()));
				}
				if (kTrait.getRevIdxNationalityMod() > 0)
				{
					szHelpString.append(NEWLINE);
					CvWString txt0;
					txt0.Format(L"%.0f", 100 * kTrait.getRevIdxNationalityMod());
					szHelpString.append(gDLL->getText("TXT_KEY_CIVICHELP_REV_NATIONALITY_INCREASE_MOD", txt0.GetCString()));
				}
			}

			//  Revolution Bad Religion Modifier
			if (0 != kTrait.getRevIdxBadReligionMod())
			{
				szHelpString.append(NEWLINE);
				CvWString txt0;
				txt0.Format(L"%.0f", 100 * kTrait.getRevIdxBadReligionMod());
				szHelpString.append(gDLL->getText("TXT_KEY_CIVICHELP_REV_BAD_RELIGION_MOD", txt0.GetCString()));
			}

			//  Revolution Good Religion Modifier
			if (0 != kTrait.getRevIdxGoodReligionMod())
			{
				szHelpString.append(NEWLINE);
				CvWString txt0;
				txt0.Format(L"%.0f", 100 * kTrait.getRevIdxGoodReligionMod());
				szHelpString.append(gDLL->getText("TXT_KEY_CIVICHELP_REV_GOOD_RELIGION_MOD", txt0.GetCString()));
			}

			//  Revolution City Distance Modifier
			if (0 != kTrait.getRevIdxDistanceModifier())
			{
				if (kTrait.getRevIdxDistanceModifier() < 0)
				{
					szHelpString.append(NEWLINE);
					szHelpString.append(gDLL->getText("TXT_KEY_CIVICHELP_CITY_DISTANCE_GOOD_MOD", kTrait.getRevIdxDistanceModifier()));
				}
				if (kTrait.getRevIdxDistanceModifier() > 0)
				{
					szHelpString.append(NEWLINE);
					szHelpString.append(gDLL->getText("TXT_KEY_CIVICHELP_CITY_DISTANCE_BAD_MOD", abs(kTrait.getRevIdxDistanceModifier())));
				}
			}
		}
		else
		{
			//All of these include the newline in their text
			if (kTrait.getRevIdxLocal() > 0)
			{
				szHelpString.append(gDLL->getText("TXT_KEY_INCREASE_LOCAL_REBELS", kTrait.getRevIdxLocal()));
			}
			else if (kTrait.getRevIdxLocal() < 0)
			{
				szHelpString.append(gDLL->getText("TXT_KEY_DECREASE_LOCAL_REBELS", kTrait.getRevIdxLocal()));
			}
			if (kTrait.getRevIdxNational() > 0)
			{
				szHelpString.append(gDLL->getText("TXT_KEY_INCREASE_NATIONAL_REBELS", kTrait.getRevIdxNational()));
			}
			else if (kTrait.getRevIdxNational() < 0)
			{
				szHelpString.append(gDLL->getText("TXT_KEY_DECREASE_NATIONAL_REBELS", kTrait.getRevIdxNational()));
			}
			if (kTrait.getRevIdxHolyCityGood() > 0)
			{
				szHelpString.append(gDLL->getText("TXT_KEY_STATE_RELIGION_WITH_HOLY_CITY", kTrait.getRevIdxHolyCityGood()));
			}
			if (kTrait.getRevIdxHolyCityBad() > 0)
			{
				szHelpString.append(gDLL->getText("TXT_KEY_STATE_RELIGION_WITHOUT_HOLY_CITY", kTrait.getRevIdxHolyCityBad()));
			}
		}
	}

	// iUpkeepModifier
	if (kTrait.getUpkeepModifier() != 0)
	{
		szHelpString.append(NEWLINE);
		szHelpString.append(gDLL->getText("TXT_KEY_TRAITHELP_CIVIC_UPKEEP_MODIFIER", kTrait.getUpkeepModifier()));
	}

	// No Civic Maintenance
	for (int iI = 0; iI < kTrait.getNumCivicOptionNoUpkeepTypes(); iI++)
	{
		const CivicOptionTypes eCivicOption = (CivicOptionTypes)kTrait.isCivicOptionNoUpkeepType(iI).eCivicOption;
		if (eCivicOption != NO_CIVICOPTION && kTrait.isCivicOptionNoUpkeepType(iI).bBool)
		{
			szHelpString.append(NEWLINE);
			szHelpString.append(gDLL->getText("TXT_KEY_TRAITHELP_NO_UPKEEP", GC.getCivicOptionInfo(eCivicOption).getTextKeyWide()));
		}
	}

	//	Distance Maintenance Modifer...
	if (kTrait.getDistanceMaintenanceModifier() != 0)
	{
		szHelpString.append(NEWLINE);
		szHelpString.append(gDLL->getText("TXT_KEY_CIVICHELP_DISTANCE_MAINT_MOD", kTrait.getDistanceMaintenanceModifier()));
	}

	//	Num Cities Maintenance Modifer...
	if (kTrait.getNumCitiesMaintenanceModifier() != 0)
	{
		szHelpString.append(NEWLINE);
		szHelpString.append(gDLL->getText("TXT_KEY_CIVICHELP_NO_MAINT_NUM_CITIES_MOD", kTrait.getNumCitiesMaintenanceModifier()));
	}
	//	Corporations Maintenance Modifer...
	if (kTrait.getCorporationMaintenanceModifier() != 0)
	{
		szHelpString.append(NEWLINE);
		szHelpString.append(gDLL->getText("TXT_KEY_CIVICHELP_NO_MAINT_CORPORATION_MOD", kTrait.getCorporationMaintenanceModifier()));
	}

	//	Worker speed modifier positive
	if (kTrait.getWorkerSpeedModifier() > 0)
	{
		szHelpString.append(NEWLINE);
		szHelpString.append(gDLL->getText("TXT_KEY_TRAITHELP_WORKER_SPEED_POSITIVE", kTrait.getWorkerSpeedModifier()));
	}

	//	Worker speed modifier negative
	if (kTrait.getWorkerSpeedModifier() < 0)
	{
		szHelpString.append(NEWLINE);
		szHelpString.append(gDLL->getText("TXT_KEY_TRAITHELP_WORKER_SPEED_NEGATIVE", kTrait.getWorkerSpeedModifier()));
	}

	//	Improvement upgrade rate modifier
	if (kTrait.getImprovementUpgradeRateModifier() != 0)
	{
		szHelpString.append(NEWLINE);
		szHelpString.append(gDLL->getText("TXT_KEY_IMPROVEMENTHELP_UPGRADE_RATE_MODIFIER", kTrait.getImprovementUpgradeRateModifier()));
	}

	foreach_(const ImprovementModifier& pair, kTrait.getImprovementUpgradeModifiers())
	{
		if (algo::none_of_equal(iIterationValues, pair.second))
		{
			iIterationValues.push_back(pair.second);
		}
	}

	foreach_(const int itrValue, iIterationValues)
	{
		bool bFirst = true;
		foreach_(const ImprovementModifier& pair, kTrait.getImprovementUpgradeModifiers())
		{
			if (pair.second == itrValue)
			{
				const CvImprovementInfo& kTempImprovement = GC.getImprovementInfo(pair.first);
				if (bFirst)
				{
					szHelpString.append(NEWLINE);
					szHelpString.append(gDLL->getText("TXT_KEY_IMPROVEMENTHELP_UPGRADE_RATE_MODIFIER_SPECIFIC", pair.second, CvWString(kTempImprovement.getType()).c_str(), kTempImprovement.getTextKeyWide()));
					bFirst = false;
				}
				else szHelpString.append(gDLL->getText("TXT_KEY_IMPROVEMENTHELP_UPGRADE_RATE_MODIFIER_ADDITIONAL", CvWString(kTempImprovement.getType()).c_str(), kTempImprovement.getTextKeyWide()));
			}
		}
		szHelpString.append(gDLL->getText("TXT_KEY_IMPROVEMENTHELP_UPGRADE_RATE_MODIFIER_END"));
	}
	iIterationValues.clear();


	foreach_(const BuildModifier2& pair, kTrait.getBuildWorkerSpeedModifiers())
	{
		if (algo::none_of_equal(iIterationValues, pair.second))
		{
			iIterationValues.push_back(pair.second);
		}
	}
	foreach_(const int itrValue, iIterationValues)
	{
		bool bFirst = true;
		foreach_(const BuildModifier2& pair, kTrait.getBuildWorkerSpeedModifiers())
		{
			if (pair.second == itrValue)
			{
				const CvBuildInfo& kTempBuild = GC.getBuildInfo(pair.first);
				if (bFirst)
				{
					szHelpString.append(NEWLINE);
					szHelpString.append(gDLL->getText("TXT_KEY_BUILDHELP_WORKER_SPEED_MODIFIER_SPECIFIC", pair.second, CvWString(kTempBuild.getType()).c_str(), kTempBuild.getDescription()));
					bFirst = false;
				}
				else szHelpString.append(gDLL->getText("TXT_KEY_BUILDHELP_WORKER_SPEED_MODIFIER_ADDITIONAL", CvWString(kTempBuild.getType()).c_str(), kTempBuild.getDescription()));
			}
		}
	}
	iIterationValues.clear();

	// Tech Research Modifier
	foreach_(const TechModifier& pair, kTrait.getTechResearchModifiers())
	{
		if (algo::none_of_equal(iIterationValues, pair.second))
		{
			iIterationValues.push_back(pair.second);
		}
	}
	foreach_(const int itrValue, iIterationValues)
	{
		bool bFirst = true;
		foreach_(const TechModifier& pair, kTrait.getTechResearchModifiers())
		{
			if (pair.second == itrValue)
			{
				const CvTechInfo& kTempTech = GC.getTechInfo(pair.first);
				if (bFirst)
				{
					szHelpString.append(NEWLINE);
					szHelpString.append(gDLL->getText("TXT_KEY_TRAITHELP_TECH_RESEARCH_MODIFIER_FIRST", pair.second, CvWString(kTempTech.getType()).c_str(), kTempTech.getTextKeyWide()));
					bFirst = false;
				}
				else szHelpString.append(gDLL->getText("TXT_KEY_TRAITHELP_TECH_RESEARCH_MODIFIER_ADDITIONAL", CvWString(kTempTech.getType()).GetCString(), kTempTech.getTextKeyWide()));
			}
		}
		szHelpString.append(gDLL->getText("TXT_KEY_TRAITHELP_TECH_RESEARCH_MODIFIER_END"));
	}
	iIterationValues.clear();

	// SpecialBuildings
	iLast = 0;
	foreach_(const SpecialBuildingModifier& pair, kTrait.getSpecialBuildingProductionModifiers())
	{
		CvWString szText = gDLL->getText("TXT_KEY_TRAITHELP_PRODUCTION_MODIFIER", pair.second);

		setListHelp(szHelpString, szText.c_str(), GC.getSpecialBuildingInfo(pair.first).getDescription(), L", ", (pair.second != iLast));
		iLast = pair.second;
	}

	// Buildings
	iLast = 0;
	for (int iI = 0; iI < GC.getNumBuildingInfos(); ++iI)
	{
		const BuildingTypes eTypeX = static_cast<BuildingTypes>(iI);

		if (!isWorldWonder(eTypeX))
		{
			for (int j = 0; j < kTrait.getNumBuildingProductionModifiers(); j++)
			{
				if (kTrait.getBuildingProductionModifier(j).eBuilding == eTypeX
				&&  kTrait.getBuildingProductionModifier(j).iModifier != 0)
				{
					CvWString szText = gDLL->getText("TXT_KEY_TRAITHELP_PRODUCTION_MODIFIER", kTrait.getBuildingProductionModifier(j).iModifier);
					CvWString szBuilding;
					szBuilding.Format(L"<link=%s>%s</link>", CvWString(GC.getBuildingInfo(eTypeX).getType()).GetCString(), GC.getBuildingInfo(eTypeX).getDescription());
					setListHelp(szHelpString, szText.GetCString(), szBuilding, L", ", (kTrait.getBuildingProductionModifier(j).iModifier != iLast));
					iLast = kTrait.getBuildingProductionModifier(j).iModifier;
				}
			}
		}
	}

	// Buildings
	iLast = 0;
	foreach_(const BuildingModifier2& pair, kTrait.getBuildingHappinessModifiersFiltered())
	{
		if (!isWorldWonder(pair.first))
		{
			CvWString szText;
			if (pair.second > 0)
			{
				szText = gDLL->getText("TXT_KEY_TRAITHELP_BUILDING_HAPPINESS", pair.second, gDLL->getSymbolID(HAPPY_CHAR));
			}
			else szText = gDLL->getText("TXT_KEY_TRAITHELP_BUILDING_HAPPINESS", -pair.second, gDLL->getSymbolID(UNHAPPY_CHAR));

			CvWString szBuilding;
			szBuilding.Format(L"<link=%s>%s</link>", CvWString(GC.getBuildingInfo(pair.first).getType()).c_str(), GC.getBuildingInfo(pair.first).getDescription());
			setListHelp(szHelpString, szText.c_str(), szBuilding, L", ", pair.second != iLast);
			iLast = pair.second;
		}
	}

	// Property manipulators
	const CvPropertyManipulators* pMani = kTrait.getPropertyManipulators();
	if (pMani) pMani->buildDisplayString(szHelpString);
}



void CvGameTextMgr::parseLeaderTraits(CvWStringBuffer &szHelpString, LeaderHeadTypes eLeader, CivilizationTypes eCivilization, bool bDawnOfMan, bool bCivilopediaText)
{
	PROFILE_FUNC();

	// Build help string
	if (eLeader != NO_LEADER)
	{
		bool bFirst = true;
		if (!bDawnOfMan && !bCivilopediaText)
		{
			szHelpString.append(CvWString::format(SETCOLR L"%s" ENDCOLR , TEXT_COLOR("COLOR_HIGHLIGHT_TEXT"), GC.getLeaderHeadInfo(eLeader).getDescription()));
			bFirst = false;
		}
		FAssertMsg(
			GC.getNumTraitInfos() > 0,
			"GC.getNumTraitInfos() is less than or equal to zero but is expected to be larger than zero in CvSimpleCivPicker::setLeaderText"
		);


		int iNumCoreDefaultTraits = GC.getLeaderHeadInfo(eLeader).getNumDefaultTraits();
		int iNumDefaultComplexTraits = GC.getLeaderHeadInfo(eLeader).getNumDefaultComplexTraits();
		TraitTypes eTrait = NO_TRAIT;

		if (GC.getGame().isOption(GAMEOPTION_LEADER_COMPLEX_TRAITS) && iNumDefaultComplexTraits > 0)
		{
			for (int iI = 0; iI < iNumDefaultComplexTraits; ++iI)
			{
				if (GC.getLeaderHeadInfo(eLeader).isDefaultComplexTrait(iI))
				{
					eTrait = TraitTypes(GC.getLeaderHeadInfo(eLeader).getDefaultComplexTrait(iI));
					if (GC.getTraitInfo(eTrait).isValidTrait(true))
					{
						if (!bFirst)
						{
							if (bDawnOfMan)
								szHelpString.append(L", ");
							else if (bCivilopediaText)
								szHelpString.append(L"\n\n");
							else szHelpString.append(L"\n");
						}
						else bFirst = false;

						parseTraits(szHelpString, eTrait, bDawnOfMan);
					}
				}
			}
		}
		else if (iNumCoreDefaultTraits > 0)
		{
			for (int iI = 0; iI < iNumCoreDefaultTraits; ++iI)
			{
				if (GC.getLeaderHeadInfo(eLeader).isDefaultTrait(iI))
				{
					eTrait = TraitTypes(GC.getLeaderHeadInfo(eLeader).getDefaultTrait(iI));
					if (GC.getTraitInfo(eTrait).isValidTrait(true))
					{
						if (!bFirst)
						{
							if (bDawnOfMan)
								szHelpString.append(L", ");
							else if (bCivilopediaText)
								szHelpString.append(L"\n\n");
							else szHelpString.append(L"\n");
						}
						else bFirst = false;

						parseTraits(szHelpString, eTrait, bDawnOfMan);
					}
				}
			}
		}
		else
		{
			for (int iI = 0; iI < GC.getNumTraitInfos(); ++iI)
			{
				eTrait = TraitTypes(iI);
				if (GC.getLeaderHeadInfo(eLeader).hasTrait(eTrait) && GC.getTraitInfo(eTrait).isValidTrait(true))
				{
					if (!bFirst)
					{
						if (bDawnOfMan)
							szHelpString.append(L", ");
						else if (bCivilopediaText)
							szHelpString.append(L"\n\n");
						else szHelpString.append(L"\n");
					}
					else bFirst = false;

					parseTraits(szHelpString, eTrait, bDawnOfMan);
				}
			}
		}
	}
	else //	Random leader
	{
		szHelpString.append(CvWString::format(SETCOLR L"%s" ENDCOLR , TEXT_COLOR("COLOR_HIGHLIGHT_TEXT"), gDLL->getText("TXT_KEY_TRAITHELP_PLAYER_UNKNOWN").c_str()));
	}
}


void CvGameTextMgr::parseLeaderShortTraits(CvWStringBuffer &szHelpString, LeaderHeadTypes eLeader)
{
	PROFILE_FUNC();

	//	Build help string
	if (eLeader != NO_LEADER)
	{
		FAssertMsg((GC.getNumTraitInfos() > 0),
			"GC.getNumTraitInfos() is less than or equal to zero but is expected to be larger than zero in CvSimpleCivPicker::setLeaderText");

		int iNumCoreDefaultTraits = GC.getLeaderHeadInfo(eLeader).getNumDefaultTraits();
		int iNumDefaultComplexTraits = GC.getLeaderHeadInfo(eLeader).getNumDefaultComplexTraits();
		TraitTypes eTrait = NO_TRAIT;
		bool bFirst = true;

		if (GC.getGame().isOption(GAMEOPTION_LEADER_COMPLEX_TRAITS) && iNumDefaultComplexTraits > 0)
		{
			for (int iI = 0; iI < iNumDefaultComplexTraits; ++iI)
			{
				if (GC.getLeaderHeadInfo(eLeader).isDefaultTrait(iI))
				{
					eTrait = TraitTypes(GC.getLeaderHeadInfo(eLeader).getDefaultComplexTrait(iI));
					if (!(GC.getGame().isOption(GAMEOPTION_LEADER_NO_NEGATIVE_TRAITS) && GC.getTraitInfo(eTrait).isNegativeTrait()) &&
						!(GC.getGame().isOption(GAMEOPTION_LEADER_START_NO_POSITIVE_TRAITS) && !GC.getTraitInfo(eTrait).isNegativeTrait()) &&
						((GC.getGame().isOption(GAMEOPTION_LEADER_DEVELOPING) && (GC.getTraitInfo(eTrait).getLinePriority() != 0 || GC.getTraitInfo(eTrait).isCivilizationTrait())) ||
						(!GC.getGame().isOption(GAMEOPTION_LEADER_DEVELOPING) && GC.getTraitInfo(eTrait).getLinePriority() == 0)))
					{
						if (!bFirst)
						{
							szHelpString.append(L"/");
						}
						szHelpString.append(gDLL->getText(GC.getTraitInfo(eTrait).getShortDescription()));
						bFirst = false;
					}
				}
			}
		}
		else if (iNumCoreDefaultTraits > 0)
		{
			for (int iI = 0; iI < iNumCoreDefaultTraits; ++iI)
			{
				if (GC.getLeaderHeadInfo(eLeader).isDefaultTrait(iI))
				{
					eTrait = TraitTypes(GC.getLeaderHeadInfo(eLeader).getDefaultTrait(iI));
					if (!(GC.getGame().isOption(GAMEOPTION_LEADER_NO_NEGATIVE_TRAITS) && GC.getTraitInfo(eTrait).isNegativeTrait()) &&
						!(GC.getGame().isOption(GAMEOPTION_LEADER_START_NO_POSITIVE_TRAITS) && !GC.getTraitInfo(eTrait).isNegativeTrait()) &&
						((GC.getGame().isOption(GAMEOPTION_LEADER_DEVELOPING) && (GC.getTraitInfo(eTrait).getLinePriority() != 0 || GC.getTraitInfo(eTrait).isCivilizationTrait())) ||
						(!GC.getGame().isOption(GAMEOPTION_LEADER_DEVELOPING) && GC.getTraitInfo(eTrait).getLinePriority() == 0)))
					{
						if (!bFirst)
						{
							szHelpString.append(L"/");
						}
						szHelpString.append(gDLL->getText(GC.getTraitInfo(eTrait).getShortDescription()));
						bFirst = false;
					}
				}
			}
		}
		else
		{
			for (int iI = 0; iI < GC.getNumTraitInfos(); ++iI)
			{
				eTrait = ((TraitTypes)iI);
				if (GC.getLeaderHeadInfo(eLeader).hasTrait(eTrait) && !(GC.getGame().isOption(GAMEOPTION_LEADER_NO_NEGATIVE_TRAITS) && GC.getTraitInfo(eTrait).isNegativeTrait()) &&
					!(GC.getGame().isOption(GAMEOPTION_LEADER_START_NO_POSITIVE_TRAITS) && !GC.getTraitInfo(eTrait).isNegativeTrait()) &&
					((GC.getGame().isOption(GAMEOPTION_LEADER_DEVELOPING) && (GC.getTraitInfo(eTrait).getLinePriority() != 0 || GC.getTraitInfo(eTrait).isCivilizationTrait())) ||
					(!GC.getGame().isOption(GAMEOPTION_LEADER_DEVELOPING) && GC.getTraitInfo(eTrait).getLinePriority() == 0)))
				{
					if (!bFirst)
					{
						szHelpString.append(L"/");
					}
					szHelpString.append(gDLL->getText(GC.getTraitInfo(eTrait).getShortDescription()));
					bFirst = false;
				}
			}
		}
	}
	else
	{
		//	Random leader
		szHelpString.append(CvWString("???/???"));
	}

	//	return szHelpString;
}

//
// Build Civilization Info Help Text
//
void CvGameTextMgr::parseCivInfos(CvWStringBuffer &szInfoText, CivilizationTypes eCivilization, bool bDawnOfMan, bool bLinks)
{
	PROFILE_FUNC();

	if (eCivilization == NO_CIVILIZATION)
	{//	This is a civless civ, let us know here...
		szInfoText.append(gDLL->getText("TXT_KEY_CIV_UNKNOWN"));
		return;
	}
	if (!bDawnOfMan)
	{
		CvWString szBuffer;
		CvWString szText;
		// Civ Name
		szBuffer.Format(SETCOLR L"%s" ENDCOLR , TEXT_COLOR("COLOR_HIGHLIGHT_TEXT"), GC.getCivilizationInfo(eCivilization).getDescription());
		szInfoText.append(szBuffer);

		// Free Techs
		szBuffer.Format(NEWLINE SETCOLR L"%s" ENDCOLR , TEXT_COLOR("COLOR_ALT_HIGHLIGHT_TEXT"), gDLL->getText("TXT_KEY_FREE_TECHS").GetCString());
		szInfoText.append(szBuffer);

		bool bFound = false;
		for (int iI = 0; iI < GC.getNumTechInfos(); ++iI)
		{
			if (GC.getCivilizationInfo(eCivilization).isCivilizationFreeTechs(iI))
			{
				bFound = true;
				// Add Tech
				szText.Format((bLinks ? L"<link=%s>%s</link>" : L"%s"), CvWString(GC.getTechInfo((TechTypes)iI).getType()).GetCString(), GC.getTechInfo((TechTypes)iI).getDescription());
				szBuffer.Format(L"%s  %c%s", NEWLINE, gDLL->getSymbolID(BULLET_CHAR), szText.GetCString());
				szInfoText.append(szBuffer);
			}
		}
		if (!bFound)
		{
			szBuffer.Format(L"%s  %s", NEWLINE, gDLL->getText("TXT_KEY_FREE_TECHS_NO").GetCString());
			szInfoText.append(szBuffer);
		}
	}
}


// BUG - Specialist Actual Effects - start
void CvGameTextMgr::parseSpecialistHelp(CvWStringBuffer &szHelpString, SpecialistTypes eSpecialist, CvCity* pCity, bool bCivilopediaText)
{
	parseSpecialistHelpActual(szHelpString, eSpecialist, pCity, bCivilopediaText, 0);
}

void CvGameTextMgr::parseSpecialistHelpActual(CvWStringBuffer &szHelpString, SpecialistTypes eSpecialist, CvCity* pCity, bool bCivilopediaText, int iChange)
// BUG - Specialist Actual Effects - end
{
	PROFILE_FUNC();

	if (eSpecialist == NO_SPECIALIST)
	{
		return;
	}

	if (!bCivilopediaText)
	{
		szHelpString.append(GC.getSpecialistInfo(eSpecialist).getDescription());
	}

	{
		int aiYields[NUM_YIELD_TYPES];
		for (int iI = 0; iI < NUM_YIELD_TYPES; ++iI)
		{
			if (GC.getGame().getActivePlayer() == NO_PLAYER)
			{
				aiYields[iI] = GC.getSpecialistInfo(eSpecialist).getYieldChange(iI);
			}
			else if (!pCity)
			{
				aiYields[iI] = GET_PLAYER(GC.getGame().getActivePlayer()).specialistYield(eSpecialist, (YieldTypes)iI);
			}
			else
			{
				aiYields[iI] = pCity->specialistYield(eSpecialist, (YieldTypes)iI);
			}
		}
		setYieldChangeHelp(szHelpString, L"", L"", L"", aiYields);
	}

	{
		int aiCommerces[NUM_COMMERCE_TYPES];
		for (int iI = 0; iI < NUM_COMMERCE_TYPES; ++iI)
		{
			if (GC.getGame().getActivePlayer() == NO_PLAYER)
			{
				aiCommerces[iI] = GC.getSpecialistInfo(eSpecialist).getCommerceChange(iI);
			}
			else if (!pCity)
			{
				aiCommerces[iI] = GET_PLAYER(GC.getGame().getActivePlayer()).specialistCommerce(eSpecialist, (CommerceTypes)iI);
			}
			else
			{
				aiCommerces[iI] = pCity->specialistCommerce(eSpecialist, (CommerceTypes)iI);
			}
		}
		listCommerceChange(szHelpString, CvWString::format(L"\n%c", gDLL->getSymbolID(BULLET_CHAR)), L"", aiCommerces);
	}

	if (GC.getSpecialistInfo(eSpecialist).getExperience() > 0)
	{
		szHelpString.append(NEWLINE);
		szHelpString.append(gDLL->getText("TXT_KEY_SPECIALISTHELP_EXPERIENCE", GC.getSpecialistInfo(eSpecialist).getExperience()));
	}

	for (int iI = GC.getNumUnitCombatInfos() - 1; iI > -1; iI--)
	{
		const UnitCombatTypes eUnitCombat = static_cast<UnitCombatTypes>(iI);

		int iUnitCombatExperience = 0;
		for (int iJ = 0; iJ < GC.getSpecialistInfo(eSpecialist).getNumUnitCombatExperienceTypes(); iJ++)
		{
			if (GC.getSpecialistInfo(eSpecialist).getUnitCombatExperienceType(iJ).eUnitCombat == eUnitCombat)
			{
				iUnitCombatExperience += GC.getSpecialistInfo(eSpecialist).getUnitCombatExperienceType(iJ).iModifier;
			}
		}
		if (iUnitCombatExperience > 0)
		{
			szHelpString.append(NEWLINE);
			szHelpString.append(gDLL->getText("TXT_KEY_SPECIALISTHELP_UNIT_COMBAT_EXPERIENCE", iUnitCombatExperience, GC.getUnitCombatInfo(eUnitCombat).getTextKeyWide()));
		}
	}

	if (GC.getSpecialistInfo(eSpecialist).getGreatPeopleRateChange() != 0)
	{
		szHelpString.append(NEWLINE);
		szHelpString.append(gDLL->getText("TXT_KEY_SPECIALISTHELP_BIRTH_RATE", GC.getSpecialistInfo(eSpecialist).getGreatPeopleRateChange()));
	}
	CvWString szTempBuffer;

	if (GC.getSpecialistInfo(eSpecialist).getInsidiousness() != 0)
	{
		szHelpString.append(NEWLINE);
		float fValue = (float)GC.getSpecialistInfo(eSpecialist).getInsidiousness();
		{
			szTempBuffer.Format(L"%.1f", fValue/10);
		}
		szHelpString.append(gDLL->getText("TXT_KEY_SPECIALISTHELP_INSIDIOUSNESS", szTempBuffer.GetCString()));
	}

	if (GC.getSpecialistInfo(eSpecialist).getInvestigation() != 0)
	{
		szHelpString.append(NEWLINE);
		float fValue = (float)GC.getSpecialistInfo(eSpecialist).getInvestigation();
		{
			szTempBuffer.Format(L"%.1f", fValue/10);
		}
		szHelpString.append(gDLL->getText("TXT_KEY_SPECIALISTHELP_INVESTIGATION", szTempBuffer.GetCString()));
	}

	for (int iI = 0; iI < GC.getNumTechInfos(); iI++)
	{
		const TechTypes eTech = static_cast<TechTypes>(iI);
		int iSpecialistHealth = GC.getSpecialistInfo(eSpecialist).getTechHealth(eTech);

		if (iSpecialistHealth > 0)
		{
			szHelpString.append(NEWLINE);
			if (GC.getGame().getActivePlayer() != NO_PLAYER && pCity && GET_TEAM(pCity->getTeam()).isHasTech(eTech))
			{
				szHelpString.append(gDLL->getText("TXT_KEY_SPECIALISTHELP_TECH_HEALTH_TYPE_KNOWN", iSpecialistHealth, gDLL->getSymbolID(HEALTHY_CHAR), GC.getTechInfo(eTech).getTextKeyWide()));
			}
			else
			{
				szHelpString.append(gDLL->getText("TXT_KEY_SPECIALISTHELP_TECH_HEALTH_TYPE", iSpecialistHealth, gDLL->getSymbolID(HEALTHY_CHAR), GC.getTechInfo(eTech).getTextKeyWide()));
			}
		}
		else if (iSpecialistHealth < 0)
		{
			szHelpString.append(NEWLINE);
			if (GC.getGame().getActivePlayer() != NO_PLAYER && pCity && GET_TEAM(pCity->getTeam()).isHasTech(eTech))
			{
				szHelpString.append(gDLL->getText("TXT_KEY_SPECIALISTHELP_TECH_HEALTH_TYPE_KNOWN", -iSpecialistHealth, gDLL->getSymbolID(UNHEALTHY_CHAR), GC.getTechInfo(eTech).getTextKeyWide()));
			}
			else
			{
				szHelpString.append(gDLL->getText("TXT_KEY_SPECIALISTHELP_TECH_HEALTH_TYPE", -iSpecialistHealth, gDLL->getSymbolID(UNHEALTHY_CHAR), GC.getTechInfo(eTech).getTextKeyWide()));
			}
		}
	}

	if (GC.getSpecialistInfo(eSpecialist).getHealthPercent() != 0)
	{
		float fValue = (float)abs(GC.getSpecialistInfo(eSpecialist).getHealthPercent());
		if (fmod(fValue,100) == 0)
		{
			szTempBuffer.Format(L"%.0f", fValue/100);
		}
		else if (fmod(fValue,10) == 0)
		{
			szTempBuffer.Format(L"%.1f", fValue/100);
		}
		else
		{
			szTempBuffer.Format(L"%.2f", fValue/100);
		}
		CvWString szFirstBuffer;
		szFirstBuffer.Format(L"%s%s", NEWLINE, gDLL->getText("TXT_KEY_SPECIALISTHELP_PERCENT", szTempBuffer.GetCString(), (GC.getSpecialistInfo(eSpecialist).getHealthPercent() > 0 ? gDLL->getSymbolID(HEALTHY_CHAR) : gDLL->getSymbolID(UNHEALTHY_CHAR))).c_str());
		szHelpString.append(szFirstBuffer);
	}
	for (int iI = 0; iI < GC.getNumTechInfos(); iI++)
	{
		const TechTypes eTech = static_cast<TechTypes>(iI);
		int iSpecialistHappiness = GC.getSpecialistInfo(eSpecialist).getTechHappiness(eTech);

		if (iSpecialistHappiness > 0)
		{
			szHelpString.append(NEWLINE);
			if (GC.getGame().getActivePlayer() != NO_PLAYER && pCity && GET_TEAM(pCity->getTeam()).isHasTech(eTech))
			{
				szHelpString.append(gDLL->getText("TXT_KEY_SPECIALISTHELP_TECH_HAPPINESS_TYPE_KNOWN", iSpecialistHappiness, gDLL->getSymbolID(HAPPY_CHAR), GC.getTechInfo(eTech).getTextKeyWide()));
			}
			else
			{
				szHelpString.append(gDLL->getText("TXT_KEY_SPECIALISTHELP_TECH_HAPPINESS_TYPE", iSpecialistHappiness, gDLL->getSymbolID(HAPPY_CHAR), GC.getTechInfo(eTech).getTextKeyWide()));
			}
		}
		else if (iSpecialistHappiness < 0)
		{
			szHelpString.append(NEWLINE);
			if (GC.getGame().getActivePlayer() != NO_PLAYER && pCity && GET_TEAM(pCity->getTeam()).isHasTech(eTech))
			{
				szHelpString.append(gDLL->getText("TXT_KEY_SPECIALISTHELP_TECH_HAPPINESS_TYPE_KNOWN", -iSpecialistHappiness, gDLL->getSymbolID(UNHAPPY_CHAR), GC.getTechInfo(eTech).getTextKeyWide()));
			}
			else
			{
				szHelpString.append(gDLL->getText("TXT_KEY_SPECIALISTHELP_TECH_HAPPINESS_TYPE", -iSpecialistHappiness, gDLL->getSymbolID(UNHAPPY_CHAR), GC.getTechInfo(eTech).getTextKeyWide()));
			}
		}
	}
	if (GC.getSpecialistInfo(eSpecialist).getHappinessPercent() != 0)
	{
		float fValue = (float)abs(GC.getSpecialistInfo(eSpecialist).getHappinessPercent());
		if (fmod(fValue,100) == 0)
		{
			szTempBuffer.Format(L"%.0f", fValue/100);
		}
		else if (fmod(fValue,10) == 0)
		{
			szTempBuffer.Format(L"%.1f", fValue/100);
		}
		else
		{
			szTempBuffer.Format(L"%.2f", fValue/100);
		}
		CvWString szFirstBuffer;
		szFirstBuffer.Format(L"%s%s", NEWLINE, gDLL->getText("TXT_KEY_SPECIALISTHELP_PERCENT", szTempBuffer.GetCString(), (GC.getSpecialistInfo(eSpecialist).getHappinessPercent() > 0 ? gDLL->getSymbolID(HAPPY_CHAR) : gDLL->getSymbolID(UNHAPPY_CHAR))).c_str());
		szHelpString.append(szFirstBuffer);
	}

	if (iChange != 0 && pCity && pCity->getOwner() == GC.getGame().getActivePlayer() && getBugOptionBOOL("MiscHover__SpecialistActualEffects", true, "BUG_MISC_SPECIALIST_HOVER_ACTUAL_EFFECTS"))
	{
		bool bStarted = false;
		CvWString szStart = gDLL->getText("TXT_KEY_ACTUAL_EFFECTS");

		// Yield
		int aiYields[NUM_YIELD_TYPES];
		for (int iI = 0; iI < NUM_YIELD_TYPES; ++iI)
		{
			aiYields[iI] = iChange * pCity->getYieldBySpecialist((YieldTypes)iI, eSpecialist);
		}
		bStarted = setResumableYieldChangeHelp(szHelpString, szStart, L": ", L"", aiYields, false, true, bStarted);

		// Commerce
		int aiCommerces[NUM_COMMERCE_TYPES];
		for (int iI = 0; iI < NUM_COMMERCE_TYPES; ++iI)
		{
			aiCommerces[iI] = pCity->getAdditionalCommerceTimes100BySpecialist((CommerceTypes)iI, eSpecialist, iChange);
		}
		bStarted = setResumableCommerceTimes100ChangeHelp(szHelpString, szStart, L": ", L"", aiCommerces, true, bStarted);

		// Great People
		int iGreatPeopleRate = pCity->getAdditionalGreatPeopleRateBySpecialist(eSpecialist, iChange);
		bStarted = setResumableValueChangeHelp(szHelpString, szStart, L": ", L"", iGreatPeopleRate, gDLL->getSymbolID(GREAT_PEOPLE_CHAR), false, true, bStarted);

	}

	GC.getSpecialistInfo(eSpecialist).getPropertyManipulators()->buildDisplayString(szHelpString);

	if (!CvWString(GC.getSpecialistInfo(eSpecialist).getHelp()).empty() && !bCivilopediaText)
	{
		szHelpString.append(NEWLINE);
		szHelpString.append(GC.getSpecialistInfo(eSpecialist).getHelp());
	}
}


void CvGameTextMgr::parseFreeSpecialistHelp(CvWStringBuffer &szHelpString, const CvCity& kCity)
{
	PROFILE_FUNC();

	for (int iLoopSpecialist = 0; iLoopSpecialist < GC.getNumSpecialistInfos(); iLoopSpecialist++)
	{
		const SpecialistTypes eSpecialist = (SpecialistTypes)iLoopSpecialist;
		int iNumSpecialists = kCity.getFreeSpecialistCount(eSpecialist);

		if (iNumSpecialists > 0)
		{

			szHelpString.append(NEWLINE);
			szHelpString.append(CvWString::format(L"%s (%d): ", GC.getSpecialistInfo(eSpecialist).getDescription(), iNumSpecialists));

			CvWStringBuffer szYield;
			{
				int aiYields[NUM_YIELD_TYPES];
				for (int iI = 0; iI < NUM_YIELD_TYPES; ++iI)
				{
					aiYields[iI] = iNumSpecialists * kCity.specialistYield(eSpecialist, (YieldTypes)iI);
				}
				setYieldChangeHelp(szYield, L"", L"", L"", aiYields, false, false);
			}
			szHelpString.append(szYield);

			CvWStringBuffer szCommerceString;
			{
				int aiCommerces[NUM_COMMERCE_TYPES];
				for (int iI = 0; iI < NUM_COMMERCE_TYPES; ++iI)
				{
					aiCommerces[iI] = iNumSpecialists * kCity.specialistCommerce(eSpecialist, (CommerceTypes)iI);
				}
				listCommerceChange(szHelpString, L"", L"", aiCommerces);
			}

			if (!szYield.isEmpty() && !szCommerceString.isEmpty())
			{
				szHelpString.append(L", ");
			}
			szHelpString.append(szCommerceString);

			if (GC.getSpecialistInfo(eSpecialist).getExperience() != 0)
			{
				if (!szYield.isEmpty() || !szCommerceString.isEmpty())
				{
					szHelpString.append(L", ");
				}
				szHelpString.append(gDLL->getText("TXT_KEY_SPECIALISTHELP_EXPERIENCE_SHORT", iNumSpecialists * GC.getSpecialistInfo(eSpecialist).getExperience()));
			}

			for (int iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
			{
				int iUnitCombatExperience = 0;
				const UnitCombatTypes eUnitCombat = ((UnitCombatTypes)iI);
				for (int iJ = 0; iJ < GC.getSpecialistInfo(eSpecialist).getNumUnitCombatExperienceTypes(); iJ++)
				{
					if (GC.getSpecialistInfo(eSpecialist).getUnitCombatExperienceType(iJ).eUnitCombat == eUnitCombat)
					{
						iUnitCombatExperience += GC.getSpecialistInfo(eSpecialist).getUnitCombatExperienceType(iJ).iModifier;
					}
				}
				if (iUnitCombatExperience > 0)
				{
					if (!szYield.isEmpty() || !szCommerceString.isEmpty() || GC.getSpecialistInfo(eSpecialist).getExperience() != 0)
					{
						szHelpString.append(L", ");
					}
					szHelpString.append(gDLL->getText("TXT_KEY_SPECIALISTHELP_UNIT_COMBAT_EXPERIENCE_SHORT", iUnitCombatExperience, GC.getUnitCombatInfo(eUnitCombat).getTextKeyWide()));
				}
			}

			if (GC.getSpecialistInfo(eSpecialist).getGreatPeopleRateChange() != 0)
			{
				szHelpString.append(L", ");
				szHelpString.append(gDLL->getText("TXT_KEY_SPECIALISTHELP_BIRTH_RATE", iNumSpecialists * GC.getSpecialistInfo(eSpecialist).getGreatPeopleRateChange()));
			}

			for (int iI = 0; iI < GC.getNumTechInfos(); iI++)
			{
				const TechTypes eTech = static_cast<TechTypes>(iI);
				int iSpecialistHealth = GC.getSpecialistInfo(eSpecialist).getTechHealth(eTech);

				if (iSpecialistHealth > 0)
				{
					szHelpString.append(L", ");
					if (GC.getGame().getActivePlayer() != NO_PLAYER && GET_PLAYER(kCity.getOwner()).getID() != NO_PLAYER && GET_TEAM(kCity.getTeam()).isHasTech(eTech))
					{
						szHelpString.append(gDLL->getText("TXT_KEY_SPECIALISTHELP_TECH_HEALTH_TYPE_KNOWN", iNumSpecialists * iSpecialistHealth, gDLL->getSymbolID(HEALTHY_CHAR), GC.getTechInfo(eTech).getTextKeyWide()));
					}
					else
					{
						szHelpString.append(gDLL->getText("TXT_KEY_SPECIALISTHELP_TECH_HEALTH_TYPE", iNumSpecialists * iSpecialistHealth, gDLL->getSymbolID(HEALTHY_CHAR), GC.getTechInfo(eTech).getTextKeyWide()));
					}
				}
				else if (iSpecialistHealth < 0)
				{
					szHelpString.append(L", ");
					if (GC.getGame().getActivePlayer() != NO_PLAYER && GET_PLAYER(kCity.getOwner()).getID() != NO_PLAYER && GET_TEAM(kCity.getTeam()).isHasTech(eTech))
					{
						szHelpString.append(gDLL->getText("TXT_KEY_SPECIALISTHELP_TECH_HEALTH_TYPE_KNOWN", iNumSpecialists * -iSpecialistHealth, gDLL->getSymbolID(UNHEALTHY_CHAR), GC.getTechInfo(eTech).getTextKeyWide()));
					}
					else
					{
						szHelpString.append(gDLL->getText("TXT_KEY_SPECIALISTHELP_TECH_HEALTH_TYPE", iNumSpecialists * -iSpecialistHealth, gDLL->getSymbolID(UNHEALTHY_CHAR), GC.getTechInfo(eTech).getTextKeyWide()));
					}
				}
			}
			CvWString szTempBuffer;
			CvWString szFirstBuffer;
			if (GC.getSpecialistInfo(eSpecialist).getHealthPercent() != 0)
			{
				float fValue = (float)abs(iNumSpecialists * GC.getSpecialistInfo(eSpecialist).getHealthPercent());
				if (fmod(fValue,100) == 0)
				{
					szTempBuffer.Format(L"%.0f", fValue/100);
				}
				else if (fmod(fValue,10) == 0)
				{
					szTempBuffer.Format(L"%.1f", fValue/100);
				}
				else
				{
					szTempBuffer.Format(L"%.2f", fValue/100);
				}
				szFirstBuffer.Format(L"%s%s, ", gDLL->getText("TXT_KEY_SPECIALISTHELP_PERCENT", szTempBuffer.GetCString(), (GC.getSpecialistInfo(eSpecialist).getHealthPercent() > 0 ? gDLL->getSymbolID(HEALTHY_CHAR) : gDLL->getSymbolID(UNHEALTHY_CHAR))).c_str());
				szHelpString.append(szFirstBuffer);
			}

			for (int iI = 0; iI < GC.getNumTechInfos(); iI++)
			{
				const TechTypes eTech = static_cast<TechTypes>(iI);
				int iSpecialistHappiness = GC.getSpecialistInfo(eSpecialist).getTechHappiness(eTech);

				if (iSpecialistHappiness > 0)
				{
					szHelpString.append(L", ");
					if (GC.getGame().getActivePlayer() != NO_PLAYER && GET_PLAYER(kCity.getOwner()).getID() != NO_PLAYER && GET_TEAM(kCity.getTeam()).isHasTech(eTech))
					{
						szHelpString.append(gDLL->getText("TXT_KEY_SPECIALISTHELP_TECH_HAPPINESS_TYPE_KNOWN", iNumSpecialists * iSpecialistHappiness, gDLL->getSymbolID(HAPPY_CHAR), GC.getTechInfo(eTech).getTextKeyWide()));
					}
					else
					{
						szHelpString.append(gDLL->getText("TXT_KEY_SPECIALISTHELP_TECH_HAPPINESS_TYPE", iNumSpecialists * iSpecialistHappiness, gDLL->getSymbolID(HAPPY_CHAR), GC.getTechInfo(eTech).getTextKeyWide()));
					}
				}
				else if (iSpecialistHappiness < 0)
				{
					szHelpString.append(L", ");
					if (GC.getGame().getActivePlayer() != NO_PLAYER && GET_PLAYER(kCity.getOwner()).getID() != NO_PLAYER && GET_TEAM(kCity.getTeam()).isHasTech(eTech))
					{
						szHelpString.append(gDLL->getText("TXT_KEY_SPECIALISTHELP_TECH_HAPPINESS_TYPE_KNOWN", iNumSpecialists * -iSpecialistHappiness, gDLL->getSymbolID(UNHAPPY_CHAR), GC.getTechInfo(eTech).getTextKeyWide()));
					}
					else
					{
						szHelpString.append(gDLL->getText("TXT_KEY_SPECIALISTHELP_TECH_HAPPINESS_TYPE", iNumSpecialists * -iSpecialistHappiness, gDLL->getSymbolID(UNHAPPY_CHAR), GC.getTechInfo(eTech).getTextKeyWide()));
					}
				}
			}
			if (GC.getSpecialistInfo(eSpecialist).getHappinessPercent() != 0)
			{
				float fValue = (float)abs(iNumSpecialists * GC.getSpecialistInfo(eSpecialist).getHappinessPercent());
				if (fmod(fValue,100) == 0)
				{
					szTempBuffer.Format(L"%.0f", fValue/100);
				}
				else if (fmod(fValue,10) == 0)
				{
					szTempBuffer.Format(L"%.1f", fValue/100);
				}
				else
				{
					szTempBuffer.Format(L"%.2f", fValue/100);
				}
				szFirstBuffer.Format(L"%s%s, ", gDLL->getText("TXT_KEY_SPECIALISTHELP_PERCENT", szTempBuffer.GetCString(), (GC.getSpecialistInfo(eSpecialist).getHappinessPercent() > 0 ? gDLL->getSymbolID(HAPPY_CHAR) : gDLL->getSymbolID(UNHAPPY_CHAR))).c_str());
				szHelpString.append(szFirstBuffer);
			}
		}
	}
}


//
// Promotion Help
//
void CvGameTextMgr::parsePromotionHelp(CvWStringBuffer &szBuffer, PromotionTypes ePromotion, const wchar_t* pcNewline)
{
	parsePromotionHelpInternal(szBuffer, ePromotion, pcNewline, true);
}

void CvGameTextMgr::parsePromotionHelpInternal(CvWStringBuffer &szBuffer, PromotionTypes ePromotion, const wchar_t* pcNewline, bool bAccrueLines)
{
	PROFILE_FUNC();

	if (NO_PROMOTION == ePromotion)
	{
		return;
	}
	const bool bHideSeek = GC.getGame().isOption(GAMEOPTION_COMBAT_HIDE_SEEK);

	const CvPromotionInfo& promo = GC.getPromotionInfo(ePromotion);
	const int iLinePriority = promo.getLinePriority();
	const PromotionLineTypes ePromoLine = promo.getPromotionLine();
	const CvPromotionLineInfo* promoLine = ePromoLine != NO_PROMOTIONLINE ? &GC.getPromotionLineInfo(ePromoLine) : NULL;

	// If this is not the display for the hover help on the actual promotion action button
	// then we want to accrue stats from all implied promotions earlier in the same line into the help text
	std::vector<PromotionTypes>	linePromotionsOwned;
	linePromotionsOwned.push_back(ePromotion);

	bool bIsNoSpreadonBattle = false;
	bool bIsNoSpreadUnitProximity = false;
	bool bIsNoSpreadUnittoCity = false;
	bool bIsNoSpreadCitytoUnit = false;

	if (ePromoLine != NO_PROMOTIONLINE)
	{
		if (bAccrueLines)
		{
			//	Afflication, equipment and status promos don't accrue values from lower elements of the same line
			if (!promo.isEquipment()
#ifdef OUTBREAKS_AND_AFFLICTIONS
			&&  !promo.isAffliction()
#endif
			&&  !promo.isStatus())
			{
				for (int iI = GC.getNumPromotionInfos() - 1; iI > -1; iI--)
				{
					if (GC.getPromotionInfo((PromotionTypes)iI).getPromotionLine() == ePromoLine
					&&  GC.getPromotionInfo((PromotionTypes)iI).getLinePriority() < iLinePriority)
					{
						linePromotionsOwned.push_back((PromotionTypes)iI);
					}
				}
			}
		}
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_LINE", promoLine->getDescription()));

		if (iLinePriority > 0)
		{
			szBuffer.append(pcNewline);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_LINE_PRIORITY", iLinePriority));
		}

		if (promoLine->isNoSpreadonBattle())
		{
			bIsNoSpreadonBattle = true;
		}
		if (promoLine->isNoSpreadUnitProximity())
		{
			bIsNoSpreadUnitProximity = true;
		}
		if (promoLine->isNoSpreadUnittoCity())
		{
			bIsNoSpreadUnittoCity = true;
		}
		if (promoLine->isNoSpreadCitytoUnit())
		{
			bIsNoSpreadCitytoUnit = true;
		}
	}

	bool bIsBlitz = false;
	bool bIsAmphib = false;
	bool bIsRiver = false;
	bool bIsEnemyRoute = false;
	bool bIsStatus = false;
	bool bIsPrereqNormInvisible = false;
	bool bIsNoSelfHeal = false;
	bool bIsAlwaysHeal = false;
	bool bIsHillsDoubleMove = false;
	bool bIsCanMovePeaks = false;
	bool bIsCanLeadThroughPeaks = false;
	bool bIsAttackOnlyCitiesAdd = false;
	bool bIsAttackOnlyCitiesSubtract = false;
	bool bIsIgnoreNoEntryLevelAdd = false;
	bool bIsIgnoreNoEntryLevelSubtract = false;
	bool bIsIgnoreZoneofControlAdd = false;
	bool bIsIgnoreZoneofControlSubtract = false;
	bool bIsFliesToMoveAdd = false;
	bool bIsFliesToMoveSubtract = false;
	bool bIsZoneOfControl = false;
	bool bIsImmuneToFirstStrikes = false;
	bool bIsStampedeChange = false;
	bool bIsRemoveStampede = false;
	bool bIsOnslaughtChange = false;
	bool bIsParalyze = false;
	bool bIsMakesDamageCold = false;
	bool bIsMakesDamageNotCold = false;
	bool bIsAddsColdImmunity = false;
	bool bIsRemovesColdImmunity = false;
	bool bIsCritical = false;
	bool bIsDefensiveVictoryMove = false;
	bool bIsFreeDrop = false;
	bool bIsOffensiveVictoryMove = false;
	bool bIsOneUp = false;
	bool bIsPillageEspionage = false;
	bool bIsPillageMarauder = false;
	bool bIsPillageOnMove = false;
	bool bIsPillageOnVictory = false;
	bool bIsPillageResearch = false;

	for (int iI = linePromotionsOwned.size() - 1; iI > -1; iI--)
	{
		const CvPromotionInfo& promoX = GC.getPromotionInfo(linePromotionsOwned[iI]);

		if (promoX.isBlitz())
		{
			bIsBlitz = true;
		}
		if (promoX.isAmphib())
		{
			bIsAmphib = true;
		}
		if (promoX.isRiver())
		{
			bIsRiver = true;
		}
		if (promoX.isEnemyRoute())
		{
			bIsEnemyRoute = true;
		}
		if (promoX.isStatus())
		{
			bIsStatus = true;
		}
		if (promoX.isPrereqNormInvisible())
		{
			bIsPrereqNormInvisible = true;
		}
		if (promoX.isNoSelfHeal())
		{
			bIsNoSelfHeal = true;
		}
		if (promoX.isAlwaysHeal())
		{
			bIsAlwaysHeal = true;
		}
		if (promoX.isHillsDoubleMove())
		{
			bIsHillsDoubleMove = true;
		}
		if (promoX.isCanMovePeaks())
		{
			bIsCanMovePeaks = true;
		}
		if (promoX.isCanLeadThroughPeaks())
		{
			bIsCanLeadThroughPeaks = true;
		}
		if (promoX.isAttackOnlyCitiesAdd())
		{
			bIsAttackOnlyCitiesAdd = true;
		}
		if (promoX.isAttackOnlyCitiesSubtract())
		{
			bIsAttackOnlyCitiesSubtract = true;
		}
		if (promoX.isIgnoreNoEntryLevelAdd())
		{
			bIsIgnoreNoEntryLevelAdd = true;
		}
		if (promoX.isIgnoreNoEntryLevelSubtract())
		{
			bIsIgnoreNoEntryLevelSubtract = true;
		}
		if (GC.getGame().isOption(GAMEOPTION_UNSUPPORTED_ZONE_OF_CONTROL))
		{
			if (promoX.isIgnoreZoneofControlAdd())
			{
				bIsIgnoreZoneofControlAdd = true;
			}
			if (promoX.isIgnoreZoneofControlSubtract())
			{
				bIsIgnoreZoneofControlSubtract = true;
			}
			if (promoX.isZoneOfControl())
			{
				bIsZoneOfControl = true;
			}
		}
		if (promoX.isFliesToMoveAdd())
		{
			bIsFliesToMoveAdd = true;
		}
		if (promoX.isFliesToMoveSubtract())
		{
			bIsFliesToMoveSubtract = true;
		}
		if (promoX.isImmuneToFirstStrikes())
		{
			bIsImmuneToFirstStrikes = true;
		}
		if (promoX.isStampedeChange())
		{
			bIsStampedeChange = true;
		}
		if (promoX.isRemoveStampede())
		{
			bIsRemoveStampede = true;
		}
		if (promoX.isOnslaughtChange())
		{
			bIsOnslaughtChange = true;
		}
		if (promoX.isParalyze())
		{
			bIsParalyze = true;
		}
		if (promoX.isMakesDamageCold())
		{
			bIsMakesDamageCold = true;
		}
		if (promoX.isMakesDamageNotCold())
		{
			bIsMakesDamageNotCold = true;
		}
		if (promoX.isAddsColdImmunity())
		{
			bIsAddsColdImmunity = true;
		}
		if (promoX.isRemovesColdImmunity())
		{
			bIsRemovesColdImmunity = true;
		}
		if (promoX.isCritical())
		{
			bIsCritical = true;
		}
		if (promoX.isDefensiveVictoryMove())
		{
			bIsDefensiveVictoryMove = true;
		}
		if (promoX.isFreeDrop())
		{
			bIsFreeDrop = true;
		}
		if (promoX.isOffensiveVictoryMove())
		{
			bIsOffensiveVictoryMove = true;
		}
		if (promoX.isOneUp())
		{
			bIsOneUp = true;
		}
		if (promoX.isPillageEspionage())
		{
			bIsPillageEspionage = true;
		}
		if (promoX.isPillageMarauder())
		{
			bIsPillageMarauder = true;
		}
		if (promoX.isPillageOnMove())
		{
			bIsPillageOnMove = true;
		}
		if (promoX.isPillageOnVictory())
		{
			bIsPillageOnVictory = true;
		}
		if (promoX.isPillageResearch())
		{
			bIsPillageResearch = true;
		}
	}


	if (bIsBlitz)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_BLITZ"));
	}
	if (bIsAmphib)
	{
		if (promo.getSound()[5] == 'P')
		{
			szBuffer.append(pcNewline);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_RADIATION_SPY"));
		}
		else
		{
			szBuffer.append(pcNewline);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_AMPHIB"));
		}
	}

	if (bIsRiver)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_RIVER_ATTACK"));
	}
	if (bIsEnemyRoute)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_ENEMY_ROADS"));
	}
	if (bIsStatus)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_STATUS"));
	}
	if (bIsNoSelfHeal)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_SELF_HEAL_NONE"));
	}
	if (bIsAlwaysHeal)
	{
		if (promo.getSound()[5] == 'P')
		{
			szBuffer.append(pcNewline);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_LOYALTY_SPY"));
		}
		else
		{
			szBuffer.append(pcNewline);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_ALWAYS_HEAL"));
		}
	}
	if (bIsHillsDoubleMove)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_HILLS_MOVE"));
	}
	if (bIsCanMovePeaks)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_CAN_MOVE_PEAKS"));
	}
	if (bIsCanLeadThroughPeaks)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_CAN_LEAD_THROUGH_PEAKS"));
	}
	if (bIsAttackOnlyCitiesAdd)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_ATTACK_ONLY_CITIES_ADD"));
	}
	if (bIsAttackOnlyCitiesSubtract)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_ATTACK_ONLY_CITIES_SUBTRACT"));
	}
	if (bIsIgnoreNoEntryLevelAdd)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_IGNORE_NO_ENTRY_LEVEL_ADD"));
	}
	if (bIsIgnoreNoEntryLevelSubtract)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_IGNORE_NO_ENTRY_LEVEL_SUBTRACT"));
	}
	if (bIsIgnoreZoneofControlAdd)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_IGNORE_ZONE_OF_CONTROL_ADD"));
	}
	if (bIsIgnoreZoneofControlSubtract)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_IGNORE_ZONE_OF_CONTROL_SUBTRACT"));
	}
	if (bIsZoneOfControl)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_ZONE_OF_CONTROL"));
	}
	if (bIsFliesToMoveAdd)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_FLIES_TO_MOVE_ADD"));
	}
	if (bIsFliesToMoveSubtract)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_FLIES_TO_MOVE_SUBTRACT"));
	}
	if (bIsStampedeChange)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_STAMPEDE"));
	}
	if (bIsRemoveStampede)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_REMOVE_STAMPEDE"));
	}
	if (bIsOnslaughtChange)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_ONSLAUGHT"));
	}
	if (bIsParalyze)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_PARALYZE"));
	}
	if (bIsNoSpreadonBattle)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_NO_SPREAD_ON_BATTLE"));
	}
	if (bIsNoSpreadUnitProximity)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_NO_SPREAD_UNIT_PROXIMITY"));
	}
	if (bIsNoSpreadUnittoCity)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_NO_SPREAD_UNIT_TO_CITY"));
	}
	if (bIsNoSpreadCitytoUnit)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_NO_SPREAD_CITY_TO_UNIT"));
	}
	if (bIsMakesDamageCold)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_MAKES_DAMAGE_COLD"));
	}
	if (bIsMakesDamageNotCold)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_MAKES_DAMAGE_NOT_COLD"));
	}
	if (bIsAddsColdImmunity)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_ADDS_COLD_IMMUNITY"));
	}
	if (bIsRemovesColdImmunity)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_REMOVES_COLD_IMMUNITY"));
	}
	if (bIsCritical)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_CRITICAL"));
	}
	if (bIsDefensiveVictoryMove)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_DV_MOVE"));
	}
	if (bIsFreeDrop)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_FREE_DROP"));
	}
	if (bIsOffensiveVictoryMove)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_OV_MOVE"));
	}
	if (bIsOneUp)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_ONEUP"));
	}
	if (bIsPillageEspionage)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_ESPIONAGE_PILLAGE"));
	}
	if (bIsPillageMarauder)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_MARAUDER_PILLAGE"));
	}
	if (bIsPillageOnMove)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_MOVING_PILLAGE"));
	}
	if (bIsPillageOnVictory)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_VICTORY_PILLAGE"));
	}
	if (bIsPillageResearch)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_RESEARCH_PILLAGE"));
	}
	if (bIsPrereqNormInvisible)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_PREREQ_NORM_INVISIBLE"));
	}


	if (promo.isEquipment())
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_EQUIPMENT"));
	}

#ifdef OUTBREAKS_AND_AFFLICTIONS
	if (promo.isAffliction())
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_AFFLICTION"));
	}
#endif

	int	iGetControlPoints = 0;
	int	iGetCommandRange = 0;
	int	iExcileChange = 0;
	int	iPassageChange = 0;
	int	iNoNonOwnedCityEntryChange = 0;
	int	iBarbCoExistChange = 0;
	int	iBlendIntoCityChange = 0;
	int	iUpgradeAnywhereChange = 0;
	int	iMovesChange = 0;
	int	iMoveDiscountChange = 0;
	int	iAirRangeChange = 0;
	int	iInterceptChange = 0;
	int	iEvasionChange = 0;
	int	iWithdrawalChange = 0;
	int	iAttackCombatModifierChange = 0;
	int	iDefenseCombatModifierChange = 0;
	int	iCombatModifierPerSizeMore = 0;
	int	iCombatModifierPerSizeLess = 0;
	int	iCombatModifierPerVolumeMore = 0;
	int	iCombatModifierPerVolumeLess = 0;
	int	iPursuitChange = 0;
	int	iEarlyWithdrawChange = 0;
	int	iVSBarbsChange = 0;
	int	iReligiousCombatModifierChange = 0;
	int	iArmorChange = 0;
	int	iPunctureChange = 0;
	int	iDamageModifierChange = 0;
	int iUpkeepModifier = 0;
	int iExtraUpkeep100 = 0;
	int	iOverrunChange = 0;
	int	iRepelChange = 0;
	int	iFortRepelChange = 0;
	int	iRepelRetriesChange = 0;
	int	iUnyieldingChange = 0;
	int	iKnockbackChange = 0;
	int	iKnockbackRetriesChange = 0;
	int	iRoundStunProbChange = 0;
	int	iPoisonProbabilityModifierChange = 0;
	int	iStrAdjperRndChange = 0;
	int	iStrAdjperAttChange = 0;
	int	iStrAdjperDefChange = 0;
	int	iWithdrawAdjperAttChange = 0;
	int	iUnnerveChange = 0;
	int	iEncloseChange = 0;
	int	iLungeChange = 0;
	int	iDynamicDefenseChange = 0;
	int	iStrengthChange = 0;
	int	iOvercomeProbability = 0;
	int	iOvercomeAdjperTurn = 0;
	int	iFortitudeChange = 0;
	int	iDamageperTurn = 0;
	int	iStrAdjperTurn = 0;
	int	iWeakenperTurn = 0;
	int	iCommunicability = 0;
	int iWorseningProbability = 0;
	int	iToleranceBuildup = 0;
	int	iToleranceDecay = 0;
#ifdef STRENGTH_IN_NUMBERS
	int	iFrontSupportPercentChange = 0;
	int	iShortRangeSupportPercentChange = 0;
	int	iMediumRangeSupportPercentChange = 0;
	int	iLongRangeSupportPercentChange = 0;
	int	iFlankSupportPercentChange = 0;
#endif
	int	iDodgeModifierChange = 0;
	int	iPrecisionModifierChange = 0;
	int	iPowerShotsChange = 0;
	int	iPowerShotCombatModifierChange = 0;
	int	iPowerShotPunctureModifierChange = 0;
	int	iPowerShotPrecisionModifierChange = 0;
	int	iPowerShotCriticalModifierChange = 0;
	int	iCriticalModifierChange = 0;
	int	iEnduranceChange = 0;
	int	iInsidiousnessChange = 0;
	int	iInvestigationChange = 0;
	int	iAssassinChange = 0;
	int	iStealthStrikesChange = 0;
	int	iStealthCombatModifierChange = 0;
	int	iStealthDefenseChange = 0;
	int	iDefenseOnlyChange = 0;
	int	iNoInvisibilityChange = 0;
	int	iTrapDamageMin = 0;
	int	iTrapDamageMax = 0;
	int	iTrapComplexity = 0;
	int	iTrapNumTriggers = 0;
	int	iTrapTriggerBeforeAttackChange = 0;
	int	iVisibilityChange = 0;
	int	iCaptureProbabilityModifierChange = 0;
	int	iCaptureResistanceModifierChange = 0;
	int	iBreakdownChanceChange = 0;
	int	iBreakdownDamageChange = 0;
	int	iTauntChange = 0;
	int	iMaxHPChange = 0;
	int	iStrengthModifier = 0;
	int	iAirCombatLimitChange = 0;
	int	iCelebrityHappy = 0;
	int	iCollateralDamageLimitChange = 0;
	int	iCollateralDamageMaxUnitsChange = 0;
	int	iCombatLimitChange = 0;
	int	iExtraDropRange = 0;
	int	iSurvivorChance = 0;
	int	iSelfHealModifier = 0;
	int	iHealSupport = 0;
	int	iVictoryAdjacentHeal = 0;
	int	iVictoryHeal = 0;
	int	iVictoryStackHeal = 0;
	int	iCargoChange = 0;
	int	iCollateralDamageChange = 0;
	int	iBombardRateChange = 0;
	int	iDCMBombRangeChange = 0;
	int	iDCMBombAccuracyChange = 0;
	int	iRBombardDamageChange = 0;
	int	iRBombardDamageLimitChange = 0;
	int	iRBombardDamageMaxUnitsChange = 0;
	int	iFirstStrikesChange = 0;
	int	iChanceFirstStrikesChange = 0;
	int	iEnemyHealChange = 0;
	int	iNeutralHealChange = 0;
	int	iFriendlyHealChange = 0;
	int	iSameTileHealChange = 0;
	int	iAdjacentTileHealChange = 0;
	int	iCombatPercent = 0;
	int	iCityAttackPercent = 0;
	int	iCityDefensePercent = 0;
	int	iHillsAttackPercent = 0;
	int	iHillsDefensePercent = 0;
	int iWorkRate = 0;
	int iHillsWorkPercent = 0;
	int iPeaksWorkPercent = 0;
	int	iRevoltProtection = 0;
	int	iCollateralDamageProtection = 0;
	int	iPillageChange = 0;
	int	iUpgradeDiscount = 0;
	int	iExperiencePercent = 0;
	int	iKamikazePercent = 0;
	int iHiddenNationality = 0;
	int	iIsAnimalIgnoresBordersChange = 0;
	int iNoDefensiveBonusChange = 0;

	for (int iI = 0; iI < (int)linePromotionsOwned.size(); iI++)
	{
		const CvPromotionInfo& promoX = GC.getPromotionInfo(linePromotionsOwned[iI]);

		iGetControlPoints += promoX.getControlPoints();
		iGetCommandRange += promoX.getCommandRange();
		iExcileChange += promoX.getExcileChange();
		iPassageChange += promoX.getPassageChange();
		iNoNonOwnedCityEntryChange += promoX.getNoNonOwnedCityEntryChange();
		iBarbCoExistChange += promoX.getBarbCoExistChange();
		iBlendIntoCityChange += promoX.getBlendIntoCityChange();
		iUpgradeAnywhereChange += promoX.getUpgradeAnywhereChange();
		iMovesChange += promoX.getMovesChange();
		iMoveDiscountChange += promoX.getMoveDiscountChange();
		iAirRangeChange += promoX.getAirRangeChange();
		iInterceptChange += promoX.getInterceptChange();
		iEvasionChange += promoX.getEvasionChange();
		iWithdrawalChange += promoX.getWithdrawalChange();
		iAttackCombatModifierChange += promoX.getAttackCombatModifierChange();
		iDefenseCombatModifierChange += promoX.getDefenseCombatModifierChange();
		iCombatModifierPerSizeMore += promoX.getCombatModifierPerSizeMoreChange();
		iCombatModifierPerSizeLess += promoX.getCombatModifierPerSizeLessChange();
		iCombatModifierPerVolumeMore += promoX.getCombatModifierPerVolumeMoreChange();
		iCombatModifierPerVolumeLess += promoX.getCombatModifierPerVolumeLessChange();
		iPursuitChange += promoX.getPursuitChange();
		iEarlyWithdrawChange += promoX.getEarlyWithdrawChange();
		iVSBarbsChange += promoX.getVSBarbsChange();
		iReligiousCombatModifierChange += promoX.getReligiousCombatModifierChange();
		iArmorChange += promoX.getArmorChange();
		iPunctureChange += promoX.getPunctureChange();
		iDamageModifierChange += promoX.getDamageModifierChange();
		iUpkeepModifier += promoX.getUpkeepModifier();
		iExtraUpkeep100 += promoX.getExtraUpkeep100();
		iOverrunChange += promoX.getOverrunChange();
		iRepelChange += promoX.getRepelChange();
		iFortRepelChange += promoX.getFortRepelChange();
		iRepelRetriesChange += promoX.getRepelRetriesChange();
		iUnyieldingChange += promoX.getUnyieldingChange();
		iKnockbackChange += promoX.getKnockbackChange();
		iKnockbackRetriesChange += promoX.getKnockbackRetriesChange();
		iRoundStunProbChange += promoX.getRoundStunProbChange();
		iPoisonProbabilityModifierChange += promoX.getPoisonProbabilityModifierChange();
#ifdef BATTLEWORN
		iStrAdjperRndChange += promoX.getStrAdjperRndChange();
		iStrAdjperAttChange += promoX.getStrAdjperAttChange();
		iStrAdjperDefChange += promoX.getStrAdjperDefChange();
		iWithdrawAdjperAttChange += promoX.getWithdrawAdjperAttChange();
#endif
		if (GC.getGame().isOption(GAMEOPTION_COMBAT_SURROUND_DESTROY))
		{
			iUnnerveChange += promoX.getUnnerveChange();
			iEncloseChange += promoX.getEncloseChange();
			iLungeChange += promoX.getLungeChange();
			iDynamicDefenseChange += promoX.getDynamicDefenseChange();
		}
		iStrengthChange += promoX.getStrengthChange();
		iFortitudeChange += promoX.getFortitudeChange();
		iDamageperTurn += promoX.getDamageperTurn();
		iStrAdjperTurn += promoX.getStrAdjperTurn();
		iWeakenperTurn += promoX.getWeakenperTurn();
#ifdef STRENGTH_IN_NUMBERS
		if (GC.getGame().isOption(GAMEOPTION_COMBAT_STRENGTH_IN_NUMBERS))
		{
			iFrontSupportPercentChange += promoX.getFrontSupportPercentChange();
			iShortRangeSupportPercentChange += promoX.getShortRangeSupportPercentChange();
			iMediumRangeSupportPercentChange += promoX.getMediumRangeSupportPercentChange();
			iLongRangeSupportPercentChange += promoX.getLongRangeSupportPercentChange();
			iFlankSupportPercentChange += promoX.getFlankSupportPercentChange();
		}
#endif
		iDodgeModifierChange += promoX.getDodgeModifierChange();
		iPrecisionModifierChange += promoX.getPrecisionModifierChange();
		iPowerShotsChange += promoX.getPowerShotsChange();
		iPowerShotCombatModifierChange += promoX.getPowerShotCombatModifierChange();
		iPowerShotPunctureModifierChange += promoX.getPowerShotPunctureModifierChange();
		iPowerShotPrecisionModifierChange += promoX.getPowerShotPrecisionModifierChange();
		iPowerShotCriticalModifierChange += promoX.getPowerShotCriticalModifierChange();
		iCriticalModifierChange += promoX.getCriticalModifierChange();
		iEnduranceChange += promoX.getEnduranceChange();
		iInsidiousnessChange += promoX.getInsidiousnessChange();
		iInvestigationChange += promoX.getInvestigationChange();
		iAssassinChange += promoX.getAssassinChange();
		iStealthStrikesChange += promoX.getStealthStrikesChange();
		iStealthCombatModifierChange += promoX.getStealthCombatModifierChange();
		iStealthDefenseChange += promoX.getStealthDefenseChange();
		iDefenseOnlyChange += promoX.getDefenseOnlyChange();
		if (bHideSeek)
		{
			iNoInvisibilityChange += promoX.getNoInvisibilityChange();
		}
		iTrapDamageMin += promoX.getTrapDamageMin();
		iTrapDamageMax += promoX.getTrapDamageMax();
		iTrapComplexity += promoX.getTrapComplexity();
		iTrapNumTriggers += promoX.getNumTriggers();
		iTrapTriggerBeforeAttackChange += promoX.getTriggerBeforeAttackChange();
		iVisibilityChange += promoX.getVisibilityChange();
		iCaptureProbabilityModifierChange += promoX.getCaptureProbabilityModifierChange();
		iCaptureResistanceModifierChange += promoX.getCaptureResistanceModifierChange();
		iBreakdownChanceChange += promoX.getBreakdownChanceChange();
		iBreakdownDamageChange += promoX.getBreakdownDamageChange();
		iTauntChange += promoX.getTauntChange();
		iMaxHPChange += promoX.getMaxHPChange();
		iStrengthModifier += promoX.getStrengthModifier();
		iAirCombatLimitChange += promoX.getAirCombatLimitChange();
		iCelebrityHappy += promoX.getCelebrityHappy();
		iCollateralDamageLimitChange += promoX.getCollateralDamageLimitChange();
		iCollateralDamageMaxUnitsChange += promoX.getCollateralDamageMaxUnitsChange();
		iCombatLimitChange += promoX.getCombatLimitChange();
		iExtraDropRange += promoX.getExtraDropRange();
		iSurvivorChance += promoX.getSurvivorChance();
		iSelfHealModifier += promoX.getSelfHealModifier();
		iHealSupport += promoX.getNumHealSupport();
		iVictoryAdjacentHeal += promoX.getVictoryAdjacentHeal();
		iVictoryHeal += promoX.getVictoryHeal();
		iVictoryStackHeal += promoX.getVictoryStackHeal();
		iCargoChange += promoX.getCargoChange();
		iCollateralDamageChange += promoX.getCollateralDamageChange();
		iBombardRateChange += promoX.getBombardRateChange();
		if(GC.isDCM_RANGE_BOMBARD())
		{
			iDCMBombRangeChange += promoX.getDCMBombRangeChange();
			iDCMBombAccuracyChange += promoX.getDCMBombAccuracyChange();
			iRBombardDamageChange += promoX.getRBombardDamageChange();
			iRBombardDamageLimitChange += promoX.getRBombardDamageLimitChange();
			iRBombardDamageMaxUnitsChange += promoX.getRBombardDamageMaxUnitsChange();
		}
		iFirstStrikesChange += promoX.getFirstStrikesChange();
		iChanceFirstStrikesChange += promoX.getChanceFirstStrikesChange();
		iEnemyHealChange += promoX.getEnemyHealChange();
		iNeutralHealChange += promoX.getNeutralHealChange();
		iFriendlyHealChange += promoX.getFriendlyHealChange();
		iSameTileHealChange += promoX.getSameTileHealChange();
		iAdjacentTileHealChange += promoX.getAdjacentTileHealChange();
		iCombatPercent += promoX.getCombatPercent();
		iCityAttackPercent += promoX.getCityAttackPercent();
		iCityDefensePercent += promoX.getCityDefensePercent();
		iHillsAttackPercent += promoX.getHillsAttackPercent();
		iHillsDefensePercent += promoX.getHillsDefensePercent();
		iWorkRate += promoX.getWorkRatePercent();
		iHillsWorkPercent += promoX.getHillsWorkPercent();
		iPeaksWorkPercent += promoX.getPeaksWorkPercent();
		iRevoltProtection += promoX.getRevoltProtection();
		iCollateralDamageProtection += promoX.getCollateralDamageProtection();
		iPillageChange += promoX.getPillageChange();
		iUpgradeDiscount += promoX.getUpgradeDiscount();
		iExperiencePercent += promoX.getExperiencePercent();
		iKamikazePercent += promoX.getKamikazePercent();
#ifdef OUTBREAKS_AND_AFFLICTIONS
		if (ePromoLine != NO_PROMOTIONLINE && GC.getGame().isOption(GAMEOPTION_COMBAT_OUTBREAKS_AND_AFFLICTIONS))
		{
			iOvercomeProbability += promoLine->getOvercomeProbability();
			iOvercomeProbability += promoLine->getWorsenedOvercomeIncrementModifier() * (promoX.getLinePriority() - 1);
			iOvercomeAdjperTurn += promoLine->getOvercomeAdjperTurn();
			iCommunicability += promoLine->getCommunicability();
			iCommunicability += promoLine->getWorsenedCommunicabilityIncrementModifier() * (promoX.getLinePriority() -1);
			iWorseningProbability += promoLine->getWorseningProbabilityIncrementModifier() * (promoX.getLinePriority() -1);
			iToleranceBuildup += promoLine->getToleranceBuildup();
			iToleranceDecay += promoLine->getToleranceDecay();
		}
#endif // OUTBREAKS_AND_AFFLICTIONS
		iHiddenNationality += promoX.getHiddenNationalityChange();
		iIsAnimalIgnoresBordersChange += promoX.getAnimalIgnoresBordersChange();
		iNoDefensiveBonusChange += promoX.getNoDefensiveBonusChange();
	}
	bool bDefWarning = (
		iDefenseCombatModifierChange > 0
		|| iRepelChange > 0
		|| iFortRepelChange > 0
		|| iRepelRetriesChange > 0
		|| iStrAdjperDefChange > 0
		|| iHillsDefensePercent > 0
		|| iCityDefensePercent != 0
	);

	CvWString szText, szText2;
	CvWString szTempBuffer;

	if (iGetControlPoints > 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_CONTROL_POINTS", iGetControlPoints));
	}
	if (iGetCommandRange > 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_COMMAND_RANGE", iGetCommandRange));
	}
	if (iExcileChange > 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_EXCILE_ADD"));
	}
	if (iExcileChange < 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_EXCILE_REMOVE"));
	}
	if (iPassageChange > 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_PASSAGE_ADD"));
	}
	if (iPassageChange < 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_PASSAGE_REMOVE"));
	}
	if (iNoNonOwnedCityEntryChange > 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_NONONOWNED_ADD"));
	}
	if (iNoNonOwnedCityEntryChange < 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_NONONOWNED_REMOVE"));
	}
	if (iBarbCoExistChange > 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_BARBCOEXIST_ADD"));
	}
	if (iBarbCoExistChange < 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_BARBCOEXIST_REMOVE"));
	}
	if (iBlendIntoCityChange > 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_BLENDCITY_ADD"));
	}
	if (iBlendIntoCityChange < 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_BLENDCITY_REMOVE"));
	}
	if (iUpgradeAnywhereChange > 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_UPGRADEANYWHERE_ADD"));
	}
	if (iUpgradeAnywhereChange < 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_UPGRADEANYWHERE_REMOVE"));
	}
	if (iMovesChange != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_MOVE", iMovesChange));
	}
	if (iMoveDiscountChange != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_MOVE_DISCOUNT", -iMoveDiscountChange));
	}
	if (iAirRangeChange != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_AIR_RANGE", iAirRangeChange));
	}
	if (iInterceptChange != 0)
	{
		if (promo.getSound()[5] == 'P')
		{
			szBuffer.append(pcNewline);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_INTERCEPT_SPY", iInterceptChange));
			szBuffer.append(pcNewline);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_INTERCEPT_SPY_COUNTER", iInterceptChange * 5));
		}
		else
		{
			szBuffer.append(pcNewline);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_INTERCEPT", iInterceptChange));
		}
	}
	if (iEvasionChange != 0)
	{
		if (promo.getSound()[5] == 'P')
		{
			szBuffer.append(pcNewline);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_EVASION_SPY", iEvasionChange));
		}
		else
		{
			szBuffer.append(pcNewline);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_EVASION", iEvasionChange));
		}
	}
	if (iWithdrawalChange != 0)
	{
		if (promo.getSound()[5] == 'P')
		{
			szBuffer.append(pcNewline);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_ESCAPE_SPY", iWithdrawalChange));
		}
		else
		{
			szBuffer.append(pcNewline);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_WITHDRAWAL", iWithdrawalChange));
		}
	}
	if (iAttackCombatModifierChange != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_ATTACK_MODIFIER", iAttackCombatModifierChange));
	}
	if (iDefenseCombatModifierChange != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_DEFENSE_MODIFIER", iDefenseCombatModifierChange));
	}
	if (iCombatModifierPerSizeMore != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_UNIT_COMBAT_MOD_PER_SIZE_MORE", iCombatModifierPerSizeMore));
	}
	if (iCombatModifierPerSizeLess != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_UNIT_COMBAT_MOD_PER_SIZE_LESS", iCombatModifierPerSizeLess));
	}
	if (iCombatModifierPerVolumeMore != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_UNIT_COMBAT_MOD_PER_VOLUME_MORE", iCombatModifierPerVolumeMore));
	}
	if (iCombatModifierPerVolumeLess != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_UNIT_COMBAT_MOD_PER_VOLUME_LESS", iCombatModifierPerVolumeLess));
	}
	if (iPursuitChange != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_PURSUIT", iPursuitChange));
	}
	if (iEarlyWithdrawChange != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_EARLY_WITHDRAW", iEarlyWithdrawChange));
	}
	if (iVSBarbsChange != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_VSBARBS", iVSBarbsChange));
	}
	if (iReligiousCombatModifierChange != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_RELIGIOUS_COMBAT_MODIFIER_SHORT", iReligiousCombatModifierChange));
	}
	if (iArmorChange != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_ARMOR", iArmorChange));
	}
	if (iPunctureChange != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_PUNCTURE", iPunctureChange));
	}
	if (iDamageModifierChange != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_DAMAGE_MODIFIER", iDamageModifierChange));
	}
	if (iUpkeepModifier != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_HELPTEXT_UNIT_UPKEEP_MODIFIER_BASE", iUpkeepModifier));
	}
	if (iExtraUpkeep100 != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_HELPTEXT_UNIT_UPKEEP_EXTRA", CvWString::format(L"%.2f", iExtraUpkeep100 / 100.0).GetCString()));
	}
	if (iOverrunChange != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_OVERRUN", iOverrunChange));
	}
	if (iRepelChange != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_REPEL", iRepelChange));
	}
	if (iFortRepelChange != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_FORT_REPEL", iFortRepelChange));
	}
	if (iRepelRetriesChange != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_REPEL_RETRIES", iRepelRetriesChange));
	}
	if (iUnyieldingChange != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_UNYIELDING", iUnyieldingChange));
	}
	if (iKnockbackChange != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_KNOCKBACK", iKnockbackChange));
	}
	if (iKnockbackRetriesChange != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_KNOCKBACK_RETRIES", iKnockbackRetriesChange));
	}
	if (iRoundStunProbChange != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_ROUND_STUN_PROB", iRoundStunProbChange));
	}
	if (iPoisonProbabilityModifierChange != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_POISON_PROB", iPoisonProbabilityModifierChange));
	}
	if (iStrAdjperRndChange > 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_RAGE", iStrAdjperRndChange));
	}
	else if (iStrAdjperRndChange < 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_FATIGUE", iStrAdjperRndChange));
	}
	if (iStrAdjperAttChange > 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_RAMPAGE", iStrAdjperAttChange));
	}
	else if (iStrAdjperAttChange < 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_TIRES", iStrAdjperAttChange));
	}
	if (iStrAdjperDefChange > 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_DETERMINATION", iStrAdjperDefChange));
	}
	else if (iStrAdjperDefChange < 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_DEMORALIZATION", iStrAdjperDefChange));
	}
	if (iWithdrawAdjperAttChange > 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_REFLEXES", iWithdrawAdjperAttChange));
	}
	else if (iWithdrawAdjperAttChange < 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_FRAYS", iWithdrawAdjperAttChange));
	}
	if (iUnnerveChange != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_UNNERVE", iUnnerveChange));
	}
	if (iEncloseChange != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_ENCLOSE", iEncloseChange));
	}
	if (iLungeChange != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_LUNGE", iLungeChange));
	}
	if (iDynamicDefenseChange != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_DYNAMIC_DEFENSE", iDynamicDefenseChange));
	}
	if (iStrengthChange > 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_STRENGTHEN", iStrengthChange));
	}
	else if (iStrengthChange < 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_WEAKEN", iStrengthChange));
	}
	if (iOvercomeProbability != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_OVERCOME_PROBABILITY", iOvercomeProbability));
	}
	if (iOvercomeAdjperTurn > 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_WEAROFF", iOvercomeAdjperTurn));
	}
	else if (iOvercomeAdjperTurn < 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_INTENSIFIES", iOvercomeAdjperTurn));
	}
	if (iFortitudeChange != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_FORTITUDE_CHANGE", iFortitudeChange));
	}
	if (iDamageperTurn != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_DAMAGE_PER_TURN", iDamageperTurn));
	}
	if (iStrAdjperTurn < 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_STR_ADJ_PER_TURN_NEGATIVE", iStrAdjperTurn));
	}
	else if (iStrAdjperTurn > 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_STR_ADJ_PER_TURN_POSITIVE", iStrAdjperTurn));
	}
	if (iWeakenperTurn > 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_WEAKEN_PER_TURN_POSITIVE", iWeakenperTurn));
	}
	else if (iWeakenperTurn < 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_WEAKEN_PER_TURN_NEGATIVE", iWeakenperTurn));
	}
	if (iCommunicability != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_COMMUNICABILITY", iCommunicability));
	}
	if (iWorseningProbability != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_PROBABILITY_OF_WORSENING_MODIFIER", iWorseningProbability));
	}
	if (iToleranceBuildup > 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_TOLERANCE_BUILDUP", iToleranceBuildup));
	}
	else if (iToleranceBuildup < 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_TOLERANCE_EROSION", iToleranceBuildup));
	}
	if (iToleranceDecay > 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_TOLERANCE_DECAY", iToleranceDecay));
	}
	if (iToleranceDecay < 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_TOLERANCE_DECAY_ADD", iToleranceDecay));
	}
#ifdef STRENGTH_IN_NUMBERS
	if (iFrontSupportPercentChange > 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_FRONT_SUPPORT_PERCENT_CHANGE", iFrontSupportPercentChange));
	}
	if (iShortRangeSupportPercentChange > 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_SHORT_RANGE_SUPPORT_PERCENT_CHANGE", iShortRangeSupportPercentChange));
	}
	if (iMediumRangeSupportPercentChange > 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_MEDIUM_RANGE_SUPPORT_PERCENT_CHANGE", iMediumRangeSupportPercentChange));
	}
	if (iLongRangeSupportPercentChange > 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_LONG_RANGE_SUPPORT_PERCENT_CHANGE", iLongRangeSupportPercentChange));
	}
	if (iFlankSupportPercentChange > 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_FLANK_SUPPORT_PERCENT_CHANGE", iFlankSupportPercentChange));
	}
#endif
	if (iDodgeModifierChange != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_DODGE_MODIFIER", iDodgeModifierChange));
	}
	if (iPrecisionModifierChange != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_PRECISION_MODIFIER", iPrecisionModifierChange));
	}
	if (iPowerShotsChange != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_POWER_SHOTS", iPowerShotsChange));
	}
	if (iPowerShotCombatModifierChange != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_POWER_SHOT_COMBAT_MODIFIER", iPowerShotCombatModifierChange));
	}
	if (iPowerShotPunctureModifierChange != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_POWER_SHOT_PUNCTURE_MODIFIER", iPowerShotPunctureModifierChange));
	}
	if (iPowerShotPrecisionModifierChange != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_POWER_SHOT_PRECISION_MODIFIER", iPowerShotPrecisionModifierChange));
	}
	if (iPowerShotCriticalModifierChange != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_POWER_SHOT_CRITICAL_MODIFIER", iPowerShotCriticalModifierChange));
	}
	if (iCriticalModifierChange != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_CRITICAL_MODIFIER", iCriticalModifierChange));
	}
	if (iEnduranceChange != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_ENDURANCE", iEnduranceChange));
	}
	if (iInsidiousnessChange != 0)
	{
		szBuffer.append(pcNewline);
		szTempBuffer.Format(L"%.1f", iInsidiousnessChange / 10.0);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_INSIDIOUSNESS", szTempBuffer.GetCString()));
	}
	if (iInvestigationChange != 0)
	{
		szBuffer.append(pcNewline);
		szTempBuffer.Format(L"%.1f", iInvestigationChange / 10.0f);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_INVESTIGATION", szTempBuffer.GetCString()));
	}
	if (iAssassinChange != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_ASSASSIN", iAssassinChange));
	}

	if (GC.getGame().isOption(GAMEOPTION_COMBAT_WITHOUT_WARNING))
	{
		if (iStealthStrikesChange != 0)
		{
			szBuffer.append(pcNewline);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_STEALTH_STRIKES", iStealthStrikesChange));
		}
		if (iStealthCombatModifierChange != 0)
		{
			szBuffer.append(pcNewline);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_STEALTH_COMBAT_MODIFIER", iStealthCombatModifierChange));
		}
		if (iStealthDefenseChange != 0)
		{
			szBuffer.append(pcNewline);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_STEALTH_DEFENSE_CHANGE", iStealthDefenseChange));
		}
	}

	if (iDefenseOnlyChange != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_DEFENSE_ONLY_CHANGE", iDefenseOnlyChange));
	}
	if (iNoInvisibilityChange != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_NO_INVISIBILITY_CHANGE", iNoInvisibilityChange));
	}
	if (iTrapDamageMin != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_TRAP_MIN_DAMAGE", iTrapDamageMin));
	}
	if (iTrapDamageMax != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_TRAP_MAX_DAMAGE", iTrapDamageMax));
	}
	if (iTrapComplexity != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_TRAP_COMPLEXITY", iTrapComplexity));
	}
	if (iTrapNumTriggers != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_TRAP_NUM_TRIGGERS", iTrapNumTriggers));
	}
	if (iTrapTriggerBeforeAttackChange != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_TRAP_TRIGGER_BEFORE_ATTACK", iTrapTriggerBeforeAttackChange));
	}
	if (iVisibilityChange > 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_VISIBILITY", iVisibilityChange));
	}
	if (iCaptureProbabilityModifierChange != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_CAPTURE_PROBABILITY_MODIFIER", iCaptureProbabilityModifierChange));
	}
	if (iCaptureResistanceModifierChange != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_CAPTURE_RESISTANCE_MODIFIER", iCaptureResistanceModifierChange));
	}
	if (iBreakdownChanceChange != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_BREAKDOWN_CHANCE", iBreakdownChanceChange));
	}
	if (iBreakdownDamageChange != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_BREAKDOWN_DAMAGE", iBreakdownDamageChange));
	}
	if (iTauntChange != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_TAUNT", iTauntChange));
	}
	if (iMaxHPChange != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_MAX_HP", iMaxHPChange));
	}
	if (iStrengthModifier != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_STRENGTH_MODIFIER", iStrengthModifier));
	}
	if (iAirCombatLimitChange != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_AIR_LIMIT_CHANGE", iAirCombatLimitChange));
	}
	if (iCelebrityHappy != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_CELEBRITY", iCelebrityHappy));
	}
	if (iCollateralDamageLimitChange != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_COLLATERAL_LIMIT_CHANGE", iCollateralDamageLimitChange));
	}
	if (iCollateralDamageMaxUnitsChange != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_MAX_UNITS_CHANGE", iCollateralDamageMaxUnitsChange));
	}
	if (iCombatLimitChange != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_COMBAT_LIMIT", iCombatLimitChange));
	}
	if (iExtraDropRange != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_EXTRA_DROP_RANGE", iExtraDropRange));
	}
	if (iSurvivorChance != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_SURVIVOR", iSurvivorChance));
	}
	if (iSelfHealModifier != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_SELF_HEAL", iSelfHealModifier));
	}
	if (iHealSupport != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_HEAL_SUPPORT", iHealSupport));
	}
	if (iVictoryAdjacentHeal != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_VICTORY_ADJACENT", iVictoryAdjacentHeal));
	}
	if (iVictoryHeal != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_VICTORY_HEAL", iVictoryHeal));
	}
	if (iVictoryStackHeal != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_VICTORY_STACK", iVictoryStackHeal));
	}
	if (iCargoChange != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_CARGO", iCargoChange));
	}
	if (iCollateralDamageChange != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_COLLATERAL_DAMAGE", iCollateralDamageChange));
	}
	if (iBombardRateChange != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_BOMBARD", iBombardRateChange));
	}
	if (iDCMBombRangeChange != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_DCM_BOMB_RANGE", iDCMBombRangeChange));
	}
	if (iDCMBombAccuracyChange != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_DCM_BOMB_ACCURACY", iDCMBombAccuracyChange));
	}
	if (iRBombardDamageChange != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_DCM_BOMB_DAMAGE", iRBombardDamageChange));
	}
	if (iRBombardDamageLimitChange != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_DCM_BOMB_DAMAGE_LIMIT", iRBombardDamageLimitChange));
	}
	if (iRBombardDamageMaxUnitsChange != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_DCM_BOMB_DAMAGE_MAX_UNITS", iRBombardDamageMaxUnitsChange));
	}
	if (iFirstStrikesChange != 0)
	{
		if (iFirstStrikesChange == 1)
		{
			szBuffer.append(pcNewline);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_FIRST_STRIKE", iFirstStrikesChange));
		}
		else
		{
			szBuffer.append(pcNewline);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_FIRST_STRIKES", iFirstStrikesChange));
		}
	}
	if (iChanceFirstStrikesChange != 0)
	{
		if (iChanceFirstStrikesChange == 1)
		{
			szBuffer.append(pcNewline);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_FIRST_STRIKE_CHANCE", iChanceFirstStrikesChange));
		}
		else
		{
			szBuffer.append(pcNewline);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_FIRST_STRIKES_CHANCE", iChanceFirstStrikesChange));
		}
	}
	if (iEnemyHealChange != 0)
	{
		if(promo.getSound()[5] == 'P')
		{
			szBuffer.append(pcNewline);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_INSTIGATE_SPY", iEnemyHealChange));
		}
		else
		{
			szBuffer.append(pcNewline);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_HEALS_EXTRA", iEnemyHealChange) + gDLL->getText("TXT_KEY_PROMOTIONHELP_ENEMY_LANDS"));
		}
	}
	if (iNeutralHealChange != 0)
	{
		if (promo.getSound()[5] == 'P')
		{
			szBuffer.append(pcNewline);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_INSTIGATE2_SPY", iNeutralHealChange));
		}
		else
		{
			szBuffer.append(pcNewline);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_HEALS_EXTRA", iNeutralHealChange) + gDLL->getText("TXT_KEY_PROMOTIONHELP_NEUTRAL_LANDS"));
		}
	}
	if (iFriendlyHealChange != 0)
	{
		if (promo.getSound()[5] == 'P')
		{
			szBuffer.append(pcNewline);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_POISON_SPY", iFriendlyHealChange));
		}
		else
		{
			szBuffer.append(pcNewline);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_HEALS_EXTRA", iFriendlyHealChange) + gDLL->getText("TXT_KEY_PROMOTIONHELP_FRIENDLY_LANDS"));
		}
	}
	if (iSameTileHealChange != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_HEALS_SAME", iSameTileHealChange) + gDLL->getText("TXT_KEY_PROMOTIONHELP_DAMAGE_TURN"));
	}
	if (iAdjacentTileHealChange != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_HEALS_ADJACENT", iAdjacentTileHealChange) + gDLL->getText("TXT_KEY_PROMOTIONHELP_DAMAGE_TURN"));
	}
	if (iCombatPercent != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_STRENGTH", iCombatPercent));
	}
	if (iCityAttackPercent != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_CITY_ATTACK", iCityAttackPercent));
	}
	if (iCityDefensePercent != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_CITY_DEFENSE", iCityDefensePercent));
	}
	if (iHillsAttackPercent != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_HILLS_ATTACK", iHillsAttackPercent));
	}
	if (iHillsDefensePercent != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_HILLS_DEFENSE", iHillsDefensePercent));
	}
	if (iWorkRate != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_WORK_RATE", iWorkRate));
	}
	if (iHillsWorkPercent != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_HILLS_WORK", iHillsWorkPercent));
	}
	if (iPeaksWorkPercent != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_PEAKS_WORK", iPeaksWorkPercent));
	}
	if (iRevoltProtection != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_TEMP_REVOLT_PROTECTION", iRevoltProtection));
	}
	if (iCollateralDamageProtection != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_COLLATERAL_PROTECTION", iCollateralDamageProtection));
	}
	if (iPillageChange != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_PILLAGE_CHANGE", iPillageChange));
	}
	if (iUpgradeDiscount != 0)
	{
		//TSHEEP Display Spy Promotions Differently
		if (promo.getSound()[5] == 'P')
		{
			szBuffer.append(pcNewline);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_UPGRADE_DISCOUNT_SPY", iUpgradeDiscount));
		}
		else if (100 == iUpgradeDiscount)
		{
			szBuffer.append(pcNewline);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_UPGRADE_DISCOUNT_FREE"));
		}
		else
		{
			szBuffer.append(pcNewline);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_UPGRADE_DISCOUNT", iUpgradeDiscount));
		}
	}
	if (iExperiencePercent != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_FASTER_EXPERIENCE", iExperiencePercent));
	}
	if (iKamikazePercent != 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_KAMIKAZE", iKamikazePercent));
	}
	if (iHiddenNationality > 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_HIDDEN_NATIONALITY_ADDS"));
	}
	else if (iHiddenNationality < 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_HIDDEN_NATIONALITY_REMOVES"));
	}
	if ( iIsAnimalIgnoresBordersChange != 0 && !GC.getGame().isOption(GAMEOPTION_ANIMAL_STAY_OUT))
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_ANIMAL_IGNORES_BORDERS", iIsAnimalIgnoresBordersChange));
	}

	if ( iNoDefensiveBonusChange > 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_NO_DEFENSIVE_BONUS_CHANGE_POSITIVE", iNoDefensiveBonusChange));
	}

	if ( iNoDefensiveBonusChange < 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_NO_DEFENSIVE_BONUS_CHANGE_NEGATIVE", iNoDefensiveBonusChange));
	}

	if (bIsImmuneToFirstStrikes)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_IMMUNE_FIRST_STRIKES"));
	}

	//references
	{
		DomainTypes	eDomainCargoChange = NO_DOMAIN;
		SpecialUnitTypes eSpecialCargoChange = NO_SPECIALUNIT;
		SpecialUnitTypes eNotSpecialCargoChange = NO_SPECIALUNIT;
		SpecialUnitTypes eSpecialUnit = NO_SPECIALUNIT;
		for (int iI = 0; iI < (int)linePromotionsOwned.size(); iI++ )
		{
			eDomainCargoChange = GC.getPromotionInfo(linePromotionsOwned[iI]).getDomainCargoChange();
			eSpecialCargoChange = GC.getPromotionInfo(linePromotionsOwned[iI]).getSpecialCargoChange();

			if (GC.getGame().isOption(GAMEOPTION_COMBAT_SIZE_MATTERS))
			{
				eNotSpecialCargoChange = GC.getPromotionInfo(linePromotionsOwned[iI]).getSMNotSpecialCargoChange();
			}
			eSpecialUnit = GC.getPromotionInfo(linePromotionsOwned[iI]).setSpecialUnit();
		}
		if (eDomainCargoChange != NO_DOMAIN)
		{
			szBuffer.append(pcNewline);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_DOMAIN_CARGO_CHANGE", GC.getDomainInfo(eDomainCargoChange).getTextKeyWide()));
		}
		if (eSpecialCargoChange != NO_SPECIALUNIT)
		{
			szBuffer.append(pcNewline);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_SPECIAL_CARGO_CHANGE", GC.getSpecialUnitInfo(eSpecialCargoChange).getTextKeyWide()));
		}
		if (eNotSpecialCargoChange != NO_SPECIALUNIT)
		{
			szBuffer.append(pcNewline);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOHELP_CHANGE_NOT_SPECIAL_CARGO", GC.getSpecialUnitInfo(eNotSpecialCargoChange).getTextKeyWide()));
		}
		if (eSpecialUnit != NO_SPECIALUNIT)
		{
			szBuffer.append(pcNewline);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOHELP_CHANGE_SPECIAL_UNIT", GC.getSpecialUnitInfo(eSpecialUnit).getTextKeyWide()));
		}
	}

	//Vectors

	if (GC.getGame().isModderGameOption(MODDERGAMEOPTION_TERRAIN_DAMAGE))
	{
		bst::scoped_array<bool> abIsIgnoreTerrainDamage(new bool[GC.getNumTerrainInfos()]());

		for (int iI = 0; iI < (int)linePromotionsOwned.size(); iI++)
		{
			const TerrainTypes eTerrainX = (TerrainTypes) GC.getPromotionInfo(linePromotionsOwned[iI]).getIgnoreTerrainDamage();

			if (eTerrainX != NO_TERRAIN && !abIsIgnoreTerrainDamage[eTerrainX])
			{
				szBuffer.append(pcNewline);
				szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_IGNORE_TERRAIN_DAMAGE", GC.getTerrainInfo(eTerrainX).getDescription()));

				abIsIgnoreTerrainDamage[eTerrainX] = true;
			}
		}
	}

#ifdef OUTBREAKS_AND_AFFLICTIONS
	std::vector<PromotionLineTypes> aAfflictions;
	std::vector<int> iMelee;
	std::vector<int> iDistance;
	std::vector<int> iImmediate;
	std::vector<int> iProbability;

	for (int iJ = 0; iJ < (int)linePromotionsOwned.size(); iJ++)
	{
		for (int iI = 0; iI < GC.getPromotionInfo(linePromotionsOwned[iJ]).getNumAfflictOnAttackChangeTypes(); ++iI)
		{
			aAfflictions.push_back((PromotionLineTypes)promo.getAfflictOnAttackChangeType(iI).eAfflictionLine);
			iMelee.push_back(promo.getAfflictOnAttackChangeType(iI).iMelee);
			iDistance.push_back(promo.getAfflictOnAttackChangeType(iI).iDistance);
			iImmediate.push_back(promo.getAfflictOnAttackChangeType(iI).iImmediate);
			iProbability.push_back(promo.getAfflictOnAttackChangeType(iI).iProbabilityChange);
		}
	}

	for (int iI = 0; iI < (int)aAfflictions.size(); iI++ )
	{
		if (iImmediate[iI] > 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_AFFLICT_ON_ATTACK_IMMEDIATE", iProbability[iI], GC.getPromotionLineInfo(aAfflictions[iI]).getDescription()));
		}
		else if (iImmediate[iI] < 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_AFFLICT_ON_ATTACK_NOT_IMMEDIATE", iProbability[iI], GC.getPromotionLineInfo(aAfflictions[iI]).getDescription()));
		}
		else
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_AFFLICT_ON_ATTACK", iProbability[iI], GC.getPromotionLineInfo(aAfflictions[iI]).getDescription()));
		}
		if (iMelee[iI] > 0 && iDistance[iI] > 0)
		{
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_AFFLICT_ON_ATTACK_BOTH"));
		}
		else
		{
			if (iMelee[iI] > 0)
			{
				szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_AFFLICT_ON_ATTACK_MELEE"));
			}
			if (iDistance[iI] > 0)
			{
				szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_AFFLICT_ON_ATTACK_DISTANCE"));
			}
		}
	}

	if (GC.getGame().isOption(GAMEOPTION_COMBAT_OUTBREAKS_AND_AFFLICTIONS))
	{
		aAfflictions.clear();
		iImmediate.clear();
		iMelee.clear();
		iDistance.clear();
		iProbability.clear();


		for( iJ = 0; iJ < (int)linePromotionsOwned.size(); iJ++ )
		{
			for (iI = 0; iI < GC.getPromotionInfo(linePromotionsOwned[iJ]).getNumCureAfflictionChangeTypes(); ++iI)
			{
				aAfflictions.push_back((PromotionLineTypes)promo.getCureAfflictionChangeType(iI));
			}
		}

		for( iI = 0; iI < (int)aAfflictions.size(); iI++ )
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_CURE_AFFLICTION", GC.getPromotionLineInfo(aAfflictions[iI]).getDescription()));
		}

		std::vector<int> afflictionModifier;

		aAfflictions.clear();
		for( iJ = 0; iJ < (int)linePromotionsOwned.size(); iJ++ )
		{
			for (iI = 0; iI < GC.getPromotionInfo(linePromotionsOwned[iJ]).getNumAfflictionFortitudeChangeModifiers(); ++iI)
			{
				aAfflictions.push_back((PromotionLineTypes)promo.getAfflictionFortitudeChangeModifier(iI).ePromotionLine);
				afflictionModifier.push_back(promo.getAfflictionFortitudeChangeModifier(iI).iModifier);
			}
		}

		for( iI = 0; iI < (int)aAfflictions.size(); iI++ )
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_AFFLICTION_FORTITUDE_CHANGE_MODIFIER", afflictionModifier[iI], GC.getPromotionLineInfo(aAfflictions[iI]).getDescription()));
		}
	}
#endif // OUTBREAKS_AND_AFFLICTIONS


	{
		bst::scoped_array<bool> unitCombats(new bool[GC.getNumUnitCombatInfos()]());

		for (int iJ = 0; iJ < (int)linePromotionsOwned.size(); iJ++)
		{
			const CvPromotionInfo& promoX = GC.getPromotionInfo(linePromotionsOwned[iJ]);

			for (int iI = 0; iI < promoX.getNumSubCombatChangeTypes(); ++iI)
			{
				const UnitCombatTypes eUnitCombatX = (UnitCombatTypes)promoX.getSubCombatChangeType(iI);

				if (eUnitCombatX != NO_UNITCOMBAT && !unitCombats[eUnitCombatX])
				{
					szBuffer.append(NEWLINE);
					szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_SUB_COMBAT", GC.getUnitCombatInfo(eUnitCombatX).getDescription()));
					unitCombats[eUnitCombatX] = true;
				}
			}
		}
		for (int iJ = 0; iJ < (int)linePromotionsOwned.size(); iJ++)
		{
			const CvPromotionInfo& promoX = GC.getPromotionInfo(linePromotionsOwned[iJ]);

			for (int iI = 0; iI < promoX.getNumSubCombatChangeTypes(); ++iI)
			{
				unitCombats[(UnitCombatTypes)promoX.getSubCombatChangeType(iI)] = false;
			}
		}

		for (int iJ = 0; iJ < (int)linePromotionsOwned.size(); iJ++)
		{
			const CvPromotionInfo& promoX = GC.getPromotionInfo(linePromotionsOwned[iJ]);

			for (int iI = 0; iI < promoX.getNumRemovesUnitCombatTypes(); ++iI)
			{
				const UnitCombatTypes eUnitCombatX = (UnitCombatTypes)promoX.getRemovesUnitCombatType(iI);

				if (eUnitCombatX != NO_UNITCOMBAT && !unitCombats[eUnitCombatX])
				{
					szBuffer.append(NEWLINE);
					szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_REMOVES_COMBAT", GC.getUnitCombatInfo(eUnitCombatX).getDescription()));
					unitCombats[eUnitCombatX] = true;
				}
			}
		}
	}

	{
		bst::scoped_array<bool> trapSetWithPromo(new bool[GC.getNumPromotionInfos()]());

		for (int iJ = 0; iJ < (int)linePromotionsOwned.size(); iJ++ )
		{
			const CvPromotionInfo& promoX = GC.getPromotionInfo(linePromotionsOwned[iJ]);

			for (int iI = 0; iI < promoX.getNumTrapSetWithPromotionTypes(); ++iI)
			{
				const PromotionTypes ePromoX = (PromotionTypes)promoX.getTrapSetWithPromotionType(iI);

				if (ePromoX != NO_PROMOTION && !trapSetWithPromo[ePromoX])
				{
					szBuffer.append(NEWLINE);
					szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_TRAP_PROMOTION_SET", GC.getPromotionInfo(ePromoX).getTextKeyWide()));
					trapSetWithPromo[ePromoX] = true;
				}
			}
		}
	}
	{
		bst::scoped_array<bool> unitCombats(new bool[GC.getNumUnitCombatInfos()]());

		for (int iJ = 0; iJ < (int)linePromotionsOwned.size(); iJ++ )
		{
			const CvPromotionInfo& promoX = GC.getPromotionInfo(linePromotionsOwned[iJ]);

			for (int iI = 0; iI < promoX.getNumTrapImmunityUnitCombatTypes(); ++iI)
			{
				const UnitCombatTypes eUnitCombatX = (UnitCombatTypes)promoX.getTrapImmunityUnitCombatType(iI);

				if (eUnitCombatX != NO_UNITCOMBAT && !unitCombats[eUnitCombatX])
				{
					szBuffer.append(NEWLINE);
					szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_TRAP_IMMUNITY", GC.getUnitCombatInfo(eUnitCombatX).getTextKeyWide()));
					unitCombats[eUnitCombatX] = true;
				}
			}
		}
		for (int iJ = 0; iJ < (int)linePromotionsOwned.size(); iJ++)
		{
			const CvPromotionInfo& promoX = GC.getPromotionInfo(linePromotionsOwned[iJ]);

			for (int iI = 0; iI < promoX.getNumSubCombatChangeTypes(); ++iI)
			{
				unitCombats[(UnitCombatTypes)promoX.getSubCombatChangeType(iI)] = false;
			}
		}
		for (int iJ = 0; iJ < (int)linePromotionsOwned.size(); iJ++ )
		{
			const CvPromotionInfo& promoX = GC.getPromotionInfo(linePromotionsOwned[iJ]);

			for (int iI = 0; iI < promoX.getNumTargetUnitCombatTypes(); ++iI)
			{
				const UnitCombatTypes eUnitCombatX = (UnitCombatTypes)promoX.getTargetUnitCombatType(iI);

				if (eUnitCombatX != NO_UNITCOMBAT && !unitCombats[eUnitCombatX])
				{
					szBuffer.append(NEWLINE);
					szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_TARGET_UNITCOMBAT", GC.getUnitCombatInfo(eUnitCombatX).getTextKeyWide()));
					unitCombats[eUnitCombatX] = true;
				}
			}
		}
	}

	{
		std::vector<UnitCombatTypes> eUnitCombat;
		std::vector<int> iHeal;
		std::vector<int> iAdjacentHeal;

		for (int iJ = 0; iJ < (int)linePromotionsOwned.size(); iJ++ )
		{
			const CvPromotionInfo& promoX = GC.getPromotionInfo(linePromotionsOwned[iJ]);

			for (int iI = 0; iI < promoX.getNumHealUnitCombatChangeTypes(); ++iI)
			{
				bool bFirst = true;
				for (int iK = 0; iK < (int)eUnitCombat.size(); iK++ )
				{
					if (eUnitCombat[iK] == (UnitCombatTypes)promoX.getHealUnitCombatChangeType(iI).eUnitCombat)
					{
						bFirst = false;
					}
				}
				if (bFirst)
				{
					eUnitCombat.push_back((UnitCombatTypes)promoX.getHealUnitCombatChangeType(iI).eUnitCombat);
					iHeal.push_back(promoX.getHealUnitCombatChangeType(iI).iHeal);
					iAdjacentHeal.push_back(promoX.getHealUnitCombatChangeType(iI).iAdjacentHeal);
				}
				else
				{
					for (int iK = 0; iK < (int)eUnitCombat.size(); iK++ )
					{
						if (eUnitCombat[iK] == (UnitCombatTypes)promoX.getHealUnitCombatChangeType(iI).eUnitCombat)
						{
							iHeal[iK] += promoX.getHealUnitCombatChangeType(iI).iHeal;
							iAdjacentHeal[iK] += promoX.getHealUnitCombatChangeType(iI).iAdjacentHeal;
						}
					}
				}
			}
		}

		for (int iI = 0; iI < (int)eUnitCombat.size(); iI++ )
		{
			if (iHeal[iI] > 0)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_HEALS_UNITCOMBAT_SAME", GC.getUnitCombatInfo(eUnitCombat[iI]).getTextKeyWide(), iHeal[iI]) + gDLL->getText("TXT_KEY_PROMOTIONHELP_DAMAGE_TURN"));
			}
			if (iAdjacentHeal[iI] > 0)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_HEALS_UNITCOMBAT_ADJACENT", GC.getUnitCombatInfo(eUnitCombat[iI]).getTextKeyWide(), iAdjacentHeal[iI]) + gDLL->getText("TXT_KEY_PROMOTIONHELP_DAMAGE_TURN"));
			}
		}
		eUnitCombat.clear();
		iHeal.clear();
		iAdjacentHeal.clear();
	}

	std::vector<BuildTypes> aAddsBuildTypes;
	aAddsBuildTypes.clear();
	for (int iJ = 0; iJ < (int)linePromotionsOwned.size(); iJ++ )
	{
		for (int iI = 0; iI < GC.getPromotionInfo(linePromotionsOwned[iJ]).getNumAddsBuildTypes(); ++iI)
		{
			aAddsBuildTypes.push_back((BuildTypes)promo.getAddsBuildType(iI));
		}
	}

	for (int iI = 0; iI < (int)aAddsBuildTypes.size(); iI++ )
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_ADDS_BUILD_TYPE", GC.getBuildInfo(aAddsBuildTypes[iI]).getTextKeyWide()));
	}

	std::vector<InvisibleTypes> aNegatesInvisibilityType;
	aNegatesInvisibilityType.clear();
	for(int iJ = 0; iJ < (int)linePromotionsOwned.size(); iJ++ )
	{
		for (int iI = 0; iI < GC.getPromotionInfo(linePromotionsOwned[iJ]).getNumNegatesInvisibilityTypes(); ++iI)
		{
			aNegatesInvisibilityType.push_back((InvisibleTypes)promo.getNegatesInvisibilityType(iI));
		}
	}

	for(int iI = 0; iI < (int)aNegatesInvisibilityType.size(); iI++ )
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOHELP_INVISIBILITY_NEGATES_VEIL", GC.getInvisibleInfo(aNegatesInvisibilityType[iI]).getChar()));
	}

	std::vector<TerrainTypes> aPrereqTerrainType;
	aPrereqTerrainType.clear();
	for(int iJ = 0; iJ < (int)linePromotionsOwned.size(); iJ++ )
	{
		for (int iI = 0; iI < GC.getPromotionInfo(linePromotionsOwned[iJ]).getNumPrereqTerrainTypes(); ++iI)
		{
			aPrereqTerrainType.push_back((TerrainTypes)promo.getPrereqTerrainType(iI));
		}
	}

	for(int iI = 0; iI < (int)aPrereqTerrainType.size(); iI++ )
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_TERRAIN_PREREQ", GC.getTerrainInfo(aPrereqTerrainType[iI]).getTextKeyWide()));
	}

	std::vector<FeatureTypes> aPrereqFeatureType;
	aPrereqFeatureType.clear();
	for(int iJ = 0; iJ < (int)linePromotionsOwned.size(); iJ++ )
	{
		for (int iI = 0; iI < GC.getPromotionInfo(linePromotionsOwned[iJ]).getNumPrereqFeatureTypes(); ++iI)
		{
			aPrereqFeatureType.push_back((FeatureTypes)promo.getPrereqFeatureType(iI));
		}
	}

	for( iI = 0; iI < (int)aPrereqFeatureType.size(); iI++ )
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_FEATURE_PREREQ", GC.getFeatureInfo(aPrereqFeatureType[iI]).getTextKeyWide()));
	}

	std::vector<ImprovementTypes> aPrereqImprovementType;
	aPrereqImprovementType.clear();
	for(int iJ = 0; iJ < (int)linePromotionsOwned.size(); iJ++ )
	{
		for (int iI = 0; iI < GC.getPromotionInfo(linePromotionsOwned[iJ]).getNumPrereqImprovementTypes(); ++iI)
		{
			aPrereqImprovementType.push_back((ImprovementTypes)promo.getPrereqImprovementType(iI));
		}
	}

	for(int iI = 0; iI < (int)aPrereqImprovementType.size(); iI++ )
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_IMPROVEMENT_PREREQ", GC.getImprovementInfo(aPrereqImprovementType[iI]).getTextKeyWide()));
	}

	for(int iJ = 0; iJ < (int)linePromotionsOwned.size(); iJ++ )
	{
		for (int iI = 0; iI < GC.getPromotionInfo(linePromotionsOwned[iJ]).getNumPrereqLocalBuildingTypes(); ++iI)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_BUILDING_PREREQ", GC.getBuildingInfo((BuildingTypes)GC.getPromotionInfo(linePromotionsOwned[iJ]).getPrereqLocalBuildingType(iI)).getTextKeyWide()));
		}
	}

	std::vector<BonusTypes> aPrereqPlotBonusType;
	aPrereqPlotBonusType.clear();
	for(int iJ = 0; iJ < (int)linePromotionsOwned.size(); iJ++ )
	{
		for (int iI = 0; iI < GC.getPromotionInfo(linePromotionsOwned[iJ]).getNumPrereqPlotBonusTypes(); ++iI)
		{
			aPrereqPlotBonusType.push_back((BonusTypes)promo.getPrereqPlotBonusType(iI));
		}
	}

	for(int iI = 0; iI < (int)aPrereqPlotBonusType.size(); iI++ )
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_BONUS_PREREQ", GC.getBonusInfo(aPrereqPlotBonusType[iI]).getTextKeyWide()));
	}

	//TerrainInfos
	bool	bIsTerrainDoubleMove = false;
	int	iTerrainAttackPercent = 0;
	int	iTerrainDefensePercent = 0;
	int iTerrainWorkPercent = 0;
	int iWithdrawOnTerrain = 0;
	for (int iI = 0; iI < GC.getNumTerrainInfos(); ++iI)
	{
		for(int iJ = 0; iJ < (int)linePromotionsOwned.size(); iJ++ )
		{
			if ( GC.getPromotionInfo(linePromotionsOwned[iJ]).getTerrainDoubleMove(iI) )
			{
				bIsTerrainDoubleMove = true;
			}
			iTerrainAttackPercent += GC.getPromotionInfo(linePromotionsOwned[iJ]).getTerrainAttackPercent(iI);
			iTerrainDefensePercent += GC.getPromotionInfo(linePromotionsOwned[iJ]).getTerrainDefensePercent(iI);
			iTerrainWorkPercent += GC.getPromotionInfo(linePromotionsOwned[iJ]).getTerrainWorkPercent(iI);
			iWithdrawOnTerrain += GC.getPromotionInfo(linePromotionsOwned[iJ]).getWithdrawOnTerrainTypeChange(iI);
		}
		if (bIsTerrainDoubleMove)
		{
			szBuffer.append(pcNewline);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_DOUBLE_MOVE", GC.getTerrainInfo((TerrainTypes) iI).getTextKeyWide()));
		}
		if (iTerrainAttackPercent != 0)
		{
			szBuffer.append(pcNewline);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_ATTACK", iTerrainAttackPercent, GC.getTerrainInfo((TerrainTypes) iI).getTextKeyWide()));
		}
		if (iTerrainDefensePercent != 0)
		{
			bDefWarning = true;
			szBuffer.append(pcNewline);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_DEFENSE", iTerrainDefensePercent, GC.getTerrainInfo((TerrainTypes) iI).getTextKeyWide()));
		}
		if (iTerrainWorkPercent != 0)
		{
			szBuffer.append(pcNewline);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_WORK", iTerrainWorkPercent, GC.getTerrainInfo((TerrainTypes)iI).getTextKeyWide()));
		}
		if (iWithdrawOnTerrain != 0)
		{
			szBuffer.append(pcNewline);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_WITHDRAW_ON", iWithdrawOnTerrain, CvWString(GC.getTerrainInfo((TerrainTypes)iI).getType()).GetCString(), GC.getTerrainInfo((TerrainTypes)iI).getTextKeyWide()));
		}
		bIsTerrainDoubleMove = false;
		iTerrainAttackPercent = 0;
		iTerrainDefensePercent = 0;
		iTerrainWorkPercent = 0;
		iWithdrawOnTerrain = 0;
	}

	//FeatureInfos
	bool	bIsFeatureDoubleMove = false;
	int iFeatureAttackPercent = 0;
	int iFeatureDefensePercent = 0;
	int iFeatureWorkPercent = 0;
	int iWithdrawOnFeature = 0;
	for (int iI = 0; iI < GC.getNumFeatureInfos(); ++iI)
	{
		for(int iJ = 0; iJ < (int)linePromotionsOwned.size(); iJ++ )
		{
			if ( GC.getPromotionInfo(linePromotionsOwned[iJ]).getFeatureDoubleMove(iI) )
			{
				bIsFeatureDoubleMove = true;
			}
			iFeatureAttackPercent += GC.getPromotionInfo(linePromotionsOwned[iJ]).getFeatureAttackPercent(iI);
			iFeatureDefensePercent += GC.getPromotionInfo(linePromotionsOwned[iJ]).getFeatureDefensePercent(iI);
			iFeatureWorkPercent += GC.getPromotionInfo(linePromotionsOwned[iJ]).getFeatureWorkPercent(iI);
			iWithdrawOnFeature += GC.getPromotionInfo(linePromotionsOwned[iJ]).getWithdrawOnFeatureTypeChange(iI);
		}
		if (bIsFeatureDoubleMove)
		{
			szBuffer.append(pcNewline);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_DOUBLE_MOVE", GC.getFeatureInfo((FeatureTypes) iI).getTextKeyWide()));
		}
		if (iFeatureAttackPercent != 0)
		{
			szBuffer.append(pcNewline);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_ATTACK", iFeatureAttackPercent, GC.getFeatureInfo((FeatureTypes) iI).getTextKeyWide()));
		}
		if (iFeatureDefensePercent != 0)
		{
			bDefWarning = true;
			szBuffer.append(pcNewline);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_DEFENSE", iFeatureDefensePercent, GC.getFeatureInfo((FeatureTypes) iI).getTextKeyWide()));
		}
		if (iFeatureWorkPercent != 0)
		{
			szBuffer.append(pcNewline);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_WORK", iFeatureWorkPercent, GC.getFeatureInfo((FeatureTypes)iI).getTextKeyWide()));
		}
		if (iWithdrawOnFeature != 0)
		{
			szBuffer.append(pcNewline);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_WITHDRAW_ON", iWithdrawOnFeature, CvWString(GC.getFeatureInfo((FeatureTypes)iI).getType()).GetCString(), GC.getFeatureInfo((FeatureTypes)iI).getTextKeyWide()));
		}
		bIsFeatureDoubleMove = false;
		iFeatureAttackPercent = 0;
		iFeatureDefensePercent = 0;
		iFeatureWorkPercent = 0;
		iWithdrawOnFeature = 0;
	}

	//Builds
	int iBuildWorkPercent = 0;
	for (int iI = 0; iI < GC.getNumBuildInfos(); ++iI)
	{
		for(int iJ = 0; iJ < (int)linePromotionsOwned.size(); iJ++)
		{
			iBuildWorkPercent += GC.getPromotionInfo(linePromotionsOwned[iJ]).getBuildWorkRateModifierChangeType(iI);
		}
		if (iBuildWorkPercent != 0)
		{
			szBuffer.append(pcNewline);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_WORK", iBuildWorkPercent, GC.getBuildInfo((BuildTypes)iI).getTextKeyWide()));
		}
		iBuildWorkPercent = 0;
	}

	//Domains
	for (int iI = 0; iI < NUM_DOMAIN_TYPES; ++iI)
	{
		int iDomainModifierPercent = 0;
		for(int iJ = 0; iJ < (int)linePromotionsOwned.size(); iJ++ )
		{
			iDomainModifierPercent += GC.getPromotionInfo(linePromotionsOwned[iJ]).getDomainModifierPercent(iI);
		}
		if (iDomainModifierPercent != 0)
		{
			szBuffer.append(pcNewline);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_VERSUS", iDomainModifierPercent, CvWString(GC.getDomainInfo((DomainTypes)iI).getType()).GetCString(), GC.getDomainInfo((DomainTypes)iI).getTextKeyWide()));
		}
	}

	//UnitCombats
	int iDisable = 0;
	int iAvoid = 0;
	int iTrigger = 0;
	int iAidChange = 0;
	int	iUnitCombatContractChanceChange = 0;
	int	iUnitCombatOvercomeChange = 0;
	int	iFlankingStrengthbyUnitCombatTypeChange = 0;
	int iUnitCombatModifierPercent = 0;
	int iWithdrawVS = 0;
	int iPursuitVS = 0;
	int iRepelVS = 0;
	int iKnockbackVS = 0;
	int iPunctureVS = 0;
	int iArmorVS = 0;
	int iDodgeVS = 0;
	int iPrecisionVS = 0;
	int iCriticalVS = 0;
	int iRoundStunVS = 0;
	for (int iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
	{
		for(int iJ = 0; iJ < (int)linePromotionsOwned.size(); iJ++ )
		{
			iDisable += GC.getPromotionInfo(linePromotionsOwned[iJ]).getTrapDisableUnitCombatType(iI);
			iAvoid += GC.getPromotionInfo(linePromotionsOwned[iJ]).getTrapAvoidanceUnitCombatType(iI);
			iTrigger += GC.getPromotionInfo(linePromotionsOwned[iJ]).getTrapTriggerUnitCombatType(iI);
#ifdef OUTBREAKS_AND_AFFLICTIONS
			iAidChange += GC.getPromotionInfo(linePromotionsOwned[iJ]).getAidChange(iI);
#endif
			iFlankingStrengthbyUnitCombatTypeChange += GC.getPromotionInfo(linePromotionsOwned[iJ]).getFlankingStrengthbyUnitCombatTypeChange(iI);
			iUnitCombatModifierPercent += GC.getPromotionInfo(linePromotionsOwned[iJ]).getUnitCombatModifierPercent(iI);
			iWithdrawVS += GC.getPromotionInfo(linePromotionsOwned[iJ]).getWithdrawVSUnitCombatChangeType(iI);
			iPursuitVS += GC.getPromotionInfo(linePromotionsOwned[iJ]).getPursuitVSUnitCombatChangeType(iI);
			iRepelVS += GC.getPromotionInfo(linePromotionsOwned[iJ]).getRepelVSUnitCombatChangeType(iI);
			iKnockbackVS += GC.getPromotionInfo(linePromotionsOwned[iJ]).getKnockbackVSUnitCombatChangeType(iI);
			iPunctureVS += GC.getPromotionInfo(linePromotionsOwned[iJ]).getPunctureVSUnitCombatChangeType(iI);
			iArmorVS += GC.getPromotionInfo(linePromotionsOwned[iJ]).getArmorVSUnitCombatChangeType(iI);
			iDodgeVS += GC.getPromotionInfo(linePromotionsOwned[iJ]).getDodgeVSUnitCombatChangeType(iI);
			iPrecisionVS += GC.getPromotionInfo(linePromotionsOwned[iJ]).getPrecisionVSUnitCombatChangeType(iI);
			iCriticalVS += GC.getPromotionInfo(linePromotionsOwned[iJ]).getCriticalVSUnitCombatChangeType(iI);
			iRoundStunVS += GC.getPromotionInfo(linePromotionsOwned[iJ]).getRoundStunVSUnitCombatChangeType(iI);
			if (GC.getPromotionInfo(linePromotionsOwned[iJ]).getPromotionLine() != NO_PROMOTIONLINE)
			{
				iUnitCombatContractChanceChange += GC.getPromotionLineInfo(GC.getPromotionInfo(linePromotionsOwned[iJ]).getPromotionLine()).getUnitCombatContractChanceChange(iI);
				iUnitCombatOvercomeChange += GC.getPromotionLineInfo(GC.getPromotionInfo(linePromotionsOwned[iJ]).getPromotionLine()).getUnitCombatOvercomeChange(iI);
			}
		}
		if (iUnitCombatContractChanceChange > 0)
		{
			szBuffer.append(pcNewline);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_UNIT_COMBAT_COMMUNICABILITY_CHANGE_POSITIVE", iUnitCombatContractChanceChange, GC.getUnitCombatInfo((UnitCombatTypes)iI).getDescription()));
		}
		else if (iUnitCombatContractChanceChange < 0)
		{
			szBuffer.append(pcNewline);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_UNIT_COMBAT_COMMUNICABILITY_CHANGE_NEGATIVE", iUnitCombatContractChanceChange, GC.getUnitCombatInfo((UnitCombatTypes)iI).getDescription()));
		}
		if (iUnitCombatOvercomeChange > 0)
		{
			szBuffer.append(pcNewline);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_UNIT_COMBAT_OVERCOME_CHANGE_POSITIVE", iUnitCombatOvercomeChange, GC.getUnitCombatInfo((UnitCombatTypes)iI).getDescription()));
		}
		else if (iUnitCombatOvercomeChange < 0)
		{
			szBuffer.append(pcNewline);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_UNIT_COMBAT_OVERCOME_CHANGE_NEGATIVE", iUnitCombatOvercomeChange, GC.getUnitCombatInfo((UnitCombatTypes)iI).getDescription()));
		}
		if (iFlankingStrengthbyUnitCombatTypeChange > 0)
		{
			szBuffer.append(pcNewline);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_FLANKING_STRENGTH_BY_UNIT_COMBAT_POSITIVE", iFlankingStrengthbyUnitCombatTypeChange, GC.getUnitCombatInfo((UnitCombatTypes)iI).getDescription()));
		}
		else if (iFlankingStrengthbyUnitCombatTypeChange < 0)
		{
			szBuffer.append(pcNewline);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_FLANKING_STRENGTH_BY_UNIT_COMBAT_NEGATIVE", iFlankingStrengthbyUnitCombatTypeChange, GC.getUnitCombatInfo((UnitCombatTypes)iI).getDescription()));
		}
		if (iDisable != 0)
		{
			szBuffer.append(pcNewline);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_TRAP_DISABLE", iDisable, GC.getUnitCombatInfo((UnitCombatTypes)iI).getTextKeyWide()));
		}
		if (iAvoid != 0)
		{
			szBuffer.append(pcNewline);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_TRAP_AVOID", iAvoid, GC.getUnitCombatInfo((UnitCombatTypes)iI).getTextKeyWide()));
		}
		if (iTrigger != 0)
		{
			szBuffer.append(pcNewline);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_TRAP_TRIGGER", iTrigger, GC.getUnitCombatInfo((UnitCombatTypes)iI).getTextKeyWide()));
		}
		if (iAidChange != 0)
		{
			szBuffer.append(pcNewline);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_AID_CHANGE", iAidChange, GC.getPropertyInfo((PropertyTypes)iI).getTextKeyWide()));
		}
		if (iUnitCombatModifierPercent != 0)
		{
			szBuffer.append(pcNewline);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_VERSUS", iUnitCombatModifierPercent, CvWString(GC.getUnitCombatInfo((UnitCombatTypes)iI).getType()).GetCString(), GC.getUnitCombatInfo((UnitCombatTypes)iI).getTextKeyWide()));
		}
		if (iWithdrawVS != 0)
		{
			szBuffer.append(pcNewline);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_WITHDRAW_VERSUS", iWithdrawVS, CvWString(GC.getUnitCombatInfo((UnitCombatTypes)iI).getType()).GetCString(), GC.getUnitCombatInfo((UnitCombatTypes)iI).getTextKeyWide()));
		}
		if (iPursuitVS != 0)
		{
			szBuffer.append(pcNewline);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_PURSUIT_VERSUS", iPursuitVS, CvWString(GC.getUnitCombatInfo((UnitCombatTypes)iI).getType()).GetCString(), GC.getUnitCombatInfo((UnitCombatTypes)iI).getTextKeyWide()));
		}
		if (iRepelVS != 0)
		{
			szBuffer.append(pcNewline);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_REPEL_VERSUS", iRepelVS, CvWString(GC.getUnitCombatInfo((UnitCombatTypes)iI).getType()).GetCString(), GC.getUnitCombatInfo((UnitCombatTypes)iI).getTextKeyWide()));
		}
		if (iKnockbackVS != 0)
		{
			szBuffer.append(pcNewline);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_KNOCKBACK_VERSUS", iKnockbackVS, CvWString(GC.getUnitCombatInfo((UnitCombatTypes)iI).getType()).GetCString(), GC.getUnitCombatInfo((UnitCombatTypes)iI).getTextKeyWide()));
		}
		if (iPunctureVS != 0)
		{
			szBuffer.append(pcNewline);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_PUNCTURE_VERSUS", iPunctureVS, CvWString(GC.getUnitCombatInfo((UnitCombatTypes)iI).getType()).GetCString(), GC.getUnitCombatInfo((UnitCombatTypes)iI).getTextKeyWide()));
		}
		if (iArmorVS != 0)
		{
			szBuffer.append(pcNewline);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_ARMOR_VERSUS", iArmorVS, CvWString(GC.getUnitCombatInfo((UnitCombatTypes)iI).getType()).GetCString(), GC.getUnitCombatInfo((UnitCombatTypes)iI).getTextKeyWide()));
		}
		if (iDodgeVS != 0)
		{
			szBuffer.append(pcNewline);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_DODGE_VERSUS", iDodgeVS, CvWString(GC.getUnitCombatInfo((UnitCombatTypes)iI).getType()).GetCString(), GC.getUnitCombatInfo((UnitCombatTypes)iI).getTextKeyWide()));
		}
		if (iPrecisionVS != 0)
		{
			szBuffer.append(pcNewline);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_PRECISION_VERSUS", iPrecisionVS, CvWString(GC.getUnitCombatInfo((UnitCombatTypes)iI).getType()).GetCString(), GC.getUnitCombatInfo((UnitCombatTypes)iI).getTextKeyWide()));
		}
		if (iCriticalVS != 0)
		{
			szBuffer.append(pcNewline);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_CRITICAL_VERSUS", iCriticalVS, CvWString(GC.getUnitCombatInfo((UnitCombatTypes)iI).getType()).GetCString(), GC.getUnitCombatInfo((UnitCombatTypes)iI).getTextKeyWide()));
		}
		if (iRoundStunVS != 0)
		{
			szBuffer.append(pcNewline);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_ROUND_STUN_VERSUS", iRoundStunVS, CvWString(GC.getUnitCombatInfo((UnitCombatTypes)iI).getType()).GetCString(), GC.getUnitCombatInfo((UnitCombatTypes)iI).getTextKeyWide()));
		}
		iDisable = 0;
		iAvoid = 0;
		iTrigger = 0;
		iUnitCombatContractChanceChange = 0;
		iUnitCombatOvercomeChange = 0;
		iFlankingStrengthbyUnitCombatTypeChange = 0;
		iUnitCombatModifierPercent = 0;
		iWithdrawVS = 0;
		iPursuitVS = 0;
		iRepelVS = 0;
		iKnockbackVS = 0;
		iPunctureVS = 0;
		iArmorVS = 0;
		iDodgeVS = 0;
		iPrecisionVS = 0;
		iCriticalVS = 0;
		iRoundStunVS = 0;
	}

	//Techs
	int	iTechContractChanceChange = 0;
	int	iTechOvercomeChange = 0;
	for (int iI = 0; iI < GC.getNumTechInfos(); iI++)
	{
		if (ePromoLine != NO_PROMOTIONLINE)
		{
			if (GC.getPromotionLineInfo(ePromoLine).isTechContractChanceChange(iI))
			{
				for(int iJ = 0; iJ < (int)linePromotionsOwned.size(); iJ++ )
				{
					iTechContractChanceChange += GC.getPromotionLineInfo(GC.getPromotionInfo(linePromotionsOwned[iJ]).getPromotionLine()).getTechContractChanceChange(iI);
				}
				if (iTechContractChanceChange > 0)
				{
					szBuffer.append(pcNewline);
					szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_TECH_COMMUNICABILITY_CHANGE_POSITIVE", iTechContractChanceChange, GC.getTechInfo((TechTypes)iI).getDescription()));
				}
				else if (iTechContractChanceChange < 0)
				{
					szBuffer.append(pcNewline);
					szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_TECH_COMMUNICABILITY_CHANGE_NEGATIVE", iTechContractChanceChange, GC.getTechInfo((TechTypes)iI).getDescription()));
				}
				iTechContractChanceChange = 0;
			}

			if (GC.getPromotionLineInfo(ePromoLine).isTechOvercomeChange(iI))
			{
				for(int iJ = 0; iJ < (int)linePromotionsOwned.size(); iJ++ )
				{
					iTechOvercomeChange += GC.getPromotionLineInfo(GC.getPromotionInfo(linePromotionsOwned[iJ]).getPromotionLine()).getTechOvercomeChange(iI);
				}
				if (iTechOvercomeChange > 0)
				{
					szBuffer.append(pcNewline);
					szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_TECH_OVERCOME_CHANGE_POSITIVE", iTechOvercomeChange, GC.getTechInfo((TechTypes)iI).getDescription()));
				}
				else if (iTechOvercomeChange < 0)
				{
					szBuffer.append(pcNewline);
					szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_TECH_OVERCOME_CHANGE_NEGATIVE", iTechOvercomeChange, GC.getTechInfo((TechTypes)iI).getDescription()));
				}
				iTechOvercomeChange = 0;
			}
		}
	}

	//Hide and Seek
	if (bHideSeek)
	{
		int iSpotIntensityChange = 0;
		int iSpotIntensityRangeChange = 0;
		int iInvisibilityIntensityChange = 0;
		int iInvisibleTerrainChange = 0;
		int iInvisibleFeatureChange = 0;
		int iInvisibleImprovementChange = 0;
		int iVisibleTerrainChange = 0;
		int iVisibleFeatureChange = 0;
		int iVisibleImprovementChange = 0;
		int iVisibleTerrainRangeChange = 0;
		int iVisibleFeatureRangeChange = 0;
		int iVisibleImprovementRangeChange = 0;
		for (int iI = 0; iI < GC.getNumInvisibleInfos(); ++iI)
		{
			for(int iJ = 0; iJ < (int)linePromotionsOwned.size(); iJ++)
			{
				iSpotIntensityChange += GC.getPromotionInfo(linePromotionsOwned[iJ]).getVisibilityIntensityChangeType(iI);
				iSpotIntensityRangeChange += GC.getPromotionInfo(linePromotionsOwned[iJ]).getVisibilityIntensityRangeChangeType(iI);
				iInvisibilityIntensityChange += GC.getPromotionInfo(linePromotionsOwned[iJ]).getInvisibilityIntensityChangeType(iI);
			}
			if (iSpotIntensityChange != 0)
			{
				szBuffer.append(pcNewline);
				szBuffer.append(gDLL->getText("TXT_KEY_PROMOHELP_INVISIBILITY_SPOT_CHANGE", iSpotIntensityChange, GC.getInvisibleInfo((InvisibleTypes)iI).getChar()));
			}
			if (iSpotIntensityRangeChange != 0)
			{
				szBuffer.append(pcNewline);
				szBuffer.append(gDLL->getText("TXT_KEY_PROMOHELP_INVISIBILITY_SPOT_RANGE_CHANGE", iSpotIntensityRangeChange, GC.getInvisibleInfo((InvisibleTypes)iI).getChar()));
			}
			if (iInvisibilityIntensityChange != 0)
			{
				szBuffer.append(pcNewline);
				szBuffer.append(gDLL->getText("TXT_KEY_PROMOHELP_INVISIBILITY_VEIL_INTENSITY_CHANGE", iInvisibilityIntensityChange, GC.getInvisibleInfo((InvisibleTypes)iI).getChar()));
			}
			iSpotIntensityChange = 0;
			iSpotIntensityRangeChange = 0;
			iInvisibilityIntensityChange = 0;
			for (int iK = 0; iK < GC.getNumTerrainInfos(); iK++)
			{
				for(int iJ = 0; iJ < (int)linePromotionsOwned.size(); iJ++)
				{
					for (int iL = 0; iL < GC.getPromotionInfo(linePromotionsOwned[iJ]).getNumInvisibleTerrainChanges(); iL++)
					{
						if (GC.getPromotionInfo(linePromotionsOwned[iJ]).getInvisibleTerrainChange(iL).eInvisible == ((InvisibleTypes)iI) &&
							GC.getPromotionInfo(linePromotionsOwned[iJ]).getInvisibleTerrainChange(iL).eTerrain == ((TerrainTypes)iK))
						{
							iInvisibleTerrainChange += GC.getPromotionInfo(linePromotionsOwned[iJ]).getInvisibleTerrainChange(iL).iIntensity;
						}
					}
					for (int iL = 0; iL < GC.getPromotionInfo(linePromotionsOwned[iJ]).getNumVisibleTerrainChanges(); iL++)
					{
						if (GC.getPromotionInfo(linePromotionsOwned[iJ]).getVisibleTerrainChange(iL).eInvisible == ((InvisibleTypes)iI) &&
							GC.getPromotionInfo(linePromotionsOwned[iJ]).getVisibleTerrainChange(iL).eTerrain == ((TerrainTypes)iK))
						{
							iVisibleTerrainChange += GC.getPromotionInfo(linePromotionsOwned[iJ]).getVisibleTerrainChange(iL).iIntensity;
						}
					}
					for (int iL = 0; iL < GC.getPromotionInfo(linePromotionsOwned[iJ]).getNumVisibleTerrainRangeChanges(); iL++)
					{
						if (GC.getPromotionInfo(linePromotionsOwned[iJ]).getVisibleTerrainRangeChange(iL).eInvisible == ((InvisibleTypes)iI) &&
							GC.getPromotionInfo(linePromotionsOwned[iJ]).getVisibleTerrainRangeChange(iL).eTerrain == ((TerrainTypes)iK))
						{
							iVisibleTerrainRangeChange += GC.getPromotionInfo(linePromotionsOwned[iJ]).getVisibleTerrainRangeChange(iL).iIntensity;
						}
					}
				}
				if (iInvisibleTerrainChange != 0)
				{
					szBuffer.append(pcNewline);
					szBuffer.append(gDLL->getText("TXT_KEY_PROMOHELP_INVISIBILITY_VEIL_PLOT_CHANGE", iInvisibleTerrainChange, GC.getInvisibleInfo((InvisibleTypes)iI).getChar(), GC.getTerrainInfo((TerrainTypes)iK).getTextKeyWide()));
				}
				if (iVisibleTerrainChange != 0)
				{
					szBuffer.append(pcNewline);
					szBuffer.append(gDLL->getText("TXT_KEY_PROMOHELP_INVISIBILITY_SPOT_PLOT_CHANGE", iVisibleTerrainChange, GC.getInvisibleInfo((InvisibleTypes)iI).getChar(), GC.getTerrainInfo((TerrainTypes)iK).getTextKeyWide()));
				}
				if (iVisibleTerrainRangeChange != 0)
				{
					szBuffer.append(pcNewline);
					szBuffer.append(gDLL->getText("TXT_KEY_PROMOHELP_INVISIBILITY_SPOT_PLOT_RANGE_CHANGE", iVisibleTerrainRangeChange, GC.getInvisibleInfo((InvisibleTypes)iI).getChar(), GC.getTerrainInfo((TerrainTypes)iK).getTextKeyWide()));
				}
				iInvisibleTerrainChange = 0;
				iVisibleTerrainChange = 0;
				iVisibleTerrainRangeChange = 0;
			}
			for (int iK = 0; iK < GC.getNumFeatureInfos(); iK++)
			{
				for(int iJ = 0; iJ < (int)linePromotionsOwned.size(); iJ++)
				{
					for (int iL = 0; iL < GC.getPromotionInfo(linePromotionsOwned[iJ]).getNumInvisibleFeatureChanges(); iL++)
					{
						if (GC.getPromotionInfo(linePromotionsOwned[iJ]).getInvisibleFeatureChange(iL).eInvisible == ((InvisibleTypes)iI) &&
							GC.getPromotionInfo(linePromotionsOwned[iJ]).getInvisibleFeatureChange(iL).eFeature == ((FeatureTypes)iK))
						{
							iInvisibleFeatureChange += GC.getPromotionInfo(linePromotionsOwned[iJ]).getInvisibleFeatureChange(iL).iIntensity;
						}
					}
					for (int iL = 0; iL < GC.getPromotionInfo(linePromotionsOwned[iJ]).getNumVisibleFeatureChanges(); iL++)
					{
						if (GC.getPromotionInfo(linePromotionsOwned[iJ]).getVisibleFeatureChange(iL).eInvisible == ((InvisibleTypes)iI) &&
							GC.getPromotionInfo(linePromotionsOwned[iJ]).getVisibleFeatureChange(iL).eFeature == ((FeatureTypes)iK))
						{
							iVisibleFeatureChange += GC.getPromotionInfo(linePromotionsOwned[iJ]).getVisibleFeatureChange(iL).iIntensity;
						}
					}
					for (int iL = 0; iL < GC.getPromotionInfo(linePromotionsOwned[iJ]).getNumVisibleFeatureRangeChanges(); iL++)
					{
						if (GC.getPromotionInfo(linePromotionsOwned[iJ]).getVisibleFeatureRangeChange(iL).eInvisible == ((InvisibleTypes)iI) &&
							GC.getPromotionInfo(linePromotionsOwned[iJ]).getVisibleFeatureRangeChange(iL).eFeature == ((FeatureTypes)iK))
						{
							iVisibleFeatureRangeChange += GC.getPromotionInfo(linePromotionsOwned[iJ]).getVisibleFeatureRangeChange(iL).iIntensity;
						}
					}
				}
				if (iInvisibleFeatureChange != 0)
				{
					szBuffer.append(pcNewline);
					szBuffer.append(gDLL->getText("TXT_KEY_PROMOHELP_INVISIBILITY_VEIL_PLOT_CHANGE", iInvisibleFeatureChange, GC.getInvisibleInfo((InvisibleTypes)iI).getChar(), GC.getFeatureInfo((FeatureTypes)iK).getTextKeyWide()));
				}
				if (iVisibleFeatureChange != 0)
				{
					szBuffer.append(pcNewline);
					szBuffer.append(gDLL->getText("TXT_KEY_PROMOHELP_INVISIBILITY_SPOT_PLOT_CHANGE", iVisibleFeatureChange, GC.getInvisibleInfo((InvisibleTypes)iI).getChar(), GC.getFeatureInfo((FeatureTypes)iK).getTextKeyWide()));
				}
				if (iVisibleFeatureRangeChange != 0)
				{
					szBuffer.append(pcNewline);
					szBuffer.append(gDLL->getText("TXT_KEY_PROMOHELP_INVISIBILITY_SPOT_PLOT_RANGE_CHANGE", iVisibleFeatureRangeChange, GC.getInvisibleInfo((InvisibleTypes)iI).getChar(), GC.getFeatureInfo((FeatureTypes)iK).getTextKeyWide()));
				}
				iInvisibleFeatureChange = 0;
				iVisibleFeatureChange = 0;
				iVisibleFeatureRangeChange = 0;
			}
			for (int iK = 0; iK < GC.getNumImprovementInfos(); iK++)
			{
				for(int iJ = 0; iJ < (int)linePromotionsOwned.size(); iJ++)
				{
					for (int iL = 0; iL < GC.getPromotionInfo(linePromotionsOwned[iJ]).getNumInvisibleImprovementChanges(); iL++)
					{
						if (GC.getPromotionInfo(linePromotionsOwned[iJ]).getInvisibleImprovementChange(iL).eInvisible == ((InvisibleTypes)iI) &&
							GC.getPromotionInfo(linePromotionsOwned[iJ]).getInvisibleImprovementChange(iL).eImprovement == ((ImprovementTypes)iK))
						{
							iInvisibleImprovementChange += GC.getPromotionInfo(linePromotionsOwned[iJ]).getInvisibleImprovementChange(iL).iIntensity;
						}
					}
					for (int iL = 0; iL < GC.getPromotionInfo(linePromotionsOwned[iJ]).getNumVisibleImprovementChanges(); iL++)
					{
						if (GC.getPromotionInfo(linePromotionsOwned[iJ]).getVisibleImprovementChange(iL).eInvisible == ((InvisibleTypes)iI) &&
							GC.getPromotionInfo(linePromotionsOwned[iJ]).getVisibleImprovementChange(iL).eImprovement == ((ImprovementTypes)iK))
						{
							iVisibleImprovementChange += GC.getPromotionInfo(linePromotionsOwned[iJ]).getVisibleImprovementChange(iL).iIntensity;
						}
					}
					for (int iL = 0; iL < GC.getPromotionInfo(linePromotionsOwned[iJ]).getNumVisibleImprovementRangeChanges(); iL++)
					{
						if (GC.getPromotionInfo(linePromotionsOwned[iJ]).getVisibleImprovementRangeChange(iL).eInvisible == ((InvisibleTypes)iI) &&
							GC.getPromotionInfo(linePromotionsOwned[iJ]).getVisibleImprovementRangeChange(iL).eImprovement == ((ImprovementTypes)iK))
						{
							iVisibleImprovementRangeChange += GC.getPromotionInfo(linePromotionsOwned[iJ]).getVisibleImprovementRangeChange(iL).iIntensity;
						}
					}
				}
				if (iInvisibleImprovementChange != 0)
				{
					szBuffer.append(pcNewline);
					szBuffer.append(gDLL->getText("TXT_KEY_PROMOHELP_INVISIBILITY_VEIL_PLOT_CHANGE", iInvisibleImprovementChange, GC.getInvisibleInfo((InvisibleTypes)iI).getChar(), GC.getImprovementInfo((ImprovementTypes)iK).getTextKeyWide()));
				}
				if (iVisibleImprovementChange != 0)
				{
					szBuffer.append(pcNewline);
					szBuffer.append(gDLL->getText("TXT_KEY_PROMOHELP_INVISIBILITY_SPOT_PLOT_CHANGE", iVisibleImprovementChange, GC.getInvisibleInfo((InvisibleTypes)iI).getChar(), GC.getImprovementInfo((ImprovementTypes)iK).getTextKeyWide()));
				}
				if (iVisibleImprovementRangeChange != 0)
				{
					szBuffer.append(pcNewline);
					szBuffer.append(gDLL->getText("TXT_KEY_PROMOHELP_INVISIBILITY_SPOT_PLOT_RANGE_CHANGE", iVisibleImprovementRangeChange, GC.getInvisibleInfo((InvisibleTypes)iI).getChar(), GC.getImprovementInfo((ImprovementTypes)iK).getTextKeyWide()));
				}
				iInvisibleImprovementChange = 0;
				iVisibleImprovementChange = 0;
				iVisibleImprovementRangeChange = 0;
			}
		}
	}

	// AIAndy: Help display for increasing specific outcomes
	for (int iI = 0; iI < GC.getNumOutcomeInfos(); iI++)
	{
		const CvOutcomeInfo& kOutcome = GC.getOutcomeInfo((OutcomeTypes)iI);

		int iExtraChancePromotion = 0;
		for(int iJ = 0; iJ < (int)linePromotionsOwned.size(); iJ++ )
		{
			for (int iK = 0; iK < kOutcome.getNumExtraChancePromotions(); iK++)
			{
				if (kOutcome.getExtraChancePromotion(iK) == linePromotionsOwned[iJ])
				{
					iExtraChancePromotion += kOutcome.getExtraChancePromotionChance(iK);
				}
			}
		}
		if (iExtraChancePromotion != 0)
		{
			szBuffer.append(pcNewline);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_OUTCOME", iExtraChancePromotion, CvWString(kOutcome.getType()).GetCString(), kOutcome.getTextKeyWide()));
		}
	}

	//	This bit won't look terribly pretty - needs a little more work
	for(int iI = 0; iI < (int)linePromotionsOwned.size(); iI++ )
	{
		GC.getPromotionInfo(linePromotionsOwned[iI]).getPropertyManipulators()->buildDisplayString(szBuffer);
	}

	if (promo.getLevelPrereq() > 0)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_LEVEL_PREREQ", promo.getLevelPrereq()));
	}

	if (bDefWarning)
	{
		szBuffer.append(pcNewline);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_DEF_WARN"));
	}

	if (promo.getHelp()[0] != '\0')
	{
		szBuffer.append(pcNewline);
		szBuffer.append(promo.getHelp());
	}
}

//	Function:			parseCivicInfo()
//	Description:	Will parse the civic info help
//	Parameters:		szHelpText -- the text to put it into
//								civicInfo - what to parse
//	Returns:			nothing
void CvGameTextMgr::parseCivicInfo(CvWStringBuffer &szHelpText, CivicTypes eCivic, bool bCivilopediaText, bool bPlayerContext, bool bSkipName)
{
	PROFILE_FUNC();

	if (NO_CIVIC == eCivic)
	{
		return;
	}
	szHelpText.clear();

	FAssert(GC.getGame().getActivePlayer() != NO_PLAYER || !bPlayerContext);

	const CvCivicInfo& kCivic = GC.getCivicInfo(eCivic);

	if (!bSkipName)
	{
		szHelpText.append(kCivic.getDescription());
	}

	if (!bCivilopediaText
	&& (!bPlayerContext || !GET_PLAYER(GC.getGame().getActivePlayer()).canDoCivics(eCivic) && !GET_TEAM(GC.getGame().getActiveTeam()).isHasTech(kCivic.getTechPrereq()))
	&& kCivic.getTechPrereq() != NO_TECH)
	{
		szHelpText.append(NEWLINE);
		szHelpText.append(gDLL->getText("TXT_KEY_REQUIRES_LINK", CvWString(GC.getTechInfo(kCivic.getTechPrereq()).getType()).c_str(), GC.getTechInfo(kCivic.getTechPrereq()).getTextKeyWide()));
	}

	// Special Building Not Required...
	for (int iI = 0; iI < GC.getNumSpecialBuildingInfos(); ++iI)
	{
		if (kCivic.isSpecialBuildingNotRequired(iI))
		{
			szHelpText.append(NEWLINE);
			szHelpText.append(gDLL->getText("TXT_KEY_CIVICHELP_BUILD_MISSIONARIES", GC.getSpecialBuildingInfo((SpecialBuildingTypes)iI).getTextKeyWide()));
		}
	}
	if (kCivic.IsFixedBorders() && GC.getGame().isOption(GAMEOPTION_CULTURE_FIXED_BORDERS))
	{
		szHelpText.append(NEWLINE);
		szHelpText.append(gDLL->getText("TXT_KEY_FIXED_BORDERS_CIVIC"));
	}

	// Valid Specialists...
	CvWString szFirstBuffer;
	bool bFirst = true;

	for (int iI = 0; iI < GC.getNumSpecialistInfos(); ++iI)
	{
		if (kCivic.isSpecialistValid(iI))
		{
			szFirstBuffer.Format(L"%s%s", NEWLINE, gDLL->getText("TXT_KEY_CIVICHELP_UNLIMTED").c_str());
			CvWString szSpecialist;
			szSpecialist.Format(L"<link=%s>%s</link>", CvWString(GC.getSpecialistInfo((SpecialistTypes)iI).getType()).GetCString(), GC.getSpecialistInfo((SpecialistTypes)iI).getDescription());
			setListHelp(szHelpText, szFirstBuffer, szSpecialist, L", ", bFirst);
			bFirst = false;
		}
	}

	//	Great People Modifier...
	if (kCivic.getGreatPeopleRateModifier() != 0)
	{
		szHelpText.append(NEWLINE);
		szHelpText.append(gDLL->getText("TXT_KEY_CIVICHELP_GREAT_PEOPLE_MOD", kCivic.getGreatPeopleRateModifier()));
	}

	//	Great General Modifier...
	if (kCivic.getGreatGeneralRateModifier() != 0)
	{
		szHelpText.append(NEWLINE);
		szHelpText.append(gDLL->getText("TXT_KEY_CIVICHELP_GREAT_GENERAL_MOD", kCivic.getGreatGeneralRateModifier()));
	}

	if (kCivic.getDomesticGreatGeneralRateModifier() != 0)
	{
		szHelpText.append(NEWLINE);
		szHelpText.append(gDLL->getText("TXT_KEY_DOMESTIC_GREAT_GENERAL_MODIFIER", kCivic.getDomesticGreatGeneralRateModifier()));
	}

	//	State Religion Great People Modifier...
	if (kCivic.getStateReligionGreatPeopleRateModifier() != 0)
	{
		if (bPlayerContext && (GET_PLAYER(GC.getGame().getActivePlayer()).getStateReligion() != NO_RELIGION))
		{
			szHelpText.append(NEWLINE);
			szHelpText.append(gDLL->getText("TXT_KEY_CIVICHELP_GREAT_PEOPLE_MOD_RELIGION", kCivic.getStateReligionGreatPeopleRateModifier(), GC.getReligionInfo(GET_PLAYER(GC.getGame().getActivePlayer()).getStateReligion()).getChar()));
		}
		else
		{
			szHelpText.append(NEWLINE);
			szHelpText.append(gDLL->getText("TXT_KEY_CIVICHELP_GREAT_PEOPLE_MOD_STATE_RELIGION", kCivic.getStateReligionGreatPeopleRateModifier(), gDLL->getSymbolID(RELIGION_CHAR)));
		}
	}

	//	Distance Maintenance Modifer...
	if (kCivic.getDistanceMaintenanceModifier() != 0)
	{
		szHelpText.append(NEWLINE);
		szHelpText.append(gDLL->getText("TXT_KEY_CIVICHELP_DISTANCE_MAINT_MOD", kCivic.getDistanceMaintenanceModifier()));

		//Afforess: Actual civic effects
		if (bPlayerContext)
		{
			CvWString szTempBuffer;
			int iSaved = 0;
			foreach_(const CvCity* pLoopCity, GET_PLAYER(GC.getGame().getActivePlayer()).cities())
			{
				iSaved += pLoopCity->getDistanceMaintenanceSavedTimes100ByCivic(eCivic);
			}
			if (iSaved != 0)
			{
				szTempBuffer.Format(L" (%.2f %c)", (float)iSaved / 100, GC.getCommerceInfo(COMMERCE_GOLD).getChar());
				szHelpText.append(szTempBuffer.GetCString());
			}
		}
	}

	//	Num Cities Maintenance Modifer...
	if (kCivic.getNumCitiesMaintenanceModifier() != 0)
	{
		szHelpText.append(NEWLINE);
		szHelpText.append(gDLL->getText("TXT_KEY_CIVICHELP_NO_MAINT_NUM_CITIES_MOD", kCivic.getNumCitiesMaintenanceModifier()));

		//Afforess: Actual civic effects
		if (bPlayerContext)
		{
			CvWString szTempBuffer;
			int iSaved = 0;
			foreach_(const CvCity* pLoopCity, GET_PLAYER(GC.getGame().getActivePlayer()).cities())
			{
				iSaved += pLoopCity->getNumCitiesMaintenanceSavedTimes100ByCivic(eCivic);
			}
			if (iSaved != 0)
			{
				szTempBuffer.Format(L" (%.2f %c)", (float)iSaved / 100, GC.getCommerceInfo(COMMERCE_GOLD).getChar());
				szHelpText.append(szTempBuffer.GetCString());
			}
		}
	}

	if (kCivic.getCorporationMaintenanceModifier() != 0)
	{
		// Corporations Maintenance Modifer...
		szHelpText.append(NEWLINE);
		szHelpText.append(gDLL->getText("TXT_KEY_CIVICHELP_NO_MAINT_CORPORATION_MOD", kCivic.getCorporationMaintenanceModifier()));
	}

	if (kCivic.getHomeAreaMaintenanceModifier() != 0)
	{
		szHelpText.append(NEWLINE);
		if (kCivic.getHomeAreaMaintenanceModifier() <= -100)
		{
			szHelpText.append(gDLL->getText("TXT_KEY_CIVICHELP_HOME_AREA_MAINT"));
		}
		else
		{
			szHelpText.append(gDLL->getText("TXT_KEY_CIVICHELP_HOME_AREA_MAINT_MOD", kCivic.getHomeAreaMaintenanceModifier()));
		}
		//Afforess: Actual civic effects
		if (bPlayerContext)
		{
			CvWString szTempBuffer;
			int iSaved = 0;
			foreach_(const CvCity* pLoopCity, GET_PLAYER(GC.getGame().getActivePlayer()).cities())
			{
				iSaved += pLoopCity->getHomeAreaMaintenanceSavedTimes100ByCivic(eCivic);
			}
			if (iSaved != 0)
			{
				szTempBuffer.Format(L" (%.2f %c)", (float)iSaved / 100, GC.getCommerceInfo(COMMERCE_GOLD).getChar());
				szHelpText.append(szTempBuffer.GetCString());
			}
		}
	}
	if (kCivic.getOtherAreaMaintenanceModifier() != 0)
	{
		szHelpText.append(NEWLINE);
		if (kCivic.getOtherAreaMaintenanceModifier() <= -100)
		{
			szHelpText.append(gDLL->getText("TXT_KEY_OVERSEAS_CITY_MAINT"));
		}
		else
		{
			szHelpText.append(gDLL->getText("TXT_KEY_OVERSEAS_CITY_MAINT_MOD", kCivic.getOtherAreaMaintenanceModifier()));
		}
		//Afforess: Actual civic effects
		if (bPlayerContext)
		{
			CvWString szTempBuffer;
			int iSaved = 0;
			foreach_(const CvCity* pLoopCity, GET_PLAYER(GC.getGame().getActivePlayer()).cities())
			{
				iSaved += pLoopCity->getOtherAreaMaintenanceSavedTimes100ByCivic(eCivic);
			}
			if (iSaved != 0)
			{
				szTempBuffer.Format(L" (%.2f %c)", (float)iSaved / 100, GC.getCommerceInfo(COMMERCE_GOLD).getChar());
				szHelpText.append(szTempBuffer.GetCString());
			}
		}
	}
	//DPII < Maintenance Modifiers >
	//	Extra Health
	if (kCivic.getExtraHealth() != 0)
	{
		szHelpText.append(NEWLINE);
		szHelpText.append(gDLL->getText("TXT_KEY_CIVICHELP_EXTRA_HEALTH", abs(kCivic.getExtraHealth()), ((kCivic.getExtraHealth() > 0) ? gDLL->getSymbolID(HEALTHY_CHAR): gDLL->getSymbolID(UNHEALTHY_CHAR))));
	}

	//	Free Experience
	if (kCivic.getFreeExperience() != 0)
	{
		szHelpText.append(NEWLINE);
		szHelpText.append(gDLL->getText("TXT_KEY_CIVICHELP_FREE_XP", kCivic.getFreeExperience()));
	}

	//	Worker speed modifier
	if (kCivic.getWorkerSpeedModifier() != 0)
	{
		szHelpText.append(NEWLINE);
		szHelpText.append(gDLL->getText("TXT_KEY_CIVICHELP_WORKER_SPEED", kCivic.getWorkerSpeedModifier()));
	}

	//	Improvement upgrade rate modifier
	if (kCivic.getImprovementUpgradeRateModifier() != 0)
	{
		szHelpText.append(NEWLINE);
		szHelpText.append(gDLL->getText("TXT_KEY_CIVICHELP_IMPROVEMENT_UPGRADE", kCivic.getImprovementUpgradeRateModifier()));
	}

	//	Military unit production modifier
	if (kCivic.getMilitaryProductionModifier() != 0)
	{
		szHelpText.append(NEWLINE);
		szHelpText.append(gDLL->getText("TXT_KEY_CIVICHELP_MILITARY_PRODUCTION", kCivic.getMilitaryProductionModifier()));
	}

	// Free Civilian unit upkeep
	if (kCivic.getFreeUnitUpkeepCivilian() != 0)
	{
		szHelpText.append(NEWLINE);
		szHelpText.append(gDLL->getText("TXT_KEY_HELPTEXT_UNIT_UPKEEP_FREE_CIVILIAN", kCivic.getFreeUnitUpkeepCivilian()));
	}
	if (kCivic.getFreeUnitUpkeepCivilianPopPercent() != 0)
	{
		if (bPlayerContext)
		{
			int iValue = 0;
			int iMod = kCivic.getFreeUnitUpkeepCivilianPopPercent();
			if (iMod > 0)
			{
				iValue = GET_PLAYER(GC.getGame().getActivePlayer()).getTotalPopulation() * (100 + iMod);
			}
			else if (iMod < 0)
			{
				iValue =
					GET_PLAYER(GC.getGame().getActivePlayer()).getTotalPopulation() -
					GET_PLAYER(GC.getGame().getActivePlayer()).getTotalPopulation() * 100 / (100 - iMod);
			}
			szHelpText.append(NEWLINE);
			szHelpText.append(gDLL->getText("TXT_KEY_HELPTEXT_UNIT_UPKEEP_FREE_CIVILIAN_PER_POP", iMod));
			szHelpText.append(gDLL->getText("TXT_KEY_HELPTEXT_UNIT_UPKEEP_FREE_PER_POP", CvWString::format(L"%.2f", iValue / 100.0).GetCString()));
		}
		else
		{
			szHelpText.append(NEWLINE);
			szHelpText.append(gDLL->getText("TXT_KEY_HELPTEXT_UNIT_UPKEEP_FREE_CIVILIAN_PER_POP", kCivic.getFreeUnitUpkeepCivilianPopPercent()));
		}
	}
	// Free Military unit upkeep
	if (kCivic.getFreeUnitUpkeepMilitary() != 0)
	{
		szHelpText.append(NEWLINE);
		szHelpText.append(gDLL->getText("TXT_KEY_HELPTEXT_UNIT_UPKEEP_FREE_MILITARY", kCivic.getFreeUnitUpkeepMilitary()));
	}
	if (kCivic.getFreeUnitUpkeepMilitaryPopPercent() != 0)
	{
		if (bPlayerContext)
		{
			int iValue = 0;
			int iMod = kCivic.getFreeUnitUpkeepMilitaryPopPercent();
			if (iMod > 0)
			{
				iValue = GET_PLAYER(GC.getGame().getActivePlayer()).getTotalPopulation() * (100 + iMod);
			}
			else if (iMod < 0)
			{
				iValue =
					GET_PLAYER(GC.getGame().getActivePlayer()).getTotalPopulation() -
					GET_PLAYER(GC.getGame().getActivePlayer()).getTotalPopulation() * 100 / (100 - iMod);
			}
			szHelpText.append(NEWLINE);
			szHelpText.append(gDLL->getText("TXT_KEY_HELPTEXT_UNIT_UPKEEP_FREE_MILITARY_PER_POP",  iMod));
			szHelpText.append(gDLL->getText("TXT_KEY_HELPTEXT_UNIT_UPKEEP_FREE_PER_POP", CvWString::format(L"%.2f", iValue / 100.0).GetCString()));
		}
		else
		{
			szHelpText.append(NEWLINE);
			szHelpText.append(gDLL->getText("TXT_KEY_HELPTEXT_UNIT_UPKEEP_FREE_MILITARY_PER_POP", kCivic.getFreeUnitUpkeepMilitaryPopPercent()));
		}
	}

	//	Happiness per military unit
	if (kCivic.getHappyPerMilitaryUnit() != 0)
	{
		szHelpText.append(NEWLINE);
		szHelpText.append(gDLL->getText("TXT_KEY_CIVICHELP_UNIT_HAPPINESS", abs(kCivic.getHappyPerMilitaryUnit()), ((kCivic.getHappyPerMilitaryUnit() > 0) ? gDLL->getSymbolID(HAPPY_CHAR) : gDLL->getSymbolID(UNHAPPY_CHAR))));
	}

	//	Military units produced with food
	if (kCivic.isMilitaryFoodProduction())
	{
		szHelpText.append(NEWLINE);
		szHelpText.append(gDLL->getText("TXT_KEY_CIVICHELP_MILITARY_FOOD"));
	}

	//	Conscription
	if (getWorldSizeMaxConscript(eCivic) != 0)
	{
		szHelpText.append(NEWLINE);
		szHelpText.append(gDLL->getText("TXT_KEY_CIVIC_CONSCRIPTION", getWorldSizeMaxConscript(eCivic)));
	}

	//	Population Unhealthiness
	if (kCivic.isNoUnhealthyPopulation())
	{
		szHelpText.append(NEWLINE);
		szHelpText.append(gDLL->getText("TXT_KEY_CIVICHELP_NO_POP_UNHEALTHY"));
	}

	//	Building Unhealthiness
	if (kCivic.isBuildingOnlyHealthy())
	{
		szHelpText.append(NEWLINE);
		szHelpText.append(gDLL->getText("TXT_KEY_CIVICHELP_NO_BUILDING_UNHEALTHY"));
	}

	//	Population Unhealthiness
	if (0 != kCivic.getExpInBorderModifier())
	{
		szHelpText.append(NEWLINE);
		szHelpText.append(gDLL->getText("TXT_KEY_CIVICHELP_EXPERIENCE_IN_BORDERS", kCivic.getExpInBorderModifier()));
	}

	if (kCivic.isUpgradeAnywhere())
	{
		szHelpText.append(NEWLINE);
		szHelpText.append(gDLL->getText("TXT_KEY_CAN_UPGRADE_ANYWHERE"));
	}

	if (GC.getGame().isOption(GAMEOPTION_RELIGION_INQUISITIONS))
	{
		if (kCivic.isAllowInquisitions())
		{
			szHelpText.append(NEWLINE);
			szHelpText.append(gDLL->getText("TXT_KEY_CIVICHELP_ALLOW_INQUISITONS"));
		}
	}

	if (GC.getGame().isOption(GAMEOPTION_RELIGION_INQUISITIONS))
	{
		if (kCivic.isDisallowInquisitions())
		{
			szHelpText.append(NEWLINE);
			szHelpText.append(gDLL->getText("TXT_KEY_CIVICHELP_DISALLOW_INQUISITONS"));
		}
	}

	//Team Project (5)
	if (GC.getGame().isOption(GAMEOPTION_RELIGION_DISABLING))
	{
		// All Religions active
		if (kCivic.isAllReligionsActive())
		{
			szHelpText.append(NEWLINE);
			szHelpText.append(gDLL->getText("TXT_KEY_ALL_RELIGIONS_ACTIVE"));
		}
		if (kCivic.isBansNonStateReligions())
		{
			szHelpText.append(NEWLINE);
			szHelpText.append(gDLL->getText("TXT_KEY_BANS_NON_STATE_RELIGIONS"));
		}
	}

	if (kCivic.isFreedomFighter())
	{
		szHelpText.append(NEWLINE);
		szHelpText.append(gDLL->getText("TXT_KEY_FREEDOM_FIGHTER"));
	}

	//Capture Probabilities
	if (kCivic.getNationalCaptureProbabilityModifier() != 0)
	{
		szHelpText.append(NEWLINE);
		szHelpText.append(gDLL->getText("TXT_KEY_NATIONAL_CAPTURE_PROBABILITY_MODIFIER", kCivic.getNationalCaptureProbabilityModifier()));
	}
	if (kCivic.getNationalCaptureResistanceModifier() != 0)
	{
		szHelpText.append(NEWLINE);
		szHelpText.append(gDLL->getText("TXT_KEY_NATIONAL_CAPTURE_RESISTANCE_MODIFIER", kCivic.getNationalCaptureResistanceModifier()));
	}

	if (GC.getGame().isOption(GAMEOPTION_UNSUPPORTED_REVOLUTION))
	{
		if (GC.getGame().getActivePlayer() != NO_PLAYER && GET_PLAYER(GC.getGame().getActivePlayer()).isModderOption(MODDEROPTION_SHOW_REV_EFFECTS))
		{
			//  Revolution Local Civic Index Modifiers
			if (0 != kCivic.getRevIdxLocal())
			{
				if (kCivic.getRevIdxLocal() > 0)
				{
					szHelpText.append(NEWLINE);
					szHelpText.append(gDLL->getText("TXT_KEY_CIVICHELP_REV_INDEX_LOCAL_PENALTY", kCivic.getRevIdxLocal()));
				}
				if (kCivic.getRevIdxLocal() < 0)
				{
					szHelpText.append(NEWLINE);
					szHelpText.append(gDLL->getText("TXT_KEY_CIVICHELP_REV_INDEX_LOCAL_BONUS", abs(kCivic.getRevIdxLocal())));
				}
			}

			//  Revolution National Civic Index Modifiers
			if (0 != kCivic.getRevIdxNational())
			{
				if (kCivic.getRevIdxNational() > 0)
				{
					szHelpText.append(NEWLINE);
					szHelpText.append(gDLL->getText("TXT_KEY_CIVICHELP_REV_INDEX_NATIONAL_PENALTY", kCivic.getRevIdxNational()));
				}
				if (kCivic.getRevIdxNational() < 0)
				{
					szHelpText.append(NEWLINE);
					szHelpText.append(gDLL->getText("TXT_KEY_CIVICHELP_REV_INDEX_NATIONAL_BONUS", abs(kCivic.getRevIdxNational())));
				}
			}

			//  Revolution Good Holy City Modifier
			if (0 != kCivic.getRevIdxHolyCityGood())
			{
				szHelpText.append(NEWLINE);
				szHelpText.append(gDLL->getText("TXT_KEY_CIVICHELP_REV_GOOD_HOLY_CITY", kCivic.getRevIdxHolyCityGood()));
			}

			//  Revolution Bad Holy City Modifier
			if (0 != kCivic.getRevIdxHolyCityBad())
			{
				szHelpText.append(NEWLINE);
				szHelpText.append(gDLL->getText("TXT_KEY_CIVICHELP_REV_BAD_HOLY_CITY", kCivic.getRevIdxHolyCityBad()));
			}

			//  Revolution Switch to Modifier
			if (0 != kCivic.getRevIdxSwitchTo())
			{
				if (kCivic.getRevIdxSwitchTo() < 0)
				{
					szHelpText.append(NEWLINE);
					szHelpText.append(gDLL->getText("TXT_KEY_CIVICHELP_REV_SWITCH_TO_BONUS", abs(kCivic.getRevIdxSwitchTo())));
				}
				if (kCivic.getRevIdxSwitchTo() > 0)
				{
					szHelpText.append(NEWLINE);
					szHelpText.append(gDLL->getText("TXT_KEY_CIVICHELP_REV_SWITCH_TO_PENALTY", kCivic.getRevIdxSwitchTo()));
				}
			}

			//  Revolution Nationality Modifier
			if (0 != kCivic.getRevIdxNationalityMod())
			{
				if (kCivic.getRevIdxNationalityMod() < 0)
				{
					szHelpText.append(NEWLINE);
					CvWString szTempBuffer;
					szTempBuffer.Format(L"%.0f", 100 * kCivic.getRevIdxNationalityMod());
					szHelpText.append(gDLL->getText("TXT_KEY_CIVICHELP_REV_NATIONALITY_REDUCTION_MOD", szTempBuffer.GetCString()));
				}
				if (kCivic.getRevIdxNationalityMod() > 0)
				{
					szHelpText.append(NEWLINE);
					CvWString szTempBuffer;
					szTempBuffer.Format(L"%.0f", 100 * kCivic.getRevIdxNationalityMod());
					szHelpText.append(gDLL->getText("TXT_KEY_CIVICHELP_REV_NATIONALITY_INCREASE_MOD", szTempBuffer.GetCString()));
				}
			}

			//  Revolution Bad Religion Modifier
			if (0 != kCivic.getRevIdxBadReligionMod())
			{
				szHelpText.append(NEWLINE);
				CvWString szTempBuffer;
				szTempBuffer.Format(L"%.0f", 100 * kCivic.getRevIdxBadReligionMod());
				szHelpText.append(gDLL->getText("TXT_KEY_CIVICHELP_REV_BAD_RELIGION_MOD", szTempBuffer.GetCString()));
			}

			//  Revolution Good Religion Modifier
			if (0 != kCivic.getRevIdxGoodReligionMod())
			{
				szHelpText.append(NEWLINE);
				CvWString szTempBuffer;
				szTempBuffer.Format(L"%.0f", 100 * kCivic.getRevIdxGoodReligionMod());
				szHelpText.append(gDLL->getText("TXT_KEY_CIVICHELP_REV_GOOD_RELIGION_MOD", szTempBuffer.GetCString()));
			}

			//  Revolution City Distance Modifier
			if (0 != kCivic.getRevIdxDistanceModifier())
			{
				if (kCivic.getRevIdxDistanceModifier() < 0)
				{
					szHelpText.append(NEWLINE);
					szHelpText.append(gDLL->getText("TXT_KEY_CIVICHELP_CITY_DISTANCE_GOOD_MOD", kCivic.getRevIdxDistanceModifier()));
				}
				if (kCivic.getRevIdxDistanceModifier() > 0)
				{
					szHelpText.append(NEWLINE);
					szHelpText.append(gDLL->getText("TXT_KEY_CIVICHELP_CITY_DISTANCE_BAD_MOD", abs(kCivic.getRevIdxDistanceModifier())));
				}
			}

			if (0 != kCivic.getRevReligiousFreedom())
			{
				if (kCivic.getRevReligiousFreedom() < 0)
				{
					szHelpText.append(NEWLINE);
					szHelpText.append(gDLL->getText("TXT_KEY_CIVICHELP_REV_RELIGION_OPRESSION", kCivic.getRevReligiousFreedom()));
				}
				if (kCivic.getRevReligiousFreedom() > 0)
				{
					szHelpText.append(NEWLINE);
					szHelpText.append(gDLL->getText("TXT_KEY_CIVICHELP_REV_RELIGION_FREEDOM", kCivic.getRevReligiousFreedom()));
				}
			}

			//  Revolution Labor Modifier
			if (0 != kCivic.getRevLaborFreedom())
			{
				szHelpText.append(NEWLINE);
				szHelpText.append(gDLL->getText("TXT_KEY_CIVICHELP_REV_LABOR", kCivic.getRevLaborFreedom()));
			}

			//  Revolution Environment Modifier
			if (0 != kCivic.getRevEnvironmentalProtection())
			{
				szHelpText.append(NEWLINE);
				szHelpText.append(gDLL->getText("TXT_KEY_CIVICHELP_REV_ENVIRONMENT", kCivic.getRevEnvironmentalProtection()));
			}

			//  Revolution Democracy Modifier
			if (0 != kCivic.getRevDemocracyLevel())
			{
				szHelpText.append(NEWLINE);
				szHelpText.append(gDLL->getText("TXT_KEY_CIVICHELP_REV_DEMOCRACY", kCivic.getRevDemocracyLevel()));
			}
		}
		else
		{
			if (kCivic.getRevIdxLocal() > 0)
			{
				//szHelpText.append(NEWLINE);
				szHelpText.append(gDLL->getText("TXT_KEY_INCREASE_LOCAL_REBELS", kCivic.getRevIdxLocal()));
			}
			else if (kCivic.getRevIdxLocal() < 0)
			{
				//szHelpText.append(NEWLINE);
				szHelpText.append(gDLL->getText("TXT_KEY_DECREASE_LOCAL_REBELS", kCivic.getRevIdxLocal()));
			}
			if (kCivic.getRevIdxNational() > 0)
			{
				//szHelpText.append(NEWLINE);
				szHelpText.append(gDLL->getText("TXT_KEY_INCREASE_NATIONAL_REBELS", kCivic.getRevIdxNational()));
			}
			else if (kCivic.getRevIdxNational() < 0)
			{
				//szHelpText.append(NEWLINE);
				szHelpText.append(gDLL->getText("TXT_KEY_DECREASE_NATIONAL_REBELS", kCivic.getRevIdxNational()));
			}
			if (kCivic.getRevIdxHolyCityGood() > 0)
			{
				//szHelpText.append(NEWLINE);
				szHelpText.append(gDLL->getText("TXT_KEY_STATE_RELIGION_WITH_HOLY_CITY", kCivic.getRevIdxHolyCityGood()));
			}
			if (kCivic.getRevIdxHolyCityBad() > 0)
			{
				//szHelpText.append(NEWLINE);
				szHelpText.append(gDLL->getText("TXT_KEY_STATE_RELIGION_WITHOUT_HOLY_CITY", kCivic.getRevIdxHolyCityBad()));
			}
		}
	}
	// RevolutionDCM - End Revolution Civic Expose

	//	War Weariness
	if (kCivic.getWarWearinessModifier() != 0)
	{
		if (kCivic.getWarWearinessModifier() <= -100)
		{
			szHelpText.append(NEWLINE);
			szHelpText.append(gDLL->getText("TXT_KEY_CIVICHELP_NO_WAR_WEARINESS"));
		}
		else
		{
			szHelpText.append(NEWLINE);
			szHelpText.append(gDLL->getText("TXT_KEY_CIVICHELP_EXTRA_WAR_WEARINESS", kCivic.getWarWearinessModifier()));
		}
	}

	//	Free specialists
	if (kCivic.getFreeSpecialist() != 0)
	{
		szHelpText.append(NEWLINE);
		szHelpText.append(gDLL->getText("TXT_KEY_CIVICHELP_FREE_SPECIALISTS", kCivic.getFreeSpecialist()));
	}

	//	Trade routes
	if (kCivic.getTradeRoutes() != 0)
	{
		szHelpText.append(NEWLINE);
		szHelpText.append(gDLL->getText("TXT_KEY_CIVICHELP_TRADE_ROUTES", kCivic.getTradeRoutes()));
	}

	if (kCivic.getForeignTradeRouteModifier() != 0)
	{
		szHelpText.append(NEWLINE);
		szHelpText.append(gDLL->getText("TXT_KEY_CIVICHELP_FOREIGN_TRADE_ROUTE_MOD", kCivic.getForeignTradeRouteModifier()));
	}

	if (kCivic.getDistantUnitSupportCostModifier() > 0)
	{
		szHelpText.append(NEWLINE);
		szHelpText.append(gDLL->getText("TXT_KEY_CIVICHELP_DISTANT_UNIT_SUPPLY_COST_MOD", kCivic.getDistantUnitSupportCostModifier()));
	}

	else if (kCivic.getDistantUnitSupportCostModifier() < 0)
	{
		szHelpText.append(NEWLINE);
		szHelpText.append(gDLL->getText("TXT_KEY_CIVICHELP_DISTANT_UNIT_SUPPLY_COST_MOD_DECREASE", kCivic.getDistantUnitSupportCostModifier()));
	}

	if (kCivic.getExtraCityDefense() != 0)
	{
		szHelpText.append(NEWLINE);
		szHelpText.append(gDLL->getText("TXT_KEY_CIVICHELP_CITY_DEFENSE_MOD", kCivic.getExtraCityDefense()));
	}

	if (kCivic.getFreedomFighterChange() != 0)
	{
		szHelpText.append(NEWLINE);
		szHelpText.append(gDLL->getText("TXT_KEY_FREEDOM_FIGHTER_CHANGE", kCivic.getFreedomFighterChange()));
	}

	//	No Foreign Trade
	if (kCivic.isNoForeignTrade())
	{
		szHelpText.append(NEWLINE);
		szHelpText.append(gDLL->getText("TXT_KEY_CIVICHELP_NO_FOREIGN_TRADE"));
	}

	//	No Corporations
	if (kCivic.isNoCorporations())
	{
		szHelpText.append(NEWLINE);
		szHelpText.append(gDLL->getText("TXT_KEY_CIVICHELP_NO_CORPORATIONS"));
	}

	//	No Foreign Corporations
	if (kCivic.isNoForeignCorporations())
	{
		szHelpText.append(NEWLINE);
		szHelpText.append(gDLL->getText("TXT_KEY_CIVICHELP_NO_FOREIGN_CORPORATIONS"));

		if (GC.getGame().isOption(GAMEOPTION_ADVANCED_REALISTIC_CORPORATIONS))
		{
			szHelpText.append(NEWLINE);
			szHelpText.append(gDLL->getText("TXT_KEY_CIVICHELP_ALLOWS_USE_OF_EXECUTIVES"));
		}
	}

	int iValue = kCivic.getCivicPercentAnger();
	if (iValue != 0)
	{
		if (iValue > 0)
		{
			szHelpText.append(NEWLINE);
			szHelpText.append(gDLL->getText("TXT_KEY_CIVICHELP_FREEDOM_ANGER", iValue));
		}

		else
		{
			szHelpText.append(NEWLINE);
			szHelpText.append(gDLL->getText("TXT_KEY_CIVICHELP_FREEDOM_HAPPINESS", -iValue));
		}
	}

	if (!kCivic.isStateReligion())
	{
		for (int iI = 0; iI < GC.getNumCivicInfos(); ++iI)
		{
			if (GC.getCivicInfo((CivicTypes) iI).getCivicOptionType() == kCivic.getCivicOptionType() && GC.getCivicInfo((CivicTypes) iI).isStateReligion())
			{
				szHelpText.append(NEWLINE);
				szHelpText.append(gDLL->getText("TXT_KEY_CIVICHELP_NO_STATE_RELIGION"));
				break;
			}
		}
	}

	if (kCivic.getStateReligionHappiness() != 0)
	{
		if (bPlayerContext && (GET_PLAYER(GC.getGame().getActivePlayer()).getStateReligion() != NO_RELIGION))
		{
			szHelpText.append(NEWLINE);
			szHelpText.append(gDLL->getText("TXT_KEY_CIVICHELP_STATE_RELIGION_HAPPINESS", abs(kCivic.getStateReligionHappiness()), ((kCivic.getStateReligionHappiness() > 0) ? gDLL->getSymbolID(HAPPY_CHAR) : gDLL->getSymbolID(UNHAPPY_CHAR)), GC.getReligionInfo(GET_PLAYER(GC.getGame().getActivePlayer()).getStateReligion()).getChar()));
		}
		else
		{
			szHelpText.append(NEWLINE);
			szHelpText.append(gDLL->getText("TXT_KEY_CIVICHELP_RELIGION_HAPPINESS", abs(kCivic.getStateReligionHappiness()), ((kCivic.getStateReligionHappiness() > 0) ? gDLL->getSymbolID(HAPPY_CHAR) : gDLL->getSymbolID(UNHAPPY_CHAR))));
		}
	}

	if (kCivic.getNonStateReligionHappiness() != 0)
	{
		if (!kCivic.isStateReligion())
		{
			szHelpText.append(NEWLINE);
			szHelpText.append(gDLL->getText("TXT_KEY_CIVICHELP_NON_STATE_REL_HAPPINESS_NO_STATE", abs(kCivic.getNonStateReligionHappiness()), ((kCivic.getNonStateReligionHappiness() > 0) ? gDLL->getSymbolID(HAPPY_CHAR) : gDLL->getSymbolID(UNHAPPY_CHAR))));
		}
		else
		{
			szHelpText.append(NEWLINE);
			szHelpText.append(gDLL->getText("TXT_KEY_CIVICHELP_NON_STATE_REL_HAPPINESS_WITH_STATE", abs(kCivic.getNonStateReligionHappiness()), ((kCivic.getNonStateReligionHappiness() > 0) ? gDLL->getSymbolID(HAPPY_CHAR) : gDLL->getSymbolID(UNHAPPY_CHAR))));
		}
	}

	//	State Religion Unit Production Modifier
	if (kCivic.getStateReligionUnitProductionModifier() != 0)
	{
		if (bPlayerContext && (GET_PLAYER(GC.getGame().getActivePlayer()).getStateReligion() != NO_RELIGION))
		{
			szHelpText.append(NEWLINE);
			szHelpText.append(gDLL->getText("TXT_KEY_CIVICHELP_REL_TRAIN", GC.getReligionInfo(GET_PLAYER(GC.getGame().getActivePlayer()).getStateReligion()).getChar(), kCivic.getStateReligionUnitProductionModifier()));
		}
		else
		{
			szHelpText.append(NEWLINE);
			szHelpText.append(gDLL->getText("TXT_KEY_CIVICHELP_STATE_REL_TRAIN", kCivic.getStateReligionUnitProductionModifier()));
		}
	}

	//	State Religion Building Production Modifier
	if (kCivic.getStateReligionBuildingProductionModifier() != 0)
	{
		if (bPlayerContext && (GET_PLAYER(GC.getGame().getActivePlayer()).getStateReligion() != NO_RELIGION))
		{
			szHelpText.append(NEWLINE);
			szHelpText.append(gDLL->getText("TXT_KEY_CIVICHELP_REL_BUILDING", GC.getReligionInfo(GET_PLAYER(GC.getGame().getActivePlayer()).getStateReligion()).getChar(), kCivic.getStateReligionBuildingProductionModifier()));
		}
		else
		{
			szHelpText.append(NEWLINE);
			szHelpText.append(gDLL->getText("TXT_KEY_CIVICHELP_STATE_REL_BUILDING", kCivic.getStateReligionBuildingProductionModifier()));
		}
	}

	//	State Religion Free Experience
	if (kCivic.getStateReligionFreeExperience() != 0)
	{
		if (bPlayerContext && (GET_PLAYER(GC.getGame().getActivePlayer()).getStateReligion() != NO_RELIGION))
		{
			szHelpText.append(NEWLINE);
			szHelpText.append(gDLL->getText("TXT_KEY_CIVICHELP_REL_FREE_XP", kCivic.getStateReligionFreeExperience(), GC.getReligionInfo(GET_PLAYER(GC.getGame().getActivePlayer()).getStateReligion()).getChar()));
		}
		else
		{
			szHelpText.append(NEWLINE);
			szHelpText.append(gDLL->getText("TXT_KEY_CIVICHELP_STATE_REL_FREE_XP", kCivic.getStateReligionFreeExperience()));
		}
	}

	if (kCivic.isNoNonStateReligionSpread())
	{
		szHelpText.append(NEWLINE);
		szHelpText.append(gDLL->getText("TXT_KEY_CIVICHELP_NO_NON_STATE_SPREAD"));
	}

	if (kCivic.getReligionSpreadRate() > 0)
	{
		szHelpText.append(NEWLINE);
		szHelpText.append(gDLL->getText("TXT_KEY_CIVICHELP_RELIGION_SPREAD_RATE_FAST", kCivic.getReligionSpreadRate()));
	}
	else if (kCivic.getReligionSpreadRate() < 0 && kCivic.getReligionSpreadRate() > -100)
	{
		szHelpText.append(NEWLINE);
		szHelpText.append(gDLL->getText("TXT_KEY_CIVICHELP_RELIGION_SPREAD_RATE_SLOW", (100 + kCivic.getReligionSpreadRate())));
	}
	else if (kCivic.getReligionSpreadRate() < -100)
	{
		szHelpText.append(NEWLINE);
		szHelpText.append(gDLL->getText("TXT_KEY_CIVICHELP_RELIGION_NO_SPREAD"));
	}

	if (kCivic.getPopulationgrowthratepercentage() > 0)
	{
		szHelpText.append(NEWLINE);
		szHelpText.append(gDLL->getText("TXT_KEY_BUILDINGHELP_CITY_SLOW_GROWTH_SPEED", kCivic.getPopulationgrowthratepercentage()));
	}
	else if (kCivic.getPopulationgrowthratepercentage() < 0)
	{
		szHelpText.append(NEWLINE);
		szHelpText.append(gDLL->getText("TXT_KEY_BUILDINGHELP_CITY_FAST_GROWTH_SPEED", kCivic.getPopulationgrowthratepercentage()));
	}

	if (kCivic.isNoCapitalUnhappiness())
	{
		szHelpText.append(NEWLINE);
		szHelpText.append(gDLL->getText("TXT_KEY_CIVICHELP_NO_CAPITAL_ANGER"));
	}

	if (kCivic.getTaxRateUnhappiness() > 0)
	{
		//This is to round it to the nearest 5%.
		int iTaxRate = abs((100 / kCivic.getTaxRateUnhappiness()));
		if ((iTaxRate % 5) > 2)
			iTaxRate += 5 - (iTaxRate % 5);
		szHelpText.append(NEWLINE);
		szHelpText.append(gDLL->getText("TXT_KEY_CIVICHELP_TAXATION_ANGER", iTaxRate));
	}

	if (kCivic.getCivicHappiness() != 0)
	{
		if (kCivic.getCivicHappiness() > 0)
		{
			szHelpText.append(NEWLINE);
			szHelpText.append(gDLL->getText("TXT_KEY_CIVICHELP_HAPPINESS", abs(kCivic.getCivicHappiness()), ((kCivic.getCivicHappiness() > 0) ? gDLL->getSymbolID(HAPPY_CHAR) : gDLL->getSymbolID(UNHAPPY_CHAR))));
		}
		else
		{
			szHelpText.append(NEWLINE);
			szHelpText.append(gDLL->getText("TXT_KEY_CIVICHELP_UNHAPPINESS", abs(kCivic.getCivicHappiness()), ((kCivic.getCivicHappiness() > 0) ? gDLL->getSymbolID(HAPPY_CHAR) : gDLL->getSymbolID(UNHAPPY_CHAR))));
		}
	}

	if (kCivic.getCityLimit(GC.getGame().getActivePlayer()) > 0)
	{
		szHelpText.append(NEWLINE);

		if (kCivic.getCityOverLimitUnhappy() > 0)
		{
			szHelpText.append(gDLL->getText("TXT_KEY_CIVICHELP_SOFT_CITY_LIMIT", kCivic.getCityLimit(GC.getGame().getActivePlayer()), kCivic.getCityOverLimitUnhappy()));
		}
		else
		{
			szHelpText.append(gDLL->getText("TXT_KEY_CIVICHELP_CITY_LIMIT", kCivic.getCityLimit(GC.getGame().getActivePlayer())));
		}
	}

	if (kCivic.getForeignerUnhappyPercent() > 0) {
		szHelpText.append(NEWLINE);
		szHelpText.append(gDLL->getText("TXT_KEY_CIVICHELP_FOREIGNER_ANGER", 1, (100 / kCivic.getForeignerUnhappyPercent())));
	}

	if (kCivic.getInflationModifier() != 0)
	{
		if (kCivic.getInflationModifier() == -100)
		{
			szHelpText.append(NEWLINE);
			szHelpText.append(gDLL->getText("TXT_KEY_NO_INFLATION"));
		}
		else
		{
			szHelpText.append(NEWLINE);
			szHelpText.append(gDLL->getText("TXT_KEY_ADJUSTS_INFLATION", kCivic.getInflationModifier()));
		}
	}

	if (kCivic.getHurryCostModifier() != 0)
	{
		szHelpText.append(NEWLINE);
		szHelpText.append(gDLL->getText("TXT_KEY_BUILDINGHELP_HURRY_MOD", kCivic.getHurryCostModifier()));
	}

	if (kCivic.getHurryInflationModifier() > 0)
	{
		szHelpText.append(NEWLINE);
		szHelpText.append(gDLL->getText("TXT_KEY_HURRY_INFLATION_MOD_MORE", kCivic.getHurryInflationModifier()));
	}
	else if (kCivic.getHurryInflationModifier() < 0)
	{
		szHelpText.append(NEWLINE);
		szHelpText.append(gDLL->getText("TXT_KEY_HURRY_INFLATION_MOD_LESS", kCivic.getHurryInflationModifier()));
	}

	if (kCivic.getSharedCivicTradeRouteModifier() != 0)
	{
		szHelpText.append(NEWLINE);
		szHelpText.append(gDLL->getText("TXT_KEY_SHARED_CIVIC_TRADE_MOD", kCivic.getSharedCivicTradeRouteModifier()));
	}

	if (bCivilopediaText || GC.getGame().isOption(GAMEOPTION_MAP_PERSONALIZED))
	{
		if (kCivic.getLandmarkHappiness() > 0)
		{
			szHelpText.append(NEWLINE);
			szHelpText.append(gDLL->getText("TXT_KEY_CIVICHELP_LANDMARK_HAPPINESS", kCivic.getLandmarkHappiness()));
		}

		if (kCivic.getLandmarkHappiness() < 0)
		{
			szHelpText.append(NEWLINE);
			szHelpText.append(gDLL->getText("TXT_KEY_CIVICHELP_LANDMARK_UNHAPPINESS", -kCivic.getLandmarkHappiness()));
		}

		if (kCivic.isNoLandmarkAnger())
		{
			szHelpText.append(NEWLINE);
			szHelpText.append(gDLL->getText("TXT_KEY_CIVICHELP_NO_LANDMARK_ANGER"));
		}
	}

	//+1 gold per turn from each city with access to Gold.
	int iLast = 0;
	CvWString szBonusName;
	CvWString szBonusList;
	szBonusList.Format(L"");
	bool bFoundAnyBonus = false;
	for (int iI = 0; iI < GC.getNumBonusInfos(); iI++)
	{
		if (kCivic.getBonusMintedPercent(iI) > 0)
		{
			szBonusName.Format(L"<link=%s>%s</link> (%c)", gDLL->getText(CvWString(GC.getBonusInfo((BonusTypes)iI).getType()).GetCString(), GC.getBonusInfo((BonusTypes)iI).getTextKeyWide()).c_str(), GC.getBonusInfo((BonusTypes)iI).getChar());
			if (bFoundAnyBonus)
			{
				szBonusList.append(L", ");
			}
			szBonusList.append(szBonusName);
			bFoundAnyBonus = true;
			CvWString szTempBuffer;
			float fValue = (float)kCivic.getBonusMintedPercent(iI);
			if (fmod(fValue,100) == 0)
			{
				if (fValue > 0)
				{
					szTempBuffer.Format(L"+%.0f", fValue/100);
				}
				else
				{
					szTempBuffer.Format(L"%.0f", fValue/100);
				}
			}
			else
			{
				if (fValue > 0)
				{
					szTempBuffer.Format(L"+%.2f", fValue/100);
				}
				else
				{
					szTempBuffer.Format(L"%.2f", fValue/100);
				}
			}
			szFirstBuffer.Format(L"%s%s ", NEWLINE, gDLL->getText("TXT_KEY_CIVICHELP_BONUS_MINTED", szTempBuffer.GetCString()).c_str());
			setListHelp(szHelpText, szFirstBuffer, szBonusName, L", ", (kCivic.getBonusMintedPercent(iI) != iLast));
			iLast = kCivic.getBonusMintedPercent(iI);
		}
	}
	if (bFoundAnyBonus)
	{
		szHelpText.append(NEWLINE);
		szHelpText.append(gDLL->getText("TXT_KEY_CONSUMES_BONUSES_CIVIC", szBonusList.GetCString()));
	}

	iLast = 0;
	int iCount = 0;
	for (int iI = 0; iI < GC.getNumBuildingInfos(); iI++)
	{
		for (int iJ = 0; iJ < NUM_COMMERCE_TYPES; iJ++)
		{
			const BuildingTypes eBuilding = static_cast<BuildingTypes>(iI);

			if (kCivic.getBuildingCommerceModifier(eBuilding, iJ) != 0)
			{
				szFirstBuffer.Format(L"%s%s", NEWLINE, gDLL->getText("TXT_KEY_CIVICHELP_BUILDING_COMMERCE_MODIFIER", kCivic.getBuildingCommerceModifier(eBuilding, iJ), GC.getCommerceInfo((CommerceTypes)iJ).getChar()).c_str());
				CvWString szBuilding;
				szBuilding.Format(L"<link=%s>%s</link>", CvWString(GC.getBuildingInfo(eBuilding).getType()).GetCString(), GC.getBuildingInfo(eBuilding).getDescription());
				setListHelp(szHelpText, szFirstBuffer, szBuilding, L", ", (kCivic.getBuildingCommerceModifier(eBuilding, iJ) != iLast));
				if (iLast == kCivic.getBuildingCommerceModifier(eBuilding, iJ)) iCount++;
				iLast = kCivic.getBuildingCommerceModifier(eBuilding, iJ);
				if (iCount > 3) iCount = iLast = 0;
			}
		}
	}

	iLast = 0;
	iCount = 0;
	for (int iI = 0; iI < GC.getNumBuildingInfos(); iI++)
	{
		for (int iJ = 0; iJ < NUM_COMMERCE_TYPES; iJ++)
		{
			const BuildingTypes eBuilding = static_cast<BuildingTypes>(iI);

			if (kCivic.getBuildingCommerceChange(iI, iJ) != 0)
			{
				szFirstBuffer.Format(L"%s%s", NEWLINE, gDLL->getText("TXT_KEY_CIVICHELP_BUILDING_COMMERCE_CHANGE", kCivic.getBuildingCommerceChange(iI, iJ), GC.getCommerceInfo((CommerceTypes)iJ).getChar()).c_str());
				CvWString szBuilding;
				szBuilding.Format(L"<link=%s>%s</link>", CvWString(GC.getBuildingInfo(eBuilding).getType()).GetCString(), GC.getBuildingInfo(eBuilding).getDescription());
				setListHelp(szHelpText, szFirstBuffer, szBuilding, L", ", (kCivic.getBuildingCommerceChange(iI, iJ) != iLast));
				if (iLast == kCivic.getBuildingCommerceChange(iI, iJ)) iCount++;
				iLast = kCivic.getBuildingCommerceChange(iI, iJ);
				if (iCount > 3) iCount = iLast = 0;
			}
		}
	}
	// +0.35 gold for scientists
	//if (kCivic.isAnySpecialistCommerceChanges())
	{
		for (int iJ = 0; iJ < NUM_COMMERCE_TYPES; iJ++)
		{
			iLast = 0;
			for (int iI = 0; iI < GC.getNumSpecialistInfos(); iI++)
			{
				if (kCivic.getSpecialistCommercePercentChanges(iI, iJ) != 0)
				{
					CvWString szTempBuffer;
					float fValue = (float)kCivic.getSpecialistCommercePercentChanges(iI, iJ);
					if (fmod(fValue,100) == 0)
					{
						szTempBuffer.Format(L"%+.0f", fValue/100);
					}
					else
					{
						szTempBuffer.Format(L"%+.2f", fValue/100);
					}
					szFirstBuffer.Format(L"%s%s", NEWLINE, gDLL->getText("TXT_KEY_CIVICHELP_SPECIALIST_COMMERCE_CHANGE", szTempBuffer.GetCString(), GC.getCommerceInfo((CommerceTypes)iJ).getChar()).c_str());
					CvWString szSpecialist;
					szSpecialist.Format(L"<link=%s>%s</link>", CvWString(GC.getSpecialistInfo((SpecialistTypes)iI).getType()).GetCString(), GC.getSpecialistInfo((SpecialistTypes)iI).getDescription());
					setListHelp(szHelpText, szFirstBuffer, szSpecialist, L", ", (kCivic.getSpecialistCommercePercentChanges(iI, iJ) != iLast));
					iLast = kCivic.getSpecialistCommercePercentChanges(iI, iJ);
				}
			}
		}
	}
	//if (kCivic.isAnySpecialistYieldChanges())
	{
		for (int iJ = 0; iJ < NUM_YIELD_TYPES; iJ++)
		{
			iLast = 0;
			for (int iI = 0; iI < GC.getNumSpecialistInfos(); iI++)
			{
				if (kCivic.getSpecialistYieldPercentChanges(iI, iJ) != 0)
				{
					CvWString szTempBuffer;
					float fValue = (float)kCivic.getSpecialistYieldPercentChanges(iI, iJ);
					if (fmod(fValue,100) == 0)
					{
						szTempBuffer.Format(L"%.0f", fValue/100);
					}
					else
					{
						szTempBuffer.Format(L"%.2f", fValue/100);
					}
					szFirstBuffer.Format(L"%s%s", NEWLINE, gDLL->getText("TXT_KEY_CIVICHELP_IMPROVEMENT_HEALTHPERCENT", szTempBuffer.GetCString(), GC.getYieldInfo((YieldTypes)iJ).getChar()).c_str());
					CvWString szSpecialist;
					szSpecialist.Format(L"<link=%s>%s</link>", CvWString(GC.getSpecialistInfo((SpecialistTypes)iI).getType()).GetCString(), GC.getSpecialistInfo((SpecialistTypes)iI).getDescription());
					setListHelp(szHelpText, szFirstBuffer, szSpecialist, L", ", (kCivic.getSpecialistYieldPercentChanges(iI, iJ) != iLast));
					iLast = kCivic.getSpecialistYieldPercentChanges(iI, iJ);
				}
			}
		}
	}

	CvWString szImprovement;
	iLast = 0;
	for (int iI = 0; iI < GC.getNumImprovementInfos(); iI++)
	{
		if (kCivic.getImprovementHappinessChanges(iI) != 0)
		{
			int iImprovementHappinessChange = kCivic.getImprovementHappinessChanges(iI);
			szFirstBuffer.Format(L"%s%s", NEWLINE ,gDLL->getText("TXT_KEY_CIVICHELP_IMPROVEMENT_HAPPINESS", iImprovementHappinessChange, (iImprovementHappinessChange > 0 ? gDLL->getSymbolID(HAPPY_CHAR) : gDLL->getSymbolID(UNHAPPY_CHAR))).c_str());
			szImprovement.Format(L"<link=%s>%s</link>", CvWString(GC.getImprovementInfo((ImprovementTypes)iI).getType()).GetCString(), GC.getImprovementInfo((ImprovementTypes)iI).getDescription());
			setListHelp(szHelpText, szFirstBuffer, szImprovement, L", ", (iImprovementHappinessChange != iLast));
			iLast = iImprovementHappinessChange;
		}
	}

	iLast = 0;
	for (int iI = 0; iI < GC.getNumImprovementInfos(); iI++)
	{
		if (kCivic.getImprovementHealthPercentChanges(iI) != 0)
		{
			CvWString szTempBuffer;
			float fValue = (float)kCivic.getImprovementHealthPercentChanges(iI);
			if (fmod(fValue,100) == 0)
			{
				szTempBuffer.Format(L"%.0f", fValue/100);
			}
			else if (fmod(fValue,10) == 0)
			{
				szTempBuffer.Format(L"%.1f", fValue/100);
			}
			else
			{
				szTempBuffer.Format(L"%.2f", fValue/100);
			}
			szFirstBuffer.Format(L"%s%s", NEWLINE, gDLL->getText("TXT_KEY_CIVICHELP_IMPROVEMENT_HEALTHPERCENT", szTempBuffer.GetCString(), (kCivic.getImprovementHealthPercentChanges(iI) > 0 ? gDLL->getSymbolID(HEALTHY_CHAR) : gDLL->getSymbolID(UNHEALTHY_CHAR))).c_str());
			//szFirstBuffer.Format(L"%s%s %s", NEWLINE, szTempBuffer, /*(kCivic.getImprovementHealthPercentChanges(iI) > 0 ? gDLL->getSymbolID(HEALTHY_CHAR) : gDLL->getSymbolID(UNHEALTHY_CHAR)),*/ gDLL->getText("TXT_KEY_MISC_FROM"));
			szImprovement.Format(L"<link=%s>%s</link>", CvWString(GC.getImprovementInfo((ImprovementTypes)iI).getType()).GetCString(), GC.getImprovementInfo((ImprovementTypes)iI).getDescription());
			setListHelp(szHelpText, szFirstBuffer, szImprovement, L", ", (kCivic.getImprovementHealthPercentChanges(iI) != iLast));
			iLast = kCivic.getImprovementHealthPercentChanges(iI);
		}
	}

	for (int iI = 0; iI < GC.getNumBonusInfos(); iI++)
	{
		int* aList = kCivic.getBonusCommerceModifierArray(iI);
		if (aList)
		{
			listCommerceChange(szHelpText, CvWString::format(L"\n%c", gDLL->getSymbolID(BULLET_CHAR)), gDLL->getText("TXT_KEY_BUILDINGHELP_WITH_BONUS", CvWString(GC.getBonusInfo((BonusTypes) iI).getType()).GetCString(), GC.getBonusInfo((BonusTypes) iI).getTextKeyWide()), aList, true);
		}
	}

	if (bCivilopediaText || GC.getGame().isOption(GAMEOPTION_MAP_PERSONALIZED))
	{
		setYieldChangeHelp(szHelpText, L"", L"", gDLL->getText("TXT_KEY_CIVICHELP_FROM_LANDMARK").GetCString(), kCivic.getLandmarkYieldChangesArray(), false);
	}

	//	Yield Modifiers
	setYieldChangeHelp(szHelpText, L"", L"", gDLL->getText("TXT_KEY_CIVICHELP_IN_ALL_CITIES").GetCString(), kCivic.getYieldModifierArray(), true);

	//	Capital Yield Modifiers
	setYieldChangeHelp(szHelpText, L"", L"", gDLL->getText("TXT_KEY_CIVICHELP_IN_CAPITAL").GetCString(), kCivic.getCapitalYieldModifierArray(), true);

	//	Trade Yield Modifiers
	setYieldChangeHelp(szHelpText, L"", L"", gDLL->getText("TXT_KEY_CIVICHELP_FROM_TRADE_ROUTES").GetCString(), kCivic.getTradeYieldModifierArray(), true);

	//	Commerce Modifier
	{
		const int* aList = kCivic.getCommerceModifierArray();
		if (aList)
		{
			listCommerceChange(szHelpText, CvWString::format(L"\n%c", gDLL->getSymbolID(BULLET_CHAR)), gDLL->getText("TXT_KEY_CIVICHELP_IN_ALL_CITIES").GetCString(), aList, true);
		}
	}
	//	Capital Commerce Modifiers
	{
		const int* aList = kCivic.getCapitalCommerceModifierArray();
		if (aList)
		{
			listCommerceChange(szHelpText, CvWString::format(L"\n%c", gDLL->getSymbolID(BULLET_CHAR)), gDLL->getText("TXT_KEY_CIVICHELP_IN_CAPITAL").GetCString(), aList, true);
		}
	}
	//	Specialist Commerce
	{
		const int* aList = kCivic.getSpecialistExtraCommerceArray();
		if (aList)
		{
			listCommerceChange(szHelpText, CvWString::format(L"\n%c", gDLL->getSymbolID(BULLET_CHAR)), gDLL->getText("TXT_KEY_CIVICHELP_PER_SPECIALIST").GetCString(), aList);
		}
	}

	//	Largest City Happiness
	if (kCivic.getLargestCityHappiness() != 0)
	{
		szHelpText.append(NEWLINE);

		// Use absolute value with unhappy face
		szHelpText.append(gDLL->getText("TXT_KEY_CIVICHELP_LARGEST_CITIES_HAPPINESS", abs(kCivic.getLargestCityHappiness()), ((kCivic.getLargestCityHappiness() > 0) ? gDLL->getSymbolID(HAPPY_CHAR) : gDLL->getSymbolID(UNHAPPY_CHAR)), GC.getWorldInfo(GC.getMap().getWorldSize()).getTargetNumCities()));
	}

	//	Improvement Yields
	for (int iI = 0; iI < NUM_YIELD_TYPES; ++iI)
	{
		iLast = 0;

		for (int iJ = 0; iJ < GC.getNumImprovementInfos(); iJ++)
		{
			if (kCivic.getImprovementYieldChanges(iJ, iI) != 0)
			{
				szFirstBuffer.Format(L"%s%s", NEWLINE, gDLL->getText("TXT_KEY_CIVICHELP_IMPROVEMENT_YIELD_CHANGE", kCivic.getImprovementYieldChanges(iJ, iI), GC.getYieldInfo((YieldTypes)iI).getChar()).c_str());
				CvWString szImprovement;
				szImprovement.Format(L"<link=%s>%s</link>", CvWString(GC.getImprovementInfo((ImprovementTypes)iJ).getType()).GetCString(), GC.getImprovementInfo((ImprovementTypes)iJ).getDescription());
				setListHelp(szHelpText, szFirstBuffer, szImprovement, L", ", (kCivic.getImprovementYieldChanges(iJ, iI) != iLast));
				iLast = kCivic.getImprovementYieldChanges(iJ, iI);
			}
		}
	}

	//	Terrain Yields
	for (int iI = 0; iI < NUM_YIELD_TYPES; ++iI)
	{
		iLast = 0;

		for (int iJ = 0; iJ < GC.getNumTerrainInfos(); iJ++)
		{
			if (kCivic.getTerrainYieldChanges(iJ, iI) != 0)
			{
				szFirstBuffer.Format(L"%s%s", NEWLINE, gDLL->getText("TXT_KEY_CIVICHELP_TERRAIN_YIELD_CHANGE", kCivic.getTerrainYieldChanges(iJ, iI), GC.getYieldInfo((YieldTypes)iI).getChar()).c_str());
				CvWString szTerrain;
				szTerrain.Format(L"<link=%s>%s</link>", CvWString(GC.getTerrainInfo((TerrainTypes)iJ).getType()).GetCString(), GC.getTerrainInfo((TerrainTypes)iJ).getDescription());
				setListHelp(szHelpText, szFirstBuffer, szTerrain, L", ", (kCivic.getTerrainYieldChanges(iJ, iI) != iLast));
				iLast = kCivic.getTerrainYieldChanges(iJ, iI);
			}
		}
	}

	//	Building Happiness
	iLast = 0;
	iCount = 0;

	for (int iI = 0; iI < GC.getNumBuildingInfos(); ++iI)
	{
		if (kCivic.getBuildingHappinessChanges(iI) != 0)
		{
			if (bPlayerContext && NO_PLAYER != GC.getGame().getActivePlayer())
			{
				const BuildingTypes eBuilding = static_cast<BuildingTypes>(iI);
				szFirstBuffer.Format(L"%s%s", NEWLINE, gDLL->getText("TXT_KEY_CIVICHELP_BUILDING_HAPPINESS_PREFIX", abs(kCivic.getBuildingHappinessChanges(iI)), ((kCivic.getBuildingHappinessChanges(iI) > 0) ? gDLL->getSymbolID(HAPPY_CHAR) : gDLL->getSymbolID(UNHAPPY_CHAR))).c_str());
				CvWString szBuilding;
				szBuilding.Format(L"<link=%s>%s</link>", CvWString(GC.getBuildingInfo(eBuilding).getType()).GetCString(), GC.getBuildingInfo(eBuilding).getDescription());
				setListHelp(szHelpText, szFirstBuffer, szBuilding, L", ", (kCivic.getBuildingHappinessChanges(iI) != iLast));
				if (iLast == kCivic.getBuildingHappinessChanges(iI)) iCount++;
				iLast = kCivic.getBuildingHappinessChanges(iI);
				if (iCount > 3) iCount = iLast = 0;
			}
			else
			{
				szHelpText.append(NEWLINE);								 		 // abs() below added by Supercheese 10/13/09  to fix "-1 Angry" issue
				szHelpText.append(gDLL->getText("TXT_KEY_CIVICHELP_BUILDING_HAPPINESS", abs(kCivic.getBuildingHappinessChanges(iI)), ((kCivic.getBuildingHappinessChanges(iI) > 0) ? gDLL->getSymbolID(HAPPY_CHAR) : gDLL->getSymbolID(UNHAPPY_CHAR)), CvWString(GC.getBuildingInfo((BuildingTypes)iI).getType()).GetCString(), GC.getBuildingInfo((BuildingTypes)iI).getTextKeyWide()));
			}
		}
	}

	iLast = 0;
	iCount = 0;

	for (int iI = 0; iI < GC.getNumBuildingInfos(); ++iI)
	{
		if (kCivic.getBuildingHealthChanges(iI) != 0)
		{
			if (bPlayerContext && NO_PLAYER != GC.getGame().getActivePlayer())
			{
				const BuildingTypes eBuilding = static_cast<BuildingTypes>(iI);
				szFirstBuffer.Format(L"%s%s", NEWLINE, gDLL->getText("TXT_KEY_CIVICHELP_BUILDING_HAPPINESS_PREFIX", abs(kCivic.getBuildingHealthChanges(iI)), ((kCivic.getBuildingHealthChanges(iI) > 0) ? gDLL->getSymbolID(HEALTHY_CHAR) : gDLL->getSymbolID(UNHEALTHY_CHAR))).c_str());
				CvWString szBuilding;
				szBuilding.Format(L"<link=%s>%s</link>", CvWString(GC.getBuildingInfo(eBuilding).getType()).GetCString(), GC.getBuildingInfo(eBuilding).getDescription());
				setListHelp(szHelpText, szFirstBuffer, szBuilding, L", ", (kCivic.getBuildingHealthChanges(iI) != iLast));
				if (iLast == kCivic.getBuildingHealthChanges(iI)) iCount++;
				iLast = kCivic.getBuildingHealthChanges(iI);
				if (iCount > 3) iCount = iLast = 0;
			}
			else
			{
				szHelpText.append(NEWLINE); // abs() below added by Supercheese 10/13/09  to fix "-1 Unhealthy" issue
				szHelpText.append(gDLL->getText("TXT_KEY_CIVICHELP_BUILDING_HAPPINESS", abs(kCivic.getBuildingHealthChanges(iI)), ((kCivic.getBuildingHealthChanges(iI) > 0) ? gDLL->getSymbolID(HEALTHY_CHAR) : gDLL->getSymbolID(UNHEALTHY_CHAR)), CvWString(GC.getBuildingInfo((BuildingTypes)iI).getType()).GetCString(), GC.getBuildingInfo((BuildingTypes)iI).getTextKeyWide()));
			}
		}
	}

	if (kCivic.getEnslavementChance() != 0)
	{
		szHelpText.append(NEWLINE);
		szHelpText.append(gDLL->getText("TXT_KEY_UNITHELP_ENSLAVEMENT_CHANCE", kCivic.getEnslavementChance()));
	}

	for (int iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
	{
		if (kCivic.getUnitCombatProductionModifier(iI) != 0)
		{
			szHelpText.append(NEWLINE);
			szHelpText.append(CvWString::format(L"%c<link=%s>%s</link>", gDLL->getSymbolID(BULLET_CHAR), CvWString(GC.getUnitCombatInfo((UnitCombatTypes)iI).getType()).GetCString(), GC.getUnitCombatInfo((UnitCombatTypes)iI).getDescription()));
			szHelpText.append(gDLL->getText("TXT_KEY_CIVICHELP_UNIT_COMBAT_PRODUCTION_MOD", kCivic.getUnitCombatProductionModifier(iI)));
		}
	}

	iLast = 0;
	int CounterMod = 0;
	CvWString szUnit;
	for (int iI = 0; iI < GC.getNumUnitInfos(); ++iI)
	{
		if (GC.getGame().canEverTrain((UnitTypes) iI))
		{
			if (kCivic.getUnitProductionModifier(iI) != 0)
			{
				szFirstBuffer.Format(L"%s%c%d%s", NEWLINE, gDLL->getSymbolID(BULLET_CHAR), abs(kCivic.getUnitProductionModifier(iI)),
					(kCivic.getUnitProductionModifier(iI) > 0 ? gDLL->getText("TXT_KEY_UNITHELP_CLASS_PRODUCTION_FAST_MOD") : gDLL->getText("TXT_KEY_UNITHELP_CLASS_PRODUCTION_SLOW_MOD")).c_str());

				szUnit.Format(L"<link=%s>%s</link>", CvWString(GC.getUnitInfo((UnitTypes) iI).getType()).GetCString(), GC.getUnitInfo((UnitTypes) iI).getDescription());

				setListHelp(szHelpText, szFirstBuffer, szUnit, L", ", (kCivic.getUnitProductionModifier(iI) != iLast));

				if (iLast == kCivic.getUnitProductionModifier(iI))
				{
					CounterMod++;
				}
				iLast = kCivic.getUnitProductionModifier(iI);

				if (CounterMod >= 3)
				{
					CounterMod = 0;
					iLast = 0;
				}
			}
		}
	}

	CvWString szBuilding;
	CounterMod = 0;
	foreach_(const BuildingModifier2& modifier, kCivic.getBuildingProductionModifiers())
	{
		szFirstBuffer.Format(L"%s%c%d%s", NEWLINE, gDLL->getSymbolID(BULLET_CHAR), abs(modifier.second), (modifier.second > 0 ? gDLL->getText("TXT_KEY_CIVICHELP_BUILDING_PRODUCTION_MOD") : gDLL->getText("TXT_KEY_CIVICHELP_BUILDING_PRODUCTION_SLOW")).c_str());
		szBuilding.Format(L"<link=%s>%s</link>", CvWString(GC.getBuildingInfo(modifier.first).getType()).c_str(), GC.getBuildingInfo(modifier.first).getDescription());
		setListHelp(szHelpText, szFirstBuffer, szBuilding, L", ", modifier.second != iLast);
		iLast = modifier.second;
		if (iLast == modifier.second)
		{
			CounterMod++;
		}
		if (CounterMod >= 3)
		{
			CounterMod = 0;
			iLast = 0;
		}
	}
	CivicTypes eTargetCivic;
	bool bEnemiesFirst = true;
	if (bPlayerContext || GC.getGame().getActivePlayer() != NO_PLAYER)
	{
		const CvPlayer& kPlayer = GET_PLAYER(GC.getGame().getActivePlayer());
		const CivicTypes eCurrentCivic = kPlayer.getCivics((CivicOptionTypes)kCivic.getCivicOptionType());
		int aiPlayerDiplomacyChanges[MAX_PC_PLAYERS];

		for (int iK = 0; iK < MAX_PC_PLAYERS; iK++)
		{
			aiPlayerDiplomacyChanges[iK] = 0;
			if (GET_PLAYER((PlayerTypes)iK).isAlive())
			{
				if (!GET_PLAYER((PlayerTypes)iK).isHumanPlayer())
				{
					if (GET_TEAM(kPlayer.getTeam()).isHasMet(GET_PLAYER((PlayerTypes)iK).getTeam()))
					{
						for (int iL = 0; iL < GC.getNumCivicOptionInfos(); iL++)
						{
							eTargetCivic = GET_PLAYER((PlayerTypes)iK).getCivics((CivicOptionTypes)iL);
							aiPlayerDiplomacyChanges[iK] += GC.getCivicInfo(eTargetCivic).getCivicAttitudeChange(eCivic) - GC.getCivicInfo(eTargetCivic).getCivicAttitudeChange(eCurrentCivic);
						}
					}
				}
			}
		}
		bFirst = true;

		//int iPlayerCount = 0;
		//int iEnemyCount = 0;
		CvWString szPlayers;
		CvWString szEnemies;
		szEnemies.Format(L"");
		szPlayers.Format(L"");
		for (int iJ = 0; iJ < MAX_PC_PLAYERS; iJ++)
		{
			if (aiPlayerDiplomacyChanges[iJ] > 0)
			{
				if (!bFirst)
					szPlayers.append(CvWString::format(L", "));
				szPlayers.append(CvWString::format(L"<link=%s>%s</link> (+%d)", CvWString(GC.getCivilizationInfo(GET_PLAYER((PlayerTypes)iJ).getCivilizationType()).getType()).GetCString(), GC.getCivilizationInfo(GET_PLAYER((PlayerTypes)iJ).getCivilizationType()).getShortDescription(), aiPlayerDiplomacyChanges[iJ]));
				bFirst = false;
				/* Toffer - Commenting this silliness out
				//Resolution Scaling
				iPlayerCount++;
				if (iPlayerCount > XResolution / 10) // Toffer - lol, if iPlayerCount > 102...
				{
					szPlayers.append(NEWLINE);
					iPlayerCount = 0;
				}
				*/
			}
			else if (aiPlayerDiplomacyChanges[iJ] < 0)
			{
				if (!bEnemiesFirst)
					szEnemies.append(CvWString::format(L", "));
				szEnemies.append(CvWString::format(L"<link=%s>%s</link> (%d)", CvWString(GC.getCivilizationInfo(GET_PLAYER((PlayerTypes)iJ).getCivilizationType()).getType()).GetCString(), GC.getCivilizationInfo(GET_PLAYER((PlayerTypes)iJ).getCivilizationType()).getShortDescription(), aiPlayerDiplomacyChanges[iJ]));
				bEnemiesFirst = false;
				/* Toffer - Commenting this silliness out
				//Resolution Scaling
				iEnemyCount++;
				if (iEnemyCount > XResolution / 10) // Toffer - lol, if iEnemyCount > 102...
				{
					szEnemies.append(NEWLINE);
					iEnemyCount = 0;
				}
				*/
			}
		}
		if (!bFirst)
		{
			szHelpText.append(NEWLINE);
			szHelpText.append(gDLL->getSymbolID(BULLET_CHAR));
			szHelpText.append(gDLL->getText("TXT_KEY_CIVICHELP_BOOSTS_DIPLOMACY"));
			szHelpText.append(szPlayers);
		}
		if (!bEnemiesFirst)
		{
			szHelpText.append(NEWLINE);
			szHelpText.append(gDLL->getSymbolID(BULLET_CHAR));
			szHelpText.append(gDLL->getText("TXT_KEY_CIVICHELP_HURTS_DIPLOMACY"));
			szHelpText.append(szEnemies);
		}
	}
	else
	{
	//Civilopedia Text
		bFirst = true;
		bEnemiesFirst = true;
		int iAttitudeChange;
		for (int iJ = 0; iJ < GC.getNumCivicInfos(); iJ++)
		{
			eTargetCivic = CivicTypes(iJ);
			iAttitudeChange = GC.getCivicInfo(eTargetCivic).getCivicAttitudeChange(eCivic);
			if (iAttitudeChange < 0)
			{
				if (bEnemiesFirst)
				{
					szHelpText.append(NEWLINE);
					szHelpText.append(gDLL->getSymbolID(BULLET_CHAR));
					szHelpText.append(gDLL->getText("TXT_KEY_CIVICHELP_HURTS_DIPLOMACY_WITH_PLAYERS"));
				}
				else
					szHelpText.append(CvWString::format(L", "));
				szHelpText.append(CvWString::format(L"<link=%s>%s</link> (%d)", CvWString(GC.getCivicInfo(eTargetCivic).getType()).GetCString(), GC.getCivicInfo(eTargetCivic).getDescription(), iAttitudeChange));
				bEnemiesFirst = false;
			}
			else if (iAttitudeChange > 0)
			{
				if (bFirst)
				{
					szHelpText.append(NEWLINE);
					szHelpText.append(gDLL->getSymbolID(BULLET_CHAR));
					szHelpText.append(gDLL->getText("TXT_KEY_CIVICHELP_BOOSTS_DIPLOMACY_WITH_PLAYERS"));
				}
				else
					szHelpText.append(CvWString::format(L", "));
				szHelpText.append(CvWString::format(L"<link=%s>%s</link> (%d)", CvWString(GC.getCivicInfo(eTargetCivic).getType()).GetCString(), GC.getCivicInfo(eTargetCivic).getDescription(), iAttitudeChange));
				bFirst = false;
			}
		}
	}

	for (int iI = 0; iI < GC.getNumSpecialistInfos(); ++iI)
	{
		if (kCivic.getFreeSpecialistCount(iI) > 0)
		{
			szHelpText.append(NEWLINE);
			szHelpText.append(gDLL->getText("TXT_KEY_BUILDINGHELP_FREE_SPECIALIST", kCivic.getFreeSpecialistCount(iI), CvWString(GC.getSpecialistInfo((SpecialistTypes)iI).getType()).GetCString(), GC.getSpecialistInfo((SpecialistTypes)iI).getTextKeyWide()));
			szHelpText.append(gDLL->getText("TXT_KEY_BUILDINGHELP_GLOBAL"));
		}
	}

	//	Feature Happiness
	iLast = 0;

	for (int iI = 0; iI < GC.getNumFeatureInfos(); ++iI)
	{
		if (kCivic.getFeatureHappinessChanges(iI) != 0)
		{
			// Use absolute value with unhappy face
			szFirstBuffer.Format(L"%s%s", NEWLINE, gDLL->getText("TXT_KEY_CIVICHELP_FEATURE_HAPPINESS", abs(kCivic.getFeatureHappinessChanges(iI)), ((kCivic.getFeatureHappinessChanges(iI) > 0) ? gDLL->getSymbolID(HAPPY_CHAR) : gDLL->getSymbolID(UNHAPPY_CHAR))).c_str());

			CvWString szFeature;
			szFeature.Format(L"<link=%s>%s</link>", CvWString(GC.getFeatureInfo((FeatureTypes)iI).getType()).GetCString(), GC.getFeatureInfo((FeatureTypes)iI).getDescription());
			setListHelp(szHelpText, szFirstBuffer, szFeature, L", ", (kCivic.getFeatureHappinessChanges(iI) != iLast));
			iLast = kCivic.getFeatureHappinessChanges(iI);
		}
	}

	//	Hurry types
	for (int iI = 0; iI < GC.getNumHurryInfos(); ++iI)
	{
		if (kCivic.isHurry(iI))
		{
			szHelpText.append(CvWString::format(L"%s%c%s", NEWLINE, gDLL->getSymbolID(BULLET_CHAR), GC.getHurryInfo((HurryTypes)iI).getDescription()));
		}
	}

	if (kCivic.getCivilianUnitUpkeepMod() != 0)
	{
		szHelpText.append(NEWLINE);
		szHelpText.append(gDLL->getText("TXT_KEY_HELPTEXT_UNIT_UPKEEP_MOD_CIVILIAN", kCivic.getCivilianUnitUpkeepMod()));
	}
	if (kCivic.getMilitaryUnitUpkeepMod() != 0)
	{
		szHelpText.append(NEWLINE);
		szHelpText.append(gDLL->getText("TXT_KEY_HELPTEXT_UNIT_UPKEEP_MOD_MILITARY", kCivic.getMilitaryUnitUpkeepMod()));
	}

	bFirst = true;
	for (int iI = 0; iI < GC.getNumBuildingInfos(); ++iI)
	{
		const BuildingTypes eLoopBuilding = static_cast<BuildingTypes>(iI);

		if (GC.getGame().canEverConstruct(eLoopBuilding))
		{
			if ((GC.getBuildingInfo(eLoopBuilding).isPrereqOrCivics(eCivic) || GC.getBuildingInfo(eLoopBuilding).isPrereqAndCivics(eCivic)))
			{
				CvWString szBuilding;
				szFirstBuffer.Format(L"%s%s", NEWLINE, gDLL->getText("TXT_KEY_CIVICHELP_UNLOCKS_BUILDING").c_str());
				szBuilding.Format(L"<link=%s>%s</link>", CvWString(GC.getBuildingInfo(eLoopBuilding).getType()).GetCString(), GC.getBuildingInfo(eLoopBuilding).getDescription());
				setListHelp(szHelpText, szFirstBuffer, szBuilding, L", ", bFirst);
				bFirst = false;
			}
		}
	}
	bFirst = true;
	if (NO_PLAYER != GC.getGame().getActivePlayer() && !GET_PLAYER(GC.getGame().getActivePlayer()).isCivic(eCivic))
	{
		for (int iI = GC.getNumBuildingInfos() - 1; iI > -1; iI--)
		{
			const BuildingTypes eTypeX = static_cast<BuildingTypes>(iI);

			if (GC.getGame().canEverConstruct(eTypeX))
			{
				bool bObsolete = false;
				const CivicTypes eCurCivic = GET_PLAYER(GC.getGame().getActivePlayer()).getCivics((CivicOptionTypes)kCivic.getCivicOptionType());

				if (GC.getBuildingInfo(eTypeX).isPrereqAndCivics(eCurCivic))
				{
					bObsolete = true;
				}
				else if (GC.getBuildingInfo(eTypeX).isPrereqOrCivics(eCurCivic) && !GC.getBuildingInfo(eTypeX).isPrereqOrCivics(eCivic))
				{
					bObsolete = true;
					for (int iJ = 0; iJ < GC.getNumCivicInfos(); iJ++)
					{
						if (iJ != eCurCivic && iJ != eCivic
						&& GC.getBuildingInfo(eTypeX).isPrereqOrCivics((CivicTypes)iJ)
						&& GET_PLAYER(GC.getGame().getActivePlayer()).isCivic((CivicTypes)iJ))
						{
							bObsolete = false;
							break;
						}
					}
				}
				if (bObsolete)
				{
					CvWString szBuilding;
					szFirstBuffer.Format(L"%s%s", NEWLINE, gDLL->getText("TXT_KEY_CIVICHELP_BLOCKS_BUILDING").c_str());
					szBuilding.Format(L"<link=%s>%s</link>", CvWString(GC.getBuildingInfo(eTypeX).getType()).GetCString(), GC.getBuildingInfo(eTypeX).getDescription());
					setListHelp(szHelpText, szFirstBuffer, szBuilding, L", ", bFirst);
					bFirst = false;
				}
			}
		}
	}
	kCivic.getPropertyManipulators()->buildDisplayString(szHelpText);

	if (!CvWString(kCivic.getHelp()).empty())
	{
		szHelpText.append(CvWString::format(L"%s%s", NEWLINE, kCivic.getHelp()).c_str());
	}
}


void CvGameTextMgr::setTechHelp(CvWStringBuffer &szBuffer, TechTypes eTech, bool bCivilopediaText, bool bPlayerContext, bool bStrategyText, bool bTreeInfo, TechTypes eFromTech)
{
	PROFILE_FUNC();

	CvWString szTempBuffer;

	// Debug mode - Alt
	if (bTreeInfo && gDLL->altKey() && GC.getGame().isDebugMode())
	{
		szBuffer.clear();

		for (int iI = 0; iI < MAX_PLAYERS; iI++)
		{
			CvPlayerAI* playerI = &GET_PLAYER((PlayerTypes)iI);
			CvTeamAI* teamI = &GET_TEAM(playerI->getTeam());
			if (playerI->isAlive())
			{
				szTempBuffer.Format(L"%s: ", playerI->getName());
				szBuffer.append(szTempBuffer);

				const TechTypes ePlayerTech = playerI->getCurrentResearch();
				if (ePlayerTech == NO_TECH)
					szTempBuffer.Format(L"-\n");
				else
					szTempBuffer.Format(L"%s (%d->%dt)(%d/%d)\n", GC.getTechInfo(ePlayerTech).getDescription(), playerI->calculateResearchRate(ePlayerTech), playerI->getResearchTurnsLeft(ePlayerTech, true), teamI->getResearchProgress(ePlayerTech), teamI->getResearchCost(ePlayerTech));

				szBuffer.append(szTempBuffer);
			}
		}
		return;
	}
	if (NO_TECH == eTech)
	{
		return;
	}

	//	Tech Name
	if (!bCivilopediaText && (!bTreeInfo || NO_TECH == eFromTech))
	{
		szTempBuffer.Format(SETCOLR L"%s" ENDCOLR , TEXT_COLOR("COLOR_TECH_TEXT"), GC.getTechInfo(eTech).getDescription());
		szBuffer.append(szTempBuffer);
	}

	const PlayerTypes ePlayerAct = GC.getGame().getActivePlayer();
	FAssert(ePlayerAct != NO_PLAYER || !bPlayerContext);

	const CvPlayer* playerAct = ePlayerAct != NO_PLAYER ? &GET_PLAYER(ePlayerAct) : NULL;

	if (bTreeInfo && (NO_TECH != eFromTech))
	{
		buildTechTreeString(szBuffer, eTech, bPlayerContext, eFromTech);
	}

	// Obsolete Buildings
	for (int iI = 0; iI < GC.getNumBuildingInfos(); ++iI)
	{
		if ((!bPlayerContext || playerAct->getBuildingCount((BuildingTypes)iI) > 0)
		&& GC.getGame().canEverConstruct((BuildingTypes)iI)
		&& GC.getBuildingInfo((BuildingTypes)iI).getObsoleteTech() == eTech)
		{
			buildObsoleteString(szBuffer, (BuildingTypes)iI, true);
		}
	}

	//	Obsolete Bonuses
	for (int iI = 0; iI < GC.getNumBonusInfos(); ++iI)
	{
		if (GC.getBonusInfo((BonusTypes)iI).getTechObsolete() == eTech)
		{
			buildObsoleteBonusString(szBuffer, iI, true);
		}
	}

	for (int iI = 0; iI < GC.getNumSpecialBuildingInfos(); ++iI)
	{
		if (GC.getSpecialBuildingInfo((SpecialBuildingTypes) iI).getObsoleteTech() == eTech)
		{
			buildObsoleteSpecialString(szBuffer, iI, true);
		}
	}

	//	Route movement change...
	buildMoveString(szBuffer, eTech, true, bPlayerContext);

	//	Creates a free unit...
	buildFreeUnitString(szBuffer, eTech, true, bPlayerContext);

	//	Increases feature production...
	buildFeatureProductionString(szBuffer, eTech, true, bPlayerContext);

	//	Increases worker build rate...
	buildWorkerRateString(szBuffer, eTech, true, bPlayerContext);

	//DPII < Maintenance Modifiers >
	//  Decreases maintenance costs...
	buildMaintenanceModifiersString(szBuffer, eTech, true);
	//DPII < Maintenance Modifiers >

	//	Trade Routed per city change...
	buildTradeRouteString(szBuffer, eTech, true, bPlayerContext);

	//	Health increase...
	buildHealthRateString(szBuffer, eTech, true, bPlayerContext);

	//  Specialist Health
	buildSpecialistHealthString(szBuffer, eTech, true, bPlayerContext);

	//	Happiness increase...
	buildHappinessRateString(szBuffer, eTech, true, bPlayerContext);

	//  Specialist Happiness
	buildSpecialistHappinessString(szBuffer, eTech, true, bPlayerContext);

	//	Free Techs...
	buildFreeTechString(szBuffer, eTech, true, bPlayerContext);

	//	Line of Sight Bonus across water...
	buildLOSString(szBuffer, eTech, true, bPlayerContext);

	//	Centers world map...
	buildMapCenterString(szBuffer, eTech, true, bPlayerContext);

	//	Reveals World Map...
	buildMapRevealString(szBuffer, eTech, true);

	//	Enables map trading...
	buildMapTradeString(szBuffer, eTech, true, bPlayerContext);

	//	Enables tech trading...
	buildTechTradeString(szBuffer, eTech, true, bPlayerContext);

	//	Enables gold trading...
	buildGoldTradeString(szBuffer, eTech, true, bPlayerContext);

	//	Enables open borders...
	buildOpenBordersString(szBuffer, eTech, true, bPlayerContext);

	//	Enables defensive pacts...
	buildDefensivePactString(szBuffer, eTech, true, bPlayerContext);

	//	Enables permanent alliances...
	buildPermanentAllianceString(szBuffer, eTech, true, bPlayerContext);

	const CvTechInfo& kTech = GC.getTechInfo(eTech);
	// Enables Embassies...
	buildEmbassyString(szBuffer, eTech, true, bPlayerContext);

	//	Peak passability...
	buildCanPassPeaksString(szBuffer, eTech, true, bPlayerContext);

	//	If it Removes Movement slowdown...
	buildMoveFastPeaksString(szBuffer, eTech, true, bPlayerContext);

	//	Can found cities on peak...
	buildCanFoundOnPeaksString(szBuffer, eTech, true, bPlayerContext);

	//   Removes Airlift Restriction...
	buildCanRebaseAnywhereString(szBuffer, eTech, true, bPlayerContext);

	if (kTech.getInflationModifier() != 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_ADJUSTS_INFLATION", kTech.getInflationModifier()));
	}

	if (kTech.getGlobalTradeModifier() != 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_TRADE_INCOME", kTech.getGlobalTradeModifier()));
	}

	if (kTech.getGlobalForeignTradeModifier() != 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_FOREIGN_TRADE_INCOME", kTech.getGlobalForeignTradeModifier()));
	}

	if (kTech.getTradeMissionModifier() != 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_TRADE_MISSION_INCOME", kTech.getTradeMissionModifier()));
	}

	if (kTech.getCorporationRevenueModifier() != 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_CORPORATIONS_REVENUE", kTech.getCorporationRevenueModifier()));
	}

	if (kTech.getCorporationMaintenanceModifier() != 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_TECHHELP_CORPORATION_MAINTENANCE", kTech.getCorporationMaintenanceModifier()));
	}

	if (kTech.isEnablesDesertFarming())
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_TECHHELP_ENABLES_DESERT_FARMING"));
	}

	if (kTech.isLanguage())
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_TECHHELP_LANGUAGE"));
	}

	if (kTech.isGlobal())
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_TECHHELP_GLOBAL"));
	}

	for (int iI = 0; iI < GC.getNumSpecialistInfos(); ++iI)
	{
		if (kTech.getFreeSpecialistCount(iI) > 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_FREE_SPECIALIST", kTech.getFreeSpecialistCount(iI), CvWString(GC.getSpecialistInfo((SpecialistTypes) iI).getType()).GetCString(), GC.getSpecialistInfo((SpecialistTypes) iI).getTextKeyWide()));
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_GLOBAL"));
		}
	}

	for (int iI = 0; iI < GC.getNumImprovementInfos(); ++iI)
	{
		if (GC.getImprovementInfo((ImprovementTypes)iI).getPrereqTech() == eTech && GC.getImprovementInfo((ImprovementTypes)iI).getImprovementPillage() != NO_IMPROVEMENT)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_TECHHELP_ALLOWS_IMPROVEMENT_UPGRADE", GC.getImprovementInfo(GC.getImprovementInfo((ImprovementTypes)iI).getImprovementPillage()).getTextKeyWide(), GC.getImprovementInfo((ImprovementTypes)iI).getTextKeyWide()));
		}
	}

	//	Enables bridge building...
	buildBridgeString(szBuffer, eTech, true, bPlayerContext);

	//	Can spread irrigation...
	buildIrrigationString(szBuffer, eTech, true, bPlayerContext);

	//	Ignore irrigation...
	buildIgnoreIrrigationString(szBuffer, eTech, true, bPlayerContext);

	//	Coastal work...
	buildWaterWorkString(szBuffer, eTech, true, bPlayerContext);

	//	Enables permanent alliances...
	buildVassalStateString(szBuffer, eTech, true, bPlayerContext);

	//	Build farm, irrigation, etc...
	for (int iI = 0; iI < GC.getNumBuildInfos(); ++iI)
	{
		buildImprovementString(szBuffer, eTech, (BuildTypes)iI, true, bPlayerContext);
	}

	//	Extra moves for certain domains...
	for (int iI = 0; iI < NUM_DOMAIN_TYPES; ++iI)
	{
		buildDomainExtraMovesString(szBuffer, eTech, iI, true, bPlayerContext);
	}

	//	Adjusting culture, science, etc
	for (int iI = 0; iI < NUM_COMMERCE_TYPES; ++iI)
	{
		buildAdjustString(szBuffer, eTech, iI, true, bPlayerContext);
	}

	//	Enabling trade routes on water...?
	for (int iI = 0; iI < GC.getNumTerrainInfos(); ++iI)
	{
		buildTerrainTradeString(szBuffer, eTech, iI, true, bPlayerContext);
	}

	//ls612: Tech Commerce Modifiers
	{
		int* aList = GC.getTechInfo(eTech).getCommerceModifierArray();
		if (aList)
		{
			listCommerceChange(szBuffer, CvWString::format(L"\n%c", gDLL->getSymbolID(BULLET_CHAR)), L"", aList, true);
		}
	}

	buildRiverTradeString(szBuffer, eTech, true, bPlayerContext);

	//	Special Buildings
	for (int iI = 0; iI < GC.getNumSpecialBuildingInfos(); ++iI)
	{
		buildSpecialBuildingString(szBuffer, eTech, iI, true, bPlayerContext);
	}

	for (int iI = 0; iI < GC.getNumBuildingInfos(); ++iI)
	{
		if (GC.getGame().canEverConstruct((BuildingTypes)iI))
		{
			const CvBuildingInfo& kBuilding = GC.getBuildingInfo((BuildingTypes)iI);

			bool bFirst = true;
			foreach_(const TechArray& pair, kBuilding.getTechYieldChanges100())
			{
				if (pair.first == eTech)
				{
					for (int iJ = 0; iJ < NUM_YIELD_TYPES; ++iJ)
					{
						if (pair.second[iJ] != 0)
						{
							if (bFirst)
							{
								szBuffer.append(
									CvWString::format(
										L"\n%c<link=%s>%s</link>: ",
										gDLL->getSymbolID(BULLET_CHAR),
										CvWString(kBuilding.getType()).GetCString(),
										kBuilding.getDescription()
									)
								);
								bFirst = false;
							}
							else szBuffer.append(L", ");

							CvWString szValue; makeValueString(szValue, pair.second[iJ], true);
							szBuffer.append(CvWString::format(L"%s%c", szValue.GetCString(), GC.getYieldInfo((YieldTypes) iJ).getChar()));
						}
					}
					break;
				}
			}
			foreach_(const TechCommerceArray& pair, kBuilding.getTechCommerceChanges100())
			{
				if (pair.first == eTech)
				{
					for (int iJ = 0; iJ < NUM_COMMERCE_TYPES; ++iJ)
					{
						if (pair.second[iJ] != 0)
						{
							if (bFirst)
							{
								szBuffer.append(
									CvWString::format(
										L"\n%c<link=%s>%s</link>: ",
										gDLL->getSymbolID(BULLET_CHAR),
										CvWString(kBuilding.getType()).GetCString(),
										kBuilding.getDescription()
									)
								);
								bFirst = false;
							}
							else szBuffer.append(L", ");

							CvWString szValue; makeValueString(szValue, pair.second[iJ], true);
							szBuffer.append(CvWString::format(L"%s%c", szValue.GetCString(), GC.getCommerceInfo((CommerceTypes) iJ).getChar()));
						}
					}
					break;
				}
			}
			bFirst = true;
			foreach_(const TechArray& pair, kBuilding.getTechYieldModifiers())
			{
				if (pair.first == eTech)
				{
					for (int iJ = 0; iJ < NUM_YIELD_TYPES; ++iJ)
					{
						if (pair.second[iJ] != 0)
						{
							if (bFirst)
							{
								szBuffer.append(
									CvWString::format(
										L"\n%c<link=%s>%s</link>: ",
										gDLL->getSymbolID(BULLET_CHAR),
										CvWString(kBuilding.getType()).GetCString(),
										kBuilding.getDescription()
									)
								);
								bFirst = false;
							}
							else szBuffer.append(L", ");

							szBuffer.append(CvWString::format(L"%d%%%c", pair.second[iJ], GC.getYieldInfo((YieldTypes) iJ).getChar()));
						}
					}
					break;
				}
			}
			foreach_(const TechCommerceArray& pair, kBuilding.getTechCommerceModifiers())
			{
				if (pair.first == eTech)
				{
					for (int iJ = 0; iJ < NUM_COMMERCE_TYPES; ++iJ)
					{
						if (pair.second[iJ] != 0)
						{
							if (bFirst)
							{
								szBuffer.append(
									CvWString::format(
										L"\n%c<link=%s>%s</link>: ",
										gDLL->getSymbolID(BULLET_CHAR),
										CvWString(kBuilding.getType()).GetCString(),
										kBuilding.getDescription()
									)
								);
								bFirst = false;
							}
							else szBuffer.append(L", ");

							szBuffer.append(CvWString::format(L"%d%%%c", pair.second[iJ], GC.getCommerceInfo((CommerceTypes) iJ).getChar()));
						}
					}
					break;
				}
			}
		//	Building specialist count changes
			if (kBuilding.isAnyTechSpecialistChanges())
				buildBuildingTechSpecialistChangeString(szBuffer, eTech, iI, true, bPlayerContext);
		//	Building happy changes
			buildBuildingTechHappinessChangesString(szBuffer, eTech, iI, true, bPlayerContext);
		//	Building health changes
			buildBuildingTechHealthChangesString(szBuffer, eTech, iI, true, bPlayerContext);
		}
	}
	//	Build farm, mine, etc...
	for (int iI = 0; iI < GC.getNumImprovementInfos(); ++iI)
	{
		buildYieldChangeString(szBuffer, eTech, iI, true, bPlayerContext);
	}

	bool bFirst = true;

	for (int iI = 0; iI < GC.getNumBonusInfos(); ++iI)
	{
		bFirst = buildBonusRevealString(szBuffer, eTech, iI, bFirst, true, bPlayerContext);
	}

	bFirst = true;

	for (int iI = 0; iI < GC.getNumCivicInfos(); ++iI)
	{
		bFirst = buildCivicRevealString(szBuffer, eTech, iI, bFirst, true, bPlayerContext);
	}
	CvWString szFirstBuffer;

	if (!bCivilopediaText)
	{
		bFirst = true;

		for (int iI = 0; iI < GC.getNumUnitInfos(); ++iI)
		{
			if (GC.getGame().canEverTrain((UnitTypes) iI)
			&& (!bPlayerContext ||
					!playerAct->isProductionMaxedUnit((UnitTypes) iI)
				&&	!playerAct->canTrain((UnitTypes) iI)))
			{
				const CvUnitInfo& kUnit = GC.getUnitInfo((UnitTypes) iI);
				if (kUnit.getPrereqAndTech() == eTech)
				{
					szFirstBuffer.Format(L"%s%s", NEWLINE, gDLL->getText("TXT_KEY_TECHHELP_CAN_TRAIN").c_str());
					szTempBuffer.Format( SETCOLR L"%s" ENDCOLR , TEXT_COLOR("COLOR_UNIT_TEXT"), kUnit.getDescription());
					setListHelp(szBuffer, szFirstBuffer, szTempBuffer, L", ", bFirst);
					bFirst = false;
					continue;
				}
				if (algo::any_of_equal(kUnit.getPrereqAndTechs(), eTech))
				{
					szFirstBuffer.Format(L"%s%s", NEWLINE, gDLL->getText("TXT_KEY_TECHHELP_CAN_TRAIN").c_str());
					szTempBuffer.Format( SETCOLR L"%s" ENDCOLR , TEXT_COLOR("COLOR_UNIT_TEXT"), kUnit.getDescription());
					setListHelp(szBuffer, szFirstBuffer, szTempBuffer, L", ", bFirst);
					bFirst = false;
				}
			}
		}

		bFirst = true;

		for (int iI = GC.getNumHeritageInfos() - 1; iI > -1; --iI)
		{
			if (GC.getHeritageInfo((HeritageTypes)iI).getPrereqTech() == eTech)
			{
				szFirstBuffer.Format(L"%s%s", NEWLINE, gDLL->getText("TXT_KEY_TECHHELP_CAN_CONSTRUCT").c_str());
				szTempBuffer.Format(
					SETCOLR L"<link=%s>%s</link>" ENDCOLR , TEXT_COLOR("COLOR_BUILDING_TEXT"),
					CvWString(GC.getHeritageInfo((HeritageTypes)iI).getType()).GetCString(),
					GC.getHeritageInfo((HeritageTypes)iI).getDescription()
				);
				setListHelp(szBuffer, szFirstBuffer, szTempBuffer, L", ", bFirst);
				bFirst = false;
			}
		}
		bFirst = true;

		for (int iI = GC.getNumBuildingInfos() - 1; iI > -1; --iI)
		{
			const BuildingTypes eLoopBuilding = static_cast<BuildingTypes>(iI);
			if (!bPlayerContext || !playerAct->isProductionMaxedBuilding(eLoopBuilding))
			{
				if (GC.getGame().canEverConstruct(eLoopBuilding))
				{
					if (!bPlayerContext || !(playerAct->canConstruct(eLoopBuilding, false, true)))
					{
						if (GC.getBuildingInfo(eLoopBuilding).getPrereqAndTech() == eTech
						|| algo::any_of_equal(GC.getBuildingInfo(eLoopBuilding).getPrereqAndTechs(), eTech))
						{
							szFirstBuffer.Format(L"%s%s", NEWLINE, gDLL->getText("TXT_KEY_TECHHELP_CAN_CONSTRUCT").c_str());
							szTempBuffer.Format(SETCOLR L"<link=%s>%s</link>" ENDCOLR , TEXT_COLOR("COLOR_BUILDING_TEXT"), CvWString(GC.getBuildingInfo(eLoopBuilding).getType()).GetCString(), GC.getBuildingInfo(eLoopBuilding).getDescription());
							setListHelp(szBuffer, szFirstBuffer, szTempBuffer, L", ", bFirst);
							bFirst = false;
						}
					}
				}
			}
		}
		bFirst = true;

		for (int iI = 0; iI < GC.getNumProjectInfos(); ++iI)
		{
			if (GC.getProjectInfo((ProjectTypes)iI).getTechPrereq() == eTech
			&& (!bPlayerContext || !playerAct->isProductionMaxedProject((ProjectTypes)iI) && !playerAct->canCreate((ProjectTypes)iI, false, true)))
			{
				szFirstBuffer.Format(L"%s%s", NEWLINE, gDLL->getText("TXT_KEY_TECHHELP_CAN_CREATE").c_str());
				szTempBuffer.Format( SETCOLR L"%s" ENDCOLR , TEXT_COLOR("COLOR_PROJECT_TEXT"), GC.getProjectInfo((ProjectTypes)iI).getDescription());
				setListHelp(szBuffer, szFirstBuffer, szTempBuffer, L", ", bFirst);
				bFirst = false;
			}
		}
	}
	bFirst = true;
	for (int iI = 0; iI < GC.getNumProcessInfos(); ++iI)
	{
		bFirst = buildProcessInfoString(szBuffer, eTech, iI, bFirst, true, bPlayerContext);
	}

	bFirst = true;
	if (!GC.getGame().isOption(GAMEOPTION_RELIGION_DIVINE_PROPHETS))
	{
		for (int iI = 0; iI < GC.getNumReligionInfos(); ++iI)
		{
			if (!bPlayerContext || !GC.getGame().isReligionSlotTaken((ReligionTypes)iI) && playerAct->canFoundReligion())
			{
				bFirst = buildFoundReligionString(szBuffer, eTech, iI, bFirst, true, bPlayerContext);
			}
		}
	}
	else if (!GC.getGame().isOption(GAMEOPTION_RELIGION_LIMITED))
	{
		if (GC.getTechInfo(eTech).getFirstFreeProphet() > -1 && GC.getGame().countKnownTechNumTeams(eTech) == 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_TECHHELP_FIRST_FREE_PROPHET"));
			bFirst = false;
		}
	}

	bFirst = true;
	for (int iI = 0; iI < GC.getNumCorporationInfos(); ++iI)
	{
		if (GC.getGame().canEverSpread((CorporationTypes)iI))
		{
			if (!bPlayerContext || !(GC.getGame().isCorporationFounded((CorporationTypes)iI)))
			{
				bFirst = buildFoundCorporationString(szBuffer, eTech, iI, bFirst, true, bPlayerContext);
			}
		}
	}

	bFirst = true;
	for (int iI = 0; iI < GC.getNumPromotionInfos(); ++iI)
	{
		bFirst = buildPromotionString(szBuffer, eTech, iI, bFirst, true);
	}

	bFirst = true;
	for (int iI = 0; iI < GC.getNumPromotionInfos(); ++iI)
	{
		if (GC.getPromotionInfo((PromotionTypes)iI).getObsoleteTech() == eTech)
		{
			if (bFirst)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_TECHHELP_OBSOLETES", CvWString(GC.getPromotionInfo((PromotionTypes)iI).getType()).GetCString(), GC.getPromotionInfo((PromotionTypes)iI).getDescription()));
				bFirst = false;
			}
			else
			{
				szTempBuffer.Format(L", <link=%s>%s</link>", CvWString(GC.getPromotionInfo((PromotionTypes)iI).getType()).GetCString(), GC.getPromotionInfo((PromotionTypes)iI).getDescription());
				szBuffer.append(szTempBuffer);
			}
		}
	}

	if (bTreeInfo && NO_TECH == eFromTech)
	{
		buildSingleLineTechTreeString(szBuffer, eTech, bPlayerContext);
	}

	if (!CvWString(GC.getTechInfo(eTech).getHelp()).empty())
	{
		szBuffer.append(CvWString::format(L"%s%s", NEWLINE, GC.getTechInfo(eTech).getHelp()).c_str());
	}

	if (bCivilopediaText || ePlayerAct == NO_PLAYER || !playerAct->canResearch(eTech))
	{
		for (int iI = 0; iI < GC.getTechInfo(eTech).getNumPrereqBuildings(); iI++)
		{
			const int iPrereq = GC.getTechInfo(eTech).getPrereqBuilding(iI).iMinimumRequired;
			if (iPrereq > 0)
			{
				const BuildingTypes eBuildingX = GC.getTechInfo(eTech).getPrereqBuilding(iI).eBuilding;

				if (ePlayerAct == NO_PLAYER)
				{
					szBuffer.append(
						CvWString::format(
							L"%s%s", NEWLINE,
							gDLL->getText(
								"TXT_KEY_HELPTEXT_REQUIRES_NUM_BUILDINGS_0",
								CvWString(GC.getBuildingInfo(eBuildingX).getType()).GetCString(),
								GC.getBuildingInfo(eBuildingX).getDescription(),
								iPrereq
							).c_str()
						)
					);
				}
				else
				{
					szBuffer.append(
						CvWString::format(
							L"%s%s", NEWLINE,
							gDLL->getText(
								"TXT_KEY_HELPTEXT_REQUIRES_NUM_BUILDINGS_1",
								CvWString(GC.getBuildingInfo(eBuildingX).getType()).GetCString(),
								GC.getBuildingInfo(eBuildingX).getDescription(),
								playerAct->getBuildingCount(eBuildingX),
								iPrereq
							).c_str()
						)
					);
				}
			}
		}
		bFirst = true;
		for (int iI = 0; iI < GC.getTechInfo(eTech).getNumPrereqOrBuildings(); iI++)
		{
			const int iPrereq = GC.getTechInfo(eTech).getPrereqOrBuilding(iI).iMinimumRequired;
			if (iPrereq > 0)
			{
				const BuildingTypes eBuildingX = GC.getTechInfo(eTech).getPrereqOrBuilding(iI).eBuilding;
				CvWString szTxt;
				if (ePlayerAct != NO_PLAYER)
				{
					szTxt.Format(L"<link=%s>%s</link> (%d/%d)", CvWString(GC.getBuildingInfo(eBuildingX).getType()).GetCString(), GC.getBuildingInfo(eBuildingX).getDescription(), playerAct->getBuildingCount(eBuildingX), iPrereq);
				}
				else szTxt.Format(L"<link=%s>%s</link> (%d)", CvWString(GC.getBuildingInfo(eBuildingX).getType()).GetCString(), GC.getBuildingInfo(eBuildingX).getDescription(), iPrereq);

				setListHelp(szBuffer, gDLL->getText("TXT_KEY_REQUIRES"), szTxt, gDLL->getText("TXT_KEY_OR").c_str(), bFirst);
				bFirst = false;
			}
		}
	}

	if (!bCivilopediaText)
	{
		if (ePlayerAct == NO_PLAYER)
		{
			szTempBuffer.Format(L"\n%d%c", GC.getTechInfo(eTech).getResearchCost(), GC.getCommerceInfo(COMMERCE_RESEARCH).getChar());
			szBuffer.append(szTempBuffer);
		}
		else if (GET_TEAM(GC.getGame().getActiveTeam()).isHasTech(eTech))
		{
			szTempBuffer.Format(L"\n%d%c", GET_TEAM(GC.getGame().getActiveTeam()).getResearchCost(eTech), GC.getCommerceInfo(COMMERCE_RESEARCH).getChar());
			szBuffer.append(szTempBuffer);
		}
		else
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_TECHHELP_NUM_TURNS", playerAct->getResearchTurnsLeft(eTech, (gDLL->ctrlKey() || !(gDLL->shiftKey())))));

			szTempBuffer.Format(L" (%d/%d %c)", GET_TEAM(GC.getGame().getActiveTeam()).getResearchProgress(eTech), GET_TEAM(GC.getGame().getActiveTeam()).getResearchCost(eTech), GC.getCommerceInfo(COMMERCE_RESEARCH).getChar());
			szBuffer.append(szTempBuffer);
		}
	}

	if (ePlayerAct != NO_PLAYER && playerAct->canResearch(eTech))
	{
		for (int iI = 0; iI < GC.getNumUnitInfos(); ++iI)
		{
			const CvUnitInfo& kUnit = GC.getUnitInfo((UnitTypes)iI);

			if (kUnit.getBaseDiscover() > 0 || kUnit.getDiscoverMultiplier() > 0)
			{
				if (::getDiscoveryTech((UnitTypes)iI, ePlayerAct) == eTech)
				{
					szBuffer.append(NEWLINE);
					szBuffer.append(gDLL->getText("TXT_KEY_TECHHELP_GREAT_PERSON_DISCOVER", kUnit.getTextKeyWide()));
				}
			}
		}

		if (playerAct->getCurrentEra() < GC.getTechInfo(eTech).getEra())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_TECHHELP_ERA_ADVANCE", GC.getEraInfo((EraTypes)GC.getTechInfo(eTech).getEra()).getTextKeyWide()));
		}
	}

	if (bStrategyText && !CvWString(GC.getTechInfo(eTech).getStrategy()).empty()
	&& (ePlayerAct == NO_PLAYER || playerAct->isOption(PLAYEROPTION_ADVISOR_HELP)))
	{
		szBuffer.append(SEPARATOR);
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_SIDS_TIPS"));
		szBuffer.append(L'\"');
		szBuffer.append(GC.getTechInfo(eTech).getStrategy());
		szBuffer.append(L'\"');
	}
}


void CvGameTextMgr::setBasicUnitHelp(CvWStringBuffer &szBuffer, UnitTypes eUnit, bool bCivilopediaText)
{
	setBasicUnitHelpWithCity(szBuffer, eUnit, bCivilopediaText, NULL, false, gDLL->ctrlKey(), gDLL->altKey(), gDLL->shiftKey());
}

void CvGameTextMgr::setBasicUnitHelpWithCity(CvWStringBuffer &szBuffer, UnitTypes eUnit, bool bCivilopediaText, CvCity* pCity, bool bConscript, bool bTBUnitView1, bool bTBUnitView2, bool bTBUnitView3)
{
	if (NO_UNIT == eUnit)
	{
		return;
	}
	PROFILE_FUNC();

	const CvGame& game = GC.getGame();
	CvWString szTempBuffer;
	bool bFirst;
	int iCount;

	const CvUnitInfo& kUnit = GC.getUnitInfo(eUnit);
	//bTBUnitView1 = (Combat)
	//bTBUnitView2 = (Civil)
	//bTBUnitView3 = (Combat Classes)
	//bNormalView = default to show but replaced by any of the above
	bool bNormalView = (!bTBUnitView1 && !bTBUnitView2 && !bTBUnitView3);

	if (bCivilopediaText)
	{
		bTBUnitView1 = true;
		bTBUnitView2 = true;
		bTBUnitView3 = true;
		bNormalView = true;
	}

	/*
	//TBGRIDX
	int iX = 0;
	if ((TechTypes)kUnit.getPrereqAndTech() != -1)
		iX = GC.getTechInfo((TechTypes)kUnit.getPrereqAndTech()).getGridX();

	TechTypes eMostAdvancedTech = (TechTypes)kUnit.getPrereqAndTech();
	for (int iI = 0; iI < GC.getNumTechInfos(); iI++)
	{
		TechTypes tTech = (TechTypes)iI;
		if (algo::any_of_equal(kUnit.getPrereqAndTechs(), tTech))
		{
			if (GC.getTechInfo(tTech).getGridX() > iX)
			{
				iX = GC.getTechInfo(tTech).getGridX();
				eMostAdvancedTech = tTech;
			}
		}
	}
	if (eMostAdvancedTech != NO_TECH)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_GRID_X", GC.getTechInfo(eMostAdvancedTech).getTextKeyWide(), iX));
	}
	*/

	if (!bCivilopediaText)
	{
		szBuffer.append(NEWLINE);

		if (GC.getGame().isOption(GAMEOPTION_COMBAT_SIZE_MATTERS))
		{
			const float fCombat = kUnit.getTotalModifiedCombatStrength100(true) / 100.0f;

			if (fCombat > 0)
			{
				szTempBuffer.Format(L"%.1f%c, ", fCombat, gDLL->getSymbolID(STRENGTH_CHAR));
				szBuffer.append(szTempBuffer);
			}
		}
		else
		{
			const int iCombat = kUnit.getTotalModifiedCombatStrength100(false) / 100;

			if (iCombat > 0)
			{
				szTempBuffer.Format(L"%d%c, ", iCombat, gDLL->getSymbolID(STRENGTH_CHAR));
				szBuffer.append(szTempBuffer);
			}
		}

		szTempBuffer.Format(L"%d%c", kUnit.getMoves(), gDLL->getSymbolID(MOVES_CHAR));
		szBuffer.append(szTempBuffer);

		if (kUnit.getAirRange() > 0)
		{
			szBuffer.append(L", ");
			szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_AIRRANGE", kUnit.getAirRange()));
		}

		if (pCity && getBugOptionBOOL("MiscHover__UnitExperience", true, "BUG_UNIT_EXPERIENCE_HOVER"))
		{
			setUnitExperienceHelp(szBuffer, L", ", eUnit, pCity, bConscript);
		}
	}

	//bTBUnitView1 = (Combat)
	if (bTBUnitView1)
	{
		if (kUnit.getFortRepel() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_FORT_REPEL", kUnit.getFortRepel()));
		}

		if (kUnit.getOverrun() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_OVERRUN", kUnit.getOverrun()));
		}
		//Basic Combat Modifiers
		if (kUnit.isNoDefensiveBonus())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_NO_DEFENSE_BONUSES"));
		}

		if (kUnit.getAttackCombatModifier() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_ATTACK_MODIFIER", kUnit.getAttackCombatModifier()));
		}

		if (kUnit.getDefenseCombatModifier() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_DEFENSE_MODIFIER", kUnit.getDefenseCombatModifier()));
		}

		if (kUnit.getCityAttackModifier() == kUnit.getCityDefenseModifier())
		{
			if (kUnit.getCityAttackModifier() != 0)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_CITY_STRENGTH_MOD", kUnit.getCityAttackModifier()));
			}
		}
		else
		{
			if (kUnit.getCityAttackModifier() != 0)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_CITY_ATTACK_MOD", kUnit.getCityAttackModifier()));
			}

			if (kUnit.getCityDefenseModifier() != 0)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_CITY_DEFENSE_MOD", kUnit.getCityDefenseModifier()));
			}
		}

		for (int iI = 0; iI < NUM_DOMAIN_TYPES; ++iI)
		{
			if (kUnit.getDomainModifier(iI) != 0)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_MOD_VS_TYPE_NO_LINK", kUnit.getDomainModifier(iI),  GC.getDomainInfo((DomainTypes)iI).getTextKeyWide()));
			}
		}

		if (kUnit.getHillsDefenseModifier() == kUnit.getHillsAttackModifier())
		{
			if (kUnit.getHillsAttackModifier() != 0)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_HILLS_STRENGTH", kUnit.getHillsAttackModifier()));
			}
		}
		else
		{
			if (kUnit.getHillsAttackModifier() != 0)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_HILLS_ATTACK", kUnit.getHillsAttackModifier()));
			}

			if (kUnit.getHillsDefenseModifier() != 0)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_HILLS_DEFENSE", kUnit.getHillsDefenseModifier()));
			}
		}

		bFirst = true;
		for (int iI = 0; iI < GC.getNumTerrainInfos(); ++iI)
		{
			if (kUnit.getTerrainDefenseModifier(iI) != 0)
			{
				if (!bFirst)
				{
					szBuffer.append(gDLL->getText("TXT_KEY_COMMA"));
				}
				if (bFirst)
				{
					szBuffer.append(NEWLINE);
					bFirst = false;
				}
				szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_DEFENSE", kUnit.getTerrainDefenseModifier(iI), GC.getTerrainInfo((TerrainTypes) iI).getTextKeyWide()));
			}
		}

		bFirst = true;
		for (int iI = 0; iI < GC.getNumTerrainInfos(); ++iI)
		{
			if (kUnit.getTerrainAttackModifier(iI) != 0)
			{
				if (!bFirst)
				{
					szBuffer.append(gDLL->getText("TXT_KEY_COMMA"));
				}
				if (bFirst)
				{
					szBuffer.append(NEWLINE);
					bFirst = false;
				}
				szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_ATTACK", kUnit.getTerrainAttackModifier(iI), GC.getTerrainInfo((TerrainTypes) iI).getTextKeyWide()));
			}
		}

		bFirst = true;
		for (int iI = 0; iI < GC.getNumFeatureInfos(); ++iI)
		{
			if (kUnit.getFeatureDefenseModifier(iI) != 0)
			{
				if (!bFirst)
				{
					szBuffer.append(gDLL->getText("TXT_KEY_COMMA"));
				}
				if (bFirst)
				{
					szBuffer.append(NEWLINE);
					bFirst = false;
				}
				szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_DEFENSE", kUnit.getFeatureDefenseModifier(iI), GC.getFeatureInfo((FeatureTypes) iI).getTextKeyWide()));
			}
		}

		bFirst = true;
		for (int iI = 0; iI < GC.getNumFeatureInfos(); ++iI)
		{
			if (kUnit.getFeatureAttackModifier(iI) != 0)
			{
				if (!bFirst)
				{
					szBuffer.append(gDLL->getText("TXT_KEY_COMMA"));
				}
				if (bFirst)
				{
					szBuffer.append(NEWLINE);
					bFirst = false;
				}
				szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_ATTACK", kUnit.getFeatureAttackModifier(iI), GC.getFeatureInfo((FeatureTypes) iI).getTextKeyWide()));
			}
		}

		bFirst = true;
		foreach_(const STD_PAIR(UnitTypes, int)& modifier, kUnit.getUnitAttackModifiers())
		{
			if (!bFirst)
			{
				szBuffer.append(gDLL->getText("TXT_KEY_COMMA"));
			}
			else
			{
				szBuffer.append(NEWLINE);
				bFirst = false;
			}
			szBuffer.append(
				gDLL->getText(
					modifier.second == kUnit.getUnitDefenseModifiers().getValue(modifier.first) ? "TXT_KEY_UNITHELP_MOD_VS_TYPE" : "TXT_KEY_UNITHELP_ATTACK_MOD_VS_CLASS",
					modifier.second, CvWString(GC.getUnitInfo(modifier.first).getType()).c_str(), GC.getUnitInfo(modifier.first).getTextKeyWide()
				)
			);
		}

		bFirst = true;
		foreach_(const STD_PAIR(UnitTypes, int)& modifier, kUnit.getUnitDefenseModifiers())
		{
			if (!bFirst)
			{
				szBuffer.append(gDLL->getText("TXT_KEY_COMMA"));
			}
			else
			{
				szBuffer.append(NEWLINE);
				bFirst = false;
			}
			szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_DEFENSE_MOD_VS_CLASS", modifier.second,
				CvWString(GC.getUnitInfo(modifier.first).getType()).c_str(), GC.getUnitInfo(modifier.first).getTextKeyWide()));
		}

		bFirst = true;
		for (int iI = 0; iI < GC.getNumUnitCombatInfos(); ++iI)
		{
			if (kUnit.getUnitCombatModifier(iI) != 0)
			{
				if (!bFirst)
				{
					szBuffer.append(gDLL->getText("TXT_KEY_COMMA"));
				}
				if (bFirst)
				{
					szBuffer.append(NEWLINE);
					bFirst = false;
				}
				szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_MOD_VS_TYPE", kUnit.getUnitCombatModifier(iI), CvWString(GC.getUnitCombatInfo((UnitCombatTypes) iI).getType()).GetCString(), GC.getUnitCombatInfo((UnitCombatTypes) iI).getTextKeyWide()));
			}
		}

		if (kUnit.getReligiousCombatModifier() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_RELIGIOUS_COMBAT_MODIFIER", kUnit.getReligiousCombatModifier()));
		}

		if (kUnit.getVSBarbs() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_VSBARBS", kUnit.getVSBarbs()));
		}

		if (kUnit.getAnimalCombatModifier() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_ANIMAL_COMBAT_MOD", kUnit.getAnimalCombatModifier()));
		}

		//Advanced Combat Modifiers
			//Armor
		if (kUnit.getArmor() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_ARMOR_BASE", kUnit.getArmor()));
		}

		bFirst = true;
		for (int iI = 0; iI < GC.getNumUnitCombatInfos(); ++iI)
		{
			if (kUnit.getArmorVSUnitCombatType(iI) != 0)
			{
				if (!bFirst)
				{
					szBuffer.append(gDLL->getText("TXT_KEY_COMMA"));
				}
				if (bFirst)
				{
					szBuffer.append(NEWLINE);
					bFirst = false;
				}
				szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_ARMOR_VS_TYPE", kUnit.getArmorVSUnitCombatType(iI), CvWString(GC.getUnitCombatInfo((UnitCombatTypes) iI).getType()).GetCString(), GC.getUnitCombatInfo((UnitCombatTypes) iI).getTextKeyWide()));
			}
		}

			//puncture
		if (kUnit.getPuncture() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_PUNCTURE", kUnit.getPuncture()));
		}

		bFirst = true;
		for (int iI = 0; iI < GC.getNumUnitCombatInfos(); ++iI)
		{
			if (kUnit.getPunctureVSUnitCombatType(iI) != 0)
			{
				if (!bFirst)
				{
					szBuffer.append(gDLL->getText("TXT_KEY_COMMA"));
				}
				if (bFirst)
				{
					szBuffer.append(NEWLINE);
					bFirst = false;
				}
				szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_PUNCTURE_VS_TYPE", kUnit.getPunctureVSUnitCombatType(iI), CvWString(GC.getUnitCombatInfo((UnitCombatTypes) iI).getType()).GetCString(), GC.getUnitCombatInfo((UnitCombatTypes) iI).getTextKeyWide()));
			}
		}

		//damage
		if (kUnit.getDamageModifier() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_DAMAGE_MODIFIER", kUnit.getDamageModifier()));
		}

		//dodge
		if (kUnit.getDodgeModifier() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_DODGE_MODIFIER", kUnit.getDodgeModifier()));
		}

		bFirst = true;
		for (int iI = 0; iI < GC.getNumUnitCombatInfos(); ++iI)
		{
			if (kUnit.getDodgeVSUnitCombatType(iI) != 0)
			{
				if (!bFirst)
				{
					szBuffer.append(gDLL->getText("TXT_KEY_COMMA"));
				}
				if (bFirst)
				{
					szBuffer.append(NEWLINE);
					bFirst = false;
				}
				szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_DODGE_VS_TYPE", kUnit.getDodgeVSUnitCombatType(iI), CvWString(GC.getUnitCombatInfo((UnitCombatTypes) iI).getType()).GetCString(), GC.getUnitCombatInfo((UnitCombatTypes) iI).getTextKeyWide()));
			}
		}

			//precision
		if (kUnit.getPrecisionModifier() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_PRECISION_MODIFIER", kUnit.getPrecisionModifier()));
		}

		bFirst = true;
		for (int iI = 0; iI < GC.getNumUnitCombatInfos(); ++iI)
		{
			if (kUnit.getPrecisionVSUnitCombatType(iI) != 0)
			{
				if (!bFirst)
				{
					szBuffer.append(gDLL->getText("TXT_KEY_COMMA"));
				}
				if (bFirst)
				{
					szBuffer.append(NEWLINE);
					bFirst = false;
				}
				szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_PRECISION_VS_TYPE", kUnit.getPrecisionVSUnitCombatType(iI), CvWString(GC.getUnitCombatInfo((UnitCombatTypes)iI).getType()).GetCString(), GC.getUnitCombatInfo((UnitCombatTypes) iI).getTextKeyWide()));
			}
		}

		if (kUnit.getCombatModifierPerSizeMore() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_COMBAT_MOD_PER_SIZE_MORE", kUnit.getCombatModifierPerSizeMore()));
		}

		if (kUnit.getCombatModifierPerSizeLess() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_COMBAT_MOD_PER_SIZE_LESS", kUnit.getCombatModifierPerSizeLess()));
		}

		if (kUnit.getCombatModifierPerVolumeMore() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_COMBAT_MOD_PER_VOLUME_MORE", kUnit.getCombatModifierPerVolumeMore()));
		}

		if (kUnit.getCombatModifierPerVolumeLess() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_COMBAT_MOD_PER_VOLUME_LESS", kUnit.getCombatModifierPerVolumeLess()));
		}

		//Withdrawal
		if (kUnit.getCombatLimit() < GC.getMAX_HIT_POINTS() && kUnit.getCombat() > 0 && !kUnit.isOnlyDefensive())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_COMBAT_LIMIT", (100 * kUnit.getCombatLimit()) / GC.getMAX_HIT_POINTS()));
		}

		if (kUnit.getAirCombatLimit() < GC.getMAX_HIT_POINTS() && kUnit.getAirCombat() > 0 && !kUnit.isOnlyDefensive())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_COMBAT_LIMIT", (100 * kUnit.getAirCombatLimit()) / GC.getMAX_HIT_POINTS()));
		}

		if (kUnit.getWithdrawalProbability() > 0)
		{
			if(kUnit.isSpy())
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_ESCAPE_SPY", kUnit.getWithdrawalProbability()));
			}
			else
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_WITHDRAWL_PROBABILITY", kUnit.getWithdrawalProbability()));
			}
		}

		bFirst = true;
		for (int iI = 0; iI < GC.getNumUnitCombatInfos(); ++iI)
		{
			if (kUnit.getWithdrawVSUnitCombatType(iI) != 0)
			{
				if (!bFirst)
				{
					szBuffer.append(gDLL->getText("TXT_KEY_COMMA"));
				}
				if (bFirst)
				{
					szBuffer.append(NEWLINE);
					bFirst = false;
				}
				szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_WITHDRAW_VS_TYPE", kUnit.getWithdrawVSUnitCombatType(iI), CvWString(GC.getUnitCombatInfo((UnitCombatTypes)iI).getTextKeyWide()).GetCString(), GC.getUnitCombatInfo((UnitCombatTypes) iI).getTextKeyWide()));
			}
		}

		if (kUnit.getEarlyWithdraw() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_EARLY_WITHDRAW", kUnit.getEarlyWithdraw()));
		}
#ifdef BATTLEWORN
		if (kUnit.getWithdrawAdjperAtt() > 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_REFLEXES", kUnit.getWithdrawAdjperAtt()));
		}

		if (kUnit.getWithdrawAdjperAtt() < 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_FRAYS", kUnit.getWithdrawAdjperAtt()));
		}
#endif // BATTLEWORN
		//Pursuit
		if (kUnit.getPursuit() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_PURSUIT", kUnit.getPursuit()));
		}

		bFirst = true;
		for (int iI = 0; iI < GC.getNumUnitCombatInfos(); ++iI)
		{
			if (kUnit.getPursuitVSUnitCombatType(iI) != 0)
			{
				if (!bFirst)
				{
					szBuffer.append(gDLL->getText("TXT_KEY_COMMA"));
				}
				if (bFirst)
				{
					szBuffer.append(NEWLINE);
					bFirst = false;
				}
				szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_PURSUIT_VS_TYPE", kUnit.getPursuitVSUnitCombatType(iI), CvWString(GC.getUnitCombatInfo((UnitCombatTypes)iI).getType()).GetCString(), GC.getUnitCombatInfo((UnitCombatTypes) iI).getTextKeyWide()));
			}
		}

		//Repel
		if (kUnit.getRepel() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_REPEL", kUnit.getRepel()));
		}

		if (kUnit.getRepelRetries() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_REPEL_RETRIES", kUnit.getRepelRetries()));
		}

		bFirst = true;
		for (int iI = 0; iI < GC.getNumUnitCombatInfos(); ++iI)
		{
			if (kUnit.getRepelVSUnitCombatType(iI) != 0)
			{
				if (!bFirst)
				{
					szBuffer.append(gDLL->getText("TXT_KEY_COMMA"));
				}
				if (bFirst)
				{
					szBuffer.append(NEWLINE);
					bFirst = false;
				}
				szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_REPEL_VS_TYPE", kUnit.getRepelVSUnitCombatType(iI), CvWString(GC.getUnitCombatInfo((UnitCombatTypes)iI).getType()).GetCString(), GC.getUnitCombatInfo((UnitCombatTypes) iI).getTextKeyWide()));
			}
		}

		//Knockback
		if (kUnit.getKnockback() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_KNOCKBACK", kUnit.getKnockback()));
		}

		if (kUnit.getKnockbackRetries() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_KNOCKBACK_RETRIES", kUnit.getKnockbackRetries()));
		}

		bFirst = true;
		for (int iI = 0; iI < GC.getNumUnitCombatInfos(); ++iI)
		{
			if (kUnit.getKnockbackVSUnitCombatType(iI) != 0)
			{
				if (!bFirst)
				{
					szBuffer.append(gDLL->getText("TXT_KEY_COMMA"));
				}
				if (bFirst)
				{
					szBuffer.append(NEWLINE);
					bFirst = false;
				}
				szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_KNOCKBACK_VS_TYPE", kUnit.getKnockbackVSUnitCombatType(iI), CvWString(GC.getUnitCombatInfo((UnitCombatTypes)iI).getType()).GetCString(), GC.getUnitCombatInfo((UnitCombatTypes) iI).getTextKeyWide()));
			}
		}

		//Unyielding
		if (kUnit.getUnyielding() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_UNYIELDING", kUnit.getUnyielding()));
		}

		//Movement pertaining to Combat
		if (kUnit.isStampede())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_STAMPEDE"));
		}

		if (kUnit.isOnslaught())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_ONSLAUGHT"));
		}

		//First Strikes
		if (kUnit.getFirstStrikes() + kUnit.getChanceFirstStrikes() > 0)
		{
			if (kUnit.getChanceFirstStrikes() == 0)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_FIRST_STRIKES", kUnit.getFirstStrikes()));
			}
			else
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_FIRST_STRIKE_CHANCES", kUnit.getFirstStrikes(), kUnit.getFirstStrikes() + kUnit.getChanceFirstStrikes()));
			}
		}

		//Immunity to First Strikes
		if (kUnit.isFirstStrikeImmune())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_FIRST_STRIKES_IMMUNE"));
		}

		//Siege
			//Breakdown Chance
		if (kUnit.getBreakdownChance() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_BREAKDOWN_CHANCE", kUnit.getBreakdownChance()));
		}
			//Breakdown Damage
		if (kUnit.getBreakdownDamage() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_BREAKDOWN_DAMAGE", kUnit.getBreakdownDamage()));
		}

			//Attack Only Cities
		if (kUnit.isAttackOnlyCities())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_CAN_ONLY_ATTACK_CITIES"));
		}

			//Ignore No Entry
		if (kUnit.isIgnoreNoEntryLevel())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_CAN_ALWAYS_ATTACK_CITIES"));
		}

			//Bombard
		if (GC.isDCM_RANGE_BOMBARD())
		{
			if (kUnit.getDCMBombRange() > 0 || kUnit.getDCMBombAccuracy() > 0)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_IS_DCM_BOMBARD"));
			}
			if (kUnit.getDCMBombRange() > 0)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_DCM_BOMB_RANGE", kUnit.getDCMBombRange()));
			}
			if (kUnit.getDCMBombAccuracy() > 0)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_DCM_BOMB_ACCURACY", kUnit.getDCMBombAccuracy()));
			}
			if (kUnit.getRBombardDamage() > 0)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_DCM_BOMB_DAMAGE", kUnit.getRBombardDamage()));
			}
			if (kUnit.getRBombardDamageLimit() > 0)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_DCM_BOMB_DAMAGE_LIMIT", kUnit.getRBombardDamageLimit()));
			}
			if (kUnit.getRBombardDamageMaxUnits() > 0)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_DCM_BOMB_DAMAGE_MAX_UNITS", kUnit.getRBombardDamageMaxUnits()));
			}
		}

		if (kUnit.getBombardRate() > 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_BOMBARD_RATE", ((kUnit.getBombardRate() * 100) / GC.getMAX_CITY_DEFENSE_DAMAGE())));
		}

		if (kUnit.getBombRate() > 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_BOMB_RATE", ((kUnit.getBombRate() * 100) / GC.getMAX_CITY_DEFENSE_DAMAGE())));
		}

			//Collateral
		if (kUnit.getCollateralDamage() > 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_COLLATERAL_DAMAGE_REVDCM", 100 * kUnit.getCollateralDamageLimit() / GC.getMAX_HIT_POINTS(), kUnit.getCollateralDamageMaxUnits()));
		}

		//Flanking
		bFirst = true;
		foreach_(const STD_PAIR(UnitTypes, int)& modifier, kUnit.getFlankingStrikeUnits())
		{
			if (modifier.second > 0)
			{
				if (bFirst)
				{
					szBuffer.append(NEWLINE);
					bFirst = false;
				}
				else
				{
					szBuffer.append(L", ");
				}
				szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_COMBAT_FLANKING_STRIKES", modifier.second, GC.getUnitInfo(modifier.first).getDescription()));
			}
		}

		bFirst = true;
		for (int iI = 0; iI < GC.getNumUnitCombatInfos(); ++iI)
		{
			int iFlank = kUnit.getFlankingStrengthbyUnitCombatType(iI);
			if (iFlank > 0)
			{
				if (bFirst)
				{
					szBuffer.append(NEWLINE);
					bFirst = false;
				}
				else
				{
					szBuffer.append(L", ");
				}

				szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_COMBAT_FLANKING_STRIKES", iFlank, GC.getUnitCombatInfo((UnitCombatTypes)iI).getDescription()));
			}
		}

		//Interception and Evasion
		if (kUnit.getInterceptionProbability() > 0)
		{
			if(kUnit.isSpy())
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_INTERCEPT_AIRCRAFT_SPY", kUnit.getInterceptionProbability()));
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_INTERCEPT_AIRCRAFT_SPY_COUNTER", kUnit.getInterceptionProbability() * 5));
			}
			else
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_INTERCEPT_AIRCRAFT", kUnit.getInterceptionProbability()));
			}
		}

		if (kUnit.getEvasionProbability() > 0)
		{
			if(kUnit.isSpy())
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_EVADE_INTERCEPTION_SPY", kUnit.getEvasionProbability()));
			}
			else
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_EVADE_INTERCEPTION", kUnit.getEvasionProbability()));
			}
		}

		if (GC.isDCM_FIGHTER_ENGAGE())
		{
			if (kUnit.getDCMFighterEngage())
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_IS_FIGHTER_ENGAGE"));
			}
		}

		//Surround and Destroy
		if (game.isOption(GAMEOPTION_COMBAT_SURROUND_DESTROY))
		{
			if (kUnit.getUnnerve() != 0)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_UNNERVE", kUnit.getUnnerve()));
			}
			if (kUnit.getEnclose() != 0)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_ENCLOSE", kUnit.getEnclose()));
			}
			if (kUnit.getLunge() != 0)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_LUNGE", kUnit.getLunge()));
			}
			if (kUnit.getDynamicDefense() != 0)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_DYNAMIC_DEFENSE", kUnit.getDynamicDefense()));
			}
		}

		//Power Shots
		if (kUnit.getPowerShots() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_POWER_SHOTS", kUnit.getPowerShots()));
		}

		if (kUnit.getPowerShotCombatModifier() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_POWER_SHOT_COMBAT_MODIFIER", kUnit.getPowerShotCombatModifier()));
		}

		if (kUnit.getPowerShotPunctureModifier() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_POWER_SHOT_PUNCTURE_MODIFIER", kUnit.getPowerShotPunctureModifier()));
		}

		if (kUnit.getPowerShotPrecisionModifier() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_POWER_SHOT_PRECISION_MODIFIER", kUnit.getPowerShotPrecisionModifier()));
		}

		if (kUnit.getPowerShotCriticalModifier() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_POWER_SHOT_CRITICAL_MODIFIER", kUnit.getPowerShotCriticalModifier()));
		}

		//Stuns and afflictions
		//Critical
		if (kUnit.getCriticalModifier() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_CRITICAL_MODIFIER", kUnit.getCriticalModifier()));
		}

		bFirst = true;
		for (int iI = 0; iI < GC.getNumUnitCombatInfos(); ++iI)
		{
			if (kUnit.getCriticalVSUnitCombatType(iI) != 0)
			{
				if (!bFirst)
				{
					szBuffer.append(gDLL->getText("TXT_KEY_COMMA"));
				}
				if (bFirst)
				{
					szBuffer.append(NEWLINE);
					bFirst = false;
				}
				szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_CRITICAL_VS_TYPE", kUnit.getCriticalVSUnitCombatType(iI), CvWString(GC.getUnitCombatInfo((UnitCombatTypes) iI).getType()).GetCString(), GC.getUnitCombatInfo((UnitCombatTypes) iI).getTextKeyWide()));
			}
		}
		//Stun
		if (kUnit.getRoundStunProb() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_ROUND_STUN_PROB", kUnit.getRoundStunProb()));
		}

		bFirst = true;
		for (int iI = 0; iI < GC.getNumUnitCombatInfos(); ++iI)
		{
			if (kUnit.getRoundStunVSUnitCombatType(iI) != 0)
			{
				if (!bFirst)
				{
					szBuffer.append(gDLL->getText("TXT_KEY_COMMA"));
				}
				if (bFirst)
				{
					szBuffer.append(NEWLINE);
					bFirst = false;
				}
				szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_ROUND_STUN_VS_TYPE", kUnit.getRoundStunVSUnitCombatType(iI), CvWString(GC.getUnitCombatInfo((UnitCombatTypes) iI).getType()).GetCString(), GC.getUnitCombatInfo((UnitCombatTypes) iI).getTextKeyWide()));
			}
		}

		//Traps
		int iValue = 0;
		bFirst = true;
		for (int iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
		{
			iValue = kUnit.getTrapDisableUnitCombatType(iI);
			if (iValue != 0)
			{
				if (!bFirst)
				{
					szBuffer.append(gDLL->getText("TXT_KEY_COMMA"));
				}
				if (bFirst)
				{
					szBuffer.append(NEWLINE);
					bFirst = false;
				}
				szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_TRAP_DISABLE_TYPE", iValue, CvWString(GC.getUnitCombatInfo((UnitCombatTypes) iI).getType()).GetCString(), GC.getUnitCombatInfo((UnitCombatTypes) iI).getTextKeyWide()));
			}
		}
		iValue = 0;
		bFirst = true;
		for (int iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
		{
			iValue = kUnit.getTrapAvoidanceUnitCombatType(iI);
			if (iValue != 0)
			{
				if (!bFirst)
				{
					szBuffer.append(gDLL->getText("TXT_KEY_COMMA"));
				}
				if (bFirst)
				{
					szBuffer.append(NEWLINE);
					bFirst = false;
				}
				szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_TRAP_AVOID_TYPE", iValue, CvWString(GC.getUnitCombatInfo((UnitCombatTypes) iI).getType()).GetCString(), GC.getUnitCombatInfo((UnitCombatTypes) iI).getTextKeyWide()));
			}
		}
		iValue = 0;
		bFirst = true;
		for (int iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
		{
			iValue = kUnit.getTrapTriggerUnitCombatType(iI);
			if (iValue != 0)
			{
				if (!bFirst)
				{
					szBuffer.append(gDLL->getText("TXT_KEY_COMMA"));
				}
				if (bFirst)
				{
					szBuffer.append(NEWLINE);
					bFirst = false;
				}
				szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_TRAP_TRIGGER_TYPE", iValue, CvWString(GC.getUnitCombatInfo((UnitCombatTypes) iI).getType()).GetCString(), GC.getUnitCombatInfo((UnitCombatTypes) iI).getTextKeyWide()));
			}
		}
		bFirst = true;
		for (int iI = 0; iI < kUnit.getNumTrapSetWithPromotionTypes(); iI++)
		{
			PromotionTypes eTrapPromo = (PromotionTypes)kUnit.getTrapSetWithPromotionType(iI);
			if (iValue != 0)
			{
				if (!bFirst)
				{
					szBuffer.append(gDLL->getText("TXT_KEY_COMMA"));
				}
				if (bFirst)
				{
					szBuffer.append(NEWLINE);
					bFirst = false;
				}
				szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_TRAP_PROMOTION_TYPE", GC.getPromotionInfo(eTrapPromo).getTextKeyWide()));
			}
		}
		bFirst = true;
		for (int iI = 0; iI < kUnit.getNumTrapImmunityUnitCombatTypes(); iI++)
		{
			UnitCombatTypes eTrapUnitCombat = (UnitCombatTypes)kUnit.getTrapImmunityUnitCombatType(iI);
			if (iValue != 0)
			{
				if (!bFirst)
				{
					szBuffer.append(gDLL->getText("TXT_KEY_COMMA"));
				}
				if (bFirst)
				{
					szBuffer.append(NEWLINE);
					bFirst = false;
				}
				szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_TRAP_IMMUNE_TYPE", GC.getUnitCombatInfo(eTrapUnitCombat).getTextKeyWide()));
			}
		}
		int iTrapMin = kUnit.getTrapDamageMin();
		int iTrapMax = kUnit.getTrapDamageMax();
		if (iTrapMax > 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_TRAP_DAMAGE", iTrapMin, iTrapMax));
		}

		int iNumTriggers = kUnit.getNumTriggers();
		if (iNumTriggers > 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_TRAP_NUM_TRIGGERS", iNumTriggers));
		}

		if (kUnit.isTriggerBeforeAttack())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_TRAP_TRIGGER_BEFORE_ATTACK"));
		}

		int iComplexity = kUnit.getTrapComplexity();
		if (iComplexity > 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_TRAP_COMPLEXITY", iComplexity));
		}
#ifdef OUTBREAKS_AND_AFFLICTIONS
		//Afflict on Attack
		for (int iI = 0; iI < kUnit.getNumAfflictOnAttackTypes(); ++iI)
		{
			PromotionLineTypes eAfflictionLine = ((PromotionLineTypes)kUnit.getAfflictOnAttackType(iI).eAfflictionLine);
			int iProbability = kUnit.getAfflictOnAttackType(iI).iProbability;
			if (kUnit.getAfflictOnAttackType(iI).iImmediate > 0)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_AFFLICT_ON_ATTACK_IMMEDIATE", iProbability, GC.getPromotionLineInfo(eAfflictionLine).getDescription()));
			}
			else
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_AFFLICT_ON_ATTACK", iProbability, GC.getPromotionLineInfo(eAfflictionLine).getDescription()));
			}
		}
#endif

		if (kUnit.getPoisonProbabilityModifier() > 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_POISON_PROB", kUnit.getPoisonProbabilityModifier()));
		}

		if (kUnit.getPoisonProbabilityModifier() < 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_POISON_PROB_NEG", kUnit.getPoisonProbabilityModifier()));
		}

			//Cold Dmg
		if (kUnit.isDealsColdDamage())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_DEALS_COLD_DAMAGE"));
		}
#ifdef BATTLEWORN
		//Str Per
		if (kUnit.getStrAdjperRnd() > 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_RAGE", kUnit.getStrAdjperRnd()));
		}

		if (kUnit.getStrAdjperRnd() < 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_FATIGUE", kUnit.getStrAdjperRnd()));
		}

		if (kUnit.getStrAdjperAtt() > 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_RAMPAGE", kUnit.getStrAdjperAtt()));
		}

		if (kUnit.getStrAdjperAtt() < 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_TIRES", kUnit.getStrAdjperAtt()));
		}

		if (kUnit.getStrAdjperDef() > 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_DETERMINATION", kUnit.getStrAdjperDef()));
		}

		if (kUnit.getStrAdjperDef() < 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_DEMORALIZATION", kUnit.getStrAdjperDef()));
		}
#endif // BATTLEWORN
	}

	//bTBUnitView2 = (Civil)
	if (bTBUnitView2)
	{
		{
			const int iCargoValue = kUnit.getCargoSpace();
			//Cargo
			if (iCargoValue > 0)
			{
				szBuffer.append(NEWLINE);

				if (game.isOption(GAMEOPTION_COMBAT_SIZE_MATTERS))
				{
					szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_CARGO_SPACE_BASE_SM", iCargoValue));

					if (kUnit.getSpecialCargo() != NO_SPECIALUNIT)
					{
						szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_CARRIES", GC.getSpecialUnitInfo((SpecialUnitTypes) kUnit.getSpecialCargo()).getTextKeyWide()));
					}
					if (kUnit.getSMNotSpecialCargo() != NO_SPECIALUNIT)
					{
						szBuffer.append(gDLL->getText("TXT_KEY_PROMOHELP_CHANGE_NOT_SPECIAL_CARGO", GC.getSpecialUnitInfo((SpecialUnitTypes) kUnit.getSMNotSpecialCargo()).getTextKeyWide()));
					}
				}
				else
				{
					szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_CARGO_SPACE_FOREIGN", iCargoValue));

					if (kUnit.getSpecialCargo() != NO_SPECIALUNIT)
					{
						szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_CARRIES", GC.getSpecialUnitInfo((SpecialUnitTypes) kUnit.getSpecialCargo()).getTextKeyWide()));
					}
				}
			}
		}
#ifdef OUTBREAKS_AND_AFFLICTIONS
		if (game.isOption(GAMEOPTION_COMBAT_OUTBREAKS_AND_AFFLICTIONS))
		{
			int iAidChange = 0;
			//Curing, resisting and overcoming afflictions
			for (int iI=0; iI < GC.getNumPropertyInfos(); iI++)
			{
				iAidChange = kUnit.getAidChange(iI);
				if (iAidChange != 0)
				{
					PropertyTypes eProperty = (PropertyTypes)iI;
					szBuffer.append(NEWLINE);
					szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_AID", GC.getPropertyInfo(eProperty).getDescription(), iAidChange));
				}
			}

			bFirst = true;
			for (int iI = 0; iI < kUnit.getNumCureAfflictionTypes(); ++iI)
			{
				PromotionLineTypes eAfflictionLine = ((PromotionLineTypes)kUnit.getCureAfflictionType(iI));
				if (!bFirst)
				{
					szBuffer.append(gDLL->getText("TXT_KEY_COMMA"));
				}
				if (bFirst)
				{
					szBuffer.append(NEWLINE);
					bFirst = false;
				}
				szBuffer.append(gDLL->getText("TXT_KEY_CURE_AFFLICTION", GC.getPromotionLineInfo(eAfflictionLine).getDescription()));
			}

			bFirst = true;
			for (int iI = 0; iI < kUnit.getNumAfflictionFortitudeModifiers(); iI++)
			{
				PromotionLineTypes eAfflictionLine = ((PromotionLineTypes)kUnit.getAfflictionFortitudeModifier(iI).ePromotionLine);
				if (kUnit.getAfflictionFortitudeModifier(iI).iModifier > 0)
				{
					if (!bFirst)
					{
						szBuffer.append(gDLL->getText("TXT_KEY_COMMA"));
					}
					if (bFirst)
					{
						szBuffer.append(NEWLINE);
						bFirst = false;
					}
					szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_AFFLICTION_FORTITUDE_MODIFIER_POSITIVE", kUnit.getAfflictionFortitudeModifier(iI).iModifier, GC.getPromotionLineInfo(eAfflictionLine).getDescription()));
				}

				if (kUnit.getAfflictionFortitudeModifier(iI).iModifier < 0)
				{
					if (!bFirst)
					{
						szBuffer.append(gDLL->getText("TXT_KEY_COMMA"));
					}
					if (bFirst)
					{
						szBuffer.append(NEWLINE);
						bFirst = false;
					}
					szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_AFFLICTION_FORTITUDE_MODIFIER_NEGATIVE", kUnit.getAfflictionFortitudeModifier(iI).iModifier, GC.getPromotionLineInfo(eAfflictionLine).getDescription()));
				}
			}

			//Resistances
			//Fortitude
			if (kUnit.getFortitude() != 0)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_FORTITUDE", kUnit.getFortitude()));
			}
		}
#endif // OUTBREAKS_AND_AFFLICTIONS

		//Endurance
		if (kUnit.getEndurance() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_ENDURANCE", kUnit.getEndurance()));
		}
		//Immunity to Cold
		if (kUnit.isColdImmune())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_COLD_IMMUNE"));
		}
		//Collateral Resistance
		bFirst = true;
		for (int iI = 0; iI < GC.getNumUnitCombatInfos(); ++iI)
		{
			if (kUnit.getUnitCombatCollateralImmune(iI))
			{
				if (!bFirst)
				{
					szBuffer.append(gDLL->getText("TXT_KEY_COMMA"));
				}
				if (bFirst)
				{
					szBuffer.append(NEWLINE);
					bFirst = false;
				}
				szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_COLLATERAL_IMMUNE", CvWString(GC.getUnitCombatInfo((UnitCombatTypes)iI).getType()).GetCString(), GC.getUnitCombatInfo((UnitCombatTypes)iI).getTextKeyWide()));
			}
		}

		//Capture interactions
		if (kUnit.isNoCapture())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_CANNOT_CAPTURE"));
		}

		if (kUnit.getCaptureProbabilityModifier() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_CAPTURE_PROBABILITY_MODIFIER", kUnit.getCaptureProbabilityModifier()));
		}

		if (kUnit.getCaptureResistanceModifier() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_CAPTURE_RESISTANCE_MODIFIER", kUnit.getCaptureResistanceModifier()));
		}

		//Taunt
		if (kUnit.getTaunt() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_TAUNT", kUnit.getTaunt()));
		}


		if (kUnit.getCultureGarrisonValue() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_TEMP_REVOLT_PROTECTION", kUnit.getCultureGarrisonValue()));
		}
		//Targeting and Defending vs types
		szTempBuffer.clear();
		bFirst = true;
		for (int iI = 0; iI < kUnit.getNumTargetUnits(); ++iI)
		{
			const UnitTypes eUnitX = (UnitTypes) kUnit.getTargetUnit(iI);

			if (bFirst)
			{
				bFirst = false;
			}
			else
			{
				szTempBuffer += L", ";
			}
			szTempBuffer += CvWString::format(L"<link=%s>%s</link>", CvWString(GC.getUnitInfo(eUnitX).getType()).GetCString(), GC.getUnitInfo(eUnitX).getDescription());
		}

		if (!bFirst)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_TARGETS_UNIT_FIRST", szTempBuffer.GetCString()));
		}

		szTempBuffer.clear();
		bFirst = true;
		for (int iI = 0; iI < kUnit.getNumDefendAgainstUnits(); ++iI)
		{
			const UnitTypes eUnitX = (UnitTypes)kUnit.getDefendAgainstUnit(iI);

			if (bFirst)
			{
				bFirst = false;
			}
			else
			{
				szTempBuffer += L", ";
			}
			szTempBuffer += CvWString::format(L"<link=%s>%s</link>", CvWString(GC.getUnitInfo(eUnitX).getType()).GetCString(), GC.getUnitInfo(eUnitX).getDescription());
		}

		if (!bFirst)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_DEFENDS_UNIT_FIRST", szTempBuffer.GetCString()));
		}

		szTempBuffer.clear();
		bFirst = true;
		for (int iI = 0; iI < GC.getNumUnitCombatInfos(); ++iI)
		{
			if (kUnit.getTargetUnitCombat(iI))
			{
				if (bFirst)
				{
					bFirst = false;
				}
				else
				{
					szTempBuffer += L", ";
				}
				szTempBuffer += CvWString::format(L"<link=%s>%s</link>", CvWString(GC.getUnitCombatInfo((UnitCombatTypes)iI).getType()).GetCString(), GC.getUnitCombatInfo((UnitCombatTypes)iI).getDescription());
			}
		}

		if (!bFirst)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_TARGETS_UNIT_FIRST", szTempBuffer.GetCString()));
		}

		szTempBuffer.clear();
		bFirst = true;
		for (int iI = 0; iI < GC.getNumUnitCombatInfos(); ++iI)
		{
			if (kUnit.getDefenderUnitCombat(iI))
			{
				if (bFirst)
				{
					bFirst = false;
				}
				else
				{
					szTempBuffer += L", ";
				}
				szTempBuffer += CvWString::format(L"<link=%s>%s</link>", CvWString(GC.getUnitCombatInfo((UnitCombatTypes)iI).getType()).GetCString(), GC.getUnitCombatInfo((UnitCombatTypes)iI).getDescription());
			}
		}

		if (!bFirst)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_DEFENDS_UNIT_FIRST", szTempBuffer.GetCString()));
		}

		//Worker details
		iCount = kUnit.getNumBuilds();

		if (iCount > 32)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_IMPROVE_PLOTS"));
		}
		else
		{
			bFirst = true;
			for (int iI = 0; iI < iCount; ++iI)
			{
				szTempBuffer.Format(L"%s%s ", NEWLINE, gDLL->getText("TXT_KEY_UNITHELP_CAN").c_str());
				setListHelp(szBuffer, szTempBuffer, GC.getBuildInfo((BuildTypes)kUnit.getBuild(iI)).getDescription(), L", ", bFirst);
				bFirst = false;
			}
		}

		for (int iI = 0; iI < GC.getNumTerrainInfos(); iI++)
		{
			if (kUnit.getTerrainWorkRateModifierType(iI) != 0)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_WORK", kUnit.getTerrainWorkRateModifierType(iI), GC.getTerrainInfo((TerrainTypes)iI).getTextKeyWide()));
			}
		}
		for (int iI = 0; iI < GC.getNumFeatureInfos(); iI++)
		{
			if (kUnit.getFeatureWorkRateModifierType(iI) != 0)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_WORK", kUnit.getFeatureWorkRateModifierType(iI), GC.getFeatureInfo((FeatureTypes)iI).getTextKeyWide()));
			}
		}
		for (int iI = 0; iI < GC.getNumBuildInfos(); iI++)
		{
			if (kUnit.getBuildWorkRateModifierType(iI) != 0)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_WORK", kUnit.getBuildWorkRateModifierType(iI), GC.getBuildInfo((BuildTypes)iI).getTextKeyWide()));
			}
		}

		if (kUnit.getHillsWorkModifier() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_HILLS_WORK", kUnit.getHillsWorkModifier()));
		}

		if (kUnit.getPeaksWorkModifier() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_PEAKS_WORK", kUnit.getPeaksWorkModifier()));
		}

#ifdef STRENGTH_IN_NUMBERS
		//Strength in Numbers offered support
		if (game.isOption(GAMEOPTION_COMBAT_STRENGTH_IN_NUMBERS))
		{
			if (kUnit.getFrontSupportPercent() > 0)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_FRONT_SUPPORT_PERCENT", kUnit.getFrontSupportPercent()));
			}
			if (kUnit.getShortRangeSupportPercent() > 0)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_SHORT_RANGE_SUPPORT_PERCENT", kUnit.getShortRangeSupportPercent()));
			}
			if (kUnit.getMediumRangeSupportPercent() > 0)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_MEDIUM_RANGE_SUPPORT_PERCENT", kUnit.getMediumRangeSupportPercent()));
			}
			if (kUnit.getLongRangeSupportPercent() > 0)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_LONG_RANGE_SUPPORT_PERCENT", kUnit.getLongRangeSupportPercent()));
			}
			if (kUnit.getFlankSupportPercent() > 0)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_FLANK_SUPPORT_PERCENT", kUnit.getFlankSupportPercent()));
			}
		}
#endif
		//Property Manipulators
		kUnit.getPropertyManipulators()->buildDisplayString(szBuffer);

		//Golden Age
		if (kUnit.isGoldenAge())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_GOLDEN_AGE"));
		}

		//Discover
		if ((kUnit.getBaseDiscover() > 0) || (kUnit.getDiscoverMultiplier() > 0))
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_DISCOVER_TECH"));
		}

		//Hurry Production
		if ((kUnit.getBaseHurry() > 0) || (kUnit.getHurryMultiplier() > 0))
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_HURRY_PRODUCTION"));
		}

		//Hurry Food
		int iFood = kUnit.getBaseFoodChange();
		if (iFood > 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_HURRY_FOOD", iFood));
		}

		//Trade Mission
		int iBase = kUnit.getBaseTrade();
		int iMult = kUnit.getTradeMultiplier();
		if ((iBase > 0) || (iMult > 0))
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_TRADE_MISSION", iBase, iMult));
		}

		//Cultural Great Work
		if (kUnit.getGreatWorkCulture() > 0)
		{
			int iCulture = kUnit.getGreatWorkCulture();
			if (NO_GAMESPEED != game.getGameSpeedType())
			{
				iCulture *= GC.getGameSpeedInfo(game.getGameSpeedType()).getSpeedPercent();
				iCulture /= 100;
			}

			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_GREAT_WORK", iCulture));
		}

		//Espionage
		if (kUnit.getEspionagePoints() > 0)
		{
			int iEspionage = kUnit.getEspionagePoints();
			if (NO_GAMESPEED != game.getGameSpeedType())
			{
				iEspionage *= GC.getGameSpeedInfo(game.getGameSpeedType()).getSpeedPercent();
				iEspionage /= 100;
			}

			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_ESPIONAGE_MISSION", iEspionage));
		}

		//Inquisitor
		if (kUnit.isInquisitor())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_IS_INQUISITOR"));
		}

		//Religion Spreads
		bFirst = true;
		for (int iI = 0; iI < GC.getNumReligionInfos(); ++iI)
		{
			if (kUnit.getReligionSpreads(iI) > 0)
			{
				szTempBuffer.Format(L"%s%s", NEWLINE, gDLL->getText("TXT_KEY_UNITHELP_CAN_SPREAD").c_str());
				CvWString szReligion;
				szReligion.Format(L"<link=%s>%s</link>", CvWString(GC.getReligionInfo((ReligionTypes)iI).getType()).GetCString(), GC.getReligionInfo((ReligionTypes) iI).getDescription());
				setListHelp(szBuffer, szTempBuffer, szReligion, L", ", bFirst);
				bFirst = false;
			}
		}

		//Corporation Spreads
		bFirst = true;
		for (int iI = 0; iI < GC.getNumCorporationInfos(); ++iI)
		{
			if (kUnit.getCorporationSpreads(iI) > 0)
			{
				szTempBuffer.Format(L"%s%s", NEWLINE, gDLL->getText("TXT_KEY_UNITHELP_CAN_EXPAND").c_str());
				CvWString szCorporation;
				szCorporation.Format(L"<link=%s>%s</link>", CvWString(GC.getCorporationInfo((CorporationTypes) iI).getType()).GetCString(), GC.getCorporationInfo((CorporationTypes) iI).getDescription());
				setListHelp(szBuffer, szTempBuffer, szCorporation, L", ", bFirst);
				bFirst = false;
			}
		}

		//Can Join
		bFirst = true;
		for (int iI = 0; iI < GC.getNumSpecialistInfos(); ++iI)
		{
			if (kUnit.getGreatPeoples(iI))
			{
				szTempBuffer.Format(L"%s%s", NEWLINE, gDLL->getText("TXT_KEY_UNITHELP_CAN_JOIN").c_str());
				CvWString szSpecialistLink = CvWString::format(L"<link=%s>%s</link>", CvWString(GC.getSpecialistInfo((SpecialistTypes)iI).getType()).GetCString(), GC.getSpecialistInfo((SpecialistTypes) iI).getDescription());
				setListHelp(szBuffer, szTempBuffer, szSpecialistLink.GetCString(), L", ", bFirst);
				bFirst = false;
			}
		}

		//Force Buildings
		bFirst = true;
		for (int iI = 0; iI < kUnit.getNumBuildings(); iI++)
		{
			const BuildingTypes eLoopBuilding = (BuildingTypes)kUnit.getBuildings(iI);

			if (NO_BUILDING != eLoopBuilding)
			{
				szTempBuffer.Format(L"%s%s", NEWLINE, gDLL->getText("TXT_KEY_UNITHELP_CAN_CONSTRUCT").c_str());
				CvWString szBuildingLink = CvWString::format(L"<link=%s>%s</link>", CvWString(GC.getBuildingInfo(eLoopBuilding).getType()).GetCString(), GC.getBuildingInfo(eLoopBuilding).getDescription());
				setListHelp(szBuffer, szTempBuffer, szBuildingLink.GetCString(), L", ", bFirst);
				bFirst = false;
			}
		}

		bFirst = true;
		for (int iI = 0; iI < kUnit.getNumHeritage(); iI++)
		{
			const HeritageTypes eTypeX = (HeritageTypes)kUnit.getHeritage(iI);

			if (NO_HERITAGE != eTypeX)
			{
				szTempBuffer.Format(L"%s%s", NEWLINE, gDLL->getText("TXT_KEY_UNITHELP_CAN_CONSTRUCT").c_str());
				CvWString szBuildingLink = CvWString::format(L"<link=%s>%s</link>", CvWString(GC.getHeritageInfo(eTypeX).getType()).GetCString(), GC.getHeritageInfo(eTypeX).getDescription());
				setListHelp(szBuffer, szTempBuffer, szBuildingLink.GetCString(), L", ", bFirst);
				bFirst = false;
			}
		}

		//No bad goodies
		if (kUnit.isNoBadGoodies())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_NO_BAD_GOODIES"));
		}

		//Tradeable Unit
		if (game.isOption(GAMEOPTION_ADVANCED_DIPLOMACY) || bCivilopediaText)
		{
			if (kUnit.isMilitaryTrade() || kUnit.isWorkerTrade())
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_TRADABLE_UNIT"));
			}
		}

		//Found City
		if (kUnit.isFound())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_FOUND_CITY"));
		}
	}
	//bTBUnitView3 = (Combat Classes)
	//bNormalView = default to show but replaced by any of the above
	if (bNormalView)
	{
		//Max HP
		if (kUnit.getTotalModifiedCombatStrength100(false) > 0 && kUnit.getMaxHP() != 100)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_MAX_HP", kUnit.getMaxHP()));
		}

		if (kUnit.isMilitarySupport())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_BRANCH_MILITARY"));
		}
		else
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_BRANCH_CIVILIAN"));
		}

		if (kUnit.getBaseUpkeep() > 0)
		{
			UnitCombatTypes eUnitCombat;
			int iExtra = 0;
			int iMod = 0;
			for (int iI = -1; iI < kUnit.getNumSubCombatTypes(); iI++)
			{
				if (iI > -1)
				{
					eUnitCombat = (UnitCombatTypes)kUnit.getSubCombatType(iI);
				}
				else
				{
					eUnitCombat = (UnitCombatTypes)kUnit.getUnitCombatType();

					if (eUnitCombat == NO_UNITCOMBAT) continue;
				}
				if (game.isValidByGameOption(GC.getUnitCombatInfo(eUnitCombat)))
				{
					iExtra += GC.getUnitCombatInfo(eUnitCombat).getExtraUpkeep100();
					iMod += GC.getUnitCombatInfo(eUnitCombat).getUpkeepModifier();
				}
			}
			const int iUpkeep = getModifiedIntValue(100 * kUnit.getBaseUpkeep() + iExtra, iMod);

			if (iUpkeep > 0)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_UPKEEP", CvWString::format(L"%.2f", iUpkeep / 100.0).GetCString()));

				if (pCity)
				{
					const int iUpkeepChange = GET_PLAYER(pCity->getOwner()).getFinalUnitUpkeepChange(iUpkeep, kUnit.isMilitarySupport());
					if (iUpkeepChange > 0)
					{
						szBuffer.append(NEWLINE);
						szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_UPKEEP_CHANGE", iUpkeepChange));
					}
				}
			}
		}

		//Spy
		if (kUnit.isCounterSpy())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_EXPOSE_SPIES"));
		}

		//Nuclear
		if (kUnit.getNukeRange() != -1)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_CAN_NUKE"));
		}

		//Is Always Hostile
		if (kUnit.isAlwaysHostile())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_ALWAYS_HOSTILE"));
		}

		//Can Explore Rival Territory
		if (kUnit.isRivalTerritory())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_EXPLORE_RIVAL"));
		}


		if (kUnit.isUpgradeAnywhere())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UPGRADE_ANYWHERE"));
		}

		//Hidden Nationality
		if (kUnit.isHiddenNationality())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_HIDDEN_NATIONALITY"));
		}

		if (kUnit.isExcile())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_EXCILE"));
		}

		if (kUnit.isPassage())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_PASSAGE"));
		}

		if (kUnit.isNoNonOwnedCityEntry())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_NO_NON_OWNED_CITY"));
		}

		if (kUnit.isBarbCoExist())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_BARB_COEXIST"));
		}

		if (kUnit.isBlendIntoCity())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_BLEND_INTO_CITY"));
		}

		if (kUnit.isAssassin())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_ASSASSIN"));
		}

		//Invisibility/Visibility
		if (kUnit.isInvisible())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_INVISIBLE_ALL"));
		}

		if (!game.isOption(GAMEOPTION_COMBAT_HIDE_SEEK))
		{
			if (kUnit.getInvisibleType() != NO_INVISIBLE)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_INVISIBLE_MOST"));
			}

			for (int iI = 0; iI < kUnit.getNumSeeInvisibleTypes(); ++iI)
			{
				if (bCivilopediaText || (kUnit.getSeeInvisibleType(iI) != kUnit.getInvisibleType()))
				{
					szBuffer.append(NEWLINE);
					szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_SEE_INVISIBLE", GC.getInvisibleInfo((InvisibleTypes) kUnit.getSeeInvisibleType(iI)).getChar()));
				}
			}
		}
		else
		{
			bool bFirst = true;

			for (int iJ = 0; iJ < GC.getNumInvisibleInfos(); iJ++)
			{
				const int iSpotIntensity = kUnit.getVisibilityIntensityType(iJ);
				if (iSpotIntensity != 0)
				{
					if (bFirst)
					{
						szBuffer.append(NEWLINE);
						szBuffer.append(gDLL->getText("TXT_BULLET_S1_COLON_SPACE", L"TXT_WORD_SPOT"));
						bFirst = false;
					}
					else
					{
						szBuffer.append(L", ");
					}
					szBuffer.append(CvWString::format(L"%d%c", iSpotIntensity, GC.getInvisibleInfo((InvisibleTypes) iJ).getChar()));
				}
			}
			bFirst = true;
			for (int iI = 0; iI < GC.getNumInvisibleInfos(); ++iI)
			{
				if (kUnit.getVisibilityIntensityRangeType(iI) != 0)
				{
					if (!bFirst)
					{
						szBuffer.append(gDLL->getText("TXT_KEY_COMMA"));
					}
					if (bFirst)
					{
						szBuffer.append(NEWLINE);
						bFirst = false;
					}
					szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_INVISIBILITY_SPOT_RANGE_VALUE", GC.getInvisibleInfo((InvisibleTypes) iI).getTextKeyWide(), kUnit.getVisibilityIntensityRangeType(iI)));
				}
			}
			bFirst = true;
			for (int iI = 0; iI < GC.getNumInvisibleInfos(); ++iI)
			{
				if (kUnit.getInvisibilityIntensityType(iI) != 0 && !kUnit.isNoInvisibility())
				{
					if (!bFirst)
					{
						szBuffer.append(gDLL->getText("TXT_KEY_COMMA"));
					}
					if (bFirst)
					{
						szBuffer.append(NEWLINE);
						bFirst = false;
					}
					szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_INVISIBILITY_VEIL_VALUE", kUnit.getInvisibilityIntensityType(iI), GC.getInvisibleInfo((InvisibleTypes) iI).getChar()));
				}
			}
			bFirst = true;
			for (int iI = 0; iI < kUnit.getNumInvisibleTerrainChanges(); ++iI)
			{
				if (kUnit.getInvisibleTerrainChange(iI).iIntensity != 0 && !kUnit.isNoInvisibility())
				{
					if (!bFirst)
					{
						szBuffer.append(gDLL->getText("TXT_KEY_COMMA"));
					}
					if (bFirst)
					{
						szBuffer.append(NEWLINE);
						bFirst = false;
					}
					szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_INVISIBILITY_VEIL_PLOT_VALUE", kUnit.getInvisibleTerrainChange(iI).iIntensity, GC.getInvisibleInfo((InvisibleTypes)kUnit.getInvisibleTerrainChange(iI).eInvisible).getChar(), GC.getTerrainInfo((TerrainTypes)kUnit.getInvisibleTerrainChange(iI).eTerrain).getTextKeyWide()));
				}
			}
			bFirst = true;
			for (int iI = 0; iI < kUnit.getNumInvisibleFeatureChanges(); ++iI)
			{
				if (kUnit.getInvisibleFeatureChange(iI).iIntensity != 0 && !kUnit.isNoInvisibility())
				{
					if (!bFirst)
					{
						szBuffer.append(gDLL->getText("TXT_KEY_COMMA"));
					}
					if (bFirst)
					{
						szBuffer.append(NEWLINE);
						bFirst = false;
					}
					szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_INVISIBILITY_VEIL_PLOT_VALUE", kUnit.getInvisibleFeatureChange(iI).iIntensity, GC.getInvisibleInfo((InvisibleTypes)kUnit.getInvisibleFeatureChange(iI).eInvisible).getChar(), GC.getFeatureInfo((FeatureTypes)kUnit.getInvisibleFeatureChange(iI).eFeature).getTextKeyWide()));
				}
			}
			bFirst = true;
			for (int iI = 0; iI < kUnit.getNumInvisibleImprovementChanges(); ++iI)
			{
				if (kUnit.getInvisibleImprovementChange(iI).iIntensity != 0 && !kUnit.isNoInvisibility())
				{
					if (!bFirst)
					{
						szBuffer.append(gDLL->getText("TXT_KEY_COMMA"));
					}
					if (bFirst)
					{
						szBuffer.append(NEWLINE);
						bFirst = false;
					}
					szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_INVISIBILITY_VEIL_PLOT_VALUE", kUnit.getInvisibleImprovementChange(iI).iIntensity, GC.getInvisibleInfo((InvisibleTypes)kUnit.getInvisibleImprovementChange(iI).eInvisible).getChar(), GC.getImprovementInfo((ImprovementTypes)kUnit.getInvisibleImprovementChange(iI).eImprovement).getTextKeyWide()));
				}
			}
			bFirst = true;
			for (int iI = 0; iI < kUnit.getNumVisibleTerrainChanges(); ++iI)
			{
				if (kUnit.getVisibleTerrainChange(iI).iIntensity != 0)
				{
					if (!bFirst)
					{
						szBuffer.append(gDLL->getText("TXT_KEY_COMMA"));
					}
					if (bFirst)
					{
						szBuffer.append(NEWLINE);
						bFirst = false;
					}
					szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_INVISIBILITY_SPOT_PLOT_VALUE", GC.getInvisibleInfo((InvisibleTypes)kUnit.getVisibleTerrainChange(iI).eInvisible).getTextKeyWide(), kUnit.getVisibleTerrainChange(iI).iIntensity, GC.getTerrainInfo((TerrainTypes)kUnit.getVisibleTerrainChange(iI).eTerrain).getTextKeyWide()));
				}
			}
			bFirst = true;
			for (int iI = 0; iI < kUnit.getNumVisibleFeatureChanges(); ++iI)
			{
				if (kUnit.getVisibleFeatureChange(iI).iIntensity != 0)
				{
					if (!bFirst)
					{
						szBuffer.append(gDLL->getText("TXT_KEY_COMMA"));
					}
					if (bFirst)
					{
						szBuffer.append(NEWLINE);
						bFirst = false;
					}
					szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_INVISIBILITY_SPOT_PLOT_VALUE", kUnit.getVisibleFeatureChange(iI).iIntensity, GC.getInvisibleInfo((InvisibleTypes)kUnit.getVisibleFeatureChange(iI).eInvisible).getChar(), GC.getFeatureInfo((FeatureTypes)kUnit.getVisibleFeatureChange(iI).eFeature).getTextKeyWide()));
				}
			}
			bFirst = true;
			for (int iI = 0; iI < kUnit.getNumVisibleImprovementChanges(); ++iI)
			{
				if (kUnit.getVisibleImprovementChange(iI).iIntensity != 0)
				{
					if (!bFirst)
					{
						szBuffer.append(gDLL->getText("TXT_KEY_COMMA"));
					}
					if (bFirst)
					{
						szBuffer.append(NEWLINE);
						bFirst = false;
					}
					szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_INVISIBILITY_SPOT_PLOT_VALUE", kUnit.getVisibleImprovementChange(iI).iIntensity, GC.getInvisibleInfo((InvisibleTypes)kUnit.getVisibleImprovementChange(iI).eInvisible).getChar(), GC.getImprovementInfo((ImprovementTypes)kUnit.getVisibleImprovementChange(iI).eImprovement).getTextKeyWide()));
				}
			}
			bFirst = true;
			for (int iI = 0; iI < kUnit.getNumVisibleTerrainRangeChanges(); ++iI)
			{
				if (kUnit.getVisibleTerrainRangeChange(iI).iIntensity != 0)
				{
					if (!bFirst)
					{
						szBuffer.append(gDLL->getText("TXT_KEY_COMMA"));
					}
					if (bFirst)
					{
						szBuffer.append(NEWLINE);
						bFirst = false;
					}
					szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_INVISIBILITY_SPOT_PLOT_RANGE_VALUE", GC.getInvisibleInfo((InvisibleTypes)kUnit.getVisibleTerrainRangeChange(iI).eInvisible).getTextKeyWide(), kUnit.getVisibleTerrainRangeChange(iI).iIntensity, GC.getTerrainInfo((TerrainTypes)kUnit.getVisibleTerrainRangeChange(iI).eTerrain).getTextKeyWide()));
				}
			}
			bFirst = true;
			for (int iI = 0; iI < kUnit.getNumVisibleFeatureRangeChanges(); ++iI)
			{
				if (kUnit.getVisibleFeatureRangeChange(iI).iIntensity != 0)
				{
					if (!bFirst)
					{
						szBuffer.append(gDLL->getText("TXT_KEY_COMMA"));
					}
					if (bFirst)
					{
						szBuffer.append(NEWLINE);
						bFirst = false;
					}
					szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_INVISIBILITY_SPOT_PLOT_RANGE_VALUE", kUnit.getVisibleFeatureRangeChange(iI).iIntensity, GC.getInvisibleInfo((InvisibleTypes)kUnit.getVisibleFeatureRangeChange(iI).eInvisible).getChar(), GC.getFeatureInfo((FeatureTypes)kUnit.getVisibleFeatureRangeChange(iI).eFeature).getTextKeyWide()));
				}
			}
			bFirst = true;
			for (int iI = 0; iI < kUnit.getNumVisibleImprovementRangeChanges(); ++iI)
			{
				if (kUnit.getVisibleImprovementRangeChange(iI).iIntensity != 0)
				{
					if (!bFirst)
					{
						szBuffer.append(gDLL->getText("TXT_KEY_COMMA"));
					}
					if (bFirst)
					{
						szBuffer.append(NEWLINE);
						bFirst = false;
					}
					szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_INVISIBILITY_SPOT_PLOT_RANGE_VALUE", kUnit.getVisibleImprovementRangeChange(iI).iIntensity, GC.getInvisibleInfo((InvisibleTypes)kUnit.getVisibleImprovementRangeChange(iI).eInvisible).getChar(), GC.getImprovementInfo((ImprovementTypes)kUnit.getVisibleImprovementRangeChange(iI).eImprovement).getTextKeyWide()));
				}
			}
		}

		//Movement
		if (kUnit.isFlatMovementCost())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_FLAT_MOVEMENT"));
		}

		if (kUnit.isIgnoreTerrainCost())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_IGNORE_TERRAIN"));
		}

		if (kUnit.isIgnoreZoneofControl())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_IGNORE_ZONE_OF_CONTROL"));
		}

		if (kUnit.isFliesToMove())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_FLIES_TO_MOVE"));
		}

		if (kUnit.getAnimalIgnoresBorders() != 0 && !game.isOption(GAMEOPTION_ANIMAL_STAY_OUT))
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_ANIMAL_IGNORES_BORDERS", kUnit.getAnimalIgnoresBorders()));
		}

		//Cannot Enter Terrains
		szTempBuffer.Format(L"%s%s ", NEWLINE, gDLL->getText("TXT_KEY_UNITHELP_CANNOT_ENTER").GetCString());

		bFirst = true;
		foreach_(const TerrainTypes impassableTerrain, kUnit.getImpassableTerrains())
		{
			CvWString szTerrain;
			const TechTypes eTech = (TechTypes)kUnit.getTerrainPassableTech(impassableTerrain);
			if (NO_TECH == eTech)
			{
				szTerrain.Format(L"<link=%s>%s</link>", CvWString(GC.getTerrainInfo(impassableTerrain).getType()).c_str(), GC.getTerrainInfo(impassableTerrain).getDescription());
			}
			else
			{
				szTerrain = gDLL->getText("TXT_KEY_TERRAINHELP_UNTIL_TECH", CvWString(GC.getTerrainInfo(impassableTerrain).getType()).c_str(), GC.getTerrainInfo(impassableTerrain).getTextKeyWide(), GC.getTechInfo(eTech).getTextKeyWide());
			}
			setListHelp(szBuffer, szTempBuffer, szTerrain, L", ", bFirst);
			bFirst = false;
		}

		//May only Traverse
		szTempBuffer.clear();
		szTempBuffer.Format(L"%s%s ", NEWLINE, gDLL->getText("TXT_KEY_UNITHELP_CAN_ONLY_TRAVERSE").GetCString());
		bFirst = true;
		for (int iI = 0; iI < GC.getNumRouteInfos(); ++iI)
		{
			if (kUnit.getPassableRouteNeeded(iI))
			{
				CvWString szRoute;
				szRoute.Format(L"<link=%s>%s</link>", CvWString(GC.getRouteInfo((RouteTypes)iI).getType()).GetCString(), GC.getRouteInfo((RouteTypes)iI).getDescription());
				setListHelp(szBuffer, szTempBuffer, szRoute, L", ", bFirst);
				bFirst = false;
			}
		}

		//Impassable Feature
		foreach_(const FeatureTypes impassableFeature, kUnit.getImpassableFeatures())
		{
			CvWString szFeature;
			const TechTypes eTech = (TechTypes)kUnit.getFeaturePassableTech(impassableFeature);
			if (NO_TECH == eTech)
			{
				szFeature.Format(L"<link=%s>%s</link>", CvWString(GC.getFeatureInfo(impassableFeature).getType()).c_str(), GC.getFeatureInfo(impassableFeature).getDescription());
			}
			else
			{
				szFeature = gDLL->getText("TXT_KEY_TERRAINHELP_UNTIL_TECH", CvWString(GC.getFeatureInfo(impassableFeature).getType()).GetCString(), GC.getFeatureInfo(impassableFeature).getTextKeyWide(), GC.getTechInfo(eTech).getTextKeyWide());
			}
			setListHelp(szBuffer, szTempBuffer, szFeature, L", ", bFirst);
			bFirst = false;
		}

		if (kUnit.isCanMoveImpassable())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_CAN_MOVE_IMPASSABLE"));
		}

		//Defensive Only
		if (kUnit.isOnlyDefensive())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_ONLY_DEFENSIVE"));
		}

		if (kUnit.getLeaderExperience() > 0)
		{
			if (0 == GC.getDefineINT("WARLORD_EXTRA_EXPERIENCE_PER_UNIT_PERCENT"))
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_LEADER", kUnit.getLeaderExperience()));
			}
			else
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_LEADER_EXPERIENCE", kUnit.getLeaderExperience()));
			}
		}

		//Paradrop
		if (kUnit.getDropRange() > 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_PARADROP_RANGE", kUnit.getDropRange()));
		}

		//Outcome Missions?
		//Leader
		if (NO_PROMOTION != kUnit.getLeaderPromotion())
		{
			szBuffer.append(CvWString::format(L"%s%c%s", NEWLINE, gDLL->getSymbolID(BULLET_CHAR), gDLL->getText("TXT_KEY_PROMOTIONHELP_WHEN_LEADING").GetCString()));
			parsePromotionHelp(szBuffer, (PromotionTypes)kUnit.getLeaderPromotion(), L"\n   ");
		}

		//Prereq
		if (kUnit.isRequiresStateReligionInCity())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_REQUIRES_STATE_RELIGION_IN_CITY"));
		}

		if (kUnit.isStateReligion())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_REQUIRES_STATE_RELIGION"));
		}

		if (kUnit.getMaxStartEra() != NO_ERA)
		{
			szTempBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_MAX_START_ERA", GC.getEraInfo((EraTypes)kUnit.getMaxStartEra()).getTextKeyWide()));
		}

		//Experience
		if (pCity && kUnit.canAcquireExperience()
		&& getBugOptionBOOL("MiscHover__UnitExperienceModifiers", true, "BUG_UNIT_EXPERIENCE_MODIFIERS_HOVER"))
		{
			CvPlayer& kPlayer = GET_PLAYER(pCity->getOwner());
			int iTotalXPBonus = 0;
			bool bFirst = true;

			if (kUnit.isSpy() && !GC.isSS_ENABLED())
			{
				iTotalXPBonus = 0;
			}
			else
			{
				int iExperience = pCity->getFreeExperience();
				if (iExperience != 0)
				{
					if (bFirst)
					{
						szBuffer.append(NEWLINE);
						szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_WILL_RECEIVE_FREE_EXPERIENCE"));
					}
					bFirst = false;
					szBuffer.append(NEWLINE);
					szBuffer.append(gDLL->getText("TXT_KEY_CITY_FREE_EXPERIENCE", iExperience));
					iTotalXPBonus += iExperience;
				}
				iExperience = kPlayer.getFreeExperience();
				if (iExperience != 0)
				{
					if (bFirst)
					{
						szBuffer.append(NEWLINE);
						szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_WILL_RECEIVE_FREE_EXPERIENCE"));
					}
					bFirst = false;
					szBuffer.append(NEWLINE);
					szBuffer.append(gDLL->getText("TXT_KEY_PLAYER_FREE_EXPERIENCE", iExperience));
					iTotalXPBonus += iExperience;
				}
				iExperience = pCity->getSpecialistFreeExperience();
				if (iExperience != 0)
				{
					if (bFirst)
					{
						szBuffer.append(NEWLINE);
						szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_WILL_RECEIVE_FREE_EXPERIENCE"));
					}
					bFirst = false;
					szBuffer.append(NEWLINE);
					szBuffer.append(gDLL->getText("TXT_KEY_SPECIALISTHELP_FREE_EXPERIENCE", iExperience));
					iTotalXPBonus += iExperience;
				}

				UnitCombatTypes eCombat;
				for (int iI = -1; iI < kUnit.getNumSubCombatTypes(); iI++)
				{
					if (iI > -1)
					{
						eCombat = (UnitCombatTypes)kUnit.getSubCombatType(iI);
					}
					else
					{
						eCombat = (UnitCombatTypes)kUnit.getUnitCombatType();

						if (eCombat == NO_UNITCOMBAT) continue;
					}
					iExperience = pCity->getUnitCombatFreeExperience(eCombat);
					if (iExperience != 0)
					{
						if (bFirst)
						{
							szBuffer.append(NEWLINE);
							szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_WILL_RECEIVE_FREE_EXPERIENCE"));
						}
						bFirst = false;
						szBuffer.append(NEWLINE);
						szBuffer.append(gDLL->getText("TXT_KEY_UNITCOMBATHELP_FREE_EXPERIENCE", iExperience, GC.getUnitCombatInfo(eCombat).getTextKeyWide()));
						iTotalXPBonus += iExperience;
					}
				}

				const DomainTypes eDomain = kUnit.getDomainType();
				iExperience = pCity->getDomainFreeExperience(eDomain);
				if (iExperience != 0)
				{
					if (bFirst)
					{
						szBuffer.append(NEWLINE);
						szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_WILL_RECEIVE_FREE_EXPERIENCE"));
					}
					bFirst = false;
					szBuffer.append(NEWLINE);
					szBuffer.append(gDLL->getText("TXT_KEY_DOMAIN_FREE_EXPERIENCE", iExperience, GC.getDomainInfo(eDomain).getTextKeyWide()));
					iTotalXPBonus += iExperience;
				}

				if (kPlayer.getStateReligion() != NO_RELIGION)
				{
					iExperience = kPlayer.getStateReligionFreeExperience();
					if (iExperience != 0)
					{
						if (pCity->isHasReligion(kPlayer.getStateReligion()))
						{
							if (bFirst)
							{
								szBuffer.append(NEWLINE);
								szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_WILL_RECEIVE_FREE_EXPERIENCE"));
							}
							bFirst = false;
							szBuffer.append(NEWLINE);
							szBuffer.append(gDLL->getText("TXT_KEY_STATE_RELIGION_FREE_EXPERIENCE", iExperience));
							iTotalXPBonus += iExperience;
						}
						else//Display what you could have IF you could get your state religion into the city
						{
							if (bFirst)
							{
								szBuffer.append(NEWLINE);
								szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_WILL_RECEIVE_FREE_EXPERIENCE"));
							}
							bFirst = false;
							szBuffer.append(NEWLINE);
							szBuffer.append(gDLL->getText("TXT_KEY_NO_STATE_RELIGION_FREE_EXPERIENCE", iExperience));
						}
					}
				}
				const UnitCombatTypes eCombatType = (UnitCombatTypes)kUnit.getUnitCombatType();
				const DomainTypes eDomainType = kUnit.getDomainType();
				//Display sources you could have if you constructed them first
				for (int iI = 0; iI < GC.getNumBuildingInfos(); iI++)
				{
					if (pCity->isActiveBuilding((BuildingTypes)iI))
					{
						continue;
					}
					const CvBuildingInfo& kBuilding = GC.getBuildingInfo((BuildingTypes)iI);
					int iExperience = kBuilding.getUnitCombatFreeExperience().getValue(eCombatType);
					foreach_(const UnitCombatTypes eSubCombat, kUnit.getSubCombatTypes())
					{
						iExperience += kBuilding.getUnitCombatFreeExperience().getValue(eSubCombat);
					}
					iExperience += kBuilding.getDomainFreeExperience(eDomainType);

					if (iExperience != 0 && pCity->canConstruct((BuildingTypes)iI, false, true))
					{
						if (bFirst)
						{
							szBuffer.append(NEWLINE);
							szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_WILL_RECEIVE_FREE_EXPERIENCE"));
						}
						bFirst = false;
						szBuffer.append(NEWLINE);
						szBuffer.append(gDLL->getText("TXT_KEY_NO_BUILDING_FREE_EXPERIENCE", iExperience, kBuilding.getTextKeyWide()));
					}
				}
			}
			int iExperienceModifier = 0;
			int iMod = 0;
			if (pCity->isCapital() || pCity->isGovernmentCenter())
			{
				iMod = kPlayer.getCapitalXPModifier();
				if (iMod != 0)
				{
					szBuffer.append(NEWLINE);
					szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_XP_MOD_CAPITAL", iMod));
					iExperienceModifier += iMod;
				}
			}
			if (pCity->isHolyCity())
			{
				if (pCity->isHolyCity(kPlayer.getStateReligion()))
				{
					iMod = kPlayer.getStateReligionHolyCityXPModifier();
					if (iMod != 0)
					{
						szBuffer.append(NEWLINE);
						szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_XP_MOD_HOLY_CITY_STATE_RELIGION", iMod));
						iExperienceModifier += iMod;
					}
				}
				else
				{
					iMod = kPlayer.getNonStateReligionHolyCityXPModifier();
					if (iMod != 0)
					{
						szBuffer.append(NEWLINE);
						szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_XP_MOD_HOLY_CITY_NONSTATE_RELIGION", iMod));
						iExperienceModifier += iMod;
					}
				}
			}
			if (iExperienceModifier != 0)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_XP_MOD_TOTAL", iExperienceModifier));
				iTotalXPBonus *= (iExperienceModifier + 100);
				iTotalXPBonus /= 100;
			}
			if (iTotalXPBonus != 0)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_XP_TOTAL", iTotalXPBonus));
			}
		}

		//Free Promos
		bFirst = true;
		for (int iI = 0; iI < GC.getNumPromotionInfos(); ++iI)
		{
			if (kUnit.getFreePromotions(iI))
			{
				szTempBuffer.Format(L"%s%s", NEWLINE, gDLL->getText("TXT_KEY_BULLET_STARTS_WITH").c_str());
				setListHelp(szBuffer, szTempBuffer, CvWString::format(L"<link=%s>%s</link>", CvWString(GC.getPromotionInfo((PromotionTypes)iI).getType()).GetCString(), GC.getPromotionInfo((PromotionTypes) iI).getDescription()), L", ", bFirst);
				bFirst = false;
			}
		}

		//Healing
		if (kUnit.isNoSelfHeal())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_SELF_HEAL_NONE"));
		}
		else if (kUnit.getSelfHealModifier() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_SELF_HEAL", kUnit.getSelfHealModifier()));
		}
		if (kUnit.getNumHealSupport() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_HEAL_SUPPORT", kUnit.getNumHealSupport()));
		}

		//Heal Unit Combat
		for (int iI = 0; iI < kUnit.getNumHealUnitCombatTypes(); ++iI)
		{
			UnitCombatTypes eUnitCombat = ((UnitCombatTypes)kUnit.getHealUnitCombatType(iI).eUnitCombat);
			int iHeal = kUnit.getHealUnitCombatType(iI).iHeal;
			int iAdjHeal = kUnit.getHealUnitCombatType(iI).iAdjacentHeal;
			if (iHeal > 0)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_HEALS_UNITCOMBAT_SAME", GC.getUnitCombatInfo(eUnitCombat).getTextKeyWide(), iHeal) + gDLL->getText("TXT_KEY_PROMOTIONHELP_DAMAGE_TURN"));
			}
			if (iAdjHeal > 0)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_HEALS_UNITCOMBAT_ADJACENT", GC.getUnitCombatInfo(eUnitCombat).getTextKeyWide(), iAdjHeal) + gDLL->getText("TXT_KEY_PROMOTIONHELP_DAMAGE_TURN"));
			}
		}

		//Modified Production
			//From Trait
		for (int i = 0; i < GC.getNumTraitInfos(); ++i)
		{
			TraitTypes eTrait = ((TraitTypes)i);
			for (int j = 0; j < GC.getTraitInfo(eTrait).getNumUnitProductionModifiers(); j++)
			{
				if ((UnitTypes)GC.getTraitInfo(eTrait).getUnitProductionModifier(j).eUnit == eUnit)
				{
					if (GC.getTraitInfo(eTrait).getUnitProductionModifier(j).iModifier != 0)
					{
						if (GC.getTraitInfo(eTrait).getUnitProductionModifier(j).iModifier == 100)
						{
							szBuffer.append(NEWLINE);
							szBuffer.append(gDLL->getText("TXT_KEY_DOUBLE_SPEED_TRAIT", GC.getTraitInfo(eTrait).getTextKeyWide()));
						}
						else
						{
							szBuffer.append(NEWLINE);
							szBuffer.append(gDLL->getText("TXT_KEY_PRODUCTION_MODIFIER_TRAIT", GC.getTraitInfo(eTrait).getUnitProductionModifier(j).iModifier, GC.getTraitInfo(eTrait).getTextKeyWide()));
						}
					}
				}
			}
		}

		if (kUnit.isNoNonTypeProdMods())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_NO_NON_TYPE_PROD_MODS"));
		}

		if (kUnit.getInsidiousness() != 0)
		{
			szBuffer.append(NEWLINE);
			float fValue = (float)kUnit.getInsidiousness();
			{
				szTempBuffer.Format(L"%.1f", fValue/10);
			}
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_INSIDIOUSNESS", szTempBuffer.GetCString()));
		}

		if (kUnit.getInvestigation() != 0)
		{
			szBuffer.append(NEWLINE);
			float fValue = (float)kUnit.getInvestigation();
			{
				szTempBuffer.Format(L"%.1f", fValue/10);
			}
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_INVESTIGATION", szTempBuffer.GetCString()));
		}

		if (game.isOption(GAMEOPTION_COMBAT_WITHOUT_WARNING))
		{
			if (kUnit.getStealthStrikes() != 0)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_STEALTH_STRIKES", kUnit.getStealthStrikes()));
			}

			if (kUnit.getStealthCombatModifier() != 0)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_STEALTH_COMBAT_MODIFIER", kUnit.getStealthCombatModifier()));
			}

			if (kUnit.isStealthDefense())
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_STEALTH_DEFEND"));
			}
		}


		if (kUnit.isNoInvisibility() && game.isOption(GAMEOPTION_COMBAT_HIDE_SEEK))
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_NO_INVISIBILIY"));
		}

		//Misc
		if (!CvWString(kUnit.getHelp()).empty())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(kUnit.getHelp());
		}

		if (!CvWString(kUnit.getExtraHoverText()).empty())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(kUnit.getExtraHoverText());
		}
		foreach_(const MapCategoryTypes eMapCategory, kUnit.getMapCategories())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_MAP_CATEGORY_PREREQUISITE", GC.getMapCategoryInfo(eMapCategory).getTextKeyWide()));
		}
	}

	if (!bCivilopediaText && bTBUnitView3 && game.getActivePlayer() != NO_PLAYER)
	{
		const uint16_t iDisplayCount = inspectUnitCombatCounters->getCount(eUnit);
		uint16_t iPotentialDisplays = 0;
		if (kUnit.getUnitCombatType() != NO_UNITCOMBAT)
		{
			if (game.isValidByGameOption(GC.getUnitCombatInfo((UnitCombatTypes)kUnit.getUnitCombatType())))
			{
				iPotentialDisplays++;
			}
			foreach_(const UnitCombatTypes eSubCombat, kUnit.getSubCombatTypes())
			{
				if (game.isValidByGameOption(GC.getUnitCombatInfo(eSubCombat))
				&& ++iPotentialDisplays > iDisplayCount)
				{
					break;
				}
			}
		}
		UnitCombatTypes eUnitCombat;
		int iCount = 0;
		for (int iI = -1; iI < kUnit.getNumSubCombatTypes(); iI++)
		{
			if (iI > -1)
			{
				eUnitCombat = (UnitCombatTypes)kUnit.getSubCombatType(iI);
			}
			else
			{
				eUnitCombat = (UnitCombatTypes)kUnit.getUnitCombatType();

				if (eUnitCombat == NO_UNITCOMBAT) continue;
			}
			if (game.isValidByGameOption(GC.getUnitCombatInfo(eUnitCombat)))
			{
				if (++iCount == iDisplayCount)
				{
					szBuffer.append(DOUBLE_SEPARATOR);
					szBuffer.append(NEWLINE);
					setUnitCombatHelp(szBuffer, eUnitCombat, false);
					szBuffer.append(DOUBLE_SEPARATOR);
				}
				else
				{
					szBuffer.append(NEWLINE);
					szBuffer.append(GC.getUnitCombatInfo(eUnitCombat).getDescription());
				}
			}
		}
		if (iDisplayCount == iPotentialDisplays)
		{
			inspectUnitCombatCounters->setCount(eUnit, 0);
		}
		else if (iDisplayCount > iPotentialDisplays)
		{
			inspectUnitCombatCounters->setCount(eUnit, 1);
		}
		else
		{
			inspectUnitCombatCounters->setCount(eUnit, iDisplayCount + 1);
		}
	}
	else if (bTBUnitView3 || bCivilopediaText)
	{
		if (kUnit.getUnitCombatType() != NO_UNITCOMBAT)
		{
			bool bFirst = true;
			CvWStringBuffer szPeekBuffer;
			setUnitCombatHelp(szPeekBuffer, (UnitCombatTypes)kUnit.getUnitCombatType(), true);
			if (!szPeekBuffer.isEmpty())
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(DOUBLE_SEPARATOR);
				szBuffer.append(NEWLINE);
				szBuffer.append(GC.getUnitCombatInfo((UnitCombatTypes)kUnit.getUnitCombatType()).getDescription());
				szBuffer.append(szPeekBuffer);
				szBuffer.append(DOUBLE_SEPARATOR);
				bFirst = false;
				szPeekBuffer.clear();
			}

			foreach_(const UnitCombatTypes eSubCombat, kUnit.getSubCombatTypes())
			{
				if (game.isValidByGameOption(GC.getUnitCombatInfo(eSubCombat)))
				{
					setUnitCombatHelp(szPeekBuffer, eSubCombat, true);
					if (!szPeekBuffer.isEmpty())
					{
						if (bFirst)
						{
							szBuffer.append(NEWLINE);
							szBuffer.append(DOUBLE_SEPARATOR);
							bFirst = false;
						}
						szBuffer.append(NEWLINE);
						szBuffer.append(GC.getUnitCombatInfo(eSubCombat).getDescription());
						szBuffer.append(szPeekBuffer);
						szBuffer.append(DOUBLE_SEPARATOR);
						szPeekBuffer.clear();
					}
				}
			}
		}
	}
}

// BUG - Starting Experience - start
/*
 * Appends the starting experience and number of promotions the given unit will have
 * when trained or conscripted in the given city.
 */
void CvGameTextMgr::setUnitExperienceHelp(CvWStringBuffer &szBuffer, CvWString szStart, UnitTypes eUnit, CvCity* pCity, bool bConscript)
{
	if (GC.getUnitInfo(eUnit).canAcquireExperience())
	{
		const int iExperience = pCity->getProductionExperience(eUnit) / (bConscript ? 2 : 1);

		if (iExperience > 0)
		{
			szBuffer.append(szStart);
			if (bConscript)
			{
				szBuffer.append(gDLL->getText("TXT_KEY_MISC_EXPERIENCE_DRAFT", iExperience));
			}
			else szBuffer.append(gDLL->getText("TXT_KEY_MISC_EXPERIENCE", iExperience));

			const int iLevel = calculateLevel(iExperience, pCity->getOwner());
			if (iLevel > 1)
			{
				szBuffer.append(L", ");
				szBuffer.append(gDLL->getText("TXT_KEY_MISC_PROMOTIONS", iLevel - 1));
			}
		}
	}
}
// BUG - Starting Experience - end


void CvGameTextMgr::setUnitHelp(CvWStringBuffer &szBuffer, UnitTypes eUnit, bool bCivilopediaText, bool bStrategyText, bool bTechChooserText, CvCity* pCity)
{
	PROFILE_FUNC();

	if (NO_UNIT == eUnit)
	{
		return;
	}
	const bool bDebugMode = GC.getGame().isDebugMode();

	const bool bTBUnitView1 = bCivilopediaText || gDLL->ctrlKey(); // (Combat)
	const bool bTBUnitView2 = bCivilopediaText || gDLL->altKey(); // (Civil)
	const bool bTBUnitView3 = bCivilopediaText || gDLL->shiftKey(); // (Combat Classes)
	// bNormalView: default, but replaced by any of the above
	const bool bNormalView = bCivilopediaText || !bTBUnitView1 && !bTBUnitView2 && !bTBUnitView3;

	const PlayerTypes ePlayer = pCity ? pCity->getOwner() : GC.getGame().getActivePlayer();

	const CvUnitInfo& unitInfo = GC.getUnitInfo(eUnit);

	CvWString szTempBuffer;

	if (!bCivilopediaText)
	{
		szTempBuffer.Format(SETCOLR L"%s" ENDCOLR , TEXT_COLOR("COLOR_UNIT_TEXT"), unitInfo.getDescription());
		szBuffer.append(szTempBuffer);
	}

	bool bFirst;

	if (bNormalView)
	{
		if (isWorldUnit(eUnit))
		{
			if (!pCity)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_WORLD_UNIT_ALLOWED", unitInfo.getMaxGlobalInstances()));
			}
			else
			{
				szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_WORLD_UNIT_LEFT",
					(unitInfo.getMaxGlobalInstances() - (ePlayer != NO_PLAYER ? GC.getGame().getUnitCreatedCount(eUnit) + GET_TEAM(GET_PLAYER(ePlayer).getTeam()).getUnitMaking(eUnit) : 0))));
			}
		}

		if (isNationalUnit(eUnit)
        	&& (!GC.getGame().isOption(GAMEOPTION_NO_NATIONAL_UNIT_LIMIT) || unitInfo.isUnlimitedException()))
        {
            //this scale will be used for national units only... the idea is to start them 5 at prehistoric and scale by 5 per age...
            // as an alternative to the 10% per unit cost increase but unlimited
            // might have to use separate indicator but this will do for now for testing purposes
        	int iMaxUnits = unitInfo.getMaxPlayerInstances();
        	if (iMaxUnits == 5)
        	{
        		EraTypes eEra = (ePlayer != NO_PLAYER) ? GET_PLAYER(ePlayer).getCurrentEra() : NO_ERA;
        		if (eEra > 0)
        		{
        			iMaxUnits += eEra * 5;
        		}
        	}

        	if (!pCity)
        	{
        		szBuffer.append(NEWLINE);
        		szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_NATIONAL_UNIT_ALLOWED", iMaxUnits));
        	}
        	else
        	{
        		int iUsed = (ePlayer != NO_PLAYER ? GET_PLAYER(ePlayer).getUnitCountPlusMaking(eUnit) : 0);
        		szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_NATIONAL_UNIT_LEFT", iMaxUnits - iUsed));
        	}
        }

		if (0 != unitInfo.getInstanceCostModifier())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_INSTANCE_COST_MOD", unitInfo.getInstanceCostModifier()));
		}

		const BoolExpr* pExpr = unitInfo.getTrainCondition();
		if (pExpr)
		{
			bool bEval = false;
			if (pCity)
			{
				bEval = pExpr->evaluate(pCity->getGameObject());
			}
			if (!bEval)
			{
				szBuffer.append(gDLL->getText("TXT_KEY_REQUIRES"));
				pExpr->buildDisplayString(szBuffer);
				szBuffer.append(ENDCOLR);
			}
		}
		bFirst = true;
		foreach_(const HeritageTypes eTypeX, unitInfo.getPrereqAndHeritage())
		{
			if (!pCity || !GET_PLAYER(ePlayer).hasHeritage(eTypeX))
			{
				setListHelp(szBuffer, gDLL->getText("TXT_KEY_REQUIRES"), GC.getHeritageInfo(eTypeX).getDescription(), gDLL->getText("TXT_KEY_OR").c_str(), bFirst);
				bFirst = false;
			}
		}
		bFirst = true;

		foreach_(const HeritageTypes eTypeX, unitInfo.getPrereqOrHeritage())
		{
			if (!pCity || !GET_PLAYER(ePlayer).hasHeritage(eTypeX))
			{
				setListHelp(szBuffer, gDLL->getText("TXT_KEY_REQUIRES"), GC.getHeritageInfo(eTypeX).getDescription(), gDLL->getText("TXT_KEY_OR").c_str(), bFirst);
				bFirst = false;
			}
		}

		if (!pCity || !pCity->canTrain(eUnit))
		{
			if (pCity && GC.getGame().isNoNukes() && unitInfo.getNukeRange() != -1)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_NO_NUKES"));
			}

			if (unitInfo.getHolyCity() != NO_RELIGION)
			{
				if (!pCity || !pCity->isHolyCity((ReligionTypes)unitInfo.getHolyCity()))
				{
					szBuffer.append(NEWLINE);
					szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_REQUIRES_HOLY_CITY", GC.getReligionInfo((ReligionTypes)(unitInfo.getHolyCity())).getChar()));
				}
			}

			bFirst = true;

			if (unitInfo.getSpecialUnitType() != NO_SPECIALUNIT)
			{
				if (!pCity || !GC.getGame().isSpecialUnitValid((SpecialUnitTypes)unitInfo.getSpecialUnitType()))
				{
					for (int iI = 0; iI < GC.getNumProjectInfos(); ++iI)
					{
						if (GC.getProjectInfo((ProjectTypes)iI).getEveryoneSpecialUnit() == unitInfo.getSpecialUnitType())
						{
							CvWString szProject;
							szProject.Format(L"<link=%s>%s</link>", CvWString(GC.getProjectInfo((ProjectTypes)iI).getType()).GetCString(), GC.getProjectInfo((ProjectTypes)iI).getDescription());
							setListHelp(szBuffer, gDLL->getText("TXT_KEY_REQUIRES"), szProject, gDLL->getText("TXT_KEY_OR").c_str(), bFirst);
							bFirst = false;
						}
					}
				}
			}

			if (!bFirst)
			{
				szBuffer.append(ENDCOLR);
			}

			bFirst = true;

			if (unitInfo.getNukeRange() != -1)
			{
				if (!pCity || !GET_PLAYER(ePlayer).isNukesValid())
				{
					for (int iI = 0; iI < GC.getNumProjectInfos(); ++iI)
					{
						if (GC.getProjectInfo((ProjectTypes)iI).isAllowsNukes())
						{
							CvWString szProject;
							szProject.Format(L"<link=%s>%s</link>", CvWString(GC.getProjectInfo((ProjectTypes)iI).getType()).GetCString(), GC.getProjectInfo((ProjectTypes)iI).getDescription());
							setListHelp(szBuffer, gDLL->getText("TXT_KEY_REQUIRES"), szProject, gDLL->getText("TXT_KEY_OR").c_str(), bFirst);
							bFirst = false;
						}
					}

					for (int iI = 0; iI < GC.getNumBuildingInfos(); ++iI)
					{
						if (GC.getBuildingInfo((BuildingTypes)iI).isAllowsNukes())
						{
							CvWString szBuilding;
							szBuilding.Format(L"<link=%s>%s</link>", CvWString(GC.getBuildingInfo((BuildingTypes)iI).getType()).GetCString(), GC.getBuildingInfo((BuildingTypes)iI).getDescription());
							setListHelp(szBuffer, gDLL->getText("TXT_KEY_REQUIRES"), szBuilding, gDLL->getText("TXT_KEY_OR").c_str(), bFirst);
							bFirst = false;
						}
					}
				}
			}

			if (!bFirst)
			{
				szBuffer.append(ENDCOLR);
			}

			// Afforess	Vicinity Bonus 07/29/09
			if (unitInfo.getPrereqVicinityBonus() != NO_BONUS)
			{
				if (!pCity || !pCity->canTrain(eUnit))
				{
					szBuffer.append(NEWLINE);
					szBuffer.append(gDLL->getText("TXT_KEY_REQUIRES_BONUS_VICINITY", GC.getBonusInfo((BonusTypes)(unitInfo.getPrereqVicinityBonus())).getTextKeyWide(), CvWString(GC.getBonusInfo((BonusTypes)(unitInfo.getPrereqVicinityBonus())).getType()).GetCString()));
				}
			}

			bFirst = true;

			foreach_(const BonusTypes ePreReqBonus, unitInfo.getPrereqOrVicinityBonuses())
			{
				if (!pCity || !pCity->canTrain(eUnit))
				{
					szTempBuffer.Format(L"%s%s", NEWLINE, gDLL->getText("TXT_KEY_REQUIRES_BONUS_VICINITY_ONEOF").c_str());
					setListHelp(szBuffer, szTempBuffer, gDLL->getText("TXT_KEY_LINK", CvWString(GC.getBonusInfo(ePreReqBonus).getType()).GetCString(), GC.getBonusInfo(ePreReqBonus).getDescription()), gDLL->getText("TXT_KEY_OR").c_str(), bFirst);
					bFirst = false;
				}
			}

			if (!bFirst)
			{
				szBuffer.append(ENDCOLR);
			}
			// Afforess	Vicinity Bonus END

			if (!bCivilopediaText)
			{
				for (int iI = 0; iI < unitInfo.getNumPrereqAndBuildings(); ++iI)
				{
					const BuildingTypes eBuildingX = (BuildingTypes)unitInfo.getPrereqAndBuilding(iI);
					if (!pCity || !GET_TEAM(pCity->getTeam()).isObsoleteBuilding(eBuildingX) && !pCity->isActiveBuilding(eBuildingX))
					{
						szBuffer.append(NEWLINE);
						szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_REQUIRES_STRING", GC.getBuildingInfo(eBuildingX).getTextKeyWide()));
					}
				}

				bFirst = true;
				int iNum = unitInfo.getPrereqOrBuildingsNum();
				bool bNeeded = true;
				if (pCity)
				{
					bNeeded = false;
					for (int iI = 0; iI < iNum; iI++) // Check if this requirement has been met already
					{
						const BuildingTypes eBuildingX = unitInfo.getPrereqOrBuilding(iI);
						if (!GET_TEAM(pCity->getTeam()).isObsoleteBuilding(eBuildingX))
						{
							bNeeded = true;
							if (pCity->isActiveBuilding(eBuildingX))
							{
								bNeeded = false;
								break;
							}
						}
					}
				}
				if (bNeeded)
				{
					for (int iI = 0; iI < iNum; iI++)
					{
						const BuildingTypes eBuildingX = unitInfo.getPrereqOrBuilding(iI);
						if (!bFirst)
						{
							szBuffer.append(gDLL->getText("TXT_KEY_OR"));
							CvWString szBuilding;
							szBuffer.append(gDLL->getText("TXT_KEY_SET_WARNING_COLOR"));
							szBuilding.Format(L"<link=%s>%s</link>", CvWString(GC.getBuildingInfo(eBuildingX).getType()).GetCString(), GC.getBuildingInfo(eBuildingX).getDescription());
							szBuffer.append(szBuilding);
							szBuffer.append(ENDCOLR);
						}
						else
						{
							szBuffer.append(NEWLINE);
							szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_REQUIRES_STRING", GC.getBuildingInfo(eBuildingX).getTextKeyWide()));
							bFirst = false;
						}
					}
				}

				if (!bTechChooserText && unitInfo.getPrereqAndTech() != NO_TECH)
				{
					if (GC.getGame().getActivePlayer() == NO_PLAYER || !GET_TEAM(GET_PLAYER(ePlayer).getTeam()).isHasTech((TechTypes)unitInfo.getPrereqAndTech()))
					{
						szBuffer.append(NEWLINE);
						szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_REQUIRES_STRING", GC.getTechInfo((TechTypes)(unitInfo.getPrereqAndTech())).getTextKeyWide()));
					}
				}
				bFirst = true;

				foreach_(const TechTypes ePrereqTech, unitInfo.getPrereqAndTechs())
				{
					if (bTechChooserText || GC.getGame().getActivePlayer() == NO_PLAYER || !GET_TEAM(GET_PLAYER(ePlayer).getTeam()).isHasTech(ePrereqTech))
					{
						setListHelp(
							szBuffer, gDLL->getText("TXT_KEY_REQUIRES"),
							GC.getTechInfo(ePrereqTech).getDescription(),
							gDLL->getText("TXT_KEY_AND").c_str(), bFirst
						);
						bFirst = false;
					}
				}

				if (!bFirst)
				{
					szBuffer.append(ENDCOLR);
				}

				if (unitInfo.getPrereqAndBonus() != NO_BONUS)
				{
					if (!pCity || !pCity->hasBonus((BonusTypes)unitInfo.getPrereqAndBonus()))
					{
						szBuffer.append(NEWLINE);
						szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_REQUIRES_STRING", GC.getBonusInfo((BonusTypes)(unitInfo.getPrereqAndBonus())).getTextKeyWide()));
					}
				}

				bFirst = true;

				foreach_(const BonusTypes ePrereqBonus, unitInfo.getPrereqOrBonuses())
				{
					if (!pCity || !pCity->hasBonus(ePrereqBonus))
					{
						setListHelp(
							szBuffer, gDLL->getText("TXT_KEY_REQUIRES"),
							GC.getBonusInfo(ePrereqBonus).getDescription(),
							gDLL->getText("TXT_KEY_OR").c_str(), bFirst
						);
						bFirst = false;
					}
				}
				bFirst = true;
				for (int iI = 0; iI < GC.getNumCivicInfos(); ++iI)
				{
					if (unitInfo.isPrereqOrCivics(CivicTypes(iI)))
					{
						bool civicActive = (!pCity ?
							(GC.getGame().getActivePlayer() != NO_PLAYER && GET_PLAYER(GC.getGame().getActivePlayer()).isCivic(CivicTypes(iI))) :
							GET_PLAYER(pCity->getOwner()).isCivic(CivicTypes(iI)));

						CvWString prefix = gDLL->getText("TXT_KEY_REVERT_COLOR") + gDLL->getText("TXT_KEY_REQUIRES_NO_WARNING");
						CvWString desc = GC.getCivicInfo((CivicTypes(iI))).getDescription();

						CvWString separator = gDLL->getText("TXT_KEY_REVERT_COLOR") + gDLL->getText("TXT_KEY_OR");

						if (!civicActive)
						{
							desc = gDLL->getText("TXT_KEY_SET_WARNING_COLOR") + desc;
						}
						else
						{
							desc = gDLL->getText("TXT_KEY_POSITIVE_COLOR") + desc;
						}

						szTempBuffer.Format(L"%s%s", NEWLINE, prefix.c_str());
						setListHelp(szBuffer,szTempBuffer, desc.c_str(), separator.c_str(), bFirst);
						bFirst = false;
					}
				}

				if (unitInfo.isStateReligion())
				{
					if (!pCity || GET_PLAYER(ePlayer).getStateReligion() == NO_RELIGION || !pCity->isHasReligion(GET_PLAYER(ePlayer).getStateReligion()))
					{
						szBuffer.append(NEWLINE);
						szBuffer.append(gDLL->getText("TXT_KEY_REQUIRES_STATE_RELIGION"));
					}
				}

				if (unitInfo.isInquisitor())
				{
					if (!pCity || !GET_PLAYER(ePlayer).isInquisitionConditions())
					{
						szBuffer.append(NEWLINE);
						szBuffer.append(gDLL->getText("TXT_KEY_NOT_INQUISITION_CONDITIONS"));
					}
				}
				if (!bFirst)
				{
					szBuffer.append(ENDCOLR);
				}
			}
		}

		if (!bCivilopediaText && GC.getGame().getActivePlayer() != NO_PLAYER)
		{
			if (pCity)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_TURNS", pCity->getProductionTurnsLeft(eUnit,((gDLL->ctrlKey() || !(gDLL->shiftKey())) ? 0 : pCity->getOrderQueueLength())), pCity->getProductionNeeded(eUnit), GC.getYieldInfo(YIELD_PRODUCTION).getChar()));

				if (pCity->getProgressOnUnit(eUnit) > 0)
				{
					szTempBuffer.Format(L" - %d/%d%c", pCity->getProgressOnUnit(eUnit), pCity->getProductionNeeded(eUnit), GC.getYieldInfo(YIELD_PRODUCTION).getChar());
					szBuffer.append(szTempBuffer);

					if (pCity->getDelayOnUnit(eUnit) > 0)
					{
						szBuffer.append(NEWLINE);
						const int iTurnsLeft = pCity->getUnitProductionDecayTurns(eUnit);

						if (iTurnsLeft < 2)
						{
							szBuffer.append(gDLL->getText("TXT_KEY_PRODUCTION_DECAY", pCity->getUnitProductionDecay(eUnit)));
						}
						else szBuffer.append(gDLL->getText("TXT_KEY_PRODUCTION_DECAY_TURNS", pCity->getUnitProductionDecay(eUnit), iTurnsLeft));
					}
				}
				else
				{
					szTempBuffer.Format(L" - %d%c", pCity->getProductionNeeded(eUnit), GC.getYieldInfo(YIELD_PRODUCTION).getChar());
					szBuffer.append(szTempBuffer);
				}
			}
			else
			{
				szTempBuffer.Format(L"%s%d%c", NEWLINE, GET_PLAYER(ePlayer).getProductionNeeded(eUnit), GC.getYieldInfo(YIELD_PRODUCTION).getChar());
				szBuffer.append(szTempBuffer);
			}
		}

		for (int iI = 0; iI < GC.getNumBonusInfos(); ++iI)
		{
			if (unitInfo.getBonusProductionModifier(iI) != 0)
			{
				if (pCity)
				{
					if (pCity->hasBonus((BonusTypes)iI))
					{
						szBuffer.append(gDLL->getText("TXT_KEY_COLOR_POSITIVE"));
					}
					else
					{
						szBuffer.append(gDLL->getText("TXT_KEY_COLOR_NEGATIVE"));
					}
				}
				if (!bCivilopediaText)
				{
					szBuffer.append(L" (");
				}
				else
				{
					szTempBuffer.Format(L"%s%c", NEWLINE, gDLL->getSymbolID(BULLET_CHAR), szTempBuffer.c_str());
					szBuffer.append(szTempBuffer);
				}
				if (unitInfo.getBonusProductionModifier(iI) == 100)
				{
					szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_DOUBLE_SPEED", CvWString(GC.getBonusInfo((BonusTypes)iI).getType()).GetCString(), GC.getBonusInfo((BonusTypes)iI).getTextKeyWide()));
				}
				else
				{
					szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_BUILDS_FASTER", unitInfo.getBonusProductionModifier(iI), CvWString(GC.getBonusInfo((BonusTypes)iI).getType()).GetCString(), GC.getBonusInfo((BonusTypes)iI).getTextKeyWide()));
				}
				if (!bCivilopediaText)
				{
					szBuffer.append(L")");
				}
				if (pCity)
				{
					szBuffer.append(gDLL->getText("TXT_KEY_COLOR_REVERT"));
				}
			}
		}
	}

	setBasicUnitHelpWithCity(szBuffer, eUnit, bCivilopediaText, pCity, false, bTBUnitView1, bTBUnitView2, bTBUnitView3);

	if (bTBUnitView1)
	{
		if (bStrategyText)
		{
			if (!CvWString(unitInfo.getStrategy()).empty())
			{
				if ((ePlayer == NO_PLAYER) || GET_PLAYER(ePlayer).isOption(PLAYEROPTION_ADVISOR_HELP))
				{
					szBuffer.append(SEPARATOR);
					szBuffer.append(NEWLINE);
					szBuffer.append(gDLL->getText("TXT_KEY_SIDS_TIPS"));
					szBuffer.append(L'\"');
					szBuffer.append(unitInfo.getStrategy());
					szBuffer.append(L'\"');
				}
			}
		}
	}

	if (pCity && bNormalView && bDebugMode && gDLL->ctrlKey())
	{
		szBuffer.append(NEWLINE);
		for (int iUnitAI = 0; iUnitAI < NUM_UNITAI_TYPES; iUnitAI++)
		{
			int iTempValue = GET_PLAYER(pCity->getOwner()).AI_unitValue(eUnit, (UnitAITypes)iUnitAI, pCity->area());
			if (iTempValue != 0)
			{
				CvWString szTempString;
				getUnitAIString(szTempString, (UnitAITypes)iUnitAI);
				szBuffer.append(CvWString::format(L"(%s : %d) ", szTempString.GetCString(), iTempValue));
			}
		}
	}

	if (!bCivilopediaText)
	{
		if (!bTBUnitView1)
		{
			szBuffer.append(NEWLINE);
			szTempBuffer.Format( SETCOLR L"%s" ENDCOLR, TEXT_COLOR("COLOR_UNIT_TEXT"), gDLL->getText("TXT_TB_UNIT_VIEW_1").c_str());
			szBuffer.append(szTempBuffer);
		}
		if (!bTBUnitView2)
		{
			szBuffer.append(NEWLINE);
			szTempBuffer.Format( SETCOLR L"%s" ENDCOLR, TEXT_COLOR("COLOR_UNIT_TEXT"), gDLL->getText("TXT_TB_UNIT_VIEW_2").c_str());
			szBuffer.append(szTempBuffer);
		}
		if (!bTBUnitView3)
		{
			szBuffer.append(NEWLINE);
			szTempBuffer.Format( SETCOLR L"%s" ENDCOLR, TEXT_COLOR("COLOR_UNIT_TEXT"), gDLL->getText("TXT_TB_UNIT_VIEW_3").c_str());
			szBuffer.append(szTempBuffer);
		}
	}
}

// BUG - Building Actual Effects - start
/*
 * Adds the actual effects of adding a building to the city.
 */
void CvGameTextMgr::setBuildingActualEffects(CvWStringBuffer &szBuffer, const CvWString& szStart, BuildingTypes eBuilding, const CvCity* pCity, bool bNewLine)
{
	PROFILE_EXTRA_FUNC();
	if (pCity)
	{
		bool bStarted = false;

		// Defense
		int iDefense = pCity->getAdditionalDefenseByBuilding(eBuilding);
		bStarted = setResumableValueChangeHelp(szBuffer, szStart, L": ", L"", iDefense, gDLL->getSymbolID(DEFENSE_CHAR), true, bNewLine, bStarted);

		// Happiness
		int iGood = 0;
		int iBad = 0;
		int iAngryPop = 0;
		pCity->getAdditionalHappinessByBuilding(eBuilding, iGood, iBad, iAngryPop);
		bStarted = setResumableGoodBadChangeHelp(szBuffer, szStart, L": ", L"", iGood, gDLL->getSymbolID(HAPPY_CHAR), iBad, gDLL->getSymbolID(UNHAPPY_CHAR), false, bNewLine, bStarted);
		bStarted = setResumableValueChangeHelp(szBuffer, szStart, L": ", L"", iAngryPop, gDLL->getSymbolID(ANGRY_POP_CHAR), false, bNewLine, bStarted);

		// Health
		iGood = 0;
		iBad = 0;
		int iSpoiledFood = 0;
		int iStarvation = 0;
		pCity->getAdditionalHealthByBuilding(eBuilding, iGood, iBad, iSpoiledFood, iStarvation);
		bStarted = setResumableGoodBadChangeHelp(szBuffer, szStart, L": ", L"", iGood, gDLL->getSymbolID(HEALTHY_CHAR), iBad, gDLL->getSymbolID(UNHEALTHY_CHAR), false, bNewLine, bStarted);
		bStarted = setResumableValueChangeHelp(szBuffer, szStart, L": ", L"", iSpoiledFood, gDLL->getSymbolID(EATEN_FOOD_CHAR), false, bNewLine, bStarted);
		bStarted = setResumableValueChangeHelp(szBuffer, szStart, L": ", L"", iStarvation, gDLL->getSymbolID(BAD_FOOD_CHAR), false, bNewLine, bStarted);

		// Yield
		int aiYields[NUM_YIELD_TYPES];
		for (int iI = 0; iI < NUM_YIELD_TYPES; ++iI)
		{
			aiYields[iI] = pCity->getAdditionalYieldByBuilding((YieldTypes)iI, eBuilding);
		}

		int iCommerce = aiYields[YIELD_COMMERCE];
		aiYields[YIELD_COMMERCE] = 0;

		bStarted = setResumableYieldChangeHelp(szBuffer, szStart, L": ", L"", aiYields, false, bNewLine, bStarted);

		// Commerce
		int aiCommerces[NUM_COMMERCE_TYPES];
		for (int iI = 0; iI < NUM_COMMERCE_TYPES; ++iI)
		{
			aiCommerces[iI] = pCity->getAdditionalCommerceTimes100ByBuilding((CommerceTypes)iI, eBuilding);

			aiCommerces[iI] += iCommerce * GET_PLAYER(pCity->getOwner()).getCommercePercent((CommerceTypes)iI);
		}

		// Maintenance - add to gold
		aiCommerces[COMMERCE_GOLD] += pCity->getSavedMaintenanceTimes100ByBuilding(eBuilding);
		bStarted = setResumableCommerceTimes100ChangeHelp(szBuffer, szStart, L": ", L"", aiCommerces, bNewLine, bStarted);

		// Great People
		int iGreatPeopleRate = pCity->getAdditionalGreatPeopleRateByBuilding(eBuilding);
		bStarted = setResumableValueChangeHelp(szBuffer, szStart, L": ", L"", iGreatPeopleRate, gDLL->getSymbolID(GREAT_PEOPLE_CHAR), false, bNewLine, bStarted);
	}
}


/*
 * Calls new function below without displaying actual effects.
 */
void CvGameTextMgr::setBuildingHelp(CvWStringBuffer &szBuffer, const BuildingTypes eBuilding, const bool bActual, CvCity* pCity, const bool bCivilopediaText, const bool bStrategyText, const bool bTechChooserText)
{
	PROFILE_FUNC();

	if (NO_BUILDING == eBuilding)
	{
		return;
	}
	const CvBuildingInfo& kBuilding = GC.getBuildingInfo(eBuilding);
	bool bRelDisabled = false;

	const bool bCity = pCity;

	if (bCity)
	{
		if (pCity->isDisabledBuilding(eBuilding))
		{
			szBuffer.append(CvWString::format(L"%s\n", kBuilding.getDescription()));
			szBuffer.append(gDLL->getText("TXT_KEY_HELPTEXT_BUILDING_DISABLED"));

			bool bFirst = true;
			for (int iI = 0; iI < kBuilding.getNumReplacementBuilding(); ++iI)
			{
				if (pCity->hasBuilding((BuildingTypes)kBuilding.getReplacementBuilding(iI)))
				{
					if (bFirst)
					{
						szBuffer.append(L"\n");
						szBuffer.append(gDLL->getText("TXT_KEY_PEDIA_REPLACED_BY"));
						bFirst = false;
					}
					else szBuffer.append(L",");

					szBuffer.append(CvWString::format(L" %s", GC.getBuildingInfo((BuildingTypes)kBuilding.getReplacementBuilding(iI)).getDescription()));
				}
			}
			return;
		}
		if (pCity->isReligiouslyLimitedBuilding(eBuilding))
		{
			szBuffer.append(gDLL->getText("TXT_KEY_HELPTEXT_BUILDING_DISABLED_RELIGIOUSLY"));
			bRelDisabled = !bCivilopediaText;
		}
	}
	const PlayerTypes ePlayer = bCity ? pCity->getOwner() : GC.getGame().getActivePlayer();
	const CvPlayer* player = ePlayer != NO_PLAYER ? &GET_PLAYER(ePlayer) : NULL;
	const TeamTypes eTeam = player ? player->getTeam() : NO_TEAM;

	CvWString szFirstBuffer;
	CvWString szTempBuffer;
	int iLast;

	if (!bCivilopediaText)
	{
		szTempBuffer.Format( SETCOLR L"<link=%s>%s</link>" ENDCOLR , TEXT_COLOR("COLOR_BUILDING_TEXT"), CvWString(kBuilding.getType()).GetCString(), kBuilding.getDescription());
		szBuffer.append(szTempBuffer);
		//ls612: Orbital Buildings are denoted but not explained, as it would take too much space
		//The Full explanation will be located in the Concepts section of the Pedia
		if (bRelDisabled)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_REL_DISABLED"));
		}

		if (kBuilding.isOrbital())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_ORBITAL"));
		}

		if (kBuilding.isOrbitalInfrastructure())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_ORBITAL_INFRASTRUCTURE"));
		}

		//ls612: bNoHolyCity tag text
		if (kBuilding.isNoHolyCity())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_NO_HOLY_CITY"));
		}

		if (!bRelDisabled)
		{
			{
				const int iHappiness = bCity ? pCity->getBuildingHappiness(eBuilding) : kBuilding.getHappiness();

				if (iHappiness != 0)
				{
					szTempBuffer.Format(L", +%d%c", abs(iHappiness), (iHappiness > 0 ? gDLL->getSymbolID(HAPPY_CHAR) : gDLL->getSymbolID(UNHAPPY_CHAR)));
					szBuffer.append(szTempBuffer);
				}
			}
			{
				const int iHealth =
				(
					bCity
					?
					pCity->getBuildingGoodHealth(eBuilding)
					:
					kBuilding.getHealth() + (player ? player->getExtraBuildingHealth(eBuilding) : 0)
				);
				if (iHealth != 0)
				{
					szTempBuffer.Format(L", +%d%c", abs(iHealth), (iHealth > 0 ? gDLL->getSymbolID(HEALTHY_CHAR): gDLL->getSymbolID(UNHEALTHY_CHAR)));
					szBuffer.append(szTempBuffer);
				}
			}

			if (bCity)
			{
				const int iHealth = pCity->getBuildingBadHealth(eBuilding);

				if (iHealth != 0)
				{
					szTempBuffer.Format(L", +%d%c", abs(iHealth), ((iHealth > 0) ? gDLL->getSymbolID(HEALTHY_CHAR): gDLL->getSymbolID(UNHEALTHY_CHAR)));
					szBuffer.append(szTempBuffer);
				}
			}

			int aiYields[NUM_YIELD_TYPES];
			int aiYieldModifiers[NUM_YIELD_TYPES];
			for (int iI = 0; iI < NUM_YIELD_TYPES; ++iI)
			{
				aiYields[iI] = kBuilding.getYieldChange(iI);
				aiYieldModifiers[iI] = kBuilding.getYieldModifier(iI);
				if (bCity)
				{
					aiYields[iI] += pCity->getBuildingYieldChange(eBuilding, (YieldTypes)iI);
					aiYieldModifiers[iI] += GET_TEAM(pCity->getTeam()).getBuildingYieldTechModifier((YieldTypes)iI, eBuilding);
				}
			}
			if (player)
			{
				YieldArray aiYields100;
				aiYields100.fill(0);
				foreach_(const TechArray& pair, kBuilding.getTechYieldChanges100())
				{
					if (GET_TEAM(eTeam).isHasTech(pair.first))
					{
						for (int iI = 0; iI < NUM_YIELD_TYPES; iI++)
						{
							aiYields100[iI] += pair.second[(YieldTypes)iI];
						}
					}
				}
				for (int iI = 0; iI < NUM_YIELD_TYPES; ++iI)
				{
					if (bCity)
					{
						aiYields100[iI] += kBuilding.getYieldPerPopChange(iI) * pCity->getPopulation();
					}
					aiYields[iI] += aiYields100[iI] / 100;
				}
			}
			setYieldChangeHelp(szBuffer, L", ", L"", L"", aiYields, false, false);

			if (!bCity)
			{
				for (int iI = 0; iI < NUM_YIELD_TYPES; ++iI)
				{
					aiYields[iI] = kBuilding.getYieldPerPopChange(iI);
				}
				setYieldPerPopChangeHelp(szBuffer, L", ", L"", L"", aiYields, false, false);
			}
			setYieldChangeHelp(szBuffer, L", ", L"", L"", aiYieldModifiers, true, bCivilopediaText);

			int aiCommerces[NUM_COMMERCE_TYPES];
			int aiCommerceModifiers[NUM_COMMERCE_TYPES];

			for (int iI = 0; iI < NUM_COMMERCE_TYPES; ++iI)
			{
				int iBaseCommerceChange = kBuilding.getCommerceChange(iI);
				if (iBaseCommerceChange < 0 && iI == COMMERCE_GOLD && GC.getTREAT_NEGATIVE_GOLD_AS_MAINTENANCE())
				{
					iBaseCommerceChange = 0;
				}
				aiCommerceModifiers[iI] = kBuilding.getCommerceModifier(iI);

				if (!bCity)
				{
					aiCommerces[iI] = iBaseCommerceChange;
				}
				else if (pCity->isActiveBuilding(eBuilding))
				{
					aiCommerces[iI] = pCity->getBuildingCommerceByBuilding((CommerceTypes)iI, eBuilding, true);
				}
				else aiCommerces[iI] = iBaseCommerceChange + kBuilding.getCommercePerPopChange(iI) * pCity->getPopulation() / 100;

				if (ePlayer != NO_PLAYER)
				{
					aiCommerceModifiers[iI] += GET_TEAM(eTeam).getBuildingCommerceTechModifier((CommerceTypes)iI, eBuilding);
				}
			}
			listCommerceChange(szBuffer, L", ", L"", aiCommerces);
			listCommerceChange(szBuffer, L", ", L"", aiCommerceModifiers, true);


		}

		if (kBuilding.getGreatPeopleRateChange() != 0)
		{
			szTempBuffer.Format(L", %s%d%c", ((kBuilding.getGreatPeopleRateChange() > 0) ? L"+" : L""), kBuilding.getGreatPeopleRateChange(), gDLL->getSymbolID(GREAT_PEOPLE_CHAR));
			szBuffer.append(szTempBuffer);

			if (kBuilding.getGreatPeopleUnitType() != NO_UNIT)
			{
				szTempBuffer.Format(L" (%s)", GC.getUnitInfo((UnitTypes)kBuilding.getGreatPeopleUnitType()).getDescription());
				szBuffer.append(szTempBuffer);
			}
		}

		if (!bRelDisabled)
		{
			int iBuildingMaintenance = -kBuilding.getCommerceChange(COMMERCE_GOLD) * 100;
			if (iBuildingMaintenance > 0)
			{
				CvWString szRate = CvWString::format(L"%d.%02d", iBuildingMaintenance/100, iBuildingMaintenance%100);
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_MAINTENANCE", szRate.GetCString()));
			}

	// BUG - Building Actual Effects - start
			if (bActual && bCity && pCity->getOwner() == GC.getGame().getActivePlayer() && getBugOptionBOOL("MiscHover__BuildingActualEffects", true, "BUG_BUILDING_HOVER_ACTUAL_EFFECTS"))
			{
				CvWString szStart = gDLL->getText("TXT_KEY_ACTUAL_EFFECTS");
				setBuildingActualEffects(szBuffer, szStart, eBuilding, pCity);
			}
		}
	// BUG - Building Actual Effects - end
	}

	if (bCivilopediaText)
	{
		if (!bRelDisabled)
		{
			setYieldChangeHelp(szBuffer, L"", L"", L"", kBuilding.getYieldModifierArray(), true, true);

			int* aList = kBuilding.getCommerceModifierArray();
			if (aList)
			{
				listCommerceChange(szBuffer, CvWString::format(L"\n%c", gDLL->getSymbolID(BULLET_CHAR)), L"", aList, true);
			}
		}
	}
	else
	{
		if (isWorldWonder(eBuilding))
		{
			if (!bCity || ePlayer == NO_PLAYER)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_WORLD_WONDER_ALLOWED", kBuilding.getMaxGlobalInstances()));
			}
			else
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_WORLD_WONDER_LEFT", kBuilding.getMaxGlobalInstances() - GC.getGame().getBuildingCreatedCount(eBuilding) - GET_TEAM(eTeam).getBuildingMaking(eBuilding)));
			}
		}

		if (isTeamWonder(eBuilding))
		{
			if (!bCity || ePlayer == NO_PLAYER)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_TEAM_WONDER_ALLOWED", kBuilding.getMaxTeamInstances()));
			}
			else
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_TEAM_WONDER_LEFT", kBuilding.getMaxTeamInstances() - GET_TEAM(eTeam).getBuildingCountPlusMaking(eBuilding)));
			}
		}

		if (isNationalWonder(eBuilding))
		{

			if (!bCity || ePlayer == NO_PLAYER)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_NATIONAL_WONDER_ALLOWED", kBuilding.getMaxPlayerInstances()));
			}
			else
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_NATIONAL_WONDER_LEFT", kBuilding.getMaxPlayerInstances() - player->getBuildingCountPlusMaking(eBuilding)));
			}
		}

		const SpecialBuildingTypes eSpecialBuilding = kBuilding.getSpecialBuilding();
		if (eSpecialBuilding != NO_SPECIALBUILDING && isNationalWonderGroupSpecialBuilding(eSpecialBuilding))
		{

			if (!bCity || ePlayer == NO_PLAYER)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_GROUP_WONDER_ALLOWED", GC.getSpecialBuildingInfo(eSpecialBuilding).getTextKeyWide(), GC.getSpecialBuildingInfo(eSpecialBuilding).getMaxPlayerInstances()));
			}
			else
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_GROUP_WONDER_LEFT", GC.getSpecialBuildingInfo(eSpecialBuilding).getTextKeyWide(), GC.getSpecialBuildingInfo(eSpecialBuilding).getMaxPlayerInstances() - player->getBuildingGroupCountPlusMaking(eSpecialBuilding)));
			}
		}
	}

	if (kBuilding.isAutoBuild())
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_AUTO_BUILD"));
	}

	if (!bRelDisabled)
	{
		int iCount = 0;
		for (int iJ = 0; iJ < NUM_COMMERCE_TYPES; iJ++)
		{
			iLast = 0;

			for (int iI = 0; iI < GC.getNumBuildingInfos(); iI++)
			{
				const BuildingTypes eLoopBuilding = static_cast<BuildingTypes>(iI);
				const int iChange = kBuilding.getGlobalBuildingCommerceChange(eLoopBuilding, (CommerceTypes)iJ);

				if (iChange != 0)
				{
					szFirstBuffer.Format(L"%s%s", NEWLINE, gDLL->getText("TXT_KEY_CIVICHELP_BUILDING_COMMERCE_CHANGE", iChange, GC.getCommerceInfo((CommerceTypes)iJ).getChar()).c_str());
					CvWString szBuilding;
					szBuilding.Format(L"<link=%s>%s</link>", CvWString(GC.getBuildingInfo(eLoopBuilding).getType()).c_str(), GC.getBuildingInfo(eLoopBuilding).getDescription());
					setListHelp(szBuffer, szFirstBuffer, szBuilding, L", ", iChange != iLast);
					if (iLast == iChange) iCount++;
					iLast = iChange;
					if (iCount > 3) iCount = iLast = 0;
				}
			}
		}
		int aiYields[NUM_YIELD_TYPES];
		for (int iI = 0; iI < NUM_YIELD_TYPES; ++iI)
		{
			aiYields[iI] = kBuilding.getYieldPerPopChange(iI);
		}
		setYieldPerPopChangeHelp(szBuffer, L", ", L"", L"", aiYields, false, true);

		if (kBuilding.getCommercePerPopChangeArray())
		{
			bool bFirst = true;
			for (int iI = 0; iI < NUM_COMMERCE_TYPES; ++iI)
			{
				const int iValue = kBuilding.getCommercePerPopChange(iI);
				if (iValue != 0)
				{
					if (bFirst)
					{
						szBuffer.append(CvWString::format(L"\n%c%s: ", gDLL->getSymbolID(BULLET_CHAR), gDLL->getText("TXT_KEY_PER_POPULATION").GetCString()));
						bFirst = false;
					}
					else szBuffer.append(L", ");

					CvWString szValue;
					makeValueString(szValue, iValue, true);
					szBuffer.append(CvWString::format(L"%s%c", szValue.GetCString(), GC.getCommerceInfo((CommerceTypes) iI).getChar()));
				}
			}
		}
	}

	//	Hurry types
	for (int iI = 0; iI < GC.getNumHurryInfos(); ++iI)
	{
		if (kBuilding.isHurry(iI))
		{
			szBuffer.append(CvWString::format(L"%s%c%s", NEWLINE, gDLL->getSymbolID(BULLET_CHAR), GC.getHurryInfo((HurryTypes)iI).getDescription()));
		}
	}

	if (!bRelDisabled && kBuilding.getGlobalReligionCommerce() != NO_RELIGION)
	{
		const int* aList = GC.getReligionInfo((ReligionTypes)kBuilding.getGlobalReligionCommerce()).getGlobalReligionCommerceArray();
		if (aList)
		{
			listCommerceChange(
				szBuffer, CvWString::format(L"\n%c", gDLL->getSymbolID(BULLET_CHAR)),
				gDLL->getText(
					"TXT_KEY_BUILDINGHELP_PER_CITY_WITH",
					GC.getReligionInfo((ReligionTypes) kBuilding.getGlobalReligionCommerce()).getChar()
				),
				aList
			);
		}
	}

	if (NO_CORPORATION != kBuilding.getFoundsCorporation())
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_FOUNDS_CORPORATION", CvWString(GC.getCorporationInfo((CorporationTypes)kBuilding.getFoundsCorporation()).getType()).GetCString(), GC.getCorporationInfo((CorporationTypes)kBuilding.getFoundsCorporation()).getTextKeyWide()));
	}

	if (kBuilding.getGlobalCorporationCommerce() != NO_CORPORATION)
	{
		const int* aList = GC.getCorporationInfo((CorporationTypes)kBuilding.getGlobalCorporationCommerce()).getHeadquarterCommerceArray();
		if (aList)
		{
			listCommerceChange(
				szBuffer, CvWString::format(L"\n%c", gDLL->getSymbolID(BULLET_CHAR)),
				gDLL->getText(
					"TXT_KEY_BUILDINGHELP_PER_CITY_WITH",
					GC.getCorporationInfo((CorporationTypes)kBuilding.getGlobalCorporationCommerce()).getChar()
				),
				aList
			);
		}
	}

	foreach_(const BonusModifier& pair, kBuilding.getFreeBonuses())
	{
		const CvBonusInfo& kBonus = GC.getBonusInfo(pair.first);
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_PROVIDES", pair.second, CvWString(kBonus.getType()).c_str(), kBonus.getTextKeyWide(), kBonus.getChar()));

		if (kBonus.getHealth() != 0)
		{
			szTempBuffer.Format(L", +%d%c", abs(kBonus.getHealth()), (kBonus.getHealth() > 0) ? gDLL->getSymbolID(HEALTHY_CHAR): gDLL->getSymbolID(UNHEALTHY_CHAR));
			szBuffer.append(szTempBuffer);
		}

		if (kBonus.getHappiness() != 0)
		{
			szTempBuffer.Format(L", +%d%c", abs(kBonus.getHappiness()), (kBonus.getHappiness() > 0) ? gDLL->getSymbolID(HAPPY_CHAR) : gDLL->getSymbolID(UNHAPPY_CHAR));
			szBuffer.append(szTempBuffer);
		}

		if (player)
		{
			szBuffer.append(gDLL->getText("TXT_KEY_BONUSHELP_AVAILABLE_PLAYER_1", player->getNumAvailableBonuses(pair.first)));
		}
	}

	const BuildingTypes eFreeBuilding = kBuilding.getFreeBuilding();
	if (eFreeBuilding != NO_BUILDING)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_FREE_IN_CITY", CvWString(GC.getBuildingInfo(eFreeBuilding).getType()).GetCString(), GC.getBuildingInfo(eFreeBuilding).getTextKeyWide()));
	}

	bool bFirst = true;
	for (int iI = 0; iI < GC.getNumBuildingInfos(); ++iI)
	{
		const BuildingTypes eLoopBuilding = static_cast<BuildingTypes>(iI);

		if (GC.getBuildingInfo(eLoopBuilding).getFreeBuilding() == eBuilding
		&& (!bCity || pCity->canConstruct(eLoopBuilding, false, true)))
		{
			szFirstBuffer.Format(L"%s%s", NEWLINE, gDLL->getText("TXT_KEY_BUILDINGHELP_GIVEN_FREE").c_str());
			szTempBuffer.Format(SETCOLR L"<link=%s>%s</link>" ENDCOLR, TEXT_COLOR("COLOR_BUILDING_TEXT"), CvWString(GC.getBuildingInfo(eLoopBuilding).getType()).GetCString(), GC.getBuildingInfo(eLoopBuilding).getDescription());
			setListHelp(szBuffer, szFirstBuffer, szTempBuffer, L", ", bFirst);
			bFirst = false;
		}
	}

	const BuildingTypes eFreeAreaBuilding = kBuilding.getFreeAreaBuilding();
	if (eFreeAreaBuilding != NO_BUILDING)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_FREE_IN_AREA", CvWString(GC.getBuildingInfo(eFreeAreaBuilding).getType()).GetCString(), GC.getBuildingInfo(eFreeAreaBuilding).getTextKeyWide()));
	}

	bFirst = true;
	for (int iI = 0; iI < GC.getNumBuildingInfos(); ++iI)
	{
		const BuildingTypes eLoopBuilding = static_cast<BuildingTypes>(iI);

		if (GC.getBuildingInfo(eLoopBuilding).getFreeAreaBuilding() == eBuilding
		&& (!bCity || pCity->canConstruct(eLoopBuilding, false, true)))
		{
			szFirstBuffer.Format(L"%s%s", NEWLINE, gDLL->getText("TXT_KEY_BUILDINGHELP_GIVEN_FREE_AREA").c_str());
			szTempBuffer.Format(SETCOLR L"<link=%s>%s</link>" ENDCOLR, TEXT_COLOR("COLOR_BUILDING_TEXT"), CvWString(GC.getBuildingInfo(eLoopBuilding).getType()).GetCString(), GC.getBuildingInfo(eLoopBuilding).getDescription());
			setListHelp(szBuffer, szFirstBuffer, szTempBuffer, L", ", bFirst);
			bFirst = false;
		}
	}

	if (kBuilding.isProvidesFreshWater())
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_PROVIDES_WATER"));
	}

	if (kBuilding.getWorkableRadius() > 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_EXPANDS_WORKABLE_RADIUS", kBuilding.getWorkableRadius()));
	}

	if (kBuilding.getAdjacentDamagePercent() > 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_DAMAGES_ENEMY_UNITS", kBuilding.getAdjacentDamagePercent()));
	}

	if (kBuilding.isProtectedCulture() && GC.getDefineINT("IDW_ENABLED"))
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_PROTECTS_CULTURE"));
	}

	if (!bRelDisabled)
	{
		if (kBuilding.getOccupationTimeModifier() > 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_OCCUPATION_TIME", kBuilding.getOccupationTimeModifier()));
		}
	}

	if (kBuilding.getNoEntryDefenseLevel() > 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_NO_ENTRY", kBuilding.getNoEntryDefenseLevel()));
	}

	if (!bRelDisabled)
	{
		if (kBuilding.getNumUnitFullHeal() > 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_FULL_HEAL_UNITS", kBuilding.getNumUnitFullHeal()));
		}
	}

	if (GC.getGame().isOption(GAMEOPTION_UNSUPPORTED_ZONE_OF_CONTROL) && kBuilding.isZoneOfControl())
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_ZONE_OF_CONTROL"));
	}

	if (kBuilding.isDamageAttackerCapable())
	{
		bFirst = true;
		if (kBuilding.isDamageAllAttackers())
		{
			if (kBuilding.getDamageAttackerChance() > 0 && kBuilding.getDamageToAttacker() > 0)
			{
				if (bFirst)
				{
					bFirst = false;
				}
				if (kBuilding.isDamageToAttackerIgnoresArmor())
				{
					szBuffer.append(NEWLINE);
					szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_DAMAGE_ALL_ATTACKER_ARMOR_EXEMPT", kBuilding.getDamageAttackerChance(), kBuilding.getDamageToAttacker()));
				}
				else
				{
					szBuffer.append(NEWLINE);
					szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_DAMAGE_ALL_ATTACKER", kBuilding.getDamageAttackerChance(), kBuilding.getDamageToAttacker()));
				}
			}
		}
		else
		{
			for (int iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
			{
				UnitCombatTypes eUnitCombat = ((UnitCombatTypes)iI);
				if (kBuilding.isMayDamageAttackingUnitCombatType(eUnitCombat))
				{
					if (kBuilding.getDamageAttackerChance() > 0 && kBuilding.getDamageToAttacker() > 0)
					{
						if (bFirst)
						{
							szBuffer.append(NEWLINE);
							szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_DAMAGE_ATTACKER_START", GC.getUnitCombatInfo(eUnitCombat).getTextKeyWide()));
							bFirst = false;
						}
						else szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_DAMAGE_ATTACKER_MIDDLE", GC.getUnitCombatInfo(eUnitCombat).getTextKeyWide()));
					}
				}
			}
			if (!bFirst)
			{
				if (kBuilding.isDamageToAttackerIgnoresArmor())
				{
					szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_DAMAGE_ATTACKER_END_ARMOR_EXEMPT", kBuilding.getDamageAttackerChance(), kBuilding.getDamageToAttacker()));
				}
				else
				{
					szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_DAMAGE_ATTACKER_END", kBuilding.getDamageAttackerChance(), kBuilding.getDamageToAttacker()));
				}
			}
		}
	}

	if (kBuilding.getMaxPopulationAllowed() > -1)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_MAX_POPULATION_ALLOWED", kBuilding.getMaxPopulationAllowed()));
	}

	if (kBuilding.getMaxPopulationChange() != 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_MAX_POPULATION_CHANGE", kBuilding.getMaxPopulationChange()));
	}

	if (kBuilding.getPropertySpawnUnit() != NO_UNIT && kBuilding.getPropertySpawnProperty() != NO_PROPERTY)
	{
		if (GC.getPropertyInfo(kBuilding.getPropertySpawnProperty()).getAIWeight() < 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_PROPERTY_SPAWN_BARB", GC.getUnitInfo(kBuilding.getPropertySpawnUnit()).getTextKeyWide()));
		}
		else
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_PROPERTY_SPAWN_FRIENDLY", GC.getUnitInfo(kBuilding.getPropertySpawnUnit()).getTextKeyWide()));
		}
	}

	if (kBuilding.getInsidiousness() != 0)
	{
		szBuffer.append(NEWLINE);
		float fValue = (float)kBuilding.getInsidiousness();
		{
			szTempBuffer.Format(L"%.1f", fValue/10);
		}
		szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_INSIDIOUSNESS", szTempBuffer.GetCString()));
	}

	if (kBuilding.getInvestigation() != 0)
	{
		szBuffer.append(NEWLINE);
		float fValue = (float)kBuilding.getInvestigation();
		{
			szTempBuffer.Format(L"%.1f", fValue/10);
		}
		szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_INVESTIGATION", szTempBuffer.GetCString()));
	}

	int iPopChange = kBuilding.getPopulationChange();
	if (iPopChange != 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_POPULATION_CHANGE", iPopChange));
	}

	if (!bRelDisabled)
	{
		if (kBuilding.getNumPopulationEmployed() > 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_POPULATION_EMPLOYED", kBuilding.getNumPopulationEmployed()));
		}

		if (kBuilding.getHealthPercentPerPopulation() != 0)
		{
			szBuffer.append(NEWLINE);
			int iHealthPercent = kBuilding.getHealthPercentPerPopulation();
			if (iHealthPercent % 100 == 0)
			{
				szTempBuffer = CvWString::format(L"%c%s%d%c%s", gDLL->getSymbolID(BULLET_CHAR),
				iHealthPercent > 0 ? L"+" : L"",
				abs(iHealthPercent / 100),
				(iHealthPercent > 0 ? gDLL->getSymbolID(HEALTHY_CHAR) : gDLL->getSymbolID(UNHEALTHY_CHAR)),
				gDLL->getText("TXT_KEY_MISC_PER_CITIZEN").GetCString());
			}
			else if (iHealthPercent % 10 == 0)
			{
				szTempBuffer = CvWString::format(L"%c%s%.1f%c%s", gDLL->getSymbolID(BULLET_CHAR),
				iHealthPercent > 0 ? L"+" : L"",
				abs(iHealthPercent) * 0.01f,
				(iHealthPercent > 0 ? gDLL->getSymbolID(HEALTHY_CHAR) : gDLL->getSymbolID(UNHEALTHY_CHAR)),
				gDLL->getText("TXT_KEY_MISC_PER_CITIZEN").GetCString());
			}
			else
			{
				szTempBuffer = CvWString::format(L"%c%s%.2f%c%s", gDLL->getSymbolID(BULLET_CHAR),
				iHealthPercent > 0 ? L"+" : L"",
				abs(iHealthPercent) * 0.01f,
				(iHealthPercent > 0 ? gDLL->getSymbolID(HEALTHY_CHAR) : gDLL->getSymbolID(UNHEALTHY_CHAR)),
				gDLL->getText("TXT_KEY_MISC_PER_CITIZEN").GetCString());
			}
			szBuffer.append(szTempBuffer);
		}

		if (kBuilding.getHappinessPercentPerPopulation() != 0)
		{
			szBuffer.append(NEWLINE);
			int iHappinessPercent = kBuilding.getHappinessPercentPerPopulation();
			if (iHappinessPercent % 100 == 0)
			{
				szTempBuffer = CvWString::format(L"%c%s%d%c%s", gDLL->getSymbolID(BULLET_CHAR),
				iHappinessPercent > 0 ? L"+" : L"",
				abs(iHappinessPercent / 100),
				(iHappinessPercent > 0 ? gDLL->getSymbolID(HAPPY_CHAR) : gDLL->getSymbolID(UNHAPPY_CHAR)),
				gDLL->getText("TXT_KEY_MISC_PER_CITIZEN").GetCString());
			}
			else if (iHappinessPercent % 10 == 0)
			{
				szTempBuffer = CvWString::format(L"%c%s%.1f%c%s", gDLL->getSymbolID(BULLET_CHAR),
				iHappinessPercent > 0 ? L"+" : L"",
				abs(iHappinessPercent) * 0.01f,
				(iHappinessPercent > 0 ? gDLL->getSymbolID(HAPPY_CHAR) : gDLL->getSymbolID(UNHAPPY_CHAR)),
				gDLL->getText("TXT_KEY_MISC_PER_CITIZEN").GetCString());
			}
			else
			{
				szTempBuffer = CvWString::format(L"%c%s%.2f%c%s", gDLL->getSymbolID(BULLET_CHAR),
				iHappinessPercent > 0 ? L"+" : L"",
				abs(iHappinessPercent) * 0.01f,
				(iHappinessPercent > 0 ? gDLL->getSymbolID(HAPPY_CHAR) : gDLL->getSymbolID(UNHAPPY_CHAR)),
				gDLL->getText("TXT_KEY_MISC_PER_CITIZEN").GetCString());
			}
			szBuffer.append(szTempBuffer);
		}

		if (bCivilopediaText || GC.getGame().isOption(GAMEOPTION_UNSUPPORTED_REVOLUTION))
		{
			if (0 != kBuilding.getRevIdxLocal())
			{
				if ( kBuilding.getRevIdxLocal() > 0 )
				{
					szBuffer.append(NEWLINE);
					szBuffer.append(gDLL->getText("TXT_KEY_CIVICHELP_REV_INDEX_LOCAL_PENALTY", kBuilding.getRevIdxLocal()));
				}
				else if ( kBuilding.getRevIdxLocal() < 0 )
				{
					szBuffer.append(NEWLINE);
					szBuffer.append(gDLL->getText("TXT_KEY_CIVICHELP_REV_INDEX_LOCAL_BONUS", abs(kBuilding.getRevIdxLocal())));
				}
			}

			//  Revolution National Civic Index Modifiers
			if (0 != kBuilding.getRevIdxNational())
			{
				if ( kBuilding.getRevIdxNational() > 0 )
				{
					szBuffer.append(NEWLINE);
					szBuffer.append(gDLL->getText("TXT_KEY_CIVICHELP_REV_INDEX_NATIONAL_PENALTY", kBuilding.getRevIdxNational()));
				}
				else if ( kBuilding.getRevIdxNational() < 0 )
				{
					szBuffer.append(NEWLINE);
					szBuffer.append(gDLL->getText("TXT_KEY_CIVICHELP_REV_INDEX_NATIONAL_BONUS", abs(kBuilding.getRevIdxNational())));
				}
			}

			if ( kBuilding.getRevIdxDistanceModifier() < 0 )
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_CIVICHELP_CITY_DISTANCE_GOOD_MOD", kBuilding.getRevIdxDistanceModifier()));
			}
			else if ( kBuilding.getRevIdxDistanceModifier() > 0 )
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_CIVICHELP_CITY_DISTANCE_BAD_MOD", abs(kBuilding.getRevIdxDistanceModifier())));
			}
		}

		if (kBuilding.getCivicOption() != NO_CIVICOPTION)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_ENABLES_CIVICS", GC.getCivicOptionInfo((CivicOptionTypes)(kBuilding.getCivicOption())).getTextKeyWide()));
		}
	}

	if (kBuilding.getFreeSpecialTech() != NO_TECH)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_FREE_SPECIAL_TECH", CvWString(GC.getTechInfo((kBuilding.getFreeSpecialTech())).getType()).GetCString(), GC.getTechInfo((kBuilding.getFreeSpecialTech())).getTextKeyWide()));
	}

	if (kBuilding.isPower())
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_PROVIDES_POWER"));
	}

	if (kBuilding.isAreaBorderObstacle())
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_BORDER_OBSTACLE"));
	}

	for (int iI = 0; iI < GC.getNumVoteSourceInfos(); ++iI)
	{
		if (kBuilding.getVoteSourceType() == (VoteSourceTypes)iI)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_DIPLO_VOTE", GC.getVoteSourceInfo((VoteSourceTypes)iI).getTextKeyWide()));
		}
	}

	if (kBuilding.isForceTeamVoteEligible())
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_ELECTION_ELIGIBILITY"));
	}

	if (kBuilding.isCapital())
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_CAPITAL"));
	}

	if (!bRelDisabled)
	{
		if (kBuilding.isGovernmentCenter())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_REDUCES_MAINTENANCE"));
		}

		if (kBuilding.isGoldenAge())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_GOLDEN_AGE"));
		}
	}

	if (kBuilding.isAllowsNukes())
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROJECTHELP_ENABLES_NUKES"));
	}

	if (kBuilding.isMapCentering())
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_CENTERS_MAP"));
	}

	if (!bRelDisabled)
	{
		if (kBuilding.isNoUnhappiness())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_NO_UNHAPPY"));
		}

		if (kBuilding.isNoUnhealthyPopulation())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_NO_UNHEALTHY_POP"));
		}

		if (kBuilding.isBuildingOnlyHealthy())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_NO_UNHEALTHY_BUILDINGS"));
		}
	}

	if (kBuilding.getGreatPeopleRateModifier() != 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_BIRTH_RATE_MOD", kBuilding.getGreatPeopleRateModifier()));
	}

	if (!bRelDisabled)
	{
		if (kBuilding.getGreatGeneralRateModifier() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_GENERAL_RATE_MOD", kBuilding.getGreatGeneralRateModifier()));
		}

		if (kBuilding.getDomesticGreatGeneralRateModifier() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_DOMESTIC_GREAT_GENERAL_MODIFIER", kBuilding.getDomesticGreatGeneralRateModifier()));
		}
	}

	if (kBuilding.getGlobalGreatPeopleRateModifier() != 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_BIRTH_RATE_MOD_ALL_CITIES", kBuilding.getGlobalGreatPeopleRateModifier()));
	}

	if (!bRelDisabled)
	{
		if (kBuilding.getAnarchyModifier() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_ANARCHY_MOD", kBuilding.getAnarchyModifier()));
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_ANARCHY_TIMER_MOD", kBuilding.getAnarchyModifier()));
		}

		if (kBuilding.getGoldenAgeModifier() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_GOLDENAGE_MOD", kBuilding.getGoldenAgeModifier()));
		}

		if (kBuilding.getGlobalHurryModifier() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_HURRY_MOD", kBuilding.getGlobalHurryModifier()));
		}

		if (kBuilding.getFreeExperience() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_FREE_XP_UNITS", kBuilding.getFreeExperience()));
		}

		if (kBuilding.getGlobalFreeExperience() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_FREE_XP_ALL_CITIES", kBuilding.getGlobalFreeExperience()));
		}

		if (kBuilding.getFoodKept() > 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_STORES_FOOD", kBuilding.getFoodKept()));
		}

		if (kBuilding.getAirlift() > 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_AIRLIFT", kBuilding.getAirlift()));
		}

		if (kBuilding.getAirModifier() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_AIR_DAMAGE_MOD", kBuilding.getAirModifier()));
		}

		if (kBuilding.getAirUnitCapacity() != 0)
		{
			int iTotal = kBuilding.getAirUnitCapacity();
			szBuffer.append(NEWLINE);
			if (GC.getGame().isOption(GAMEOPTION_COMBAT_SIZE_MATTERS))
			{
				iTotal *= GC.getGame().getBaseAirUnitIncrementsbyCargoVolume();
			}
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_AIR_UNIT_CAPACITY", iTotal));
		}

		if (kBuilding.getNukeModifier() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_NUKE_DAMAGE_MOD", kBuilding.getNukeModifier()));
		}

		int iNukeExplosionRand = kBuilding.getNukeExplosionRand();
		if ( iNukeExplosionRand != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_NUKE_EXPLOSION_CHANCE", iNukeExplosionRand));
		}

		if (kBuilding.getFreeSpecialist() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_FREE_SPECIALISTS", kBuilding.getFreeSpecialist()));
		}

		if (kBuilding.getAreaFreeSpecialist() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_FREE_SPECIALISTS_CONT", kBuilding.getAreaFreeSpecialist()));
		}

		if (kBuilding.getGlobalFreeSpecialist() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_FREE_SPECIALISTS_ALL_CITIES", kBuilding.getGlobalFreeSpecialist()));
		}

		if (kBuilding.getMaintenanceModifier() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_MAINT_MOD", kBuilding.getMaintenanceModifier()));
		}
		//DPII < Maintenance Modifiers >
		if (kBuilding.getGlobalMaintenanceModifier() != 0)
		{
			if (kBuilding.getGlobalMaintenanceModifier() <= -100)
			{
				szBuffer.append(NEWLINE);
			   szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_GLOBAL_MAINT"));
			}
			else
			{
				szBuffer.append(NEWLINE);
			   szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_GLOBAL_MAINT_MOD", kBuilding.getGlobalMaintenanceModifier()));
			}
		}

		if (kBuilding.getDistanceMaintenanceModifier() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_DISTANCE_MAINT_MOD", kBuilding.getDistanceMaintenanceModifier()));
		}

		if (kBuilding.getNumCitiesMaintenanceModifier() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_NO_MAINT_NUM_CITIES_MOD", kBuilding.getNumCitiesMaintenanceModifier()));
		}

		if (kBuilding.getCoastalDistanceMaintenanceModifier() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_COASTAL_DISTANCE_MAINT_MOD", kBuilding.getCoastalDistanceMaintenanceModifier()));
		}

		if (kBuilding.getConnectedCityMaintenanceModifier() != 0)
		{
			if (kBuilding.getConnectedCityMaintenanceModifier() <= -100)
			{
				szBuffer.append(NEWLINE);
			   szBuffer.append(gDLL->getText("TXT_KEY_CONNECTED_CITY_MAINT"));
			}
			else
			{
				szBuffer.append(NEWLINE);
			   szBuffer.append(gDLL->getText("TXT_KEY_CONNECTED_CITY_MAINT_MOD", kBuilding.getConnectedCityMaintenanceModifier()));
			}
		}

		if (kBuilding.getAreaMaintenanceModifier() != 0)
		{
			if (kBuilding.getAreaMaintenanceModifier() <= -100)
			{
				szBuffer.append(NEWLINE);
			   szBuffer.append(gDLL->getText("TXT_KEY_CONTINENTAL_CITY_MAINT"));
			}
			else
			{
				szBuffer.append(NEWLINE);
			   szBuffer.append(gDLL->getText("TXT_KEY_CONTINENTAL_CITY_MAINT_MOD", kBuilding.getAreaMaintenanceModifier()));
			}
		}

		if (kBuilding.getOtherAreaMaintenanceModifier() != 0)
		{
			if (kBuilding.getOtherAreaMaintenanceModifier() <= -100)
			{
				szBuffer.append(NEWLINE);
			   szBuffer.append(gDLL->getText("TXT_KEY_OVERSEAS_CITY_MAINT"));
			}
			else
			{
				szBuffer.append(NEWLINE);
			   szBuffer.append(gDLL->getText("TXT_KEY_OVERSEAS_CITY_MAINT_MOD", kBuilding.getOtherAreaMaintenanceModifier()));
			}
		}
		//DPII < Maintenance Modifiers >
		if (kBuilding.getHurryAngerModifier() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_HURRY_ANGER_MOD", kBuilding.getHurryAngerModifier()));
		}
	}
	if (kBuilding.getLineOfSight() > 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_INCREASES_LINE_OF_SIGHT"));
	}
	else if (kBuilding.getLineOfSight() < 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_DECREASES_LINE_OF_SIGHT"));
	}

	if (!bRelDisabled)
	{
		if (kBuilding.getInflationModifier() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_ADJUSTS_INFLATION", kBuilding.getInflationModifier()));
		}

		if (kBuilding.getWarWearinessModifier() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_WAR_WEAR_MOD", kBuilding.getWarWearinessModifier()));
		}

		if (kBuilding.getGlobalWarWearinessModifier() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_WAR_WEAR_MOD_ALL_CITIES", kBuilding.getGlobalWarWearinessModifier()));
		}

		if (kBuilding.getEnemyWarWearinessModifier() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_ENEMY_WAR_WEAR", kBuilding.getEnemyWarWearinessModifier()));
		}

		if (kBuilding.getHealRateChange() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_HEAL_MOD", kBuilding.getHealRateChange()));
		}

		if (kBuilding.getNumHealUnitCombatTypes() > 0)
		{
			for (int iI = 0; iI < kBuilding.getNumHealUnitCombatTypes(); iI++)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_HEAL_UNITCOMBAT_MOD", GC.getUnitCombatInfo(kBuilding.getHealUnitCombatType(iI).eUnitCombat).getTextKeyWide(), kBuilding.getHealUnitCombatType(iI).iHeal));
			}
		}

		if (kBuilding.getAreaHealth() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_HEALTH_CHANGE_CONT", abs(kBuilding.getAreaHealth()), ((kBuilding.getAreaHealth() > 0) ? gDLL->getSymbolID(HEALTHY_CHAR): gDLL->getSymbolID(UNHEALTHY_CHAR))));
		}

		if (kBuilding.getGlobalHealth() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_HEALTH_CHANGE_ALL_CITIES", abs(kBuilding.getGlobalHealth()), ((kBuilding.getGlobalHealth() > 0) ? gDLL->getSymbolID(HEALTHY_CHAR): gDLL->getSymbolID(UNHEALTHY_CHAR))));
		}

		// Use absolute value with unhappy face
		if (kBuilding.getAreaHappiness() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_HAPPY_CHANGE_CONT", abs(kBuilding.getAreaHappiness()), ((kBuilding.getAreaHappiness() > 0) ? gDLL->getSymbolID(HAPPY_CHAR) : gDLL->getSymbolID(UNHAPPY_CHAR))));
		}

		if (kBuilding.getGlobalHappiness() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_HAPPY_CHANGE_ALL_CITIES", abs(kBuilding.getGlobalHappiness()), ((kBuilding.getGlobalHappiness() > 0) ? gDLL->getSymbolID(HAPPY_CHAR) : gDLL->getSymbolID(UNHAPPY_CHAR))));
		}

		if (kBuilding.getStateReligionHappiness() != 0)
		{
			if (kBuilding.getReligionType() != NO_RELIGION)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_RELIGION_HAPPINESS", abs(kBuilding.getStateReligionHappiness()), ((kBuilding.getStateReligionHappiness() > 0) ? gDLL->getSymbolID(HAPPY_CHAR) : gDLL->getSymbolID(UNHAPPY_CHAR)), GC.getReligionInfo((ReligionTypes)(kBuilding.getReligionType())).getChar()));
			}
		}

		if (kBuilding.getWorkerSpeedModifier() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_WORKER_MOD", kBuilding.getWorkerSpeedModifier()));
		}

		if (kBuilding.getMilitaryProductionModifier() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_MILITARY_MOD", kBuilding.getMilitaryProductionModifier()));
		}

		if (kBuilding.getSpaceProductionModifier() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_SPACESHIP_MOD", kBuilding.getSpaceProductionModifier()));
		}

		if (kBuilding.getGlobalSpaceProductionModifier() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_SPACESHIP_MOD_ALL_CITIES", kBuilding.getGlobalSpaceProductionModifier()));
		}

		if (kBuilding.getTradeRoutes() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_TRADE_ROUTES", kBuilding.getTradeRoutes()));
		}

		if (kBuilding.getCoastalTradeRoutes() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_COASTAL_TRADE_ROUTES", kBuilding.getCoastalTradeRoutes()));
		}

		if (kBuilding.getGlobalTradeRoutes() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_TRADE_ROUTES_ALL_CITIES", kBuilding.getGlobalTradeRoutes()));
		}

		if (kBuilding.getTradeRouteModifier() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_TRADE_ROUTE_MOD", kBuilding.getTradeRouteModifier()));
		}

		if (kBuilding.getForeignTradeRouteModifier() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_FOREIGN_TRADE_ROUTE_MOD", kBuilding.getForeignTradeRouteModifier()));
		}

		if (kBuilding.getGlobalPopulationChange() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_GLOBAL_POP", kBuilding.getGlobalPopulationChange()));
		}
	}

	if (kBuilding.getFreeTechs() != 0)
	{
		if (kBuilding.getFreeTechs() == 1)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_FREE_TECH"));
		}
		else
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_FREE_TECHS", kBuilding.getFreeTechs()));
		}
	}

	if (kBuilding.getDefenseModifier() != 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_DEFENSE_MOD", kBuilding.getDefenseModifier()));
	}

	if (kBuilding.getBombardDefenseModifier() != 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_BOMBARD_DEFENSE_MOD", -kBuilding.getBombardDefenseModifier()));
	}

	if (!bRelDisabled)
	{
		if (kBuilding.getAllCityDefenseModifier() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_DEFENSE_MOD_ALL_CITIES", kBuilding.getAllCityDefenseModifier()));
		}

		if (kBuilding.getEspionageDefenseModifier() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_ESPIONAGE_DEFENSE_MOD", kBuilding.getEspionageDefenseModifier()));

			if (kBuilding.getEspionageDefenseModifier() > 0)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_EXPOSE_SPIES"));
			}
		}

		//TB Combat Mod (Buildings) begin
		for (int iI = 0; iI < kBuilding.getNumAidRateChanges(); iI++)
		{
			PropertyTypes eProperty = kBuilding.getAidRateChange(iI).ePropertyType;
			int iChange = kBuilding.getAidRateChange(iI).iChange;
			if (iChange != 0)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_AID_RATE", iChange, GC.getPropertyInfo(eProperty).getDescription()));
			}
		}
	}

	if (kBuilding.getTradeCommunicability() > 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_TRADE_COMMUNICABILITY_ADDED", kBuilding.getTradeCommunicability()));
	}

	if (kBuilding.getTradeCommunicability() < 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_TRADE_COMMUNICABILITY_REDUCED", kBuilding.getTradeCommunicability()));
	}

#ifdef OUTBREAKS_AND_AFFLICTIONS
	if (kBuilding.getPromotionLineType() != NO_PROMOTIONLINE)
	{
		PromotionLineTypes eDiseaseLine = kBuilding.getPromotionLineType();
		if (GC.getPromotionLineInfo(eDiseaseLine).isAffliction())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_DISEASE_TYPE", GC.getPromotionLineInfo(eDiseaseLine).getDescription()));
		}
	}
#endif

	for (int iI = 0; iI < kBuilding.getNumBonusAidModifiers(); iI++)
	{
		int iBonusAidModifier = kBuilding.getBonusAidModifier(iI).iModifier;
		if (iBonusAidModifier != 0)
		{
			BonusTypes eBonus = kBuilding.getBonusAidModifier(iI).eBonusType;
			PropertyTypes eProperty = kBuilding.getBonusAidModifier(iI).ePropertyType;
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_BONUS_AID_MODIFIER", GC.getBonusInfo(eBonus).getDescription(), iBonusAidModifier, GC.getPropertyInfo(eProperty).getDescription()));
		}
	}

	for (int iI = 0; iI < GC.getNumPromotionLineInfos(); iI++)
	{
		if (kBuilding.getAfflictionOutbreakLevelChange(iI) != 0)
		{
			PromotionLineTypes eAfflictionLine = ((PromotionLineTypes)iI);
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_AFFLICTION_OUTBREAK_LEVEL_CHANGE", GC.getPromotionLineInfo(eAfflictionLine).getDescription(), kBuilding.getAfflictionOutbreakLevelChange(iI)));
		}
	}

	for (int iI = 0; iI < GC.getNumTechInfos(); iI++)
	{
		if (kBuilding.getTechOutbreakLevelChange(iI) != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_TECH_OUTBREAK_LEVEL_CHANGE", GC.getTechInfo(static_cast<TechTypes>(iI)).getDescription(), kBuilding.getTechOutbreakLevelChange(iI)));
		}
	}

	foreach_(const TraitTypes eTrait, kBuilding.getFreeTraitTypes())
	{
		if (GC.getTraitInfo(eTrait).isCivilizationTrait())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_FREE_TRAIT", GC.getTraitInfo(eTrait).getDescription()));
		}
	}

	if (!bRelDisabled)
	{
		foreach_(const FreePromoTypes& freePromo, kBuilding.getFreePromoTypes())
		{
			const CvPromotionInfo& promo = GC.getPromotionInfo(freePromo.ePromotion);

			szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_FREE_PROMO_CONDITION", CvWString(promo.getType()).GetCString(), promo.getTextKeyWide()));
			if (!kBuilding.isApplyFreePromotionOnMove())
			{
				szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_FREE_PROMO_CONDITION_ADDON"));
			}
			const BoolExpr* pExpr = freePromo.m_pExprFreePromotionCondition;
			if (pExpr)
			{
				pExpr->buildDisplayString(szBuffer);
			}
			else // List all unitcombats that allows the promo in general.
			{
				bool bFirst = true;
				for (int iI = promo.getNumQualifiedUnitCombatTypes() - 1; iI > -1; iI--)
				{
					const UnitCombatTypes eUnitCombat = (UnitCombatTypes)promo.getQualifiedUnitCombatType(iI);
					CvWString szFirstBuffer;
					CvWString szTempBuffer;
					szTempBuffer.Format(L"<link=%s>%s</link>", CvWString(GC.getUnitCombatInfo(eUnitCombat).getType()).GetCString(), GC.getUnitCombatInfo(eUnitCombat).getDescription());
					setListHelp(szBuffer, szFirstBuffer, szTempBuffer, L", ", bFirst);
					bFirst = false;
				}
			}
		}

		if (kBuilding.getNumUnitCombatProdModifiers() > 0)
		{
			for (int iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
			{
				if (kBuilding.getUnitCombatProdModifier(iI) > 0)
				{
					UnitCombatTypes eCombat = ((UnitCombatTypes)iI);
					szBuffer.append(NEWLINE);
					szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_UNIT_COMBAT_PROD_POSITIVE_MODIFIER", GC.getUnitCombatInfo(eCombat).getDescription(), kBuilding.getUnitCombatProdModifier(iI)));
				}
				if (kBuilding.getUnitCombatProdModifier(iI) < 0)
				{
					UnitCombatTypes eCombat = ((UnitCombatTypes)iI);
					szBuffer.append(NEWLINE);
					szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_UNIT_COMBAT_PROD_NEGATIVE_MODIFIER", GC.getUnitCombatInfo(eCombat).getDescription(), kBuilding.getUnitCombatProdModifier(iI)));
				}
			}
		}
	}

	if (kBuilding.getNumUnitCombatRepelModifiers() > 0)
	{
		for (int iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
		{
			if (kBuilding.getUnitCombatRepelModifier(iI) != 0)
			{
				UnitCombatTypes eCombat = ((UnitCombatTypes)iI);
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_UNIT_COMBAT_REPEL_MODIFIER", kBuilding.getUnitCombatRepelModifier(iI), GC.getUnitCombatInfo(eCombat).getDescription()));
			}
		}
	}

	if (kBuilding.getNumUnitCombatRepelAgainstModifiers() > 0)
	{
		for (int iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
		{
			if (kBuilding.getUnitCombatRepelAgainstModifier(iI) != 0)
			{
				UnitCombatTypes eCombat = ((UnitCombatTypes)iI);
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_UNIT_COMBAT_REPEL_AGAINST_MODIFIER", kBuilding.getUnitCombatRepelAgainstModifier(iI), GC.getUnitCombatInfo(eCombat).getDescription()));
			}
		}
	}

	if (kBuilding.getNumUnitCombatDefenseAgainstModifiers() > 0)
	{
		for (int iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
		{
			if (kBuilding.getUnitCombatDefenseAgainstModifier(iI) != 0)
			{
				UnitCombatTypes eCombat = ((UnitCombatTypes)iI);
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_UNIT_COMBAT_DEFENSE_AGAINST_MODIFIER", kBuilding.getUnitCombatDefenseAgainstModifier(iI), GC.getUnitCombatInfo(eCombat).getDescription()));
			}
		}
	}

#ifdef STRENGTH_IN_NUMBERS
	if (GC.getGame().isOption(GAMEOPTION_COMBAT_STRENGTH_IN_NUMBERS))
	{
		if (kBuilding.getFrontSupportPercentModifier() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_FRONT_SUPPORT_PERCENT_MODIFIER", kBuilding.getFrontSupportPercentModifier()));
		}

		if (kBuilding.getShortRangeSupportPercentModifier() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_SHORT_RANGE_SUPPORT_PERCENT_MODIFIER", kBuilding.getShortRangeSupportPercentModifier()));
		}

		if (kBuilding.getMediumRangeSupportPercentModifier() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_MEDIUM_RANGE_SUPPORT_PERCENT_MODIFIER", kBuilding.getMediumRangeSupportPercentModifier()));
		}

		if (kBuilding.getLongRangeSupportPercentModifier() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_LONG_RANGE_SUPPORT_PERCENT_MODIFIER", kBuilding.getLongRangeSupportPercentModifier()));
		}

		if (kBuilding.getFlankSupportPercentModifier() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_FLANK_SUPPORT_PERCENT_MODIFIER", kBuilding.getFlankSupportPercentModifier()));
		}
	}
#endif
	if (!bRelDisabled)
	{
		setYieldChangeHelp(szBuffer, gDLL->getText("TXT_KEY_BUILDINGHELP_RIVER_PLOTS").c_str(), L": ", L"", kBuilding.getRiverPlotYieldChangeArray());

		setYieldChangeHelp(szBuffer, gDLL->getText("TXT_KEY_BUILDINGHELP_WATER_PLOTS_ALL_CITIES").c_str(), L": ", L"", kBuilding.getGlobalSeaPlotYieldChangeArray());

		setYieldChangeHelp(szBuffer, L"", L"", gDLL->getText("TXT_KEY_BUILDINGHELP_WITH_POWER").c_str(), kBuilding.getPowerYieldModifierArray(), true, true);

		setYieldChangeHelp(szBuffer, L"", L"", gDLL->getText("TXT_KEY_BUILDINGHELP_ALL_CITIES_THIS_CONTINENT").c_str(), kBuilding.getAreaYieldModifierArray(), true, true);

		setYieldChangeHelp(szBuffer, L"", L"", gDLL->getText("TXT_KEY_BUILDINGHELP_ALL_CITIES").c_str(), kBuilding.getGlobalYieldModifierArray(), true, true);

		{
			const int* aList = kBuilding.getGlobalCommerceModifierArray();
			if (aList)
			{
				listCommerceChange(szBuffer, CvWString::format(L"\n%c", gDLL->getSymbolID(BULLET_CHAR)), gDLL->getText("TXT_KEY_BUILDINGHELP_ALL_CITIES").GetCString(), aList, true);
			}
		}
		{
			const int* aList = kBuilding.getSpecialistExtraCommerceArray();
			if (aList)
			{
				listCommerceChange(szBuffer, CvWString::format(L"\n%c", gDLL->getSymbolID(BULLET_CHAR)), gDLL->getText("TXT_KEY_BUILDINGHELP_PER_SPECIALIST_ALL_CITIES").GetCString(), aList);
			}
		}
		{
			const int* aList = kBuilding.getStateReligionCommerceArray();
			if (aList)
			{
				if (player  && player->getStateReligion() != NO_RELIGION)
				{
					szTempBuffer = gDLL->getText("TXT_KEY_BUILDINGHELP_FROM_ALL_REL_BUILDINGS", GC.getReligionInfo(player->getStateReligion()).getChar());
				}
				else
				{
					szTempBuffer = gDLL->getText("TXT_KEY_BUILDINGHELP_STATE_REL_BUILDINGS");
				}
				listCommerceChange(szBuffer, CvWString::format(L"\n%c", gDLL->getSymbolID(BULLET_CHAR)), szTempBuffer, aList);
			}
		}

		for (int iI = 0; iI < NUM_COMMERCE_TYPES; ++iI)
		{
			if (kBuilding.getCommerceHappiness(iI) != 0)
			{
				szBuffer.append(NEWLINE);
				// Use absolute value with unhappy face
				szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_PER_LEVEL", ((kBuilding.getCommerceHappiness(iI) > 0) ? gDLL->getSymbolID(HAPPY_CHAR) : gDLL->getSymbolID(UNHAPPY_CHAR)), abs(100 / kBuilding.getCommerceHappiness(iI)), GC.getCommerceInfo((CommerceTypes)iI).getChar()));
			}

			if (kBuilding.isCommerceFlexible(iI) != 0)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_ADJUST_COMM_RATE", GC.getCommerceInfo((CommerceTypes) iI).getChar()));
			}
		}
		if (kBuilding.isAnySpecialistYieldChanges())
		{
			bFirst = true;
			for (int iI = 0; iI < GC.getNumSpecialistInfos(); ++iI)
			{
				if (kBuilding.getSpecialistYieldChangeArray(iI))
				{
					if (bFirst)
					{
						szBuffer.append(NEWLINE);
						szBuffer.append(gDLL->getSymbolID(BULLET_CHAR));
						bFirst = false;
					}
					else szBuffer.append(gDLL->getText("TXT_KEY_COMMA"));

					szFirstBuffer = gDLL->getText("TXT_KEY_BUILDINGHELP_FROM_IN_ALL_CITIES", CvWString(GC.getSpecialistInfo((SpecialistTypes) iI).getType()).GetCString(), GC.getSpecialistInfo((SpecialistTypes) iI).getTextKeyWide());
					setYieldChangeHelp(szBuffer, L"", L"", szFirstBuffer, kBuilding.getSpecialistYieldChangeArray(iI), false, false);
				}
			}
		}
		if (kBuilding.isAnySpecialistCommerceChanges())
		{
			bFirst = true;
			for (int iI = 0; iI < GC.getNumSpecialistInfos(); ++iI)
			{
				const int* aList = kBuilding.getSpecialistCommerceChangeArray(iI);
				if (aList)
				{
					CvWString szStart;
					if (bFirst)
					{
						szStart.Format(L"\n%c", gDLL->getSymbolID(BULLET_CHAR));
						bFirst = false;
					}
					else szStart = L", ";

					listCommerceChange(
						szBuffer, szStart,
						gDLL->getText(
							"TXT_KEY_BUILDINGHELP_FROM_IN_ALL_CITIES",
							CvWString(GC.getSpecialistInfo((SpecialistTypes) iI).getType()).GetCString(),
							GC.getSpecialistInfo((SpecialistTypes) iI).getTextKeyWide()
						),
						aList
					);
				}
			}
		}

		if (kBuilding.isAnyLocalSpecialistYieldChanges())
		{
			bFirst = true;
			for (int iI = 0; iI < GC.getNumSpecialistInfos(); ++iI)
			{
				if (kBuilding.getLocalSpecialistYieldChangeArray(iI))
				{
					if (bFirst)
					{
						szBuffer.append(NEWLINE);
						szBuffer.append(gDLL->getSymbolID(BULLET_CHAR));
						bFirst = false;
					}
					else szBuffer.append(gDLL->getText("TXT_KEY_COMMA"));

					szFirstBuffer = gDLL->getText("TXT_KEY_BUILDINGHELP_FROM_SPECIALIST", CvWString(GC.getSpecialistInfo((SpecialistTypes) iI).getType()).GetCString(), GC.getSpecialistInfo((SpecialistTypes) iI).getTextKeyWide());
					setYieldChangeHelp(szBuffer, L"", L"", szFirstBuffer, kBuilding.getLocalSpecialistYieldChangeArray(iI), false, false);
				}
			}
		}
		if (kBuilding.isAnyLocalSpecialistCommerceChanges())
		{
			bFirst = true;
			for (int iI = 0; iI < GC.getNumSpecialistInfos(); ++iI)
			{
				const int* aList = kBuilding.getLocalSpecialistCommerceChangeArray(iI);
				if (aList)
				{
					CvWString szStart;
					if (bFirst)
					{
						szStart.Format(L"\n%c", gDLL->getSymbolID(BULLET_CHAR));
						bFirst = false;
					}
					else szStart = L", ";

					listCommerceChange(
						szBuffer, szStart,
						gDLL->getText(
							"TXT_KEY_BUILDINGHELP_FROM_SPECIALIST",
							CvWString(GC.getSpecialistInfo((SpecialistTypes) iI).getType()).GetCString(),
							GC.getSpecialistInfo((SpecialistTypes) iI).getTextKeyWide()
						),
						aList
					);
				}
			}
		}

		//TB TESTING to see if we can't change the new line bool so that it doesn't display each one individually - this will impact the long Taxidermy building's list.

		if (kBuilding.isAnyBonusYieldModifiers())
		{
			bFirst = true;
			for (int iI = 0; iI < GC.getNumBonusInfos(); ++iI)
			{
				if (kBuilding.getBonusYieldModifierArray(iI))
				{
					if (bFirst)
					{
						szBuffer.append(NEWLINE);
						szBuffer.append(gDLL->getSymbolID(BULLET_CHAR));
						bFirst = false;
					}
					else szBuffer.append(gDLL->getText("TXT_KEY_COMMA"));

					szFirstBuffer = gDLL->getText("TXT_KEY_BUILDINGHELP_WITH_BONUS", CvWString(GC.getBonusInfo((BonusTypes) iI).getType()).GetCString(), GC.getBonusInfo((BonusTypes) iI).getTextKeyWide());
					setYieldChangeHelp(szBuffer, L"", L"", szFirstBuffer, kBuilding.getBonusYieldModifierArray(iI), true, false);
				}
			}
		}

		if (kBuilding.isAnyBonusCommerceModifiers())
		{
			bFirst = true;
			for (int iI = 0; iI < GC.getNumBonusInfos(); ++iI)
			{
				const int* aList = kBuilding.getBonusCommerceModifierArray(iI);
				if (aList)
				{
					CvWString szStart;
					if (bFirst)
					{
						szStart.Format(L"\n%c", gDLL->getSymbolID(BULLET_CHAR));
						bFirst = false;
					}
					else szStart = L", ";

					listCommerceChange(
						szBuffer, szStart,
						gDLL->getText(
							"TXT_KEY_BUILDINGHELP_WITH_BONUS",
							CvWString(GC.getBonusInfo((BonusTypes)iI).getType()).GetCString(),
							GC.getBonusInfo((BonusTypes)iI).getTextKeyWide(), true
						),
						aList
					);
				}
			}
		}

		iLast = 0;
		if (kBuilding.isAnyVicinityBonusYieldChanges())
		{
			bFirst = true;
			for (int iI = 0; iI < GC.getNumBonusInfos(); ++iI)
			{
				if (kBuilding.getVicinityBonusYieldChangesArray(iI))
				{
					if (bFirst)
					{
						szBuffer.append(NEWLINE);
						szBuffer.append(gDLL->getSymbolID(BULLET_CHAR));
						bFirst = false;
					}
					else szBuffer.append(gDLL->getText("TXT_KEY_COMMA"));

					szFirstBuffer = gDLL->getText("TXT_KEY_BUILDINGHELP_WITH_BONUS", CvWString(GC.getBonusInfo((BonusTypes) iI).getType()).GetCString(), GC.getBonusInfo((BonusTypes) iI).getTextKeyWide());
					szFirstBuffer += gDLL->getText("TXT_KEY_IN_CITY_VICINITY");
					setYieldChangeHelp(szBuffer, L"", L"", szFirstBuffer, kBuilding.getVicinityBonusYieldChangesArray(iI), false, false);
				}
			}
		}

		iLast = 0;
		if (kBuilding.isAnyBonusYieldChanges())
		{
			bFirst = true;
			for (int iI = 0; iI < GC.getNumBonusInfos(); ++iI)
			{
				if (kBuilding.getBonusYieldChangesArray(iI))
				{
					if (bFirst)
					{
						szBuffer.append(NEWLINE);
						szBuffer.append(gDLL->getSymbolID(BULLET_CHAR));
						bFirst = false;
					}
					else szBuffer.append(gDLL->getText("TXT_KEY_COMMA"));

					szFirstBuffer = gDLL->getText("TXT_KEY_BUILDINGHELP_WITH_BONUS", CvWString(GC.getBonusInfo((BonusTypes) iI).getType()).GetCString(), GC.getBonusInfo((BonusTypes) iI).getTextKeyWide());
					setYieldChangeHelp(szBuffer, L"", L"", szFirstBuffer, kBuilding.getBonusYieldChangesArray(iI), false, false);
				}
			}
		}

		if (kBuilding.isAnyBonusCommercePercentChanges())
		{
			for (int iI = 0; iI < GC.getNumBonusInfos(); ++iI)
			{
				bFirst = true;
				for (int iJ = 0; iJ < NUM_COMMERCE_TYPES; ++iJ)
				{
					const int iValue = kBuilding.getBonusCommercePercentChanges(iI, iJ);
					if (iValue != 0)
					{
						if (bFirst)
						{
							szBuffer.append(
								CvWString::format(
									L"\n%c%s <link=%s>%s</link>: ",
									gDLL->getSymbolID(BULLET_CHAR), gDLL->getText("TXT_WORD_WITH").GetCString(),
									CvWString(GC.getBonusInfo((BonusTypes)iI).getType()).GetCString(),
									GC.getBonusInfo((BonusTypes)iI).getDescription()
								)
							);
							bFirst = false;
						}
						else szBuffer.append(L", ");

						CvWString szValue;
						makeValueString(szValue, iValue, true);
						szBuffer.append(CvWString::format(L"%s%c", szValue.GetCString(), GC.getCommerceInfo((CommerceTypes) iJ).getChar()));
					}
				}
			}
		}

		{
			std::map<TechTypes, const int*> tempMap;

			foreach_(const TechCommerceArray& pair, kBuilding.getTechCommerceChanges100())
			{
				tempMap[pair.first] = pair.second.data();
			}
			foreach_(const TechArray& pair, kBuilding.getTechYieldChanges100())
			{
				bFirst = true;
				for (int iJ = 0; iJ < NUM_YIELD_TYPES; ++iJ)
				{
					const int iValue = pair.second[iJ];
					if (iValue != 0)
					{
						if (bFirst)
						{
							szBuffer.append(
								CvWString::format(
									L"\n%c%s <link=%s>%s</link>: ",
									gDLL->getSymbolID(BULLET_CHAR), gDLL->getText("TXT_WORD_WITH").GetCString(),
									CvWString(GC.getTechInfo(pair.first).getType()).GetCString(),
									GC.getTechInfo(pair.first).getDescription()
								)
							);
							bFirst = false;
						}
						else szBuffer.append(L", ");

						CvWString szValue;
						makeValueString(szValue, iValue, true);
						szBuffer.append(CvWString::format(L"%s%c", szValue.GetCString(), GC.getYieldInfo((YieldTypes) iJ).getChar()));
					}
				}
				if (tempMap.count(pair.first) == 1)
				{
					for (int iJ = 0; iJ < NUM_COMMERCE_TYPES; ++iJ)
					{
						const int iValue = tempMap[pair.first][iJ];
						if (iValue != 0)
						{
							// We know it ain't first as this building has yield change from tech.
							CvWString szValue;
							makeValueString(szValue, iValue, true);
							szBuffer.append(CvWString::format(L", %s%c", szValue.GetCString(), GC.getCommerceInfo((CommerceTypes) iJ).getChar()));
						}
					}
					tempMap.erase(pair.first);
				}
			}
			for (std::map<TechTypes, const int*>::const_iterator it = tempMap.begin(), itEnd = tempMap.end(); it != itEnd; ++it)
			{
				bFirst = true;
				for (int iJ = 0; iJ < NUM_COMMERCE_TYPES; ++iJ)
				{
					const int iValue = it->second[iJ];
					if (iValue != 0)
					{
						if (bFirst)
						{
							szBuffer.append(
								CvWString::format(
									L"\n%c%s <link=%s>%s</link>: ",
									gDLL->getSymbolID(BULLET_CHAR), gDLL->getText("TXT_WORD_WITH").GetCString(),
									CvWString(GC.getTechInfo(it->first).getType()).GetCString(),
									GC.getTechInfo(it->first).getDescription()
								)
							);
							bFirst = false;
						}
						else szBuffer.append(L", ");

						CvWString szValue;
						makeValueString(szValue, iValue, true);
						szBuffer.append(CvWString::format(L"%s%c", szValue.GetCString(), GC.getCommerceInfo((CommerceTypes) iJ).getChar()));
					}
				}
			}
		}
		{
			std::map<TechTypes, const int*> tempMap;

			foreach_(const TechCommerceArray& pair, kBuilding.getTechCommerceModifiers())
			{
				tempMap[pair.first] = pair.second.data();
			}
			foreach_(const TechArray& pair, kBuilding.getTechYieldModifiers())
			{
				bFirst = true;
				for (int iI = 0; iI < NUM_YIELD_TYPES; ++iI)
				{
					const int iValue = pair.second[iI];
					if (iValue != 0)
					{
						if (bFirst)
						{
							szBuffer.append(
								CvWString::format(
									L"\n%c%s <link=%s>%s</link>: ",
									gDLL->getSymbolID(BULLET_CHAR), gDLL->getText("TXT_WORD_WITH").GetCString(),
									CvWString(GC.getTechInfo(pair.first).getType()).GetCString(),
									GC.getTechInfo(pair.first).getDescription()
								)
							);
							bFirst = false;
						}
						else szBuffer.append(L", ");

						szBuffer.append(CvWString::format(L"%d%%%c", iValue, GC.getYieldInfo((YieldTypes) iI).getChar()));
					}
				}
				if (tempMap.count(pair.first) == 1)
				{
					for (int iJ = 0; iJ < NUM_COMMERCE_TYPES; ++iJ)
					{
						const int iValue = tempMap[pair.first][iJ];
						if (iValue != 0)
						{
							// We know it ain't first as this building has yield change from tech.
							szBuffer.append(CvWString::format(L"%d%%%c", iValue, GC.getCommerceInfo((CommerceTypes) iJ).getChar()));
						}
					}
					tempMap.erase(pair.first);
				}
			}
			for (std::map<TechTypes, const int*>::const_iterator it = tempMap.begin(), itEnd = tempMap.end(); it != itEnd; ++it)
			{
				bFirst = true;
				for (int iJ = 0; iJ < NUM_COMMERCE_TYPES; ++iJ)
				{
					const int iValue = it->second[iJ];
					if (iValue != 0)
					{
						if (bFirst)
						{
							szBuffer.append(
								CvWString::format(
									L"\n%c%s <link=%s>%s</link>: ",
									gDLL->getSymbolID(BULLET_CHAR), gDLL->getText("TXT_WORD_WITH").GetCString(),
									CvWString(GC.getTechInfo(it->first).getType()).GetCString(),
									GC.getTechInfo(it->first).getDescription()
								)
							);
							bFirst = false;
						}
						else szBuffer.append(L", ");

						szBuffer.append(CvWString::format(L"%d%%%c", iValue, GC.getCommerceInfo((CommerceTypes) iJ).getChar()));
					}
				}
			}
		}

		foreach_(const PlotArray& pair, kBuilding.getPlotYieldChanges())
		{
			bFirst = true;
			for (int iI = 0; iI < NUM_YIELD_TYPES; ++iI)
			{
				const int iValue = pair.second[iI];
				if (iValue != 0)
				{
					if (bFirst)
					{
						szBuffer.append(CvWString::format(L"\n%c", gDLL->getSymbolID(BULLET_CHAR)));
						switch (pair.first)
						{
							case PLOT_PEAK: szBuffer.append(gDLL->getText("TXT_KEY_PLOTS_PEAK")); break;
							case PLOT_HILLS: szBuffer.append(gDLL->getText("TXT_KEY_PLOTS_HILL")); break;
							case PLOT_LAND: szBuffer.append(gDLL->getText("TXT_KEY_PLOTS_FLATLAND")); break;
							case PLOT_OCEAN: szBuffer.append(gDLL->getText("TXT_KEY_PLOTS_WATER")); break;
						}
						bFirst = false;

						if (bCity)
						{
							int iCount = 0;
							foreach_(const CvPlot* plotX, pCity->plots(NUM_CITY_PLOTS))
							{
								if (plotX->getPlotType() == pair.first && pCity->canWork(plotX))
								{
									iCount++;
								}
							}
							szBuffer.append(CvWString::format(L" (%d): ", iCount));
						}
						else szBuffer.append(L": ");
					}
					else szBuffer.append(L", ");

					szBuffer.append(CvWString::format(L"%d%c", iValue, GC.getYieldInfo((YieldTypes) iI).getChar()));
				}
			}
		}

		foreach_(const TerrainArray& pair, kBuilding.getTerrainYieldChanges())
		{
			bFirst = true;
			for (int iI = 0; iI < NUM_YIELD_TYPES; ++iI)
			{
				const int iValue = pair.second[iI];
				if (iValue != 0)
				{
					if (bFirst)
					{
						szBuffer.append(
							CvWString::format(
								L"\n%c<link=%s>%s</link>",
								gDLL->getSymbolID(BULLET_CHAR),
								CvWString(GC.getTerrainInfo(pair.first).getType()).GetCString(),
								GC.getTerrainInfo(pair.first).getDescription()
							)
						);
						bFirst = false;

						if (bCity)
						{
							int iCount = 0;
							foreach_(const CvPlot* plotX, pCity->plots(NUM_CITY_PLOTS))
							{
								if (plotX->getTerrainType() == pair.first && pCity->canWork(plotX))
								{
									iCount++;
								}
							}
							szBuffer.append(CvWString::format(L" (%d): ", iCount));
						}
						else szBuffer.append(L": ");
					}
					else szBuffer.append(L", ");

					szBuffer.append(CvWString::format(L"%d%c", iValue, GC.getYieldInfo((YieldTypes) iI).getChar()));
				}
			}
		}

		foreach_(const ReligionModifier& pair, kBuilding.getReligionChanges())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_SPREADS_RELIGION", GC.getReligionInfo(pair.first).getChar(), pair.second));
		}

		for (int iI = 0; iI < GC.getNumSpecialistInfos(); ++iI)
		{
			if (kBuilding.getSpecialistCount(iI) > 0)
			{
				if (kBuilding.getSpecialistCount(iI) == 1)
				{
					szBuffer.append(NEWLINE);
					szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_TURN_CITIZEN_INTO", CvWString(GC.getSpecialistInfo((SpecialistTypes) iI).getType()).GetCString(), GC.getSpecialistInfo((SpecialistTypes) iI).getTextKeyWide()));
				}
				else
				{
					szBuffer.append(NEWLINE);
					szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_TURN_CITIZENS_INTO", kBuilding.getSpecialistCount(iI), CvWString(GC.getSpecialistInfo((SpecialistTypes) iI).getType()).GetCString(), GC.getSpecialistInfo((SpecialistTypes) iI).getTextKeyWide()));
				}
			}

			if (kBuilding.getFreeSpecialistCount(iI) > 0)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_FREE_SPECIALIST", kBuilding.getFreeSpecialistCount(iI), CvWString(GC.getSpecialistInfo((SpecialistTypes) iI).getType()).GetCString(), GC.getSpecialistInfo((SpecialistTypes) iI).getTextKeyWide()));
			}
		}

		iLast = 0;

		foreach_(const ImprovementModifier& pair, kBuilding.getImprovementFreeSpecialists())
		{
			szFirstBuffer.Format(L"%s%s", NEWLINE, gDLL->getText("TXT_KEY_BUILDINGHELP_IMPROVEMENT_FREE_SPECIALISTS", pair.second).c_str());
			szTempBuffer.Format(L"<link=%s>%s</link>", CvWString(GC.getImprovementInfo(pair.first).getType()).c_str(), GC.getImprovementInfo(pair.first).getDescription());
			setListHelp(szBuffer, szFirstBuffer, szTempBuffer, L", ", (pair.second != iLast));
			iLast = pair.second;
		}

		iLast = 0;

		foreach_(const BonusModifier& modifier, kBuilding.getBonusHealthChanges())
		{
			szFirstBuffer.Format(L"%s%s", NEWLINE, gDLL->getText("TXT_KEY_BUILDINGHELP_HEALTH_HAPPINESS_CHANGE", abs(modifier.second), (modifier.second > 0 ? gDLL->getSymbolID(HEALTHY_CHAR): gDLL->getSymbolID(UNHEALTHY_CHAR))).c_str());
			szTempBuffer.Format(L"<link=%s>%s</link>", CvWString(GC.getBonusInfo(modifier.first).getType()).GetCString(), GC.getBonusInfo(modifier.first).getDescription());
			setListHelp(szBuffer, szFirstBuffer, szTempBuffer, L", ", (modifier.second != iLast));
			iLast = modifier.second;
		}

		for (int iTech = 0; iTech < GC.getNumTechInfos(); iTech++)
		{
			const TechTypes eTech = static_cast<TechTypes>(iTech);
			if (GC.getGame().canEverResearch(eTech))
			{
				if (kBuilding.isAnyTechSpecialistChanges())
				{
					for (int iSpecialist = 0; iSpecialist < GC.getNumSpecialistInfos(); iSpecialist++)
					{
						const int iChange = kBuilding.getTechSpecialistChange(iTech, iSpecialist);
						if (0 != iChange)
						{
							szBuffer.append(NEWLINE);
							if (iChange == 1)
							{
								szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_TURN_CITIZEN_INTO", CvWString(GC.getSpecialistInfo((SpecialistTypes)iSpecialist).getType()).GetCString(), GC.getSpecialistInfo((SpecialistTypes) iSpecialist).getTextKeyWide()));
							}
							else
							{
								szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_TURN_CITIZENS_INTO", iChange, CvWString(GC.getSpecialistInfo((SpecialistTypes)iSpecialist).getType()).GetCString(), GC.getSpecialistInfo((SpecialistTypes) iSpecialist).getTextKeyWide()));
							}
							szBuffer.append(gDLL->getText("TXT_KEY_WITH"));
							szTempBuffer.Format(L"<link=%s>%s</link>", CvWString(GC.getTechInfo(eTech).getType()).GetCString(), GC.getTechInfo(eTech).getDescription());
							szBuffer.append(szTempBuffer);
						}
					}
				}

				if (kBuilding.getTechHealth(eTech) != 0)
				{
					szFirstBuffer.Format(L"%s%c+%d%c%s ", NEWLINE, gDLL->getSymbolID(BULLET_CHAR), abs(kBuilding.getTechHealth(eTech)), kBuilding.getTechHealth(eTech) > 0 ? gDLL->getSymbolID(HEALTHY_CHAR): gDLL->getSymbolID(UNHEALTHY_CHAR), gDLL->getText("TXT_KEY_WITH").GetCString());
					szTempBuffer.Format(L"<link=%s>%s</link>", CvWString(GC.getTechInfo(eTech).getType()).GetCString(), GC.getTechInfo(eTech).getDescription());
					setListHelp(szBuffer, szFirstBuffer, szTempBuffer, L", ", (kBuilding.getTechHealth(eTech) != iLast));
					iLast = kBuilding.getTechHealth(eTech);
				}

				iLast = 0;

				if (kBuilding.getTechHappiness(eTech) != 0)
				{
					szFirstBuffer.Format(L"%s%c+%d%c%s", NEWLINE, gDLL->getSymbolID(BULLET_CHAR), abs(kBuilding.getTechHappiness(eTech)), kBuilding.getTechHappiness(eTech) > 0 ? gDLL->getSymbolID(HAPPY_CHAR): gDLL->getSymbolID(UNHAPPY_CHAR), gDLL->getText("TXT_KEY_WITH").GetCString());
					szTempBuffer.Format(L"<link=%s>%s</link>", CvWString(GC.getTechInfo(eTech).getType()).GetCString(), GC.getTechInfo(eTech).getDescription());
					setListHelp(szBuffer, szFirstBuffer, szTempBuffer, L", ", (kBuilding.getTechHappiness(eTech) != iLast));
					iLast = kBuilding.getTechHappiness(eTech);
				}
			}
		}

		iLast = 0;

		for (int iI = 0; iI < GC.getNumCivicInfos(); ++iI)
		{
			const int iChange = GC.getCivicInfo((CivicTypes)iI).getBuildingHealthChanges(eBuilding);
			if (0 != iChange)
			{
				szFirstBuffer.Format(L"%s%s", NEWLINE, gDLL->getText("TXT_KEY_BUILDINGHELP_CIVIC_HEALTH_HAPPINESS_CHANGE", abs(iChange), ((iChange > 0) ? gDLL->getSymbolID(HEALTHY_CHAR): gDLL->getSymbolID(UNHEALTHY_CHAR))).c_str());
				szTempBuffer.Format(L"<link=%s>%s</link>", CvWString(GC.getCivicInfo((CivicTypes)iI).getType()).GetCString(), GC.getCivicInfo((CivicTypes)iI).getDescription());
				setListHelp(szBuffer, szFirstBuffer, szTempBuffer, L", ", (iChange != iLast));
				iLast = iChange;
			}
		}

		iLast = 0;
		foreach_(const BonusModifier& modifier, kBuilding.getBonusHappinessChanges())
		{
			szFirstBuffer.Format(L"%s%s", NEWLINE, gDLL->getText("TXT_KEY_BUILDINGHELP_HEALTH_HAPPINESS_CHANGE", abs(modifier.second), modifier.second ? gDLL->getSymbolID(HAPPY_CHAR) : gDLL->getSymbolID(UNHAPPY_CHAR)).c_str());
			szTempBuffer.Format(L"<link=%s>%s</link>", CvWString(GC.getBonusInfo(modifier.first).getType()).GetCString(), GC.getBonusInfo(modifier.first).getDescription());
			setListHelp(szBuffer, szFirstBuffer, szTempBuffer, L", ", (modifier.second != iLast));
			iLast = modifier.second;
		}

		iLast = 0;
		for (int iI = 0; iI < GC.getNumCivicInfos(); ++iI)
		{
			const int iChange = GC.getCivicInfo((CivicTypes)iI).getBuildingHappinessChanges(eBuilding);
			if (0 != iChange)
			{
				szFirstBuffer.Format(L"%s%s", NEWLINE, gDLL->getText("TXT_KEY_BUILDINGHELP_CIVIC_HEALTH_HAPPINESS_CHANGE", abs(iChange), ((iChange > 0) ? gDLL->getSymbolID(HAPPY_CHAR): gDLL->getSymbolID(UNHAPPY_CHAR))).c_str());
				szTempBuffer.Format(L"<link=%s>%s</link>", CvWString(GC.getCivicInfo((CivicTypes)iI).getType()).GetCString(), GC.getCivicInfo((CivicTypes)iI).getDescription());
				setListHelp(szBuffer, szFirstBuffer, szTempBuffer, L", ", (iChange != iLast));
				iLast = iChange;
			}
		}

		foreach_(const UnitCombatModifier2& modifier, kBuilding.getUnitCombatFreeExperience())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_FREE_XP", GC.getUnitCombatInfo(modifier.first).getTextKeyWide(), modifier.second));
		}

		for (int iI = 0; iI < NUM_DOMAIN_TYPES; ++iI)
		{
			if (kBuilding.getDomainFreeExperience(iI) != 0)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_FREE_XP", GC.getDomainInfo((DomainTypes)iI).getTextKeyWide(), kBuilding.getDomainFreeExperience(iI)));
			}

		}

		for (int iI = 0; iI < NUM_DOMAIN_TYPES; ++iI)
		{
			if (kBuilding.getDomainProductionModifier(iI) != 0)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_BUILDS_FASTER_DOMAIN", GC.getDomainInfo((DomainTypes)iI).getTextKeyWide(), kBuilding.getDomainProductionModifier(iI)));
			}
		}

		if (kBuilding.isForceAllTradeRoutes())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_ALL_TRADE"));
		}

		if (kBuilding.getWorldTradeRoutes() > 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_MORE_WORLD_TRADE", kBuilding.getWorldTradeRoutes()));
		}
		else if (kBuilding.getWorldTradeRoutes() < 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_LESS_WORLD_TRADE", -kBuilding.getWorldTradeRoutes()));
		}

		foreach_(const UnitModifier2& modifier, kBuilding.getUnitProductionModifiers())
		{
			CvWString szUnit;

			if (GC.getGame().canEverTrain(modifier.first))
			{
				szFirstBuffer.Format(L"%s%c%d%s", NEWLINE, gDLL->getSymbolID(BULLET_CHAR), abs(modifier.second),
					(modifier.second > 0 ? gDLL->getText("TXT_KEY_UNITHELP_CLASS_PRODUCTION_FAST_MOD") : gDLL->getText("TXT_KEY_UNITHELP_CLASS_PRODUCTION_SLOW_MOD")).c_str());

				szUnit.Format(L"<link=%s>%s</link>", CvWString(GC.getUnitInfo(modifier.first).getType()).c_str(), GC.getUnitInfo(modifier.first).getDescription());

				setListHelp(szBuffer, szFirstBuffer, szUnit, L", ", (modifier.second != iLast));
				iLast = modifier.second;
			}
		}

		CvWString szBuilding;

		iLast = 0;
		foreach_(const BuildingModifier2& modifier, kBuilding.getBuildingProductionModifiers())
		{
			if (GC.getGame().canEverConstruct(modifier.first))
			{
				szFirstBuffer.Format(L"%s%c%d%s", NEWLINE, gDLL->getSymbolID(BULLET_CHAR), abs(modifier.second), (modifier.second > 0 ? gDLL->getText("TXT_KEY_CIVICHELP_BUILDING_PRODUCTION_MOD") : gDLL->getText("TXT_KEY_CIVICHELP_BUILDING_PRODUCTION_SLOW")).c_str());
				szBuilding.Format(L"<link=%s>%s</link>", CvWString(GC.getBuildingInfo(modifier.first).getType()).GetCString(), GC.getBuildingInfo(modifier.first).getDescription());
				setListHelp(szBuffer, szFirstBuffer, szBuilding, L", ", (modifier.second != iLast));
				iLast = modifier.second;
			}
		}

		std::map<int, std::vector<BuildingTypes> > aMap;

		foreach_(const BuildingModifier2& modifier, kBuilding.getGlobalBuildingCostModifiers())
		{
			aMap[modifier.second].push_back(modifier.first);
		}
		for (std::map<int, std::vector<BuildingTypes> >::const_iterator it = aMap.begin(); it != aMap.end(); ++it)
		{
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_GLOBAL_BUILDINGCOST_MOD", it->first));

			int iI = 0;
			foreach_(const BuildingTypes eBuildingX, it->second)
			{
				if (iI++ % 3 == 0)
				{
					szBuffer.append(gDLL->getText("TXT_KEY_HELP_LIST"));
				}
				else szBuffer.append(L", ");

				szBuilding.Format(L"<link=%s>%s</link>", CvWString(GC.getBuildingInfo(eBuildingX).getType()).GetCString(), GC.getBuildingInfo(eBuildingX).getDescription());
				szBuffer.append(szBuilding);
			}
		}

		iLast = 0;
		bool bGlobal = false;
		foreach_(const BuildingModifier2& modifier, kBuilding.getGlobalBuildingProductionModifiers())
		{
			const BuildingTypes eLoopBuilding = modifier.first;

			if (GC.getGame().canEverConstruct(eLoopBuilding))
			{
				if (bGlobal && modifier.second != iLast)
					szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_GLOBAL"));
				bGlobal = true;
				szFirstBuffer.Format(L"%s%c%d%s", NEWLINE, gDLL->getSymbolID(BULLET_CHAR), abs(modifier.second), (modifier.second > 0 ? gDLL->getText("TXT_KEY_CIVICHELP_BUILDING_PRODUCTION_MOD") : gDLL->getText("TXT_KEY_CIVICHELP_BUILDING_PRODUCTION_SLOW")).c_str());
				szBuilding.Format(L"<link=%s>%s</link>", CvWString(GC.getBuildingInfo(eLoopBuilding).getType()).GetCString(), GC.getBuildingInfo(eLoopBuilding).getDescription());
				setListHelp(szBuffer, szFirstBuffer, szBuilding, L", ", (modifier.second != iLast));
				iLast = modifier.second;
			}
		}
		if (bGlobal)
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_GLOBAL"));

		//City Growth Speed Modifier

		if (kBuilding.getPopulationgrowthratepercentage() != 0)
		{
			if (kBuilding.getPopulationgrowthratepercentage() > 0)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_CITY_SLOW_GROWTH_SPEED", kBuilding.getPopulationgrowthratepercentage()));
			}
			if (kBuilding.getPopulationgrowthratepercentage() < 0)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_CITY_FAST_GROWTH_SPEED", -kBuilding.getPopulationgrowthratepercentage()));
			}
		}

		//Properties
		kBuilding.getProperties()->buildChangesString(szBuffer);
		kBuilding.getPropertiesAllCities()->buildChangesAllCitiesString(szBuffer);

		kBuilding.getPrereqMinProperties()->buildRequiresMinString(szBuffer, pCity ? pCity->getPropertiesConst() : NULL);
		kBuilding.getPrereqMaxProperties()->buildRequiresMaxString(szBuffer, pCity ? pCity->getPropertiesConst() : NULL);

		kBuilding.getPrereqPlayerMinProperties()->buildRequiresMinString(szBuffer, player ? player->getPropertiesConst() : NULL);
		kBuilding.getPrereqPlayerMaxProperties()->buildRequiresMaxString(szBuffer, player ? player->getPropertiesConst() : NULL);

		kBuilding.getPropertyManipulators()->buildDisplayString(szBuffer);
	}

	bFirst = true;
	for (int iI = 0; iI < kBuilding.getNumReplacedBuilding(); ++iI)
	{
		const BuildingTypes eBuildingX = static_cast<BuildingTypes>(kBuilding.getReplacedBuilding(iI));

		if (!bCity || pCity->isActiveBuilding(eBuildingX) || pCity->canConstruct(eBuildingX, false, true))
		{
			szFirstBuffer.Format(L"%s%s", NEWLINE, gDLL->getText("TXT_KEY_BUILDINGHELP_REPLACED_BY_BUILDING").c_str());
			szTempBuffer.Format(SETCOLR L"<link=%s>%s</link>" ENDCOLR, TEXT_COLOR("COLOR_BUILDING_TEXT"), CvWString(GC.getBuildingInfo(eBuildingX).getType()).GetCString(), GC.getBuildingInfo(eBuildingX).getDescription());
			setListHelp(szBuffer, szFirstBuffer, szTempBuffer, L", ", bFirst);
			bFirst = false;
		}
	}

	iLast = 0;
	for (int iI = 0; iI < GC.getNumBonusInfos(); ++iI)
	{
		if (kBuilding.getBonusDefenseChanges(iI) != 0)
		{
			int iBonusDefenseChange = kBuilding.getBonusDefenseChanges(iI);
			szFirstBuffer.Format(L"%s%c%s%d%s", NEWLINE, gDLL->getSymbolID(BULLET_CHAR), (iBonusDefenseChange > 0 ? L"+" : L""), iBonusDefenseChange, gDLL->getText("TXT_KEY_BUILDINGHELP_BONUS_DEFENSE_CHANGE").c_str());
			szTempBuffer.Format(L"<link=%s>%s</link>", CvWString(GC.getBonusInfo((BonusTypes)iI).getType()).GetCString(), GC.getBonusInfo((BonusTypes)iI).getDescription());
			setListHelp(szBuffer, szFirstBuffer, szTempBuffer, L", ", (iBonusDefenseChange != iLast));
			iLast = iBonusDefenseChange;
		}
	}

	if (!bRelDisabled)
	{
		iLast = 0;
		foreach_(const UnitCombatModifier2& modifier, kBuilding.getUnitCombatExtraStrength())
		{
			szFirstBuffer.Format(L"%s%c%s%d%s", NEWLINE, gDLL->getSymbolID(BULLET_CHAR), (modifier.second > 0 ? L"+" : L""), modifier.second, gDLL->getText("TXT_KEY_BUILDINGHELP_UNITCOMBAT_EXTRA_STRENGTH").c_str());
			szTempBuffer.Format(L"<link=%s>%s</link>", CvWString(GC.getUnitCombatInfo(modifier.first).getType()).GetCString(), GC.getUnitCombatInfo(modifier.first).getDescription());
			setListHelp(szBuffer, szFirstBuffer, szTempBuffer, L", ", (modifier.second != iLast));
			if (iLast != modifier.second)
				szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_IN_CITY"));
			iLast = modifier.second;
		}
		/*
		iLast = 0;
		for (int iI = 0; iI < NUM_YIELD_TYPES; ++iI)
		{
			for (int iJ = 0; iJ < GC.getNumImprovementInfos(); iJ++)
			{
				if (kBuilding.getImprovementYieldChanges(iJ, iI) != 0)
				{
					szFirstBuffer.Format(L"%s%s", NEWLINE, gDLL->getText("TXT_KEY_CIVICHELP_IMPROVEMENT_YIELD_CHANGE", kBuilding.getImprovementYieldChanges(iJ, iI), GC.getYieldInfo((YieldTypes)iI).getChar()).c_str());
					CvWString szImprovement;
					szImprovement.Format(L"<link=%s>%s</link>", CvWString(GC.getImprovementInfo((ImprovementTypes)iJ).getType()).GetCString(), GC.getImprovementInfo((ImprovementTypes)iJ).getDescription());
					setListHelp(szBuffer, szFirstBuffer, szImprovement, L", ", (kBuilding.getImprovementYieldChanges(iJ, iI) != iLast));
					iLast = kBuilding.getImprovementYieldChanges(iJ, iI);
				}
			}
		}
		*/
		bFirst = true;
		for (int iI = 0; iI < GC.getNumUnitInfos(); ++iI)
		{
			if (GC.getUnitInfo((UnitTypes)iI).isPrereqAndBuilding((int)eBuilding))
			{
				szFirstBuffer.Format(L"%s%s", NEWLINE, gDLL->getText("TXT_KEY_BUILDINGHELP_REQUIRED_TO_TRAIN").c_str());

				if (ePlayer != NO_PLAYER)
				{
					szTempBuffer.Format( SETCOLR L"<link=%s>%s</link>" ENDCOLR , TEXT_COLOR("COLOR_UNIT_TEXT"), CvWString(GC.getUnitInfo((UnitTypes)iI).getType()).GetCString(), GC.getUnitInfo((UnitTypes)iI).getDescription(player->getCivilizationType()));
				}
				else
				{
					szTempBuffer.Format( SETCOLR L"<link=%s>%s</link>" ENDCOLR , TEXT_COLOR("COLOR_UNIT_TEXT"), CvWString(GC.getUnitInfo((UnitTypes)iI).getType()).GetCString(), GC.getUnitInfo((UnitTypes)iI).getDescription());
				}

				setListHelp(szBuffer, szFirstBuffer, szTempBuffer, L", ", bFirst);
				bFirst = false;
			}
		}

		bFirst = true;
		for (int iI = 0; iI < GC.getNumUnitInfos(); ++iI)
		{
			if (GC.getUnitInfo((UnitTypes)iI).isPrereqOrBuilding((int)eBuilding))
			{
				szFirstBuffer.Format(L"%s%s", NEWLINE, gDLL->getText("TXT_KEY_BUILDINGHELP_NEEDED_TO_TRAIN").c_str());

				if (ePlayer != NO_PLAYER)
				{
					szTempBuffer.Format( SETCOLR L"<link=%s>%s</link>" ENDCOLR , TEXT_COLOR("COLOR_UNIT_TEXT"), CvWString(GC.getUnitInfo((UnitTypes)iI).getType()).GetCString(), GC.getUnitInfo((UnitTypes)iI).getDescription(player->getCivilizationType()));
				}
				else
				{
					szTempBuffer.Format( SETCOLR L"<link=%s>%s</link>" ENDCOLR , TEXT_COLOR("COLOR_UNIT_TEXT"), CvWString(GC.getUnitInfo((UnitTypes)iI).getType()).GetCString(), GC.getUnitInfo((UnitTypes)iI).getDescription());
				}

				setListHelp(szBuffer, szFirstBuffer, szTempBuffer, L", ", bFirst);
				bFirst = false;
			}
		}

		bFirst = true;
		int iCount = 0;

		for (int iI = 0; iI < GC.getNumUnitInfos(); ++iI)
		{
			if (GC.getUnitInfo((UnitTypes)iI).getHasBuilding(eBuilding))
			{
				iCount++;
				if (!bCivilopediaText && (iCount > 5))
				{
					szBuffer.append(L", ...");
					break;
				}

				szFirstBuffer.Format(L"%s%s", NEWLINE, gDLL->getText("TXT_KEY_UNITHELP_REQUIRED_TO_BUILD").c_str());

				if (player)
				{
					szTempBuffer.Format( SETCOLR L"<link=%s>%s</link>" ENDCOLR , TEXT_COLOR("COLOR_UNIT_TEXT"), CvWString(GC.getUnitInfo((UnitTypes)iI).getType()).GetCString(), GC.getUnitInfo((UnitTypes)iI).getDescription(player->getCivilizationType()));
				}
				else
				{
					szTempBuffer.Format( SETCOLR L"<link=%s>%s</link>" ENDCOLR , TEXT_COLOR("COLOR_UNIT_TEXT"), CvWString(GC.getUnitInfo((UnitTypes)iI).getType()).GetCString(), GC.getUnitInfo((UnitTypes)iI).getDescription());
				}
				setListHelp(szBuffer, szFirstBuffer, szTempBuffer, L", ", bFirst);
				bFirst = false;
			}
		}

		iLast = 0;

		foreach_(const BuildingModifier2& pair, kBuilding.getBuildingHappinessChanges())
		{
			// Use absolute value with unhappy face
			szTempBuffer.Format(L"%s%s", NEWLINE, gDLL->getText("TXT_KEY_BUILDINGHELP_HAPPINESS_CHANGE", abs(pair.second),
				(pair.second > 0 ? gDLL->getSymbolID(HAPPY_CHAR) : gDLL->getSymbolID(UNHAPPY_CHAR))).c_str());

			CvWString szBuilding;
			szBuilding.Format(L"<link=%s>%s</link>", CvWString(GC.getBuildingInfo(pair.first).getType()).GetCString(), GC.getBuildingInfo(pair.first).getDescription());
			setListHelp(szBuffer, szTempBuffer, szBuilding, L", ", (pair.second != iLast));
			iLast = pair.second;
		}
	}

	if (kBuilding.getPowerBonus() != NO_BONUS)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_PROVIDES_POWER_WITH", CvWString(GC.getBonusInfo((BonusTypes)kBuilding.getPowerBonus()).getType()).GetCString(), GC.getBonusInfo((BonusTypes)kBuilding.getPowerBonus()).getTextKeyWide()));
	}

	bFirst = true;
	for (int iI = 0; iI < GC.getNumBuildingInfos(); ++iI)
	{
		const BuildingTypes eLoopBuilding = static_cast<BuildingTypes>(iI);

		if (GC.getBuildingInfo(eLoopBuilding).isPrereqInCityBuilding(eBuilding)
		&& (!bCity || pCity->canConstruct(eLoopBuilding, false, true)))
		{
			szFirstBuffer.Format(L"%s%s", NEWLINE, gDLL->getText("TXT_KEY_BUILDINGHELP_REQUIRED_TO_BUILD").c_str());
			szTempBuffer.Format(SETCOLR L"<link=%s>%s</link>" ENDCOLR, TEXT_COLOR("COLOR_BUILDING_TEXT"), CvWString(GC.getBuildingInfo(eLoopBuilding).getType()).GetCString(), GC.getBuildingInfo(eLoopBuilding).getDescription());
			setListHelp(szBuffer, szFirstBuffer, szTempBuffer, L", ", bFirst);
			bFirst = false;
		}
	}

	bFirst = true;
	for (int iI = 0; iI < GC.getNumBuildingInfos(); ++iI)
	{
		const BuildingTypes eLoopBuilding = static_cast<BuildingTypes>(iI);

		if (GC.getBuildingInfo(eLoopBuilding).isPrereqOrBuilding(eBuilding)
		&& (!bCity || pCity->canConstruct(eLoopBuilding, false, true)))
		{
			szFirstBuffer.Format(L"%s%s", NEWLINE, gDLL->getText("TXT_KEY_BUILDINGHELP_NEEDED_TO_BUILD").c_str());
			szTempBuffer.Format(SETCOLR L"<link=%s>%s</link>" ENDCOLR, TEXT_COLOR("COLOR_BUILDING_TEXT"), CvWString(GC.getBuildingInfo(eLoopBuilding).getType()).GetCString(), GC.getBuildingInfo(eLoopBuilding).getDescription());
			setListHelp(szBuffer, szFirstBuffer, szTempBuffer, L", ", bFirst);
			bFirst = false;
		}
	}

	bFirst = true;
	for (int iI = 0; iI < GC.getNumBuildingInfos(); ++iI)
	{
		const BuildingTypes eLoopBuilding = static_cast<BuildingTypes>(iI);

		if (GC.getBuildingInfo(eLoopBuilding).getPrereqNumOfBuildings().getValue(eBuilding)
		&& (!bCity || pCity->canConstruct(eLoopBuilding, false, true)))
		{
			szFirstBuffer.Format(L"%s%s", NEWLINE, gDLL->getText("TXT_KEY_BUILDINGHELP_NEEDED_TO_BUILD_ANYWHERE").c_str());
			szTempBuffer.Format(SETCOLR L"<link=%s>%s</link>" ENDCOLR, TEXT_COLOR("COLOR_BUILDING_TEXT"), CvWString(GC.getBuildingInfo(eLoopBuilding).getType()).GetCString(), GC.getBuildingInfo(eLoopBuilding).getDescription());
			setListHelp(szBuffer, szFirstBuffer, szTempBuffer, L", ", bFirst);
			bFirst = false;
		}
	}

	if (!bRelDisabled)
	{
		if (kBuilding.getUnitUpgradePriceModifier() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_UNIT_UPGRADE_COST_MOD", kBuilding.getUnitUpgradePriceModifier()));
		}

		if (kBuilding.getNationalCaptureProbabilityModifier() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_NATIONAL_CAPTURE_PROBABILITY_MODIFIER", kBuilding.getNationalCaptureProbabilityModifier()));
		}
		if (kBuilding.getNationalCaptureResistanceModifier() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_NATIONAL_CAPTURE_RESISTANCE_MODIFIER", kBuilding.getNationalCaptureResistanceModifier()));
		}
		if (kBuilding.getLocalCaptureProbabilityModifier() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_LOCAL_CAPTURE_PROBABILITY_MODIFIER", kBuilding.getLocalCaptureProbabilityModifier()));
		}
		if (kBuilding.getLocalCaptureResistanceModifier() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_LOCAL_CAPTURE_RESISTANCE_MODIFIER", kBuilding.getLocalCaptureResistanceModifier()));
		}
	}

	if (GC.getGame().isOption(GAMEOPTION_COMBAT_SURROUND_DESTROY))
	{
		if (kBuilding.getLocalDynamicDefense() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_LOCAL_DYNAMIC_DEFENSE", kBuilding.getLocalDynamicDefense()));
		}
	}

	if (kBuilding.getRiverDefensePenalty() > 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_RIVER_DEFENSE_PENALTY_POSITIVE", kBuilding.getRiverDefensePenalty()));
	}

	if (kBuilding.getRiverDefensePenalty() < 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_RIVER_DEFENSE_PENALTY_NEGATIVE", -kBuilding.getRiverDefensePenalty()));
	}

	if (kBuilding.getLocalRepel() != 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_CITY_REPEL", kBuilding.getLocalRepel()));
	}

	if (kBuilding.getMinDefense() != 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_MIN_DEFENSE", kBuilding.getMinDefense()));
	}

	if (kBuilding.getBuildingDefenseRecoverySpeedModifier() > 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_DEFENSE_RECOVERY_SPEED_MODIFIER_POSITIVE", kBuilding.getBuildingDefenseRecoverySpeedModifier()));
	}

	if (kBuilding.getBuildingDefenseRecoverySpeedModifier() < 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_DEFENSE_RECOVERY_SPEED_MODIFIER_NEGATIVE", -kBuilding.getBuildingDefenseRecoverySpeedModifier()));
	}

	if (kBuilding.getCityDefenseRecoverySpeedModifier() > 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_CITY_DEFENSE_RECOVERY_SPEED_MODIFIER_POSITIVE", kBuilding.getCityDefenseRecoverySpeedModifier()));
	}

	if (kBuilding.getCityDefenseRecoverySpeedModifier() < 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_CITY_DEFENSE_RECOVERY_SPEED_MODIFIER_NEGATIVE", -kBuilding.getCityDefenseRecoverySpeedModifier()));
	}

	if (bCivilopediaText)
	{
		// Trait
		foreach_(const CvTraitInfo* pTrait, GC.getTraitInfos())
		{
			for (int j = 0; j < pTrait->getNumBuildingProductionModifiers(); j++)
			{
				if (pTrait->getBuildingProductionModifier(j).eBuilding == eBuilding)
				{
					if (pTrait->getBuildingProductionModifier(j).iModifier != 0)
					{
						if (pTrait->getBuildingProductionModifier(j).iModifier == 100)
						{
							szBuffer.append(NEWLINE);
							szBuffer.append(gDLL->getText("TXT_KEY_DOUBLE_SPEED_TRAIT", pTrait->getTextKeyWide()));
						}
						else
						{
							szBuffer.append(NEWLINE);
							szBuffer.append(gDLL->getText("TXT_KEY_PRODUCTION_MODIFIER_TRAIT", pTrait->getBuildingProductionModifier(j).iModifier, pTrait->getTextKeyWide()));
						}
					}
				}
			}
		}

		if (!bRelDisabled)
		{
			foreach_(const CvTraitInfo* pTrait, GC.getTraitInfos())
			{
				foreach_(const BuildingModifier2& pair, pTrait->getBuildingHappinessModifiersFiltered())
				{
					if (pair.first == eBuilding)
					{
						szBuffer.append(NEWLINE);
						szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_HAPPINESS_TRAIT", pair.second, pTrait->getTextKeyWide()));
					}
				}
			}
		}
	}

	if (bCivilopediaText)
	{
		const UnitTypes eGreatPeopleUnit = (UnitTypes)kBuilding.getGreatPeopleUnitType();

		if (eGreatPeopleUnit!= NO_UNIT)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_LIKELY_TO_GENERATE", CvWString(GC.getUnitInfo(eGreatPeopleUnit).getType()).GetCString(), GC.getUnitInfo(eGreatPeopleUnit).getTextKeyWide()));
		}

		if (kBuilding.getFreeStartEra() != NO_ERA)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_FREE_START_ERA", GC.getEraInfo((EraTypes)kBuilding.getFreeStartEra()).getTextKeyWide()));
		}
	}

	if (!CvWString(kBuilding.getHelp()).empty())
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(kBuilding.getHelp());
	}

	buildBuildingRequiresString(szBuffer, eBuilding, bCivilopediaText, bTechChooserText, pCity);

	//AIAndy: Display in which range of a property this building is auto built
	for (int i=0; i<GC.getNumPropertyInfos(); i++)
	{
		const CvPropertyInfo& kInfo = GC.getPropertyInfo((PropertyTypes)i);
		foreach_(const PropertyBuilding& propBuilding, kInfo.getPropertyBuildings())
		{
			if (propBuilding.eBuilding == eBuilding)
			{
				szBuffer.append(NEWLINE);
				int iMinVal = propBuilding.iMinValue;
				int iMaxVal = propBuilding.iMaxValue;
				int iOpMin = kInfo.getOperationalRangeMin();
				int iOpMax = kInfo.getOperationalRangeMax();
				if (iMinVal < iOpMin - 5*(iOpMax - iOpMin))
				{
					szBuffer.append(gDLL->getText("TXT_KEY_PROPERTY_BUILDING_DISPLAY_UNDER", iMaxVal));
				}
				else if (iMaxVal > iOpMax + 5*(iOpMax - iOpMin))
				{
					szBuffer.append(gDLL->getText("TXT_KEY_PROPERTY_BUILDING_DISPLAY_OVER", iMinVal));
				}
				else
				{
					szBuffer.append(gDLL->getText("TXT_KEY_PROPERTY_BUILDING_DISPLAY", iMinVal, iMaxVal));
				}
				CvWString szTemp;
				szTemp.Format(L"%c", kInfo.getChar());
				szBuffer.append(szTemp);
			}
		}
	}

	if (bCity)
	{
		if (GC.getGame().getActivePlayer() != NO_PLAYER
		&& getBugOptionBOOL("CityScreen__BuildingDoubleCommerce", true, "BUG_BUILDING_DOUBLE_COMMERCE"))
		{
			int iYear = MIN_INT;
			if (pCity->hasBuilding(eBuilding))
			{
				iYear = pCity->getBuildingData(eBuilding).iTimeBuilt;
			}

			if (iYear != MIN_INT)
			{
				// year built
				CvWString szYear;

				if (iYear < 0)
				{
					szYear = gDLL->getText("TXT_KEY_TIME_BC", -iYear);
				}
				else if (iYear > 0)
				{
					szYear = gDLL->getText("TXT_KEY_TIME_AD", iYear);
				}
				else
				{
					szYear = gDLL->getText("TXT_KEY_TIME_AD", 1);
				}

				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_BUG_YEAR_BUILT", szYear.GetCString()));
			}

			if ( iYear == MIN_INT )
			{
				iYear = GC.getGame().getGameTurnYear();	//	Not yet built so display the full time to double commerces
			}

			// double commerce
			if (pCity->getOwner() == GC.getGame().getActivePlayer())
			{
				for (int iI = 0; iI < NUM_COMMERCE_TYPES; iI++)
				{
					// Can't just use .getCommerce because source may be tech, other.
					if (pCity->getBuildingCommerceByBuilding((CommerceTypes)iI, eBuilding, true, true) == 0) continue;

					int iDoubleTime = kBuilding.getCommerceChangeDoubleTime(iI);

					int iAge = GC.getGame().getGameTurnYear() - iYear;
					if (iAge < iDoubleTime)
					{
						szBuffer.append(NEWLINE);
						if (iAge - iDoubleTime == 1)
						{
							szBuffer.append(gDLL->getText("TXT_KEY_BUG_DOUBLE_COMMERCE_NEXT_YEAR", GC.getCommerceInfo((CommerceTypes)iI).getTextKeyWide()));
						}
						else
						{
							szBuffer.append(gDLL->getText("TXT_KEY_BUG_DOUBLE_COMMERCE_YEARS", GC.getCommerceInfo((CommerceTypes)iI).getTextKeyWide(), iDoubleTime - iAge));
						}
					}
					else if (iDoubleTime > 0)
					{
						szBuffer.append(NEWLINE);
						szBuffer.append(gDLL->getText("TXT_KEY_BUG_DOUBLE_COMMERCE_COMPLETE", iDoubleTime, GC.getCommerceInfo((CommerceTypes)iI).getTextKeyWide()));
					}
				}
			}
		}

		if (!kBuilding.isNoLimit())
		{
			if (isWorldWonder(eBuilding))
			{
				if (pCity->isWorldWondersMaxed())
				{
					szBuffer.append(NEWLINE);
					szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_WORLD_WONDERS_PER_CITY", GC.getCultureLevelInfo(pCity->getCultureLevel()).getMaxWorldWonders()));
				}
			}
			else if (isTeamWonder(eBuilding))
			{
				if (pCity->isTeamWondersMaxed())
				{
					szBuffer.append(NEWLINE);
					szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_TEAM_WONDERS_PER_CITY", GC.getCultureLevelInfo(pCity->getCultureLevel()).getMaxTeamWonders()));
				}
			}
			else if (isNationalWonder(eBuilding))
			{
				if (pCity->isNationalWondersMaxed())
				{
					const int iMaxNumWonders = GC.getGame().isOption(GAMEOPTION_CHALLENGE_ONE_CITY) ? GC.getCultureLevelInfo(pCity->getCultureLevel()).getMaxNationalWondersOCC() : GC.getCultureLevelInfo(pCity->getCultureLevel()).getMaxNationalWonders();
					szBuffer.append(NEWLINE);
					szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_NATIONAL_WONDERS_PER_CITY", iMaxNumWonders));
				}
			}
		}
	}

	if (!bCity || !pCity->hasBuilding(eBuilding))
	{
		if (!bCivilopediaText)
		{
			if (bCity)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_NUM_TURNS", pCity->getProductionTurnsLeft(eBuilding, ((gDLL->ctrlKey() || !(gDLL->shiftKey())) ? 0 : pCity->getOrderQueueLength()))));

				if (pCity->getProgressOnBuilding(eBuilding) > 0)
				{
					szTempBuffer.Format(L" - %d/%d%c", pCity->getProgressOnBuilding(eBuilding), pCity->getProductionNeeded(eBuilding), GC.getYieldInfo(YIELD_PRODUCTION).getChar());
					szBuffer.append(szTempBuffer);

					if (pCity->getDelayOnBuilding(eBuilding) > 0)
					{
						szBuffer.append(NEWLINE);
						const int iTurnsLeft = pCity->getBuildingProductionDecayTurns(eBuilding);

						if (iTurnsLeft < 2)
						{
							szBuffer.append(gDLL->getText("TXT_KEY_PRODUCTION_DECAY", pCity->getBuildingProductionDecay(eBuilding)));
						}
						else szBuffer.append(gDLL->getText("TXT_KEY_PRODUCTION_DECAY_TURNS", pCity->getBuildingProductionDecay(eBuilding), iTurnsLeft));
					}
				}
				else
				{
					szTempBuffer.Format(L" - %d%c", pCity->getProductionNeeded(eBuilding), GC.getYieldInfo(YIELD_PRODUCTION).getChar());
					szBuffer.append(szTempBuffer);
				}
			}
			else if (kBuilding.getProductionCost() > 0)
			{
				szTempBuffer.Format(L"\n%d%c", (player ? player->getProductionNeeded(eBuilding) : kBuilding.getProductionCost()), GC.getYieldInfo(YIELD_PRODUCTION).getChar());
				szBuffer.append(szTempBuffer);
			}
		}

		for (int iI = 0; iI < GC.getNumBonusInfos(); ++iI)
		{
			if (kBuilding.getBonusProductionModifier(iI) != 0)
			{
				if (bCity)
				{
					if (pCity->hasBonus((BonusTypes)iI))
					{
						szBuffer.append(gDLL->getText("TXT_KEY_COLOR_POSITIVE"));
					}
					else
					{
						szBuffer.append(gDLL->getText("TXT_KEY_COLOR_NEGATIVE"));
					}
				}
				if (!bCivilopediaText)
				{
					szBuffer.append(L" (");
				}
				else
				{
					szTempBuffer.Format(L"\n%c", gDLL->getSymbolID(BULLET_CHAR), szTempBuffer.c_str());
					szBuffer.append(szTempBuffer);
				}
				if (kBuilding.getBonusProductionModifier(iI) == 100)
				{
					szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_DOUBLE_SPEED_WITH", CvWString(GC.getBonusInfo((BonusTypes)iI).getType()).GetCString(), GC.getBonusInfo((BonusTypes) iI).getTextKeyWide()));
				}
				else
				{
					szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_BUILDS_FASTER_WITH", kBuilding.getBonusProductionModifier(iI), CvWString(GC.getBonusInfo((BonusTypes)iI).getType()).GetCString(), GC.getBonusInfo((BonusTypes) iI).getTextKeyWide()));
				}
				if (!bCivilopediaText)
				{
					szBuffer.append(L')');
				}
				if (bCity)
				{
					szBuffer.append(gDLL->getText("TXT_KEY_COLOR_REVERT"));
				}
			}
		}

		if (kBuilding.getObsoleteTech() != NO_TECH)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_OBSOLETE_WITH", CvWString(GC.getTechInfo(kBuilding.getObsoleteTech()).getType()).GetCString(), GC.getTechInfo(kBuilding.getObsoleteTech()).getTextKeyWide()));

			const BuildingTypes iObsoletesToBuilding = kBuilding.getObsoletesToBuilding();
			if (iObsoletesToBuilding != NO_BUILDING)
			{
				szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_OBSOLETE_WITH_TO", CvWString(GC.getBuildingInfo(iObsoletesToBuilding).getType()).GetCString(), GC.getBuildingInfo(iObsoletesToBuilding).getDescription()));
			}
		}

		if (kBuilding.getSpecialBuilding() != NO_SPECIALBUILDING)
		{
			if (GC.getSpecialBuildingInfo(kBuilding.getSpecialBuilding()).getObsoleteTech() != NO_TECH)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_OBSOLETE_WITH", CvWString(GC.getTechInfo(GC.getSpecialBuildingInfo(kBuilding.getSpecialBuilding()).getObsoleteTech()).getType()).c_str(), GC.getTechInfo(GC.getSpecialBuildingInfo(kBuilding.getSpecialBuilding()).getObsoleteTech()).getTextKeyWide()));
			}
		}
	}

	if (bCity && gDLL->ctrlKey() && GC.getGame().isDebugMode())
	{
		szBuffer.append(CvWString::format(L"\nAI Building Value = %d", pCity->AI_buildingValue(eBuilding, 0, false, true)));
	}

	if (bStrategyText && !CvWString(kBuilding.getStrategy()).empty()
	&& (!player || player->isOption(PLAYEROPTION_ADVISOR_HELP)))
	{
		szBuffer.append(SEPARATOR);
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_SIDS_TIPS"));
		szBuffer.append(L'\"');
		szBuffer.append(kBuilding.getStrategy());
		szBuffer.append(L'\"');
	}

	if (bCivilopediaText)
	{
		foreach_(const MapCategoryTypes eMapCategory, kBuilding.getMapCategories())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_MAP_CATEGORY_PREREQUISITE", GC.getMapCategoryInfo(eMapCategory).getTextKeyWide()));
		}
	}
}

void CvGameTextMgr::setHeritageHelp(CvWStringBuffer &szBuffer, const HeritageTypes eType, CvCity* pCity, const bool bCivilopediaText, const bool bStrategyText, const bool bTechChooserText)
{
	PROFILE_FUNC();

	if (NO_HERITAGE == eType)
	{
		return;
	}
	const PlayerTypes ePlayer = pCity ? pCity->getOwner() : GC.getGame().getActivePlayer();
	const CvPlayer* player = ePlayer != NO_PLAYER ? &GET_PLAYER(ePlayer) : NULL;

	const bool bCanAddHeritage = player && player->canAddHeritage(eType);

	const CvHeritageInfo& heritage = GC.getHeritageInfo(eType);

	if (!CvWString(heritage.getHelp()).empty())
	{
		szBuffer.append(heritage.getHelp());
		szBuffer.append(NEWLINE);
	}

	if (bCivilopediaText || !bCanAddHeritage)
	{
		const TechTypes eTech = static_cast<TechTypes>(heritage.getPrereqTech());
		if (!bTechChooserText && heritage.getPrereqTech() != NO_TECH)
		{
			szBuffer.append(gDLL->getText("TXT_KEY_REQUIRES_LINK", CvWString(GC.getTechInfo(eTech).getType()).GetCString(), GC.getTechInfo(eTech).getDescription()));
			szBuffer.append(NEWLINE);
		}
		bool bFirst = true;
		foreach_(const HeritageTypes eTypeX, heritage.getPrereqOrHeritage())
		{
			CvWString szTempBuffer;
			szTempBuffer.Format(L"<link=%s>%s</link>", CvWString(GC.getHeritageInfo(eTypeX).getType()).GetCString(), GC.getHeritageInfo(eTypeX).getDescription());

			setListHelp(szBuffer, gDLL->getText("TXT_KEY_REQUIRES_2"), szTempBuffer, gDLL->getText("TXT_KEY_OR").c_str(), bFirst);
			bFirst = false;
		}
		if (!bFirst)
		{
			szBuffer.append(NEWLINE);
		}
	}

	foreach_(const EraCommerceArray& pair, heritage.getEraCommerceChanges100())
	{
		bool bFirst = true;
		for (int iI = 0; iI < NUM_COMMERCE_TYPES; ++iI)
		{
			if (pair.second[iI] != 0)
			{
				if (bFirst)
				{
					szBuffer.append(
						CvWString::format(
							L"%c%s <link=%s>%s</link>: ",
							gDLL->getSymbolID(BULLET_CHAR), gDLL->getText("TXT_WORD_WITH").GetCString(),
							CvWString(GC.getEraInfo(pair.first).getType()).GetCString(),
							GC.getEraInfo(pair.first).getDescription()
						)
					);
					bFirst = false;
				}
				else szBuffer.append(L", ");

				CvWString szValue;
				makeValueString(szValue, pair.second[iI], true);
				szBuffer.append(CvWString::format(L"%s%c", szValue.GetCString(), GC.getCommerceInfo((CommerceTypes) iI).getChar()));
			}
		}
		if (!bFirst)
		{
			szBuffer.append(NEWLINE);
		}
	}

	{
		bool bFirst = true;
		int iCount = 0;
		for (int iI = 0; iI < GC.getNumUnitInfos(); ++iI)
		{
			if (GC.getUnitInfo((UnitTypes)iI).getHasHeritage(eType))
			{
				iCount++;
				if (!bCivilopediaText && (iCount > 5))
				{
					szBuffer.append(L", ...");
					break;
				}
				CvWString szTempBuffer;
				szTempBuffer.Format( SETCOLR L"<link=%s>%s</link>" ENDCOLR , TEXT_COLOR("COLOR_UNIT_TEXT"), CvWString(GC.getUnitInfo((UnitTypes)iI).getType()).GetCString(), GC.getUnitInfo((UnitTypes)iI).getDescription());

				setListHelp(szBuffer, gDLL->getText("TXT_KEY_UNITHELP_REQUIRED_TO_BUILD"), szTempBuffer, L", ", bFirst);
				bFirst = false;
			}
		}
	}

	if (heritage.getPropertyManipulators())
		heritage.getPropertyManipulators()->buildDisplayString(szBuffer);

	if (bStrategyText && !CvWString(heritage.getStrategy()).empty()
	&& (!player || player->isOption(PLAYEROPTION_ADVISOR_HELP)))
	{
		szBuffer.append(SEPARATOR);
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_SIDS_TIPS"));
		szBuffer.append(L'\"');
		szBuffer.append(heritage.getStrategy());
		szBuffer.append(L'\"');
	}
}


void CvGameTextMgr::buildBuildingRequiresString(CvWStringBuffer& szBuffer, BuildingTypes eBuilding, bool bCivilopediaText, bool bTechChooserText, const CvCity* pCity)
{
	PROFILE_EXTRA_FUNC();
	bool bFirst;
	CvWString szTempBuffer;
	CvWString szFirstBuffer;
	const CvBuildingInfo& kBuilding = GC.getBuildingInfo(eBuilding);

	const PlayerTypes ePlayer = pCity ? pCity->getOwner() : GC.getGame().getActivePlayer();

	const bool bCanConstruct = pCity && pCity->canConstruct(eBuilding);

	//	Future - do the green/red text thing with all of this - for now just civics do it
	//	so can skip the rest of teh code for constructable buildings
	if (!bCanConstruct)
	{
		bFirst = true;

		if (kBuilding.getSpecialBuilding() != NO_SPECIALBUILDING
		&& (!pCity || !GC.getGame().isSpecialBuildingValid(kBuilding.getSpecialBuilding())))
		{
			for (int iI = 0; iI < GC.getNumProjectInfos(); ++iI)
			{
				if (GC.getProjectInfo((ProjectTypes)iI).getEveryoneSpecialBuilding() == kBuilding.getSpecialBuilding())
				{
					CvWString szProject;
					szProject.Format(L"<link=%s>%s</link>", CvWString(GC.getProjectInfo((ProjectTypes)iI).getType()).GetCString(), GC.getProjectInfo((ProjectTypes)iI).getDescription());
					setListHelp(szBuffer, gDLL->getText("TXT_KEY_REQUIRES"), szProject, gDLL->getText("TXT_KEY_OR").c_str(), bFirst);
					bFirst = false;
				}
			}
		}
		if (!bFirst)
		{
			szBuffer.append(ENDCOLR);
		}

		TechTypes eTech = NO_TECH;
		if (kBuilding.getSpecialBuilding() != NO_SPECIALBUILDING)
		{
			if (!pCity || !GC.getGame().isSpecialBuildingValid(kBuilding.getSpecialBuilding()))
			{
				eTech = (TechTypes)GC.getSpecialBuildingInfo(kBuilding.getSpecialBuilding()).getTechPrereqAnyone();
				if (NO_TECH != eTech)
				{
					szBuffer.append(NEWLINE);
					szBuffer.append(gDLL->getText("TXT_KEY_REQUIRES_TECH_ANYONE", CvWString(GC.getTechInfo(eTech).getType()).GetCString(), GC.getTechInfo(eTech).getTextKeyWide()));
				}
			}
			eTech = (TechTypes)GC.getSpecialBuildingInfo(kBuilding.getSpecialBuilding()).getTechPrereq();

			if (NO_TECH != eTech && (!pCity || !GET_TEAM(pCity->getTeam()).isHasTech(eTech)))
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_REQUIRES_LINK", CvWString(GC.getTechInfo(eTech).getType()).GetCString(), GC.getTechInfo(eTech).getTextKeyWide()));
			}
		}

		foreach_(const BuildingModifier2& modifier, kBuilding.getPrereqNumOfBuildings())
		{
			if (modifier.second > 0)
			{
				if (ePlayer == NO_PLAYER)
				{
					szBuffer.append(
						CvWString::format(
							L"%s%s", NEWLINE,
							gDLL->getText(
								"TXT_KEY_HELPTEXT_REQUIRES_NUM_BUILDINGS_0",
								CvWString(GC.getBuildingInfo(modifier.first).getType()).GetCString(),
								GC.getBuildingInfo(modifier.first).getDescription(),
								modifier.second
							).c_str()
						)
					);
				}
				else
				{
					szBuffer.append(
						CvWString::format(
							L"%s%s", NEWLINE,
							gDLL->getText(
								"TXT_KEY_HELPTEXT_REQUIRES_NUM_BUILDINGS_1",
								CvWString(GC.getBuildingInfo(modifier.first).getType()).GetCString(),
								GC.getBuildingInfo(modifier.first).getDescription(),
								GET_PLAYER(ePlayer).getBuildingCount(modifier.first),
								GET_PLAYER(ePlayer).getBuildingPrereqBuilding(eBuilding, modifier.first)
							).c_str()
						)
					);
				}
			}
		}
		for (int iI = 0; iI < GC.getNumBuildingInfos(); ++iI)
		{
			if (kBuilding.isPrereqInCityBuilding(iI) && (!pCity || !GET_TEAM(pCity->getTeam()).isObsoleteBuilding((BuildingTypes)iI) && !pCity->isActiveBuilding((BuildingTypes)iI)))
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_REQUIRES_LINK", CvWString(GC.getBuildingInfo((BuildingTypes)iI).getType()).GetCString(), GC.getBuildingInfo((BuildingTypes)iI).getTextKeyWide()));
			}
		}

		if (kBuilding.getNumCitiesPrereq() > 0
		&& (NO_PLAYER == ePlayer || GET_PLAYER(ePlayer).getNumCities() < kBuilding.getNumCitiesPrereq()))
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_REQUIRES_NUM_CITIES", kBuilding.getNumCitiesPrereq()));
		}

		if (kBuilding.getUnitLevelPrereq() > 0
		&& (NO_PLAYER == ePlayer || GET_PLAYER(ePlayer).getHighestUnitLevel() < kBuilding.getUnitLevelPrereq()))
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_REQUIRES_UNIT_LEVEL", kBuilding.getUnitLevelPrereq()));
		}

		if (kBuilding.getMinLatitude() > 0 && (!pCity || pCity->plot()->getLatitude() < kBuilding.getMinLatitude()))
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_MIN_LATITUDE", kBuilding.getMinLatitude()));
		}

		if (kBuilding.getMaxLatitude() < 90 && (!pCity || pCity->plot()->getLatitude() > kBuilding.getMaxLatitude()))
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_MAX_LATITUDE", kBuilding.getMaxLatitude()));
		}

		if (kBuilding.needStateReligionInCity()
		&& (!pCity || NO_PLAYER == ePlayer || NO_RELIGION == GET_PLAYER(ePlayer).getStateReligion() || !pCity->isHasReligion(GET_PLAYER(ePlayer).getStateReligion())))
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_REQUIRES_STATE_RELIGION"));
		}

		if (kBuilding.getHolyCity() != NO_RELIGION
		&& (!pCity || !pCity->isHolyCity((ReligionTypes)(kBuilding.getHolyCity()))))
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_ACTION_ONLY_HOLY_CONSTRUCT", GC.getReligionInfo((ReligionTypes) kBuilding.getHolyCity()).getChar()));
		}

		if (kBuilding.getPrereqReligion() != NO_RELIGION
		&& (!pCity || NO_PLAYER == ePlayer || !pCity->isHasReligion((ReligionTypes)kBuilding.getPrereqReligion())))
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_REQUIRES_PREREQUISITE_RELIGION", GC.getReligionInfo((ReligionTypes)kBuilding.getPrereqReligion()).getChar()));
		}

		if (kBuilding.getReligionType() != NO_RELIGION)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_RELIGION_DECLARED", GC.getReligionInfo((ReligionTypes)(kBuilding.getReligionType())).getChar()));
		}

		if (kBuilding.getPrereqStateReligion() != NO_RELIGION)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_STATE_RELIGION_PREREQ", GC.getReligionInfo((ReligionTypes)(kBuilding.getPrereqStateReligion())).getChar()));
		}

		bFirst = true;
		foreach_(const HeritageTypes eTypeX, kBuilding.getPrereqOrHeritage())
		{
			if (bFirst)
			{
				szBuffer.append(NEWLINE);
			}
			szTempBuffer.Format(L"<link=%s>%s</link>", CvWString(GC.getHeritageInfo(eTypeX).getType()).GetCString(), GC.getHeritageInfo(eTypeX).getDescription());

			setListHelp(szBuffer, gDLL->getText("TXT_KEY_REQUIRES_2"), szTempBuffer, gDLL->getText("TXT_KEY_OR").c_str(), bFirst);
			bFirst = false;
		}
	}

	bFirst = true;
	bool civicRequirementsAllMet = true;
	{
		bool bLastCivicWasMet = false;
		for (int iI = 0; iI < GC.getNumCivicInfos(); ++iI)
		{
			if (kBuilding.isPrereqAndCivics(CivicTypes(iI)))
			{
				if (GC.getGame().getActivePlayer() == NO_PLAYER || !GET_PLAYER(GC.getGame().getActivePlayer()).isCivic((CivicTypes)iI))
				{
					if (bLastCivicWasMet && !bFirst)
					{
						szBuffer.append(gDLL->getText("TXT_KEY_SET_WARNING_COLOR").c_str());
					}
					setListHelp(szBuffer, gDLL->getText("TXT_KEY_REQUIRES"), GC.getCivicInfo((CivicTypes(iI))).getDescription(), gDLL->getText("TXT_KEY_AND").c_str(), bFirst);
					bLastCivicWasMet = false;
					civicRequirementsAllMet = false;
				}
				else
				{
					if (!bLastCivicWasMet && !bFirst)
					{
						szBuffer.append(gDLL->getText("TXT_KEY_REVERT_COLOR").c_str());
					}
					szTempBuffer.Format(L"%s%s", NEWLINE, gDLL->getText("TXT_KEY_REQUIRES_NO_WARNING").c_str());
					setListHelp(szBuffer, szTempBuffer, GC.getCivicInfo((CivicTypes(iI))).getDescription(), gDLL->getText("TXT_KEY_AND").c_str(), bFirst);
					bLastCivicWasMet = true;
				}
				bFirst = false;
			}
		}
	}

	bFirst = true;
	{
		const CvWString prefix = gDLL->getText("TXT_KEY_REQUIRES_NO_WARNING");
		const CvWString separator = gDLL->getText("TXT_KEY_REVERT_COLOR") + gDLL->getText("TXT_KEY_OR");
		bool bCivicORRequirementMet = false;

		for (int iI = 0; iI < GC.getNumCivicInfos(); ++iI)
		{
			if (kBuilding.isPrereqOrCivics(CivicTypes(iI)))
			{
				CvWString desc = GC.getCivicInfo((CivicTypes(iI))).getDescription();

				if (GC.getGame().getActivePlayer() != NO_PLAYER && GET_PLAYER(GC.getGame().getActivePlayer()).isCivic(CivicTypes(iI)))
				{
					desc = gDLL->getText("TXT_KEY_POSITIVE_COLOR") + desc;
					bCivicORRequirementMet= true;
				}
				else desc = gDLL->getText("TXT_KEY_SET_WARNING_COLOR") + desc;

				szTempBuffer.Format(L"%s%s", NEWLINE, prefix.c_str());
				setListHelp(szBuffer,szTempBuffer, desc.c_str(), separator.c_str(), bFirst);
				bFirst = false;
			}
		}
		civicRequirementsAllMet &= (bFirst || bCivicORRequirementMet);
	}

	if (kBuilding.isRequiresActiveCivics())
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText(civicRequirementsAllMet ? "TXT_KEY_BUILDINGHELP_REQUIRES_ACTIVE_CIVICS_MET" : "TXT_KEY_BUILDINGHELP_REQUIRES_ACTIVE_CIVICS"));
	}

	if (!bCanConstruct)
	{
		if (kBuilding.getPrereqVicinityBonus() != NO_BONUS
		&& (!pCity || !pCity->hasVicinityBonus((BonusTypes)kBuilding.getPrereqVicinityBonus())))
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_REQUIRES_BONUS_VICINITY", GC.getBonusInfo((BonusTypes)kBuilding.getPrereqVicinityBonus()).getTextKeyWide(), CvWString(GC.getBonusInfo((BonusTypes)kBuilding.getPrereqVicinityBonus()).getType()).GetCString()));
		}

		if (kBuilding.getPrereqRawVicinityBonus() != NO_BONUS
		&& (!pCity || !pCity->hasRawVicinityBonus((BonusTypes)kBuilding.getPrereqRawVicinityBonus())))
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_REQUIRES_BONUS_RAWVICINITY", GC.getBonusInfo((BonusTypes)kBuilding.getPrereqRawVicinityBonus()).getTextKeyWide(), CvWString(GC.getBonusInfo((BonusTypes)kBuilding.getPrereqRawVicinityBonus()).getType()).GetCString()));
		}

		CvWStringBuffer szBonusList;
		bFirst = true;

		foreach_(const BonusTypes ePrereqBonus, kBuilding.getPrereqOrVicinityBonuses())
		{
			if (!pCity || !pCity->hasVicinityBonus(ePrereqBonus))
			{
				szTempBuffer.Format(L"%s%s", NEWLINE, gDLL->getText("TXT_KEY_REQUIRES_BONUS_VICINITY_ONEOF").c_str());
				setListHelp(szBonusList, szTempBuffer, gDLL->getText("TXT_KEY_LINK", CvWString(GC.getBonusInfo(ePrereqBonus).getType()).GetCString(), GC.getBonusInfo(ePrereqBonus).getDescription()), gDLL->getText("TXT_KEY_OR").c_str(), bFirst);
				bFirst = false;
			}
			else if (pCity)
			{
				bFirst = true;
				break;
			}
		}

		if (!bFirst)
		{
			szBonusList.append(ENDCOLR);
			szBuffer.append(szBonusList);
		}

		CvWStringBuffer szRawBonusList;
		bFirst = true;

		foreach_(const BonusTypes bonus, kBuilding.getPrereqOrRawVicinityBonuses())
		{
			if (!pCity || !pCity->hasRawVicinityBonus(bonus))
			{
				szTempBuffer.Format(L"%s%s", NEWLINE, gDLL->getText("TXT_KEY_REQUIRES_BONUS_RAWVICINITY_ONEOF").c_str());
				setListHelp(szRawBonusList, szTempBuffer, gDLL->getText("TXT_KEY_LINK", CvWString(GC.getBonusInfo(bonus).getType()).GetCString(), GC.getBonusInfo(bonus).getDescription()), gDLL->getText("TXT_KEY_OR").c_str(), bFirst);
				bFirst = false;
			}
			else if (pCity)
			{
				bFirst = true;
				break;
			}
		}

		if (!bFirst)
		{
			szBonusList.append(ENDCOLR);
			szBuffer.append(szRawBonusList);
		}

		if (kBuilding.isPrereqPower() && (!pCity || !pCity->isPower()))
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_REQUIRES_POWER"));
			szBuffer.append(CvWString::format(L" (%c)", gDLL->getSymbolID(POWER_CHAR)));
		}

		if (kBuilding.isPrereqWar() && (!pCity || !GET_TEAM(pCity->getTeam()).isAtWar()))
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_REQUIRES_WARTIME"));
		}

		int iPrereqPopulation = std::max(kBuilding.getPrereqPopulation(), (pCity ? pCity->getNumPopulationEmployed() + 1 : 0) + kBuilding.getNumPopulationEmployed());
		if (iPrereqPopulation > 0 && (!pCity || pCity->getPopulation() < iPrereqPopulation))
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_REQUIRES_POPULATION", iPrereqPopulation));
		}

		if (kBuilding.isWater())
		{
			if (kBuilding.isRiver())
			{
				if (!pCity || !(pCity->plot()->isRiver() || pCity->isCoastal(kBuilding.getMinAreaSize())))
				{
					szBuffer.append(NEWLINE);
					szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_REQUIRES_RIVER_OR_COAST"));
				}
			}
			else if (!pCity || !pCity->isCoastal(kBuilding.getMinAreaSize()))
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_REQUIRES_COAST"));
			}
		}
		else if (kBuilding.isRiver())
		{
			if (!pCity || !(pCity->plot()->isRiver()))
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_REQUIRES_RIVER"));
			}
		}
		else if (kBuilding.isFreshWater() && (!pCity || !pCity->plot()->isFreshWater()))
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_REQUIRES_FRESH_WATER"));
		}

		if (kBuilding.getPrereqCultureLevel() != NO_CULTURELEVEL
		&& (!pCity || pCity->getCultureLevel() < kBuilding.getPrereqCultureLevel()))
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_REQUIRES_CULTURE", GC.getCultureLevelInfo((CultureLevelTypes)kBuilding.getPrereqCultureLevel()).getDescription()));
		}

		const BuildingTypes ePrereqBuilding = GC.getBuildingInfo(eBuilding).getPrereqAnyoneBuilding();
		if (ePrereqBuilding != NO_BUILDING
		&& (!pCity || GC.getGame().getBuildingCreatedCount(ePrereqBuilding) == 0))
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_REQUIRES_ANY_BUILDING", GC.getBuildingInfo(ePrereqBuilding).getDescription()));
		}

		bFirst = true;
		bool bValid = false;
		if (pCity)
		{
			bValid = true;
			for (int iI = 0; iI < kBuilding.getNumPrereqOrBuilding(); ++iI)
			{
				if (!GET_TEAM(pCity->getTeam()).isObsoleteBuilding((BuildingTypes)kBuilding.getPrereqOrBuilding(iI)))
				{
					bValid = false;
					if (pCity->isActiveBuilding((BuildingTypes)kBuilding.getPrereqOrBuilding(iI)))
					{
						bValid = true;
						break;
					}
				}
			}
		}
		if (!bValid)
		{
			for (int iI = 0; iI < kBuilding.getNumPrereqOrBuilding(); ++iI)
			{
				setListHelp(
					szBuffer, gDLL->getText("TXT_KEY_REQUIRES"),
					GC.getBuildingInfo((BuildingTypes)kBuilding.getPrereqOrBuilding(iI)).getDescription(),
					gDLL->getText("TXT_KEY_OR").c_str(), bFirst
				);
				bFirst = false;
			}
		}

		bFirst = true;
		for (int iI = 0; iI < kBuilding.getNumPrereqNotInCityBuildings(); ++iI)
		{
			const BuildingTypes eBuildingX = static_cast<BuildingTypes>(kBuilding.getPrereqNotInCityBuilding(iI));

			if (!pCity || pCity->isActiveBuilding(eBuildingX))
			{
				szFirstBuffer.Format(L"%s%s", NEWLINE, gDLL->getText("TXT_KEY_BUILDINGHELP_NOT_REQUIRED_TO_BUILD").c_str());
				szTempBuffer.Format(SETCOLR L"<link=%s>%s</link>" ENDCOLR, TEXT_COLOR("COLOR_BUILDING_TEXT"), CvWString(GC.getBuildingInfo(eBuildingX).getType()).GetCString(), GC.getBuildingInfo(eBuildingX).getDescription());
				setListHelp(szBuffer, szFirstBuffer, szTempBuffer, L", ", bFirst);
				bFirst = false;
			}
		}
		bFirst = true;
		for (int iI = 0; iI < GC.getNumTerrainInfos(); ++iI)
		{
			if (kBuilding.isPrereqOrTerrain(iI))
			{
				setListHelp(szBuffer, gDLL->getText("TXT_KEY_REQUIRES"), GC.getTerrainInfo((TerrainTypes)iI).getDescription(), gDLL->getText("TXT_KEY_OR").c_str(), bFirst);
				bFirst = false;
			}
		}
		if (!bFirst)
		{
			szBuffer.append(gDLL->getText("TXT_KEY_IN_CITY_VICINITY"));
			szBuffer.append(ENDCOLR);
		}

		bFirst = true;
		for (int iI = 0; iI < GC.getNumTerrainInfos(); ++iI)
		{
			if (kBuilding.isPrereqAndTerrain(iI))
			{
				setListHelp(szBuffer, gDLL->getText("TXT_KEY_REQUIRES"), GC.getTerrainInfo((TerrainTypes)iI).getDescription(), gDLL->getText("TXT_KEY_AND").c_str(), bFirst);
				bFirst = false;
			}
		}
		if (!bFirst)
		{
			szBuffer.append(gDLL->getText("TXT_KEY_IN_CITY_VICINITY"));
			szBuffer.append(ENDCOLR);
		}

		bFirst = true;
		foreach_(const ImprovementTypes prereqOrImprovement, kBuilding.getPrereqOrImprovements())
		{
			setListHelp(szBuffer, gDLL->getText("TXT_KEY_REQUIRES"), GC.getImprovementInfo(prereqOrImprovement).getDescription(), gDLL->getText("TXT_KEY_OR").c_str(), bFirst);
			bFirst = false;
		}
		if (!bFirst)
		{
			szBuffer.append(gDLL->getText("TXT_KEY_IN_CITY_VICINITY"));
			szBuffer.append(ENDCOLR);
		}
		bFirst = true;
		for (int iI = 0; iI < GC.getNumFeatureInfos(); ++iI)
		{
			if (kBuilding.isPrereqOrFeature(iI))
			{
				setListHelp(szBuffer, gDLL->getText("TXT_KEY_REQUIRES"), GC.getFeatureInfo((FeatureTypes)iI).getDescription(), gDLL->getText("TXT_KEY_OR").c_str(), bFirst);
				bFirst = false;
			}
		}
		if (!bFirst)
		{
			szBuffer.append(gDLL->getText("TXT_KEY_IN_CITY_VICINITY"));
			szBuffer.append(ENDCOLR);
		}

		if (pCity && kBuilding.isAllowsNukes() && GC.getGame().isNoNukes())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_PROJECTHELP_NO_NUKES"));
		}

		const BoolExpr* pExpr = kBuilding.getConstructCondition();
		if (pExpr && (!pCity || !pExpr->evaluate(pCity->getGameObject())))
		{
			szBuffer.append(gDLL->getText("TXT_KEY_REQUIRES"));
			pExpr->buildDisplayString(szBuffer);
			szBuffer.append(ENDCOLR);
		}

		if (bCivilopediaText)
		{
			if (kBuilding.getVictoryPrereq() != NO_VICTORY)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_REQUIRES_VICTORY", GC.getVictoryInfo((VictoryTypes)(kBuilding.getVictoryPrereq())).getTextKeyWide()));
			}
			if (kBuilding.getMaxStartEra() != NO_ERA)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_MAX_START_ERA", GC.getEraInfo((EraTypes)kBuilding.getMaxStartEra()).getTextKeyWide()));
			}
			if (kBuilding.getNumTeamsPrereq() > 0)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_REQUIRES_NUM_TEAMS", kBuilding.getNumTeamsPrereq()));
			}
		}
		else
		{
			if (!bTechChooserText && kBuilding.getPrereqAndTech() != NO_TECH
			&& (ePlayer == NO_PLAYER || !GET_TEAM(GET_PLAYER(ePlayer).getTeam()).isHasTech((TechTypes)kBuilding.getPrereqAndTech())))
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_REQUIRES_LINK", CvWString(GC.getTechInfo((TechTypes)(kBuilding.getPrereqAndTech())).getType()).GetCString(), GC.getTechInfo((TechTypes)(kBuilding.getPrereqAndTech())).getTextKeyWide()));
			}

			bFirst = true;

			foreach_(const TechTypes ePrereqTech, kBuilding.getPrereqAndTechs())
			{
				if (bTechChooserText || ePlayer == NO_PLAYER
				|| !GET_TEAM(GET_PLAYER(ePlayer).getTeam()).isHasTech(ePrereqTech))
				{
					setListHelp(
						szBuffer, gDLL->getText("TXT_KEY_REQUIRES"),
						GC.getTechInfo(ePrereqTech).getDescription(),
						gDLL->getText("TXT_KEY_AND").c_str(), bFirst
					);
					bFirst = false;
				}
			}
			if (!bFirst)
			{
				szBuffer.append(ENDCOLR);
			}

			if (kBuilding.getPrereqAndBonus() != NO_BONUS
			&& (!pCity || !pCity->hasBonus((BonusTypes)kBuilding.getPrereqAndBonus())))
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_REQUIRES_STRING", GC.getBonusInfo((BonusTypes)kBuilding.getPrereqAndBonus()).getTextKeyWide()));
			}
			szBonusList.clear();

			bFirst = true;

			foreach_(const BonusTypes ePrereqBonus, kBuilding.getPrereqOrBonuses())
			{
				if (!pCity || !pCity->hasBonus(ePrereqBonus))
				{
					setListHelp(
						szBonusList, gDLL->getText("TXT_KEY_REQUIRES"),
						GC.getBonusInfo(ePrereqBonus).getDescription(),
						gDLL->getText("TXT_KEY_OR").c_str(), bFirst
					);
					bFirst = false;
				}
				else if (pCity)
				{
					bFirst = true;
					break;
				}
			}

			if (!bFirst)
			{
				szBonusList.append(ENDCOLR);
				szBuffer.append(szBonusList);
			}

			if (NO_CORPORATION != kBuilding.getFoundsCorporation())
			{
				bFirst = true;
				szBonusList.clear();
				foreach_(const BonusTypes eBonus, GC.getCorporationInfo((CorporationTypes)kBuilding.getFoundsCorporation()).getPrereqBonuses())
				{
					if (!pCity || !pCity->hasBonus(eBonus))
					{
						szTempBuffer.Format(L"<link=%s>%s</link>", CvWString(GC.getBonusInfo(eBonus).getType()).GetCString(), GC.getBonusInfo(eBonus).getDescription());
						setListHelp(szBonusList, gDLL->getText("TXT_KEY_REQUIRES"), szTempBuffer, gDLL->getText("TXT_KEY_OR"), bFirst);
						bFirst = false;
					}
					else if (pCity)
					{
						bFirst = true;
						break;
					}
				}

				if (!bFirst)
				{
					szBonusList.append(ENDCOLR);
					szBuffer.append(szBonusList);
				}
			}
		}
	}
}


void CvGameTextMgr::setProjectHelp(CvWStringBuffer &szBuffer, ProjectTypes eProject, bool bCivilopediaText, CvCity* pCity)
{
	PROFILE_FUNC();

	CvWString szTempBuffer;
	CvWString szFirstBuffer;
	PlayerTypes ePlayer;
	bool bFirst;
	int iProduction;
	int iI;

	if (NO_PROJECT == eProject)
	{
		return;
	}

	const CvProjectInfo& kProject = GC.getProjectInfo(eProject);

	if (pCity)
	{
		ePlayer = pCity->getOwner();
	}
	else
	{
		ePlayer = GC.getGame().getActivePlayer();
	}

	if (!bCivilopediaText)
	{
		szTempBuffer.Format( SETCOLR L"<link=%s>%s</link>" ENDCOLR , TEXT_COLOR("COLOR_PROJECT_TEXT"), CvWString(kProject.getType()).GetCString(), kProject.getDescription());
		szBuffer.append(szTempBuffer);

		if (isWorldProject(eProject))
		{
			if (!pCity)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_PROJECTHELP_WORLD_NUM_ALLOWED", kProject.getMaxGlobalInstances()));
			}
			else
			{
				szBuffer.append(gDLL->getText("TXT_KEY_PROJECTHELP_WORLD_NUM_LEFT", (kProject.getMaxGlobalInstances() - GC.getGame().getProjectCreatedCount(eProject) - GET_TEAM(GET_PLAYER(ePlayer).getTeam()).getProjectMaking(eProject))));
			}
		}

		if (isTeamProject(eProject))
		{
			if (!pCity)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_PROJECTHELP_TEAM_NUM_ALLOWED", kProject.getMaxTeamInstances()));
			}
			else
			{
				szBuffer.append(gDLL->getText("TXT_KEY_PROJECTHELP_TEAM_NUM_LEFT", (kProject.getMaxTeamInstances() - GET_TEAM(GET_PLAYER(ePlayer).getTeam()).getProjectCount(eProject) - GET_TEAM(GET_PLAYER(ePlayer).getTeam()).getProjectMaking(eProject))));
			}
		}
	}

	if (kProject.getNukeInterception() != 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROJECTHELP_CHANCE_INTERCEPT_NUKES", kProject.getNukeInterception()));
	}

	if (kProject.getTechShare() != 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROJECTHELP_TECH_SHARE", kProject.getTechShare()));
	}
	//DPII < Maintenance Modifiers >
	if (kProject.getGlobalMaintenanceModifier() != 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROJECTHELP_GLOBAL_MAINT_MOD", kProject.getGlobalMaintenanceModifier()));
	}

	if (kProject.getDistanceMaintenanceModifier() != 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROJECTHELP_DISTANCE_MAINT_MOD", kProject.getDistanceMaintenanceModifier()));
	}

	if (kProject.getNumCitiesMaintenanceModifier() != 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROJECTHELP_NUM_CITIES_MAINT_MOD", kProject.getNumCitiesMaintenanceModifier()));
	}
	//DPII < Maintenance Modifiers >
	if (kProject.isAllowsNukes())
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROJECTHELP_ENABLES_NUKES"));
	}

	if (kProject.getEveryoneSpecialUnit() != NO_SPECIALUNIT)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROJECTHELP_ENABLES_SPECIAL", GC.getSpecialUnitInfo((SpecialUnitTypes)(kProject.getEveryoneSpecialUnit())).getTextKeyWide()));
	}

	if (kProject.getEveryoneSpecialBuilding() != NO_SPECIALBUILDING)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROJECTHELP_ENABLES_SPECIAL", GC.getSpecialBuildingInfo((SpecialBuildingTypes)(kProject.getEveryoneSpecialBuilding())).getTextKeyWide()));
	}

	if (kProject.getWorldHappiness() > 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROJECTHELP_WORLD_HAPPINESS", kProject.getWorldHappiness()));
	}

	else if (kProject.getWorldHappiness() < 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROJECTHELP_WORLD_UNHAPPINESS", -kProject.getWorldHappiness()));
	}

	if (kProject.getWorldHealth() > 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROJECTHELP_WORLD_HEALTH", kProject.getWorldHealth()));
	}

	else if (kProject.getWorldHealth() < 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROJECTHELP_WORLD_UNHEALTH", -kProject.getWorldHealth()));
	}

	if (kProject.getGlobalHappiness() > 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROJECTHELP_HAPPINESS", kProject.getGlobalHappiness()));
	}

	else if (kProject.getGlobalHappiness() < 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROJECTHELP_UNHAPPINESS", -kProject.getGlobalHappiness()));
	}

	if (kProject.getGlobalHealth() > 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROJECTHELP_HEALTH", kProject.getGlobalHealth()));
	}

	else if (kProject.getGlobalHealth() < 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROJECTHELP_UNHEALTH", -kProject.getGlobalHealth()));
	}

	if (kProject.getWorldTradeRoutes() > 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_MORE_WORLD_TRADE", kProject.getWorldTradeRoutes()));
	}
	else if (kProject.getWorldTradeRoutes() < 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_LESS_WORLD_TRADE", -kProject.getWorldTradeRoutes()));
	}

	if (kProject.getInflationModifier() != 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_ADJUSTS_INFLATION", kProject.getInflationModifier()));
	}

	{
		const int* aList = kProject.getCommerceModifierArray();
		if (aList)
		{
			listCommerceChange(szBuffer, CvWString::format(L"\n%c", gDLL->getSymbolID(BULLET_CHAR)), gDLL->getText("TXT_KEY_BUILDINGHELP_ALL_CITIES").c_str(), aList, true);
		}
	}

	for (iI = 0; iI < GC.getNumVictoryInfos(); ++iI)
	{
		if (kProject.getVictoryThreshold(iI) > 0)
		{
			if (kProject.getVictoryThreshold(iI) == kProject.getVictoryMinThreshold(iI))
			{
				szTempBuffer.Format(L"%d", kProject.getVictoryThreshold(iI));
			}
			else
			{
				szTempBuffer.Format(L"%d-%d", kProject.getVictoryMinThreshold(iI), kProject.getVictoryThreshold(iI));
			}

			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_PROJECTHELP_REQUIRED_FOR_VICTORY", szTempBuffer.GetCString(), GC.getVictoryInfo((VictoryTypes)iI).getTextKeyWide()));
		}
	}

	bFirst = true;

	for (iI = 0; iI < GC.getNumProjectInfos(); ++iI)
	{
		if (GC.getProjectInfo((ProjectTypes)iI).getAnyoneProjectPrereq() == eProject)
		{
			szFirstBuffer.Format(L"%s%s", NEWLINE, gDLL->getText("TXT_KEY_PROJECTHELP_REQUIRED_TO_CREATE_ANYONE").c_str());
			szTempBuffer.Format(SETCOLR L"<link=%s>%s</link>" ENDCOLR, TEXT_COLOR("COLOR_PROJECT_TEXT"), CvWString(GC.getProjectInfo((ProjectTypes)iI).getType()).GetCString(), GC.getProjectInfo((ProjectTypes)iI).getDescription());
			setListHelp(szBuffer, szFirstBuffer, szTempBuffer, L", ", bFirst);
			bFirst = false;
		}
	}

	bFirst = true;

	for (iI = 0; iI < GC.getNumProjectInfos(); ++iI)
	{
		if (GC.getProjectInfo((ProjectTypes)iI).getProjectsNeeded(eProject) > 0)
		{
			if (!pCity || pCity->canCreate(((ProjectTypes)iI), false, true))
			{
				szFirstBuffer.Format(L"%s%s", NEWLINE, gDLL->getText("TXT_KEY_PROJECTHELP_REQUIRED_TO_CREATE").c_str());
				szTempBuffer.Format(SETCOLR L"<link=%s>%s</link>" ENDCOLR, TEXT_COLOR("COLOR_PROJECT_TEXT"), CvWString(GC.getProjectInfo((ProjectTypes)iI).getType()).GetCString(), GC.getProjectInfo((ProjectTypes)iI).getDescription());
				setListHelp(szBuffer, szFirstBuffer, szTempBuffer, L", ", bFirst);
				bFirst = false;
			}
		}
	}

	if (!pCity || !(pCity->canCreate(eProject)))
	{
		if (pCity)
		{
			if (GC.getGame().isNoNukes())
			{
				if (kProject.isAllowsNukes())
				{
					szBuffer.append(NEWLINE);
					szBuffer.append(gDLL->getText("TXT_KEY_PROJECTHELP_NO_NUKES"));
				}
			}
		}

		if (kProject.getAnyoneProjectPrereq() != NO_PROJECT)
		{
			if (!pCity || (GC.getGame().getProjectCreatedCount((ProjectTypes)(kProject.getAnyoneProjectPrereq())) == 0))
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_PROJECTHELP_REQUIRES_ANYONE", CvWString(GC.getProjectInfo((ProjectTypes)kProject.getAnyoneProjectPrereq()).getType()).GetCString(), GC.getProjectInfo((ProjectTypes)kProject.getAnyoneProjectPrereq()).getTextKeyWide()));
			}
		}

		for (iI = 0; iI < GC.getNumProjectInfos(); ++iI)
		{
			if (kProject.getProjectsNeeded(iI) > 0)
			{
				if (!pCity || (GET_TEAM(GET_PLAYER(ePlayer).getTeam()).getProjectCount((ProjectTypes)iI) < kProject.getProjectsNeeded(iI)))
				{
					if (pCity)
					{
						szBuffer.append(NEWLINE);
						szBuffer.append(gDLL->getText("TXT_KEY_PROJECTHELP_REQUIRES", CvWString(GC.getProjectInfo((ProjectTypes)iI).getType()).GetCString(), GC.getProjectInfo((ProjectTypes)iI).getTextKeyWide(), GET_TEAM(GET_PLAYER(ePlayer).getTeam()).getProjectCount((ProjectTypes)iI), kProject.getProjectsNeeded(iI)));
					}
					else
					{
						szBuffer.append(NEWLINE);
						szBuffer.append(gDLL->getText("TXT_KEY_PROJECTHELP_REQUIRES_NO_CITY", CvWString(GC.getProjectInfo((ProjectTypes)iI).getType()).GetCString(), GC.getProjectInfo((ProjectTypes)iI).getTextKeyWide(), kProject.getProjectsNeeded(iI)));
					}
				}
			}
		}

		if (bCivilopediaText)
		{
			if (kProject.getVictoryPrereq() != NO_VICTORY)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_PROJECTHELP_REQUIRES_STRING_VICTORY", GC.getVictoryInfo((VictoryTypes)(kProject.getVictoryPrereq())).getTextKeyWide()));
			}

			foreach_(const MapCategoryTypes eMapCategory, kProject.getMapCategories())
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_MAP_CATEGORY_PREREQUISITE", GC.getMapCategoryInfo(eMapCategory).getTextKeyWide()));
			}
		}
	}

	if (!bCivilopediaText)
	{
		if (!pCity)
		{
			if (ePlayer != NO_PLAYER)
			{
				szTempBuffer.Format(L"\n%d%c", GET_PLAYER(ePlayer).getProductionNeeded(eProject), GC.getYieldInfo(YIELD_PRODUCTION).getChar());
			}
			else
			{
				szTempBuffer.Format(L"\n%d%c", kProject.getProductionCost(), GC.getYieldInfo(YIELD_PRODUCTION).getChar());
			}
			szBuffer.append(szTempBuffer);
		}
		else
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_PROJECTHELP_NUM_TURNS", pCity->getProductionTurnsLeft(eProject, ((gDLL->ctrlKey() || !(gDLL->shiftKey())) ? 0 : pCity->getOrderQueueLength()))));

			iProduction = pCity->getProjectProduction(eProject);

			if (iProduction > 0)
			{
				szTempBuffer.Format(L" - %d/%d%c", iProduction, pCity->getProductionNeeded(eProject), GC.getYieldInfo(YIELD_PRODUCTION).getChar());
			}
			else
			{
				szTempBuffer.Format(L" - %d%c", pCity->getProductionNeeded(eProject), GC.getYieldInfo(YIELD_PRODUCTION).getChar());
			}
			szBuffer.append(szTempBuffer);
		}
	}

	for (iI = 0; iI < GC.getNumBonusInfos(); ++iI)
	{
		if (kProject.getBonusProductionModifier(iI) != 0)
		{
			if (pCity)
			{
				if (pCity->hasBonus((BonusTypes)iI))
				{
					szBuffer.append(gDLL->getText("TXT_KEY_COLOR_POSITIVE"));
				}
				else
				{
					szBuffer.append(gDLL->getText("TXT_KEY_COLOR_NEGATIVE"));
				}
			}
			if (!bCivilopediaText)
			{
				szBuffer.append(L" (");
			}
			else
			{
				szTempBuffer.Format(L"%s%c", NEWLINE, gDLL->getSymbolID(BULLET_CHAR), szTempBuffer.c_str());
				szBuffer.append(szTempBuffer);
			}
			if (kProject.getBonusProductionModifier(iI) == 100)
			{
				szBuffer.append(gDLL->getText("TXT_KEY_PROJECTHELP_DOUBLE_SPEED_WITH", CvWString(GC.getBonusInfo((BonusTypes)iI).getType()).GetCString(), GC.getBonusInfo((BonusTypes)iI).getTextKeyWide()));
			}
			else
			{
				szBuffer.append(gDLL->getText("TXT_KEY_PROJECTHELP_BUILDS_FASTER_WITH", kProject.getBonusProductionModifier(iI), CvWString(GC.getBonusInfo((BonusTypes)iI).getType()).GetCString(), GC.getBonusInfo((BonusTypes)iI).getTextKeyWide()));
			}
			if (!bCivilopediaText)
			{
				szBuffer.append(L')');
			}
			if (pCity)
			{
				szBuffer.append(gDLL->getText("TXT_KEY_COLOR_REVERT"));
			}
		}
	}
}


void CvGameTextMgr::setProcessHelp(CvWStringBuffer &szBuffer, ProcessTypes eProcess)
{
	PROFILE_EXTRA_FUNC();
	szBuffer.append(GC.getProcessInfo(eProcess).getDescription());

	for (int iI = 0; iI < NUM_COMMERCE_TYPES; ++iI)
	{
		if (GC.getProcessInfo(eProcess).getProductionToCommerceModifier(iI) != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_PROCESS_CONVERTS", GC.getProcessInfo(eProcess).getProductionToCommerceModifier(iI), GC.getYieldInfo(YIELD_PRODUCTION).getChar(), GC.getCommerceInfo((CommerceTypes) iI).getChar()));
		}
	}
}

void CvGameTextMgr::setBadHealthHelp(CvWStringBuffer &szBuffer, CvCity& city)
{
	PROFILE_EXTRA_FUNC();
	const int iBadHealthTotal = city.badHealth();
	if (iBadHealthTotal < 1)
	{
		return;
	}
	int iSum = 0;
	int iHealth = -(city.getFeatureBadHealth());
	if (iHealth > 0)
	{
		iSum += iHealth;
		FeatureTypes eFeature = NO_FEATURE;

		foreach_(const CvPlot* pLoopPlot, city.plots(NUM_CITY_PLOTS))
		{
			if (pLoopPlot->getFeatureType() != NO_FEATURE
			&& GC.getFeatureInfo(pLoopPlot->getFeatureType()).getHealthPercent() < 0)
			{
				if (eFeature == NO_FEATURE)
				{
					eFeature = pLoopPlot->getFeatureType();
				}
				else if (eFeature != pLoopPlot->getFeatureType())
				{
					eFeature = NO_FEATURE;
					break;
				}
			}
		}
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_FEAT_HEALTH", iHealth, ((eFeature == NO_FEATURE) ? L"TXT_KEY_MISC_FEATURES" : GC.getFeatureInfo(eFeature).getTextKeyWide())));
		szBuffer.append(NEWLINE);
	}

	iHealth = -city.getImprovementBadHealth() / 100;
	const CvPlayer& kPlayer = GET_PLAYER(city.getOwner());
	if (iHealth > 0)
	{
		iSum += iHealth;
		ImprovementTypes eImprovement = NO_IMPROVEMENT;
		int iTotalHealth;
		int iBestHealth = 0;
		for (int iI = 0; iI < GC.getNumImprovementInfos(); iI++)
		{
			iTotalHealth = 0;

			if (GC.getImprovementInfo((ImprovementTypes)iI).getHealthPercent() < 0)
			{
				foreach_(const CvPlot* pLoopPlot, city.plots())
				{
					if (pLoopPlot->getImprovementType() == iI)
					{
						iTotalHealth -= GC.getImprovementInfo((ImprovementTypes)iI).getHealthPercent();
						for (int iK = 0; iK < GC.getNumCivicOptionInfos(); iK++)
						{
							if (kPlayer.getCivics((CivicOptionTypes)iK) != NO_CIVIC)
							{
								iTotalHealth -= std::min(0, GC.getCivicInfo(kPlayer.getCivics((CivicOptionTypes)iK)).getImprovementHealthPercentChanges(iI)) / 100;
							}
						}
					}
				}
			}
			if (iTotalHealth > iBestHealth)
			{
				eImprovement = (ImprovementTypes)iI;
				iBestHealth = iTotalHealth;
			}
		}
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_IMPR_HEALTH", iHealth, ((eImprovement == NO_IMPROVEMENT) ? L"TXT_KEY_MISC_IMPROVEMENTS" : GC.getImprovementInfo(eImprovement).getTextKeyWide())));
		szBuffer.append(NEWLINE);
	}

	iHealth = -(city.getSpecialistBadHealth() / 100);
	if (iHealth > 0)
	{
		iSum += iHealth;
		szBuffer.append(gDLL->getText("TXT_KEY_BAD_HEALTH_FROM_SPECIALISTS", iHealth));
		szBuffer.append(NEWLINE);
	}

	iHealth = city.getEspionageHealthCounter();
	if (iHealth > 0)
	{
		iSum += iHealth;
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_HEALTH_FROM_ESPIONAGE", iHealth));
		szBuffer.append(NEWLINE);
	}

	iHealth = -(city.getBonusBadHealth());
	if (iHealth > 0)
	{
		iSum += iHealth;
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_HEALTH_FROM_BONUSES", iHealth));
		szBuffer.append(NEWLINE);
	}

	iHealth = -(city.totalBadBuildingHealth());
	if (iHealth > 0)
	{
		iSum += iHealth;
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_HEALTH_FROM_BUILDINGS", iHealth));
		szBuffer.append(NEWLINE);
	}

	iHealth = -GET_PLAYER(city.getOwner()).getCivicHealth();
	if (iHealth > 0)
	{
		iSum += iHealth;
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_BAD_HEALTH_FROM_CIVICS", iHealth));
		szBuffer.append(NEWLINE);
	}
	iHealth = -GET_PLAYER(city.getOwner()).getCivilizationHealth();

	if (iHealth > 0)
	{
		iSum += iHealth;
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_HEALTH_FROM_CIV", iHealth));
		szBuffer.append(NEWLINE);
	}

	//	Koshling - event health
	iHealth = -GET_PLAYER(city.getOwner()).getExtraHealth();
	if (iHealth > 0)
	{
		iSum += iHealth;
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_BAD_HEALTH_FROM_EVENTS", iHealth));
		szBuffer.append(NEWLINE);
	}

	iHealth = -city.getExtraHealth();
	if (iHealth > 0)
	{
		iSum += iHealth;
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_UNHEALTH_EXTRA", iHealth));
		szBuffer.append(NEWLINE);
	}

	if ( GC.getGame().getHandicapType() != NO_HANDICAP )
	{
		iHealth = -(GC.getHandicapInfo(city.getHandicapType()).getHealthBonus());
		if (iHealth > 0)
		{
			iSum += iHealth;
			szBuffer.append(gDLL->getText("TXT_KEY_MISC_HEALTH_FROM_HANDICAP", iHealth));
			szBuffer.append(NEWLINE);
		}
	}

	iHealth = city.unhealthyPopulation();
	if (iHealth > 0)
	{
		iSum += iHealth;
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_HEALTH_FROM_POP", iHealth));
		szBuffer.append(NEWLINE);
	}

	iHealth = -(GET_PLAYER(city.getOwner()).getWorldHealth());
	if (iHealth > 0)
	{
		iSum += iHealth;
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_HEALTH_FROM_WORLD_PROJECT", iHealth));
		szBuffer.append(NEWLINE);
	}

	iHealth = -(GET_PLAYER(city.getOwner()).getProjectHealth());
	if (iHealth > 0)
	{
		iSum += iHealth;
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_HEALTH_FROM_PROJECT", iHealth));
		szBuffer.append(NEWLINE);
	}
	iHealth = -city.calculateCorporationHealth();
	if (iHealth > 0)
	{
		iSum += iHealth;
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_HEALTH_FROM_CORPORATION", iHealth));
		szBuffer.append(NEWLINE);
	}

	iHealth = -city.getExtraTechHealthTotal();
	if (iHealth > 0)
	{
		iSum += iHealth;
		szBuffer.append(gDLL->getText("TXT_KEY_UNHEALTHY_TECH_SPECIALIST", iHealth));
		szBuffer.append(NEWLINE);
	}
	szBuffer.append(L"-----------------------\n");
	szBuffer.append(gDLL->getText("TXT_KEY_MISC_TOTAL_UNHEALTHY", iBadHealthTotal));

	FAssertMsg(iBadHealthTotal == iSum, CvString::format("Actual: %d; displayed: %d", iBadHealthTotal, iSum));
}

void CvGameTextMgr::setGoodHealthHelp(CvWStringBuffer &szBuffer, CvCity& city)
{
	PROFILE_EXTRA_FUNC();
	const int iGoodHealthTotal = city.goodHealth();
	if (iGoodHealthTotal < 1)
	{
		return;
	}
	int iSum = 0;
	int iHealth = city.getFreshWaterGoodHealth();
	if (iHealth > 0)
	{
		iSum += iHealth;
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_HEALTH_FROM_FRESH_WATER", iHealth));
		szBuffer.append(NEWLINE);
	}

	iHealth = city.getFeatureGoodHealth();
	if (iHealth > 0)
	{
		iSum += iHealth;
		FeatureTypes eFeature = NO_FEATURE;

		foreach_(const CvPlot* pLoopPlot, city.plots(NUM_CITY_PLOTS))
		{
			if (pLoopPlot->getFeatureType() != NO_FEATURE
			&& GC.getFeatureInfo(pLoopPlot->getFeatureType()).getHealthPercent() > 0)
			{
				if (eFeature == NO_FEATURE)
				{
					eFeature = pLoopPlot->getFeatureType();
				}
				else if (eFeature != pLoopPlot->getFeatureType())
				{
					eFeature = NO_FEATURE;
					break;
				}
			}
		}
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_FEAT_GOOD_HEALTH", iHealth, ((eFeature == NO_FEATURE) ? L"TXT_KEY_MISC_FEATURES" : GC.getFeatureInfo(eFeature).getTextKeyWide())));
		szBuffer.append(NEWLINE);
	}
	iHealth = city.getImprovementGoodHealth() / 100;
	const CvPlayer& kPlayer = GET_PLAYER(city.getOwner());
	if (iHealth > 0)
	{
		iSum += iHealth;
		ImprovementTypes eImprovement = NO_IMPROVEMENT;
		int iBestHealth = 0;
		for (int iI = 0; iI < GC.getNumImprovementInfos(); iI++)
		{
			int iTotalHealth = 0;

			if (GC.getImprovementInfo((ImprovementTypes)iI).getHealthPercent() > 0)
			{
				foreach_(const CvPlot* pLoopPlot, city.plots())
				{
					if (pLoopPlot->getImprovementType() == iI)
					{
						iTotalHealth += GC.getImprovementInfo((ImprovementTypes)iI).getHealthPercent();
						for (int iK = 0; iK < GC.getNumCivicOptionInfos(); iK++)
						{
							if (kPlayer.getCivics((CivicOptionTypes)iK) != NO_CIVIC)
							{
								iTotalHealth += std::max(0, GC.getCivicInfo(kPlayer.getCivics((CivicOptionTypes)iK)).getImprovementHealthPercentChanges(iI)) / 100;
							}
						}
					}
				}
			}
			if (iTotalHealth > iBestHealth)
			{
				eImprovement = (ImprovementTypes)iI;
				iBestHealth = iTotalHealth;
			}
		}
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_IMPR_GOOD_HEALTH", iHealth, ((eImprovement == NO_IMPROVEMENT) ? L"TXT_KEY_MISC_IMPROVEMENTS" : GC.getImprovementInfo(eImprovement).getTextKeyWide())));
		szBuffer.append(NEWLINE);
	}
	iHealth = city.getSpecialistGoodHealth() / 100;
	if (iHealth > 0)
	{
		iSum += iHealth;
		szBuffer.append(gDLL->getText("TXT_KEY_GOOD_HEALTH_FROM_SPECIALISTS", iHealth));
		szBuffer.append(NEWLINE);
	}

	iHealth = city.getBonusGoodHealth();
	if (iHealth > 0)
	{
		iSum += iHealth;
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_GOOD_HEALTH_FROM_BONUSES", iHealth));
		szBuffer.append(NEWLINE);
	}

	iHealth = city.totalGoodBuildingHealth();
	if (iHealth > 0)
	{
		iSum += iHealth;
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_GOOD_HEALTH_FROM_BUILDINGS", iHealth));
		szBuffer.append(NEWLINE);
	}

	iHealth = GET_PLAYER(city.getOwner()).getCivicHealth();
	if (iHealth > 0)
	{
		iSum += iHealth;
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_GOOD_HEALTH_FROM_CIVICS", iHealth));
		szBuffer.append(NEWLINE);
	}
	iHealth = GET_PLAYER(city.getOwner()).getCivilizationHealth();

	if (iHealth > 0)
	{
		iSum += iHealth;
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_GOOD_HEALTH_FROM_CIV", iHealth));
		szBuffer.append(NEWLINE);
	}

	//	Koshling - event health
	iHealth = GET_PLAYER(city.getOwner()).getExtraHealth();
	if (iHealth > 0)
	{
		iSum += iHealth;
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_GOOD_HEALTH_FROM_EVENTS", iHealth));
		szBuffer.append(NEWLINE);
	}

	iHealth = city.getExtraHealth();
	if (iHealth > 0)
	{
		iSum += iHealth;
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_HEALTH_EXTRA", iHealth));
		szBuffer.append(NEWLINE);
	}

	if ( GC.getGame().getHandicapType() != NO_HANDICAP )
	{
		iHealth = GC.getHandicapInfo(city.getHandicapType()).getHealthBonus();
		if (iHealth > 0)
		{
			iSum += iHealth;
			szBuffer.append(gDLL->getText("TXT_KEY_MISC_GOOD_HEALTH_FROM_HANDICAP", iHealth));
			szBuffer.append(NEWLINE);
		}
	}
	iHealth = (GET_PLAYER(city.getOwner()).getWorldHealth());
	if (iHealth > 0)
	{
		iSum += iHealth;
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_GOOD_HEALTH_FROM_WORLD_PROJECT", iHealth));
		szBuffer.append(NEWLINE);
	}

	iHealth = (GET_PLAYER(city.getOwner()).getProjectHealth());
	if (iHealth > 0)
	{
		iSum += iHealth;
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_GOOD_HEALTH_FROM_PROJECT", iHealth));
		szBuffer.append(NEWLINE);
	}

	iHealth = city.calculateCorporationHealth();
	if (iHealth > 0)
	{
		iSum += iHealth;
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_GOOD_HEALTH_FROM_CORPORATION", iHealth));
		szBuffer.append(NEWLINE);
	}

	iHealth = city.getExtraTechHealthTotal();
	if (iHealth > 0)
	{
		iSum += iHealth;
		szBuffer.append(gDLL->getText("TXT_KEY_HEALTHY_TECH_SPECIALIST", iHealth));
		szBuffer.append(NEWLINE);
	}
	szBuffer.append(L"-----------------------\n");
	szBuffer.append(gDLL->getText("TXT_KEY_MISC_TOTAL_HEALTHY", iGoodHealthTotal));

	FAssertMsg(iGoodHealthTotal == iSum, CvString::format("Actual: %d; displayed: %d", iGoodHealthTotal, iSum));
}


bool CvGameTextMgr::setBuildingAdditionalHealthHelp(CvWStringBuffer &szBuffer, CvCity& city, const CvWString& szStart, bool bStarted)
{
	PROFILE_EXTRA_FUNC();
	for (int iI = 0; iI < GC.getNumBuildingInfos(); iI++)
	{
		const BuildingTypes eBuilding = static_cast<BuildingTypes>(iI);

		if (city.canConstruct(eBuilding, false, false, false))
		{
			int iGood = 0, iBad = 0, iSpoiledFood = 0, iStarvation = 0;
			city.getAdditionalHealthByBuilding(eBuilding, iGood, iBad, iSpoiledFood, iStarvation);

			if (iGood != 0 || iBad != 0)
			{
				if (!bStarted)
				{
					szBuffer.append(szStart);
					bStarted = true;
				}

				CvWString szLabel;
				szLabel.Format(SETCOLR L"%s" ENDCOLR, TEXT_COLOR("COLOR_BUILDING_TEXT"), GC.getBuildingInfo(eBuilding).getDescription());
				const bool bStartedLine = setResumableGoodBadChangeHelp(szBuffer, szLabel, L": ", L"", iGood, gDLL->getSymbolID(HEALTHY_CHAR), iBad, gDLL->getSymbolID(UNHEALTHY_CHAR), false, true);
				setResumableValueChangeHelp(szBuffer, szLabel, L": ", L"", iSpoiledFood, gDLL->getSymbolID(EATEN_FOOD_CHAR), false, true, bStartedLine);
				setResumableValueChangeHelp(szBuffer, szLabel, L": ", L"", iStarvation, gDLL->getSymbolID(BAD_FOOD_CHAR), false, true, bStartedLine);
			}
		}
	}

	return bStarted;
}


void CvGameTextMgr::parseHappinessHelp(CvWStringBuffer &szBuffer)
{
	CvCity* pHeadSelectedCity = gDLL->getInterfaceIFace()->getHeadSelectedCity();

	if (pHeadSelectedCity)
	{
		setAngerHelp(szBuffer, *pHeadSelectedCity);
		szBuffer.append(L"\n=======================\n");
		setHappyHelp(szBuffer, *pHeadSelectedCity);

		if (pHeadSelectedCity->getOwner() == GC.getGame().getActivePlayer() && getBugOptionBOOL("MiscHover__BuildingAdditionalHappiness", true, "BUG_BUILDING_ADDITIONAL_HAPPINESS_HOVER"))
		{
			setBuildingAdditionalHappinessHelp(szBuffer, *pHeadSelectedCity, DOUBLE_SEPARATOR);
		}
	}
}

void CvGameTextMgr::setAngerHelp(CvWStringBuffer &szBuffer, CvCity& city)
{
	PROFILE_EXTRA_FUNC();
	if (city.isOccupation())
	{
		szBuffer.append(gDLL->getText("TXT_KEY_ANGER_RESISTANCE"));
		return;
	}
	CvPlayer& kPlayer = GET_PLAYER(city.getOwner());

	if (kPlayer.isAnarchy())
	{
		szBuffer.append(gDLL->getText("TXT_KEY_ANGER_ANARCHY"));
		return;
	}
	if (city.unhappyLevel() < 1)
	{
		return;
	}
	int iPop = city.getPopulation();
	int iDivisor = GC.getPERCENT_ANGER_DIVISOR();
	int iTotal = 0;

	int iAnger = city.getOvercrowdingPercentAnger() * iPop / iDivisor;
	if (iAnger > 0)
	{
		szBuffer.append(gDLL->getText("TXT_KEY_ANGER_OVERCROWDING", iAnger));
		szBuffer.append(NEWLINE);
		iTotal += iAnger;
	}

	iAnger = city.getNoMilitaryPercentAnger() * iPop / iDivisor;
	if (iAnger > 0)
	{
		szBuffer.append(gDLL->getText("TXT_KEY_ANGER_MILITARY_PROTECTION", iAnger));
		szBuffer.append(NEWLINE);
		iTotal += iAnger;
	}

	iAnger = city.getCulturePercentAnger() * iPop / iDivisor;
	if (iAnger > 0)
	{
		szBuffer.append(gDLL->getText("TXT_KEY_ANGER_OCCUPIED", iAnger));
		szBuffer.append(NEWLINE);
		iTotal += iAnger;
	}

	iAnger = city.getReligionPercentAnger() * iPop / iDivisor;
	if (iAnger > 0)
	{
		szBuffer.append(gDLL->getText("TXT_KEY_ANGER_RELIGION_FIGHT", iAnger));
		szBuffer.append(NEWLINE);
		iTotal += iAnger;
	}

	iAnger = (city.getHurryPercentAnger() + city.getEventAnger()) * iPop / iDivisor;
	if (iAnger > 0)
	{
		szBuffer.append(gDLL->getText("TXT_KEY_ANGER_OPPRESSION", iAnger));
		szBuffer.append(NEWLINE);
		iTotal += iAnger;
	}

	iAnger = city.getRevRequestPercentAnger() * iPop / iDivisor;
	if (iAnger > 0)
	{
		szBuffer.append(gDLL->getText("TXT_KEY_REV_REQUEST_ANGER", iAnger));
		szBuffer.append(NEWLINE);
		iTotal += iAnger;
	}

	iAnger = city.getRevIndexPercentAnger() * iPop / iDivisor;
	if (iAnger > 0)
	{
		szBuffer.append(gDLL->getText("TXT_KEY_REV_INDEX_ANGER", iAnger));
		szBuffer.append(NEWLINE);
		iTotal += iAnger;
	}

	iAnger = city.getConscriptPercentAnger() * iPop / iDivisor;
	if (iAnger > 0)
	{
		szBuffer.append(gDLL->getText("TXT_KEY_ANGER_DRAFT", iAnger));
		szBuffer.append(NEWLINE);
		iTotal += iAnger;
	}

	iAnger = city.getDefyResolutionPercentAnger() * iPop / iDivisor;
	if (iAnger > 0)
	{
		szBuffer.append(gDLL->getText("TXT_KEY_ANGER_DEFY_RESOLUTION", iAnger));
		szBuffer.append(NEWLINE);
		iTotal += iAnger;
	}

	iAnger = city.getWarWearinessPercentAnger() * iPop / iDivisor;
	if (iAnger > 0)
	{
		szBuffer.append(gDLL->getText("TXT_KEY_ANGER_WAR_WEAR", iAnger));
		szBuffer.append(NEWLINE);
		iTotal += iAnger;
	}

	iAnger = city.getVassalUnhappiness();
	if (iAnger > 0)
	{
		szBuffer.append(gDLL->getText("TXT_KEY_UNHAPPY_VASSAL", iAnger));
		szBuffer.append(NEWLINE);
		iTotal += iAnger;
	}

	iAnger = city.getEspionageHappinessCounter();
	if (iAnger > 0)
	{
		szBuffer.append(gDLL->getText("TXT_KEY_ANGER_ESPIONAGE", iAnger));
		szBuffer.append(NEWLINE);
		iTotal += iAnger;
	}

	for (int iI = 0; iI < GC.getNumCivicInfos(); ++iI)
	{
		iAnger = kPlayer.getCivicPercentAnger((CivicTypes)iI) * iPop / iDivisor;
		if (iAnger != 0)
		{
			if (iAnger > 0)
			{
				szBuffer.append(gDLL->getText("TXT_KEY_ANGER_CIVIC_PERCENT_BAD", iAnger, GC.getCivicInfo((CivicTypes) iI).getTextKeyWide()));
				szBuffer.append(NEWLINE);
			}
			else
			{
				szBuffer.append(gDLL->getText("TXT_KEY_ANGER_CIVIC_PERCENT_GOOD", iAnger, GC.getCivicInfo((CivicTypes) iI).getTextKeyWide()));
				szBuffer.append(NEWLINE);
			}
			iTotal += iAnger;
		}
	}

	iAnger = city.getLargestCityHappiness();
	if (iAnger > 0)
	{
		szBuffer.append(gDLL->getText("TXT_KEY_ANGER_BIG_CITY", iAnger));
		szBuffer.append(NEWLINE);
		iTotal += iAnger;
	}

	iAnger = -city.getCivicHappiness();
	if (iAnger > 0)
	{
		szBuffer.append(gDLL->getText("TXT_KEY_UNHAPPY_CIVIC", iAnger));
		szBuffer.append(NEWLINE);
		iTotal += iAnger;
	}

	iAnger = -kPlayer.getWorldHappiness();
	if (iAnger > 0)
	{
		szBuffer.append(gDLL->getText("TXT_KEY_UNHAPPY_WORLD_PROJECT", iAnger));
		szBuffer.append(NEWLINE);
		iTotal += iAnger;
	}

	iAnger = -kPlayer.getProjectHappiness();
	if (iAnger > 0)
	{
		szBuffer.append(gDLL->getText("TXT_KEY_UNHAPPY_PROJECT", iAnger));
		szBuffer.append(NEWLINE);
		iTotal += iAnger;
	}

	iAnger = kPlayer.calculateTaxRateUnhappiness();
	if (iAnger > 0)
	{
		szBuffer.append(gDLL->getText("TXT_KEY_CITY_TAXATION_ANGER", iAnger));
		szBuffer.append(NEWLINE);
		iTotal += iAnger;
	}

	iAnger = -city.calculateCorporationHappiness();
	if (iAnger > 0)
	{
		szBuffer.append(gDLL->getText("TXT_KEY_UNHAPPY_CORPORATIONS", iAnger));
		szBuffer.append(NEWLINE);
		iTotal += iAnger;
	}

	iAnger = kPlayer.getForeignUnhappyPercent();
	if (iAnger > 0)
	{
		iAnger = (100 - city.plot()->calculateCulturePercent(city.getOwner())) / iAnger;
		if (iAnger > 0)
		{
			szBuffer.append(gDLL->getText("TXT_KEY_CITY_FOREIGNER_ANGER", iAnger));
			szBuffer.append(NEWLINE);
			iTotal += iAnger;
		}
	}

	if (GC.getGame().isOption(GAMEOPTION_MAP_PERSONALIZED))
	{
		iAnger = -kPlayer.getLandmarkHappiness();
		if (iAnger > 0)
		{
			szBuffer.append(gDLL->getText("TXT_KEY_CITY_LANDMARK_ANGER", iAnger));
			szBuffer.append(NEWLINE);
			iTotal += iAnger;
		}

		if (!kPlayer.isNoLandmarkAnger())
		{
			iAnger = city.getLandmarkAnger();
			if (iAnger > 0)
			{
				szBuffer.append(gDLL->getText("TXT_KEY_CITY_LANDMARK_DESTRUCTION_ANGER", iAnger));
				szBuffer.append(NEWLINE);
				iTotal += iAnger;
			}
		}
	}

	iAnger = -city.getMilitaryHappiness();
	if (iAnger > 0)
	{
		szBuffer.append(gDLL->getText("TXT_KEY_ANGER_MILITARY_PRESENCE", iAnger));
		szBuffer.append(NEWLINE);
		iTotal += iAnger;
	}

	iAnger = -city.getCurrentStateReligionHappiness();
	if (iAnger > 0)
	{
		szBuffer.append(gDLL->getText("TXT_KEY_ANGER_STATE_RELIGION", iAnger));
		szBuffer.append(NEWLINE);
		iTotal += iAnger;
	}

	if (kPlayer.getCityLimit() > 0 && kPlayer.getCityOverLimitUnhappy() > 0)
	{
		iAnger = kPlayer.getCityOverLimitUnhappy() * (kPlayer.getNumCities() - kPlayer.getCityLimit());
		if (iAnger > 0)
		{
			szBuffer.append(gDLL->getText("TXT_KEY_ANGER_TOO_MANY_CITIES", iAnger));
			szBuffer.append(NEWLINE);
			iTotal += iAnger;
		}
	}

	iAnger = -(city.getBuildingBadHappiness() + city.getExtraBuildingBadHappiness());
	if (iAnger > 0)
	{
		szBuffer.append(gDLL->getText("TXT_KEY_UNHAPPY_CITY_BUILDINGS", iAnger));
		szBuffer.append(NEWLINE);
		iTotal += iAnger;
	}

	iAnger = -city.getFeatureBadHappiness();
	if (iAnger > 0)
	{
		szBuffer.append(gDLL->getText("TXT_KEY_ANGER_FEATURES", iAnger));
		szBuffer.append(NEWLINE);
		iTotal += iAnger;
	}

	iAnger = -city.getBonusBadHappiness();
	if (iAnger > 0)
	{
		szBuffer.append(gDLL->getText("TXT_KEY_ANGER_BONUS", iAnger));
		szBuffer.append(NEWLINE);
		iTotal += iAnger;
	}

	iAnger = -city.getSpecialistUnhappiness() / 100;
	if (iAnger > 0)
	{
		szBuffer.append(gDLL->getText("TXT_KEY_UNHAPPY_SPECIALISTS", iAnger));
		szBuffer.append(NEWLINE);
		iTotal += iAnger;
	}

	iAnger = -city.getReligionBadHappiness();
	if (iAnger > 0)
	{
		szBuffer.append(gDLL->getText("TXT_KEY_ANGER_RELIGIOUS_FREEDOM", iAnger));
		szBuffer.append(NEWLINE);
		iTotal += iAnger;
	}

	iAnger = -city.getCommerceHappiness();
	if (iAnger > 0)
	{
		szBuffer.append(gDLL->getText("TXT_KEY_ANGER_BAD_ENTERTAINMENT", iAnger));
		szBuffer.append(NEWLINE);
		iTotal += iAnger;
	}

	iAnger = -city.area()->getBuildingHappiness(city.getOwner());
	if (iAnger > 0)
	{
		szBuffer.append(gDLL->getText("TXT_KEY_UNHAPPY_AREA_BUILDINGS", iAnger));
		szBuffer.append(NEWLINE);
		iTotal += iAnger;
	}

	iAnger = -kPlayer.getBuildingHappiness();
	if (iAnger > 0)
	{
		szBuffer.append(gDLL->getText("TXT_KEY_UNHAPPY_PLAYER_BUILDINGS", iAnger));
		szBuffer.append(NEWLINE);
		iTotal += iAnger;
	}

	iAnger = -(city.getExtraHappiness() + kPlayer.getExtraHappiness());
	if (iAnger > 0)
	{
		szBuffer.append(gDLL->getText("TXT_KEY_ANGER_ARGH", iAnger));
		szBuffer.append(NEWLINE);
		iTotal += iAnger;
	}

	iAnger = -city.getExtraTechHappinessTotal();
	if (iAnger > 0)
	{
		szBuffer.append(gDLL->getText("TXT_KEY_UNHAPPY_TECH_SPECIALIST", iAnger));
		szBuffer.append(NEWLINE);
		iTotal += iAnger;
	}

	if (GC.getGame().getHandicapType() != NO_HANDICAP)
	{
		iAnger = -GC.getHandicapInfo(city.getHandicapType()).getHappyBonus();
		if (iAnger > 0)
		{
			szBuffer.append(gDLL->getText("TXT_KEY_ANGER_HANDICAP", iAnger));
			szBuffer.append(NEWLINE);
			iTotal += iAnger;
		}
	}

	int iUnhappy = city.unhappyLevel();
	if (iUnhappy > iTotal)
	{
		// Accounting for rounding error in the above decomposition and other possible sources not handled above.
		szBuffer.append(gDLL->getText("TXT_KEY_ANGER_MISC", iUnhappy - iTotal));
		szBuffer.append(NEWLINE);
	}
	szBuffer.append(L"-----------------------\n");
	szBuffer.append(gDLL->getText("TXT_KEY_ANGER_TOTAL_UNHAPPY", iUnhappy));
}


void CvGameTextMgr::setHappyHelp(CvWStringBuffer &szBuffer, CvCity& city)
{

	if (city.isDisorder())
	{
		return;
	}
	if (city.happyLevel() > 0)
	{
		int iTotalHappy = 0;
		int iHappy = city.getRevSuccessHappiness();
		if (iHappy > 0)
		{
			iTotalHappy += iHappy;
			szBuffer.append(gDLL->getText("TXT_KEY_REV_SUCCESS_HAPPINESS", iHappy));
			szBuffer.append(NEWLINE);
		}

		iHappy = city.getLargestCityHappiness();
		if (iHappy > 0)
		{
			iTotalHappy += iHappy;
			szBuffer.append(gDLL->getText("TXT_KEY_HAPPY_BIG_CITY", iHappy));
			szBuffer.append(NEWLINE);
		}

		iHappy = city.getCivicHappiness();
		if (iHappy > 0)
		{
			iTotalHappy += iHappy;
			szBuffer.append(gDLL->getText("TXT_KEY_HAPPY_CIVIC", iHappy));
			szBuffer.append(NEWLINE);
		}

		iHappy = GET_PLAYER(city.getOwner()).getWorldHappiness();
		if (iHappy > 0)
		{
			iTotalHappy += iHappy;
			szBuffer.append(gDLL->getText("TXT_KEY_HAPPY_WORLD_PROJECT", iHappy));
			szBuffer.append(NEWLINE);
		}

		iHappy = GET_PLAYER(city.getOwner()).getProjectHappiness();
		if (iHappy > 0)
		{
			iTotalHappy += iHappy;
			szBuffer.append(gDLL->getText("TXT_KEY_HAPPY_WORLD_PROJECT", iHappy));
			szBuffer.append(NEWLINE);
		}
		iHappy = city.calculateCorporationHappiness();
		if (iHappy > 0)
		{
			iTotalHappy += iHappy;
			szBuffer.append(gDLL->getText("TXT_KEY_HAPPY_CORPORATIONS", iHappy));
			szBuffer.append(NEWLINE);
		}
		if (GC.getGame().isOption(GAMEOPTION_MAP_PERSONALIZED))
		{
			iHappy = GET_PLAYER(city.getOwner()).getLandmarkHappiness();
			if (iHappy > 0)
			{
				iTotalHappy += iHappy;
				szBuffer.append(gDLL->getText("TXT_KEY_HAPPY_LANDMARKS", iHappy));
				szBuffer.append(NEWLINE);
			}
		}

		iHappy = city.getMilitaryHappiness();
		if (iHappy > 0)
		{
			iTotalHappy += iHappy;
			szBuffer.append(gDLL->getText("TXT_KEY_HAPPY_MILITARY_PRESENCE", iHappy));
			szBuffer.append(NEWLINE);
		}

		iHappy = city.getVassalHappiness();
		if (iHappy > 0)
		{
			iTotalHappy += iHappy;
			szBuffer.append(gDLL->getText("TXT_KEY_HAPPY_VASSAL", iHappy));
			szBuffer.append(NEWLINE);
		}

		iHappy = city.getCurrentStateReligionHappiness();
		if (iHappy > 0)
		{
			iTotalHappy += iHappy;
			szBuffer.append(gDLL->getText("TXT_KEY_HAPPY_STATE_RELIGION", iHappy));
			szBuffer.append(NEWLINE);
		}

		iHappy = 0;
		int iValue = city.area()->getBuildingHappiness(city.getOwner());
		if (iValue > 0)
		{
			iHappy += iValue;
		}
		iValue = GET_PLAYER(city.getOwner()).getBuildingHappiness();
		if (iValue > 0)
		{
			iHappy += iValue;
		}
		iValue = (city.getBuildingGoodHappiness() + city.getExtraBuildingGoodHappiness());
		if (iValue > 0)
		{
			iHappy += iValue;
		}
		if (iHappy > 0)
		{
			iTotalHappy += iHappy;
			szBuffer.append(gDLL->getText("TXT_KEY_HAPPY_BUILDINGS", iHappy));
			szBuffer.append(NEWLINE);
		}

		iHappy = city.getFeatureGoodHappiness();
		if (iHappy > 0)
		{
			iTotalHappy += iHappy;
			szBuffer.append(gDLL->getText("TXT_KEY_HAPPY_FEATURES", iHappy));
			szBuffer.append(NEWLINE);
		}

		iHappy = city.getBonusGoodHappiness();
		if (iHappy > 0)
		{
			iTotalHappy += iHappy;
			szBuffer.append(gDLL->getText("TXT_KEY_HAPPY_BONUS", iHappy));
			szBuffer.append(NEWLINE);
		}

		iHappy = city.getSpecialistHappiness() / 100;
		if (iHappy > 0)
		{
			iTotalHappy += iHappy;
			szBuffer.append(gDLL->getText("TXT_KEY_HAPPY_SPECIALISTS", iHappy));
			szBuffer.append(NEWLINE);
		}

		iHappy = city.getReligionGoodHappiness();
		if (iHappy > 0)
		{
			iTotalHappy += iHappy;
			szBuffer.append(gDLL->getText("TXT_KEY_HAPPY_RELIGIOUS_FREEDOM", iHappy));
			szBuffer.append(NEWLINE);
		}

		iHappy = city.getCommerceHappiness();
		if (iHappy > 0)
		{
			iTotalHappy += iHappy;
			szBuffer.append(gDLL->getText("TXT_KEY_HAPPY_ENTERTAINMENT", iHappy));
			szBuffer.append(NEWLINE);
		}

		iHappy = (city.getExtraHappiness() + GET_PLAYER(city.getOwner()).getExtraHappiness());
		if (iHappy > 0)
		{
			iTotalHappy += iHappy;
			szBuffer.append(gDLL->getText("TXT_KEY_HAPPY_YEAH", iHappy));
			szBuffer.append(NEWLINE);
		}

		if (city.getHappinessTimer() > 0)
		{
			iHappy = GC.getTEMP_HAPPY();
			iTotalHappy += iHappy;
			szBuffer.append(gDLL->getText("TXT_KEY_HAPPY_TEMP", iHappy, city.getHappinessTimer()));
			szBuffer.append(NEWLINE);
		}

		iHappy = GC.getHandicapInfo(city.getHandicapType()).getHappyBonus();
		if (iHappy > 0)
		{
			iTotalHappy += iHappy;
			szBuffer.append(gDLL->getText("TXT_KEY_HAPPY_HANDICAP", iHappy));
			szBuffer.append(NEWLINE);
		}

		iHappy = std::max(0, (city.getCelebrityHappiness()));
		if (iHappy > 0)
		{
			iTotalHappy += iHappy;
			szBuffer.append(gDLL->getText("TXT_KEY_HAPPY_CELEBRITY", iHappy));
			szBuffer.append(NEWLINE);
		}

		iHappy = city.getExtraTechHappinessTotal();
		if (iHappy > 0)
		{
			iTotalHappy += iHappy;
			szBuffer.append(gDLL->getText("TXT_KEY_HAPPY_TECH_SPECIALIST", iHappy));
			szBuffer.append(NEWLINE);
		}

		szBuffer.append(L"-----------------------\n");

		szBuffer.append(gDLL->getText("TXT_KEY_HAPPY_TOTAL_HAPPY", iTotalHappy));

		FAssert(iTotalHappy == city.happyLevel())
	}
}

// BUG - Building Additional Happiness - start
bool CvGameTextMgr::setBuildingAdditionalHappinessHelp(CvWStringBuffer &szBuffer, CvCity& city, const CvWString& szStart, bool bStarted)
{
	PROFILE_EXTRA_FUNC();
	for (int i = 0; i < GC.getNumBuildingInfos(); i++)
	{
		const BuildingTypes eBuilding = static_cast<BuildingTypes>(i);

		if (city.canConstruct(eBuilding, false, false, false))
		{
			int iGood = 0, iBad = 0, iAngryPop = 0;
			city.getAdditionalHappinessByBuilding(eBuilding, iGood, iBad, iAngryPop);

			if (iGood != 0 || iBad != 0)
			{
				if (!bStarted)
				{
					szBuffer.append(szStart);
					bStarted = true;
				}

				CvWString szLabel;
				szLabel.Format(SETCOLR L"%s" ENDCOLR, TEXT_COLOR("COLOR_BUILDING_TEXT"), GC.getBuildingInfo(eBuilding).getDescription());
				const bool bStartedLine = setResumableGoodBadChangeHelp(szBuffer, szLabel, L": ", L"", iGood, gDLL->getSymbolID(HAPPY_CHAR), iBad, gDLL->getSymbolID(UNHAPPY_CHAR), false, true);
				setResumableValueChangeHelp(szBuffer, szLabel, L": ", L"", iAngryPop, gDLL->getSymbolID(ANGRY_POP_CHAR), false, true, bStartedLine);
			}
		}
	}

	return bStarted;
}
// BUG - Building Additional Happiness - end


// BUG - Resumable Value Change Help - start
void CvGameTextMgr::setYieldChangeHelp(CvWStringBuffer &szBuffer, const CvWString& szStart, const CvWString& szSpace, const CvWString& szEnd, const int* piYieldChange, bool bPercent, bool bNewLine)
{
	setResumableYieldChangeHelp(szBuffer, szStart, szSpace, szEnd, piYieldChange, bPercent, bNewLine);
}
void CvGameTextMgr::setYieldPerPopChangeHelp(CvWStringBuffer &szBuffer, const CvWString& szStart, const CvWString& szSpace, const CvWString& szEnd, const int* piYieldChange, bool bPercent, bool bNewLine)
{
	setResumableYieldChangeHelp(szBuffer, szStart, szSpace, szEnd, piYieldChange, bPercent, bNewLine, false, true);
}

/*
 * Adds the ability to pass in and get back the value of bStarted so that
 * it can be used with other setResumable<xx>ChangeHelp() calls on a single line.
 */
bool CvGameTextMgr::setResumableYieldChangeHelp(CvWStringBuffer &szBuffer, const CvWString& szStart, const CvWString& szSpace, const CvWString& szEnd, const int* piYieldChange, bool bPercent, bool bNewLine, bool bStarted, bool bPerPop)
{
	PROFILE_EXTRA_FUNC();
	CvWString szPerPop;

	if (bPerPop)
	{
		szPerPop.append(gDLL->getText("TXT_KEY_PER_POP"));
	}

	if (piYieldChange)
	{
		for (int iI = 0; iI < NUM_YIELD_TYPES; ++iI)
		{
			if (piYieldChange[iI] != 0)
			{
				CvWString szTempBuffer;
				if (!bStarted)
				{
					if (bNewLine)
					{
						szTempBuffer.Format(L"\n%c", gDLL->getSymbolID(BULLET_CHAR));
					}
					if (!bPerPop)
					{
						szTempBuffer += CvWString::format(
							L"%s%s%s%d%s%c",
							szStart.GetCString(),
							szSpace.GetCString(),
							piYieldChange[iI] > 0 ? L"+" : L"",
							piYieldChange[iI],
							bPercent ? L"%" : L"",
							GC.getYieldInfo((YieldTypes)iI).getChar()
						);
					}
					else if (piYieldChange[iI] % 100 == 0)
					{
						szTempBuffer += CvWString::format(
							L"%s%s%s%d%s%c%s",
							szStart.GetCString(),
							szSpace.GetCString(),
							piYieldChange[iI] > 0 ? L"+" : L"",
							piYieldChange[iI] / 100,
							bPercent ? L"%" : L"",
							GC.getYieldInfo((YieldTypes)iI).getChar(),
							szPerPop.GetCString()
						);
					}
					else
					{
						szTempBuffer += CvWString::format(
							L"%s%s%s%d.%02d%s%c%s",
							szStart.GetCString(),
							szSpace.GetCString(),
							piYieldChange[iI] > 0 ? L"+" : L"",
							piYieldChange[iI] / 100,
							piYieldChange[iI] % 100,
							bPercent ? L"%" : L"",
							GC.getYieldInfo((YieldTypes)iI).getChar(),
							szPerPop.GetCString()
						);
					}
				}
				else if (!bPerPop)
				{
					szTempBuffer.Format(
						L", %s%d%s%c",
						piYieldChange[iI] > 0 ? L"+" : L"",
						piYieldChange[iI],
						bPercent ? L"%" : L"",
						GC.getYieldInfo((YieldTypes)iI).getChar()
					);
				}
				else if (piYieldChange[iI] % 100 == 0)
				{
					szTempBuffer.Format(
						L", %s%d%s%c%s",
						piYieldChange[iI] > 0 ? L"+" : L"",
						piYieldChange[iI] / 100,
						bPercent ? L"%" : L"",
						GC.getYieldInfo((YieldTypes)iI).getChar(),
						szPerPop.GetCString()
					);
				}
				else
				{
					szTempBuffer.Format(
						L", %s%d.%02d%s%c%s",
						piYieldChange[iI] > 0 ? L"+" : L"",
						piYieldChange[iI] / 100,
						piYieldChange[iI] % 100,
						bPercent ? L"%" : L"",
						GC.getYieldInfo((YieldTypes)iI).getChar(),
						szPerPop.GetCString()
					);
				}
				szBuffer.append(szTempBuffer);
				bStarted = true;
			}
		}
		if (bStarted)
		{
			szBuffer.append(szEnd);
		}
	}
	return bStarted;
}


void CvGameTextMgr::listCommerceChange(CvWStringBuffer &szBuffer, const CvWString& szStart, const CvWString& szEnd, const int* aList, bool bPercent)
{
	PROFILE_EXTRA_FUNC();
	bool bStarted = false;
	for (int iI = 0; iI < NUM_COMMERCE_TYPES; ++iI)
	{
		if (aList[iI] != 0)
		{
			if (bStarted)
			{
				szBuffer.append(L", ");
			}
			else
			{
				szBuffer.append(szStart);
				bStarted = true;
			}
			szBuffer.append(CvWString::format(L"%s%d%s%c", (aList[iI] > 0) ? L"+" : L"", aList[iI], (bPercent) ? L"%" : L"", GC.getCommerceInfo((CommerceTypes)iI).getChar()));
		}
	}
	if (bStarted)
	{
		szBuffer.append(szEnd);
	}
}

/*
 * Displays float values by dividing each value by 100.
 */
void CvGameTextMgr::setCommerceTimes100ChangeHelp(CvWStringBuffer &szBuffer, const CvWString& szStart, const CvWString& szSpace, const CvWString& szEnd, const int* piCommerceChange, bool bNewLine, bool bStarted)
{
	setResumableCommerceTimes100ChangeHelp(szBuffer, szStart, szSpace, szEnd, piCommerceChange, bNewLine);
}

/*
 * Adds the ability to pass in and get back the value of bStarted so that
 * it can be used with other setResumable<xx>ChangeHelp() calls on a single line.
 */
bool CvGameTextMgr::setResumableCommerceTimes100ChangeHelp(CvWStringBuffer &szBuffer, const CvWString& szStart, const CvWString& szSpace, const CvWString& szEnd, const int* piCommerceChange, bool bNewLine, bool bStarted)
{
	PROFILE_EXTRA_FUNC();
	CvWString szTempBuffer;

	for (int iI = 0; iI < NUM_COMMERCE_TYPES; ++iI)
	{
		int iChange = piCommerceChange[iI];
		if (iChange != 0)
		{
			if (!bStarted)
			{
				if (bNewLine)
				{
					szTempBuffer.Format(L"\n%c", gDLL->getSymbolID(BULLET_CHAR));
				}
				szTempBuffer += CvWString::format(L"%s%s", szStart.GetCString(), szSpace.GetCString());
				bStarted = true;
			}
			else
			{
				szTempBuffer.Format(L", ");
			}
			szBuffer.append(szTempBuffer);

			if (iChange % 100 == 0)
			{
				szTempBuffer.Format(L"%+d%c", iChange / 100, GC.getCommerceInfo((CommerceTypes) iI).getChar());
			}
			else
			{
				if (iChange >= 0)
				{
					szBuffer.append(L"+");
				}
				else
				{
					iChange = - iChange;
					szBuffer.append(L"-");
				}
				szTempBuffer.Format(L"%d.%02d%c", iChange / 100, iChange % 100, GC.getCommerceInfo((CommerceTypes) iI).getChar());
			}
			szBuffer.append(szTempBuffer);
		}
	}

	if (bStarted)
	{
		szBuffer.append(szEnd);
	}

	return bStarted;
}

/*
 * Adds the ability to pass in and get back the value of bStarted so that
 * it can be used with other setResumable<xx>ChangeHelp() calls on a single line.
 */
bool CvGameTextMgr::setResumableGoodBadChangeHelp(CvWStringBuffer &szBuffer, const CvWString& szStart, const CvWString& szSpace, const CvWString& szEnd, int iGood, int iGoodSymbol, int iBad, int iBadSymbol, bool bPercent, bool bNewLine, bool bStarted)
{
	bStarted = setResumableValueChangeHelp(szBuffer, szStart, szSpace, szEnd, iGood, iGoodSymbol, bPercent, bNewLine, bStarted);
	bStarted = setResumableValueChangeHelp(szBuffer, szStart, szSpace, szEnd, iBad, iBadSymbol, bPercent, bNewLine, bStarted);

	return bStarted;
}

/*
 * Adds the ability to pass in and get back the value of bStarted so that
 * it can be used with other setResumable<xx>ChangeHelp() calls on a single line.
 */
bool CvGameTextMgr::setResumableValueChangeHelp(CvWStringBuffer &szBuffer, const CvWString& szStart, const CvWString& szSpace, const CvWString& szEnd, int iValue, int iSymbol, bool bPercent, bool bNewLine, bool bStarted)
{
	CvWString szTempBuffer;

	if (iValue != 0)
	{
		if (!bStarted)
		{
			if (bNewLine)
			{
				szTempBuffer.Format(L"\n%c", gDLL->getSymbolID(BULLET_CHAR));
			}
			szTempBuffer += CvWString::format(L"%s%s", szStart.GetCString(), szSpace.GetCString());
		}
		else
		{
			szTempBuffer = L", ";
		}
		szBuffer.append(szTempBuffer);

		szTempBuffer.Format(L"%+d%s%c", iValue, bPercent ? L"%" : L"", iSymbol);
		szBuffer.append(szTempBuffer);

		bStarted = true;
	}

	return bStarted;
}

/*
 * Adds the ability to pass in and get back the value of bStarted so that
 * it can be used with other setResumable<xx>ChangeHelp() calls on a single line.
 */
bool CvGameTextMgr::setResumableValueTimes100ChangeHelp(CvWStringBuffer &szBuffer, const CvWString& szStart, const CvWString& szSpace, const CvWString& szEnd, int iValue, int iSymbol, bool bNewLine, bool bStarted)
{
	CvWString szTempBuffer;

	if (iValue != 0)
	{
		if (!bStarted)
		{
			if (bNewLine)
			{
				szTempBuffer.Format(L"\n%c", gDLL->getSymbolID(BULLET_CHAR));
			}
			szTempBuffer += CvWString::format(L"%s%s", szStart.GetCString(), szSpace.GetCString());
		}
		else
		{
			szTempBuffer = L", ";
		}
		szBuffer.append(szTempBuffer);

		if (iValue % 100 == 0)
		{
			szTempBuffer.Format(L"%+d%c", iValue / 100, iSymbol);
		}
		else
		{
			if (iValue >= 0)
			{
				szBuffer.append(L"+");
			}
			else
			{
				iValue = - iValue;
				szBuffer.append(L"-");
			}
			szTempBuffer.Format(L"%d.%02d%c", iValue / 100, iValue % 100, iSymbol);
		}
		szBuffer.append(szTempBuffer);

		bStarted = true;
	}

	return bStarted;
}
// BUG - Resumable Value Change Help - end

/************************************************************************************************/
/* REVOLUTION_MOD								 ?/?/?						   DPII		  */
/*																							  */
/* BUG																						  */
/************************************************************************************************/
void CvGameTextMgr::setBonusHelp(CvWStringBuffer &szBuffer, BonusTypes eBonus, bool bCivilopediaText)
{
	setBonusTradeHelp(szBuffer, eBonus, bCivilopediaText, NO_PLAYER);
}

void CvGameTextMgr::setBonusTradeHelp(CvWStringBuffer &szBuffer, BonusTypes eBonus, bool bCivilopediaText, PlayerTypes eTradePlayer)
{
PROFILE_EXTRA_FUNC();
/************************************************************************************************/
/* REVOLUTION_MOD						  END												  */
/************************************************************************************************/

	if (NO_BONUS == eBonus)
	{
		return;
	}

	PlayerTypes eTradingPlayer = NO_PLAYER;
	if ( gDLL->isDiplomacy() )
	{
		eTradingPlayer = (PlayerTypes) gDLL->getDiplomacyPlayer();
	}
	else if (gDLL->isMPDiplomacy() && gDLL->isMPDiplomacyScreenUp())
	{
		eTradingPlayer = (PlayerTypes) gDLL->getMPDiplomacyPlayer();
	}

	bool bTradingPlayer = eTradingPlayer != NO_PLAYER;

	if (!bCivilopediaText)
	{
		szBuffer.append(CvWString::format( SETCOLR L"%s" ENDCOLR , TEXT_COLOR("COLOR_HIGHLIGHT_TEXT"), GC.getBonusInfo(eBonus).getDescription()));

		if (NO_PLAYER != GC.getGame().getActivePlayer())
		{
			CvPlayer& kActivePlayer = GET_PLAYER(GC.getGame().getActivePlayer());
			szBuffer.append(gDLL->getText("TXT_KEY_BONUSHELP_AVAILABLE_PLAYER", kActivePlayer.getNumAvailableBonuses(eBonus), kActivePlayer.getNameKey()));

			if (bTradingPlayer)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_BONUSHELP_AVAILABLE_PLAYER", GET_PLAYER(eTradingPlayer).getNumAvailableBonuses(eBonus), GET_PLAYER(eTradingPlayer).getNameKey()));
			}
			for (int iCorp = 0; iCorp < GC.getNumCorporationInfos(); ++iCorp)
			{
				if (kActivePlayer.isActiveCorporation((CorporationTypes)iCorp) || (bTradingPlayer && GET_PLAYER(eTradingPlayer).isActiveCorporation((CorporationTypes)iCorp)))
				{
					if (algo::any_of_equal(GC.getCorporationInfo((CorporationTypes)iCorp).getPrereqBonuses(), eBonus))
					{
						if (algo::any_of(kActivePlayer.cities(), bind(CvCity::isHasCorporation, _1, (CorporationTypes)iCorp))

						|| (bTradingPlayer && algo::any_of(GET_PLAYER(eTradingPlayer).cities(), bind(CvCity::isHasCorporation, _1, (CorporationTypes)iCorp))))
						{
							szBuffer.append(GC.getCorporationInfo((CorporationTypes)iCorp).getChar());
							break;
						}
					}
				}
			}

			if (kActivePlayer.getBonusImport(eBonus) > 0)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_BONUSHELP_IMPORTS_PLAYER", kActivePlayer.getBonusImport(eBonus), kActivePlayer.getNameKey()));
			}
			if (kActivePlayer.getBonusExport(eBonus) > 0)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_BONUSHELP_EXPORTS_PLAYER", kActivePlayer.getBonusExport(eBonus), kActivePlayer.getNameKey()));
			}
			if (bTradingPlayer)
			{
				if (GET_PLAYER(eTradingPlayer).getBonusImport(eBonus) > 0)
				{
					szBuffer.append(NEWLINE);
					szBuffer.append(gDLL->getText("TXT_KEY_BONUSHELP_IMPORTS_PLAYER", GET_PLAYER(eTradingPlayer).getBonusImport(eBonus), GET_PLAYER(eTradingPlayer).getNameKey()));
				}
				if (GET_PLAYER(eTradingPlayer).getBonusExport(eBonus) > 0)
				{
					szBuffer.append(NEWLINE);
					szBuffer.append(gDLL->getText("TXT_KEY_BONUSHELP_EXPORTS_PLAYER", GET_PLAYER(eTradingPlayer).getBonusExport(eBonus), GET_PLAYER(eTradingPlayer).getNameKey()));
				}
			}
		}

		setYieldChangeHelp(szBuffer, L"", L"", L"", GC.getBonusInfo(eBonus).getYieldChangeArray());

		if (GC.getBonusInfo(eBonus).getTechReveal() != NO_TECH)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BONUSHELP_REVEALED_BY", GC.getTechInfo((TechTypes)GC.getBonusInfo(eBonus).getTechReveal()).getTextKeyWide()));
		}
	}


	ImprovementTypes eImprovement = NO_IMPROVEMENT;
	for (int iLoopImprovement = 0; iLoopImprovement < GC.getNumImprovementInfos(); iLoopImprovement++)
	{
		eImprovement = NO_IMPROVEMENT;
		if (GC.getImprovementInfo((ImprovementTypes)iLoopImprovement).isImprovementBonusMakesValid(eBonus))
		{
			eImprovement = (ImprovementTypes)iLoopImprovement;
		}
		if (eImprovement != NO_IMPROVEMENT)
		{
			if (GC.getBonusInfo(eBonus).getHealth() != 0)
			{
				if (GC.getBonusInfo(eBonus).getHealth() > 0)
				{
					szBuffer.append(NEWLINE);
					szBuffer.append(gDLL->getText("TXT_KEY_BONUSHELP_HEALTHY", GC.getBonusInfo(eBonus).getHealth()));
				}
				else
				{
					szBuffer.append(NEWLINE);
					szBuffer.append(gDLL->getText("TXT_KEY_BONUSHELP_UNHEALTHY", -GC.getBonusInfo(eBonus).getHealth()));
				}

				szBuffer.append(gDLL->getText("TXT_KEY_BONUSHELP_WITH_IMPROVEMENT", GC.getImprovementInfo(eImprovement).getTextKeyWide()));
			}

			if (GC.getBonusInfo(eBonus).getHappiness() != 0)
			{
				if (GC.getBonusInfo(eBonus).getHappiness() > 0)
				{
					szBuffer.append(NEWLINE);
					szBuffer.append(gDLL->getText("TXT_KEY_BONUSHELP_HAPPY", GC.getBonusInfo(eBonus).getHappiness()));
				}
				else
				{
					szBuffer.append(NEWLINE);
					szBuffer.append(gDLL->getText("TXT_KEY_BONUSHELP_UNHAPPY", -GC.getBonusInfo(eBonus).getHappiness()));
				}

				szBuffer.append(gDLL->getText("TXT_KEY_BONUSHELP_WITH_IMPROVEMENT", GC.getImprovementInfo(eImprovement).getTextKeyWide()));
			}
		}
		else if (GC.getImprovementInfo((ImprovementTypes)iLoopImprovement).isImprovementObsoleteBonusMakesValid(eBonus))
		{
			eImprovement = (ImprovementTypes)iLoopImprovement;
			szBuffer.append(gDLL->getText("TXT_KEY_BONUSHELP_OBSOLETED_VALIDATES_IMPROVEMENT", GC.getImprovementInfo(eImprovement).getTextKeyWide()));
		}

	}

	foreach_(const CvBuildingInfo* pBuilding, GC.getBuildingInfos())
	{
		const int iHappiness = pBuilding->getBonusHappinessChanges().getValue(eBonus);
		if (iHappiness != 0)
		{
			if (iHappiness > 0)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_BONUSHELP_HAPPY", iHappiness));
			}
			else
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_BONUSHELP_UNHAPPY", -iHappiness));
			}

			szBuffer.append(gDLL->getText("TXT_KEY_BONUSHELP_WITH_IMPROVEMENT", pBuilding->getTextKeyWide()));
		}

		const int iHealth = pBuilding->getBonusHealthChanges().getValue(eBonus);
		if (iHealth != 0)
		{
			if (iHealth > 0)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_BONUSHELP_HEALTHY", iHealth));
			}
			else
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_BONUSHELP_UNHEALTHY", -iHealth));
			}

			szBuffer.append(gDLL->getText("TXT_KEY_BONUSHELP_WITH_IMPROVEMENT", pBuilding->getTextKeyWide()));
		}
	}

// BUG - Trade Denial - start
	if (eTradePlayer != NO_PLAYER && GC.getGame().getActivePlayer() != NO_PLAYER && getBugOptionBOOL("MiscHover__BonusTradeDenial", true, "BUG_BONUS_TRADE_DENIAL_HOVER"))
	{
		TradeData trade;
		trade.m_eItemType = TRADE_RESOURCES;
		trade.m_iData = eBonus;

		if (GET_PLAYER(eTradePlayer).canTradeItem(GC.getGame().getActivePlayer(), trade, false))
		{
			const DenialTypes eDenial = GET_PLAYER(eTradePlayer).getTradeDenial(GC.getGame().getActivePlayer(), trade);
			if (eDenial != NO_DENIAL)
			{
				CvWString szTempBuffer;
				szTempBuffer.Format(SETCOLR L"%s" ENDCOLR, TEXT_COLOR("COLOR_NEGATIVE_TEXT"), GC.getDenialInfo(eDenial).getDescription());
				szBuffer.append(NEWLINE);
				szBuffer.append(szTempBuffer);
			}
		}
	}
// BUG - Trade Denial - end

	if (!CvWString(GC.getBonusInfo(eBonus).getHelp()).empty())
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(GC.getBonusInfo(eBonus).getHelp());
	}
	if (bCivilopediaText)
	{
		foreach_(const MapCategoryTypes eMapCategory, GC.getBonusInfo(eBonus).getMapCategories())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_MAP_CATEGORY_PREREQUISITE", GC.getMapCategoryInfo(eMapCategory).getTextKeyWide()));
		}
	}
}

void CvGameTextMgr::setReligionHelp(CvWStringBuffer &szBuffer, ReligionTypes eReligion, bool bCivilopedia)
{
	if (NO_RELIGION == eReligion)
	{
		return;
	}
	const CvReligionInfo& religion = GC.getReligionInfo(eReligion);

	if (!bCivilopedia)
	{
		szBuffer.append(CvWString::format(SETCOLR L"%s" ENDCOLR , TEXT_COLOR("COLOR_HIGHLIGHT_TEXT"), religion.getDescription()));
	}

	{
		const int* aList = religion.getHolyCityCommerceArray();
		if (aList)
		{
			listCommerceChange(szBuffer, CvWString::format(L"\n%c%s: ", gDLL->getSymbolID(BULLET_CHAR), gDLL->getText("TXT_KEY_RELIGION_HOLY_CITY").c_str()), L"", aList, true);
		}
	}
	{
		const int* aList = religion.getStateReligionCommerceArray();
		if (aList)
		{
			listCommerceChange(szBuffer, CvWString::format(L"\n%c%s: ", gDLL->getSymbolID(BULLET_CHAR), gDLL->getText("TXT_KEY_RELIGION_ALL_CITIES").c_str()), L"", aList, true);
		}
	}

	if (religion.getTechPrereq() != NO_TECH)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(
			gDLL->getText(
				"TXT_KEY_RELIGION_FOUNDED_FIRST",
				CvWString(GC.getTechInfo(religion.getTechPrereq()).getType()).c_str(),
				GC.getTechInfo(religion.getTechPrereq()).getTextKeyWide()
			)
		);
	}
	const UnitTypes eFreeUnit = (UnitTypes) religion.getFreeUnit();

	if (eFreeUnit != NO_UNIT)
	{
		if (religion.getNumFreeUnits() > 1)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_RELIGION_FOUNDER_RECEIVES_NUM", GC.getUnitInfo(eFreeUnit).getTextKeyWide(), religion.getNumFreeUnits()));
		}
		else if (religion.getNumFreeUnits() > 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_RELIGION_FOUNDER_RECEIVES", GC.getUnitInfo(eFreeUnit).getTextKeyWide()));
		}
	}
}

void CvGameTextMgr::setReligionHelpCity(CvWStringBuffer &szBuffer, ReligionTypes eReligion, CvCity *pCity, bool bCityBar, bool bForceReligion, bool bForceState, bool bNoStateReligion)
{
	PROFILE_EXTRA_FUNC();
	int i;
	CvWString szTempBuffer;
	bool bHandled = false;
	int iCommerce;
	int iHappiness;
	int iProductionModifier;
	int iFreeExperience;
	int iGreatPeopleRateModifier;

	if (!pCity)
	{
		return;
	}

	ReligionTypes eStateReligion = (bNoStateReligion ? NO_RELIGION : GET_PLAYER(pCity->getOwner()).getStateReligion());

	if (bCityBar)
	{
		szBuffer.append(CvWString::format(SETCOLR L"%s" ENDCOLR , TEXT_COLOR("COLOR_HIGHLIGHT_TEXT"), GC.getReligionInfo(eReligion).getDescription()));
		szBuffer.append(NEWLINE);

		if (!(GC.getGame().isReligionFounded(eReligion)) && !GC.getGame().isOption(GAMEOPTION_RELIGION_PICK))
		{
			if (GC.getReligionInfo(eReligion).getTechPrereq() != NO_TECH)
			{
				szBuffer.append(gDLL->getText("TXT_KEY_RELIGION_FOUNDED_FIRST", GC.getTechInfo(GC.getReligionInfo(eReligion).getTechPrereq()).getTextKeyWide()));
			}
		}
	}

	if (!bForceReligion)
	{
		if (!(pCity->isHasReligion(eReligion)))
		{
			return;
		}
	}

	if (eStateReligion == eReligion || eStateReligion == NO_RELIGION || (GET_PLAYER(pCity->getOwner()).isNonStateReligionCommerce()) || bForceState)
	{
		for (i = 0; i < NUM_COMMERCE_TYPES; i++)
		{
			iCommerce = GC.getReligionInfo(eReligion).getStateReligionCommerce((CommerceTypes)i);

			if (pCity->isHolyCity(eReligion))
			{
				iCommerce += GC.getReligionInfo(eReligion).getHolyCityCommerce((CommerceTypes)i);
			}

			if (iCommerce != 0)
			{
				if (bHandled)
				{
					szBuffer.append(L", ");
				}

				szTempBuffer.Format(L"%s%d%c", iCommerce > 0 ? L"+" : L"", iCommerce, GC.getCommerceInfo((CommerceTypes)i).getChar());
				szBuffer.append(szTempBuffer);
				bHandled = true;
			}
		}
	}

	if (eStateReligion == eReligion || bForceState)
	{
		iHappiness = (pCity->getStateReligionHappiness(eReligion) + GET_PLAYER(pCity->getOwner()).getStateReligionHappiness());

		if (iHappiness != 0)
		{
			if (bHandled)
			{
				szBuffer.append(L", ");
			}
			// Use absolute value with unhappy face
			szTempBuffer.Format(L"%d%c", abs(iHappiness), ((iHappiness > 0) ? gDLL->getSymbolID(HAPPY_CHAR) : gDLL->getSymbolID(UNHAPPY_CHAR)));

			szBuffer.append(szTempBuffer);
			bHandled = true;
		}

		iProductionModifier = GET_PLAYER(pCity->getOwner()).getStateReligionBuildingProductionModifier();
		if (iProductionModifier != 0)
		{
			if (bHandled)
			{
				szBuffer.append(L", ");
			}

			szBuffer.append(gDLL->getText("TXT_KEY_RELIGION_BUILDING_PROD_MOD", iProductionModifier));
			bHandled = true;
		}

		iProductionModifier = GET_PLAYER(pCity->getOwner()).getStateReligionUnitProductionModifier();
		if (iProductionModifier != 0)
		{
			if (bHandled)
			{
				szBuffer.append(L", ");
			}

			szBuffer.append(gDLL->getText("TXT_KEY_RELIGION_UNIT_PROD_MOD", iProductionModifier));
			bHandled = true;
		}

		iFreeExperience = GET_PLAYER(pCity->getOwner()).getStateReligionFreeExperience();
		if (iFreeExperience != 0)
		{
			if (bHandled)
			{
				szBuffer.append(L", ");
			}

			szBuffer.append(gDLL->getText("TXT_KEY_RELIGION_FREE_XP", iFreeExperience));
			bHandled = true;
		}

		iGreatPeopleRateModifier = GET_PLAYER(pCity->getOwner()).getStateReligionGreatPeopleRateModifier();
		if (iGreatPeopleRateModifier != 0)
		{
			if (bHandled)
			{
				szBuffer.append(L", ");
			}

			szBuffer.append(gDLL->getText("TXT_KEY_RELIGION_BIRTH_RATE_MOD", iGreatPeopleRateModifier));
			bHandled = true;
		}
	}
}

void CvGameTextMgr::setCorporationHelp(CvWStringBuffer &szBuffer, CorporationTypes eCorporation, bool bCivilopedia)
{
	PROFILE_EXTRA_FUNC();
	if (NO_CORPORATION == eCorporation)
	{
		return;
	}
	const CvCorporationInfo& kCorporation = GC.getCorporationInfo(eCorporation);

	if (!bCivilopedia)
	{
		szBuffer.append(CvWString::format(SETCOLR L"%s" ENDCOLR , TEXT_COLOR("COLOR_HIGHLIGHT_TEXT"), kCorporation.getDescription()));
	}

	CvWString szTempBuffer;
	szTempBuffer.clear();

	for (int iI = 0; iI < NUM_YIELD_TYPES; ++iI)
	{
		int iYieldProduced = kCorporation.getYieldProduced((YieldTypes)iI);
		if (NO_PLAYER != GC.getGame().getActivePlayer())
		{
			iYieldProduced *= GC.getWorldInfo(GC.getMap().getWorldSize()).getCorporationMaintenancePercent();
			iYieldProduced /= 100;
		}

		if (iYieldProduced != 0)
		{
			if (!szTempBuffer.empty())
			{
				szTempBuffer += L", ";
			}

			if (iYieldProduced % 100 == 0)
			{
				szTempBuffer += CvWString::format(L"%s%d%c",
					iYieldProduced > 0 ? L"+" : L"",
					iYieldProduced / 100,
					GC.getYieldInfo((YieldTypes)iI).getChar());
			}
			else
			{
				szTempBuffer += CvWString::format(L"%s%.2f%c",
					iYieldProduced > 0 ? L"+" : L"",
					0.01f * abs(iYieldProduced),
					GC.getYieldInfo((YieldTypes)iI).getChar());
			}
		}
	}

	if (!szTempBuffer.empty())
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_CORPORATION_ALL_CITIES", szTempBuffer.GetCString()));
	}

	szTempBuffer.clear();
	for (int iI = 0; iI < NUM_COMMERCE_TYPES; ++iI)
	{
		int iCommerceProduced = kCorporation.getCommerceProduced((CommerceTypes)iI);
		if (NO_PLAYER != GC.getGame().getActivePlayer())
		{
			iCommerceProduced *= GC.getWorldInfo(GC.getMap().getWorldSize()).getCorporationMaintenancePercent();
			iCommerceProduced /= 100;
		}
		if (iCommerceProduced != 0)
		{
			if (!szTempBuffer.empty())
			{
				szTempBuffer += L", ";
			}

			if (iCommerceProduced % 100 == 0)
			{
				szTempBuffer += CvWString::format(L"%s%d%c",
					iCommerceProduced > 0 ? L"+" : L"",
					iCommerceProduced / 100,
					GC.getCommerceInfo((CommerceTypes)iI).getChar());
			}
			else
			{
				szTempBuffer += CvWString::format(L"%s%.2f%c",
					iCommerceProduced > 0 ? L"+" : L"",
					0.01f * abs(iCommerceProduced),
					GC.getCommerceInfo((CommerceTypes)iI).getChar());
			}

		}
	}

	if (!szTempBuffer.empty())
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_CORPORATION_ALL_CITIES", szTempBuffer.c_str()));
	}

	if (!bCivilopedia && kCorporation.getTechPrereq() != NO_TECH)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_CORPORATION_FOUNDED_FIRST", CvWString(GC.getTechInfo(kCorporation.getTechPrereq()).getType()).c_str(), GC.getTechInfo(kCorporation.getTechPrereq()).getTextKeyWide()));
	}

	bool bFirst = true;
	szBuffer.append(NEWLINE);
	szBuffer.append(gDLL->getText("TXT_KEY_CORPORATION_BONUS_REQUIRED"));
	foreach_(const BonusTypes eBonus, kCorporation.getPrereqBonuses())
	{
		if (bFirst)
		{
			bFirst = false;
		}
		else
		{
			szBuffer.append(L", ");
		}

		if (!bFirst)
			szBuffer.append(gDLL->getText("TXT_KEY_CORPORATION_BONUS_CONSUMES", CvWString(GC.getBonusInfo(eBonus).getType()).GetCString(), GC.getBonusInfo(eBonus).getTextKeyWide(), GC.getBonusInfo(eBonus).getChar()));
	}

	if (kCorporation.getBonusProduced() != NO_BONUS)
	{
		if (!bFirst)
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_CORPORATION_BONUS_PRODUCED", GC.getBonusInfo((BonusTypes)kCorporation.getBonusProduced()).getChar()));
	}

	const UnitTypes eFreeUnit = (UnitTypes) kCorporation.getFreeUnit();

	if (eFreeUnit != NO_UNIT)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_RELIGION_FOUNDER_RECEIVES", GC.getUnitInfo(eFreeUnit).getTextKeyWide()));
	}

	bFirst = true;
	for (int iI = 0; iI < GC.getNumCorporationInfos(); ++iI)
	{
		if (iI != eCorporation)
		{
			const CvCorporationInfo& kLoopCorporation = GC.getCorporationInfo((CorporationTypes)iI);

			bool bCompeting = kLoopCorporation.isCompetingCorporation(eCorporation) || kCorporation.isCompetingCorporation(iI);

			if (!bCompeting)
			{
				foreach_(const BonusTypes eBonus, kCorporation.getPrereqBonuses())
				{
					if (algo::any_of_equal(kLoopCorporation.getPrereqBonuses(), eBonus))
					{
						bCompeting = true;
						break;
					}
				}
			}
			if (bCompeting)
			{
				const CvWString szTemp = CvWString::format(L"<link=%s>%s</link>", CvWString(kLoopCorporation.getType()).GetCString(), kLoopCorporation.getDescription());
				setListHelp(szBuffer, gDLL->getText("TXT_KEY_CORPORATION_COMPETES").c_str(), szTemp.GetCString(), L", ", bFirst);
				bFirst = false;
			}
		}
	}

	if (kCorporation.getHealth() > 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_CORPORATION_HEALTHINESS", kCorporation.getHealth()));
	}
	else if (kCorporation.getHealth() < 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_CORPORATION_UNHEALTHINESS", -kCorporation.getHealth()));
	}

	if (kCorporation.getHappiness() > 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_CORPORATION_HAPPINESS", kCorporation.getHappiness()));
	}
	else if (kCorporation.getHappiness() < 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_CORPORATION_UNHAPPINESS", -kCorporation.getHappiness()));
	}

	if (kCorporation.getMilitaryProductionModifier() != 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_CIVICHELP_MILITARY_PRODUCTION", kCorporation.getMilitaryProductionModifier()));
	}

	if (kCorporation.getFreeXP() != 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_CIVICHELP_FREE_XP", kCorporation.getFreeXP()));
	}

	{
		const int* aList = kCorporation.getCommerceChangeArray();
		if (aList)
		{
			listCommerceChange(szBuffer, CvWString::format(L"\n%c", gDLL->getSymbolID(BULLET_CHAR)), gDLL->getText("TXT_KEY_BUILDINGHELP_ALL_CITIES").c_str(), aList);
		}
	}
	setYieldChangeHelp(szBuffer, L"", L"", gDLL->getText("TXT_KEY_BUILDINGHELP_ALL_CITIES").c_str(), kCorporation.getYieldChangeArray(), false);

	for (int iI = 0; iI < GC.getNumBuildingInfos(); iI++)
	{
		if (kCorporation.getPrereqBuilding(iI) > 0)
		{
			szBuffer.append(
				CvWString::format(
					L"%s%s", NEWLINE,
					gDLL->getText(
						"TXT_KEY_HELPTEXT_REQUIRES_NUM_BUILDINGS_0",
						CvWString(GC.getBuildingInfo((BuildingTypes)iI).getType()).GetCString(),
						GC.getBuildingInfo((BuildingTypes)iI).getDescription(),
						kCorporation.getPrereqBuilding(iI)
					).c_str()
				)
			);
		}
	}
	if (kCorporation.getObsoleteTech() != NO_TECH)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_OBSOLETE_WITH", CvWString(GC.getTechInfo(kCorporation.getObsoleteTech()).getType()).GetCString(), GC.getTechInfo(kCorporation.getObsoleteTech()).getTextKeyWide()));
	}
}

void CvGameTextMgr::setCorporationHelpCity(CvWStringBuffer &szBuffer, CorporationTypes eCorporation, CvCity *pCity, bool bCityBar, bool bForceCorporation)
{
	PROFILE_EXTRA_FUNC();
	if (!pCity)
	{
		return;
	}

	const CvCorporationInfo& kCorporation = GC.getCorporationInfo(eCorporation);

	if (bCityBar)
	{
		szBuffer.append(CvWString::format(SETCOLR L"%s" ENDCOLR , TEXT_COLOR("COLOR_HIGHLIGHT_TEXT"), kCorporation.getDescription()));
		szBuffer.append(NEWLINE);

		if (!GC.getGame().isCorporationFounded(eCorporation) && kCorporation.getTechPrereq() != NO_TECH)
		{
			szBuffer.append(gDLL->getText("TXT_KEY_CORPORATION_FOUNDED_FIRST",
				CvWString(GC.getTechInfo(kCorporation.getTechPrereq()).getType()).c_str(),
				GC.getTechInfo(kCorporation.getTechPrereq()).getTextKeyWide()));
		}
	}

	if (!bForceCorporation && !pCity->isHasCorporation(eCorporation))
	{
		return;
	}

	int iNumResources = 0;
	int iNumReqResources = 0;
	foreach_(const BonusTypes eBonus, kCorporation.getPrereqBonuses())
	{
		iNumReqResources++;
		iNumResources += pCity->getNumBonuses(eBonus);
	}

	bool bActive = ((pCity->isActiveCorporation(eCorporation) || (bForceCorporation && iNumResources > 0) || (iNumReqResources == 0)) &&
	(!GET_TEAM(pCity->getTeam()).isHasTech(kCorporation.getObsoleteTech()) || (kCorporation.getObsoleteTech() == NO_TECH)));
	bool bGenerates = kCorporation.getBonusProduced() != NO_BONUS || kCorporation.getHappiness() != 0 || kCorporation.getHealth() != 0;
	int iMaintenance = 0;

	bool bHandled = false;
	for (int i = 0; i < NUM_YIELD_TYPES; ++i)
	{
		int iYield = 0;

		if (bActive)
		{
			iYield += (kCorporation.getYieldProduced(i) * iNumResources * GC.getWorldInfo(GC.getMap().getWorldSize()).getCorporationMaintenancePercent()) / 100;
			iYield += 100 * kCorporation.getYieldChange(i);
		}

		if (iYield != 0)
		{
			if (bHandled)
			{
				szBuffer.append(L", ");
			}

			CvWString szTempBuffer;
			szTempBuffer.Format(L"%s%d%c", iYield > 0 ? L"+" : L"", (iYield + 99) / 100, GC.getYieldInfo((YieldTypes)i).getChar());
			szBuffer.append(szTempBuffer);
			bHandled = true;
		}
	}

	bHandled = false;
	for (int i = 0; i < NUM_COMMERCE_TYPES; ++i)
	{
		int iCommerce = 0;

		if (bActive)
		{
			iCommerce += (kCorporation.getCommerceProduced(i) * iNumResources * GC.getWorldInfo(GC.getMap().getWorldSize()).getCorporationMaintenancePercent()) / 100;

			iCommerce += 100 * kCorporation.getCommerceChange(i);
			iCommerce *= (GET_TEAM(pCity->getTeam()).getCorporationRevenueModifier() + 100);
			iCommerce /= 100;
			if (i == COMMERCE_GOLD)
			{
				iMaintenance += pCity->calculateCorporationMaintenanceTimes100(eCorporation);
				iMaintenance = getModifiedIntValue(iMaintenance, pCity->getMaintenanceModifier());

				iCommerce -= iMaintenance;
			}
		}

		if (iCommerce != 0)
		{
			if (bHandled)
			{
				szBuffer.append(L", ");
			}

			CvWString szTempBuffer;
			szTempBuffer.Format(L"%s%d%c", iCommerce > 0 ? L"+" : L"", (iCommerce + 99) / 100, GC.getCommerceInfo((CommerceTypes)i).getChar());
			szBuffer.append(szTempBuffer);
			bHandled = true;
		}
	}

	if (bCityBar)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_CORPORATION_BONUS_REQUIRED"));
		bool bFirst = true;
		foreach_(const BonusTypes eBonus, kCorporation.getPrereqBonuses())
		{
			if (bFirst)
			{
				bFirst = false;
			}
			else
			{
				szBuffer.append(L", ");
			}

			szBuffer.append(CvWString::format(L"%c", GC.getBonusInfo(eBonus).getChar()));
		}

		if (bActive && bGenerates)
		{
			szBuffer.append(NEWLINE);
			if (kCorporation.getBonusProduced() != NO_BONUS)
			{
				szBuffer.append(gDLL->getText("TXT_KEY_CORPORATION_BONUS_PRODUCED", GC.getBonusInfo((BonusTypes)kCorporation.getBonusProduced()).getChar()));
			}
			else
			{
				szBuffer.append(gDLL->getText("TXT_KEY_CORPORATION_BONUS_GENERATES"));
			}
			if (kCorporation.getHappiness() != 0)
			{
				szBuffer.append(CvWString::format(L"%c", ((kCorporation.getHappiness() > 0) ? gDLL->getSymbolID(HAPPY_CHAR): gDLL->getSymbolID(UNHAPPY_CHAR))));
			}
			if (kCorporation.getHealth() != 0)
			{
				szBuffer.append(CvWString::format(L"%c", ((kCorporation.getHealth() > 0) ? gDLL->getSymbolID(HEALTHY_CHAR): gDLL->getSymbolID(UNHEALTHY_CHAR))));
			}
		}

	}
	else
	{
		if (bGenerates)
		{
			if (bActive)
			{
				if (bHandled)
				{
					szBuffer.append(L", ");
				}
				if (kCorporation.getBonusProduced() != NO_BONUS)
				{
					szBuffer.append(CvWString::format(L"%c", GC.getBonusInfo((BonusTypes)kCorporation.getBonusProduced()).getChar()));
				}
				if (kCorporation.getHappiness() != 0)
				{
					szBuffer.append(CvWString::format(L"%c", ((kCorporation.getHappiness() > 0) ? gDLL->getSymbolID(HAPPY_CHAR): gDLL->getSymbolID(UNHAPPY_CHAR))));
				}
				if (kCorporation.getHealth() != 0)
				{
					szBuffer.append(CvWString::format(L"%c", ((kCorporation.getHealth() > 0) ? gDLL->getSymbolID(HEALTHY_CHAR): gDLL->getSymbolID(UNHEALTHY_CHAR))));
				}
			}
		}
	}
}

void CvGameTextMgr::buildObsoleteString(CvWStringBuffer &szBuffer, int iItem, bool bList, bool bPlayerContext)
{
	CvWString szTempBuffer;

	if (bList)
	{
		szBuffer.append(NEWLINE);
	}
	szBuffer.append(gDLL->getText("TXT_KEY_TECHHELP_OBSOLETES", CvWString(GC.getBuildingInfo((BuildingTypes)iItem).getType()).c_str(), GC.getBuildingInfo((BuildingTypes) iItem).getTextKeyWide()));
}

void CvGameTextMgr::buildObsoleteBonusString(CvWStringBuffer &szBuffer, int iItem, bool bList, bool bPlayerContext)
{
	CvWString szTempBuffer;

	if (bList)
	{
		szBuffer.append(NEWLINE);
	}
	szBuffer.append(gDLL->getText("TXT_KEY_TECHHELP_OBSOLETES", CvWString(GC.getBonusInfo((BonusTypes)iItem).getType()).GetCString(), GC.getBonusInfo((BonusTypes) iItem).getTextKeyWide()));
}

void CvGameTextMgr::buildObsoleteSpecialString(CvWStringBuffer &szBuffer, int iItem, bool bList, bool bPlayerContext)
{
	CvWString szTempBuffer;

	if (bList)
	{
		szBuffer.append(NEWLINE);
	}
	szBuffer.append(gDLL->getText("TXT_KEY_TECHHELP_OBSOLETES_NO_LINK", GC.getSpecialBuildingInfo((SpecialBuildingTypes) iItem).getTextKeyWide()));
}

void CvGameTextMgr::buildMoveString(CvWStringBuffer &szBuffer, TechTypes eTech, bool bList, bool bPlayerContext)
{
	PROFILE_EXTRA_FUNC();
	int iI;
	int iMoveDiff;

	for (iI = 0; iI < GC.getNumRouteInfos(); ++iI)
	{
		iMoveDiff = ((GC.getMOVE_DENOMINATOR() / std::max(1, (GC.getRouteInfo((RouteTypes) iI).getMovementCost() + ((bPlayerContext) ? GET_TEAM(GC.getGame().getActiveTeam()).getRouteChange((RouteTypes)iI) : 0)))) - (GC.getMOVE_DENOMINATOR() / std::max(1, (GC.getRouteInfo((RouteTypes) iI).getMovementCost() + ((bPlayerContext) ? GET_TEAM(GC.getGame().getActiveTeam()).getRouteChange((RouteTypes)iI) : 0) + GC.getRouteInfo((RouteTypes) iI).getTechMovementChange(eTech)))));

		if (iMoveDiff != 0)
		{
			if (bList)
			{
				szBuffer.append(NEWLINE);
			}
			szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_MOVEMENT", -(iMoveDiff), GC.getRouteInfo((RouteTypes) iI).getTextKeyWide()));
			bList = true;
		}
	}
}

void CvGameTextMgr::buildFreeUnitString(CvWStringBuffer &szBuffer, TechTypes eTech, bool bList, bool bPlayerContext)
{
	const UnitTypes eFreeUnit = (UnitTypes)GC.getTechInfo(eTech).getFirstFreeUnit();

	if (eFreeUnit != NO_UNIT && (!bPlayerContext || GC.getGame().countKnownTechNumTeams(eTech) == 0))
	{
		if (bList)
		{
			szBuffer.append(NEWLINE);
		}
		szBuffer.append(gDLL->getText("TXT_KEY_TECHHELP_FIRST_RECEIVES", CvWString(GC.getUnitInfo(eFreeUnit).getType()).GetCString(), GC.getUnitInfo(eFreeUnit).getTextKeyWide()));
	}
}

void CvGameTextMgr::buildFeatureProductionString(CvWStringBuffer &szBuffer, TechTypes eTech, bool bList, bool bPlayerContext)
{
	if (GC.getTechInfo(eTech).getFeatureProductionModifier() != 0)
	{
		if (bList)
		{
			szBuffer.append(NEWLINE);
		}
		szBuffer.append(gDLL->getText("TXT_KEY_FEATUREHELP_PRODUCTION_MODIFIER", GC.getTechInfo(eTech).getFeatureProductionModifier()));
	}
}

void CvGameTextMgr::buildWorkerRateString(CvWStringBuffer &szBuffer, TechTypes eTech, bool bList, bool bPlayerContext)
{
	if (GC.getTechInfo(eTech).getWorkerSpeedModifier() != 0)
	{
		if (bList)
		{
			szBuffer.append(NEWLINE);
		}
		szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_WORKERS_FASTER", GC.getTechInfo(eTech).getWorkerSpeedModifier()));
	}
}

void CvGameTextMgr::buildTradeRouteString(CvWStringBuffer &szBuffer, TechTypes eTech, bool bList, bool bPlayerContext)
{
	if (GC.getTechInfo(eTech).getTradeRoutes() != 0)
	{
		if (bList)
		{
			szBuffer.append(NEWLINE);
		}
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_TRADE_ROUTES", GC.getTechInfo(eTech).getTradeRoutes()));
	}
}

void CvGameTextMgr::buildHealthRateString(CvWStringBuffer &szBuffer, TechTypes eTech, bool bList, bool bPlayerContext)
{
	if (GC.getTechInfo(eTech).getHealth() != 0)
	{
		if (bList)
		{
			szBuffer.append(NEWLINE);
		}
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_HEALTH_ALL_CITIES", abs(GC.getTechInfo(eTech).getHealth()), ((GC.getTechInfo(eTech).getHealth() > 0) ? gDLL->getSymbolID(HEALTHY_CHAR): gDLL->getSymbolID(UNHEALTHY_CHAR))));
	}
}

//Team Project (1)
void CvGameTextMgr::buildSpecialistHealthString(CvWStringBuffer &szBuffer, TechTypes eTech, bool bList, bool bPlayerContext)
{
	PROFILE_EXTRA_FUNC();
	for (int iI = 0; iI < GC.getNumSpecialistInfos(); iI++)
	{
		const CvSpecialistInfo& kSpecialist = GC.getSpecialistInfo((SpecialistTypes)iI);
		const int iSpecialistHealth = kSpecialist.getTechHealth(eTech);

		if (iSpecialistHealth > 0)
		{
			if (bList)
			{
				szBuffer.append(NEWLINE);
			}
			szBuffer.append(gDLL->getText("TXT_KEY_TECHHELP_SPECIALIST_TECH_HEALTH_TYPE", kSpecialist.getTextKeyWide(), iSpecialistHealth, gDLL->getSymbolID(HEALTHY_CHAR)));
		}
		else if (iSpecialistHealth < 0)
		{
			if (bList)
			{
				szBuffer.append(NEWLINE);
			}
			szBuffer.append(gDLL->getText("TXT_KEY_TECHHELP_SPECIALIST_TECH_HEALTH_TYPE", kSpecialist.getTextKeyWide(), -iSpecialistHealth, gDLL->getSymbolID(UNHEALTHY_CHAR)));
		}
	}
}

void CvGameTextMgr::buildHappinessRateString(CvWStringBuffer &szBuffer, TechTypes eTech, bool bList, bool bPlayerContext)
{
	if (GC.getTechInfo(eTech).getHappiness() != 0)
	{
		if (bList)
		{
			szBuffer.append(NEWLINE);
		}
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_HAPPINESS_ALL_CITIES", abs(GC.getTechInfo(eTech).getHappiness()), ((GC.getTechInfo(eTech).getHappiness() > 0) ? gDLL->getSymbolID(HAPPY_CHAR): gDLL->getSymbolID(UNHAPPY_CHAR))));
	}
}

//Team Project (1)
void CvGameTextMgr::buildSpecialistHappinessString(CvWStringBuffer &szBuffer, TechTypes eTech, bool bList, bool bPlayerContext)
{
	PROFILE_EXTRA_FUNC();
	for (int iI = 0; iI < GC.getNumSpecialistInfos(); iI++)
	{
		const CvSpecialistInfo& kSpecialist = GC.getSpecialistInfo((SpecialistTypes)iI);
		const int iSpecialistHappiness = kSpecialist.getTechHappiness(eTech);
		if (iSpecialistHappiness > 0)
		{
			if (bList)
			{
				szBuffer.append(NEWLINE);
			}
			szBuffer.append(gDLL->getText("TXT_KEY_TECHHELP_SPECIALIST_TECH_HAPPINESS_TYPE", kSpecialist.getTextKeyWide(), iSpecialistHappiness, gDLL->getSymbolID(HAPPY_CHAR)));
		}
		else if (iSpecialistHappiness < 0)
		{
			if (bList)
			{
				szBuffer.append(NEWLINE);
			}
			szBuffer.append(gDLL->getText("TXT_KEY_TECHHELP_SPECIALIST_TECH_HAPPINESS_TYPE", kSpecialist.getTextKeyWide(), -iSpecialistHappiness, gDLL->getSymbolID(UNHAPPY_CHAR)));
		}
	}
}

void CvGameTextMgr::buildFreeTechString(CvWStringBuffer &szBuffer, TechTypes eTech, bool bList, bool bPlayerContext)
{
	if (GC.getTechInfo(eTech).getFirstFreeTechs() > 0)
	{
		if (!bPlayerContext || (GC.getGame().countKnownTechNumTeams(eTech) == 0))
		{
			if (bList)
			{
				szBuffer.append(NEWLINE);
			}

			if (GC.getTechInfo(eTech).getFirstFreeTechs() == 1)
			{
				szBuffer.append(gDLL->getText("TXT_KEY_TECHHELP_FIRST_FREE_TECH"));
			}
			else
			{
				szBuffer.append(gDLL->getText("TXT_KEY_TECHHELP_FIRST_FREE_TECHS", GC.getTechInfo(eTech).getFirstFreeTechs()));
			}
		}
	}
}

void CvGameTextMgr::buildLOSString(CvWStringBuffer &szBuffer, TechTypes eTech, bool bList, bool bPlayerContext)
{
	if (GC.getTechInfo(eTech).isExtraWaterSeeFrom() && (!bPlayerContext || !(GET_TEAM(GC.getGame().getActiveTeam()).isExtraWaterSeeFrom())))
	{
		if (bList)
		{
			szBuffer.append(NEWLINE);
		}
		szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_EXTRA_SIGHT"));
	}
}

void CvGameTextMgr::buildMapCenterString(CvWStringBuffer &szBuffer, TechTypes eTech, bool bList, bool bPlayerContext)
{
	if (GC.getTechInfo(eTech).isMapCentering() && (!bPlayerContext || !(GET_TEAM(GC.getGame().getActiveTeam()).isMapCentering())))
	{
		if (bList)
		{
			szBuffer.append(NEWLINE);
		}
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_CENTERS_MAP"));
	}
}

void CvGameTextMgr::buildMapRevealString(CvWStringBuffer &szBuffer, TechTypes eTech, bool bList)
{
	if (GC.getTechInfo(eTech).isMapVisible())
	{
		if (bList)
		{
			szBuffer.append(NEWLINE);
		}
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_REVEALS_MAP"));
	}
}

void CvGameTextMgr::buildMapTradeString(CvWStringBuffer &szBuffer, TechTypes eTech, bool bList, bool bPlayerContext)
{
	if (GC.getTechInfo(eTech).isMapTrading() && (!bPlayerContext || !(GET_TEAM(GC.getGame().getActiveTeam()).isMapTrading())))
	{
		if (bList)
		{
			szBuffer.append(NEWLINE);
		}
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_ENABLES_MAP_TRADING"));
	}
}

void CvGameTextMgr::buildTechTradeString(CvWStringBuffer &szBuffer, TechTypes eTech, bool bList, bool bPlayerContext)
{
	if (GC.getTechInfo(eTech).isTechTrading() && (!bPlayerContext || !(GET_TEAM(GC.getGame().getActiveTeam()).isTechTrading())))
	{
		if (bList)
		{
			szBuffer.append(NEWLINE);
		}
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_ENABLES_TECH_TRADING"));
	}
}

void CvGameTextMgr::buildGoldTradeString(CvWStringBuffer &szBuffer, TechTypes eTech, bool bList, bool bPlayerContext)
{
	if (GC.getTechInfo(eTech).isGoldTrading() && (!bPlayerContext || !(GET_TEAM(GC.getGame().getActiveTeam()).isGoldTrading())))
	{
		if (bList)
		{
			szBuffer.append(NEWLINE);
		}
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_ENABLES_GOLD_TRADING"));
	}
}

void CvGameTextMgr::buildOpenBordersString(CvWStringBuffer &szBuffer, TechTypes eTech, bool bList, bool bPlayerContext)
{
	if (GC.getTechInfo(eTech).isOpenBordersTrading() && (!bPlayerContext || !(GET_TEAM(GC.getGame().getActiveTeam()).isOpenBordersTrading())))
	{
		if (bList)
		{
			szBuffer.append(NEWLINE);
		}
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_ENABLES_OPEN_BORDERS"));
	}
}

void CvGameTextMgr::buildDefensivePactString(CvWStringBuffer &szBuffer, TechTypes eTech, bool bList, bool bPlayerContext)
{
	if (GC.getTechInfo(eTech).isDefensivePactTrading() && (!bPlayerContext || !(GET_TEAM(GC.getGame().getActiveTeam()).isDefensivePactTrading())))
	{
		if (bList)
		{
			szBuffer.append(NEWLINE);
		}
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_ENABLES_DEFENSIVE_PACTS"));
	}
}

void CvGameTextMgr::buildPermanentAllianceString(CvWStringBuffer &szBuffer, TechTypes eTech, bool bList, bool bPlayerContext)
{
	if (GC.getTechInfo(eTech).isPermanentAllianceTrading() && (!bPlayerContext || (!(GET_TEAM(GC.getGame().getActiveTeam()).isPermanentAllianceTrading()) && GC.getGame().isOption(GAMEOPTION_ENABLE_PERMANENT_ALLIANCES))))
	{
		if (bList)
		{
			szBuffer.append(NEWLINE);
		}
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_ENABLES_PERM_ALLIANCES"));
	}
}

void CvGameTextMgr::buildVassalStateString(CvWStringBuffer &szBuffer, TechTypes eTech, bool bList, bool bPlayerContext)
{
	if (GC.getTechInfo(eTech).isVassalStateTrading() && (!bPlayerContext || (!(GET_TEAM(GC.getGame().getActiveTeam()).isVassalStateTrading()) && GC.getGame().isOption(GAMEOPTION_NO_VASSAL_STATES))))
	{
		if (bList)
		{
			szBuffer.append(NEWLINE);
		}
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_ENABLES_VASSAL_STATES"));
	}
}


void CvGameTextMgr::buildEmbassyString(CvWStringBuffer &szBuffer, TechTypes eTech, bool bList, bool bPlayerContext)
{
	if (GC.getGame().isOption(GAMEOPTION_ADVANCED_DIPLOMACY))
	{
		if (GC.getTechInfo(eTech).isEmbassyTrading() && (!bPlayerContext || !(GET_TEAM(GC.getGame().getActiveTeam()).isEmbassyTrading())))
		{
			if (bList)
			{
				szBuffer.append(NEWLINE);
			}
			szBuffer.append(gDLL->getText("TXT_KEY_MISC_ENABLES_EMBASSIES"));
		}
	}
}


void CvGameTextMgr::buildBridgeString(CvWStringBuffer &szBuffer, TechTypes eTech, bool bList, bool bPlayerContext)
{
	if (GC.getTechInfo(eTech).isBridgeBuilding() && (!bPlayerContext || !(GET_TEAM(GC.getGame().getActiveTeam()).isBridgeBuilding())))
	{
		if (bList)
		{
			szBuffer.append(NEWLINE);
		}
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_ENABLES_BRIDGE_BUILDING"));
	}
}

void CvGameTextMgr::buildIrrigationString(CvWStringBuffer &szBuffer, TechTypes eTech, bool bList, bool bPlayerContext)
{
	if (GC.getTechInfo(eTech).isIrrigation() && (!bPlayerContext || !(GET_TEAM(GC.getGame().getActiveTeam()).isIrrigation())))
	{
		if (bList)
		{
			szBuffer.append(NEWLINE);
		}
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_SPREAD_IRRIGATION"));
	}
}

void CvGameTextMgr::buildIgnoreIrrigationString(CvWStringBuffer &szBuffer, TechTypes eTech, bool bList, bool bPlayerContext)
{
	if (GC.getTechInfo(eTech).isIgnoreIrrigation() && (!bPlayerContext || !(GET_TEAM(GC.getGame().getActiveTeam()).isIgnoreIrrigation())))
	{
		if (bList)
		{
			szBuffer.append(NEWLINE);
		}
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_IRRIGATION_ANYWHERE"));
	}
}

void CvGameTextMgr::buildWaterWorkString(CvWStringBuffer &szBuffer, TechTypes eTech, bool bList, bool bPlayerContext)
{
	if (GC.getTechInfo(eTech).isWaterWork() && (!bPlayerContext || !(GET_TEAM(GC.getGame().getActiveTeam()).isWaterWork())))
	{
		if (bList)
		{
			szBuffer.append(NEWLINE);
		}
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_WATER_WORK"));
	}
}

void CvGameTextMgr::buildImprovementString(CvWStringBuffer &szBuffer, TechTypes eTech, BuildTypes eBuild, bool bList, bool bPlayerContext)
{
	PROFILE_EXTRA_FUNC();
	const CvBuildInfo& kBuild = GC.getBuildInfo(eBuild);

	bool bTechFound = false;

	if (kBuild.getTechPrereq() == NO_TECH)
	{
		if (kBuild.getRoute() == NO_ROUTE || GC.getGame().isOption(GAMEOPTION_ADVANCED_ROUTES) || GC.getRouteInfo((RouteTypes)kBuild.getRoute()).isSeaTunnel())
		{
			foreach_(const TerrainStructs& kTerrainStruct, kBuild.getTerrainStructs())
			{
				if (kTerrainStruct.ePrereqTech == eTech)
				{
					bTechFound = true;
					break;
				}
			}
			if (!bTechFound)
			{
				for (int iJ = 0; iJ < GC.getNumFeatureInfos(); iJ++)
				{
					if (kBuild.getFeatureTech((FeatureTypes)iJ) == eTech)
					{
						bTechFound = true;
						break;
					}
				}
			}
		}
	}
	else if (kBuild.getTechPrereq() == eTech)
	{
		bTechFound = true;
	}

	if (bTechFound)
	{
		if (bList) szBuffer.append(NEWLINE);

		if (GC.getGame().getActiveTeam() != NO_TEAM)
		{
			if (kBuild.getObsoleteTech() != NO_TECH)
			{
				if (GET_TEAM(GC.getGame().getActiveTeam()).isHasTech(kBuild.getObsoleteTech()))
				{
					szBuffer.append(gDLL->getText("TXT_KEY_TECHHELP_OBSOLETES", CvWString(kBuild.getType()).c_str(), kBuild.getTextKeyWide()));
				}
				else szBuffer.append(gDLL->getText("TXT_KEY_MISC_CAN_BUILD_IMPROVEMENT", kBuild.getTextKeyWide()));
			}
			else szBuffer.append(gDLL->getText("TXT_KEY_MISC_CAN_BUILD_IMPROVEMENT", kBuild.getTextKeyWide()));
		}
		else szBuffer.append(gDLL->getText("TXT_KEY_MISC_CAN_BUILD_IMPROVEMENT", kBuild.getTextKeyWide()));
	}

	foreach_(const MapCategoryTypes eMapCategory, kBuild.getMapCategories())
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_MAP_CATEGORY_PREREQUISITE", GC.getMapCategoryInfo(eMapCategory).getTextKeyWide()));
	}
}


void CvGameTextMgr::buildDomainExtraMovesString(CvWStringBuffer &szBuffer, TechTypes eTech, int iDomainType, bool bList, bool bPlayerContext)
{
	if (GC.getTechInfo(eTech).getDomainExtraMoves(iDomainType) != 0)
	{
		if (bList) szBuffer.append(NEWLINE);

		if (iDomainType == DOMAIN_AIR)
		{
			szBuffer.append(gDLL->getText("TXT_KEY_MISC_EXTRA_RANGE", GC.getTechInfo(eTech).getDomainExtraMoves(iDomainType)));
		}
		else szBuffer.append(gDLL->getText("TXT_KEY_MISC_EXTRA_MOVES", GC.getTechInfo(eTech).getDomainExtraMoves(iDomainType), GC.getDomainInfo((DomainTypes)iDomainType).getTextKeyWide()));
	}
}


void CvGameTextMgr::buildAdjustString(CvWStringBuffer &szBuffer, TechTypes eTech, int iCommerceType, bool bList, bool bPlayerContext)
{
	if (GC.getTechInfo(eTech).isCommerceFlexible(iCommerceType) && (!bPlayerContext || !(GET_TEAM(GC.getGame().getActiveTeam()).isCommerceFlexible((CommerceTypes)iCommerceType))))
	{
		if (bList) szBuffer.append(NEWLINE);

		szBuffer.append(gDLL->getText("TXT_KEY_MISC_ADJUST_COMMERCE_RATE", GC.getCommerceInfo((CommerceTypes) iCommerceType).getChar()));
	}
}


void CvGameTextMgr::buildTerrainTradeString(CvWStringBuffer &szBuffer, TechTypes eTech, int iTerrainType, bool bList, bool bPlayerContext)
{
	if (GC.getTechInfo(eTech).isTerrainTrade(iTerrainType) && (!bPlayerContext || !(GET_TEAM(GC.getGame().getActiveTeam()).isTerrainTrade((TerrainTypes)iTerrainType))))
	{
		if (bList) szBuffer.append(NEWLINE);

		szBuffer.append(gDLL->getText("TXT_KEY_MISC_ENABLES_ON_TERRAIN", gDLL->getSymbolID(TRADE_CHAR), GC.getTerrainInfo((TerrainTypes) iTerrainType).getTextKeyWide()));
	}
}

void CvGameTextMgr::buildRiverTradeString(CvWStringBuffer &szBuffer, TechTypes eTech, bool bList, bool bPlayerContext)
{
	if (GC.getTechInfo(eTech).isRiverTrade() && (!bPlayerContext || !(GET_TEAM(GC.getGame().getActiveTeam()).isRiverTrade())))
	{
		if (bList) szBuffer.append(NEWLINE);

		szBuffer.append(gDLL->getText("TXT_KEY_MISC_ENABLES_ON_TERRAIN", gDLL->getSymbolID(TRADE_CHAR), gDLL->getText("TXT_KEY_MISC_RIVERS").GetCString()));
	}
}

void CvGameTextMgr::buildSpecialBuildingString(CvWStringBuffer &szBuffer, TechTypes eTech, int iBuildingType, bool bList, bool bPlayerContext)
{
	if (GC.getSpecialBuildingInfo((SpecialBuildingTypes)iBuildingType).getTechPrereq() == eTech)
	{
		if (bList) szBuffer.append(NEWLINE);

		szBuffer.append(gDLL->getText("TXT_KEY_MISC_CAN_CONSTRUCT_BUILDING", GC.getSpecialBuildingInfo((SpecialBuildingTypes) iBuildingType).getTextKeyWide()));
	}

	if (GC.getSpecialBuildingInfo((SpecialBuildingTypes)iBuildingType).getTechPrereqAnyone() == eTech)
	{
		if (bList) szBuffer.append(NEWLINE);

		szBuffer.append(
			gDLL->getText(
				"TXT_KEY_MISC_CAN_CONSTRUCT_BUILDING_ANYONE",
				CvWString(GC.getSpecialBuildingInfo((SpecialBuildingTypes)iBuildingType).getType()).GetCString(),
				GC.getSpecialBuildingInfo((SpecialBuildingTypes) iBuildingType).getTextKeyWide()
			)
		);
	}
}

void CvGameTextMgr::buildYieldChangeString(CvWStringBuffer &szBuffer, TechTypes eTech, int iYieldType, bool bList, bool bPlayerContext)
{
	CvWString szTempBuffer;
	if (bList)
	{
		szTempBuffer.Format(L"<link=%s>%s</link>", CvWString(GC.getImprovementInfo((ImprovementTypes)iYieldType).getType()).GetCString(), GC.getImprovementInfo((ImprovementTypes)iYieldType).getDescription());
	}
	else
	{
		szTempBuffer.Format(L"%c<link=%s>%s</link>", gDLL->getSymbolID(BULLET_CHAR), CvWString(GC.getImprovementInfo((ImprovementTypes)iYieldType).getType()).GetCString(), GC.getImprovementInfo((ImprovementTypes)iYieldType).getDescription());
	}

	setYieldChangeHelp(szBuffer, szTempBuffer, L": ", L"", GC.getImprovementInfo((ImprovementTypes)iYieldType).getTechYieldChangesArray(eTech), false, bList);
}


void CvGameTextMgr::buildBuildingTechSpecialistChangeString(CvWStringBuffer &szBuffer, TechTypes eTech, int iBuildingType, bool bList, bool bPlayerContext)
{
	PROFILE_EXTRA_FUNC();
	CvWString szTempBuffer;
	for (int iSpecialist = 0; iSpecialist < GC.getNumSpecialistInfos(); iSpecialist++)
	{
		int iChange = GC.getBuildingInfo((BuildingTypes)iBuildingType).getTechSpecialistChange(eTech, iSpecialist);
		if (0 != iChange)
		{
			szBuffer.append(NEWLINE);
			if (bList)
			{
				szTempBuffer.Format(L"%c<link=%s>%s</link>: ", gDLL->getSymbolID(BULLET_CHAR), CvWString(GC.getBuildingInfo((BuildingTypes)iBuildingType).getType()).GetCString(), GC.getBuildingInfo((BuildingTypes)iBuildingType).getDescription());
			}
			else
			{
				szTempBuffer.Format(L"<link=%s>%s</link>: ", CvWString(GC.getBuildingInfo((BuildingTypes)iBuildingType).getType()).GetCString(), GC.getBuildingInfo((BuildingTypes)iBuildingType).getDescription());
			}
			szBuffer.append(szTempBuffer);
			if (iChange == 1)
			{
				szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_TURN_CITIZEN_INTO_NO_BULLET", CvWString(GC.getSpecialistInfo((SpecialistTypes) iSpecialist).getType()).GetCString(), GC.getSpecialistInfo((SpecialistTypes) iSpecialist).getTextKeyWide()));
			}
			else
			{
				szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_TURN_CITIZENS_INTO_NO_BULLET", iChange, CvWString(GC.getSpecialistInfo((SpecialistTypes)iSpecialist).getType()).GetCString(), GC.getSpecialistInfo((SpecialistTypes) iSpecialist).getTextKeyWide()));
			}
		}
	}
}


void CvGameTextMgr::buildBuildingTechHappinessChangesString(CvWStringBuffer &szBuffer, TechTypes eTech, int iBuildingType, bool bList, bool bPlayerContext)
{
	CvWString szTempBuffer;
	CvWString szFirstBuffer;
	if (GC.getBuildingInfo((BuildingTypes)iBuildingType).getTechHappiness(eTech) != 0)
	{
		szTempBuffer.Format(L"%s%c+%d%c%s<link=%s>%s</link>", NEWLINE, gDLL->getSymbolID(BULLET_CHAR), abs(GC.getBuildingInfo((BuildingTypes)iBuildingType).getTechHappiness(eTech)), (((GC.getBuildingInfo((BuildingTypes)iBuildingType).getTechHappiness(eTech) > 0) ? gDLL->getSymbolID(HAPPY_CHAR): gDLL->getSymbolID(UNHAPPY_CHAR))), gDLL->getText("TXT_KEY_WITH").GetCString(), CvWString(GC.getBuildingInfo((BuildingTypes)iBuildingType).getType()).GetCString(), GC.getBuildingInfo((BuildingTypes)iBuildingType).getDescription());
		setListHelp(szBuffer, szFirstBuffer, szTempBuffer, L", ", true);
	}
}

void CvGameTextMgr::buildBuildingTechHealthChangesString(CvWStringBuffer &szBuffer, TechTypes eTech, int iBuildingType, bool bList, bool bPlayerContext)
{
	CvWString szTempBuffer;
	CvWString szFirstBuffer;
	if (GC.getBuildingInfo((BuildingTypes)iBuildingType).getTechHealth(eTech) != 0)
	{
		szTempBuffer.Format(L"%s%c+%d%c%s<link=%s>%s</link>", NEWLINE, gDLL->getSymbolID(BULLET_CHAR), abs(GC.getBuildingInfo((BuildingTypes)iBuildingType).getTechHealth(eTech)), (((GC.getBuildingInfo((BuildingTypes)iBuildingType).getTechHealth(eTech) > 0) ? gDLL->getSymbolID(HEALTHY_CHAR): gDLL->getSymbolID(UNHEALTHY_CHAR))), gDLL->getText("TXT_KEY_WITH").GetCString(), CvWString(GC.getBuildingInfo((BuildingTypes)iBuildingType).getType()).GetCString(), GC.getBuildingInfo((BuildingTypes)iBuildingType).getDescription());
		setListHelp(szBuffer, szFirstBuffer, szTempBuffer, L", ", true);
	}
}


bool CvGameTextMgr::buildBonusRevealString(CvWStringBuffer &szBuffer, TechTypes eTech, int iBonusType, bool bFirst, bool bList, bool bPlayerContext)
{
	CvWString szTempBuffer;

	if (GC.getBonusInfo((BonusTypes) iBonusType).getTechReveal() == eTech)
	{
		if (bList && bFirst)
		{
			szBuffer.append(NEWLINE);
		}
		szTempBuffer.Format( SETCOLR L"<link=%s>%s</link>" ENDCOLR , TEXT_COLOR("COLOR_HIGHLIGHT_TEXT"), CvWString(GC.getBonusInfo((BonusTypes) iBonusType).getType()).GetCString(), GC.getBonusInfo((BonusTypes) iBonusType).getDescription());
		setListHelp(szBuffer, gDLL->getText("TXT_KEY_MISC_REVEALS").c_str(), szTempBuffer, L", ", bFirst);
		bFirst = false;
	}
	return bFirst;
}

bool CvGameTextMgr::buildCivicRevealString(CvWStringBuffer &szBuffer, TechTypes eTech, int iCivicType, bool bFirst, bool bList, bool bPlayerContext)
{
	CvWString szTempBuffer;

	if (GC.getCivicInfo((CivicTypes) iCivicType).getTechPrereq() == eTech)
	{
		if (bList && bFirst)
		{
			szBuffer.append(NEWLINE);
		}
		szTempBuffer.Format( SETCOLR L"<link=%s>%s</link>" ENDCOLR , TEXT_COLOR("COLOR_HIGHLIGHT_TEXT"), CvWString(GC.getCivicInfo((CivicTypes) iCivicType).getType()).GetCString(), GC.getCivicInfo((CivicTypes) iCivicType).getDescription());
		setListHelp(szBuffer, gDLL->getText("TXT_KEY_MISC_ENABLES").c_str(), szTempBuffer, L", ", bFirst);
		bFirst = false;
	}
	return bFirst;
}

bool CvGameTextMgr::buildProcessInfoString(CvWStringBuffer &szBuffer, TechTypes eTech, int iProcessType, bool bFirst, bool bList, bool bPlayerContext)
{
	CvWString szTempBuffer;

	if (GC.getProcessInfo((ProcessTypes) iProcessType).getTechPrereq() == eTech)
	{
		if (bList && bFirst)
		{
			szBuffer.append(NEWLINE);
		}
		szTempBuffer.Format( SETCOLR L"<link=%s>%s</link>" ENDCOLR , TEXT_COLOR("COLOR_HIGHLIGHT_TEXT"), CvWString(GC.getProcessInfo((ProcessTypes) iProcessType).getType()).GetCString(), GC.getProcessInfo((ProcessTypes) iProcessType).getDescription());
		setListHelp(szBuffer, gDLL->getText("TXT_KEY_MISC_CAN_BUILD").c_str(), szTempBuffer, L", ", bFirst);
		bFirst = false;
	}
	return bFirst;
}

bool CvGameTextMgr::buildFoundReligionString(CvWStringBuffer &szBuffer, TechTypes eTech, int iReligionType, bool bFirst, bool bList, bool bPlayerContext)
{
	CvWString szTempBuffer;

	if (GC.getReligionInfo((ReligionTypes) iReligionType).getTechPrereq() == eTech)
	{
/************************************************************************************************/
/* REVDCM								 04/29/10								phungus420	*/
/*																							  */
/* Player Functions																			 */
/************************************************************************************************/
		if (!bPlayerContext ||
		(!(GC.getGame().isReligionSlotTaken((ReligionTypes)iReligionType))
		&& GET_PLAYER(GC.getGame().getActivePlayer()).canFoundReligion()) )
/************************************************************************************************/
/* LIMITED_RELIGIONS			   END														  */
/************************************************************************************************/
		{
			if (bList && bFirst)
			{
				szBuffer.append(NEWLINE);
			}

			if (GC.getGame().isOption(GAMEOPTION_RELIGION_PICK))
			{
				szTempBuffer = gDLL->getText("TXT_KEY_RELIGION_UNKNOWN");
			}
			else
			{
				szTempBuffer.Format( SETCOLR L"<link=%s>%s</link>" ENDCOLR , TEXT_COLOR("COLOR_HIGHLIGHT_TEXT"), CvWString(GC.getReligionInfo((ReligionTypes) iReligionType).getType()).GetCString(), GC.getReligionInfo((ReligionTypes) iReligionType).getDescription());
			}
			setListHelp(szBuffer, gDLL->getText("TXT_KEY_MISC_FIRST_DISCOVER_FOUNDS").c_str(), szTempBuffer, L", ", bFirst);
			bFirst = false;
		}
	}
	return bFirst;
}

bool CvGameTextMgr::buildFoundCorporationString(CvWStringBuffer &szBuffer, TechTypes eTech, int iCorporationType, bool bFirst, bool bList, bool bPlayerContext)
{
	CvWString szTempBuffer;

	if (GC.getCorporationInfo((CorporationTypes) iCorporationType).getTechPrereq() == eTech)
	{
		if (!bPlayerContext || (GC.getGame().countKnownTechNumTeams(eTech) == 0))
		{
			if (bList && bFirst)
			{
				szBuffer.append(NEWLINE);
			}
			szTempBuffer.Format( SETCOLR L"<link=%s>%s</link>" ENDCOLR , TEXT_COLOR("COLOR_HIGHLIGHT_TEXT"), CvWString(GC.getCorporationInfo((CorporationTypes) iCorporationType).getType()).GetCString(), GC.getCorporationInfo((CorporationTypes) iCorporationType).getDescription());
			setListHelp(szBuffer, gDLL->getText("TXT_KEY_MISC_FIRST_DISCOVER_INCORPORATES").c_str(), szTempBuffer, L", ", bFirst);
			bFirst = false;
		}
	}
	return bFirst;
}

bool CvGameTextMgr::buildPromotionString(CvWStringBuffer &szBuffer, TechTypes eTech, int iPromotionType, bool bFirst, bool bList) const
{
	CvWString szTempBuffer;

	if (GC.getPromotionInfo((PromotionTypes) iPromotionType).getTechPrereq() == eTech)
	{
		if (bList && bFirst)
		{
			szBuffer.append(NEWLINE);
		}
		szTempBuffer.Format( SETCOLR L"<link=%s>%s</link>" ENDCOLR , TEXT_COLOR("COLOR_HIGHLIGHT_TEXT"), CvWString(GC.getPromotionInfo((PromotionTypes) iPromotionType).getType()).GetCString(), GC.getPromotionInfo((PromotionTypes) iPromotionType).getDescription());
		setListHelp(szBuffer, gDLL->getText("TXT_KEY_MISC_ENABLES").c_str(), szTempBuffer, L", ", bFirst);
		bFirst = false;
	}
	return bFirst;
}

// Displays a list of derived technologies - no distinction between AND/OR prerequisites
void CvGameTextMgr::buildSingleLineTechTreeString(CvWStringBuffer &szBuffer, TechTypes eTech, bool bPlayerContext)
{
	PROFILE_EXTRA_FUNC();
	CvWString szTempBuffer;	// Formatting

	if (NO_TECH == eTech)
	{
		// you need to specify a tech of origin for this method to do anything
		return;
	}

	bool bFirst = true;
	for (int iI = 0; iI < GC.getNumTechInfos(); ++iI)
	{
		bool bTechAlreadyAccessible = false;
		if (bPlayerContext)
		{
			bTechAlreadyAccessible = (GET_TEAM(GC.getGame().getActiveTeam()).isHasTech((TechTypes)iI) || GET_PLAYER(GC.getGame().getActivePlayer()).canResearch((TechTypes)iI));
		}
		if (!bTechAlreadyAccessible)
		{
			if (algo::any_of_equal(GC.getTechInfo((TechTypes)iI).getPrereqOrTechs(), eTech)
			||  algo::any_of_equal(GC.getTechInfo((TechTypes)iI).getPrereqAndTechs(), eTech))
			{
				szTempBuffer.Format( SETCOLR L"<link=%s>%s</link>" ENDCOLR , TEXT_COLOR("COLOR_TECH_TEXT"), CvWString(GC.getTechInfo((TechTypes)iI).getType()).GetCString(), GC.getTechInfo((TechTypes) iI).getDescription());
				setListHelp(szBuffer, gDLL->getText("TXT_KEY_MISC_LEADS_TO").c_str(), szTempBuffer, L", ", bFirst);
				bFirst = false;
			}
		}
	}
}

// Information about other prerequisite technologies to eTech besides eFromTech
void CvGameTextMgr::buildTechTreeString(CvWStringBuffer &szBuffer, TechTypes eTech, bool bPlayerContext, TechTypes eFromTech)
{
	PROFILE_EXTRA_FUNC();
	CvWString szTempBuffer;	// Formatting

	if (NO_TECH == eTech || NO_TECH == eFromTech)
	{
		return;
	}

	szTempBuffer.Format(SETCOLR L"%s" ENDCOLR, TEXT_COLOR("COLOR_TECH_TEXT"), GC.getTechInfo(eTech).getDescription());
	szBuffer.append(szTempBuffer);

	// Loop through OR prerequisites to make list
	CvWString szOtherOrTechs;
	int nOtherOrTechs = 0;
	bool bOrTechFound = false;
	foreach_(const TechTypes eTestTech, GC.getTechInfo(eTech).getPrereqOrTechs())
	{
		bool bTechAlreadyResearched = false;
		if (bPlayerContext)
		{
			bTechAlreadyResearched = GET_TEAM(GC.getGame().getActiveTeam()).isHasTech(eTestTech);
		}
		if (!bTechAlreadyResearched)
		{
			if (eTestTech == eFromTech)
			{
				bOrTechFound = true;
			}
			else
			{
				szTempBuffer.Format( SETCOLR L"%s" ENDCOLR , TEXT_COLOR("COLOR_TECH_TEXT"), GC.getTechInfo(eTestTech).getDescription());
				setListHelp(szOtherOrTechs, L"", szTempBuffer, gDLL->getText("TXT_KEY_OR").c_str(), 0 == nOtherOrTechs);
				nOtherOrTechs++;
			}
		}
	}

	// Loop through AND prerequisites to make list
	CvWString szOtherAndTechs;
	int nOtherAndTechs = 0;
	bool bAndTechFound = false;
	foreach_(const TechTypes eTestTech, GC.getTechInfo(eTech).getPrereqAndTechs())
	{
		bool bTechAlreadyResearched = false;
		if (bPlayerContext)
		{
			bTechAlreadyResearched = GET_TEAM(GC.getGame().getActiveTeam()).isHasTech(eTestTech);
		}
		if (!bTechAlreadyResearched)
		{
			if (eTestTech == eFromTech)
			{
				bAndTechFound = true;
			}
			else
			{
				szTempBuffer.Format( SETCOLR L"%s" ENDCOLR , TEXT_COLOR("COLOR_TECH_TEXT"), GC.getTechInfo(eTestTech).getDescription());
				setListHelp(szOtherAndTechs, L"", szTempBuffer, L", ", 0 == nOtherAndTechs);
				nOtherAndTechs++;
			}
		}
	}

	if (bOrTechFound || bAndTechFound)
	{
		if (nOtherAndTechs > 0 || nOtherOrTechs > 0)
		{
			szBuffer.append(L' ');

			if (nOtherAndTechs > 0)
			{
				szBuffer.append(gDLL->getText("TXT_KEY_WITH"));
				szBuffer.append(szOtherAndTechs);
			}

			if (nOtherOrTechs > 0)
			{
				if (bAndTechFound)
				{
					if (nOtherAndTechs > 0)
					{
						szBuffer.append(gDLL->getText("TXT_KEY_AND_SPACE"));
					}
					else
					{
						szBuffer.append(gDLL->getText("TXT_KEY_WITH"));
					}
					szBuffer.append(szOtherOrTechs);
				}
				else if (bOrTechFound)
				{
					szBuffer.append(NEWLINE);
					szBuffer.append(gDLL->getText("TXT_KEY_MISC_ALTERNATIVELY_DERIVED", GC.getTechInfo(eTech).getTextKeyWide(), szOtherOrTechs.GetCString()));
				}
			}
		}
	}
}

void CvGameTextMgr::setPromotionHelp(CvWStringBuffer &szBuffer, PromotionTypes ePromotion, bool bCivilopediaBodyText)
{
	CvUnit*	pUnit = gDLL->getInterfaceIFace()->getHeadSelectedUnit();

	// Hide overridden promotions if there is a selected unit and this is not a pedia request
	if (GC.getIsInPedia() || !pUnit || !pUnit->isPromotionOverriden(ePromotion))
	{
		if (!bCivilopediaBodyText)
		{
			if (NO_PROMOTION == ePromotion)
			{
				return;
			}
			CvWString szTempBuffer;
			szTempBuffer.Format( SETCOLR L"%s" ENDCOLR , TEXT_COLOR("COLOR_HIGHLIGHT_TEXT"), GC.getPromotionInfo(ePromotion).getDescription());
			szBuffer.append(szTempBuffer);
		}
		parsePromotionHelpInternal(szBuffer, ePromotion, NEWLINE, !GC.getIsInPedia());
	}
}

void CvGameTextMgr::setBuildUpHelp(CvWStringBuffer &szBuffer, PromotionLineTypes ePromotionLine)
{
	CivilizationTypes eCivilization;

	if (GC.getGame().getActivePlayer() != NO_PLAYER)
	{
		eCivilization = GET_PLAYER(GC.getGame().getActivePlayer()).getCivilizationType();
	}
	else
	{
		eCivilization = NO_CIVILIZATION;
	}

	if (NO_PROMOTIONLINE == ePromotionLine)
	{
		return;
	}
	parseBuildUp(szBuffer, ePromotionLine, eCivilization);
}

void CvGameTextMgr::setTraitHelp(CvWStringBuffer &szBuffer, TraitTypes eTrait)
{
	if (NO_TRAIT == eTrait)
	{
		return;
	}
	parseTraits(szBuffer, eTrait, false, false);
}

void CvGameTextMgr::setUnitCombatHelp(CvWStringBuffer& szBuffer, UnitCombatTypes eUnitCombat, bool bCivilopediaText) const
{
	PROFILE_EXTRA_FUNC();
	const CvUnitCombatInfo& info = GC.getUnitCombatInfo(eUnitCombat);

	if (!bCivilopediaText)
	{
		szBuffer.append(info.getDescription());
	}

	if (info.getExcileChange() > 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_EXCILE_ADD"));
	}
	if (info.getExcileChange() < 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_EXCILE_REMOVE"));
	}

	if (info.getPassageChange() > 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_PASSAGE_ADD"));
	}
	if (info.getPassageChange() < 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_PASSAGE_REMOVE"));
	}

	if (info.getNoNonOwnedCityEntryChange() > 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_NONONOWNED_ADD"));
	}
	if (info.getNoNonOwnedCityEntryChange() < 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_NONONOWNED_REMOVE"));
	}

	if (info.getBarbCoExistChange() > 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_BARBCOEXIST_ADD"));
	}
	if (info.getBarbCoExistChange() < 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_BARBCOEXIST_REMOVE"));
	}

	if (info.getBlendIntoCityChange() > 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_BLENDCITY_ADD"));
	}
	if (info.getBlendIntoCityChange() < 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_BLENDCITY_REMOVE"));
	}

	// integers
	if (info.isAlwaysInvisible())
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_INVISIBLE_ALL"));
	}
	if (info.getVisibilityChange() != 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_IMPROVEMENTHELP_VISIBILITY_RANGE", info.getVisibilityChange()));
	}

	if (GC.getGame().isOption(GAMEOPTION_COMBAT_HIDE_SEEK))
	{
		bool bFirst = true;

		for (int iJ = 0; iJ < GC.getNumInvisibleInfos(); iJ++)
		{
			const int iSpotIntensity = info.getVisibilityIntensityChangeType((InvisibleTypes)iJ);
			if (iSpotIntensity != 0)
			{
				if (bFirst)
				{
					szBuffer.append(NEWLINE);
					szBuffer.append(gDLL->getText("TXT_BULLET_S1_COLON_SPACE", L"TXT_WORD_SPOT"));
					bFirst = false;
				}
				else
				{
					szBuffer.append(L", ");
				}
				szBuffer.append(CvWString::format(L"%d%c", iSpotIntensity, GC.getInvisibleInfo((InvisibleTypes) iJ).getChar()));
			}
		}
		for (int iI = 0; iI < GC.getNumInvisibleInfos(); iI++)
		{
			if (info.getVisibilityIntensityRangeChangeType((InvisibleTypes)iI) != 0)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_PROMOHELP_INVISIBILITY_SPOT_RANGE_CHANGE", info.getVisibilityIntensityRangeChangeType((InvisibleTypes)iI), GC.getInvisibleInfo((InvisibleTypes)iI).getChar()));
			}
		}
		for (int iI = 0; iI < GC.getNumInvisibleInfos(); iI++)
		{
			if (info.getVisibilityIntensitySameTileChangeType((InvisibleTypes)iI) != 0)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_PROMOHELP_INVISIBILITY_SPOT_SAME_TILE_CHANGE", info.getVisibilityIntensitySameTileChangeType((InvisibleTypes)iI), GC.getInvisibleInfo((InvisibleTypes)iI).getChar()));
			}
		}
		for (int iI = 0; iI < GC.getNumInvisibleInfos(); iI++)
		{
			if (info.getInvisibilityIntensityChangeType((InvisibleTypes)iI) != 0)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_PROMOHELP_INVISIBILITY_VEIL_INTENSITY_CHANGE", info.getInvisibilityIntensityChangeType((InvisibleTypes)iI), GC.getInvisibleInfo((InvisibleTypes)iI).getChar()));
			}
		}
		for (int iI = 0; iI < info.getNumInvisibleTerrainChanges(); iI++)
		{
			InvisibleTypes eInvisible = info.getInvisibleTerrainChange(iI).eInvisible;
			TerrainTypes eTerrain = info.getInvisibleTerrainChange(iI).eTerrain;
			const int iIntensity = info.getInvisibleTerrainChange(iI).iIntensity;
			if (iIntensity != 0)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_PROMOHELP_INVISIBILITY_VEIL_PLOT_CHANGE", iIntensity, GC.getInvisibleInfo(eInvisible).getChar(), GC.getTerrainInfo(eTerrain).getTextKeyWide()));
			}
		}
		for (int iI = 0; iI < info.getNumInvisibleFeatureChanges(); iI++)
		{
			InvisibleTypes eInvisible = info.getInvisibleFeatureChange(iI).eInvisible;
			FeatureTypes eFeature = info.getInvisibleFeatureChange(iI).eFeature;
			const int iIntensity = info.getInvisibleFeatureChange(iI).iIntensity;
			if (iIntensity != 0)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_PROMOHELP_INVISIBILITY_VEIL_PLOT_CHANGE", iIntensity, GC.getInvisibleInfo(eInvisible).getChar(), GC.getFeatureInfo(eFeature).getTextKeyWide()));
			}
		}
		for (int iI = 0; iI < info.getNumInvisibleImprovementChanges(); iI++)
		{
			InvisibleTypes eInvisible = info.getInvisibleImprovementChange(iI).eInvisible;
			ImprovementTypes eImprovement = info.getInvisibleImprovementChange(iI).eImprovement;
			const int iIntensity = info.getInvisibleImprovementChange(iI).iIntensity;
			if (iIntensity != 0)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_PROMOHELP_INVISIBILITY_VEIL_PLOT_CHANGE", iIntensity, GC.getInvisibleInfo(eInvisible).getChar(), GC.getImprovementInfo(eImprovement).getTextKeyWide()));
			}
		}
		for (int iI = 0; iI < info.getNumVisibleTerrainChanges(); iI++)
		{
			InvisibleTypes eInvisible = info.getVisibleTerrainChange(iI).eInvisible;
			TerrainTypes eTerrain = info.getVisibleTerrainChange(iI).eTerrain;
			const int iIntensity = info.getVisibleTerrainChange(iI).iIntensity;
			if (iIntensity != 0)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_PROMOHELP_INVISIBILITY_SPOT_PLOT_CHANGE", iIntensity, GC.getInvisibleInfo(eInvisible).getChar(), GC.getTerrainInfo(eTerrain).getTextKeyWide()));
			}
		}
		for (int iI = 0; iI < info.getNumVisibleFeatureChanges(); iI++)
		{
			InvisibleTypes eInvisible = info.getVisibleFeatureChange(iI).eInvisible;
			FeatureTypes eFeature = info.getVisibleFeatureChange(iI).eFeature;
			const int iIntensity = info.getVisibleFeatureChange(iI).iIntensity;
			if (iIntensity != 0)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_PROMOHELP_INVISIBILITY_SPOT_PLOT_CHANGE", iIntensity, GC.getInvisibleInfo(eInvisible).getChar(), GC.getFeatureInfo(eFeature).getTextKeyWide()));
			}
		}
		for (int iI = 0; iI < info.getNumVisibleImprovementChanges(); iI++)
		{
			InvisibleTypes eInvisible = info.getVisibleImprovementChange(iI).eInvisible;
			ImprovementTypes eImprovement = info.getVisibleImprovementChange(iI).eImprovement;
			const int iIntensity = info.getVisibleImprovementChange(iI).iIntensity;
			if (iIntensity != 0)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_PROMOHELP_INVISIBILITY_SPOT_PLOT_CHANGE", iIntensity, GC.getInvisibleInfo(eInvisible).getChar(), GC.getImprovementInfo(eImprovement).getTextKeyWide()));
			}
		}
		for (int iI = 0; iI < info.getNumVisibleTerrainRangeChanges(); iI++)
		{
			InvisibleTypes eInvisible = info.getVisibleTerrainRangeChange(iI).eInvisible;
			TerrainTypes eTerrain = info.getVisibleTerrainRangeChange(iI).eTerrain;
			const int iIntensity = info.getVisibleTerrainRangeChange(iI).iIntensity;
			if (iIntensity != 0)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_PROMOHELP_INVISIBILITY_SPOT_PLOT_RANGE_CHANGE", iIntensity, GC.getInvisibleInfo(eInvisible).getChar(), GC.getTerrainInfo(eTerrain).getTextKeyWide()));
			}
		}
		for (int iI = 0; iI < info.getNumVisibleFeatureRangeChanges(); iI++)
		{
			InvisibleTypes eInvisible = info.getVisibleFeatureRangeChange(iI).eInvisible;
			FeatureTypes eFeature = info.getVisibleFeatureRangeChange(iI).eFeature;
			const int iIntensity = info.getVisibleFeatureRangeChange(iI).iIntensity;
			if (iIntensity != 0)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_PROMOHELP_INVISIBILITY_SPOT_PLOT_RANGE_CHANGE", iIntensity, GC.getInvisibleInfo(eInvisible).getChar(), GC.getFeatureInfo(eFeature).getTextKeyWide()));
			}
		}
		for (int iI = 0; iI < info.getNumVisibleImprovementRangeChanges(); iI++)
		{
			InvisibleTypes eInvisible = info.getVisibleImprovementRangeChange(iI).eInvisible;
			ImprovementTypes eImprovement = info.getVisibleImprovementRangeChange(iI).eImprovement;
			const int iIntensity = info.getVisibleImprovementRangeChange(iI).iIntensity;
			if (iIntensity != 0)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_PROMOHELP_INVISIBILITY_SPOT_PLOT_RANGE_CHANGE", iIntensity, GC.getInvisibleInfo(eInvisible).getChar(), GC.getImprovementInfo(eImprovement).getTextKeyWide()));
			}
		}
	}
#ifdef OUTBREAKS_AND_AFFLICTIONS
	if (GC.getGame().isOption(GAMEOPTION_COMBAT_OUTBREAKS_AND_AFFLICTIONS))
	{
		for (int iI = 0; iI < GC.getNumPropertyInfos(); iI++)
		{
			if (info.getAidChange(iI) != 0)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_AID_CHANGE", info.getAidChange(iI), GC.getPropertyInfo((PropertyTypes)iI).getTextKeyWide()));
			}
		}
	}
#endif // OUTBREAKS_AND_AFFLICTIONS

	if (info.getMovesChange() != 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_MOVE", info.getMovesChange()));
	}

	if (info.getMoveDiscountChange() != 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_MOVE_DISCOUNT", info.getMoveDiscountChange()));
	}

	if (info.getAirRangeChange() != 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_AIR_RANGE", info.getAirRangeChange()));
	}

	if (info.getInterceptChange() != 0)
	{
		szBuffer.append(NEWLINE);

		if (info.isSpy())
		{
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_INTERCEPT_SPY", info.getInterceptChange()));
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_INTERCEPT_SPY_COUNTER", info.getInterceptChange() * 5));
		}
		else szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_INTERCEPT", info.getInterceptChange()));
	}

	if (info.getEvasionChange() != 0)
	{
		szBuffer.append(NEWLINE);

		if (info.isSpy())
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_EVASION_SPY", info.getEvasionChange()));
		else szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_EVASION", info.getEvasionChange()));
	}

	if (info.getWithdrawalChange() != 0)
	{
		szBuffer.append(NEWLINE);

		if (info.isSpy())
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_ESCAPE_SPY", info.getWithdrawalChange()));
		else szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_WITHDRAWAL", info.getWithdrawalChange()));
	}

	if (info.getCargoChange() != 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_CARGO", info.getCargoChange()));
	}

	if (info.getSMCargoChange() != 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_SM_CARGO", info.getSMCargoChange()));
	}

	if (info.getCollateralDamageChange() != 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_COLLATERAL_DAMAGE", info.getCollateralDamageChange()));
	}


	//Bombard
	if(GC.isDCM_RANGE_BOMBARD())
	{
		if (info.getDCMBombRangeBase() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_DCM_BOMB_RANGE", info.getDCMBombRangeBase()));
		}
		if (info.getDCMBombAccuracyBase() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_DCM_BOMB_ACCURACY", info.getDCMBombAccuracyBase()));
		}
		if (info.getRBombardDamageBase() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_DCM_BOMB_DAMAGE", info.getRBombardDamageBase()));
		}
		if (info.getRBombardDamageLimitBase() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_DCM_BOMB_DAMAGE_LIMIT", info.getRBombardDamageLimitBase()));
		}
		if (info.getRBombardDamageMaxUnitsBase() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_DCM_BOMB_DAMAGE_MAX_UNITS", info.getRBombardDamageMaxUnitsBase()));
		}
		if (info.isRBombardDirect() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_RANGED_BOMBARD_DIRECT"));
		}
	}

	if (info.getBombardRateChange() != 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_BOMBARD", info.getBombardRateChange()));
	}

	if (info.getFirstStrikesChange() != 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_FIRST_STRIKE", info.getFirstStrikesChange()));
	}

	if (info.getChanceFirstStrikesChange() != 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_FIRST_STRIKE_CHANCE", info.getChanceFirstStrikesChange()));
	}

	if (info.isNoSelfHeal())
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_SELF_HEAL_NONE"));
	}
	else if (info.getSelfHealModifier() != 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_SELF_HEAL", info.getSelfHealModifier()));
	}

	if (info.getEnemyHealChange() != 0)
	{
		szBuffer.append(NEWLINE);

		if (info.isSpy())
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_INSTIGATE_SPY", info.getEnemyHealChange()));
		else szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_HEALS_EXTRA", info.getEnemyHealChange()) + gDLL->getText("TXT_KEY_PROMOTIONHELP_ENEMY_LANDS"));
	}

	if (info.getNeutralHealChange() != 0)
	{
		szBuffer.append(NEWLINE);

		if (info.isSpy())
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_INSTIGATE2_SPY", info.getNeutralHealChange()));
		else szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_HEALS_EXTRA", info.getNeutralHealChange()) + gDLL->getText("TXT_KEY_PROMOTIONHELP_NEUTRAL_LANDS"));
	}

	if (info.getFriendlyHealChange() != 0)
	{
		szBuffer.append(NEWLINE);

		if (info.isSpy())
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_POISON_SPY", info.getFriendlyHealChange()));
		else szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_HEALS_EXTRA", info.getFriendlyHealChange()) + gDLL->getText("TXT_KEY_PROMOTIONHELP_FRIENDLY_LANDS"));
	}

	if (info.getNumHealSupport() != 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_HEAL_SUPPORT", info.getNumHealSupport()));
	}

	if (info.getSameTileHealChange() != 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_HEALS_SAME", info.getSameTileHealChange()) + gDLL->getText("TXT_KEY_PROMOTIONHELP_DAMAGE_TURN"));
	}

	if (info.getAdjacentTileHealChange() != 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_HEALS_ADJACENT", info.getAdjacentTileHealChange()) + gDLL->getText("TXT_KEY_PROMOTIONHELP_DAMAGE_TURN"));
	}

	if (info.getCombatPercent() != 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_STRENGTH", info.getCombatPercent()));
	}

	if (info.getCombatModifierPerSizeMoreChange() != 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_UNIT_COMBAT_MOD_PER_SIZE_MORE", info.getCombatModifierPerSizeMoreChange()));
	}

	if (info.getCombatModifierPerSizeLessChange() != 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_UNIT_COMBAT_MOD_PER_SIZE_LESS", info.getCombatModifierPerSizeLessChange()));
	}

	if (info.getCombatModifierPerVolumeMoreChange() != 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_UNIT_COMBAT_MOD_PER_VOLUME_MORE", info.getCombatModifierPerVolumeMoreChange()));
	}

	if (info.getCombatModifierPerVolumeLessChange() != 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_UNIT_COMBAT_MOD_PER_VOLUME_LESS", info.getCombatModifierPerVolumeLessChange()));
	}

	if (info.getCityAttackPercent() != 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_CITY_ATTACK", info.getCityAttackPercent()));
	}

	if (info.getCityDefensePercent() != 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_CITY_DEFENSE", info.getCityDefensePercent()));
	}

	if (info.getHillsAttackPercent() != 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_HILLS_ATTACK", info.getHillsAttackPercent()));
	}

	if (info.getHillsDefensePercent() != 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_HILLS_DEFENSE", info.getHillsDefensePercent()));
	}

	if (info.getHillsWorkPercent() != 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_HILLS_WORK", info.getHillsWorkPercent()));
	}

	if (info.getWorkRatePercent() != 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_WORK_RATE", info.getWorkRatePercent()));
	}

	if (info.getRevoltProtection() != 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_TEMP_REVOLT_PROTECTION", info.getRevoltProtection()));
	}

	if (info.getCollateralDamageProtection() != 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_COLLATERAL_PROTECTION", info.getCollateralDamageProtection()));
	}

	if (info.getPillageChange() != 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_PILLAGE_CHANGE", info.getPillageChange()));
	}

	if (info.getUpgradeDiscount() != 0)
	{
		szBuffer.append(NEWLINE);

		if (info.isSpy())
		{
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_UPGRADE_DISCOUNT_SPY", info.getUpgradeDiscount()));
		}
		else if (100 == info.getUpgradeDiscount())
		{
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_UPGRADE_DISCOUNT_FREE"));
		}
		else szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_UPGRADE_DISCOUNT", info.getUpgradeDiscount()));
	}

	if (info.getExperiencePercent() != 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_FASTER_EXPERIENCE", info.getExperiencePercent()));
	}

	if (info.getKamikazePercent() != 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_COMBAT_KAMIKAZE_MOD", -info.getKamikazePercent()));
	}

	if (info.getAirCombatLimitChange() != 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_AIR_LIMIT_CHANGE", info.getAirCombatLimitChange()));
	}

	if (info.getCelebrityHappy() != 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_CELEBRITY", info.getCelebrityHappy()));
	}

	if (info.getCollateralDamageLimitChange() != 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_COLLATERAL_LIMIT_CHANGE", info.getCollateralDamageLimitChange()));
	}

	if (info.getCollateralDamageMaxUnitsChange() != 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_MAX_UNITS_CHANGE", info.getCollateralDamageMaxUnitsChange()));
	}

	if (info.getCombatLimitChange() != 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_COMBAT_LIMIT", info.getCombatLimitChange()));
	}

	if (info.getExtraDropRange() != 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_EXTRA_DROP_RANGE", info.getExtraDropRange()));
	}

	if (info.getSurvivorChance() != 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_SURVIVOR", info.getSurvivorChance()));
	}

	if (info.getVictoryAdjacentHeal())
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_VICTORY_ADJACENT", info.getVictoryHeal(), info.getVictoryStackHeal(), info.getVictoryAdjacentHeal()));
	}

	if ((info.getVictoryHeal() != 0) && (info.getVictoryStackHeal() == 0))
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_VICTORY_HEAL", info.getVictoryHeal()));
	}

	if (info.getVictoryStackHeal() != 0 && info.getVictoryAdjacentHeal() == 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_VICTORY_STACK", info.getVictoryHeal(), info.getVictoryStackHeal()));
	}

	if (info.getAttackCombatModifierChange() != 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_ATTACK_MODIFIER", info.getAttackCombatModifierChange()));
	}

	if (info.getDefenseCombatModifierChange() != 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_DEFENSE_MODIFIER", info.getDefenseCombatModifierChange()));
	}

	if (info.getPursuitChange() != 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_PURSUIT", info.getPursuitChange()));
	}

	if (info.getEarlyWithdrawChange() != 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_EARLY_WITHDRAW", info.getEarlyWithdrawChange()));
	}

	if (info.getVSBarbsChange() != 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_VSBARBS", info.getVSBarbsChange()));
	}

	if (info.getReligiousCombatModifierChange() != 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_RELIGIOUS_COMBAT_MODIFIER_SHORT", info.getReligiousCombatModifierChange()));
	}

	if (info.getArmorChange() != 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_ARMOR", info.getArmorChange()));
	}

	if (info.getPunctureChange() != 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_PUNCTURE", info.getPunctureChange()));
	}

	if (info.getDamageModifierChange() != 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_DAMAGE_MODIFIER", info.getDamageModifierChange()));
	}

	if (info.getUpkeepModifier() != 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_HELPTEXT_UNIT_UPKEEP_MODIFIER_BASE", info.getUpkeepModifier()));
	}

	if (info.getExtraUpkeep100() != 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_HELPTEXT_UNIT_UPKEEP_EXTRA", CvWString::format(L"%.2f", info.getExtraUpkeep100() / 100.0).GetCString()));
	}

	if (info.getOverrunChange() != 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_OVERRUN", info.getOverrunChange()));
	}

	if (info.getRepelChange() != 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_REPEL", info.getRepelChange()));
	}

	if (info.getFortRepelChange() != 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_FORT_REPEL", info.getFortRepelChange()));
	}

	if (info.getRepelRetriesChange() != 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_REPEL_RETRIES", info.getRepelRetriesChange()));
	}

	if (info.getUnyieldingChange() != 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_UNYIELDING", info.getUnyieldingChange()));
	}

	if (info.getKnockbackChange() != 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_KNOCKBACK", info.getKnockbackChange()));
	}

	if (info.getKnockbackRetriesChange() != 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_KNOCKBACK_RETRIES", info.getKnockbackRetriesChange()));
	}
#ifdef BATTLEWORN
	if (info.getStrAdjperAttChange() > 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_RAMPAGE", info.getStrAdjperAttChange()));
	}

	if (info.getStrAdjperAttChange() < 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_TIRES", info.getStrAdjperAttChange()));
	}

	if (info.getStrAdjperDefChange() > 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_DETERMINATION", info.getStrAdjperDefChange()));
	}

	if (info.getStrAdjperDefChange() < 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_DEMORALIZATION", info.getStrAdjperDefChange()));
	}

	if (info.getWithdrawAdjperAttChange() > 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_REFLEXES", info.getWithdrawAdjperAttChange()));
	}

	if (info.getWithdrawAdjperAttChange() < 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_FRAYS", info.getWithdrawAdjperAttChange()));
	}
#endif // BATTLEWORN

	if (info.getUnnerveChange() != 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_UNNERVE", info.getUnnerveChange()));
	}

	if (info.getEncloseChange() != 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_ENCLOSE", info.getEncloseChange()));
	}

	if (info.getLungeChange() != 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_LUNGE", info.getLungeChange()));
	}

	if (info.getDynamicDefenseChange() != 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_DYNAMIC_DEFENSE", info.getDynamicDefenseChange()));
	}

	{
		const int iStrengthChange = info.getStrengthChange();

		if (iStrengthChange > 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_STRENGTHEN", iStrengthChange));
		}
		else if (iStrengthChange < 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_WEAKEN", iStrengthChange));
		}
	}

	if (info.getFortitudeChange() != 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_FORTITUDE_CHANGE", info.getFortitudeChange()));
	}

#ifdef STRENGTH_IN_NUMBERS
	if (GC.getGame().isOption(GAMEOPTION_COMBAT_STRENGTH_IN_NUMBERS))
	{
		if (info.getFrontSupportPercentChange() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_FRONT_SUPPORT_PERCENT_CHANGE", info.getFrontSupportPercentChange()));
		}

		if (info.getShortRangeSupportPercentChange() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_SHORT_RANGE_SUPPORT_PERCENT_CHANGE", info.getShortRangeSupportPercentChange()));
		}

		if (info.getMediumRangeSupportPercentChange() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_MEDIUM_RANGE_SUPPORT_PERCENT_CHANGE", info.getMediumRangeSupportPercentChange()));
		}

		if (info.getLongRangeSupportPercentChange() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_LONG_RANGE_SUPPORT_PERCENT_CHANGE", info.getLongRangeSupportPercentChange()));
		}

		if (info.getFlankSupportPercentChange() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_FLANK_SUPPORT_PERCENT_CHANGE", info.getFlankSupportPercentChange()));
		}
	}
#endif
	if (info.getDodgeModifierChange() != 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_DODGE_MODIFIER", info.getDodgeModifierChange()));
	}

	if (info.getPrecisionModifierChange() != 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_PRECISION_MODIFIER", info.getPrecisionModifierChange()));
	}

	if (info.getPowerShotsChange() != 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_POWER_SHOTS", info.getPowerShotsChange()));
	}

	if (info.getPowerShotCombatModifierChange() != 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_POWER_SHOT_COMBAT_MODIFIER", info.getPowerShotCombatModifierChange()));
	}

	if (info.getPowerShotPunctureModifierChange() != 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_POWER_SHOT_PUNCTURE_MODIFIER", info.getPowerShotPunctureModifierChange()));
	}

	if (info.getPowerShotPrecisionModifierChange() != 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_POWER_SHOT_PRECISION_MODIFIER", info.getPowerShotPrecisionModifierChange()));
	}

	if (info.getPowerShotCriticalModifierChange() != 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_POWER_SHOT_CRITICAL_MODIFIER", info.getPowerShotCriticalModifierChange()));
	}

	if (info.getCriticalModifierChange() != 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_CRITICAL_MODIFIER", info.getCriticalModifierChange()));
	}

	if (info.getEnduranceChange() != 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_ENDURANCE", info.getEnduranceChange()));
	}

	if (info.getRoundStunProbChange() != 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_ROUND_STUN_PROB", info.getRoundStunProbChange()));
	}

	if (info.getPoisonProbabilityModifierChange() != 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_POISON_PROB", info.getPoisonProbabilityModifierChange()));
	}

	if (info.getCaptureProbabilityModifierChange() != 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_CAPTURE_PROBABILITY_MODIFIER", info.getCaptureProbabilityModifierChange()));
	}

	if (info.getCaptureResistanceModifierChange() != 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_CAPTURE_RESISTANCE_MODIFIER", info.getCaptureResistanceModifierChange()));
	}

	if (info.getPeaksWorkPercent() != 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_PEAKS_WORK", info.getPeaksWorkPercent()));
	}

	if (info.getBreakdownChanceChange() != 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_BREAKDOWN_CHANCE", info.getBreakdownChanceChange()));
	}

	if (info.getBreakdownDamageChange() != 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_BREAKDOWN_DAMAGE", info.getBreakdownDamageChange()));
	}

	if (info.getTauntChange() != 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_TAUNT", info.getTauntChange()));
	}

	if (info.getMaxHPChange() != 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_MAX_HP", info.getMaxHPChange()));
	}

	if (info.getStrengthModifier() != 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_STRENGTH_MODIFIER", info.getStrengthModifier()));
	}

	if (GC.getGame().isOption(GAMEOPTION_COMBAT_WITHOUT_WARNING))
	{
		if (info.getStealthStrikesChange() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_STEALTH_STRIKES", info.getStealthStrikesChange()));
		}

		if (info.getStealthCombatModifierChange() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_STEALTH_COMBAT_MODIFIER", info.getStealthCombatModifierChange()));
		}

		if (info.getStealthDefenseChange() != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_STEALTH_DEFENSE_CHANGE", info.getStealthDefenseChange()));
		}
	}

	if (info.getDefenseOnlyChange() != 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_DEFENSE_ONLY_CHANGE", info.getDefenseOnlyChange()));
	}

	if (info.getNoInvisibilityChange() != 0 && GC.getGame().isOption(GAMEOPTION_COMBAT_HIDE_SEEK))
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_NO_INVISIBILITY_CHANGE", info.getNoInvisibilityChange()));
	}

	if (info.getNoCaptureChange() > 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_ADDS_CANNOT_CAPTURE"));
	}
	else if (info.getNoCaptureChange() < 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_REMOVES_CANNOT_CAPTURE"));
	}

	for (int iI = 0; iI < GC.getNumTerrainInfos(); iI++)
	{
		if (info.getWithdrawOnTerrainTypeChange((TerrainTypes)iI) != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_WITHDRAW_ON", info.getWithdrawOnTerrainTypeChange((TerrainTypes)iI), CvWString(GC.getTerrainInfo((TerrainTypes)iI).getType()).GetCString(), GC.getTerrainInfo((TerrainTypes)iI).getTextKeyWide()));
		}
	}

	for (int iI = 0; iI < GC.getNumFeatureInfos(); iI++)
	{
		if (info.getWithdrawOnFeatureTypeChange((FeatureTypes)iI) != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_WITHDRAW_ON", info.getWithdrawOnFeatureTypeChange((FeatureTypes)iI), CvWString(GC.getFeatureInfo((FeatureTypes)iI).getType()).GetCString(), GC.getFeatureInfo((FeatureTypes)iI).getTextKeyWide()));
		}
	}

	//booleans
	if (info.isDefensiveVictoryMove())
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_DV_MOVE"));
	}

	if (info.isFreeDrop())
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_FREE_DROP"));

		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_DROP_SIGHT_UNSEEN"));
	}

	if (info.isOffensiveVictoryMove())
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_OV_MOVE"));
	}

	if (info.isOneUp())
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_ONEUP"));
	}

	if (info.isPillageEspionage())
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_ESPIONAGE_PILLAGE"));
	}

	if (info.isPillageMarauder())
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_MARAUDER_PILLAGE"));
	}

	if (info.isPillageOnMove())
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_MOVING_PILLAGE"));
	}

	if (info.isPillageOnVictory())
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_VICTORY_PILLAGE"));
	}

	if (info.isPillageResearch())
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_RESEARCH_PILLAGE"));
	}

	if (info.isBlitz())
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_BLITZ"));
	}

	if (info.isAmphib())
	{
		szBuffer.append(NEWLINE);

		if (info.isSpy())
		{
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_RADIATION_SPY"));
		}
		else szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_AMPHIB"));
	}

	if (info.isRiver())
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_RIVER_ATTACK"));
	}

	if (info.isEnemyRoute())
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_ENEMY_ROADS"));
	}

	if (info.isAlwaysHeal())
	{
		szBuffer.append(NEWLINE);

		if (info.isSpy())
		{
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_LOYALTY_SPY"));
		}
		else szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_ALWAYS_HEAL"));
	}

	if (info.isHillsDoubleMove())
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_HILLS_MOVE"));
	}

	if (info.isImmuneToFirstStrikes())
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_IMMUNE_FIRST_STRIKES"));
	}

	if (info.isStampedeChange())
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_STAMPEDE"));
	}

	if (info.isRemoveStampede())
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_REMOVE_STAMPEDE"));
	}

	if (info.getAnimalIgnoresBordersChange() != 0 && !GC.getGame().isOption(GAMEOPTION_ANIMAL_STAY_OUT))
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_ANIMAL_IGNORES_BORDERS", info.getAnimalIgnoresBordersChange()));
	}

	{
		const int iNoDefensiveBonusChange = info.getNoDefensiveBonusChange();
		if (iNoDefensiveBonusChange != 0)
		{
			szBuffer.append(NEWLINE);

			if (iNoDefensiveBonusChange > 0)
			{
				szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_NO_DEFENSIVE_BONUS_CHANGE_POSITIVE", iNoDefensiveBonusChange));
			}
			else if (iNoDefensiveBonusChange < 0)
			{
				szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_NO_DEFENSIVE_BONUS_CHANGE_NEGATIVE", iNoDefensiveBonusChange));
			}
		}
	}

	if (info.isOnslaughtChange())
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_ONSLAUGHT"));
	}

	if (info.isMakesDamageCold())
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_MAKES_DAMAGE_COLD"));
	}

	if (info.isMakesDamageNotCold())
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_MAKES_DAMAGE_NOT_COLD"));
	}

	if (info.isAddsColdImmunity())
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_ADDS_COLD_IMMUNITY"));
	}

	if (info.isRemovesColdImmunity())
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_REMOVES_COLD_IMMUNITY"));
	}

	if (info.isAttackOnlyCitiesAdd())
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_ATTACK_ONLY_CITIES_ADD"));
	}

	if (info.isAttackOnlyCitiesSubtract())
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_ATTACK_ONLY_CITIES_SUBTRACT"));
	}

	if (info.isIgnoreNoEntryLevelAdd())
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_IGNORE_NO_ENTRY_LEVEL_ADD"));
	}

	if (info.isIgnoreNoEntryLevelSubtract())
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_IGNORE_NO_ENTRY_LEVEL_SUBTRACT"));
	}

	if (GC.getGame().isOption(GAMEOPTION_UNSUPPORTED_ZONE_OF_CONTROL))
	{
		if (info.isIgnoreZoneofControlAdd())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_IGNORE_ZONE_OF_CONTROL_ADD"));
		}
		if (info.isIgnoreZoneofControlSubtract())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_IGNORE_ZONE_OF_CONTROL_SUBTRACT"));
		}
	}

	if (info.isFliesToMoveAdd())
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_FLIES_TO_MOVE_ADD"));
	}

	if (info.isFliesToMoveSubtract())
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_FLIES_TO_MOVE_SUBTRACT"));
	}

	if (info.isCannotMergeSplit() && GC.getGame().isOption(GAMEOPTION_COMBAT_SIZE_MATTERS))
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_CANNOT_MERGE_SPLIT"));
	}

	if (info.isCanMovePeaks())
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_CAN_MOVE_PEAKS"));
	}

	if (info.isCanLeadThroughPeaks())
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_CAN_LEAD_THROUGH_PEAKS"));
	}

	if (GC.getGame().isOption(GAMEOPTION_UNSUPPORTED_ZONE_OF_CONTROL) && info.isZoneOfControl())
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_ZONE_OF_CONTROL"));
	}

	// Arrays
	if (info.isAnyDomainModifierPercent())
	{
		for (int iI = 0; iI < NUM_DOMAIN_TYPES; ++iI)
		{
			if (info.getDomainModifierPercent(iI) != 0)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_VERSUS", info.getDomainModifierPercent(iI), CvWString(GC.getDomainInfo((DomainTypes)iI).getType()), GC.getDomainInfo((DomainTypes)iI).getTextKeyWide()));
			}
		}
	}

#ifdef OUTBREAKS_AND_AFFLICTIONS
	// bool vector with delayed resolution
	if (GC.getGame().isOption(GAMEOPTION_COMBAT_OUTBREAKS_AND_AFFLICTIONS))
	{
		for (int iI = 0; iI < info.getNumCureAfflictionChangeTypes(); ++iI)
		{
			if (info.isCureAfflictionChangeType(iI))
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_CURE_AFFLICTION", GC.getPromotionLineInfo((PromotionLineTypes)info.getCureAfflictionChangeType(iI)).getTextKeyWide()));
			}
		}
	}
#endif // OUTBREAKS_AND_AFFLICTIONS

	for (int iI = 0; iI < info.getNumTerrainIgnoreDamageChangeTypes(); ++iI)
	{
		if (info.isTerrainIgnoreDamageChangeType(iI))
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_IGNORE_TERRAIN_DAMAGE", GC.getTerrainInfo((TerrainTypes)info.getTerrainIgnoreDamageChangeType(iI)).getTextKeyWide()));
		}
	}

	for (int iI = 0; iI < info.getNumTerrainDoubleMoveChangeTypes(); ++iI)
	{
		if (info.isTerrainDoubleMoveChangeType(iI))
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_DOUBLE_MOVE", GC.getTerrainInfo((TerrainTypes)info.getTerrainDoubleMoveChangeType(iI)).getTextKeyWide()));
		}
	}

	for (int iI = 0; iI < info.getNumFeatureDoubleMoveChangeTypes(); ++iI)
	{
		if (info.isFeatureDoubleMoveChangeType(iI))
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_DOUBLE_MOVE", GC.getFeatureInfo((FeatureTypes)info.getFeatureDoubleMoveChangeType(iI)).getTextKeyWide()));
		}
	}

#ifdef OUTBREAKS_AND_AFFLICTIONS
	// int vector utilizing struct with delayed resolution
	if (GC.getGame().isOption(GAMEOPTION_COMBAT_OUTBREAKS_AND_AFFLICTIONS))
	{
		if (info.getNumAfflictionFortitudeChangeModifiers() > 0 )
		{
			for (int iI = 0; iI < info.getNumAfflictionFortitudeChangeModifiers(); ++iI)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_AFFLICTION_FORTITUDE_CHANGE_MODIFIER", info.getAfflictionFortitudeChangeModifier(iI).iModifier, GC.getPromotionLineInfo((PromotionLineTypes)info.getAfflictionFortitudeChangeModifier(iI).ePromotionLine).getTextKeyWide()));
			}
		}

		if (info.getNumAfflictOnAttackChangeTypes() > 0 )
		{
			for (int iI = 0; iI < info.getNumAfflictOnAttackChangeTypes(); ++iI)
			{
				if (info.getAfflictOnAttackChangeType(iI).eAfflictionLine != NO_PROMOTIONLINE)
				{
					szBuffer.append(NEWLINE);

					if (info.getAfflictOnAttackChangeType(iI).iImmediate > 0)
					{
						szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_AFFLICT_ON_ATTACK_IMMEDIATE", info.getAfflictOnAttackChangeType(iI).iProbabilityChange, GC.getPromotionLineInfo(info.getAfflictOnAttackChangeType(iI).eAfflictionLine).getTextKeyWide()));
					}
					else if (info.getAfflictOnAttackChangeType(iI).iImmediate < 0)
					{
						szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_AFFLICT_ON_ATTACK_NOT_IMMEDIATE", info.getAfflictOnAttackChangeType(iI).iProbabilityChange, GC.getPromotionLineInfo(info.getAfflictOnAttackChangeType(iI).eAfflictionLine).getTextKeyWide()));
					}
					else szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_AFFLICT_ON_ATTACK", info.getAfflictOnAttackChangeType(iI).iProbabilityChange, GC.getPromotionLineInfo(info.getAfflictOnAttackChangeType(iI).eAfflictionLine).getTextKeyWide()));
				}
			}
		}
	}
#endif // OUTBREAKS_AND_AFFLICTIONS

	//Traps
	for (int iI = 0; iI < info.getNumTrapImmunityUnitCombatTypes(); ++iI)
	{
		if (info.isTrapImmunityUnitCombatType(iI))
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_TRAP_IMMUNITY", GC.getUnitCombatInfo((UnitCombatTypes)info.getTrapImmunityUnitCombatType(iI)).getTextKeyWide()));
		}
	}

	if (info.getNumTrapAvoidanceUnitCombatTypes() > 0 )
	{
		for (int iI = 0; iI < info.getNumTrapAvoidanceUnitCombatTypes(); ++iI)
		{
			if (info.getTrapAvoidanceUnitCombatType(iI).eUnitCombat != NO_UNITCOMBAT)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_TRAP_AVOID", info.getTrapAvoidanceUnitCombatType(iI).iModifier, GC.getUnitCombatInfo((UnitCombatTypes)info.getTrapAvoidanceUnitCombatType(iI).eUnitCombat).getTextKeyWide()));
			}
		}
	}

	if (info.getNumTerrainAttackChangeModifiers() > 0 )
	{
		for (int iI = 0; iI < info.getNumTerrainAttackChangeModifiers(); ++iI)
		{
			if (info.getTerrainAttackChangeModifier(iI).eTerrain != NO_TERRAIN)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_ATTACK", info.getTerrainAttackChangeModifier(iI).iModifier, GC.getTerrainInfo((TerrainTypes)info.getTerrainAttackChangeModifier(iI).eTerrain).getTextKeyWide()));
			}
		}
	}

	if (info.getNumTerrainDefenseChangeModifiers() > 0 )
	{
		for (int iI = 0; iI < info.getNumTerrainDefenseChangeModifiers(); ++iI)
		{
			if (info.getTerrainDefenseChangeModifier(iI).eTerrain != NO_TERRAIN)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_DEFENSE", info.getTerrainDefenseChangeModifier(iI).iModifier, GC.getTerrainInfo((TerrainTypes)info.getTerrainDefenseChangeModifier(iI).eTerrain).getTextKeyWide()));
			}
		}
	}

	if (info.getNumTerrainWorkChangeModifiers() > 0 )
	{
		for (int iI = 0; iI < info.getNumTerrainWorkChangeModifiers(); ++iI)
		{
			if (info.getTerrainWorkChangeModifier(iI).eTerrain != NO_TERRAIN)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_WORK", info.getTerrainWorkChangeModifier(iI).iModifier, GC.getTerrainInfo((TerrainTypes)info.getTerrainWorkChangeModifier(iI).eTerrain).getTextKeyWide()));
			}
		}
	}

	if (info.getNumBuildWorkChangeModifiers() > 0 )
	{
		for (int iI = 0; iI < info.getNumBuildWorkChangeModifiers(); ++iI)
		{
			if (info.getBuildWorkChangeModifier(iI).eBuild != NO_BUILD)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_WORK", info.getBuildWorkChangeModifier(iI).iModifier, GC.getBuildInfo((BuildTypes)info.getBuildWorkChangeModifier(iI).eBuild).getTextKeyWide()));
			}
		}
	}

	if (info.getNumFeatureAttackChangeModifiers() > 0 )
	{
		for (int iI = 0; iI < info.getNumFeatureAttackChangeModifiers(); ++iI)
		{
			if (info.getFeatureAttackChangeModifier(iI).eFeature != NO_FEATURE)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_ATTACK", info.getFeatureAttackChangeModifier(iI).iModifier, GC.getFeatureInfo((FeatureTypes)info.getFeatureAttackChangeModifier(iI).eFeature).getTextKeyWide()));
			}
		}
	}

	if (info.getNumFeatureDefenseChangeModifiers() > 0 )
	{
		for (int iI = 0; iI < info.getNumFeatureDefenseChangeModifiers(); ++iI)
		{
			if (info.getFeatureDefenseChangeModifier(iI).eFeature != NO_FEATURE)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_DEFENSE", info.getFeatureDefenseChangeModifier(iI).iModifier, GC.getFeatureInfo((FeatureTypes)info.getFeatureDefenseChangeModifier(iI).eFeature).getTextKeyWide()));
			}
		}
	}

	if (info.getNumFeatureWorkChangeModifiers() > 0 )
	{
		for (int iI = 0; iI < info.getNumFeatureWorkChangeModifiers(); ++iI)
		{
			if (info.getFeatureWorkChangeModifier(iI).eFeature != NO_FEATURE)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_WORK", info.getFeatureWorkChangeModifier(iI).iModifier, GC.getFeatureInfo((FeatureTypes)info.getFeatureWorkChangeModifier(iI).eFeature).getTextKeyWide()));
			}
		}
	}

	if (info.getNumUnitCombatChangeModifiers() > 0 )
	{
		for (int iI = 0; iI < info.getNumUnitCombatChangeModifiers(); ++iI)
		{
			if (info.getUnitCombatChangeModifier(iI).eUnitCombat != NO_UNITCOMBAT)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_MOD_VS_TYPE", info.getUnitCombatChangeModifier(iI).iModifier, CvWString(GC.getUnitCombatInfo((UnitCombatTypes)info.getUnitCombatChangeModifier(iI).eUnitCombat).getType()).GetCString(), GC.getUnitCombatInfo((UnitCombatTypes)info.getUnitCombatChangeModifier(iI).eUnitCombat).getTextKeyWide()));
			}
		}
	}

	if (info.getNumFlankingStrengthbyUnitCombatTypesChange() > 0 )
	{
		for (int iI = 0; iI < info.getNumFlankingStrengthbyUnitCombatTypesChange(); ++iI)
		{
			if (info.getFlankingStrengthbyUnitCombatTypeChange(iI).eUnitCombat != NO_UNITCOMBAT)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_UNITHELP_COMBAT_FLANKING_STRIKES", info.getFlankingStrengthbyUnitCombatTypeChange(iI).iModifier, GC.getUnitCombatInfo((UnitCombatTypes)info.getFlankingStrengthbyUnitCombatTypeChange(iI).eUnitCombat).getTextKeyWide()));
			}
		}
	}

	if (info.getNumWithdrawVSUnitCombatTypesChange() > 0 )
	{
		for (int iI = 0; iI < info.getNumWithdrawVSUnitCombatTypesChange(); ++iI)
		{
			if (info.getWithdrawVSUnitCombatTypeChange(iI).eUnitCombat != NO_UNITCOMBAT)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_WITHDRAW_VERSUS", info.getWithdrawVSUnitCombatTypeChange(iI).iModifier, CvWString(GC.getUnitCombatInfo((UnitCombatTypes)info.getWithdrawVSUnitCombatTypeChange(iI).eUnitCombat).getType()).GetCString(), GC.getUnitCombatInfo((UnitCombatTypes)info.getWithdrawVSUnitCombatTypeChange(iI).eUnitCombat).getTextKeyWide()));
			}
		}
	}

	if (GC.getGame().isOption(GAMEOPTION_COMBAT_FIGHT_OR_FLIGHT) && info.getNumPursuitVSUnitCombatTypesChange() > 0)
	{
		for (int iI = 0; iI < info.getNumPursuitVSUnitCombatTypesChange(); ++iI)
		{
			if (info.getPursuitVSUnitCombatTypeChange(iI).eUnitCombat != NO_UNITCOMBAT)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_PURSUIT_VERSUS", info.getPursuitVSUnitCombatTypeChange(iI).iModifier, CvWString(GC.getUnitCombatInfo((UnitCombatTypes)info.getPursuitVSUnitCombatTypeChange(iI).eUnitCombat).getType()).GetCString(), GC.getUnitCombatInfo((UnitCombatTypes)info.getPursuitVSUnitCombatTypeChange(iI).eUnitCombat).getTextKeyWide()));
			}
		}
	}

	if (GC.getGame().isOption(GAMEOPTION_COMBAT_HEART_OF_WAR))
	{
		if (info.getNumRepelVSUnitCombatTypesChange() > 0 )
		{
			for (int iI = 0; iI < info.getNumRepelVSUnitCombatTypesChange(); ++iI)
			{
				if (info.getRepelVSUnitCombatTypeChange(iI).eUnitCombat != NO_UNITCOMBAT)
				{
					szBuffer.append(NEWLINE);
					szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_REPEL_VERSUS", info.getRepelVSUnitCombatTypeChange(iI).iModifier, CvWString(GC.getUnitCombatInfo((UnitCombatTypes)info.getRepelVSUnitCombatTypeChange(iI).eUnitCombat).getType()).GetCString(), GC.getUnitCombatInfo((UnitCombatTypes)info.getRepelVSUnitCombatTypeChange(iI).eUnitCombat).getTextKeyWide()));
				}
			}
		}

		if (info.getNumKnockbackVSUnitCombatTypesChange() > 0 )
		{
			for (int iI = 0; iI < info.getNumKnockbackVSUnitCombatTypesChange(); ++iI)
			{
				if (info.getKnockbackVSUnitCombatTypeChange(iI).eUnitCombat != NO_UNITCOMBAT)
				{
					szBuffer.append(NEWLINE);
					szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_KNOCKBACK_VERSUS", info.getKnockbackVSUnitCombatTypeChange(iI).iModifier, CvWString(GC.getUnitCombatInfo((UnitCombatTypes)info.getKnockbackVSUnitCombatTypeChange(iI).eUnitCombat).getType()).GetCString(), GC.getUnitCombatInfo((UnitCombatTypes)info.getKnockbackVSUnitCombatTypeChange(iI).eUnitCombat).getTextKeyWide()));
				}
			}
		}
	}

	if (info.getNumPunctureVSUnitCombatTypesChange() > 0 )
	{
		for (int iI = 0; iI < info.getNumPunctureVSUnitCombatTypesChange(); ++iI)
		{
			if (info.getPunctureVSUnitCombatTypeChange(iI).eUnitCombat != NO_UNITCOMBAT)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_PUNCTURE_VERSUS", info.getPunctureVSUnitCombatTypeChange(iI).iModifier, CvWString(GC.getUnitCombatInfo((UnitCombatTypes)info.getPunctureVSUnitCombatTypeChange(iI).eUnitCombat).getType()).GetCString(), GC.getUnitCombatInfo((UnitCombatTypes)info.getPunctureVSUnitCombatTypeChange(iI).eUnitCombat).getTextKeyWide()));
			}
		}
	}

	if (info.getNumArmorVSUnitCombatTypesChange() > 0 )
	{
		for (int iI = 0; iI < info.getNumArmorVSUnitCombatTypesChange(); ++iI)
		{
			if (info.getArmorVSUnitCombatTypeChange(iI).eUnitCombat != NO_UNITCOMBAT)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_ARMOR_VERSUS", info.getArmorVSUnitCombatTypeChange(iI).iModifier, CvWString(GC.getUnitCombatInfo((UnitCombatTypes)info.getArmorVSUnitCombatTypeChange(iI).eUnitCombat).getType()).GetCString(), GC.getUnitCombatInfo((UnitCombatTypes)info.getArmorVSUnitCombatTypeChange(iI).eUnitCombat).getTextKeyWide()));
			}
		}
	}

	if (info.getNumDodgeVSUnitCombatTypesChange() > 0 )
	{
		for (int iI = 0; iI < info.getNumDodgeVSUnitCombatTypesChange(); ++iI)
		{
			if (info.getDodgeVSUnitCombatTypeChange(iI).eUnitCombat != NO_UNITCOMBAT)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_DODGE_VERSUS", info.getDodgeVSUnitCombatTypeChange(iI).iModifier, CvWString(GC.getUnitCombatInfo((UnitCombatTypes)info.getDodgeVSUnitCombatTypeChange(iI).eUnitCombat).getType()).GetCString(), GC.getUnitCombatInfo((UnitCombatTypes)info.getDodgeVSUnitCombatTypeChange(iI).eUnitCombat).getTextKeyWide()));
			}
		}
	}

	if (info.getNumPrecisionVSUnitCombatTypesChange() > 0 )
	{
		for (int iI = 0; iI < info.getNumPrecisionVSUnitCombatTypesChange(); ++iI)
		{
			if (info.getPrecisionVSUnitCombatTypeChange(iI).eUnitCombat != NO_UNITCOMBAT)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_PRECISION_VERSUS", info.getPrecisionVSUnitCombatTypeChange(iI).iModifier, CvWString(GC.getUnitCombatInfo((UnitCombatTypes)info.getPrecisionVSUnitCombatTypeChange(iI).eUnitCombat).getType()).GetCString(), GC.getUnitCombatInfo((UnitCombatTypes)info.getPrecisionVSUnitCombatTypeChange(iI).eUnitCombat).getTextKeyWide()));
			}
		}
	}

	if (info.getNumCriticalVSUnitCombatTypesChange() > 0 )
	{
		for (int iI = 0; iI < info.getNumCriticalVSUnitCombatTypesChange(); ++iI)
		{
			if (info.getCriticalVSUnitCombatTypeChange(iI).eUnitCombat != NO_UNITCOMBAT)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_CRITICAL_VERSUS", info.getCriticalVSUnitCombatTypeChange(iI).iModifier, CvWString(GC.getUnitCombatInfo((UnitCombatTypes)info.getCriticalVSUnitCombatTypeChange(iI).eUnitCombat).getType()).GetCString(), GC.getUnitCombatInfo((UnitCombatTypes)info.getCriticalVSUnitCombatTypeChange(iI).eUnitCombat).getTextKeyWide()));
			}
		}
	}

	if (info.getNumRoundStunVSUnitCombatTypesChange() > 0 )
	{
		for (int iI = 0; iI < info.getNumRoundStunVSUnitCombatTypesChange(); ++iI)
		{
			if (info.getRoundStunVSUnitCombatTypeChange(iI).eUnitCombat != NO_UNITCOMBAT)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_ROUND_STUN_VERSUS", info.getRoundStunVSUnitCombatTypeChange(iI).iModifier, CvWString(GC.getUnitCombatInfo((UnitCombatTypes)info.getRoundStunVSUnitCombatTypeChange(iI).eUnitCombat).getType()).GetCString(), GC.getUnitCombatInfo((UnitCombatTypes)info.getRoundStunVSUnitCombatTypeChange(iI).eUnitCombat).getTextKeyWide()));
			}
		}
	}


	if (info.getInsidiousnessChange() != 0)
	{
		CvWString szTempBuffer;
		szBuffer.append(NEWLINE);
		float fValue = (float)info.getInsidiousnessChange();
		{
			szTempBuffer.Format(L"%.1f", fValue/10);
		}
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_INSIDIOUSNESS", szTempBuffer.GetCString()));
	}

	if (info.getInvestigationChange() != 0)
	{
		CvWString szTempBuffer;
		szBuffer.append(NEWLINE);
		float fValue = (float)info.getInvestigationChange();
		{
			szTempBuffer.Format(L"%.1f", fValue/10);
		}
		szBuffer.append(gDLL->getText("TXT_KEY_PROMOTIONHELP_INVESTIGATION", szTempBuffer.GetCString()));
	}
	//Propery Manipulators
	if (info.getPropertyManipulators())
		info.getPropertyManipulators()->buildDisplayString(szBuffer);
}

void CvGameTextMgr::setImprovementHelp(CvWStringBuffer &szBuffer, ImprovementTypes eImprovement, FeatureTypes eFeature, bool bCivilopediaText)
{
	PROFILE_EXTRA_FUNC();
	if (NO_IMPROVEMENT == eImprovement)
	{
		return;
	}
	CvWString szTempBuffer;
	CvWString szFirstBuffer;
	const PlayerTypes ePlayer = GC.getGame().getActivePlayer();
	const bool bPlayerContext = ePlayer != NO_PLAYER;

	const CvImprovementInfo& info = GC.getImprovementInfo(eImprovement);

	if (!bCivilopediaText)
	{
		szTempBuffer.Format( SETCOLR L"%s" ENDCOLR, TEXT_COLOR("COLOR_HIGHLIGHT_TEXT"), info.getDescription());
		szBuffer.append(szTempBuffer);

		setYieldChangeHelp(szBuffer, L", ", L"", L"", info.getYieldChangeArray(), false, false);

		setYieldChangeHelp(szBuffer, L"", L"", gDLL->getText("TXT_KEY_MISC_WITH_IRRIGATION").c_str(), info.getIrrigatedYieldChangeArray());
		setYieldChangeHelp(szBuffer, L"", L"", gDLL->getText("TXT_KEY_MISC_ALONG_RIVER").c_str(), info.getRiverSideYieldChangeArray());

		for (int iTech = 0; iTech < GC.getNumTechInfos(); iTech++)
		{
			if (GC.getGame().canEverResearch((TechTypes)iTech))
			{
				for (int iYield = 0; iYield < NUM_YIELD_TYPES; iYield++)
				{
					if (0 != info.getTechYieldChanges(iTech, iYield))
					{
						szBuffer.append(NEWLINE);
						szBuffer.append
						(
							gDLL->getText
							(
								"TXT_KEY_IMPROVEMENTHELP_WITH_TECH",
								info.getTechYieldChanges(iTech, iYield),
								GC.getYieldInfo((YieldTypes)iYield).getChar(),
								GC.getTechInfo((TechTypes)iTech).getTextKeyWide()
							)
						);
					}
				}
			}
		}

		for (int iTrait = 0; iTrait < GC.getNumTraitInfos(); iTrait++)
		{
			const CvTraitInfo& trait = GC.getTraitInfo((TraitTypes)iTrait);

			for (int iYield = 0; iYield < NUM_YIELD_TYPES; iYield++)
			{
				if (trait.getImprovementYieldChange(eImprovement, iYield) != 0)
				{
					szTempBuffer.Format( SETCOLR L"%s" ENDCOLR , TEXT_COLOR("COLOR_MAGENTA"), trait.getDescription());
					szBuffer.append(NEWLINE);
					szBuffer.append(gDLL->getText("TXT_KEY_CIVICHELP_IMPROVEMENT_YIELD_CHANGE", trait.getImprovementYieldChange(eImprovement, iYield), GC.getYieldInfo((YieldTypes)iYield).getChar()));
					szBuffer.append(szTempBuffer);
				}
				//if (0 != info.getTraitYieldChanges(iTrait, iYield))
				//{
				//	szTempBuffer.Format( SETCOLR L"%s" ENDCOLR , TEXT_COLOR("COLOR_MAGENTA"), trait.getDescription());
				//	szBuffer.append(NEWLINE);
				//	szBuffer.append(gDLL->getText("TXT_KEY_CIVICHELP_IMPROVEMENT_YIELD_CHANGE", info.getTraitYieldChanges(iTrait, iYield), GC.getYieldInfo((YieldTypes)iYield).getChar()));
				//	szBuffer.append(szTempBuffer);
				//}
			}
		}

		//	Civics
		for (int iYield = 0; iYield < NUM_YIELD_TYPES; iYield++)
		{
			for (int iCivic = 0; iCivic < GC.getNumCivicInfos(); iCivic++)
			{
				const int iChange = GC.getCivicInfo((CivicTypes)iCivic).getImprovementYieldChanges(eImprovement, iYield);
				if (0 != iChange)
				{
					szTempBuffer.Format( SETCOLR L"%s" ENDCOLR , TEXT_COLOR("COLOR_HIGHLIGHT_TEXT"), GC.getCivicInfo((CivicTypes)iCivic).getDescription());
					szBuffer.append(NEWLINE);
					szBuffer.append(gDLL->getText("TXT_KEY_CIVICHELP_IMPROVEMENT_YIELD_CHANGE", iChange, GC.getYieldInfo((YieldTypes)iYield).getChar()));
					szBuffer.append(szTempBuffer);
				}
			}
		}
	}

	if (info.isRequiresRiverSide())
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_IMPROVEMENTHELP_REQUIRES_RIVER"));
	}

	if (info.isPeakImprovement())
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_IMPROVEMENTHELP_REQUIRES_PEAK"));
	}

	if (info.isCarriesIrrigation())
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_IMPROVEMENTHELP_CARRIES_IRRIGATION"));
	}
	if (bCivilopediaText)
	{
		if (info.isNoFreshWater())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_IMPROVEMENTHELP_NO_BUILD_FRESH_WATER"));
		}
		if (info.isWaterImprovement())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_IMPROVEMENTHELP_BUILD_ONLY_WATER"));
		}
		if (info.isRequiresFlatlands())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_IMPROVEMENTHELP_ONLY_BUILD_FLATLANDS"));
		}
	}

	foreach_(const BuildTypes& eBuild, info.getBuildTypes())
	{
		const CvBuildInfo& build = GC.getBuildInfo(eBuild);

		foreach_(const BonusTypes ePrereqBonus, build.getPrereqBonuses())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDHELP_REQUIRES_BONUS", build.getTextKeyWide(), GC.getBonusInfo(ePrereqBonus).getTextKeyWide()));
		}
	}

	if (info.getImprovementUpgrade() != NO_IMPROVEMENT)
	{
		const int iTurns =
		(
			bPlayerContext
			?
			(
				100 * GC.getGame().getImprovementUpgradeTime(eImprovement)
				/
				GET_PLAYER(ePlayer).getImprovementUpgradeProgressRate(eImprovement)
			)
			:
			info.getUpgradeTime()
		);
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_UPGRADE_TIME", iTurns));

		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_UPGRADES"));

		for (int iI = -1; iI < info.getNumAlternativeImprovementUpgradeTypes(); iI++)
		{
			const ImprovementTypes eUpgradeX =
			(
				iI == -1 ? info.getImprovementUpgrade()
				:
				(ImprovementTypes)info.getAlternativeImprovementUpgradeType(iI)
			);
			if (iI > -1)
			{
				szBuffer.append(L", ");
			}
			szBuffer.append
			(
				gDLL->getText
				(
					"TXT_KEY_LINK",
					CvWString(GC.getImprovementInfo(eUpgradeX).getType()).GetCString(),
					GC.getImprovementInfo(eUpgradeX).getTextKeyWide()
				)
			);
		}

		if (info.isUpgradeRequiresFortify())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_IMPROVEMENTHELP_FORTIFY_TO_UPGRADE"));
		}
	}

	int iLast = -1;
	for (int iBonus = 0; iBonus < GC.getNumBonusInfos(); iBonus++)
	{
		const int iRand = info.getImprovementBonusDiscoverRand(iBonus);
		if (iRand > 0)
		{
			szFirstBuffer.Format(L"%s%s", NEWLINE, gDLL->getText("TXT_KEY_IMPROVEMENTHELP_CHANCE_DISCOVER").c_str());
			szTempBuffer.Format(L"%c", GC.getBonusInfo((BonusTypes) iBonus).getChar());
			setListHelp(szBuffer, szFirstBuffer, szTempBuffer, L", ", iRand != iLast);
			iLast = iRand;
		}
	}

	if (0 != info.getDefenseModifier())
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_IMPROVEMENTHELP_DEFENSE_MODIFIER", info.getDefenseModifier()));
	}

	if (0 != info.getHealthPercent())
	{
		const int iHealthPercent = info.getHealthPercent();
		szBuffer.append(NEWLINE);
		if (iHealthPercent % 100 == 0)
		{
			szBuffer.append
			(
				CvWString::format
				(
					L"%c%s%d%c%s",
					gDLL->getSymbolID(BULLET_CHAR),
					iHealthPercent > 0 ? L"+" : L"",
					abs(iHealthPercent / 100),
					(
						iHealthPercent > 0
						?
						gDLL->getSymbolID(HEALTHY_CHAR)
						:
						gDLL->getSymbolID(UNHEALTHY_CHAR)
					),
					gDLL->getText("TXT_KEY_MISC_ICON_CHANGE_NEARBY_CITIES_1").GetCString()
				)
			);
		}
		else if (iHealthPercent % 10 == 0)
		{
			szBuffer.append
			(
				CvWString::format
				(
					L"%c%s%.1f%c%s",
					gDLL->getSymbolID(BULLET_CHAR),
					iHealthPercent > 0 ? L"+" : L"",
					abs(iHealthPercent) * 0.01f,
					(
						iHealthPercent > 0
						?
						gDLL->getSymbolID(HEALTHY_CHAR)
						:
						gDLL->getSymbolID(UNHEALTHY_CHAR)
					),
					gDLL->getText("TXT_KEY_MISC_ICON_CHANGE_NEARBY_CITIES_1").GetCString()
				)
			);
		}
		else
		{
			szBuffer.append
			(
				CvWString::format
				(
					L"%c%s%.2f%c%s",
					gDLL->getSymbolID(BULLET_CHAR),
					iHealthPercent > 0 ? L"+" : L"",
					abs(iHealthPercent) * 0.01f,
					(
						iHealthPercent > 0
						?
						gDLL->getSymbolID(HEALTHY_CHAR)
						:
						gDLL->getSymbolID(UNHEALTHY_CHAR)
					),
					gDLL->getText("TXT_KEY_MISC_ICON_CHANGE_NEARBY_CITIES_1").GetCString()
				)
			);
		}
	}
	if (0 != info.getHappiness())
	{
		szBuffer.append(NEWLINE);
		szBuffer.append
		(
			gDLL->getText
			(
				"TXT_KEY_MISC_ICON_CHANGE_NEARBY_CITIES",
				abs(info.getHappiness()),
				(
					info.getHappiness() > 0
					?
					gDLL->getSymbolID(HAPPY_CHAR)
					:
					gDLL->getSymbolID(UNHAPPY_CHAR)
				)
			)
		);
	}
	if (info.isActsAsCity())
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_IMPROVEMENTHELP_DEFENSE_MODIFIER_EXTRA"));
	}

	if (info.getFeatureGrowthProbability() > 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_IMPROVEMENTHELP_MORE_GROWTH"));
	}
	else if (info.getFeatureGrowthProbability() < 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_IMPROVEMENTHELP_LESS_GROWTH"));
	}

	if (info.isBombardable() && (info.getDefenseModifier() > 0))
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_IMPROVEMENTHELP_BOMBARD"));
	}
	if (info.getUniqueRange() > 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_IMPROVEMENTHELP_UNIQUE_RANGE", info.getUniqueRange()));
	}
	if (info.isZOCSource())
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_IMPROVEMENTHELP_IS_ZOC_SOURCE"));
	}
	if (info.getNumFeatureChangeTypes() > 0)
	{
		for (int iI = 0; iI < info.getNumFeatureChangeTypes(); iI++)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_IMPROVEMENTHELP_FEATURE_CHANGE", GC.getFeatureInfo((FeatureTypes)info.getFeatureChangeType(iI)).getTextKeyWide()));
		}
	}
	if (info.getBonusChange() != NO_BONUS)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_IMPROVEMENTHELP_BONUS_CHANGE", GC.getBonusInfo(info.getBonusChange()).getTextKeyWide()));
	}
	if (info.isNotOnAnyBonus())
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_IMPROVEMENTHELP_NOT_ON_ANY_BONUS"));
	}
	if (info.isNational())
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_IMPROVEMENTHELP_NATIONAL"));
	}
	if (info.isGlobal())
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_IMPROVEMENTHELP_GLOBAL"));
	}
	if (info.isChangeRemove())
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_IMPROVEMENTHELP_CHANGE_REMOVE"));
	}
	if (info.isCanMoveSeaUnits())
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_IMPROVEMENTHELP_IS_CAN_MOVE_SEA_UNITS"));
	}
	if (info.isImprovementBonusTrade())
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_IMPROVEMENTHELP_IS_UNIVERSAL_BONUS_PROVIDER"));
	}
	if (info.getCulture() > 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_IMPROVEMENTHELP_PLOT_CULTURE", info.getCulture()));
	}
	if (info.getCultureRange() > 0 && info.getCulture() > 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_IMPROVEMENTHELP_CULTURE_RANGE", info.getCultureRange()));
	}
	if (info.getVisibilityChange() > 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_IMPROVEMENTHELP_VISIBILITY_RANGE", info.getVisibilityChange()));
	}
	if (info.getSeeFrom() > 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_IMPROVEMENTHELP_SEE_FROM", info.getSeeFrom()));
	}
	if (info.getPillageGold() > 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_IMPROVEMENTHELP_PILLAGE_YIELDS", info.getPillageGold()));
	}

	if (bPlayerContext && eFeature != NO_FEATURE)
	{
		const CvPlot* pPlot =
		(
			GET_PLAYER(ePlayer).getFocusPlotX() != -1
			?
			GC.getMap().plot(GET_PLAYER(ePlayer).getFocusPlotX(), GET_PLAYER(ePlayer).getFocusPlotY())
			:
			NULL
		);
		if (pPlot)
		{
			const TeamTypes eTeam = GET_PLAYER(ePlayer).getTeam();
			FAssertMsg(eTeam != NO_TEAM, "eTeam should be valid");
			CvCity* pCity = NULL;
			int iBestProduction = 0;

			foreach_(const BuildTypes& eBuild, info.getBuildTypes())
			{
				const CvBuildInfo& build = GC.getBuildInfo(eBuild);

				if (GET_TEAM(eTeam).isHasTech(build.getTechPrereq()))
				{
					if (build.isFeatureRemove(eFeature))
					{
						const int iProduction = pPlot->getFeatureProduction(eBuild, eTeam, &pCity);

						if (iProduction >= iBestProduction && iProduction != -1)
						{
							iBestProduction = iProduction;
						}
					}
					else iBestProduction = -1;
				}
			}
			if (iBestProduction >= 0)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_IMPROVEMENTHELP_UPGRADE_DESTROYS_FEATURE", GC.getFeatureInfo(eFeature).getTextKeyWide(), iBestProduction, pCity->getNameKey()));
			}
			else if (iBestProduction == -1)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_IMPROVEMENTHELP_UPGRADE_RETAINS_FEATURE", GC.getFeatureInfo(eFeature).getTextKeyWide()));
			}
		}
	}

	info.getPropertyManipulators()->buildDisplayString(szBuffer);

	if (bCivilopediaText)
	{
		foreach_(const MapCategoryTypes eMapCategory, info.getMapCategories())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_MAP_CATEGORY_PREREQUISITE", GC.getMapCategoryInfo(eMapCategory).getTextKeyWide()));
		}
	}
}

void CvGameTextMgr::setRouteHelp(CvWStringBuffer &szBuffer, RouteTypes eRoute, bool bCivilopediaText)
{
	PROFILE_EXTRA_FUNC();
	if (NO_ROUTE == eRoute)
	{
		return;
	}
	CvWString szTempBuffer;
	CvWString szFirstBuffer;

	const int iMoveDenominator = GC.getMOVE_DENOMINATOR();

	const CvRouteInfo& info = GC.getRouteInfo(eRoute);
	if (!bCivilopediaText)
	{
		szTempBuffer.Format(SETCOLR L"%s" ENDCOLR, TEXT_COLOR("COLOR_HIGHLIGHT_TEXT"), info.getDescription());
		szBuffer.append(szTempBuffer);
		setYieldChangeHelp(szBuffer, L", ", L"", L"", info.getYieldChangeArray(), false, false);
	}

	if (info.isSeaTunnel())
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_ROUTE_SEA_TUNNEL"));
	}

	if (info.getMovementCost() != 0)
	{
		szTempBuffer.clear();
		szTempBuffer.Format(L"%.2f%c ", (float)info.getMovementCost() / iMoveDenominator, gDLL->getSymbolID(MOVES_CHAR));
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_ROUTE_MOVEMENT_COST", szTempBuffer.GetCString()));
	}

	if (info.getFlatMovementCost() != 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_ROUTE_FLAT_MOVEMENT_COST", iMoveDenominator / info.getFlatMovementCost()));
	}

	if (info.getPrereqBonus() != NO_BONUS)
	{
		if ((GC.getGame().getActivePlayer() != NO_PLAYER && !GET_PLAYER(GC.getGame().getActivePlayer()).hasBonus((BonusTypes)info.getPrereqBonus())) || GC.getGame().getActivePlayer() == NO_PLAYER)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_ROUTE_REQUIRES_BONUS", GC.getBonusInfo((BonusTypes)info.getPrereqBonus()).getTextKeyWide()));
		}
	}

	if (!info.getPrereqOrBonuses().empty())
	{
		bool bQualified = true;

		foreach_(const BonusTypes eBonusOrPrereq, info.getPrereqOrBonuses())
		{
			if (GC.getGame().getActivePlayer() != NO_PLAYER && GET_PLAYER(GC.getGame().getActivePlayer()).hasBonus(eBonusOrPrereq))
			{
				bQualified = false;
				break;
			}
		}
		if (bQualified)
		{

			foreach_(const BonusTypes eBonusOrPrereq, info.getPrereqOrBonuses())
			{
				if (GC.getGame().getActivePlayer() == NO_PLAYER || !GET_PLAYER(GC.getGame().getActivePlayer()).hasBonus(eBonusOrPrereq))
				{
					szBuffer.append(gDLL->getText("TXT_KEY_ROUTE_REQUIRES_BONUS_OR", GC.getBonusInfo(eBonusOrPrereq).getTextKeyWide()));
				}
			}
		}
	}

	if (bCivilopediaText)
	{
		for (int iTech = 0; iTech < GC.getNumTechInfos(); iTech++)
		{
			if (GC.getGame().canEverResearch((TechTypes)iTech))
			{
				if (0 != info.getTechMovementChange(iTech))
				{
					szTempBuffer.clear();
					szTempBuffer.Format(L"%.2f%c ", (float)info.getMovementCost() / iMoveDenominator, gDLL->getSymbolID(MOVES_CHAR));
					szBuffer.append(NEWLINE);
					szBuffer.append(gDLL->getText("TXT_KEY_MOVEMENT_ROUTE_WITH_TECH", szTempBuffer.GetCString(), GC.getTechInfo((TechTypes)iTech).getTextKeyWide()));
				}
			}
		}
	}

	info.getPropertyManipulators()->buildDisplayString(szBuffer);
}


void CvGameTextMgr::getDealString(CvWStringBuffer& szBuffer, CvDeal& deal, PlayerTypes ePlayerPerspective)
{
	PlayerTypes ePlayer1 = deal.getFirstPlayer();
	PlayerTypes ePlayer2 = deal.getSecondPlayer();

	const CLinkList<TradeData>* pListPlayer1 = deal.getFirstTrades();
	const CLinkList<TradeData>* pListPlayer2 = deal.getSecondTrades();

	getDealString(szBuffer, ePlayer1, ePlayer2, pListPlayer1,  pListPlayer2, ePlayerPerspective);
}

void CvGameTextMgr::getDealString(CvWStringBuffer& szBuffer, PlayerTypes ePlayer1, PlayerTypes ePlayer2, const CLinkList<TradeData>* pListPlayer1, const CLinkList<TradeData>* pListPlayer2, PlayerTypes ePlayerPerspective)
{
	PROFILE_EXTRA_FUNC();
	if (NO_PLAYER == ePlayer1 || NO_PLAYER == ePlayer2)
	{
		FErrorMsg("Deal needs two parties");
		return;
	}

	CvWStringBuffer szDealOne;
	if (pListPlayer1 && pListPlayer1->getLength() > 0)
	{
		CLLNode<TradeData>* pTradeNode;
		bool bFirst = true;
		for (pTradeNode = pListPlayer1->head(); pTradeNode; pTradeNode = pListPlayer1->next(pTradeNode))
		{
			CvWStringBuffer szTrade;
			getTradeString(szTrade, pTradeNode->m_data, ePlayer1, ePlayer2);
			setListHelp(szDealOne, L"", szTrade.getCString(), L", ", bFirst);
			bFirst = false;
		}
	}

	CvWStringBuffer szDealTwo;
	if (pListPlayer2 && pListPlayer2->getLength() > 0)
	{
		CLLNode<TradeData>* pTradeNode;
		bool bFirst = true;
		for (pTradeNode = pListPlayer2->head(); pTradeNode; pTradeNode = pListPlayer2->next(pTradeNode))
		{
			CvWStringBuffer szTrade;
			getTradeString(szTrade, pTradeNode->m_data, ePlayer2, ePlayer1);
			setListHelp(szDealTwo, L"", szTrade.getCString(), L", ", bFirst);
			bFirst = false;
		}
	}

	if (!szDealOne.isEmpty())
	{
		if (!szDealTwo.isEmpty())
		{
			if (ePlayerPerspective == ePlayer1)
			{
				szBuffer.append(gDLL->getText("TXT_KEY_MISC_OUR_DEAL", szDealOne.getCString(), GET_PLAYER(ePlayer2).getNameKey(), szDealTwo.getCString()));
			}
			else if (ePlayerPerspective == ePlayer2)
			{
				szBuffer.append(gDLL->getText("TXT_KEY_MISC_OUR_DEAL", szDealTwo.getCString(), GET_PLAYER(ePlayer1).getNameKey(), szDealOne.getCString()));
			}
			else
			{
				szBuffer.append(gDLL->getText("TXT_KEY_MISC_DEAL", GET_PLAYER(ePlayer1).getNameKey(), szDealOne.getCString(), GET_PLAYER(ePlayer2).getNameKey(), szDealTwo.getCString()));
			}
		}
		else
		{
			if (ePlayerPerspective == ePlayer1)
			{
				szBuffer.append(gDLL->getText("TXT_KEY_MISC_DEAL_ONESIDED_OURS", szDealOne.getCString(), GET_PLAYER(ePlayer2).getNameKey()));
			}
			else if (ePlayerPerspective == ePlayer2)
			{
				szBuffer.append(gDLL->getText("TXT_KEY_MISC_DEAL_ONESIDED_THEIRS", szDealOne.getCString(), GET_PLAYER(ePlayer1).getNameKey()));
			}
			else
			{
				szBuffer.append(gDLL->getText("TXT_KEY_MISC_DEAL_ONESIDED", GET_PLAYER(ePlayer1).getNameKey(), szDealOne.getCString(), GET_PLAYER(ePlayer2).getNameKey()));
			}
		}
	}
	else if (!szDealTwo.isEmpty())
	{
		if (ePlayerPerspective == ePlayer1)
		{
			szBuffer.append(gDLL->getText("TXT_KEY_MISC_DEAL_ONESIDED_THEIRS", szDealTwo.getCString(), GET_PLAYER(ePlayer2).getNameKey()));
		}
		else if (ePlayerPerspective == ePlayer2)
		{
			szBuffer.append(gDLL->getText("TXT_KEY_MISC_DEAL_ONESIDED_OURS", szDealTwo.getCString(), GET_PLAYER(ePlayer1).getNameKey()));
		}
		else
		{
			szBuffer.append(gDLL->getText("TXT_KEY_MISC_DEAL_ONESIDED", GET_PLAYER(ePlayer2).getNameKey(), szDealTwo.getCString(), GET_PLAYER(ePlayer1).getNameKey()));
		}
	}
}

void CvGameTextMgr::getWarplanString(CvWStringBuffer& szString, WarPlanTypes eWarPlan)
{
	switch (eWarPlan)
	{
		case WARPLAN_ATTACKED_RECENT: szString.assign(L"new defensive war"); break;
		case WARPLAN_ATTACKED: szString.assign(L"defensive war"); break;
		case WARPLAN_PREPARING_LIMITED: szString.assign(L"preparing limited war"); break;
		case WARPLAN_PREPARING_TOTAL: szString.assign(L"preparing total war"); break;
		case WARPLAN_LIMITED: szString.assign(L"limited war"); break;
		case WARPLAN_TOTAL: szString.assign(L"total war"); break;
		case WARPLAN_DOGPILE: szString.assign(L"dogpile war"); break;
		case NO_WARPLAN: szString.assign(L"unplanned war"); break;
		default:  szString.assign(L"unknown war"); break;
	}
}

void CvGameTextMgr::getAttitudeString(CvWStringBuffer& szBuffer, PlayerTypes ePlayer, PlayerTypes eTargetPlayer)
{
	PROFILE_EXTRA_FUNC();
	CvWString szTempBuffer;
	int iAttitudeChange;
	int iPass;
	int iI;
	const CvPlayerAI& kPlayer = GET_PLAYER(ePlayer);
	const TeamTypes eTeam = (TeamTypes) kPlayer.getTeam();
	const CvTeamAI& kTeam = GET_TEAM(eTeam);

	if (eTargetPlayer == NO_PLAYER)
	{
		FErrorMsg("TargetPlayer must be valid when requesting attitude string")
		return;
	}

	szBuffer.append(gDLL->getText("TXT_KEY_ATTITUDE_TOWARDS", GC.getAttitudeInfo(GET_PLAYER(ePlayer).AI_getAttitude(eTargetPlayer)).getTextKeyWide(), GET_PLAYER(eTargetPlayer).getNameKey()));

	for (int iTeam = 0; iTeam < MAX_TEAMS; iTeam++)
	{
		CvTeam& kLoopTeam = GET_TEAM((TeamTypes)iTeam);
		if (kLoopTeam.isAlive())
		{
			CvTeam& kTargetTeam = GET_TEAM(GET_PLAYER(eTargetPlayer).getTeam());
			if (kTargetTeam.isHasMet((TeamTypes)iTeam))
			{
				if (kTeam.isVassal((TeamTypes)iTeam))
				{
					szBuffer.append(NEWLINE);
					szBuffer.append(gDLL->getText("TXT_KEY_ATTITUDE_VASSAL_OF", kLoopTeam.getName().GetCString()));

					setVassalRevoltHelp(szBuffer, (TeamTypes)iTeam, kTeam.getID());
				}
				else if (kLoopTeam.isVassal(kTeam.getID()))
				{
					szBuffer.append(NEWLINE);
					szBuffer.append(gDLL->getText("TXT_KEY_ATTITUDE_MASTER_OF", kLoopTeam.getName().GetCString()));
				}
			}
		}
	}

	for (iPass = 0; iPass < 2; iPass++)
	{
		iAttitudeChange = kPlayer.AI_getTraitAttitude(eTargetPlayer);
		if ((iPass == 0) ? (iAttitudeChange > 0) : (iAttitudeChange < 0))
		{
			szTempBuffer.Format(SETCOLR L"%s" ENDCOLR, TEXT_COLOR((iAttitudeChange > 0) ? "COLOR_POSITIVE_TEXT" : "COLOR_NEGATIVE_TEXT"), gDLL->getText(((iAttitudeChange > 0) ? "TXT_KEY_MISC_ATTITUDE_TRAIT_GOOD" : "TXT_KEY_MISC_ATTITUDE_TRAIT_BAD"), iAttitudeChange).GetCString());
			szBuffer.append(NEWLINE);
			szBuffer.append(szTempBuffer);
		}

		iAttitudeChange = kPlayer.AI_getCloseBordersAttitude(eTargetPlayer);
		if ((iPass == 0) ? (iAttitudeChange > 0) : (iAttitudeChange < 0))
		{
			szTempBuffer.Format(SETCOLR L"%s" ENDCOLR, TEXT_COLOR((iAttitudeChange > 0) ? "COLOR_POSITIVE_TEXT" : "COLOR_NEGATIVE_TEXT"), gDLL->getText("TXT_KEY_MISC_ATTITUDE_LAND_TARGET", iAttitudeChange).GetCString());
			szBuffer.append(NEWLINE);
			szBuffer.append(szTempBuffer);
		}

		iAttitudeChange = kPlayer.AI_getWarAttitude(eTargetPlayer);
		if ((iPass == 0) ? (iAttitudeChange > 0) : (iAttitudeChange < 0))
		{
			szTempBuffer.Format(SETCOLR L"%s" ENDCOLR, TEXT_COLOR((iAttitudeChange > 0) ? "COLOR_POSITIVE_TEXT" : "COLOR_NEGATIVE_TEXT"), gDLL->getText("TXT_KEY_MISC_ATTITUDE_WAR", iAttitudeChange).GetCString());
			szBuffer.append(NEWLINE);
			szBuffer.append(szTempBuffer);
		}

		iAttitudeChange = kPlayer.AI_getPeaceAttitude(eTargetPlayer);
		if ((iPass == 0) ? (iAttitudeChange > 0) : (iAttitudeChange < 0))
		{
			szTempBuffer.Format(SETCOLR L"%s" ENDCOLR, TEXT_COLOR((iAttitudeChange > 0) ? "COLOR_POSITIVE_TEXT" : "COLOR_NEGATIVE_TEXT"), gDLL->getText("TXT_KEY_MISC_ATTITUDE_PEACE", iAttitudeChange).GetCString());
			szBuffer.append(NEWLINE);
			szBuffer.append(szTempBuffer);
		}

		iAttitudeChange = kPlayer.AI_getSameReligionAttitude(eTargetPlayer);
		if ((iPass == 0) ? (iAttitudeChange > 0) : (iAttitudeChange < 0))
		{
			szTempBuffer.Format(SETCOLR L"%s" ENDCOLR, TEXT_COLOR((iAttitudeChange > 0) ? "COLOR_POSITIVE_TEXT" : "COLOR_NEGATIVE_TEXT"), gDLL->getText("TXT_KEY_MISC_ATTITUDE_SAME_RELIGION", iAttitudeChange).GetCString());
			szBuffer.append(NEWLINE);
			szBuffer.append(szTempBuffer);
		}

		iAttitudeChange = kPlayer.AI_getDifferentReligionAttitude(eTargetPlayer);
		if ((iPass == 0) ? (iAttitudeChange > 0) : (iAttitudeChange < 0))
		{
			szTempBuffer.Format(SETCOLR L"%s" ENDCOLR, TEXT_COLOR((iAttitudeChange > 0) ? "COLOR_POSITIVE_TEXT" : "COLOR_NEGATIVE_TEXT"), gDLL->getText("TXT_KEY_MISC_ATTITUDE_DIFFERENT_RELIGION", iAttitudeChange).GetCString());
			szBuffer.append(NEWLINE);
			szBuffer.append(szTempBuffer);
		}

		iAttitudeChange = kPlayer.AI_getBonusTradeAttitude(eTargetPlayer);
		if ((iPass == 0) ? (iAttitudeChange > 0) : (iAttitudeChange < 0))
		{
			szTempBuffer.Format(SETCOLR L"%s" ENDCOLR, TEXT_COLOR((iAttitudeChange > 0) ? "COLOR_POSITIVE_TEXT" : "COLOR_NEGATIVE_TEXT"), gDLL->getText("TXT_KEY_MISC_ATTITUDE_BONUS_TRADE", iAttitudeChange).GetCString());
			szBuffer.append(NEWLINE);
			szBuffer.append(szTempBuffer);
		}

		iAttitudeChange = kPlayer.AI_getOpenBordersAttitude(eTargetPlayer);
		if ((iPass == 0) ? (iAttitudeChange > 0) : (iAttitudeChange < 0))
		{
			szTempBuffer.Format(SETCOLR L"%s" ENDCOLR, TEXT_COLOR((iAttitudeChange > 0) ? "COLOR_POSITIVE_TEXT" : "COLOR_NEGATIVE_TEXT"), gDLL->getText("TXT_KEY_MISC_ATTITUDE_OPEN_BORDERS", iAttitudeChange).GetCString());
			szBuffer.append(NEWLINE);
			szBuffer.append(szTempBuffer);
		}

		iAttitudeChange = kPlayer.AI_getDefensivePactAttitude(eTargetPlayer);
		if ((iPass == 0) ? (iAttitudeChange > 0) : (iAttitudeChange < 0))
		{
			szTempBuffer.Format(SETCOLR L"%s" ENDCOLR, TEXT_COLOR((iAttitudeChange > 0) ? "COLOR_POSITIVE_TEXT" : "COLOR_NEGATIVE_TEXT"), gDLL->getText("TXT_KEY_MISC_ATTITUDE_DEFENSIVE_PACT", iAttitudeChange).GetCString());
			szBuffer.append(NEWLINE);
			szBuffer.append(szTempBuffer);
		}

		iAttitudeChange = kPlayer.AI_getRivalDefensivePactAttitude(eTargetPlayer);
		if ((iPass == 0) ? (iAttitudeChange > 0) : (iAttitudeChange < 0))
		{
			szTempBuffer.Format(SETCOLR L"%s" ENDCOLR, TEXT_COLOR((iAttitudeChange > 0) ? "COLOR_POSITIVE_TEXT" : "COLOR_NEGATIVE_TEXT"), gDLL->getText("TXT_KEY_MISC_ATTITUDE_RIVAL_DEFENSIVE_PACT", iAttitudeChange).GetCString());
			szBuffer.append(NEWLINE);
			szBuffer.append(szTempBuffer);
		}

		iAttitudeChange = kPlayer.AI_getRivalVassalAttitude(eTargetPlayer);
		if ((iPass == 0) ? (iAttitudeChange > 0) : (iAttitudeChange < 0))
		{
			szTempBuffer.Format(SETCOLR L"%s" ENDCOLR, TEXT_COLOR((iAttitudeChange > 0) ? "COLOR_POSITIVE_TEXT" : "COLOR_NEGATIVE_TEXT"), gDLL->getText("TXT_KEY_MISC_ATTITUDE_RIVAL_VASSAL", iAttitudeChange).GetCString());
			szBuffer.append(NEWLINE);
			szBuffer.append(szTempBuffer);
		}

		iAttitudeChange = kPlayer.AI_getShareWarAttitude(eTargetPlayer);
		if ((iPass == 0) ? (iAttitudeChange > 0) : (iAttitudeChange < 0))
		{
			szTempBuffer.Format(SETCOLR L"%s" ENDCOLR, TEXT_COLOR((iAttitudeChange > 0) ? "COLOR_POSITIVE_TEXT" : "COLOR_NEGATIVE_TEXT"), gDLL->getText("TXT_KEY_MISC_ATTITUDE_SHARE_WAR", iAttitudeChange).GetCString());
			szBuffer.append(NEWLINE);
			szBuffer.append(szTempBuffer);
		}

		iAttitudeChange = kPlayer.AI_getFavoriteCivicAttitude(eTargetPlayer);
		if ((iPass == 0) ? (iAttitudeChange > 0) : (iAttitudeChange < 0))
		{
			szTempBuffer.Format(SETCOLR L"%s" ENDCOLR, TEXT_COLOR((iAttitudeChange > 0) ? "COLOR_POSITIVE_TEXT" : "COLOR_NEGATIVE_TEXT"), gDLL->getText("TXT_KEY_MISC_ATTITUDE_FAVORITE_CIVIC", iAttitudeChange).GetCString());
			szBuffer.append(NEWLINE);
			szBuffer.append(szTempBuffer);
		}

		iAttitudeChange = kPlayer.AI_getTradeAttitude(eTargetPlayer);
		if ((iPass == 0) ? (iAttitudeChange > 0) : (iAttitudeChange < 0))
		{
			szTempBuffer.Format(SETCOLR L"%s" ENDCOLR, TEXT_COLOR((iAttitudeChange > 0) ? "COLOR_POSITIVE_TEXT" : "COLOR_NEGATIVE_TEXT"), gDLL->getText("TXT_KEY_MISC_ATTITUDE_TRADE", iAttitudeChange).GetCString());
			szBuffer.append(NEWLINE);
			szBuffer.append(szTempBuffer);
		}

		iAttitudeChange = kPlayer.AI_getRivalTradeAttitude(eTargetPlayer);
		if ((iPass == 0) ? (iAttitudeChange > 0) : (iAttitudeChange < 0))
		{
			szTempBuffer.Format(SETCOLR L"%s" ENDCOLR, TEXT_COLOR((iAttitudeChange > 0) ? "COLOR_POSITIVE_TEXT" : "COLOR_NEGATIVE_TEXT"), gDLL->getText("TXT_KEY_MISC_ATTITUDE_RIVAL_TRADE", iAttitudeChange).GetCString());
			szBuffer.append(NEWLINE);
			szBuffer.append(szTempBuffer);
		}

		iAttitudeChange = GET_PLAYER(ePlayer).AI_getColonyAttitude(eTargetPlayer);
		if ((iPass == 0) ? (iAttitudeChange > 0) : (iAttitudeChange < 0))
		{
			szTempBuffer.Format(SETCOLR L"%s" ENDCOLR, TEXT_COLOR((iAttitudeChange > 0) ? "COLOR_POSITIVE_TEXT" : "COLOR_NEGATIVE_TEXT"), gDLL->getText("TXT_KEY_MISC_ATTITUDE_FREEDOM", iAttitudeChange).GetCString());
			szBuffer.append(NEWLINE);
			szBuffer.append(szTempBuffer);
		}

		iAttitudeChange = GET_PLAYER(ePlayer).AI_getAttitudeExtra(eTargetPlayer);
		if ((iPass == 0) ? (iAttitudeChange > 0) : (iAttitudeChange < 0))
		{
			szTempBuffer.Format(SETCOLR L"%s" ENDCOLR, TEXT_COLOR((iAttitudeChange > 0) ? "COLOR_POSITIVE_TEXT" : "COLOR_NEGATIVE_TEXT"), gDLL->getText(((iAttitudeChange > 0) ? "TXT_KEY_MISC_ATTITUDE_EXTRA_GOOD" : "TXT_KEY_MISC_ATTITUDE_EXTRA_BAD"), iAttitudeChange).GetCString());
			szBuffer.append(NEWLINE);
			szBuffer.append(szTempBuffer);
		}

		iAttitudeChange = GET_PLAYER(ePlayer).AI_getCivicShareAttitude(eTargetPlayer);
		if ((iPass == 0) ? (iAttitudeChange > 0) : (iAttitudeChange < 0))
		{
			if (GET_PLAYER(ePlayer).AI_getCivicShareAttitude(eTargetPlayer) > 0)
			{
				szTempBuffer.Format(SETCOLR L"%s" ENDCOLR, TEXT_COLOR((iAttitudeChange > 0) ? "COLOR_POSITIVE_TEXT" : "COLOR_NEGATIVE_TEXT"), gDLL->getText("TXT_KEY_MISC_ATTITUDE_CIVIC_SHARE_GOOD", iAttitudeChange).GetCString());
				szBuffer.append(NEWLINE);
				szBuffer.append(szTempBuffer);
			}
			if (GET_PLAYER(ePlayer).AI_getCivicShareAttitude(eTargetPlayer) < 0)
			{
				szTempBuffer.Format(SETCOLR L"%s" ENDCOLR, TEXT_COLOR((iAttitudeChange > 0) ? "COLOR_POSITIVE_TEXT" : "COLOR_NEGATIVE_TEXT"), gDLL->getText("TXT_KEY_MISC_ATTITUDE_CIVIC_SHARE_BAD", iAttitudeChange).GetCString());
				szBuffer.append(NEWLINE);
				szBuffer.append(szTempBuffer);
			}
		}
		iAttitudeChange = GET_PLAYER(ePlayer).AI_getEmbassyAttitude(eTargetPlayer);
		if ((iPass == 0) ? (iAttitudeChange > 0) : (iAttitudeChange < 0))
		{
			if (iAttitudeChange > 0)
			{
				szTempBuffer.Format(SETCOLR L"%s" ENDCOLR, TEXT_COLOR((iAttitudeChange > 0) ? "COLOR_POSITIVE_TEXT" : "COLOR_NEGATIVE_TEXT"), gDLL->getText("TXT_KEY_EMBASSY_DIPLOMACY_BONUS", iAttitudeChange).GetCString());
				szBuffer.append(NEWLINE);
				szBuffer.append(szTempBuffer);
			}
			else if (iAttitudeChange < 0)
			{
				szTempBuffer.Format(SETCOLR L"%s" ENDCOLR, TEXT_COLOR((iAttitudeChange > 0) ? "COLOR_POSITIVE_TEXT" : "COLOR_NEGATIVE_TEXT"), gDLL->getText("TXT_KEY_EMBASSY_DIPLOMACY_MALUS", iAttitudeChange).GetCString());
				szBuffer.append(NEWLINE);
				szBuffer.append(szTempBuffer);
			}
		}
		if (iPass == 0)
		{
			CivicTypes eTargetCivic;
			CivicTypes eCivic;
			int** ppaiCivicAttitudeChanges = new int*[GC.getNumCivicOptionInfos()];
			CvWString** ppaszCivicAttitudeReasons = new CvWString*[GC.getNumCivicOptionInfos()];
			for (int iJ = 0; iJ < GC.getNumCivicOptionInfos(); iJ++)
			{
				ppaiCivicAttitudeChanges[iJ] = new int[GC.getNumCivicOptionInfos()];
				ppaszCivicAttitudeReasons[iJ] = new CvWString[GC.getNumCivicOptionInfos()];
			}
			for (int iJ = 0; iJ < GC.getNumCivicOptionInfos(); iJ++)
			{
				eTargetCivic = GET_PLAYER(eTargetPlayer).getCivics((CivicOptionTypes)iJ);
				for (int iK = 0; iK < GC.getNumCivicOptionInfos(); iK++)
				{
					eCivic = GET_PLAYER(ePlayer).getCivics((CivicOptionTypes)iK);
					ppaiCivicAttitudeChanges[iJ][iK] = GC.getCivicInfo(eCivic).getCivicAttitudeChange(eTargetCivic);
					ppaszCivicAttitudeReasons[iJ][iK] = GC.getCivicInfo(eCivic).getCivicAttitudeReason(eTargetCivic);
				}
			}
			for (int iJ = 0; iJ < GC.getNumCivicOptionInfos(); iJ++)
			{
				for (int iK = 0; iK < GC.getNumCivicOptionInfos(); iK++)
				{
					for (int iL = iK + 1; iL < GC.getNumCivicOptionInfos(); iL++)
					{
						if (ppaszCivicAttitudeReasons[iJ][iK] == ppaszCivicAttitudeReasons[iJ][iL])
						{
							ppaiCivicAttitudeChanges[iJ][iK] += ppaiCivicAttitudeChanges[iJ][iL];
							ppaszCivicAttitudeReasons[iJ][iL].clear();
							ppaiCivicAttitudeChanges[iJ][iL] = 0;
						}
					}
				}
			}
			for (int iJ = 0; iJ < GC.getNumCivicOptionInfos(); iJ++)
			{
				for (int iK = 0; iK < GC.getNumCivicOptionInfos(); iK++)
				{
					if (ppaiCivicAttitudeChanges[iJ][iK] != 0 && !ppaszCivicAttitudeReasons[iJ][iK].empty())
					{
						szBuffer.append(NEWLINE);
						szTempBuffer.Format(SETCOLR L"%s" ENDCOLR, TEXT_COLOR((ppaiCivicAttitudeChanges[iJ][iK] > 0) ? "COLOR_POSITIVE_TEXT" : "COLOR_NEGATIVE_TEXT"), gDLL->getText(ppaszCivicAttitudeReasons[iJ][iK], ppaiCivicAttitudeChanges[iJ][iK]).GetCString());
						szBuffer.append(szTempBuffer);
					}
				}
			}
			for (int iJ = 0; iJ < GC.getNumCivicOptionInfos(); iJ++)
			{
				SAFE_DELETE_ARRAY(ppaiCivicAttitudeChanges[iJ]);
				SAFE_DELETE_ARRAY(ppaszCivicAttitudeReasons[iJ]);
			}
			SAFE_DELETE_ARRAY(ppaiCivicAttitudeChanges);
			SAFE_DELETE_ARRAY(ppaszCivicAttitudeReasons);
		}

		// BEGIN: Show Hidden Attitude Mod 01/22/2010
		if (GC.getDefineINT("SHOW_HIDDEN_ATTITUDE")
			&& getBugOptionBOOL("MiscHover__LeaderheadHiddenAttitude", true, "BUG_LEADERHEAD_HOVER_HIDDEN_ATTITUDE"))
		{
			iAttitudeChange = kPlayer.AI_getBetterRankDifferenceAttitude(eTargetPlayer);
			if ((iPass == 0) ? (iAttitudeChange > 0) : (iAttitudeChange < 0))
			{
				szTempBuffer.Format(SETCOLR L"%s" ENDCOLR, TEXT_COLOR((iAttitudeChange > 0) ? "COLOR_POSITIVE_TEXT" : "COLOR_NEGATIVE_TEXT"), gDLL->getText("TXT_KEY_MISC_ATTITUDE_BETTER_RANK", iAttitudeChange).GetCString());
				szBuffer.append(NEWLINE);
				szBuffer.append(szTempBuffer);
			}

			iAttitudeChange = kPlayer.AI_getWorseRankDifferenceAttitude(eTargetPlayer);
			if ((iPass == 0) ? (iAttitudeChange > 0) : (iAttitudeChange < 0))
			{
				szTempBuffer.Format(SETCOLR L"%s" ENDCOLR, TEXT_COLOR((iAttitudeChange > 0) ? "COLOR_POSITIVE_TEXT" : "COLOR_NEGATIVE_TEXT"), gDLL->getText("TXT_KEY_MISC_ATTITUDE_WORSE_RANK", iAttitudeChange).GetCString());
				szBuffer.append(NEWLINE);
				szBuffer.append(szTempBuffer);
			}

			iAttitudeChange = kPlayer.AI_getLowRankAttitude(eTargetPlayer);
			if ((iPass == 0) ? (iAttitudeChange > 0) : (iAttitudeChange < 0))
			{
				szTempBuffer.Format(SETCOLR L"%s" ENDCOLR, TEXT_COLOR((iAttitudeChange > 0) ? "COLOR_POSITIVE_TEXT" : "COLOR_NEGATIVE_TEXT"), gDLL->getText("TXT_KEY_MISC_ATTITUDE_LOW_RANK", iAttitudeChange).GetCString());
				szBuffer.append(NEWLINE);
				szBuffer.append(szTempBuffer);
			}

			iAttitudeChange = kPlayer.AI_getLostWarAttitude(eTargetPlayer);
			if ((iPass == 0) ? (iAttitudeChange > 0) : (iAttitudeChange < 0))
			{
				szTempBuffer.Format(SETCOLR L"%s" ENDCOLR, TEXT_COLOR((iAttitudeChange > 0) ? "COLOR_POSITIVE_TEXT" : "COLOR_NEGATIVE_TEXT"), gDLL->getText("TXT_KEY_MISC_ATTITUDE_LOST_WAR", iAttitudeChange).GetCString());
				szBuffer.append(NEWLINE);
				szBuffer.append(szTempBuffer);
			}

			iAttitudeChange = kPlayer.AI_getTeamSizeAttitude(eTargetPlayer);
			if ((iPass == 0) ? (iAttitudeChange > 0) : (iAttitudeChange < 0))
			{
				szTempBuffer.Format(SETCOLR L"%s" ENDCOLR, TEXT_COLOR((iAttitudeChange > 0) ? "COLOR_POSITIVE_TEXT" : "COLOR_NEGATIVE_TEXT"), gDLL->getText("TXT_KEY_MISC_ATTITUDE_TEAM_SIZE", iAttitudeChange).GetCString());
				szBuffer.append(NEWLINE);
				szBuffer.append(szTempBuffer);
			}

			iAttitudeChange = kPlayer.AI_getFirstImpressionAttitude(eTargetPlayer);
			if ((iPass == 0) ? (iAttitudeChange > 0) : (iAttitudeChange < 0))
			{
				szTempBuffer.Format(SETCOLR L"%s" ENDCOLR, TEXT_COLOR((iAttitudeChange > 0) ? "COLOR_POSITIVE_TEXT" : "COLOR_NEGATIVE_TEXT"), gDLL->getText("TXT_KEY_MISC_ATTITUDE_FIRST_IMPRESSION", iAttitudeChange).GetCString());
				szBuffer.append(NEWLINE);
				szBuffer.append(szTempBuffer);
			}
		}

		for (iI = 0; iI < NUM_MEMORY_TYPES; ++iI)
		{
			iAttitudeChange = kPlayer.AI_getMemoryAttitude(eTargetPlayer, ((MemoryTypes)iI));
			if ((iPass == 0) ? (iAttitudeChange > 0) : (iAttitudeChange < 0))
			{
				szTempBuffer.Format(SETCOLR L"%s" ENDCOLR, TEXT_COLOR((iAttitudeChange > 0) ? "COLOR_POSITIVE_TEXT" : "COLOR_NEGATIVE_TEXT"), gDLL->getText("TXT_KEY_MISC_ATTITUDE_MEMORY", iAttitudeChange, GC.getMemoryInfo((MemoryTypes)iI).getDescription()).GetCString());
				szBuffer.append(NEWLINE);
				szBuffer.append(szTempBuffer);
			}
		}
	}

	int iWarWeariness = GET_PLAYER(eTargetPlayer).getModifiedWarWearinessPercentAnger(GET_TEAM(GET_PLAYER(eTargetPlayer).getTeam()).getWarWeariness(eTeam) * std::max(0, 100 + kTeam.getEnemyWarWearinessModifier()));
	if (iWarWeariness / 10000 > 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_WAR_WEAR_HELP", iWarWeariness / 10000));
	}
}

void CvGameTextMgr::getEspionageString(CvWStringBuffer& szBuffer, PlayerTypes ePlayer, PlayerTypes eTargetPlayer)
{
	const TeamTypes eTeam = GET_PLAYER(ePlayer).getTeam();
	const CvPlayer& kTargetPlayer = GET_PLAYER(eTargetPlayer);

	szBuffer.append(
		gDLL->getText(
			"TXT_KEY_ESPIONAGE_AGAINST_PLAYER",
			kTargetPlayer.getNameKey(),
			GET_TEAM(eTeam).getEspionagePointsAgainstTeam(kTargetPlayer.getTeam()),
			GET_TEAM(kTargetPlayer.getTeam()).getEspionagePointsAgainstTeam(eTeam)
		)
	);
}

void CvGameTextMgr::getTradeString(CvWStringBuffer& szBuffer, const TradeData& tradeData, PlayerTypes ePlayer1, PlayerTypes ePlayer2)
{
	switch (tradeData.m_eItemType)
	{
	case TRADE_GOLD:
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_GOLD", tradeData.m_iData));
		break;
	case TRADE_GOLD_PER_TURN:
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_GOLD_PER_TURN", tradeData.m_iData));
		break;
	case TRADE_MAPS:
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_WORLD_MAP"));
		break;
	case TRADE_SURRENDER:
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_CAPITULATE"));
		break;
	case TRADE_VASSAL:
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_VASSAL"));
		break;
	case TRADE_OPEN_BORDERS:
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_OPEN_BORDERS"));
		break;
	case TRADE_DEFENSIVE_PACT:
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_DEFENSIVE_PACT"));
		break;
	case TRADE_PERMANENT_ALLIANCE:
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_PERMANENT_ALLIANCE"));
		break;
	case TRADE_PEACE_TREATY:
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_PEACE_TREATY", getTreatyLength()));
		break;
	case TRADE_TECHNOLOGIES:
		szBuffer.assign(CvWString::format(L"%s", GC.getTechInfo((TechTypes)tradeData.m_iData).getDescription()));
		break;
	case TRADE_RESOURCES:
		szBuffer.assign(CvWString::format(L"%s", GC.getBonusInfo((BonusTypes)tradeData.m_iData).getDescription()));
		break;
	case TRADE_CITIES:
		szBuffer.assign(CvWString::format(L"%s", GET_PLAYER(ePlayer1).getCity(tradeData.m_iData)->getName().GetCString()));
		break;
	case TRADE_PEACE:
	case TRADE_WAR:
	case TRADE_CONTACT:
	case TRADE_EMBARGO:
		szBuffer.assign(CvWString::format(L"%s", GET_TEAM((TeamTypes)tradeData.m_iData).getName().GetCString()));
		break;
	case TRADE_CIVIC:
		szBuffer.assign(CvWString::format(L"%s", GC.getCivicInfo((CivicTypes)tradeData.m_iData).getDescription()));
		break;
	case TRADE_RELIGION:
		szBuffer.assign(CvWString::format(L"%s", GC.getReligionInfo((ReligionTypes)tradeData.m_iData).getDescription()));
		break;
	case TRADE_WORKER:
	case TRADE_MILITARY_UNIT:
		szBuffer.assign(CvWString::format(L"%s", GET_PLAYER(ePlayer1).getUnit(tradeData.m_iData)->getName().GetCString()));
		break;
	case TRADE_EMBASSY:
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_EMBASSY"));
		break;
	case TRADE_CORPORATION:
		szBuffer.assign(CvWString::format(L"%s", GC.getCorporationInfo((CorporationTypes)tradeData.m_iData).getDescription()));
		break;
	case TRADE_SECRETARY_GENERAL_VOTE:
		szBuffer.assign(CvWString::format(L"%s", GC.getVoteSourceInfo((VoteSourceTypes)tradeData.m_iData).getDescription()));
		break;
	case TRADE_RITE_OF_PASSAGE:
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_LIMITED_BORDERS"));
		break;
	case TRADE_FREE_TRADE_ZONE:
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_FREE_TRADE_ZONE"));
		break;
	default:
		FErrorMsg("error");
		break;
	}
}

void CvGameTextMgr::setFeatureHelp(CvWStringBuffer &szBuffer, FeatureTypes eFeature, bool bCivilopediaText)
{
	PROFILE_EXTRA_FUNC();
	if (NO_FEATURE == eFeature)
	{
		return;
	}
	const CvFeatureInfo& feature = GC.getFeatureInfo(eFeature);

	int aiYields[NUM_YIELD_TYPES];
	if (!bCivilopediaText)
	{
		szBuffer.append(feature.getDescription());

		for (int iI = 0; iI < NUM_YIELD_TYPES; ++iI)
		{
			aiYields[iI] = feature.getYieldChange(iI);
		}
		setYieldChangeHelp(szBuffer, L"", L"", L"", aiYields);
	}
	for (int iI = 0; iI < NUM_YIELD_TYPES; ++iI)
	{
		aiYields[iI] = feature.getRiverYieldChange(iI);
	}
	setYieldChangeHelp(szBuffer, L"", L"", gDLL->getText("TXT_KEY_TERRAINHELP_NEXT_TO_RIVER"), aiYields);


	if (feature.getMovementCost() != 0)
	{
		szBuffer.append(gDLL->getText("TXT_KEY_TERRAINHELP_MOVEMENT_COST", feature.getMovementCost()));
	}

	CvWString szHealth;
	szHealth.Format(L"%.2f", 0.01f * abs(feature.getHealthPercent()));
	if (feature.getHealthPercent() > 0)
	{
		szBuffer.append(gDLL->getText("TXT_KEY_FEATUREHRLP_GOOD_HEALTH", szHealth.GetCString()));
	}
	else if (feature.getHealthPercent() < 0)
	{
		szBuffer.append(gDLL->getText("TXT_KEY_FEATUREHELP_BAD_HEALTH", szHealth.GetCString()));
	}

	if (feature.getDefenseModifier() != 0)
	{
		szBuffer.append(gDLL->getText("TXT_KEY_TERRAINHELP_DEFENSE_MODIFIER", feature.getDefenseModifier()));
	}

	if (feature.isAddsFreshWater())
	{
		szBuffer.append(gDLL->getText("TXT_KEY_FEATUREHELP_ADDS_FRESH_WATER"));
	}

	if (feature.isImpassable())
	{
		szBuffer.append(gDLL->getText("TXT_KEY_TERRAINHELP_IMPASSABLE"));
	}

	if (feature.isNoCity())
	{
		szBuffer.append(gDLL->getText("TXT_KEY_TERRAINHELP_NO_CITIES"));
	}

	if (feature.isNoImprovement())
	{
		szBuffer.append(gDLL->getText("TXT_KEY_FEATUREHELP_NO_IMPROVEMENT"));
	}

	if (feature.isNoBonus())
	{
		szBuffer.append(gDLL->getText("TXT_KEY_FEATUREHELP_NO_BONUS"));
	}

	if (feature.getPopDestroys() == -1)
	{
		szBuffer.append(gDLL->getText("TXT_KEY_FEATUREHELP_POP_NEVER_DESTROYED"));
	}

	if (feature.getPopDestroys() > -1 && feature.getPopDestroys() < 2)
	{
		szBuffer.append(gDLL->getText("TXT_KEY_FEATUREHELP_POP_ALWAYS_DESTROYED"));
	}

	if (feature.getPopDestroys() > 1)
	{
		szBuffer.append(gDLL->getText("TXT_KEY_FEATUREHELP_POP_DESTROYS", feature.getPopDestroys()));
	}

	const int iDamage = feature.getTurnDamage();
	if (iDamage > 0)
	{
		szBuffer.append(gDLL->getText("TXT_KEY_TERRAINHELP_TURN_DAMAGE", iDamage));
	}

	feature.getPropertyManipulators()->buildDisplayString(szBuffer);

	if (bCivilopediaText)
	{
		foreach_(const MapCategoryTypes eMapCategory, GC.getFeatureInfo(eFeature).getMapCategories())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_MAP_CATEGORY_PREREQUISITE", GC.getMapCategoryInfo(eMapCategory).getTextKeyWide()));
		}
	}

}


void CvGameTextMgr::setTerrainHelp(CvWStringBuffer &szBuffer, TerrainTypes eTerrain, bool bCivilopediaText)
{
	PROFILE_EXTRA_FUNC();
	if (NO_TERRAIN == eTerrain)
	{
		return;
	}
	const CvTerrainInfo& terrain = GC.getTerrainInfo(eTerrain);

	int aiYields[NUM_YIELD_TYPES];
	if (!bCivilopediaText)
	{
		szBuffer.append(terrain.getDescription());

		for (int iI = 0; iI < NUM_YIELD_TYPES; ++iI)
		{
			aiYields[iI] = terrain.getYield(iI);
		}
		setYieldChangeHelp(szBuffer, L"", L"", L"", aiYields);
	}

	if (terrain.getMovementCost() != 0)
	{
		szBuffer.append(gDLL->getText("TXT_KEY_TERRAINHELP_MOVEMENT_COST", terrain.getMovementCost()));
	}

	if (terrain.getBuildModifier() != 0)
	{
		szBuffer.append(gDLL->getText("TXT_KEY_TERRAINHELP_BUILD_MODIFIER", terrain.getBuildModifier()));
	}

	if (terrain.getDefenseModifier() != 0)
	{
		szBuffer.append(gDLL->getText("TXT_KEY_TERRAINHELP_DEFENSE_MODIFIER", terrain.getDefenseModifier()));
	}

	if (terrain.isImpassable())
	{
		szBuffer.append(gDLL->getText("TXT_KEY_TERRAINHELP_IMPASSABLE"));
	}
	if (!terrain.isFound())
	{
		szBuffer.append(gDLL->getText("TXT_KEY_TERRAINHELP_NO_CITIES"));
		bool bFirst = true;
		if (terrain.isFoundCoast())
		{
			szBuffer.append(gDLL->getText("TXT_KEY_TERRAINHELP_COASTAL_CITIES"));
			bFirst = false;
		}
		if (!bFirst)
		{
			szBuffer.append(gDLL->getText("TXT_KEY_OR"));
		}
		if (terrain.isFoundFreshWater())
		{
			szBuffer.append(gDLL->getText("TXT_KEY_TERRAINHELP_FRESH_WATER_CITIES"));
			bFirst = false;
		}
	}

	if (GC.getGame().isModderGameOption(MODDERGAMEOPTION_TERRAIN_DAMAGE))
	{
		const int iDamage = -terrain.getHealthPercent();
		if (iDamage != 0)
		{
			szBuffer.append(gDLL->getText("TXT_KEY_TERRAINHELP_TURN_DAMAGE", iDamage));
		}
	}

	terrain.getPropertyManipulators()->buildDisplayString(szBuffer);

	if (bCivilopediaText)
	{
		foreach_(const MapCategoryTypes eMapCategory, terrain.getMapCategories())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_MAP_CATEGORY_TERRAIN", GC.getMapCategoryInfo(eMapCategory).getTextKeyWide()));
		}
	}
}


void CvGameTextMgr::buildFinanceSpecialistGoldString(CvWStringBuffer& szBuffer, PlayerTypes ePlayer) const
{
	PROFILE_EXTRA_FUNC();
	if (NO_PLAYER == ePlayer)
	{
		return;
	}
	const CvPlayer& player = GET_PLAYER(ePlayer);

	int* iCounts = new int[GC.getNumSpecialistInfos()];
	for (int iI = 0; iI < GC.getNumSpecialistInfos(); iI++)
	{
		iCounts[iI] = 0;
	}
	int iTotalSpecialists = 0;
	foreach_(const CvCity* pCity, player.cities())
	{
		int iCityGold = 0;
		if (!pCity->isDisorder())
		{
			for (int iI = 0; iI < GC.getNumSpecialistInfos(); iI++)
			{
				iCounts[iI] += pCity->getSpecialistCount((SpecialistTypes)iI) + pCity->getFreeSpecialistCount((SpecialistTypes)iI);

				iCityGold += ((pCity->getSpecialistCount((SpecialistTypes)iI) + pCity->getFreeSpecialistCount((SpecialistTypes)iI))*player.specialistCommerceTimes100((SpecialistTypes)iI, COMMERCE_GOLD))/100;
			}

			iTotalSpecialists += pCity->getSpecialistPopulation() + pCity->getNumGreatPeople();
		}
	}

	bool bFirst = true;
	int iTotal = 0;
	for (int iI = 0; iI < GC.getNumSpecialistInfos(); iI++)
	{
		int iGold = (iCounts[iI] * player.specialistCommerceTimes100((SpecialistTypes)iI, COMMERCE_GOLD));
		if (iGold != 0)
		{
			if (bFirst)
			{
				szBuffer.append(NEWLINE);
				bFirst = false;
			}

			CvWString buf;

			buf.Format(L"%d.%02d",iGold/100, iGold%100);
			szBuffer.append(gDLL->getText("TXT_KEY_BUG_FINANCIAL_ADVISOR_SPECIALIST_GOLD", buf.GetCString(), iCounts[iI], GC.getSpecialistInfo((SpecialistTypes)iI).getDescription()));
			iTotal += iGold;
		}
	}

	szBuffer.append(gDLL->getText("TXT_KEY_BUG_FINANCIAL_ADVISOR_SPECIALIST_TOTAL_GOLD", iTotal/100));
	SAFE_DELETE_ARRAY(iCounts);
}


void CvGameTextMgr::buildFinanceInflationString(CvWStringBuffer& szBuffer, PlayerTypes ePlayer) const
{
	if (NO_PLAYER == ePlayer)
	{
		return;
	}
	const CvPlayer& kPlayer = GET_PLAYER(ePlayer);

	const long long iInflationCost = kPlayer.getInflationCost();
	if (iInflationCost > 0)
	{
		const int iInflationRate10000 = kPlayer.getInflationMod10000();
		const int iInflationRateInt = iInflationRate10000 / 100 - 100;
		const int iInflationRateDec = iInflationRate10000 % 100;
		const long long iPreInflation = kPlayer.calculatePreInflatedCosts();
		szBuffer.append(gDLL->getText("TXT_KEY_FINANCE_ADVISOR_INFLATION_0", iPreInflation));
		szBuffer.append(gDLL->getText("TXT_KEY_FINANCE_ADVISOR_INFLATION_1", iInflationRateInt, iInflationRateDec, iInflationCost));
		szBuffer.append(gDLL->getText("TXT_KEY_FINANCE_ADVISOR_SOURCES_OF_INFLATION", kPlayer.getCivicInflation(), kPlayer.getTechInflation(), kPlayer.getBuildingInflation(), kPlayer.getProjectInflation(), kPlayer.getHurriedCount()));
	}
}

void CvGameTextMgr::buildFinanceUnitUpkeepString(CvWStringBuffer& szBuffer, PlayerTypes ePlayer) const
{
	PROFILE_EXTRA_FUNC();
	if (NO_PLAYER == ePlayer)
	{
		return;
	}
	const CvPlayer& player = GET_PLAYER(ePlayer);

	int iCivicModCivilian = 0;
	int iCivicModMilitary = 0;
	for (int iI = 0; iI < GC.getNumCivicOptionInfos(); ++iI)
	{
		const CivicTypes eCivic = player.getCivics((CivicOptionTypes)iI);
		if (NO_CIVIC != eCivic)
		{
			iCivicModCivilian += GC.getCivicInfo(eCivic).getCivilianUnitUpkeepMod();
			iCivicModMilitary += GC.getCivicInfo(eCivic).getMilitaryUnitUpkeepMod();
		}
	}

	int iTraitModCivilian = 0;
	int iTraitModMilitary = 0;
	for (int iI = 0; iI < GC.getNumTraitInfos(); iI++)
	{
		const TraitTypes eTrait = (TraitTypes) iI;
		if (player.hasTrait(eTrait))
		{
			iTraitModCivilian += GC.getTraitInfo(eTrait).getCivilianUnitUpkeepMod();
			iTraitModMilitary += GC.getTraitInfo(eTrait).getMilitaryUnitUpkeepMod();
		}
	}

	// Civilian section
	const int64_t iUpkeepCivilian100 = player.getUnitUpkeepCivilian100();

	szBuffer.append(gDLL->getText("TXT_KEY_FINANCE_ADVISOR_UNIT_UPKEEP_CIVILIAN", CvWString::format(L"%.2f", iUpkeepCivilian100 / 100.0).GetCString()));

	if (iCivicModCivilian != 0)
	{
		int64_t iCivicCivilian = 0;
		if (iCivicModCivilian > 0)
		{
			iCivicCivilian = iUpkeepCivilian100 * (100 + iCivicModCivilian) / 100 - iUpkeepCivilian100;
		}
		else if (iCivicModCivilian < 0)
		{
			iCivicCivilian = iUpkeepCivilian100 * 100 / (100 - iCivicModCivilian) - iUpkeepCivilian100;
		}

		if (iCivicCivilian != 0)
		{
			szBuffer.append(gDLL->getText("TXT_KEY_FINANCE_ADVISOR_UNIT_UPKEEP_MOD_CIVIC", CvWString::format(L"%.2f", iCivicCivilian / 100.0).GetCString()));
		}
	}
	if (iTraitModCivilian != 0)
	{
		int64_t iTraitCivilian = 0;
		if (iTraitModCivilian > 0)
		{
			iTraitCivilian = iUpkeepCivilian100 * (100 + iTraitModCivilian) / 100 - iUpkeepCivilian100;
		}
		else if (iTraitModCivilian < 0)
		{
			iTraitCivilian = iUpkeepCivilian100 * 100 / (100 - iTraitModCivilian) - iUpkeepCivilian100;
		}

		if (iTraitCivilian != 0)
		{
			szBuffer.append(gDLL->getText("TXT_KEY_FINANCE_ADVISOR_UNIT_UPKEEP_MOD_TRAIT", CvWString::format(L"%.2f", iTraitCivilian / 100.0).GetCString()));
		}
	}
	szBuffer.append(gDLL->getText("TXT_KEY_FINANCE_ADVISOR_UNIT_UPKEEP_FREE", player.getFreeUnitUpkeepCivilian()));

	const int64_t iUpkeepCivilianNet = player.getUnitUpkeepCivilianNet();

	szBuffer.append(gDLL->getText("TXT_KEY_FINANCE_ADVISOR_UNIT_UPKEEP_TOTAL_1", iUpkeepCivilianNet));

	// Military section
	szBuffer.append(NEWLINE);
	const int64_t iUpkeepMilitary100 = player.getUnitUpkeepMilitary100();

	szBuffer.append(gDLL->getText("TXT_KEY_FINANCE_ADVISOR_UNIT_UPKEEP_MILITARY", CvWString::format(L"%.2f", iUpkeepMilitary100 / 100.0).GetCString()));

	if (iCivicModMilitary != 0)
	{
		int64_t iCivicMilitary = 0;
		if (iCivicModMilitary > 0)
		{
			iCivicMilitary = iUpkeepMilitary100 * (100 + iCivicModMilitary) / 100 - iUpkeepMilitary100;
		}
		else if (iCivicModMilitary < 0)
		{
			iCivicMilitary = iUpkeepMilitary100 * 100 / (100 - iCivicModMilitary) - iUpkeepMilitary100;
		}

		if (iCivicMilitary != 0)
		{
			szBuffer.append(gDLL->getText("TXT_KEY_FINANCE_ADVISOR_UNIT_UPKEEP_MOD_CIVIC", CvWString::format(L"%.2f", iCivicMilitary / 100.0).GetCString()));
		}
	}
	if (iTraitModMilitary != 0)
	{
		int64_t iTraitMilitary = 0;
		if (iTraitModMilitary > 0)
		{
			iTraitMilitary = iUpkeepMilitary100 * (100 + iTraitModMilitary) / 100 - iUpkeepMilitary100;
		}
		else if (iTraitModMilitary < 0)
		{
			iTraitMilitary = iUpkeepMilitary100 * 100 / (100 - iTraitModMilitary) - iUpkeepMilitary100;
		}

		if (iTraitMilitary != 0)
		{
			szBuffer.append(gDLL->getText("TXT_KEY_FINANCE_ADVISOR_UNIT_UPKEEP_MOD_TRAIT", CvWString::format(L"%.2f", iTraitMilitary / 100.0).GetCString()));
		}
	}
	szBuffer.append(gDLL->getText("TXT_KEY_FINANCE_ADVISOR_UNIT_UPKEEP_FREE", player.getFreeUnitUpkeepMilitary()));

	const int64_t iUnitUpkeepMilitaryNet = player.getUnitUpkeepMilitaryNet();

	szBuffer.append(gDLL->getText("TXT_KEY_FINANCE_ADVISOR_UNIT_UPKEEP_TOTAL_1", iUnitUpkeepMilitaryNet));

	// End Section
	const int64_t iHandicap = player.getFinalUnitUpkeep() - iUpkeepCivilianNet - iUnitUpkeepMilitaryNet;
	if (iHandicap != 0)
	{
		szBuffer.append(gDLL->getText("TXT_KEY_FINANCE_ADVISOR_UNIT_UPKEEP_HANDICAP_ADJUSTMENT", iHandicap));
	}
	szBuffer.append(gDLL->getText("TXT_KEY_FINANCE_ADVISOR_UNIT_UPKEEP_TOTAL_2", player.getFinalUnitUpkeep()));
}

void CvGameTextMgr::buildFinanceAwaySupplyString(CvWStringBuffer& szBuffer, PlayerTypes ePlayer) const
{
	if (NO_PLAYER == ePlayer)
	{
		return;
	}
	const CvPlayer& player = GET_PLAYER(ePlayer);

	int iPaidUnits = 0;
	int iBaseCost = 0;
	const int iCost = player.calculateUnitSupply(iPaidUnits, iBaseCost);
	const int iHandicap = iCost - iBaseCost;

	CvWString szHandicap;
	if (iHandicap != 0)
	{
		szHandicap = gDLL->getText("TXT_KEY_FINANCE_ADVISOR_HANDICAP_COST", iHandicap);
	}
	szBuffer.append(NEWLINE);
	szBuffer.append(gDLL->getText("TXT_KEY_FINANCE_ADVISOR_SUPPLY_COST", iPaidUnits, GC.getDefineINT("INITIAL_FREE_OUTSIDE_UNITS"), iBaseCost, szHandicap.GetCString(), iCost));
}

void CvGameTextMgr::buildFinanceCityMaintString(CvWStringBuffer& szBuffer, PlayerTypes ePlayer) const
{
	PROFILE_EXTRA_FUNC();
	if (NO_PLAYER == ePlayer)
	{
		return;
	}
	int iBaseMaint = 0;
	int iDistanceMaint = 0;
	int iNumCityMaint = 0;
	int iColonyMaint = 0;
	int iCorporationMaint = 0;
	int iBuildingMaint = 0;

	const CvPlayer& player = GET_PLAYER(ePlayer);

	const int iBase = GC.getEraInfo(player.getCurrentEra()).getInitialCityMaintenancePercent();

	foreach_(const CvCity* pLoopCity, player.cities())
	{
		iBaseMaint += iBase;

		if (!pLoopCity->isDisorder() && !pLoopCity->isWeLoveTheKingDay() && pLoopCity->getPopulation() > 0)
		{
			const int iMod = pLoopCity->getEffectiveMaintenanceModifier();

			iDistanceMaint += getModifiedIntValue(pLoopCity->calculateDistanceMaintenanceTimes100(), iMod);
			iNumCityMaint += getModifiedIntValue(pLoopCity->calculateNumCitiesMaintenanceTimes100(), iMod);
			iColonyMaint += getModifiedIntValue(pLoopCity->calculateColonyMaintenanceTimes100(), iMod);
			iCorporationMaint += getModifiedIntValue(pLoopCity->calculateCorporationMaintenanceTimes100(), iMod);
			iBuildingMaint += getModifiedIntValue(pLoopCity->calculateBuildingMaintenanceTimes100(), iMod);
		}
	}

	if (iBaseMaint != 0)
	{
		CvWString szMaint = CvWString::format(L"%d.%02d", iBaseMaint/100, iBaseMaint%100);
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_BASE_MAINTENANCE", szMaint.GetCString()));
	}
	if (iDistanceMaint != 0)
	{
		CvWString szMaint = CvWString::format(L"%d.%02d", iDistanceMaint/100, iDistanceMaint%100);
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_FINANCE_ADVISOR_CITY_MAINT_COST_DISTANCE", szMaint.GetCString()));
	}
	if (iNumCityMaint != 0)
	{
		CvWString szMaint = CvWString::format(L"%d.%02d", iNumCityMaint/100, iNumCityMaint%100);
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_NUM_CITIES_FLOAT", szMaint.GetCString()));
	}
	if (iColonyMaint != 0)
	{
		CvWString szMaint = CvWString::format(L"%d.%02d", iColonyMaint/100, iColonyMaint%100);
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_COLONY_MAINT_FLOAT", szMaint.GetCString()));
	}
	if (iCorporationMaint != 0)
	{
		CvWString szMaint = CvWString::format(L"%d.%02d", iCorporationMaint/100, iCorporationMaint%100);
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_CORPORATION_MAINT_FLOAT", szMaint.GetCString()));
	}
	if (iBuildingMaint != 0)
	{
		CvWString szMaint = CvWString::format(L"%d.%02d", iBuildingMaint/100, iBuildingMaint%100);
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_BUILDING_MAINT_FLOAT", szMaint.GetCString()));
	}
	const int iTotal = player.getTotalMaintenance();
	if (iTotal != 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_FINANCE_ADVISOR_CITY_MAINT_COST_TOTAL", iTotal));
	}
}

void CvGameTextMgr::buildFinanceCivicUpkeepString(CvWStringBuffer& szBuffer, PlayerTypes ePlayer) const
{
	PROFILE_EXTRA_FUNC();
	if (NO_PLAYER == ePlayer)
	{
		return;
	}
	const CvPlayer& player = GET_PLAYER(ePlayer);
	CvWString szCivicOptionCosts;
	for (int iI = 0; iI < GC.getNumCivicOptionInfos(); ++iI)
	{
		const CivicTypes eCivic = player.getCivics((CivicOptionTypes)iI);
		if (NO_CIVIC != eCivic)
		{
			CvWString szTemp;
			szTemp.Format(L"%d%c: %s", player.getSingleCivicUpkeep(eCivic), GC.getCommerceInfo(COMMERCE_GOLD).getChar(),  GC.getCivicInfo(eCivic).getDescription());
			szCivicOptionCosts += NEWLINE + szTemp;
		}
	}

	szBuffer.append(NEWLINE);
	szBuffer.append(gDLL->getText("TXT_KEY_FINANCE_ADVISOR_CIVIC_UPKEEP_COST", szCivicOptionCosts.GetCString(), player.getCivicUpkeep()));
}

void CvGameTextMgr::buildFinanceForeignIncomeString(CvWStringBuffer& szBuffer, PlayerTypes ePlayer) const
{
	PROFILE_EXTRA_FUNC();
	if (NO_PLAYER == ePlayer)
	{
		return;
	}
	const CvPlayer& player = GET_PLAYER(ePlayer);

	CvWString szPlayerIncome;
	for (int iI = 0; iI < MAX_PLAYERS; iI++)
	{
		const CvPlayer& otherPlayer = GET_PLAYER((PlayerTypes)iI);
		if (otherPlayer.isAlive() && player.getGoldPerTurnByPlayer((PlayerTypes)iI) != 0)
		{
			CvWString szTemp;
			szTemp.Format(L"%d%c: %s", player.getGoldPerTurnByPlayer((PlayerTypes)iI), GC.getCommerceInfo(COMMERCE_GOLD).getChar(), otherPlayer.getCivilizationShortDescription());
			szPlayerIncome += NEWLINE + szTemp;
		}
	}
	if (!szPlayerIncome.empty())
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_FINANCE_ADVISOR_FOREIGN_INCOME", szPlayerIncome.GetCString(), player.getGoldPerTurn()));
	}
}


/*
	+14 from Worked Tiles
	+2 from Specialists
	+5 from Corporations
	+1 from Buildings
	----------------------- |
	Base Food Produced: 22  |-- only if there are modifiers
	+25% from Buildings	 |
	-----------------------
	Total Food Produced: 27
	=======================
	+16 for Population
	+2 for Health
	-----------------------
	Total Food Consumed: 18
	=======================
	Net Food: +9			or
	Net Food for Settler: 9
	=======================
	* Lighthouse: +3
	* Supermarket: +1
*/
void CvGameTextMgr::setFoodHelp(CvWStringBuffer &szBuffer, CvCity& city)
{
	FAssertMsg(NO_PLAYER != city.getOwner(), "City must have an owner");

	int iRate = city.getYieldRate(YIELD_FOOD);

	// shows Base Food and lists all modifiers
	setYieldHelp(szBuffer, city, YIELD_FOOD);

	szBuffer.append(DOUBLE_SEPARATOR);

	int iFoodConsumed = 0;

	// Eaten
	int iEatenFood = city.getFoodConsumedByPopulation();
	if (iEatenFood != 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_HELP_EATEN_FOOD", iEatenFood));
		iFoodConsumed += iEatenFood;
	}

	// Wasted
	int iWastedFood = (int)city.foodWastage();
	if (iWastedFood != 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_HELP_WASTED_FOOD", iWastedFood));
		iFoodConsumed += iWastedFood;
	}

	// Health
	int iSpoiledFood = - city.healthRate();
	if (iSpoiledFood != 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_HELP_SPOILED_FOOD", iSpoiledFood));
		iFoodConsumed += iSpoiledFood;
	}

	// Total Consumed
	szBuffer.append(NEWLINE);
	szBuffer.append(gDLL->getText("TXT_KEY_MISC_HELP_TOTAL_FOOD_CONSUMED", iFoodConsumed));

	// ==========================
	szBuffer.append(DOUBLE_SEPARATOR NEWLINE);
	iRate -= iFoodConsumed;

	// Production
	if (city.isFoodProduction() && iRate > 0)
	{
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_HELP_NET_FOOD_PRODUCTION", iRate, city.getProductionNameKey()));
	}
	else
	{
		// cannot starve a size 1 city with no food in
		if (iRate < 0 && city.getPopulation() == 1 && city.getFood() == 0)
		{
			iRate = 0;
		}

		// Net Food
		if (iRate > 0)
		{
			szBuffer.append(gDLL->getText("TXT_KEY_MISC_HELP_NET_FOOD_GROW", iRate));
		}
		else if (iRate < 0)
		{
			szBuffer.append(gDLL->getText("TXT_KEY_MISC_HELP_NET_FOOD_SHRINK", iRate));
		}
		else
		{
			szBuffer.append(gDLL->getText("TXT_KEY_MISC_HELP_NET_FOOD_STAGNATE"));
		}
	}

	if (city.getOwner() == GC.getGame().getActivePlayer() && getBugOptionBOOL("MiscHover__BuildingAdditionalFood", true, "BUG_BUILDING_ADDITIONAL_FOOD_HOVER"))
	{
		setBuildingAdditionalYieldHelp(szBuffer, city, YIELD_FOOD, DOUBLE_SEPARATOR);
	}
}


// BUG - Building Additional Yield - start
bool CvGameTextMgr::setBuildingAdditionalYieldHelp(CvWStringBuffer &szBuffer, CvCity& city, YieldTypes eIndex, const CvWString& szStart, bool bStarted)
{
	PROFILE_EXTRA_FUNC();
	const CvYieldInfo& info = GC.getYieldInfo(eIndex);

	for (int i = 0; i < GC.getNumBuildingInfos(); i++)
	{
		const BuildingTypes eBuilding = static_cast<BuildingTypes>(i);

		if (city.canConstruct(eBuilding, false, false, false))
		{
			const int iChange = city.getAdditionalYieldByBuilding(eIndex, eBuilding);

			if (iChange != 0)
			{
				if (!bStarted)
				{
					szBuffer.append(szStart);
					bStarted = true;
				}

				CvWString szLabel;
				szLabel.Format(SETCOLR L"%s" ENDCOLR, TEXT_COLOR("COLOR_BUILDING_TEXT"), GC.getBuildingInfo(eBuilding).getDescription());
				setResumableValueChangeHelp(szBuffer, szLabel, L": ", L"", iChange, info.getChar(), false, true);
			}
		}
	}

	return bStarted;
}
// BUG - Building Additional Yield - end

// BUG - Building Additional Commerce - start
bool CvGameTextMgr::setBuildingAdditionalCommerceHelp(CvWStringBuffer &szBuffer, CvCity& city, CommerceTypes eIndex, const CvWString& szStart, bool bStarted)
{
	PROFILE_EXTRA_FUNC();
	const CvCommerceInfo& info = GC.getCommerceInfo(eIndex);

	for (int i = 0; i < GC.getNumBuildingInfos(); i++)
	{
		const BuildingTypes eBuilding = static_cast<BuildingTypes>(i);

		if (city.canConstruct(eBuilding, false, false, false))
		{
			int iChange = city.getAdditionalCommerceTimes100ByBuilding(eIndex, eBuilding);
			const int iCommerce = city.getAdditionalYieldByBuilding(YIELD_COMMERCE, eBuilding);
			iChange += iCommerce * GET_PLAYER(city.getOwner()).getCommercePercent(eIndex);

			if (iChange != 0)
			{
				if (!bStarted)
				{
					szBuffer.append(szStart);
					bStarted = true;
				}

				CvWString szLabel;
				szLabel.Format(SETCOLR L"%s" ENDCOLR, TEXT_COLOR("COLOR_BUILDING_TEXT"), GC.getBuildingInfo(eBuilding).getDescription());
				setResumableValueTimes100ChangeHelp(szBuffer, szLabel, L": ", L"", iChange, info.getChar(), true);
			}
		}
	}
	// BUG jdog5000 - need to verify building type is correct for this player to avoid asserts - end

	return bStarted;
}
// BUG - Building Additional Commerce - end

// BUG - Building Saved Maintenance - start
bool CvGameTextMgr::setBuildingSavedMaintenanceHelp(CvWStringBuffer &szBuffer, const CvCity& city, const CvWString& szStart, bool bStarted)
{
	PROFILE_EXTRA_FUNC();
	const CvCommerceInfo& info = GC.getCommerceInfo(COMMERCE_GOLD);

	for (int i = 0; i < GC.getNumBuildingInfos(); i++)
	{
		const BuildingTypes eBuilding = static_cast<BuildingTypes>(i);

		if (city.canConstruct(eBuilding, false, false, false))
		{
			const int iChange = -city.getSavedMaintenanceTimes100ByBuilding(eBuilding); //Afforess: saved maintenance is displayed as negative in hover

			if (iChange != 0)
			{
				if (!bStarted)
				{
					szBuffer.append(szStart);
					bStarted = true;
				}

				CvWString szLabel;
				szLabel.Format(SETCOLR L"%s" ENDCOLR, TEXT_COLOR("COLOR_BUILDING_TEXT"), GC.getBuildingInfo(eBuilding).getDescription());
				setResumableValueTimes100ChangeHelp(szBuffer, szLabel, L": ", L"", iChange, info.getChar(), true);
			}
		}
	}

	return bStarted;
}
// BUG - Building Saved Maintenance - end

void CvGameTextMgr::setProductionHelp(CvWStringBuffer &szBuffer, CvCity& city)
{
	FAssertMsg(NO_PLAYER != city.getOwner(), "City must have an owner");

	setYieldHelp(szBuffer, city, YIELD_PRODUCTION);

	if (city.getOwner() == GC.getGame().getActivePlayer()
	&& getBugOptionBOOL("MiscHover__BuildingAdditionalProduction", true, "BUG_BUILDING_ADDITIONAL_PRODUCTION_HOVER"))
	{
		setBuildingAdditionalYieldHelp(szBuffer, city, YIELD_PRODUCTION, DOUBLE_SEPARATOR);
	}
}


void CvGameTextMgr::parsePlayerTraits(CvWStringBuffer &szBuffer, PlayerTypes ePlayer)
{
	PROFILE_EXTRA_FUNC();

	CvPlayer& kPlayer = GET_PLAYER(ePlayer);
	{
		bool bStarted = false;
		const int iNumTraitInfos = GC.getNumTraitInfos();
		for (int i = 0; i < iNumTraitInfos; ++i)
		{
			if (kPlayer.hasTrait(static_cast<TraitTypes>(i)))
			{
				if (bStarted) szBuffer.append(L", ");
				else bStarted = true;

				szBuffer.append(GC.getTraitInfo(static_cast<TraitTypes>(i)).getDescription());
			}
		}
	}
	if (GC.getGame().isOption(GAMEOPTION_LEADER_DEVELOPING))
	{
		const int iLevel = kPlayer.getLeaderHeadLevel();
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_LEADER_LEVEL", iLevel));
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_LEADER_LEVEL_PROGRESS_1", CvWString::format(L"%I64d", kPlayer.getCulture()).GetCString()));
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_LEADER_LEVEL_PROGRESS_2", CvWString::format(L"%I64u", kPlayer.getLeaderLevelupNextCultureTotal()).GetCString(), iLevel+1));
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_LEADER_LEVEL_PROGRESS_3", CvWString::format(L"%I64u", kPlayer.getLeaderLevelupCultureToEarn()).GetCString()));
	}
	else
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_LEADER_LEVEL_PROGRESS_1", CvWString::format(L"%I64d", kPlayer.getCulture()).GetCString()));
	}
}

void CvGameTextMgr::parsePlayerHasFixedBorders(CvWStringBuffer &szBuffer, PlayerTypes ePlayer)
{
	bool bHasFixedBorders = GET_PLAYER(ePlayer).hasFixedBorders();
	szBuffer.append(gDLL->getText(bHasFixedBorders ? "TXT_KEY_PLAYER_HAS_FIXED_BORDERS" : "TXT_KEY_PLAYER_HAS_NOT_FIXED_BORDERS"));
}

void CvGameTextMgr::parseLeaderHeadHelp(CvWStringBuffer &szBuffer, PlayerTypes eThisPlayer, PlayerTypes eOtherPlayer)
{
	if (NO_PLAYER == eThisPlayer)
	{
		return;
	}

	szBuffer.append(CvWString::format(L"%s\n", GET_PLAYER(eThisPlayer).getName()));

	parsePlayerTraits(szBuffer, eThisPlayer);

	szBuffer.append(L"\n");

	if ( GC.getGame().isOption(GAMEOPTION_CULTURE_FIXED_BORDERS) )
	{
		parsePlayerHasFixedBorders(szBuffer, eThisPlayer);

		szBuffer.append(L"\n");
	}

// BUG - Leaderhead Relations - start
	PlayerTypes eActivePlayer = GC.getGame().getActivePlayer();
	TeamTypes eThisTeam = GET_PLAYER(eThisPlayer).getTeam();
	CvTeam& kThisTeam = GET_TEAM(eThisTeam);

	if (eOtherPlayer == NO_PLAYER)
	{
		eOtherPlayer = eActivePlayer;
	}
	if (eThisPlayer != eOtherPlayer && kThisTeam.isHasMet(GET_PLAYER(eOtherPlayer).getTeam()))
	{
		getEspionageString(szBuffer, eThisPlayer, eOtherPlayer);

		getAttitudeString(szBuffer, eThisPlayer, eOtherPlayer);

		if (gDLL->ctrlKey())
		{
			getActiveDealsString(szBuffer, eThisPlayer, eOtherPlayer);
		}
	}

	getAllRelationsString(szBuffer, eThisTeam);
// BUG - Leaderhead Relations - end
}


void CvGameTextMgr::getActiveDealsString(CvWStringBuffer &szBuffer, PlayerTypes eThisPlayer, PlayerTypes eOtherPlayer)
{
	PROFILE_EXTRA_FUNC();
	foreach_(CvDeal& kDeal, GC.getGame().deals())
	{
		if ((kDeal.getFirstPlayer() == eThisPlayer && kDeal.getSecondPlayer() == eOtherPlayer)
		|| (kDeal.getFirstPlayer() == eOtherPlayer && kDeal.getSecondPlayer() == eThisPlayer))
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(CvWString::format(L"%c", gDLL->getSymbolID(BULLET_CHAR)));
			getDealString(szBuffer, kDeal, eThisPlayer);
		}
	}
}

// BUG - Leaderhead Relations - start
/*
 * Shows the peace/war/enemy/pact status between eThisTeam and all rivals known to the active player.
 * Relations for the active player are shown first.
 */
void CvGameTextMgr::getAllRelationsString(CvWStringBuffer& szString, TeamTypes eThisTeam)
{
	getActiveTeamRelationsString(szString, eThisTeam);
	getOtherRelationsString(szString, eThisTeam, NO_TEAM, GC.getGame().getActiveTeam());
}

/*
 * Shows the peace/war/enemy/pact status between eThisTeam and the active player.
 */
void CvGameTextMgr::getActiveTeamRelationsString(CvWStringBuffer& szString, TeamTypes eThisTeam)
{
	CvTeamAI& kThisTeam = GET_TEAM(eThisTeam);
	TeamTypes eActiveTeam = GC.getGame().getActiveTeam();
	CvTeamAI& kActiveTeam = GET_TEAM(eActiveTeam);


	if (!kThisTeam.isHasMet(eActiveTeam))
	{
		return;
	}

	if (kThisTeam.isAtWar(eActiveTeam))
	{
		szString.append(NEWLINE);
		szString.append(gDLL->getText(L"TXT_KEY_AT_WAR_WITH_YOU"));
	}
	else if (kThisTeam.isForcePeace(eActiveTeam))
	{
		szString.append(NEWLINE);
		szString.append(gDLL->getText(L"TXT_KEY_PEACE_TREATY_WITH_YOU"));
	}

	if (!kThisTeam.isHuman() && kThisTeam.AI_getWorstEnemy() == eActiveTeam)
	{
		szString.append(NEWLINE);
		szString.append(gDLL->getText(L"TXT_KEY_WORST_ENEMY_IS_YOU"));
	}

	if (kThisTeam.isDefensivePact(eActiveTeam))
	{
		szString.append(NEWLINE);
		szString.append(gDLL->getText(L"TXT_KEY_DEFENSIVE_PACT_WITH_YOU"));
	}

	if (!kThisTeam.isAtWar(eActiveTeam))
	{

		if (kActiveTeam.AI_getWarPlan(eThisTeam) == WARPLAN_PREPARING_TOTAL)
		{
			szString.append(NEWLINE);
			szString.append(gDLL->getText(L"TXT_KEY_WARPLAN_TARGET_OF_YOU"));
		}

		if (GC.getGame().isDebugMode())
		{
			if (kThisTeam.AI_getWarPlan(eActiveTeam) == WARPLAN_PREPARING_TOTAL || kThisTeam.AI_getWarPlan(eActiveTeam) == WARPLAN_TOTAL)
			{
				szString.append(NEWLINE);
				szString.append(gDLL->getText(L"TXT_KEY_WARPLAN_TARGET_IS_YOU"));
			}
			else if (kThisTeam.AI_getWarPlan(eActiveTeam) == WARPLAN_PREPARING_LIMITED || kThisTeam.AI_getWarPlan(eActiveTeam) == WARPLAN_LIMITED)
			{
				szString.append(NEWLINE);
				szString.append(gDLL->getText(L"TXT_KEY_WARPLAN_LIMITED_TARGET_IS_YOU"));
			}
		}
	}
}

/*
 * Shows the peace/war/enemy/pact status between eThisPlayer and eOtherPlayer (both must not be NO_PLAYER).
 * If eOtherTeam is not NO_TEAM, only relations between it and eThisTeam are shown.
 * if eSkipTeam is not NO_TEAM, relations involving it are not shown.
 */
void CvGameTextMgr::getOtherRelationsString(CvWStringBuffer& szString, PlayerTypes eThisPlayer, PlayerTypes eOtherPlayer)
{
	if (eThisPlayer == NO_PLAYER || eOtherPlayer == NO_PLAYER)
	{
		return;
	}
	getOtherRelationsString(szString, GET_PLAYER(eThisPlayer).getTeam(), GET_PLAYER(eOtherPlayer).getTeam(), NO_TEAM);
}

/*
 * Shows the peace/war/enemy/pact status between eThisPlayer and all rivals known to the active player.
 * If eOtherTeam is not NO_TEAM, only relations between it and eThisTeam are shown.
 * if eSkipTeam is not NO_TEAM, relations involving it are not shown.
 */
void CvGameTextMgr::getOtherRelationsString(CvWStringBuffer& szString, TeamTypes eThisTeam, TeamTypes eOtherTeam, TeamTypes eSkipTeam)
{
	PROFILE_EXTRA_FUNC();
	if (eThisTeam == NO_TEAM)
	{
		return;
	}
	const CvTeamAI& kThisTeam = GET_TEAM(eThisTeam);
	CvWString szWar, szPeace, szEnemy, szPact, szWarPlanTotal, szWarPlanLimited;
	bool bFirstWar = true, bFirstPeace = true, bFirstEnemy = true, bFirstPact = true, bFirstWarPlanTotal = true, bFirstWarPlanLimited = true;

	for (int iTeam = 0; iTeam < MAX_PC_TEAMS; ++iTeam)
	{
		const CvTeamAI& kTeam = GET_TEAM((TeamTypes) iTeam);

		if (kTeam.isAlive() && !kTeam.isMinorCiv()
		&& iTeam != eThisTeam && iTeam != eSkipTeam
		&& (eOtherTeam == NO_TEAM || iTeam == eOtherTeam)
		&& kTeam.isHasMet(eThisTeam)
		&& kTeam.isHasMet(GC.getGame().getActiveTeam()))
		{
			if (kTeam.isAtWar(eThisTeam))
			{
				setListHelp(szWar, L"", kTeam.getName().GetCString(), L", ", bFirstWar);
				bFirstWar = false;
			}
			else if (kTeam.isForcePeace(eThisTeam))
			{
				setListHelp(szPeace, L"", kTeam.getName().GetCString(), L", ", bFirstPeace);
				bFirstPeace = false;
			}

			if (!kTeam.isHuman() && kTeam.AI_getWorstEnemy() == eThisTeam)
			{
				setListHelp(szEnemy, L"", kTeam.getName().GetCString(), L", ", bFirstEnemy);
				bFirstEnemy = false;
			}

			if (kTeam.isDefensivePact(eThisTeam))
			{
				setListHelp(szPact, L"", kTeam.getName().GetCString(), L", ", bFirstPact);
				bFirstPact = false;
			}

			//Show own war plans
			if (eThisTeam == GC.getGame().getActiveTeam() || GC.getGame().isDebugMode() && !kTeam.isAtWar(eThisTeam))
			{
				if (kThisTeam.AI_getWarPlan((TeamTypes)iTeam) == WARPLAN_PREPARING_TOTAL || kThisTeam.AI_getWarPlan((TeamTypes)iTeam) == WARPLAN_TOTAL)
				{
					setListHelp(szWarPlanTotal, L"", kTeam.getName().GetCString(), L", ", bFirstWarPlanTotal);
					bFirstWarPlanTotal = false;
				}
				else if (kThisTeam.AI_getWarPlan((TeamTypes)iTeam) == WARPLAN_PREPARING_LIMITED || kThisTeam.AI_getWarPlan((TeamTypes)iTeam) == WARPLAN_LIMITED || kThisTeam.AI_getWarPlan((TeamTypes)iTeam) == WARPLAN_DOGPILE)
				{
					setListHelp(szWarPlanLimited, L"", kTeam.getName().GetCString(), L", ", bFirstWarPlanLimited);
					bFirstWarPlanLimited = false;
				}
			}
		}
	}

	if (!szWar.empty())
	{
		szString.append(NEWLINE);
		szString.append(gDLL->getText(L"TXT_KEY_AT_WAR_WITH", szWar.GetCString()));
	}
	if (!kThisTeam.isHuman())
	{
		TeamTypes eWorstEnemy = kThisTeam.AI_getWorstEnemy();
		if (eWorstEnemy != NO_TEAM && eWorstEnemy != eSkipTeam && (eOtherTeam == NO_TEAM || eWorstEnemy == eOtherTeam) && GET_TEAM(eWorstEnemy).isHasMet(GC.getGame().getActiveTeam()))
		{
			szString.append(NEWLINE);
			szString.append(gDLL->getText(L"TXT_KEY_WORST_ENEMY_IS", GET_TEAM(eWorstEnemy).getName().GetCString()));
		}
	}
	if (!szEnemy.empty())
	{
		szString.append(NEWLINE);
		szString.append(gDLL->getText(L"TXT_KEY_WORST_ENEMY_OF", szEnemy.GetCString()));
	}
	if (!szPeace.empty())
	{
		szString.append(NEWLINE);
		szString.append(gDLL->getText(L"TXT_KEY_PEACE_TREATY_WITH", szPeace.GetCString()));
	}
	if (!szPact.empty())
	{
		szString.append(NEWLINE);
		szString.append(gDLL->getText(L"TXT_KEY_DEFENSIVE_PACT_WITH", szPact.GetCString()));
	}
	if (!szWarPlanTotal.empty())
	{
		szString.append(NEWLINE);
		szString.append(gDLL->getText(L"TXT_KEY_WARPLAN_TARGET_IS", szWarPlanTotal.GetCString()));
	}
	if (!szWarPlanLimited.empty())
	{
		szString.append(NEWLINE);
		szString.append(gDLL->getText(L"TXT_KEY_WARPLAN_LIMITED_TARGET_IS", szWarPlanLimited.GetCString()));
	}
}
// BUG - Leaderhead Relations - end

void CvGameTextMgr::buildHintsList(CvWStringBuffer& szBuffer)
{
	PROFILE_EXTRA_FUNC();
	for (int i = 0; i < GC.getNumHints(); i++)
	{
		szBuffer.append(CvWString::format(L"%c%s", gDLL->getSymbolID(BULLET_CHAR), GC.getHints(i).getText()));
		szBuffer.append(NEWLINE);
		szBuffer.append(NEWLINE);
	}
}

void CvGameTextMgr::setCommerceHelp(CvWStringBuffer &szBuffer, CvCity& city, CommerceTypes eCommerceType)
{
	PROFILE_EXTRA_FUNC();
	if (NO_COMMERCE == eCommerceType || NO_PLAYER == city.getOwner())
	{
		return;
	}
	CvWString szValue;

	//define commerce info.
	const CvCommerceInfo& info = GC.getCommerceInfo(eCommerceType);

	//define player owner.
	CvPlayer& owner = GET_PLAYER(city.getOwner());
	//define team owner.
	CvTeam& team = GET_TEAM(owner.getTeam());

	//initiate with an exposition on the base commerce yield income total for the city before we start a breakdown
	//Note: should generate a total value as it shows the base and then modifier but not a total - that would be a helpful addition
	setYieldHelp(szBuffer, city, YIELD_COMMERCE);
	szBuffer.append(DOUBLE_SEPARATOR);

	//STEP 1 : Slider
	//displays as: slider% of totalCommerce = total base unmodified commerce
	const int iSliderRate100 = city.getCommerceFromPercent(eCommerceType);
	int iCommerce100 = iSliderRate100;
	CvWString szRate = CvWString::format(L"%d.%02d", iCommerce100 / 100, iCommerce100 % 100);
	szBuffer.append(gDLL->getText("TXT_KEY_MISC_HELP_SLIDER_PERCENT_FLOAT", owner.getCommercePercent(eCommerceType), city.getYieldRate(YIELD_COMMERCE), szRate.GetCString(), info.getChar()));

	//STEP 2 : Commerce Changes from specialists
	{
		const int iSpecialistCommerce = city.getSpecialistCommerce(eCommerceType) + city.getExtraSpecialistCommerceTotal(eCommerceType);
		if (0 != iSpecialistCommerce)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_BULLET_D1_F2_FROM_S3", iSpecialistCommerce, info.getChar(), L"TXT_KEY_CONCEPT_SPECIALISTS"));
			iCommerce100 += 100 * iSpecialistCommerce;
		}
	}
	//STEP 3 : Religion Commerce
	{
		const int iReligionCommerce = city.getReligionCommerce(eCommerceType);
		if (0 != iReligionCommerce)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_MISC_HELP_RELIGION_COMMERCE", iReligionCommerce, info.getChar()));
			iCommerce100 += 100 * iReligionCommerce;
		}
	}
	//STEP 4 : Corporation Commerce
	{
		const int iCorporationCommerce = city.getCorporationCommerce(eCommerceType);
		if (0 != iCorporationCommerce)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_MISC_HELP_CORPORATION_COMMERCE", iCorporationCommerce, info.getChar()));
			iCommerce100 += 100 * iCorporationCommerce;
		}
	}
	//STEP 5 : Building Commerce Changes
	{
		const int iBuildingCommerce100 = city.getBuildingCommerce100(eCommerceType);
		if (0 != iBuildingCommerce100)
		{
			makeValueString(szValue, iBuildingCommerce100, true);
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_BULLET_S1_F2_FROM_S3", szValue.GetCString(), info.getChar(), L"TXT_KEY_WB_BUILDINGS"));
			iCommerce100 += iBuildingCommerce100;
		}
	}
	//STEP 6 : Free City Commerce (player tallied from civics/traits a change value to all cities commerce output)
	{
		const int iExtraCommerce100 = owner.getExtraCommerce100(eCommerceType);
		if (0 != iExtraCommerce100)
		{
			makeValueString(szValue, iExtraCommerce100, true);
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_BULLET_S1_F2_FROM_S3", szValue.GetCString(), info.getChar(), L"TXT_KEY_NATIONAL_SOURCES"));
			iCommerce100 += iExtraCommerce100;
		}
	}
	//STEP 7 : Minted Commerce
	if (eCommerceType == COMMERCE_GOLD)
	{
		const int iMintedCommerce100 = city.getMintedCommerceTimes100();
		if (0 != iMintedCommerce100)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_MISC_HELP_MINTED_COMMERCE", CvWString::format(L"%d.%02d", iMintedCommerce100 / 100, iMintedCommerce100 % 100).GetCString(), info.getChar()));
			iCommerce100 += iMintedCommerce100;
		}
	}
	//STEP 8 : Golden Age Base Commerce Changes (usually trait driven though it might be interesting to enable this on civics.)
	if (owner.isGoldenAge())
	{
		const int iGoldenAgeCommerce = owner.getGoldenAgeCommerce(eCommerceType);
		if (0 != iGoldenAgeCommerce)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_MISC_HELP_GOLDEN_AGE_PLAYER_COMMERCE", iGoldenAgeCommerce, info.getChar()));
			iCommerce100 += 100 * iGoldenAgeCommerce;
		}
	}

	if (iCommerce100 != 0 && iCommerce100 != iSliderRate100)
	{
		makeValueString(szValue, iCommerce100);
		szBuffer.append(SEPARATOR);
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_BASE_S1_IS_S2_F3", info.getTextKeyWide(), szValue.GetCString(), info.getChar()));
	}

	//Debug check to make sure Base in display matches base in programming
	FAssertMsg(city.getBaseCommerceRateTimes100(eCommerceType) == iCommerce100, "Base Commerce rate does not agree with actual value");

	//% MODIFIER TALLY
	//In the city coding the final modifier value appears to be processed in and out and stored on m_totalCommerceRateModifier[eIndex]
	int iModifier = 100;

	//STEP 1 : Bonus Commerce Rate Modifier
	{
		const int iBonusCommerce = city.calculateBonusCommerceRateModifier(eCommerceType);
		if (0 != iBonusCommerce)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_MISC_HELP_BONUS_COMMERCE", iBonusCommerce, info.getChar()));
			iModifier += iBonusCommerce;
		}
	}
	//STEP 2 : Buildings (split into projects and everything else)
	{
		const int iBuildingMod = city.getBuildingCommerceModifier(eCommerceType);
		if (0 != iBuildingMod)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_MISC_HELP_YIELD_BUILDINGS", iBuildingMod, info.getChar()));
			iModifier += iBuildingMod;
		}
	}
	//STEP 2.5
	//Display projects (AND Player level buildings (Wonders))
	const int iProjectMod = owner.getCommerceRateModifierfromBuildings(eCommerceType);
	if (iProjectMod != 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_HELP_YIELD_PROJECTS", iProjectMod, info.getChar()));
		iModifier += iProjectMod;
	}
	//STEP 3 : Events
	{
		const int iEventsModifier = city.getCommerceRateModifier(eCommerceType) + owner.getCommerceRateModifierfromEvents(eCommerceType);
		if (0 != iEventsModifier)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_MISC_HELP_COMMERCE_EVENTS", iEventsModifier, info.getChar()));
			iModifier += iEventsModifier;
		}
	}
	//STEP 4 : Player Level
	int iPlayerLevelModifier = owner.getCommerceRateModifier(eCommerceType);
	int iPlayerLevelCompare = 0;
	//Remove Events - they were included in the above report
	iPlayerLevelModifier -= owner.getCommerceRateModifierfromEvents(eCommerceType);
	//Remove Team and Player level Building Modifiers - they were included in the above report
	iPlayerLevelModifier -= iProjectMod;

	// Trait
	for (int i = 0; i < GC.getNumTraitInfos(); i++)
	{
		if (city.hasTrait((TraitTypes)i))
		{
			const CvTraitInfo& trait = GC.getTraitInfo((TraitTypes)i);
			const int iTraitMod = trait.getCommerceModifier(eCommerceType);
			if (0 != iTraitMod)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_MISC_HELP_COMMERCE_TRAIT", iTraitMod, info.getChar(), trait.getTextKeyWide()));
				iPlayerLevelCompare += iTraitMod;
			}
		}
	}


	// Civics
	int iCivicMod = 0;
	for (int i = 0; i < GC.getNumCivicOptionInfos(); i++)
	{
		if (NO_CIVIC != owner.getCivics((CivicOptionTypes)i))
		{
			iCivicMod += GC.getCivicInfo(owner.getCivics((CivicOptionTypes)i)).getCommerceModifier(eCommerceType);
		}
	}
	if (0 != iCivicMod)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_HELP_YIELD_CIVICS", iCivicMod, info.getChar()));
		iPlayerLevelCompare += iCivicMod;
	}

	// Techs
	for (int i = 0; i < GC.getNumTechInfos(); i++)
	{
		if (team.isHasTech((TechTypes)i))
		{
			const CvTechInfo& tech = GC.getTechInfo((TechTypes)i);
			const int iTechMod = tech.getCommerceModifier(eCommerceType);
			if (0 != iTechMod)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_MISC_HELP_COMMERCE_TECH", iTechMod, info.getChar(), tech.getTextKeyWide()));
				iPlayerLevelCompare += iTechMod;
			}
		}
	}
	iModifier += iPlayerLevelModifier;
	//Debug check to make sure Base in display matches base in progamming
	FAssertMsg(iPlayerLevelModifier == iPlayerLevelCompare, "Player Level Commerce Modifier display does not agree with actual value");

	//STEP 5 : Capital Modifier
	// Capital
	int iCapitalMod = city.isCapital() ? owner.getCapitalCommerceRateModifier(eCommerceType) : 0;
	if (iCapitalMod != 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_HELP_YIELD_CAPITAL", iCapitalMod, info.getChar()));
		iModifier += iCapitalMod;
	}

	iModifier = std::max(1, iModifier);

	int iFinalValue100;
	// Modifiers apply inversely against a negative base to avoid counter-intuitive
	//	situations like intelligence agencies making negative espionag worse
	if (iCommerce100 > 0)
	{
		iFinalValue100 = iCommerce100 * iModifier / 100;
	}
	else iFinalValue100 = iCommerce100 * 100 / iModifier;
	{
		const int iProducedCommerce100 = city.getProductionToCommerceModifier(eCommerceType) * city.getYieldRate(YIELD_PRODUCTION);
		if (0 != iProducedCommerce100)
		{
			if (iProducedCommerce100 % 100 == 0)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_MISC_HELP_PRODUCTION_TO_COMMERCE", iProducedCommerce100 / 100, info.getChar()));
			}
			else
			{
				szRate = CvWString::format(L"+%d.%02d", iProducedCommerce100 / 100, iProducedCommerce100 % 100);
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_MISC_HELP_PRODUCTION_TO_COMMERCE_FLOAT", szRate.GetCString(), info.getChar()));
			}
			iFinalValue100 += iProducedCommerce100;
		}
	}
	FAssertMsg(iFinalValue100 == city.getCommerceRateTimes100(eCommerceType), "Commerce yield does not match actual value");

	makeValueString(szValue, iFinalValue100);
	szBuffer.append(DOUBLE_SEPARATOR);
	szBuffer.append(gDLL->getText("TXT_KEY_MISC_HELP_COMMERCE_FINAL_YIELD_FLOAT", info.getTextKeyWide(), szValue.GetCString(), info.getChar()));

	if (city.getOwner() == GC.getGame().getActivePlayer()
	&& getBugOptionBOOL("MiscHover__BuildingAdditionalCommerce", true, "BUG_BUILDING_ADDITIONAL_COMMERCE_HOVER"))
	{
		setBuildingAdditionalCommerceHelp(szBuffer, city, eCommerceType, DOUBLE_SEPARATOR);
	}
}

void CvGameTextMgr::setYieldHelp(CvWStringBuffer &szBuffer, CvCity& city, YieldTypes eYieldType)
{
	PROFILE_EXTRA_FUNC();
	FAssertMsg(NO_PLAYER != city.getOwner(), "City must have an owner");

	if (NO_YIELD == eYieldType || NO_PLAYER == city.getOwner())
	{
		return;
	}
	const CvYieldInfo& info = GC.getYieldInfo(eYieldType);
	const CvPlayer& owner = GET_PLAYER(city.getOwner());

	const int iBaseYield = city.getBaseYieldRate(eYieldType);
	int iYield = iBaseYield;

	const int iPlotYield = city.getPlotYield(eYieldType);
	szBuffer.append(gDLL->getText("TXT_KEY_MISC_HELP_WORKED_TILES_YIELD", iPlotYield, info.getChar()));
	iYield -= iPlotYield;

	// Traits
	if (owner.getFreeCityYield(eYieldType) != 0)
	{
		for (int i = 0; i < GC.getNumTraitInfos(); i++)
		{
			TraitTypes eTrait = static_cast<TraitTypes>(i);
			if (owner.hasTrait(eTrait))
			{
				const int iTraitYield = GC.getTraitInfo(eTrait).getYieldChange(eYieldType);
				if (iTraitYield != 0)
				{
					szBuffer.append(NEWLINE);
					szBuffer.append(gDLL->getText("TXT_BULLET_D1_F2_FROM_S3", iTraitYield, info.getChar(), GC.getTraitInfo(eTrait).getDescription()));
					iYield -= iTraitYield;
				}
			}
		}
	}
	// Trade
	{
		const int iTradeYield = city.getTradeYield(eYieldType);
		if (iTradeYield != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_BULLET_D1_F2_FROM_S3", iTradeYield, info.getChar(), L"TXT_KEY_HEADING_TRADEROUTE_LIST"));
			iYield -= iTradeYield;
		}
	}
	if (iYield != 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_HELP_YIELD_OTHER", iYield, info.getChar()));
	}
	szBuffer.append(SEPARATOR);
	szBuffer.append(NEWLINE);
	szBuffer.append(gDLL->getText("TXT_KEY_MISC_HELP_BASE_YIELD", info.getTextKeyWide(), iBaseYield, info.getChar()));
	szBuffer.append(NEWLINE);

	const int iActualBaseMod = city.getBaseYieldRateModifier(eYieldType);
	int iBaseModifier = 100;

	if (iActualBaseMod != 100)
	{
		int iEventModifier = city.getYieldRateModifier(eYieldType) + owner.getYieldRateModifier(eYieldType);
		// Traits
		{
			int iMod = 0;
			for (int iI = 0; iI < GC.getNumTraitInfos(); iI++)
			{
				if (owner.hasTrait((TraitTypes)iI))
				{
					const int iTemp = GC.getTraitInfo((TraitTypes)iI).getYieldModifier(eYieldType);
					if (iTemp != 0)
					{
						iEventModifier -= iTemp;
						iMod += iTemp;
					}
				}
			}
			if (0 != iMod)
			{
				szBuffer.append(gDLL->getText("TXT_KEY_MISC_HELP_YIELD_TRAITS", iMod, info.getChar()));
				szBuffer.append(NEWLINE);
				iBaseModifier += iMod;
			}
		}
		// Civics
		{
			int iMod = 0;
			for (int iI = 0; iI < GC.getNumCivicOptionInfos(); iI++)
			{
				if (NO_CIVIC != owner.getCivics((CivicOptionTypes)iI))
				{
					const int iTemp = GC.getCivicInfo(owner.getCivics((CivicOptionTypes)iI)).getYieldModifier(eYieldType);
					if (iTemp != 0)
					{
						iEventModifier -= iTemp;
						iMod += iTemp;
					}
				}
			}
			if (0 != iMod)
			{
				szBuffer.append(gDLL->getText("TXT_KEY_MISC_HELP_YIELD_CIVICS", iMod, info.getChar()));
				szBuffer.append(NEWLINE);
				iBaseModifier += iMod;
			}
		}
		// Buildings
		{
			int iMod = city.getBuildingYieldModifier(eYieldType);

			for (int iI = GC.getNumBuildingInfos() - 1; iI > -1; iI--)
			{
				const int iTemp = GC.getBuildingInfo((BuildingTypes)iI).getGlobalYieldModifier(eYieldType);
				if (iTemp != 0)
				{
					for (int iJ = 0; iJ < MAX_PLAYERS; iJ++)
					{
						if (GET_PLAYER((PlayerTypes)iJ).isAliveAndTeam(owner.getTeam()))
						{
							foreach_(const CvCity* cityX, GET_PLAYER((PlayerTypes)iJ).cities())
							{
								if (cityX->isActiveBuilding((BuildingTypes)iI))
								{
									iEventModifier -= iTemp;
									iMod += iTemp;
								}
							}
						}
					}
				}
			}
			if (city.area())
			{
				iMod += city.area()->getYieldRateModifier(city.getOwner(), eYieldType);
			}
			if (0 != iMod)
			{
				szBuffer.append(gDLL->getText("TXT_KEY_MISC_HELP_YIELD_BUILDINGS", iMod, info.getChar()));
				szBuffer.append(NEWLINE);
				iBaseModifier += iMod;
			}
		}
		// Resources
		{
			const int iMod = city.getBonusYieldRateModifier(eYieldType);
			if (0 != iMod)
			{
				szBuffer.append(gDLL->getText("TXT_KEY_MISC_HELP_YIELD_BONUS", iMod, info.getChar()));
				szBuffer.append(NEWLINE);
				iBaseModifier += iMod;
			}
		}
		// Power
		if (city.isPower())
		{
			const int iMod = city.getPowerYieldRateModifier(eYieldType);
			if (0 != iMod)
			{
				szBuffer.append(gDLL->getText("TXT_KEY_MISC_HELP_YIELD_POWER", iMod, info.getChar()));
				szBuffer.append(NEWLINE);
				iBaseModifier += iMod;
			}
		}
		// Capital
		if (city.isCapital())
		{
			const int iMod = owner.getCapitalYieldRateModifier(eYieldType);
			if (0 != iMod)
			{
				szBuffer.append(gDLL->getText("TXT_KEY_MISC_HELP_YIELD_CAPITAL", iMod, info.getChar()));
				szBuffer.append(NEWLINE);
				iBaseModifier += iMod;
			}
		}
		// Events
		if (iEventModifier != 0)
		{
			szBuffer.append(gDLL->getText("TXT_KEY_MISC_HELP_YIELD_EVENTS", iEventModifier, info.getChar()));
			szBuffer.append(NEWLINE);
			iBaseModifier += iEventModifier;
		}
		FAssertMsg(iActualBaseMod == iBaseModifier, CvString::format("Total Yield Modifier %d should be %d", iBaseModifier, iActualBaseMod).c_str())

		// Sub total
		if (iBaseModifier != 100)
		{
			const int iModBaseYield100 = iBaseYield * iBaseModifier;
			CvWString szYield = CvWString::format(L"%d.%02d", iModBaseYield100/100, iModBaseYield100%100);
			szBuffer.append(gDLL->getText("TXT_KEY_MISC_HELP_TOTAL_YIELD_MOD", iBaseModifier-100, szYield.GetCString(), info.getChar()));
		}
	}
	szBuffer.append(SEPARATOR);

	// Extra yields
	int iExtraYield = city.getExtraYield(eYieldType);
	iYield = iExtraYield;

	// Specialists
	{
		int iSpecialistYield = 0;
		int iFreeSpecialistYield = 0;
		for (int iI = 0; iI < GC.getNumSpecialistInfos(); iI++)
		{
			const SpecialistTypes eType = static_cast<SpecialistTypes>(iI);
			int iCount = city.getSpecialistCount(eType);
			if (iCount > 0)
			{
				iSpecialistYield += iCount * city.specialistYield(eType, eYieldType);
			}
			iCount = city.getFreeSpecialistCount(eType);
			if (iCount > 0)
			{
				iFreeSpecialistYield += iCount * city.specialistYield(eType, eYieldType);
			}
		}
		if (iSpecialistYield != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_BULLET_D1_F2_FROM_S3", iSpecialistYield, info.getChar(), L"TXT_KEY_CONCEPT_SPECIALISTS"));
			iYield -= iSpecialistYield;
		}
		if (iFreeSpecialistYield != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_BULLET_D1_F2_FROM_S3", iFreeSpecialistYield, info.getChar(), L"TXT_KEY_WB_FREE_SPECIALISTS"));
			iYield -= iFreeSpecialistYield;
		}
	}
	// Corporations
	{
		const int iCorporationYield = city.getCorporationYield(eYieldType);
		if (iCorporationYield != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_MISC_HELP_CORPORATION_COMMERCE", iCorporationYield, info.getChar()));
			iYield -= iCorporationYield;
		}
	}
	// Buildings
	{
		const int iBuildingYield100 = city.getBuildingExtraYield100(eYieldType) + city.getBaseYieldPerPopRate(eYieldType) * city.getPopulation();
		if (0 != iBuildingYield100)
		{
			CvWString szValue;
			makeValueString(szValue, iBuildingYield100, true);
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_BULLET_S1_F2_FROM_S3", szValue.GetCString(), info.getChar(), L"TXT_KEY_WB_BUILDINGS"));
			iYield -= iBuildingYield100 / 100;
		}
	}

	// Yield specifics
	switch (eYieldType)
	{
		case YIELD_FOOD:
		{
			break;
		}
		case YIELD_PRODUCTION:
		{
			const int iFoodProduction = city.isFoodProduction() ? std::max(0, city.getYieldRate(YIELD_FOOD) - city.foodConsumption(true)) : 0;
			if (iFoodProduction > 0)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_MISC_HELP_PROD_FOOD", iFoodProduction, iFoodProduction));
			}
			const bool bIsProcess = city.isProductionProcess();
			const int iPastOverflow = (bIsProcess ? 0 : city.getOverflowProduction());
			if (iPastOverflow != 0)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_MISC_HELP_PROD_OVERFLOW", iPastOverflow));
			}

			const int iFromChops = (bIsProcess ? 0 : city.getFeatureProduction());
			if (iFromChops != 0)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_MISC_HELP_PROD_CHOPS", iFromChops));
			}
			iExtraYield += iFoodProduction + iPastOverflow + iFromChops;
			break;
		}
		case YIELD_COMMERCE:
		{
			break;
		}
	}
	// Unspecified
	if (iYield != 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_HELP_YIELD_OTHER", iYield, info.getChar()));
	}

	// Total
	szBuffer.append(SEPARATOR);
	szBuffer.append(NEWLINE);
	const int iTotal = std::max(1, iExtraYield + iBaseYield * iBaseModifier / 100);
	szBuffer.append(gDLL->getText("TXT_KEY_MISC_HELP_FINAL_YIELD", iTotal, info.getChar()));
}


void CvGameTextMgr::setConvertHelp(CvWStringBuffer& szBuffer, PlayerTypes ePlayer, ReligionTypes eReligion)
{
	CvWString szReligion = L"TXT_KEY_MISC_NO_STATE_RELIGION";

	if (eReligion != NO_RELIGION)
	{
		szReligion = GC.getReligionInfo(eReligion).getTextKeyWide();
	}

	szBuffer.assign(gDLL->getText("TXT_KEY_MISC_CANNOT_CONVERT_TO", szReligion.GetCString()));

	if (GET_PLAYER(ePlayer).isAnarchy())
	{
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_WHILE_IN_ANARCHY"));
	}
	else if (GET_PLAYER(ePlayer).getStateReligion() == eReligion)
	{
		szBuffer.append(L". ");
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_ALREADY_STATE_REL"));
	}
	else if (GET_PLAYER(ePlayer).getConversionTimer() > 0)
	{
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_ANOTHER_REVOLUTION_RECENTLY"));
		szBuffer.append(L". ");
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_WAIT_MORE_TURNS", GET_PLAYER(ePlayer).getConversionTimer()));
	}
}

void CvGameTextMgr::setRevolutionHelp(CvWStringBuffer& szBuffer, PlayerTypes ePlayer)
{
	szBuffer.assign(gDLL->getText("TXT_KEY_MISC_CANNOT_CHANGE_CIVICS"));

	if (GET_PLAYER(ePlayer).isAnarchy())
	{
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_WHILE_IN_ANARCHY"));
	}
	else if (GET_PLAYER(ePlayer).getRevolutionTimer() > 0)
	{
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_ANOTHER_REVOLUTION_RECENTLY"));
		szBuffer.append(L" : ");
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_WAIT_MORE_TURNS", GET_PLAYER(ePlayer).getRevolutionTimer()));
	}
}

void CvGameTextMgr::setVassalRevoltHelp(CvWStringBuffer& szBuffer, TeamTypes eMaster, TeamTypes eVassal)
{
	if (NO_TEAM == eMaster || NO_TEAM == eVassal)
	{
		return;
	}

	if (!GET_TEAM(eVassal).isCapitulated())
	{
		return;
	}

	if (GET_TEAM(eMaster).isParent(eVassal))
	{
		return;
	}

	CvTeam& kMaster = GET_TEAM(eMaster);
	CvTeam& kVassal = GET_TEAM(eVassal);

	int iMasterLand = kMaster.getTotalLand(false);
	int iVassalLand = kVassal.getTotalLand(false);
	if (iMasterLand > 0 && GC.getDefineINT("FREE_VASSAL_LAND_PERCENT") >= 0)
	{
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_VASSAL_LAND_STATS", (iVassalLand * 100) / iMasterLand, GC.getDefineINT("FREE_VASSAL_LAND_PERCENT")));
	}

	int iMasterPop = kMaster.getTotalPopulation(false);
	int iVassalPop = kVassal.getTotalPopulation(false);
	if (iMasterPop > 0 && GC.getDefineINT("FREE_VASSAL_POPULATION_PERCENT") >= 0)
	{
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_VASSAL_POPULATION_STATS", (iVassalPop * 100) / iMasterPop, GC.getDefineINT("FREE_VASSAL_POPULATION_PERCENT")));
	}

	if (GC.getDefineINT("VASSAL_REVOLT_OWN_LOSSES_FACTOR") > 0 && kVassal.getVassalPower() > 0)
	{
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_VASSAL_AREA_LOSS", (iVassalLand * 100) / kVassal.getVassalPower(), GC.getDefineINT("VASSAL_REVOLT_OWN_LOSSES_FACTOR")));
	}

	if (GC.getDefineINT("VASSAL_REVOLT_MASTER_LOSSES_FACTOR") > 0 && kVassal.getMasterPower() > 0)
	{
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_MASTER_AREA_LOSS", (iMasterLand * 100) / kVassal.getMasterPower(), GC.getDefineINT("VASSAL_REVOLT_MASTER_LOSSES_FACTOR")));
	}
}

void CvGameTextMgr::parseGreatPeopleHelp(CvWStringBuffer &szBuffer, CvCity& city)
{
	PROFILE_EXTRA_FUNC();
	if (NO_PLAYER == city.getOwner())
	{
		return;
	}
	CvPlayer& owner = GET_PLAYER(city.getOwner());

	szBuffer.assign(gDLL->getText("TXT_KEY_MISC_GREAT_PERSON", city.getGreatPeopleProgress(), owner.greatPeopleThresholdNonMilitary()));

	if (city.getGreatPeopleRate() > 0)
	{
		const int iGPPLeft = owner.greatPeopleThresholdNonMilitary() - city.getGreatPeopleProgress();

		if (iGPPLeft > 0)
		{
			int iTurnsLeft = iGPPLeft / city.getGreatPeopleRate();

			if (iTurnsLeft * city.getGreatPeopleRate() <  iGPPLeft)
			{
				iTurnsLeft++;
			}

			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("INTERFACE_CITY_TURNS", std::max(1, iTurnsLeft)));
		}
	}

	int iTotalGreatPeopleUnitProgress = 0;

	for (int iI = 0; iI < GC.getNumUnitInfos(); ++iI)
	{
		iTotalGreatPeopleUnitProgress += city.getGreatPeopleUnitProgress((UnitTypes)iI);
	}

	if (iTotalGreatPeopleUnitProgress > 0)
	{
		szBuffer.append(SEPARATOR);
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_PROB"));

		std::vector< std::pair<UnitTypes, int> > aUnitProgress;
		int iTotalTruncated = 0;
		for (int iI = 0; iI < GC.getNumUnitInfos(); ++iI)
		{
			const int iProgress = city.getGreatPeopleUnitProgress((UnitTypes)iI) * 100 / iTotalGreatPeopleUnitProgress;
			if (iProgress > 0)
			{
				iTotalTruncated += iProgress;
				aUnitProgress.push_back(std::make_pair((UnitTypes)iI, iProgress));
			}
		}

		if (iTotalTruncated < 100 && !aUnitProgress.empty())
		{
			aUnitProgress[0].second += 100 - iTotalTruncated;
		}

		for (int iI = 0; iI < (int)aUnitProgress.size(); iI++)
		{
			szBuffer.append(CvWString::format(L"%s%s - %d%%", NEWLINE, GC.getUnitInfo(aUnitProgress[iI].first).getDescription(), aUnitProgress[iI].second));
		}
	}


	const bool bBuildingAdditionalGreatPeople = getBugOptionBOOL("MiscHover__BuildingAdditionalGreatPeople", true, "BUG_BUILDING_ADDITIONAL_GREAT_PEOPLE_HOVER");

	if (city.getGreatPeopleRate() == 0 && !bBuildingAdditionalGreatPeople)
	{
		return;
	}

	if (getBugOptionBOOL("MiscHover__GreatPeopleRateBreakdown", true, "BUG_GREAT_PEOPLE_RATE_BREAKDOWN_HOVER"))
	{
		bool bFirst = true;
		int iRate = 0;
		for (int i = 0; i < GC.getNumSpecialistInfos(); i++)
		{
			int iCount = city.getSpecialistCount((SpecialistTypes)i) + city.getFreeSpecialistCount((SpecialistTypes)i);
			if (iCount > 0)
			{
				iRate += iCount * GC.getSpecialistInfo((SpecialistTypes)i).getGreatPeopleRateChange();
			}
		}
		if (iRate > 0)
		{
			if (bFirst)
			{
				szBuffer.append(SEPARATOR);
				bFirst = false;
			}
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_BULLET_D1_F2_FROM_S3", iRate, gDLL->getSymbolID(GREAT_PEOPLE_CHAR), L"TXT_KEY_CONCEPT_SPECIALISTS"));
		}

		iRate = 0;
		foreach_(const BuildingTypes eTypeX, city.getHasBuildings())
		{
			if (!city.isDisabledBuilding(eTypeX))
			{
				iRate += GC.getBuildingInfo(eTypeX).getGreatPeopleRateChange();
			}
		}
		if (iRate > 0)
		{
			if (bFirst)
			{
				szBuffer.append(SEPARATOR);
				bFirst = false;
			}
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_BULLET_D1_F2_FROM_S3", iRate, gDLL->getSymbolID(GREAT_PEOPLE_CHAR), L"TXT_KEY_WB_BUILDINGS"));
		}

		for (int i = 0; i < GC.getNumTraitInfos(); i++)
		{
			if (owner.hasTrait((TraitTypes)i))
			{
				iRate = GC.getTraitInfo((TraitTypes)i).getGreatPeopleRateChange();
				if (iRate > 0)
				{
					if (bFirst)
					{
						szBuffer.append(SEPARATOR);
						bFirst = false;
					}
					szBuffer.append(NEWLINE);
					szBuffer.append(gDLL->getText("TXT_BULLET_D1_F2_FROM_S3", iRate, gDLL->getSymbolID(GREAT_PEOPLE_CHAR), GC.getTraitInfo((TraitTypes)i).getDescription()));
				}
			}
		}
	}

	szBuffer.append(SEPARATOR);
	szBuffer.append(NEWLINE);
	szBuffer.append(gDLL->getText("TXT_KEY_MISC_HELP_GREATPEOPLE_BASE_RATE", city.getBaseGreatPeopleRate()));
	szBuffer.append(NEWLINE);

	int iModifier = 100;

	// Buildings
	const TeamTypes eTeam = owner.getTeam();
	int iBuildingMod = 0;
	for (int i = GC.getNumBuildingInfos() - 1; i > -1; i--)
	{
		const BuildingTypes eTypeX = static_cast<BuildingTypes>(i);

		if (city.isActiveBuilding(eTypeX))
		{
			iBuildingMod += GC.getBuildingInfo(eTypeX).getGreatPeopleRateModifier();
		}
		const int iGlobalGreatPeopleRateModifier = GC.getBuildingInfo(eTypeX).getGlobalGreatPeopleRateModifier();
		if (iGlobalGreatPeopleRateModifier != 0)
		{
			for (int j = 0; j < MAX_PLAYERS; j++)
			{
				if (GET_PLAYER((PlayerTypes)j).isAliveAndTeam(eTeam))
				{
					foreach_(const CvCity* cityX, GET_PLAYER((PlayerTypes)j).cities())
					{
						if (cityX->isActiveBuilding(eTypeX))
						{
							iBuildingMod += iGlobalGreatPeopleRateModifier;
						}
					}
				}
			}
		}
	}
	if (0 != iBuildingMod)
	{
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_HELP_GREATPEOPLE_BUILDINGS", iBuildingMod));
		szBuffer.append(NEWLINE);
		iModifier += iBuildingMod;
	}

	// Civics
	int iCivicMod = 0;
	for (int i = 0; i < GC.getNumCivicOptionInfos(); i++)
	{
		if (NO_CIVIC != owner.getCivics((CivicOptionTypes)i))
		{
			iCivicMod += GC.getCivicInfo(owner.getCivics((CivicOptionTypes)i)).getGreatPeopleRateModifier();
			if (owner.getStateReligion() != NO_RELIGION && city.isHasReligion(owner.getStateReligion()))
			{
				iCivicMod += GC.getCivicInfo(owner.getCivics((CivicOptionTypes)i)).getStateReligionGreatPeopleRateModifier();
			}
		}
	}
	if (0 != iCivicMod)
	{
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_HELP_GREATPEOPLE_CIVICS", iCivicMod));
		szBuffer.append(NEWLINE);
		iModifier += iCivicMod;
	}

	// Trait
	for (int i = 0; i < GC.getNumTraitInfos(); i++)
	{
		if (owner.hasTrait((TraitTypes)i))
		{
			const CvTraitInfo& trait = GC.getTraitInfo((TraitTypes)i);
			int iTraitMod = trait.getGreatPeopleRateModifier();

			if (owner.getStateReligion() != NO_RELIGION && city.isHasReligion(owner.getStateReligion()))
			{
				iTraitMod += trait.getStateReligionGreatPeopleRateModifier();
			}
			if (0 != iTraitMod)
			{
				szBuffer.append(gDLL->getText("TXT_KEY_MISC_HELP_GREATPEOPLE_TRAIT", iTraitMod, trait.getTextKeyWide()));
				szBuffer.append(NEWLINE);
				iModifier += iTraitMod;
			}
		}
	}

	if (owner.isGoldenAge())
	{
		const int iGoldenAgeMod = GC.getDefineINT("GOLDEN_AGE_GREAT_PEOPLE_MODIFIER");

		if (0 != iGoldenAgeMod)
		{
			szBuffer.append(gDLL->getText("TXT_KEY_MISC_HELP_GREATPEOPLE_GOLDEN_AGE", iGoldenAgeMod));
			szBuffer.append(NEWLINE);
			iModifier += iGoldenAgeMod;
		}
	}

	int iModGreatPeople = (iModifier * city.getBaseGreatPeopleRate()) / 100;

	FAssertMsg(iModGreatPeople == city.getGreatPeopleRate(), "Great person rate does not match actual value");

	szBuffer.append(gDLL->getText("TXT_KEY_MISC_HELP_GREATPEOPLE_FINAL", iModGreatPeople));

	if (bBuildingAdditionalGreatPeople && city.getOwner() == GC.getGame().getActivePlayer())
	{
		setBuildingAdditionalGreatPeopleHelp(szBuffer, city, DOUBLE_SEPARATOR);
	}
}

// BUG - Building Additional Great People - start
bool CvGameTextMgr::setBuildingAdditionalGreatPeopleHelp(CvWStringBuffer &szBuffer, CvCity& city, const CvWString& szStart, bool bStarted)
{
	PROFILE_EXTRA_FUNC();
	CvWString szLabel;

	for (int i = 0; i < GC.getNumBuildingInfos(); i++)
	{
		const BuildingTypes eBuilding = static_cast<BuildingTypes>(i);

		if (city.canConstruct(eBuilding, false, false, false))
		{
			const int iChange = city.getAdditionalGreatPeopleRateByBuilding(eBuilding);

			if (iChange != 0)
			{
				if (!bStarted)
				{
					szBuffer.append(szStart);
					bStarted = true;
				}

				szLabel.Format(SETCOLR L"%s" ENDCOLR, TEXT_COLOR("COLOR_BUILDING_TEXT"), GC.getBuildingInfo(eBuilding).getDescription());
				setResumableValueChangeHelp(szBuffer, szLabel, L": ", L"", iChange, gDLL->getSymbolID(GREAT_PEOPLE_CHAR), false, true);
			}
		}
	}

	return bStarted;
}
// BUG - Building Additional Great People - end


void CvGameTextMgr::parseGreatGeneralHelp(CvWStringBuffer &szBuffer, CvPlayer& kPlayer)
{
	PROFILE_EXTRA_FUNC();
	szBuffer.append(gDLL->getText("TXT_KEY_MISC_GREAT_MILITARY_PERSON", kPlayer.getCombatExperience(), kPlayer.greatPeopleThresholdMilitary(), GC.getUnitInfo(kPlayer.getGreatGeneralTypetoAssign()).getTextKeyWide()));

	for (int iI = 0; iI < GC.getNumUnitInfos(); iI++)
	{
		UnitTypes eGGType = ((UnitTypes)iI);
		if (kPlayer.getGreatGeneralPointsForType(eGGType) != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_MISC_GREAT_MILITARY_PERSON_BREAKDOWN", GC.getUnitInfo(eGGType).getTextKeyWide(), kPlayer.getGreatGeneralPointsForType(eGGType)));
		}
	}
}


//------------------------------------------------------------------------------------------------

void CvGameTextMgr::buildCityBillboardIconString( CvWStringBuffer& szBuffer, CvCity* pCity)
{
	PROFILE_EXTRA_FUNC();
	szBuffer.clear();
/************************************************************************************************/
/* TGA_INDEXATION						  02/18/08								MRGENIE	  */
/*																							  */
/* adding link to resources in the Pedia														*/
/************************************************************************************************/

	CvString szDebugBuffer;
	CvWString szTempBuffer;
/************************************************************************************************/
/* TGA_INDEXATION						  END												  */
/************************************************************************************************/

	// government center icon
	if (pCity->isGovernmentCenter() && !(pCity->isCapital()))
	{
		szBuffer.append(CvWString::format(L"%c", gDLL->getSymbolID(SILVER_STAR_CHAR)));
	}

	// happiness, healthiness, superlative icons
	if (pCity->canBeSelected())
	{
		if (pCity->angryPopulation() > 0)
		{
			szBuffer.append(CvWString::format(L"%c", gDLL->getSymbolID(UNHAPPY_CHAR)));
		}

		if (pCity->healthRate() < 0)
		{
			szBuffer.append(CvWString::format(L"%c", gDLL->getSymbolID(UNHEALTHY_CHAR)));
		}

		if (gDLL->getGraphicOption(GRAPHICOPTION_CITY_DETAIL))
		{
			if (GET_PLAYER(pCity->getOwner()).getNumCities() > 2)
			{
				if (pCity->findYieldRateRank(YIELD_PRODUCTION) == 1)
				{
					szBuffer.append(CvWString::format(L"%c", GC.getYieldInfo(YIELD_PRODUCTION).getChar()));
				}
				if (pCity->findCommerceRateRank(COMMERCE_GOLD) == 1)
				{
					szBuffer.append(CvWString::format(L"%c", GC.getCommerceInfo(COMMERCE_GOLD).getChar()));
				}
				if (pCity->findCommerceRateRank(COMMERCE_RESEARCH) == 1)
				{
					szBuffer.append(CvWString::format(L"%c", GC.getCommerceInfo(COMMERCE_RESEARCH).getChar()));
				}
			}
		}

		if (pCity->isConnectedToCapital())
		{
			if (GET_PLAYER(pCity->getOwner()).countNumCitiesConnectedToCapital() > 1)
			{
				szBuffer.append(CvWString::format(L"%c", gDLL->getSymbolID(TRADE_CHAR)));
			}
		}

		if (getBugOptionBOOL("CityBar__AirportIcons", true, "BUG_CITYBAR_AIRPORT_ICONS"))
		{
			foreach_(const BuildingTypes eTypeX, pCity->getHasBuildings())
			{
				if (GC.getBuildingInfo(eTypeX).getAirlift() > 0
				&& !pCity->isReligiouslyLimitedBuilding(eTypeX)
				&& !pCity->isDisabledBuilding(eTypeX))
				{
					szBuffer.append(CvWString::format(L"%c", gDLL->getSymbolID(AIRPORT_CHAR)));
					break;
				}
			}
		}
	}

	// religion icons
	logging::logMsg("CvGameTextMgr_buildCityBillboardString.log", "=== City %S religion icons ===", pCity->getName().GetCString());
	for (int iI = 0; iI < GC.getNumReligionInfos(); ++iI)
	{
		if (pCity->isHasReligion((ReligionTypes)iI))
		{
			if (pCity->isHolyCity((ReligionTypes)iI))
			{
				const CvReligionInfo& pInfo = GC.getReligionInfo((ReligionTypes) iI);
				logging::logMsg("CvGameTextMgr_buildCityBillboardString.log", "Religion %s, TGA index %i.", pInfo.getType(), pInfo.getTGAIndex());
				szBuffer.append(CvWString::format(L"%c", pInfo.getHolyCityChar()));
			}
			else
			{
				const CvReligionInfo& pInfo = GC.getReligionInfo((ReligionTypes) iI);
				szBuffer.append(CvWString::format(L"%c", pInfo.getChar()));
				logging::logMsg("CvGameTextMgr_buildCityBillboardString.log", "Religion %s, TGA index %i.", pInfo.getType(), pInfo.getTGAIndex());
			}
		}
	}

	// corporation icons
	for (int iI = 0; iI < GC.getNumCorporationInfos(); ++iI)
	{
		if (pCity->isHeadquarters((CorporationTypes)iI))
		{
			if (pCity->isHasCorporation((CorporationTypes)iI))
			{
				szBuffer.append(CvWString::format(L"%c", GC.getCorporationInfo((CorporationTypes) iI).getHeadquarterChar()));
			}
		}
		else
		{
			if (pCity->isActiveCorporation((CorporationTypes)iI))
			{
				szBuffer.append(CvWString::format(L"%c", GC.getCorporationInfo((CorporationTypes) iI).getChar()));
			}
		}
	}

	if (pCity->getTeam() == GC.getGame().getActiveTeam())
	{
		if (pCity->isPower())
		{
			szBuffer.append(CvWString::format(L"%c", gDLL->getSymbolID(POWER_CHAR)));
		}
	}

	// XXX out this in bottom bar???
	if (pCity->isOccupation())
	{
		szBuffer.append(CvWString::format(L" (%c:%d)", gDLL->getSymbolID(OCCUPATION_CHAR), pCity->getOccupationTimer()));
	}

	// defense icon and text
	//if (pCity->getTeam() != GC.getGame().getActiveTeam())
	{
		if (pCity->isVisible(GC.getGame().getActiveTeam(), true))
		{
			int iDefenseModifier = pCity->getDefenseModifier(GC.getGame().selectionListIgnoreBuildingDefense());

			if (iDefenseModifier != 0)
			{
				bool bRed = (iDefenseModifier == pCity->getExtraMinDefense());
				if (!bRed)
				{
					szBuffer.append(CvWString::format(L" %c:%s%d%%", gDLL->getSymbolID(DEFENSE_CHAR), ((iDefenseModifier > 0) ? L"+" : L""), iDefenseModifier));
				}
				else
				{
					szBuffer.append(CvWString::format(SETCOLR L" %c:%s%d%%" ENDCOLR, TEXT_COLOR("COLOR_WARNING_TEXT"), gDLL->getSymbolID(DEFENSE_CHAR), ((iDefenseModifier > 0) ? L"+" : L""), iDefenseModifier));
				}
			}
		}
	}

	if (pCity->getCivilizationType() != GET_PLAYER(pCity->getOwner()).getCivilizationType())
	{
		szBuffer.append(CvWString::format(L" (%s)", GC.getCivilizationInfo(pCity->getCivilizationType()).getShortDescription()));
	}
}

void CvGameTextMgr::buildCityBillboardCityNameString( CvWStringBuffer& szBuffer, CvCity* pCity)
{
	szBuffer.assign(pCity->getName());

	if (pCity->canBeSelected())
	{
		if (gDLL->getGraphicOption(GRAPHICOPTION_CITY_DETAIL))
		{
			if (pCity->foodDifference() > 0)
			{
				int iTurns = pCity->getFoodTurnsLeft();

				if ((iTurns > 1) || !(pCity->AI_isEmphasizeAvoidGrowth()))
				{
					if (iTurns < MAX_INT)
					{
						szBuffer.append(CvWString::format(L" (%d)", iTurns));
					}
				}
			}
// BUG - Starvation Turns - start
			else if (pCity->foodDifference() < 0 && getBugOptionBOOL("CityBar__StarvationTurns", true, "BUG_CITYBAR_STARVATION_TURNS"))
			{
				int iFoodDifference = pCity->foodDifference();
				if (pCity->getFood() + iFoodDifference >= 0)
				{
					int iTurns = pCity->getFood() / -iFoodDifference + 1;
					szBuffer.append(CvWString::format(L" (%d)", iTurns));
				}
				else
				{
					szBuffer.append(L" (!!!)");
				}
			}
// BUG - Starvation Turns - end
		}
	}
}

void CvGameTextMgr::buildCityBillboardProductionString( CvWStringBuffer& szBuffer, CvCity* pCity)
{
	if (pCity->getOrderQueueLength() > 0)
	{
		szBuffer.assign(pCity->getProductionName());

		if (gDLL->getGraphicOption(GRAPHICOPTION_CITY_DETAIL))
		{
			int iTurns = pCity->getProductionTurnsLeft();

			if (iTurns < MAX_INT)
			{
				szBuffer.append(CvWString::format(L" (%d)", iTurns));
			}
		}
	}
	else
	{
		szBuffer.clear();
	}
}


void CvGameTextMgr::buildCityBillboardCitySizeString( CvWStringBuffer& szBuffer, CvCity* pCity, const NiColorA& kColor)
{
#define CAPARAMS(c) (int)((c).r * 255.0f), (int)((c).g * 255.0f), (int)((c).b * 255.0f), (int)((c).a * 255.0f)
	szBuffer.assign(CvWString::format(SETCOLR L"%d" ENDCOLR, CAPARAMS(kColor), pCity->getPopulation()));
#undef CAPARAMS
}

void CvGameTextMgr::getCityBillboardFoodbarColors(CvCity* pCity, std::vector<NiColorA>& aColors)
{
	aColors.resize(NUM_INFOBAR_TYPES);
	aColors[INFOBAR_STORED] = GC.getColorInfo((ColorTypes)(GC.getYieldInfo(YIELD_FOOD).getColorType())).getColor();
	aColors[INFOBAR_RATE] = aColors[INFOBAR_STORED];
	aColors[INFOBAR_RATE].a = 0.5f;
	aColors[INFOBAR_RATE_EXTRA] = GC.getColorInfo((ColorTypes)GC.getInfoTypeForString("COLOR_NEGATIVE_RATE")).getColor();
	aColors[INFOBAR_EMPTY] = GC.getColorInfo((ColorTypes)GC.getInfoTypeForString("COLOR_EMPTY")).getColor();
}

void CvGameTextMgr::getCityBillboardProductionbarColors(CvCity* pCity, std::vector<NiColorA>& aColors)
{
	aColors.resize(NUM_INFOBAR_TYPES);
	aColors[INFOBAR_STORED] = GC.getColorInfo((ColorTypes)(GC.getYieldInfo(YIELD_PRODUCTION).getColorType())).getColor();
	aColors[INFOBAR_RATE] = aColors[INFOBAR_STORED];
	aColors[INFOBAR_RATE].a = 0.5f;
	aColors[INFOBAR_RATE_EXTRA] = GC.getColorInfo((ColorTypes)(GC.getYieldInfo(YIELD_FOOD).getColorType())).getColor();
	aColors[INFOBAR_RATE_EXTRA].a = 0.5f;
	aColors[INFOBAR_EMPTY] = GC.getColorInfo((ColorTypes)GC.getInfoTypeForString("COLOR_EMPTY")).getColor();
}


void CvGameTextMgr::setScoreHelp(CvWStringBuffer &szString, PlayerTypes ePlayer)
{
	if (NO_PLAYER != ePlayer)
	{
		CvPlayer& player = GET_PLAYER(ePlayer);

		int iPop = player.getPopScore();
		int iMaxPop = GC.getGame().getMaxPopulation();
		int iPopScore = 0;
		if (iMaxPop > 0)
		{
			iPopScore = (GC.getDefineINT("SCORE_POPULATION_FACTOR") * iPop) / iMaxPop;
		}
		int iLand = player.getLandScore();
		int iMaxLand = GC.getGame().getMaxLand();
		int iLandScore = 0;
		if (iMaxLand > 0)
		{
			iLandScore = (GC.getDefineINT("SCORE_LAND_FACTOR") * iLand) / iMaxLand;
		}
		int iTech = player.getTechScore();
		int iMaxTech = GC.getGame().getMaxTech();
		int iTechScore = 0;
		if (iMaxTech > 0)
		{
			iTechScore = (GC.getDefineINT("SCORE_TECH_FACTOR") * iTech) / std::max(1, iMaxTech);
		}
		int iWonders = player.getWondersScore();
		int iMaxWonders = GC.getGame().getMaxWonders();
		int iWondersScore = 0;
		if (iMaxWonders > 0)
		{
			iWondersScore = (GC.getDefineINT("SCORE_WONDER_FACTOR") * iWonders) / std::max(1, iMaxWonders);
		}
		int iTotalScore = iPopScore + iLandScore + iTechScore + iWondersScore;
		int iVictoryScore = player.calculateScore(true, true);
		szString.append(gDLL->getText("TXT_KEY_SCORE_BREAKDOWN",
			iPopScore, iPop, iMaxPop, iLandScore, iLand, iMaxLand, iTechScore,
			iTech, iMaxTech, iWondersScore, iWonders, iMaxWonders, iTotalScore, iVictoryScore)
		);
	}
}

void CvGameTextMgr::setEventHelp(CvWStringBuffer& szBuffer, EventTypes eEvent, int iEventTriggeredId, PlayerTypes ePlayer)
{
	PROFILE_EXTRA_FUNC();
	if (NO_EVENT == eEvent || NO_PLAYER == ePlayer)
	{
		return;
	}

	const CvEventInfo& kEvent = GC.getEventInfo(eEvent);
	CvPlayer& kActivePlayer = GET_PLAYER(ePlayer);
	const EventTriggeredData* pTriggeredData = kActivePlayer.getEventTriggered(iEventTriggeredId);

	if (!pTriggeredData)
	{
		return;
	}

	CvCity* pCity = kActivePlayer.getCity(pTriggeredData->m_iCityId);
	CvCity* pOtherPlayerCity = NULL;
	CvPlot* pPlot = GC.getMap().plot(pTriggeredData->m_iPlotX, pTriggeredData->m_iPlotY);
	CvUnit* pUnit = kActivePlayer.getUnit(pTriggeredData->m_iUnitId);

	if (NO_PLAYER != pTriggeredData->m_eOtherPlayer)
	{
		pOtherPlayerCity = GET_PLAYER(pTriggeredData->m_eOtherPlayer).getCity(pTriggeredData->m_iOtherPlayerCityId);
	}

	CvWString szCity = gDLL->getText("TXT_KEY_EVENT_THE_CITY");
	if (pCity && kEvent.isCityEffect())
	{
		szCity = pCity->getNameKey();
	}
	else if (pOtherPlayerCity && kEvent.isOtherPlayerCityEffect())
	{
		szCity = pOtherPlayerCity->getNameKey();
	}

	CvWString szUnit = gDLL->getText("TXT_KEY_EVENT_THE_UNIT");
	if (pUnit)
	{
		szUnit = pUnit->getNameKey();
	}

	CvWString szReligion = gDLL->getText("TXT_KEY_EVENT_THE_RELIGION");
	if (NO_RELIGION != pTriggeredData->m_eReligion)
	{
		szReligion = GC.getReligionInfo(pTriggeredData->m_eReligion).getTextKeyWide();
	}

	eventGoldHelp(szBuffer, eEvent, ePlayer, pTriggeredData->m_eOtherPlayer);

	eventTechHelp(szBuffer, eEvent, kActivePlayer.getBestEventTech(eEvent, pTriggeredData->m_eOtherPlayer), ePlayer, pTriggeredData->m_eOtherPlayer);

	if (NO_PLAYER != pTriggeredData->m_eOtherPlayer && NO_BONUS != kEvent.getBonusGift())
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_EVENT_GIFT_BONUS_TO_PLAYER", GC.getBonusInfo((BonusTypes)kEvent.getBonusGift()).getTextKeyWide(), GET_PLAYER(pTriggeredData->m_eOtherPlayer).getNameKey()));
	}

	if (kEvent.getHappy() != 0)
	{
		if (NO_PLAYER != pTriggeredData->m_eOtherPlayer)
		{
			if (kEvent.getHappy() > 0)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_EVENT_HAPPY_FROM_PLAYER", kEvent.getHappy(), kEvent.getHappy(), GET_PLAYER(pTriggeredData->m_eOtherPlayer).getNameKey()));
			}
			else
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_EVENT_HAPPY_TO_PLAYER", -kEvent.getHappy(), -kEvent.getHappy(), GET_PLAYER(pTriggeredData->m_eOtherPlayer).getNameKey()));
			}
		}
		else
		{
			if (kEvent.getHappy() > 0)
			{
				if (kEvent.isCityEffect() || kEvent.isOtherPlayerCityEffect())
				{
					szBuffer.append(NEWLINE);
					szBuffer.append(gDLL->getText("TXT_KEY_EVENT_HAPPY_CITY", kEvent.getHappy(), szCity.GetCString()));
				}
				else
				{
					szBuffer.append(NEWLINE);
					szBuffer.append(gDLL->getText("TXT_KEY_EVENT_HAPPY", kEvent.getHappy()));
				}
			}
			else
			{
				if (kEvent.isCityEffect() || kEvent.isOtherPlayerCityEffect())
				{
					szBuffer.append(NEWLINE);
					szBuffer.append(gDLL->getText("TXT_KEY_EVENT_UNHAPPY_CITY", -kEvent.getHappy(), szCity.GetCString()));
				}
				else
				{
					szBuffer.append(NEWLINE);
					szBuffer.append(gDLL->getText("TXT_KEY_EVENT_UNHAPPY", -kEvent.getHappy()));
				}
			}
		}
	}

	if (kEvent.getHealth() != 0)
	{
		if (NO_PLAYER != pTriggeredData->m_eOtherPlayer)
		{
			if (kEvent.getHealth() > 0)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_EVENT_HEALTH_FROM_PLAYER", kEvent.getHealth(), kEvent.getHealth(), GET_PLAYER(pTriggeredData->m_eOtherPlayer).getNameKey()));
			}
			else
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_EVENT_HEALTH_TO_PLAYER", -kEvent.getHealth(), -kEvent.getHealth(), GET_PLAYER(pTriggeredData->m_eOtherPlayer).getNameKey()));
			}
		}
		else
		{
			if (kEvent.getHealth() > 0)
			{
				if (kEvent.isCityEffect() || kEvent.isOtherPlayerCityEffect())
				{
					szBuffer.append(NEWLINE);
					szBuffer.append(gDLL->getText("TXT_KEY_EVENT_HEALTH_CITY", kEvent.getHealth(), szCity.GetCString()));
				}
				else
				{
					szBuffer.append(NEWLINE);
					szBuffer.append(gDLL->getText("TXT_KEY_EVENT_HEALTH", kEvent.getHealth()));
				}
			}
			else
			{
				if (kEvent.isCityEffect() || kEvent.isOtherPlayerCityEffect())
				{
					szBuffer.append(NEWLINE);
					szBuffer.append(gDLL->getText("TXT_KEY_EVENT_UNHEALTH", -kEvent.getHealth(), szCity.GetCString()));
				}
				else
				{
					szBuffer.append(NEWLINE);
					szBuffer.append(gDLL->getText("TXT_KEY_EVENT_UNHEALTH_CITY", -kEvent.getHealth()));
				}
			}
		}
	}

	if (kEvent.getHurryAnger() != 0)
	{
		if (kEvent.isCityEffect() || kEvent.isOtherPlayerCityEffect())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_EVENT_HURRY_ANGER_CITY", kEvent.getHurryAnger(), szCity.GetCString()));
		}
		else
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_EVENT_HURRY_ANGER", kEvent.getHurryAnger()));
		}
	}

	if (kEvent.getHappyTurns() > 0)
	{
		if (kEvent.isCityEffect() || kEvent.isOtherPlayerCityEffect())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_EVENT_TEMP_HAPPY_CITY", GC.getTEMP_HAPPY(), kEvent.getHappyTurns(), szCity.GetCString()));
		}
		else
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_EVENT_TEMP_HAPPY", GC.getTEMP_HAPPY(), kEvent.getHappyTurns()));
		}
	}

	if (kEvent.getFood() != 0)
	{
		if (kEvent.isCityEffect() || kEvent.isOtherPlayerCityEffect())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_EVENT_FOOD_CITY", kEvent.getFood(), szCity.GetCString()));
		}
		else
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_EVENT_FOOD", kEvent.getFood()));
		}
	}

	if (kEvent.getFoodPercent() != 0)
	{
		if (kEvent.isCityEffect() || kEvent.isOtherPlayerCityEffect())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_EVENT_FOOD_PERCENT_CITY", kEvent.getFoodPercent(), szCity.GetCString()));
		}
		else
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_EVENT_FOOD_PERCENT", kEvent.getFoodPercent()));
		}
	}

	if (kEvent.getRevoltTurns() > 0)
	{
		if (kEvent.isCityEffect() || kEvent.isOtherPlayerCityEffect())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_EVENT_REVOLT_TURNS", kEvent.getRevoltTurns(), szCity.GetCString()));
		}
	}

	if (0 != kEvent.getSpaceProductionModifier())
	{
		if (kEvent.isCityEffect() || kEvent.isOtherPlayerCityEffect())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_EVENT_SPACE_PRODUCTION_CITY", kEvent.getSpaceProductionModifier(), szCity.GetCString()));
		}
		else
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_SPACESHIP_MOD_ALL_CITIES", kEvent.getSpaceProductionModifier()));
		}
	}

	if (kEvent.getMaxPillage() > 0)
	{
		if (kEvent.isCityEffect() || kEvent.isOtherPlayerCityEffect())
		{
			if (kEvent.getMaxPillage() == kEvent.getMinPillage())
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_EVENT_PILLAGE_CITY", kEvent.getMinPillage(), szCity.GetCString()));
			}
			else
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_EVENT_PILLAGE_RANGE_CITY", kEvent.getMinPillage(), kEvent.getMaxPillage(), szCity.GetCString()));
			}
		}
		else
		{
			if (kEvent.getMaxPillage() == kEvent.getMinPillage())
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_EVENT_PILLAGE", kEvent.getMinPillage()));
			}
			else
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_EVENT_PILLAGE_RANGE", kEvent.getMinPillage(), kEvent.getMaxPillage()));
			}
		}
	}

	for (int i = 0; i < GC.getNumSpecialistInfos(); ++i)
	{
		if (kEvent.getFreeSpecialistCount(i) > 0)
		{
			if (kEvent.isCityEffect() || kEvent.isOtherPlayerCityEffect())
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_EVENT_FREE_SPECIALIST", kEvent.getFreeSpecialistCount(i), GC.getSpecialistInfo((SpecialistTypes)i).getTextKeyWide(), szCity.GetCString()));
			}
		}
	}

	if (kEvent.getPopulationChange() != 0)
	{
		if (kEvent.isCityEffect() || kEvent.isOtherPlayerCityEffect())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_EVENT_POPULATION_CHANGE_CITY", kEvent.getPopulationChange(), szCity.GetCString()));
		}
		else
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_EVENT_POPULATION_CHANGE", kEvent.getPopulationChange()));
		}
	}

	if (kEvent.getCulture() != 0)
	{
		if (kEvent.isCityEffect() || kEvent.isOtherPlayerCityEffect())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_EVENT_CULTURE_CITY", kEvent.getCulture(), szCity.GetCString()));
		}
		else
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_EVENT_CULTURE", kEvent.getCulture()));
		}
	}

	if (kEvent.getFreeUnit() != NO_UNIT)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_EVENT_BONUS_UNIT", kEvent.getNumUnits(), GC.getUnitInfo((UnitTypes) kEvent.getFreeUnit()).getTextKeyWide()));
	}

	const BuildingTypes eBuilding = static_cast<BuildingTypes>(kEvent.getBuilding());
	if (eBuilding != NO_BUILDING)
	{
		if (kEvent.getBuildingChange() > 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_EVENT_BONUS_BUILDING", GC.getBuildingInfo(eBuilding).getTextKeyWide()));
		}
		else if (kEvent.getBuildingChange() < 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_EVENT_REMOVE_BUILDING", GC.getBuildingInfo(eBuilding).getTextKeyWide()));
		}
	}

	if (kEvent.getNumBuildingYieldChanges() > 0)
	{
		if (pCity)
		{
			foreach_(const BuildingTypes eType, pCity->getHasBuildings())
			{
				int aiYields[NUM_YIELD_TYPES];
				for (int iYield = 0; iYield < NUM_YIELD_TYPES; ++iYield)
				{
					aiYields[iYield] = kEvent.getBuildingYieldChange(eType, iYield);
				}
				CvWStringBuffer szYield;
				szYield.clear();
				setYieldChangeHelp(szYield, L"", L"", L"", aiYields, false, false);
				if (!szYield.isEmpty())
				{
					szBuffer.append(NEWLINE);
					szBuffer.append(
						gDLL->getText(
							"TXT_KEY_EVENT_YIELD_CHANGE_BUILDING",
							GC.getBuildingInfo(eType).getTextKeyWide(),
							szYield.getCString()
						)
					);
				}
			}
		}
		else
		{
			for (int i = GC.getNumBuildingInfos() - 1; i > -1; i--)
			{
				int aiYields[NUM_YIELD_TYPES];
				for (int iYield = 0; iYield < NUM_YIELD_TYPES; ++iYield)
				{
					aiYields[iYield] = kEvent.getBuildingYieldChange(i, iYield);
				}
				CvWStringBuffer szYield;
				szYield.clear();
				setYieldChangeHelp(szYield, L"", L"", L"", aiYields, false, false);
				if (!szYield.isEmpty())
				{
					szBuffer.append(NEWLINE);
					szBuffer.append(
						gDLL->getText(
							"TXT_KEY_EVENT_YIELD_CHANGE_BUILDING",
							GC.getBuildingInfo(static_cast<BuildingTypes>(i)).getTextKeyWide(),
							szYield.getCString()
						)
					);
				}
			}
		}
	}

	if (kEvent.getNumBuildingCommerceChanges() > 0)
	{
		for (int iBuilding = 0; iBuilding < GC.getNumBuildingInfos(); ++iBuilding)
		{
			const BuildingTypes eBuilding = static_cast<BuildingTypes>(iBuilding);
			if (!pCity || pCity->hasBuilding(eBuilding))
			{
				int aiCommerces[NUM_COMMERCE_TYPES];
				for (int iCommerce = 0; iCommerce < NUM_COMMERCE_TYPES; ++iCommerce)
				{
					aiCommerces[iCommerce] = kEvent.getBuildingCommerceChange(iBuilding, iCommerce);
				}
				listCommerceChange(szBuffer, CvWString::format(L"\n%c%s: ", gDLL->getSymbolID(BULLET_CHAR), GC.getBuildingInfo(eBuilding).getDescription()), L"", aiCommerces);
			}
		}
	}

	if (kEvent.getNumBuildingHappyChanges() > 0)
	{
		if (pCity)
		{
			foreach_(const BuildingTypes eType, pCity->getHasBuildings())
			{
				const int iHappy = kEvent.getBuildingHappyChange(eType);
				if (iHappy > 0)
				{
					szBuffer.append(NEWLINE);
					szBuffer.append(
						gDLL->getText(
							"TXT_KEY_EVENT_HAPPY_BUILDING",
							GC.getBuildingInfo(eType).getTextKeyWide(),
							iHappy, gDLL->getSymbolID(HAPPY_CHAR)
						)
					);
				}
				else if (iHappy < 0)
				{
					szBuffer.append(NEWLINE);
					szBuffer.append(
						gDLL->getText(
							"TXT_KEY_EVENT_HAPPY_BUILDING",
							GC.getBuildingInfo(eType).getTextKeyWide(),
							-iHappy, gDLL->getSymbolID(UNHAPPY_CHAR)
						)
					);
				}
			}
		}
		else
		{
			for (int i = GC.getNumBuildingInfos() - 1; i > -1; i--)
			{
				const int iHappy = kEvent.getBuildingHappyChange(i);
				if (iHappy > 0)
				{
					szBuffer.append(NEWLINE);
					szBuffer.append(
						gDLL->getText(
							"TXT_KEY_EVENT_HAPPY_BUILDING",
							GC.getBuildingInfo(static_cast<BuildingTypes>(i)).getTextKeyWide(),
							iHappy, gDLL->getSymbolID(HAPPY_CHAR)
						)
					);
				}
				else if (iHappy < 0)
				{
					szBuffer.append(NEWLINE);
					szBuffer.append(
						gDLL->getText(
							"TXT_KEY_EVENT_HAPPY_BUILDING",
							GC.getBuildingInfo(static_cast<BuildingTypes>(i)).getTextKeyWide(),
							-iHappy, gDLL->getSymbolID(UNHAPPY_CHAR)
						)
					);
				}
			}
		}
	}

	if (kEvent.getNumBuildingHealthChanges() > 0)
	{
		if (pCity)
		{
			foreach_(const BuildingTypes eType, pCity->getHasBuildings())
			{
				const int iHealth = kEvent.getBuildingHealthChange(eType);
				if (iHealth > 0)
				{
					szBuffer.append(NEWLINE);
					szBuffer.append(
						gDLL->getText(
							"TXT_KEY_EVENT_HAPPY_BUILDING",
							GC.getBuildingInfo(eType).getTextKeyWide(),
							iHealth, gDLL->getSymbolID(HEALTHY_CHAR)
						)
					);
				}
				else if (iHealth < 0)
				{
					szBuffer.append(NEWLINE);
					szBuffer.append(
						gDLL->getText(
							"TXT_KEY_EVENT_HAPPY_BUILDING",
							GC.getBuildingInfo(eType).getTextKeyWide(),
							-iHealth, gDLL->getSymbolID(UNHEALTHY_CHAR)
						)
					);
				}
			}
		}
		else
		{
			for (int i = 0; i < GC.getNumBuildingInfos(); ++i)
			{
				const int iHealth = kEvent.getBuildingHealthChange(i);
				if (iHealth > 0)
				{
					szBuffer.append(NEWLINE);
					szBuffer.append(
						gDLL->getText(
							"TXT_KEY_EVENT_HAPPY_BUILDING",
							GC.getBuildingInfo(static_cast<BuildingTypes>(i)).getTextKeyWide(),
							iHealth, gDLL->getSymbolID(HEALTHY_CHAR)
						)
					);
				}
				else if (iHealth < 0)
				{
					szBuffer.append(NEWLINE);
					szBuffer.append(
						gDLL->getText(
							"TXT_KEY_EVENT_HAPPY_BUILDING",
							GC.getBuildingInfo(static_cast<BuildingTypes>(i)).getTextKeyWide(),
							-iHealth, gDLL->getSymbolID(UNHEALTHY_CHAR)
						)
					);
				}
			}
		}
	}

	if (kEvent.getRevolutionIndexChange() != 0)
	{
		if (kEvent.isCityEffect() || kEvent.isOtherPlayerCityEffect())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_EVENT_REVOLUTION_INDEX_CITY"));
		}
		else
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_EVENT_REVOLUTION_INDEX"));
		}
	}

	if (kEvent.getFeatureChange() > 0)
	{
		if (kEvent.getFeature() != NO_FEATURE)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_EVENT_FEATURE_GROWTH", GC.getFeatureInfo((FeatureTypes)kEvent.getFeature()).getTextKeyWide()));
		}
	}
	else if (kEvent.getFeatureChange() < 0)
	{
		if (pPlot && NO_FEATURE != pPlot->getFeatureType())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_EVENT_FEATURE_REMOVE", GC.getFeatureInfo(pPlot->getFeatureType()).getTextKeyWide()));
		}
	}

	if (kEvent.getImprovementChange() > 0)
	{
		if (kEvent.getImprovement() != NO_IMPROVEMENT)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_EVENT_IMPROVEMENT_GROWTH", GC.getImprovementInfo(kEvent.getImprovement()).getTextKeyWide()));
		}
	}
	else if (kEvent.getImprovementChange() < 0)
	{
		if (pPlot && NO_IMPROVEMENT != pPlot->getImprovementType())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_EVENT_IMPROVEMENT_REMOVE", GC.getImprovementInfo(pPlot->getImprovementType()).getTextKeyWide()));
		}
	}

	if (kEvent.getBonusChange() > 0)
	{
		if (kEvent.getBonus() != NO_BONUS)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_EVENT_BONUS_GROWTH", GC.getBonusInfo((BonusTypes)kEvent.getBonus()).getTextKeyWide()));
		}
	}
	else if (kEvent.getBonusChange() < 0)
	{
		if (pPlot && NO_BONUS != pPlot->getBonusType())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_EVENT_BONUS_REMOVE", GC.getBonusInfo(pPlot->getBonusType()).getTextKeyWide()));
		}
	}

	if (kEvent.getRouteChange() > 0)
	{
		if (kEvent.getRoute() != NO_ROUTE)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_EVENT_ROUTE_GROWTH", GC.getRouteInfo((RouteTypes)kEvent.getRoute()).getTextKeyWide()));
		}
	}
	else if (kEvent.getRouteChange() < 0)
	{
		if (pPlot && NO_ROUTE != pPlot->getRouteType())
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_EVENT_ROUTE_REMOVE", GC.getRouteInfo(pPlot->getRouteType()).getTextKeyWide()));
		}
	}

	int aiYields[NUM_YIELD_TYPES];
	for (int i = 0; i < NUM_YIELD_TYPES; ++i)
	{
		aiYields[i] = kEvent.getPlotExtraYield(i);
	}

	CvWStringBuffer szYield;
	setYieldChangeHelp(szYield, L"", L"", L"", aiYields, false, false);
	if (!szYield.isEmpty())
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_EVENT_YIELD_CHANGE_PLOT", szYield.getCString()));
	}

	if (NO_BONUS != kEvent.getBonusRevealed())
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_EVENT_BONUS_REVEALED", GC.getBonusInfo((BonusTypes)kEvent.getBonusRevealed()).getTextKeyWide()));
	}

	if (0 != kEvent.getUnitExperience())
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_EVENT_UNIT_EXPERIENCE", kEvent.getUnitExperience(), szUnit.GetCString()));
	}

	if (0 != kEvent.isDisbandUnit())
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_EVENT_UNIT_DISBAND", szUnit.GetCString()));
	}

	for (int i = 0; i < GC.getNumUnitCombatInfos(); ++i)
	{
		if (NO_PROMOTION != kEvent.getUnitCombatPromotion(i))
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_EVENT_UNIT_COMBAT_PROMOTION", GC.getUnitCombatInfo((UnitCombatTypes)i).getTextKeyWide(), GC.getPromotionInfo((PromotionTypes)kEvent.getUnitCombatPromotion(i)).getTextKeyWide()));
		}
	}

	for (int i = 0; i < GC.getNumUnitInfos(); ++i)
	{
		if (NO_PROMOTION != kEvent.getUnitPromotion(i))
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_EVENT_UNIT_CLASS_PROMOTION", GC.getUnitInfo((UnitTypes) i).getTextKeyWide(), GC.getPromotionInfo((PromotionTypes)kEvent.getUnitPromotion(i)).getTextKeyWide()));
		}
	}

	if (kEvent.getConvertOwnCities() > 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_EVENT_CONVERT_OWN_CITIES", kEvent.getConvertOwnCities(), szReligion.GetCString()));
	}

	if (kEvent.getConvertOtherCities() > 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_EVENT_CONVERT_OTHER_CITIES", kEvent.getConvertOtherCities(), szReligion.GetCString()));
	}

	if (NO_PLAYER != pTriggeredData->m_eOtherPlayer)
	{
		if (kEvent.getAttitudeModifier() > 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_EVENT_ATTITUDE_GOOD", kEvent.getAttitudeModifier(), GET_PLAYER(pTriggeredData->m_eOtherPlayer).getNameKey()));
		}
		else if (kEvent.getAttitudeModifier() < 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_EVENT_ATTITUDE_BAD", kEvent.getAttitudeModifier(), GET_PLAYER(pTriggeredData->m_eOtherPlayer).getNameKey()));
		}

		TeamTypes eWorstEnemy = GET_TEAM(GET_PLAYER(pTriggeredData->m_eOtherPlayer).getTeam()).AI_getWorstEnemy();
		if (NO_TEAM != eWorstEnemy)
		{
			if (kEvent.getTheirEnemyAttitudeModifier() > 0)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_EVENT_ATTITUDE_GOOD", kEvent.getTheirEnemyAttitudeModifier(), GET_TEAM(eWorstEnemy).getName().GetCString()));
			}
			else if (kEvent.getTheirEnemyAttitudeModifier() < 0)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_EVENT_ATTITUDE_BAD", kEvent.getTheirEnemyAttitudeModifier(), GET_TEAM(eWorstEnemy).getName().GetCString()));
			}
		}

		if (kEvent.getEspionagePoints() > 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_EVENT_ESPIONAGE_POINTS", kEvent.getEspionagePoints(), GET_PLAYER(pTriggeredData->m_eOtherPlayer).getNameKey()));
		}
		else if (kEvent.getEspionagePoints() < 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_EVENT_ESPIONAGE_COST", -kEvent.getEspionagePoints()));
		}
	}

	if (kEvent.isGoldenAge())
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_EVENT_GOLDEN_AGE"));
	}

	if (0 != kEvent.getFreeUnitSupport())
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_EVENT_FREE_UNIT_SUPPORT", kEvent.getFreeUnitSupport()));
	}

	if (0 != kEvent.getInflationModifier())
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_EVENT_INFLATION_MODIFIER", kEvent.getInflationModifier()));
	}

	if (kEvent.isDeclareWar())
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_EVENT_DECLARE_WAR", GET_PLAYER(pTriggeredData->m_eOtherPlayer).getCivilizationAdjectiveKey()));
	}

	if (kEvent.getUnitImmobileTurns() > 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_EVENT_IMMOBILE_UNIT", kEvent.getUnitImmobileTurns(), szUnit.GetCString()));
	}

	if (kEvent.isCityEffect())
		kEvent.getProperties()->buildChangesString(szBuffer, &szCity);

	kEvent.getPropertiesAllCities()->buildChangesAllCitiesString(szBuffer);

	if (!CvWString(kEvent.getPythonHelp()).empty())
	{
		CvWString szHelp = Cy::call<CvWString>(PYRandomEventModule, kEvent.getPythonHelp(), Cy::Args() << eEvent << pTriggeredData);
		szBuffer.append(NEWLINE);
		szBuffer.append(szHelp);
	}

	CvWStringBuffer szTemp;
	for (int i = 0; i < GC.getNumEventInfos(); ++i)
	{
		if (0 == kEvent.getAdditionalEventTime(i))
		{
			if (kEvent.getAdditionalEventChance(i) > 0 && kActivePlayer.canDoEvent((EventTypes)i, *pTriggeredData))
			{
				szTemp.clear();
				setEventHelp(szTemp, (EventTypes)i, iEventTriggeredId, ePlayer);

				if (!szTemp.isEmpty())
				{
					szBuffer.append(NEWLINE);
					szBuffer.append(gDLL->getText("TXT_KEY_EVENT_ADDITIONAL_CHANCE", kEvent.getAdditionalEventChance(i), L""));
					szBuffer.append(NEWLINE);
					szBuffer.append(szTemp);
				}
			}
		}
		else
		{
			szTemp.clear();
			setEventHelp(szTemp, (EventTypes)i, iEventTriggeredId, ePlayer);

			if (!szTemp.isEmpty())
			{
				CvWString szDelay = gDLL->getText("TXT_KEY_EVENT_DELAY_TURNS", kEvent.getAdditionalEventTime((EventTypes)i) * GC.getGameSpeedInfo(GC.getGame().getGameSpeedType()).getSpeedPercent() / 100);
				szBuffer.append(NEWLINE);

				if (kEvent.getAdditionalEventChance(i) > 0)
				{
					szBuffer.append(gDLL->getText("TXT_KEY_EVENT_ADDITIONAL_CHANCE", kEvent.getAdditionalEventChance(i), szDelay.GetCString()));
				}
				else
				{
					szBuffer.append(gDLL->getText("TXT_KEY_EVENT_DELAY", szDelay.GetCString()));
				}
				szBuffer.append(NEWLINE);
				szBuffer.append(szTemp);
			}
		}
	}

	if (NO_TECH != kEvent.getPrereqTech() && !GET_TEAM(kActivePlayer.getTeam()).isHasTech(kEvent.getPrereqTech()))
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_REQUIRES_LINK", CvWString(GC.getTechInfo(kEvent.getPrereqTech()).getType()).GetCString(), GC.getTechInfo(kEvent.getPrereqTech()).getTextKeyWide()));
	}

	bool done = false;
	while(!done)
	{
		done = true;
		if(!szBuffer.isEmpty())
		{
			const wchar_t* wideChar = szBuffer.getCString();
			if(wideChar[0] == L'\n')
			{
				CvWString tempString(&wideChar[1]);
				szBuffer.clear();
				szBuffer.append(tempString);
				done = false;
			}
		}
	}
}

void CvGameTextMgr::eventTechHelp(CvWStringBuffer& szBuffer, EventTypes eEvent, TechTypes eTech, PlayerTypes eActivePlayer, PlayerTypes eOtherPlayer) const
{
	const CvEventInfo& kEvent = GC.getEventInfo(eEvent);

	if (eTech != NO_TECH)
	{
		if (100 == kEvent.getTechPercent())
		{
			if (NO_PLAYER != eOtherPlayer)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_EVENT_TECH_GAINED_FROM_PLAYER", GC.getTechInfo(eTech).getTextKeyWide(), GET_PLAYER(eOtherPlayer).getNameKey()));
			}
			else
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_EVENT_TECH_GAINED", GC.getTechInfo(eTech).getTextKeyWide()));
			}
		}
		else if (0 != kEvent.getTechPercent())
		{
			CvTeam& kTeam = GET_TEAM(GET_PLAYER(eActivePlayer).getTeam());
			int iBeakers = (kTeam.getResearchCost(eTech) * kEvent.getTechPercent()) / 100;
			if (kEvent.getTechPercent() > 0)
			{
				iBeakers = std::min(kTeam.getResearchLeft(eTech), iBeakers);
			}
			else if (kEvent.getTechPercent() < 0)
			{
				iBeakers = std::max(kTeam.getResearchLeft(eTech) - kTeam.getResearchCost(eTech), iBeakers);
			}

			if (NO_PLAYER != eOtherPlayer)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_EVENT_TECH_GAINED_FROM_PLAYER_PERCENT", iBeakers, GC.getTechInfo(eTech).getTextKeyWide(), GET_PLAYER(eOtherPlayer).getNameKey()));
			}
			else
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_EVENT_TECH_GAINED_PERCENT", iBeakers, GC.getTechInfo(eTech).getTextKeyWide()));
			}
		}
	}
}

void CvGameTextMgr::eventGoldHelp(CvWStringBuffer& szBuffer, EventTypes eEvent, PlayerTypes ePlayer, PlayerTypes eOtherPlayer) const
{
	const CvEventInfo& kEvent = GC.getEventInfo(eEvent);
	CvPlayer& kPlayer = GET_PLAYER(ePlayer);

	int iGold1 = kPlayer.getEventCost(eEvent, eOtherPlayer, false);
	int iGold2 = kPlayer.getEventCost(eEvent, eOtherPlayer, true);

	if (iGold1 != iGold2) iGold2 = abs(iGold2);

	if (0 != iGold1 || 0 != iGold2)
	{
		if (iGold1 == iGold2)
		{
			if (NO_PLAYER != eOtherPlayer && kEvent.isGoldToPlayer())
			{
				if (iGold1 > 0)
				{
					szBuffer.append(NEWLINE);
					szBuffer.append(gDLL->getText("TXT_KEY_EVENT_GOLD_FROM_PLAYER", iGold1, GET_PLAYER(eOtherPlayer).getNameKey()));
				}
				else
				{
					szBuffer.append(NEWLINE);
					szBuffer.append(gDLL->getText("TXT_KEY_EVENT_GOLD_TO_PLAYER", -iGold1, GET_PLAYER(eOtherPlayer).getNameKey()));
				}
			}
			else
			{
				if (iGold1 > 0)
				{
					szBuffer.append(NEWLINE);
					szBuffer.append(gDLL->getText("TXT_KEY_EVENT_GOLD_GAINED", iGold1));
				}
				else
				{
					szBuffer.append(NEWLINE);
					szBuffer.append(gDLL->getText("TXT_KEY_EVENT_GOLD_LOST", -iGold1));
				}
			}
		}
		else
		{
			if (NO_PLAYER != eOtherPlayer && kEvent.isGoldToPlayer())
			{
				if (iGold1 > 0)
				{
					szBuffer.append(NEWLINE);
					szBuffer.append(gDLL->getText("TXT_KEY_EVENT_GOLD_RANGE_FROM_PLAYER", iGold1, iGold2, GET_PLAYER(eOtherPlayer).getNameKey()));
				}
				else
				{
					szBuffer.append(NEWLINE);
					szBuffer.append(gDLL->getText("TXT_KEY_EVENT_GOLD_RANGE_TO_PLAYER", -iGold1, -iGold2, GET_PLAYER(eOtherPlayer).getNameKey()));
				}
			}
			else
			{
				if (iGold1 > 0)
				{
					szBuffer.append(NEWLINE);
					szBuffer.append(gDLL->getText("TXT_KEY_EVENT_GOLD_RANGE_GAINED", iGold1, iGold2));
				}
				else
				{
					szBuffer.append(NEWLINE);
					szBuffer.append(gDLL->getText("TXT_KEY_EVENT_GOLD_RANGE_LOST", -iGold1, iGold2));
				}
			}
		}
	}
}

void CvGameTextMgr::setTradeRouteHelp(CvWStringBuffer &szBuffer, int iRoute, CvCity* pCity)
{
	PROFILE_EXTRA_FUNC();
	if (pCity)
	{
		CvCity* pOtherCity = pCity->getTradeCity(iRoute);

		if (pOtherCity)
		{
			szBuffer.append(pOtherCity->getName());

			int iProfit = pCity->getBaseTradeProfit(pOtherCity);

			szBuffer.append(NEWLINE);
			CvWString szBaseProfit;
			szBaseProfit.Format(L"%d.%02d", iProfit/100, iProfit%100);
			szBuffer.append(gDLL->getText("TXT_KEY_TRADE_ROUTE_HELP_BASE", szBaseProfit.GetCString()));

			int iModifier = 100;
			int iTestValue = pCity->getTradeRouteModifier();
			int iTradeRouteModifier = 0;

			foreach_(const BuildingTypes eTypeX, pCity->getHasBuildings())
			{
				if (!pCity->isReligiouslyLimitedBuilding(eTypeX) && !pCity->isDisabledBuilding(eTypeX))
				{
					const int iValue = GC.getBuildingInfo(eTypeX).getTradeRouteModifier();
					if (0 != iValue)
					{
						szBuffer.append(NEWLINE);
						szBuffer.append(gDLL->getText("TXT_KEY_TRADE_ROUTE_MOD_BUILDING", GC.getBuildingInfo(eTypeX).getTextKeyWide(), iValue));
						iTradeRouteModifier += iValue;
					}
				}
			}
			FAssert(iTradeRouteModifier == iTestValue);

			iModifier += iTradeRouteModifier;

			int iValue = pCity->getPopulationTradeModifier();
			if (0 != iValue)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_TRADE_ROUTE_MOD_POPULATION", iValue));
				iModifier += iValue;
			}

			if (pCity->isConnectedToCapital())
			{
				iValue = GC.getDefineINT("CAPITAL_TRADE_MODIFIER");
				if (0 != iValue)
				{
					szBuffer.append(NEWLINE);
					szBuffer.append(gDLL->getText("TXT_KEY_TRADE_ROUTE_MOD_CAPITAL", iValue));
					iModifier += iValue;
				}
			}

			iValue = GET_TEAM(pCity->getTeam()).getTradeModifier();
			if (0 != iValue)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_TRADE_ROUTE_TECH", iValue));
				iModifier += iValue;
			}

			if (pCity->area() != pOtherCity->area())
			{
				iValue = GC.getDefineINT("OVERSEAS_TRADE_MODIFIER");
				if (0 != iValue)
				{
					szBuffer.append(NEWLINE);
					szBuffer.append(gDLL->getText("TXT_KEY_TRADE_ROUTE_MOD_OVERSEAS", iValue));
					iModifier += iValue;
				}
			}

			if (pCity->getTeam() != pOtherCity->getTeam())
			{
				iValue = pCity->getForeignTradeRouteModifier();

				iValue += GET_TEAM(pCity->getTeam()).getForeignTradeModifier();
				iValue += GET_PLAYER(pCity->getOwner()).getForeignTradeRouteModifier();
				for (int iI = 0; iI < GC.getNumCivicOptionInfos(); iI++)
				{
					if (GET_PLAYER(pCity->getOwner()).getCivics((CivicOptionTypes)iI) == GET_PLAYER(pOtherCity->getOwner()).getCivics((CivicOptionTypes)iI))
					{
						if (GET_PLAYER(pCity->getOwner()).getCivics((CivicOptionTypes)iI) != NO_CIVIC)
						{
							iValue += GC.getCivicInfo(GET_PLAYER(pCity->getOwner()).getCivics((CivicOptionTypes)iI)).getSharedCivicTradeRouteModifier();
						}
					}
				}

				if (0 != iValue)
				{
					szBuffer.append(NEWLINE);
					szBuffer.append(gDLL->getText("TXT_KEY_TRADE_ROUTE_MOD_FOREIGN", iValue));
					iModifier += iValue;
				}

				iValue = pCity->getPeaceTradeModifier(pOtherCity->getTeam());
				if (0 != iValue)
				{
					szBuffer.append(NEWLINE);
					szBuffer.append(gDLL->getText("TXT_KEY_TRADE_ROUTE_MOD_PEACE", iValue));
					iModifier += iValue;
				}
			}

			FAssert(pCity->totalTradeModifier(pOtherCity) == iModifier);

			iProfit *= iModifier;

#ifdef _MOD_FRACTRADE
			iProfit /= 100;
			FAssert(iProfit == pCity->calculateTradeProfitTimes100(pOtherCity));
#else
			iProfit /= 10000;
			FAssert(iProfit == pCity->calculateTradeProfit(pOtherCity));
#endif

			szBuffer.append(SEPARATOR);
			szBuffer.append(NEWLINE);

#ifdef _MOD_FRACTRADE
			CvWString szProfit;
			szProfit.Format(L"%d.%02d", iProfit / 100, iProfit % 100);
			szBuffer.append(gDLL->getText("TXT_KEY_TRADE_ROUTE_TOTAL_FRACTIONAL", szProfit.GetCString()));
#else
			szBuffer.append(gDLL->getText("TXT_KEY_TRADE_ROUTE_TOTAL", iProfit));
#endif
		}
	}
}

void CvGameTextMgr::setEspionageCostHelp(CvWStringBuffer &szBuffer, EspionageMissionTypes eMission, PlayerTypes eTargetPlayer, const CvPlot* pPlot, int iExtraData, const CvUnit* pSpyUnit)
{
	CvPlayer& kPlayer = GET_PLAYER(GC.getGame().getActivePlayer());
	const CvEspionageMissionInfo& kMission = GC.getEspionageMissionInfo(eMission);

	//szBuffer.assign(kMission.getDescription());

	int64_t iMissionCost = kPlayer.getEspionageMissionBaseCost(eMission, eTargetPlayer, pPlot, iExtraData, pSpyUnit);

	if (pPlot)
	{
		if (kMission.isDestroyImprovement())
		{
			if (NO_IMPROVEMENT != pPlot->getImprovementType())
			{
				szBuffer.append(gDLL->getText("TXT_KEY_ESPIONAGE_HELP_DESTROY_IMPROVEMENT", GC.getImprovementInfo(pPlot->getImprovementType()).getTextKeyWide()));
				szBuffer.append(NEWLINE);
			}
		}

		const CvCity* pCity = pPlot->getPlotCity();
		if (pCity)
		{
			if (kMission.getDestroyBuildingCostFactor() > 0)
			{

				szBuffer.append(
					gDLL->getText(
						"TXT_KEY_ESPIONAGE_HELP_DESTROY_IMPROVEMENT",
						GC.getBuildingInfo((BuildingTypes)iExtraData).getTextKeyWide()
					)
				);
				szBuffer.append(NEWLINE);
			}

			if (kMission.getDestroyProjectCostFactor() > 0)
			{
				szBuffer.append(gDLL->getText("TXT_KEY_ESPIONAGE_HELP_DESTROY_IMPROVEMENT", GC.getProjectInfo((ProjectTypes)iExtraData).getTextKeyWide()));
				szBuffer.append(NEWLINE);
			}

			if (kMission.getDestroyProductionCostFactor() > 0)
			{
				szBuffer.append(gDLL->getText("TXT_KEY_ESPIONAGE_HELP_DESTROY_PRODUCTION", pCity->getProductionProgress()));
				szBuffer.append(NEWLINE);
			}

			if (kMission.getBuyCityCostFactor() > 0)
			{
				szBuffer.append(gDLL->getText("TXT_KEY_ESPIONAGE_HELP_BRIBE", pCity->getNameKey()));
				szBuffer.append(NEWLINE);
			}

			if (kMission.getCityInsertCultureCostFactor() > 0)
			{
				szBuffer.append(
					gDLL->getText(
						"TXT_KEY_ESPIONAGE_HELP_INSERT_CULTURE",
						pCity->getNameKey(),
						std::max(1, kMission.getCityInsertCultureAmountFactor() *  pCity->countTotalCultureTimes100() / 10000),
						kMission.getCityInsertCultureAmountFactor()
					)
				);
				szBuffer.append(NEWLINE);
			}

			if (kMission.getCityPoisonWaterCounter() > 0)
			{
				szBuffer.append(gDLL->getText("TXT_KEY_ESPIONAGE_HELP_POISON", kMission.getCityPoisonWaterCounter(), gDLL->getSymbolID(UNHEALTHY_CHAR), pCity->getNameKey(), kMission.getCityPoisonWaterCounter()));
				szBuffer.append(NEWLINE);
			}

			if (kMission.getCityUnhappinessCounter() > 0)
			{
				szBuffer.append(gDLL->getText("TXT_KEY_ESPIONAGE_HELP_POISON", kMission.getCityUnhappinessCounter(), gDLL->getSymbolID(UNHAPPY_CHAR), pCity->getNameKey(), kMission.getCityUnhappinessCounter()));
				szBuffer.append(NEWLINE);
			}

			if (kMission.getCityRevoltCounter() > 0)
			{
				szBuffer.append(gDLL->getText("TXT_KEY_ESPIONAGE_HELP_REVOLT", pCity->getNameKey(), kMission.getCityRevoltCounter()));
				szBuffer.append(NEWLINE);
			}

			if (kMission.isNuke())
			{
				szBuffer.append(gDLL->getText("TXT_KEY_ESPIONAGE_HELP_NUKE", pCity->getNameKey()));
				szBuffer.append(NEWLINE);
			}
			if (kMission.isRevolt())
			{
				szBuffer.append(gDLL->getText("TXT_KEY_ESPIONAGE_HELP_REVOLTUTION", pCity->getNameKey()));
				szBuffer.append(NEWLINE);
			}

			if (kMission.isDisablePower())
			{
				szBuffer.append(
					gDLL->getText(
						"TXT_KEY_ESPIONAGE_HELP_POWER",
						pCity->getNameKey(),
						6 * GC.getGameSpeedInfo(GC.getGame().getGameSpeedType()).getSpeedPercent() / 100
					)
				);
				szBuffer.append(NEWLINE);
			}

			if (kMission.getWarWearinessCounter() > 0)
			{
				szBuffer.append(gDLL->getText("TXT_KEY_ESPIONAGE_HELP_WAR_WEARINESS", pCity->getNameKey(), kMission.getWarWearinessCounter()));
				szBuffer.append(NEWLINE);
			}

			if (kMission.getSabatogeResearchCostFactor() > 0)
			{
				szBuffer.append(
					gDLL->getText(
						"TXT_KEY_ESPIONAGE_HELP_SABATOGE_RESEARCH",
						GET_PLAYER(eTargetPlayer).getNameKey(),
						GC.getTechInfo(GET_PLAYER(eTargetPlayer).getCurrentResearch()).getTextKeyWide()
					)
				);
				szBuffer.append(NEWLINE);
			}

			if (kMission.getRemoveReligionsCostFactor() > 0)
			{
				szBuffer.append(gDLL->getText("TXT_KEY_ESPIONAGE_HELP_REMOVE_RELIGIONS", GC.getReligionInfo((ReligionTypes)iExtraData).getTextKeyWide(), pCity->getNameKey()));
				szBuffer.append(NEWLINE);
			}

			if (kMission.getRemoveCorporationsCostFactor() > 0)
			{
				szBuffer.append(gDLL->getText("TXT_KEY_ESPIONAGE_HELP_REMOVE_RELIGIONS", GC.getCorporationInfo((CorporationTypes)iExtraData).getTextKeyWide(), pCity->getNameKey()));
				szBuffer.append(NEWLINE);
			}
		}
	}


	if (NO_PLAYER != eTargetPlayer)
	{
		if (kMission.getDestroyUnitCostFactor() > 0)
		{
			const CvUnit* pUnit = GET_PLAYER(eTargetPlayer).getUnit(iExtraData);

			if (pUnit)
			{
				szBuffer.append(gDLL->getText("TXT_KEY_ESPIONAGE_HELP_DESTROY_UNIT", pUnit->getNameKey()));
				szBuffer.append(NEWLINE);
			}
		}

		if (kMission.getBuyUnitCostFactor() > 0)
		{
			const CvUnit* pUnit = GET_PLAYER(eTargetPlayer).getUnit(iExtraData);

			if (pUnit)
			{
				szBuffer.append(gDLL->getText("TXT_KEY_ESPIONAGE_HELP_BRIBE", pUnit->getNameKey()));
				szBuffer.append(NEWLINE);
			}
		}

		if (kMission.getSwitchCivicCostFactor() > 0)
		{
			szBuffer.append(gDLL->getText("TXT_KEY_ESPIONAGE_HELP_SWITCH_CIVIC", GET_PLAYER(eTargetPlayer).getNameKey(), GC.getCivicInfo((CivicTypes)iExtraData).getTextKeyWide()));
			szBuffer.append(NEWLINE);
		}

		if (kMission.getSwitchReligionCostFactor() > 0)
		{
			szBuffer.append(gDLL->getText("TXT_KEY_ESPIONAGE_HELP_SWITCH_CIVIC", GET_PLAYER(eTargetPlayer).getNameKey(), GC.getReligionInfo((ReligionTypes)iExtraData).getTextKeyWide()));
			szBuffer.append(NEWLINE);
		}

		if (kMission.getPlayerAnarchyCounter() > 0)
		{
			szBuffer.append(gDLL->getText("TXT_KEY_ESPIONAGE_HELP_ANARCHY", GET_PLAYER(eTargetPlayer).getNameKey(), kMission.getPlayerAnarchyCounter() * GC.getGameSpeedInfo(GC.getGame().getGameSpeedType()).getSpeedPercent() / 100));
			szBuffer.append(NEWLINE);
		}

		if (kMission.getCounterespionageNumTurns() > 0 && kMission.getCounterespionageMod() > 0)
		{
			szBuffer.append(
				gDLL->getText(
					"TXT_KEY_ESPIONAGE_HELP_COUNTERESPIONAGE",
					kMission.getCounterespionageMod(),
					GET_PLAYER(eTargetPlayer).getCivilizationAdjectiveKey(),
					kMission.getCounterespionageNumTurns() * GC.getGameSpeedInfo(GC.getGame().getGameSpeedType()).getSpeedPercent() / 100
				)
			);
			szBuffer.append(NEWLINE);
		}

		if (kMission.getStealTreasuryTypes() > 0)
		{
			int64_t iGold = GET_PLAYER(eTargetPlayer).getGold() * kMission.getStealTreasuryTypes() / 100;

			if (pPlot)
			{
				const CvCity* pCity = pPlot->getPlotCity();

				if (pCity)
				{
					iGold *= pCity->getPopulation();
					iGold /= std::max(1, GET_PLAYER(eTargetPlayer).getTotalPopulation());
				}
			}
			szBuffer.append(gDLL->getText("TXT_KEY_ESPIONAGE_HELP_STEAL_TREASURY", iGold, GET_PLAYER(eTargetPlayer).getCivilizationAdjectiveKey()));
			szBuffer.append(NEWLINE);
		}
	}

	if (kMission.getBuyTechCostFactor() > 0)
	{
		szBuffer.append(gDLL->getText("TXT_KEY_ESPIONAGE_HELP_STEAL_TECH", GC.getTechInfo((TechTypes)iExtraData).getTextKeyWide()));
		szBuffer.append(NEWLINE);
	}

	szBuffer.append(NEWLINE);
	szBuffer.append(gDLL->getText("TXT_KEY_ESPIONAGE_BASE_COST", iMissionCost));

	if (kPlayer.getEspionageMissionCost(eMission, eTargetPlayer, pPlot, iExtraData, pSpyUnit) > 0)
	{
		int iModifier = 100;
		CvCity* pCity = pPlot ? pPlot->getPlotCity() : NULL;

		if (pCity && GC.getEspionageMissionInfo(eMission).isTargetsCity())
		{
			{
				// City Population
				const int iTempModifier = (GC.getDefineINT("ESPIONAGE_CITY_POP_EACH_MOD") * (pCity->getPopulation() - 1));
				if (0 != iTempModifier)
				{
					szBuffer.append(NEWLINE);
					szBuffer.append(gDLL->getText("TXT_KEY_ESPIONAGE_POPULATION_MOD", iTempModifier));
					iModifier *= 100 + iTempModifier;
					iModifier /= 100;
				}
			}

			// Trade Route
			if (pCity->isTradeRoute(kPlayer.getID()))
			{
				const int iTempModifier = GC.getDefineINT("ESPIONAGE_CITY_TRADE_ROUTE_MOD");
				if (0 != iTempModifier)
				{
					szBuffer.append(NEWLINE);
					szBuffer.append(gDLL->getText("TXT_KEY_ESPIONAGE_TRADE_ROUTE_MOD", iTempModifier));
					iModifier *= 100 + iTempModifier;
					iModifier /= 100;
				}
			}

			const ReligionTypes eReligion = kPlayer.getStateReligion();
			if (NO_RELIGION != eReligion && pCity->isHasReligion(eReligion))
			{
				int iTempModifier = 0;

				if (GET_PLAYER(eTargetPlayer).getStateReligion() != eReligion)
				{
					iTempModifier += GC.getDefineINT("ESPIONAGE_CITY_RELIGION_STATE_MOD");
				}
				if (kPlayer.hasHolyCity(eReligion))
				{
					iTempModifier += GC.getDefineINT("ESPIONAGE_CITY_HOLY_CITY_MOD");
				}
				if (0 != iTempModifier)
				{
					szBuffer.append(NEWLINE);
					szBuffer.append(gDLL->getText("TXT_KEY_ESPIONAGE_RELIGION_MOD", iTempModifier));
					iModifier *= 100 + iTempModifier;
					iModifier /= 100;
				}
			}

			{
				// City's culture affects cost
				const int iTempModifier = -pCity->getCultureTimes100(kPlayer.getID()) * GC.getDefineINT("ESPIONAGE_CULTURE_MULTIPLIER_MOD")
					/ std::max(1, pCity->getCultureTimes100(eTargetPlayer) + pCity->getCultureTimes100(kPlayer.getID()));

				if (0 != iTempModifier)
				{
					szBuffer.append(NEWLINE);
					szBuffer.append(gDLL->getText("TXT_KEY_ESPIONAGE_CULTURE_MOD", iTempModifier));
					iModifier *= 100 + iTempModifier;
					iModifier /= 100;
				}
			}

			const int iTempModifier = pCity->getEspionageDefenseModifier();
			if (0 != iTempModifier)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_ESPIONAGE_DEFENSE_MOD", iTempModifier));
				iModifier *= 100 + iTempModifier;
				iModifier /= 100;
			}
		}

		// Distance mod
		if (pPlot)
		{
			int iDistance = GC.getMap().maxPlotDistance();

			const CvCity* pOurCapital = kPlayer.getCapitalCity();
			if (pOurCapital)
			{
				if (kMission.isSelectPlot() || kMission.isTargetsCity())
				{
					iDistance = plotDistance(pOurCapital->getX(), pOurCapital->getY(), pPlot->getX(), pPlot->getY());
				}
				else
				{
					const CvCity* pTheirCapital = GET_PLAYER(eTargetPlayer).getCapitalCity();
					if (pTheirCapital)
					{
						iDistance = plotDistance(pOurCapital->getX(), pOurCapital->getY(), pTheirCapital->getX(), pTheirCapital->getY());
					}
				}
			}

			const int iTempModifier = (iDistance + GC.getMap().maxPlotDistance()) * GC.getDefineINT("ESPIONAGE_DISTANCE_MULTIPLIER_MOD") / GC.getMap().maxPlotDistance() - 100;
			if (0 != iTempModifier)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_ESPIONAGE_DISTANCE_MOD", iTempModifier));
				iModifier *= 100 + iTempModifier;
				iModifier /= 100;
			}
		}

		// Spy presence mission cost alteration
		if (pSpyUnit)
		{
			const int iTempModifier = (
				-std::min(5, pSpyUnit->getFortifyTurns() + pSpyUnit->getUpgradeDiscount() / 10)
				* GC.getDefineINT("ESPIONAGE_EACH_TURN_UNIT_COST_DECREASE")
			);
			if (0 != iTempModifier)
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_ESPIONAGE_SPY_STATIONARY_MOD", iTempModifier));
				iModifier *= 100 + iTempModifier;
				iModifier /= 100;
			}
		}

		{
			// My points VS. Your points to mod cost
			const int iTempModifier = GC.getDefineINT("ESPIONAGE_SPENDING_MULTIPLIER")
				* (GET_TEAM(GET_PLAYER(eTargetPlayer).getTeam()).getEspionagePointsEver() * 2 + GET_TEAM(kPlayer.getTeam()).getEspionagePointsEver())
				/ std::max(
				1, GET_TEAM(GET_PLAYER(eTargetPlayer).getTeam()).getEspionagePointsEver() + 2 * GET_TEAM(kPlayer.getTeam()).getEspionagePointsEver()
				) - 100;

			if (0 != iTempModifier)
			{
				szBuffer.append(SEPARATOR);
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_ESPIONAGE_EP_RATIO_MOD", iTempModifier));
				iModifier *= 100 + iTempModifier;
				iModifier /= 100;
			}
		}

		// Counterespionage Mission Mod
		CvTeam& kTargetTeam = GET_TEAM(GET_PLAYER(eTargetPlayer).getTeam());
		if (kTargetTeam.getCounterespionageModAgainstTeam(kPlayer.getTeam()) > 0)
		{
			const int iTempModifier = kTargetTeam.getCounterespionageModAgainstTeam(kPlayer.getTeam()) - 100;
			if (0 != iTempModifier)
			{
				szBuffer.append(SEPARATOR);
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_ESPIONAGE_COUNTERESPIONAGE_MOD", iTempModifier));
				iModifier *= 100 + iTempModifier;
				iModifier /= 100;
			}
		}

		if (pCity)
		{
			if (pCity == GET_PLAYER(pCity->getOwner()).getCapitalCity() && kTargetTeam.isHasEmbassy(kPlayer.getTeam()))
			{
				const int iTempModifier = -GC.getDefineINT("EMBASSY_ESPIONAGE_MISSION_COST_MODIFIER");
				if (0 != iTempModifier)
				{
					szBuffer.append(SEPARATOR);
					szBuffer.append(NEWLINE);
					szBuffer.append(gDLL->getText("TXT_KEY_ESPIONAGE_EMBASSY_MOD", iTempModifier));
					iModifier *= 100 + iTempModifier;
					iModifier /= 100;
				}
			}
			if (kTargetTeam.isFreeTradeAgreement(kPlayer.getTeam()))
			{
				const int iTempModifier = -GC.getDefineINT("FREE_TRADE_AGREEMENT_ESPIONAGE_MISSION_COST_MODIFIER");
				if (0 != iTempModifier)
				{
					szBuffer.append(SEPARATOR);
					szBuffer.append(NEWLINE);
					szBuffer.append(gDLL->getText("TXT_KEY_FREE_TRADE_AGREEMENT_MOD", iTempModifier));
					iModifier *= 100 + iTempModifier;
					iModifier /= 100;
				}
			}
		}
		// Toffer - Should add some text for this last part too I guess...
		iModifier += GC.getESPIONAGE_MISSION_COST_END_TOTAL_PERCENT_ADJUSTMENT();

		FAssert(iModifier == kPlayer.getEspionageMissionCostModifier(eMission, eTargetPlayer, pPlot, pSpyUnit));

		iMissionCost *= iModifier;
		iMissionCost /= 100;

		FAssert(iMissionCost == kPlayer.getEspionageMissionCost(eMission, eTargetPlayer, pPlot, iExtraData, pSpyUnit));

		szBuffer.append(SEPARATOR);

		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_ESPIONAGE_COST_TOTAL", iMissionCost));


		if (pSpyUnit)
		{
			int iInterceptChance = (pSpyUnit->getSpyInterceptPercent(GET_PLAYER(eTargetPlayer).getTeam()) * (100 + kMission.getDifficultyMod())) / 100;

			szBuffer.append(NEWLINE);
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_ESPIONAGE_CHANCE_OF_SUCCESS", std::min(100, std::max(0, 100 - iInterceptChance))));
		}
	}
}

void CvGameTextMgr::getTradeScreenTitleIcon(CvString& szButton, CvWidgetDataStruct& widgetData, PlayerTypes ePlayer)
{
	szButton.clear();

	ReligionTypes eReligion = GET_PLAYER(ePlayer).getStateReligion();
	if (eReligion != NO_RELIGION)
	{
		szButton = GC.getReligionInfo(eReligion).getButton();
		widgetData.m_eWidgetType = WIDGET_HELP_RELIGION;
		widgetData.m_iData1 = eReligion;
		widgetData.m_iData2 = -1;
		widgetData.m_bOption = false;
	}
}

void CvGameTextMgr::getTradeScreenIcons(std::vector< std::pair<CvString, CvWidgetDataStruct> >& aIconInfos, PlayerTypes ePlayer)
{
	PROFILE_EXTRA_FUNC();
	aIconInfos.clear();
	for (int i = 0; i < GC.getNumCivicOptionInfos(); i++)
	{
		CivicTypes eCivic = GET_PLAYER(ePlayer).getCivics((CivicOptionTypes)i);
		CvWidgetDataStruct widgetData;
		widgetData.m_eWidgetType = WIDGET_PEDIA_JUMP_TO_CIVIC;
		widgetData.m_iData1 = eCivic;
		widgetData.m_iData2 = -1;
		widgetData.m_bOption = false;
		aIconInfos.push_back(std::make_pair(GC.getCivicInfo(eCivic).getButton(), widgetData));
	}

}

void CvGameTextMgr::getTradeScreenHeader(CvWString& szHeader, PlayerTypes ePlayer, PlayerTypes eOtherPlayer, bool bAttitude)
{
	const CvPlayer& kPlayer = GET_PLAYER(ePlayer);
	szHeader.Format(L"%s - %s", CvWString(kPlayer.getName()).GetCString(), CvWString(kPlayer.getCivilizationDescription()).GetCString());
	if (bAttitude)
	{
		szHeader += CvWString::format(L" (%s)", GC.getAttitudeInfo(kPlayer.AI_getAttitude(eOtherPlayer)).getDescription());
	}
}

// BUG - Trade Hover - start
void CvGameTextMgr::buildDomesticTradeString(CvWStringBuffer& szBuffer, PlayerTypes ePlayer) const
{
	buildTradeString(szBuffer, ePlayer, NO_PLAYER, true, false, false);
}

void CvGameTextMgr::buildForeignTradeString(CvWStringBuffer& szBuffer, PlayerTypes ePlayer) const
{
	buildTradeString(szBuffer, ePlayer, NO_PLAYER, false, true, false);
}

void CvGameTextMgr::buildTradeString(CvWStringBuffer& szBuffer, PlayerTypes ePlayer, PlayerTypes eWithPlayer, bool bDomestic, bool bForeign, bool bHeading) const
{
	if (NO_PLAYER == ePlayer)
	{
		return;
	}

	const CvPlayer& player = GET_PLAYER(ePlayer);
	if (bHeading)
	{
		if (ePlayer == eWithPlayer)
		{
			szBuffer.append(gDLL->getText("TXT_KEY_BUG_DOMESTIC_TRADE_HEADING"));
		}
		else if (NO_PLAYER != eWithPlayer)
		{
			if (player.canHaveTradeRoutesWith(eWithPlayer))
			{
				szBuffer.append(gDLL->getText("TXT_KEY_BUG_FOREIGN_TRADE_HEADING", GET_PLAYER(eWithPlayer).getNameKey(), GET_PLAYER(eWithPlayer).getCivilizationShortDescription()));
			}
			else
			{
				szBuffer.append(gDLL->getText("TXT_KEY_BUG_CANNOT_TRADE_HEADING", GET_PLAYER(eWithPlayer).getNameKey(), GET_PLAYER(eWithPlayer).getCivilizationShortDescription()));
			}
		}
		else
		{
			szBuffer.append(gDLL->getText("TXT_KEY_BUG_TRADE_HEADING"));
		}
		szBuffer.append(NEWLINE);
	}

	if (NO_PLAYER != eWithPlayer)
	{
		bDomestic = ePlayer == eWithPlayer;
		bForeign = ePlayer != eWithPlayer;

		if (bForeign && !player.canHaveTradeRoutesWith(eWithPlayer))
		{
			const CvPlayer& withPlayer = GET_PLAYER(eWithPlayer);
			bool bCanTrade = true;
			if (!GET_PLAYER(eWithPlayer).isAlive())
			{
				szBuffer.append(gDLL->getText("TXT_KEY_BUG_CANNOT_TRADE_DEAD"));
				return;
			}
			if (!player.canTradeNetworkWith(eWithPlayer))
			{
				szBuffer.append(gDLL->getText("TXT_KEY_BUG_CANNOT_TRADE_NETWORK_NOT_CONNECTED"));
				bCanTrade = false;
			}
			if (!GET_TEAM(player.getTeam()).isFreeTrade(withPlayer.getTeam()))
			{
				szBuffer.append(gDLL->getText("TXT_KEY_BUG_CANNOT_TRADE_CLOSED_BORDERS"));
				bCanTrade = false;
			}
			if (player.isNoForeignTrade())
			{
				szBuffer.append(gDLL->getText("TXT_KEY_BUG_CANNOT_TRADE_FOREIGN_YOU"));
				bCanTrade = false;
			}
			if (withPlayer.isNoForeignTrade())
			{
				szBuffer.append(gDLL->getText("TXT_KEY_BUG_CANNOT_TRADE_FOREIGN_THEM"));
				bCanTrade = false;
			}

			if (!bCanTrade)
			{
				return;
			}
		}
	}

	int iDomesticYield = 0;
	int iDomesticRoutes = 0;
	int iForeignYield = 0;
	int iForeignRoutes = 0;

	player.calculateTradeTotals(YIELD_COMMERCE, iDomesticYield, iDomesticRoutes, iForeignYield, iForeignRoutes, eWithPlayer, false);

	int iTotalYield = 0;
	int iTotalRoutes = 0;
	if (bDomestic)
	{
		iTotalYield += iDomesticYield;
		iTotalRoutes += iDomesticRoutes;
	}
	if (bForeign)
	{
		iTotalYield += iForeignYield;
		iTotalRoutes += iForeignRoutes;
	}

	CvWString szYield;
// BUG - Fractional Trade Routes - start
#ifdef _MOD_FRACTRADE
	szYield.Format(L"%d.%02d", iTotalYield / 100, iTotalYield % 100);
#else
	szYield.Format(L"%d", iTotalYield);
#endif
// BUG - Fractional Trade Routes - end
	szBuffer.append(gDLL->getText("TXT_KEY_BUG_TOTAL_TRADE_YIELD", szYield.GetCString()));
	szBuffer.append(gDLL->getText("TXT_KEY_BUG_TOTAL_TRADE_ROUTES", iTotalRoutes));

	if (iTotalRoutes > 0)
	{
// BUG - Fractional Trade Routes - start
#ifdef _MOD_FRACTRADE
		int iAverage = iTotalYield / iTotalRoutes;
#else
		int iAverage = 100 * iTotalYield / iTotalRoutes;
#endif
// BUG - Fractional Trade Routes - end
		CvWString szAverage;
		szAverage.Format(L"%d.%02d", iAverage / 100, iAverage % 100);
		szBuffer.append(gDLL->getText("TXT_KEY_BUG_AVERAGE_TRADE_YIELD", szAverage.GetCString()));
	}
}
// BUG - Trade Hover - end

void CvGameTextMgr::getGlobeLayerName(GlobeLayerTypes eType, int iOption, CvWString& strName)
{
	switch (eType)
	{
	case GLOBE_LAYER_STRATEGY:
		switch(iOption)
		{
		case 0:
			strName = gDLL->getText("TXT_KEY_GLOBELAYER_STRATEGY_VIEW");
			break;
		case 1:
			strName = gDLL->getText("TXT_KEY_GLOBELAYER_STRATEGY_NEW_LINE");
			break;
		case 2:
			strName = gDLL->getText("TXT_KEY_GLOBELAYER_STRATEGY_NEW_SIGN");
			break;
		case 3:
			strName = gDLL->getText("TXT_KEY_GLOBELAYER_STRATEGY_DELETE");
			break;
		case 4:
			strName = gDLL->getText("TXT_KEY_GLOBELAYER_STRATEGY_DELETE_LINES");
			break;
		}
		break;
	case GLOBE_LAYER_UNIT:
		switch(iOption)
		{
		case SHOW_ALL_MILITARY:
			strName = gDLL->getText("TXT_KEY_GLOBELAYER_UNITS_ALLMILITARY");
			break;
		case SHOW_TEAM_MILITARY:
			strName = gDLL->getText("TXT_KEY_GLOBELAYER_UNITS_TEAMMILITARY");
			break;
		case SHOW_ENEMIES_IN_TERRITORY:
			strName = gDLL->getText("TXT_KEY_GLOBELAYER_UNITS_ENEMY_TERRITORY_MILITARY");
			break;
		case SHOW_ENEMIES:
			strName = gDLL->getText("TXT_KEY_GLOBELAYER_UNITS_ENEMYMILITARY");
			break;
		case SHOW_PLAYER_DOMESTICS:
			strName = gDLL->getText("TXT_KEY_GLOBELAYER_UNITS_DOMESTICS");
			break;
		}
		break;
	case GLOBE_LAYER_RESOURCE:
		switch(iOption)
		{
		case SHOW_RESOURCES_ALL:
			strName = gDLL->getText("TXT_KEY_ALL_RESOURCES");
			break;
		case SHOW_RESOURCES_STRATEGIC:
			strName = gDLL->getText("TXT_KEY_STRATEGIC");
			break;
		case SHOW_RESOURCES_LUXURY:
			strName = gDLL->getText("TXT_KEY_LUXURY");
			break;
		case SHOW_RESOURCES_PRODUCTION:
			strName = gDLL->getText("TXT_KEY_PRODUCTION");
			break;
		case SHOW_RESOURCES_GROWTH:
			strName = gDLL->getText("TXT_KEY_GROWTH");
			break;
		case SHOW_RESOURCES_MISC:
			strName = gDLL->getText("TXT_KEY_MISC");
			break;
		case SHOW_RESOURCES_UNCLAIMED:
			strName = gDLL->getText("TXT_KEY_UNCLAIMED");
			break;
		case SHOW_RESOURCES_CANCLAIM:
			strName = gDLL->getText("TXT_KEY_CANCLAIM");
			break;
		}
		break;
	case GLOBE_LAYER_RELIGION:
		strName = GC.getReligionInfo((ReligionTypes) iOption).getDescription();
		break;
	case GLOBE_LAYER_CULTURE:
	case GLOBE_LAYER_TRADE:
		// these have no sub-options
		strName.clear();
		break;
	}
}

void CvGameTextMgr::getPlotHelp(CvPlot* mousePlot, CvCity* city, CvPlot* flagPlot, bool bAlt, CvWStringBuffer& strHelp)
{
	PROFILE_EXTRA_FUNC();

	if (city)
	{
		setCityBarHelp(strHelp, city);
	}
	else if (flagPlot)
	{
		setPlotListHelp(strHelp, flagPlot, false, true);
	}

	if (mousePlot)
	{
		if (strHelp.isEmpty()
		&& (bAlt || mousePlot == gDLL->getInterfaceIFace()->getGotoPlot())
		&& mousePlot->isVisiblePotentialEnemyDefender(gDLL->getInterfaceIFace()->getSelectionList()->getHeadUnit()))
		{
			setCombatPlotHelp(strHelp, mousePlot);
		}

		if (strHelp.isEmpty() && mousePlot->isRevealed(GC.getGame().getActiveTeam(), true))
		{
			if (mousePlot->isActiveVisible(true))
			{
				setPlotListHelp(strHelp, mousePlot, true, false);

				if (!strHelp.isEmpty())
				{
					strHelp.append(L"\n");
				}
			}
			setPlotHelp(strHelp, mousePlot);
		}

		if (mousePlot->isRevealed(GC.getGame().getActiveTeam(), true)
		&& mousePlot->isActiveVisible(true) && mousePlot->getTeam() != NO_TEAM)
		{
			const CvUnit* selectedUnit = gDLL->getInterfaceIFace()->getHeadSelectedUnit();
			if (selectedUnit
			&& GET_TEAM(mousePlot->getTeam()).isAtWar(selectedUnit->getTeam())
			&& !selectedUnit->canEnterPlot(mousePlot))
			{
				CvWString szTempBuffer;
				szTempBuffer.clear();
				if (mousePlot->isCity())
				{
					const CvCity* mouseOverCity = mousePlot->getPlotCity();
					int iMinimumDefenseLevel = MAX_INT;
					BuildingTypes eBestBuilding = NO_BUILDING;

					foreach_(const BuildingTypes eTypeX, mouseOverCity->getHasBuildings())
					{
						if (!mouseOverCity->isDisabledBuilding(eTypeX))
						{
							const int iNoEntryDefense = GC.getBuildingInfo(eTypeX).getNoEntryDefenseLevel();

							if(iNoEntryDefense > 0 && iNoEntryDefense < iMinimumDefenseLevel)
							{
								iMinimumDefenseLevel = iNoEntryDefense;
								eBestBuilding = eTypeX;
							}
						}
					}
					if (mouseOverCity->getExtraMinDefense() > iMinimumDefenseLevel)
					{
						iMinimumDefenseLevel = mouseOverCity->getExtraMinDefense();
					}
					if (eBestBuilding != NO_BUILDING
					&& mouseOverCity->getDefenseModifier(false) > iMinimumDefenseLevel
					&& !selectedUnit->canIgnoreNoEntryLevel())
					{
						szTempBuffer.clear();
						szTempBuffer.append(gDLL->getText("TXT_KEY_PLOT_HOVER_MAX_CITY_DEFENSES", mouseOverCity->getNameKey(), GC.getBuildingInfo(eBestBuilding).getDescription(), GC.getBuildingInfo(eBestBuilding).getDescription(), iMinimumDefenseLevel));
					}
				}
				else if (GC.getGame().isOption(GAMEOPTION_UNSUPPORTED_ZONE_OF_CONTROL))
				{
					// Fort ZoC
					const PlayerTypes eDefender = selectedUnit->plot()->controlsAdjacentZOCSource(selectedUnit->getTeam());
					if (eDefender != NO_PLAYER)
					{
						const CvPlot* pZoneOfControl = selectedUnit->plot()->isInFortControl(true, eDefender, selectedUnit->getOwner());
						const CvPlot* pForwardZoneOfControl = mousePlot->isInFortControl(true, eDefender, selectedUnit->getOwner());
						if (pZoneOfControl && pForwardZoneOfControl
						&& pZoneOfControl == mousePlot->isInFortControl(true, eDefender, selectedUnit->getOwner(), pZoneOfControl))
						{
							szTempBuffer.clear();
							szTempBuffer.append(gDLL->getText("TXT_KEY_PLOT_HOVER_FORT_ZOC"));
						}
					}
					// City ZoC
					if (selectedUnit->plot()->isInCityZoneOfControl(selectedUnit->getOwner()) && mousePlot->isInCityZoneOfControl(selectedUnit->getOwner()))
					{
						szTempBuffer.clear();
						szTempBuffer.append(gDLL->getText("TXT_KEY_PLOT_HOVER_CITY_ZOC"));
					}
					// Promotion ZoC
					if (selectedUnit->plot()->isInUnitZoneOfControl(selectedUnit->getOwner()) && mousePlot->isInUnitZoneOfControl(selectedUnit->getOwner()))
					{
						szTempBuffer.clear();
						szTempBuffer.append(gDLL->getText("TXT_KEY_PLOT_HOVER_UNIT_ZOC"));
					}
				}

				if (szTempBuffer != L"")
				{
					strHelp.assign(szTempBuffer);
				}
			}
		}
	}

	const InterfaceModeTypes eInterfaceMode = gDLL->getInterfaceIFace()->getInterfaceMode();
	if (eInterfaceMode != INTERFACEMODE_SELECTION)
	{
		CvWString szTempBuffer;
		szTempBuffer.Format(SETCOLR L"%s" ENDCOLR NEWLINE, TEXT_COLOR("COLOR_HIGHLIGHT_TEXT"), GC.getInterfaceModeInfo(eInterfaceMode).getDescription());

		switch (eInterfaceMode)
		{
			case INTERFACEMODE_REBASE:
			{
				getRebasePlotHelp(mousePlot, szTempBuffer);
				break;
			}
			case INTERFACEMODE_NUKE:
			{
				if (mousePlot)
				{
					const CvUnit* unit = gDLL->getInterfaceIFace()->getHeadSelectedUnit();

					if (unit)
					{
						const CvTeam& team = GET_TEAM(unit->getTeam());

						for (int iI = 0; iI < MAX_PC_TEAMS; iI++)
						{
							if (!team.isAtWar(static_cast<TeamTypes>(iI))
							&&  !team.canDeclareWar(static_cast<TeamTypes>(iI))
							&&  unit->isNukeVictim(mousePlot, static_cast<TeamTypes>(iI), unit->nukeRange()))
							{
								szTempBuffer += gDLL->getText("TXT_KEY_CANT_NUKE_FRIENDS");
								break;
							}
						}
					}
				}
				break;
			}
			case INTERFACEMODE_SHADOW_UNIT:
			{
				if (mousePlot)
				{
					const CvUnit* pHeadSelectedUnit = gDLL->getInterfaceIFace()->getHeadSelectedUnit();
					if (pHeadSelectedUnit
					&& !pHeadSelectedUnit->getGroup()->canDoInterfaceModeAt(eInterfaceMode, mousePlot))
					{
						strHelp.clear();
						const CvUnit* pShadowUnit = mousePlot->getCenterUnit(false);
						if (pShadowUnit)
						{
							const int iValidShadowUnits = algo::count_if(mousePlot->units(), bind(CvUnit::canShadowAt, pHeadSelectedUnit, mousePlot, _1));
							if (iValidShadowUnits == 0)
							{
								bool bFirst = true;
								if (pShadowUnit->baseMoves() > pHeadSelectedUnit->baseMoves())
								{
									strHelp.append(gDLL->getText("TXT_KEY_CAN_NOT_AUTOMATE_PROTECT_NOT_FAST_ENOUGH", pShadowUnit->getNameKey(), pHeadSelectedUnit->getNameKey(), pShadowUnit->baseMoves(), pShadowUnit->getNameKey()));
									bFirst = false;
								}
								if (pShadowUnit->getTeam() != pHeadSelectedUnit->getTeam())
								{
									if (!bFirst)
										strHelp.append(L"\n");
									strHelp.append(gDLL->getText("TXT_KEY_CAN_NOT_AUTOMATE_PROTECT_DIFFERENT_TEAM", pShadowUnit->getNameKey()));
									bFirst = false;
								}
								if (pShadowUnit == pHeadSelectedUnit)
								{
									if (!bFirst)
										strHelp.append(L"\n");
									strHelp.append(gDLL->getText("TXT_KEY_CAN_NOT_AUTOMATE_PROTECT_YOURSELF"));
									bFirst = false;
								}
							}
						}
					}
				}
				break;
			}
			default:
			{
				if (!CvWString(GC.getInterfaceModeInfo(eInterfaceMode).getHelp()).empty())
				{
					szTempBuffer.append(GC.getInterfaceModeInfo(eInterfaceMode).getHelp());
					szTempBuffer.append(NEWLINE);
				}
				break;
			}
		}
		szTempBuffer.append(NEWLINE);
		szTempBuffer += strHelp.getCString();
		strHelp.assign(szTempBuffer);
	}
}

void CvGameTextMgr::getRebasePlotHelp(const CvPlot* pPlot, CvWString& strHelp) const
{
	if (pPlot)
	{
		const CvUnit* pHeadSelectedUnit = gDLL->getInterfaceIFace()->getHeadSelectedUnit();
		if (pHeadSelectedUnit)
		{
			if (pPlot->isFriendlyCity(*pHeadSelectedUnit, true))
			{
				const CvCity* pCity = pPlot->getPlotCity();
				if (pCity)
				{
					int iNumUnits = pCity->plot()->countNumAirUnits(GC.getGame().getActiveTeam());
					bool bFull = (iNumUnits >= pCity->getAirUnitCapacity(GC.getGame().getActiveTeam()));
					if (GC.getGame().isOption(GAMEOPTION_COMBAT_SIZE_MATTERS))
					{
						iNumUnits = pCity->plot()->countNumAirUnitCargoVolume(GC.getGame().getActiveTeam());
						bFull = (iNumUnits >= pCity->getSMAirUnitCapacity(GC.getGame().getActiveTeam()));
					}

					if (bFull)
					{
						strHelp += CvWString::format(SETCOLR, TEXT_COLOR("COLOR_WARNING_TEXT"));
					}

					if (!GC.getGame().isOption(GAMEOPTION_COMBAT_SIZE_MATTERS))
					{
						strHelp +=  NEWLINE + gDLL->getText("TXT_KEY_CITY_BAR_AIR_UNIT_CAPACITY", iNumUnits, pCity->getAirUnitCapacity(GC.getGame().getActiveTeam()));
					}
					else
					{
						strHelp +=  NEWLINE + gDLL->getText("TXT_KEY_CITY_BAR_AIR_UNIT_CAPACITY", iNumUnits, pCity->getSMAirUnitCapacity(GC.getGame().getActiveTeam()));
					}

					if (bFull)
					{
						strHelp += ENDCOLR;
					}

					strHelp += NEWLINE;
				}
			}
		}
	}
}


void CvGameTextMgr::getInterfaceCenterText(CvWString& strText)
{
	strText.clear();
	if (!gDLL->getInterfaceIFace()->isCityScreenUp())
	{
		if (GC.getGame().getWinner() != NO_TEAM)
		{
			strText = gDLL->getText("TXT_KEY_MISC_WINS_VICTORY", GET_TEAM(GC.getGame().getWinner()).getName().GetCString(), GC.getVictoryInfo(GC.getGame().getVictory()).getTextKeyWide());
		}
		else if (!GET_PLAYER(GC.getGame().getActivePlayer()).isAlive())
		{
			strText = gDLL->getText("TXT_KEY_MISC_DEFEAT");
		}
	}
}

void CvGameTextMgr::getTurnTimerText(CvWString& strText)
{
	PROFILE_EXTRA_FUNC();
	strText.clear();
	if (gDLL->getInterfaceIFace()->getShowInterface() == INTERFACE_SHOW || gDLL->getInterfaceIFace()->getShowInterface() == INTERFACE_ADVANCED_START)
	{
		if (GC.getGame().isMPOption(MPOPTION_TURN_TIMER))
		{
			// Get number of turn slices remaining until end-of-turn
			int iTurnSlicesRemaining = GC.getGame().getTurnSlicesRemaining();

			if (iTurnSlicesRemaining > 0)
			{
				// Get number of seconds remaining
				int iTurnSecondsRemaining = ((int)floorf((float)(iTurnSlicesRemaining-1) * ((float)gDLL->getMillisecsPerTurn()/1000.0f)) + 1);
				int iTurnMinutesRemaining = (int)(iTurnSecondsRemaining/60);
				iTurnSecondsRemaining = (iTurnSecondsRemaining%60);
				int iTurnHoursRemaining = (int)(iTurnMinutesRemaining/60);
				iTurnMinutesRemaining = (iTurnMinutesRemaining%60);

				// Display time remaining
				CvWString szTempBuffer;
				szTempBuffer.Format(L"%d:%02d:%02d", iTurnHoursRemaining, iTurnMinutesRemaining, iTurnSecondsRemaining);
				strText += szTempBuffer;
			}
			else
			{
				// Flash zeroes
				if (iTurnSlicesRemaining % 2 == 0)
				{
					// Display 0
					strText+=L"0:00";
				}
			}
		}

		if (GC.getGame().getGameState() == GAMESTATE_ON)
		{
			int iMinVictoryTurns = MAX_INT;
			for (int i = 0; i < GC.getNumVictoryInfos(); ++i)
			{
				TeamTypes eActiveTeam = GC.getGame().getActiveTeam();
				if (NO_TEAM != eActiveTeam)
				{
					int iCountdown = GET_TEAM(eActiveTeam).getVictoryCountdown((VictoryTypes)i);
					if (iCountdown > 0 && iCountdown < iMinVictoryTurns)
					{
						iMinVictoryTurns = iCountdown;
					}
				}
			}

			if (GC.getGame().isOption(GAMEOPTION_CORE_CUSTOM_START) && GC.getGame().getElapsedGameTurns() <= getTreatyLength())
			{
				if (!strText.empty())
				{
					strText += L" -- ";
				}

				strText += gDLL->getText("TXT_KEY_MISC_ADVANCED_START_PEACE_REMAINING", getTreatyLength() - GC.getGame().getElapsedGameTurns());
			}
			else if (iMinVictoryTurns < MAX_INT)
			{
				if (!strText.empty())
				{
					strText += L" -- ";
				}

				strText += gDLL->getText("TXT_KEY_MISC_TURNS_LEFT_TO_VICTORY", iMinVictoryTurns);
			}
			else if (GC.getGame().getMaxTurns() > 0)
			{
				if ((GC.getGame().getElapsedGameTurns() >= (GC.getGame().getMaxTurns() - 100)) && (GC.getGame().getElapsedGameTurns() < GC.getGame().getMaxTurns()))
				{
					if (!strText.empty())
					{
						strText += L" -- ";
					}

					strText += gDLL->getText("TXT_KEY_MISC_TURNS_LEFT", (GC.getGame().getMaxTurns() - GC.getGame().getElapsedGameTurns()));
				}
			}
		}
	}
}


void CvGameTextMgr::getFontSymbols(std::vector< std::vector<wchar_t> >& aacSymbols, std::vector<int>& aiMaxNumRows)
{
	PROFILE_EXTRA_FUNC();
	aacSymbols.push_back(std::vector<wchar_t>());
	aiMaxNumRows.push_back(1);
	for (int iI = 0; iI < NUM_YIELD_TYPES; iI++)
	{
		aacSymbols[aacSymbols.size() - 1].push_back((wchar_t) GC.getYieldInfo((YieldTypes) iI).getChar());
	}

	aacSymbols.push_back(std::vector<wchar_t>());
	aiMaxNumRows.push_back(2);
	for (int iI = 0; iI < NUM_COMMERCE_TYPES; iI++)
	{
		aacSymbols[aacSymbols.size() - 1].push_back((wchar_t) GC.getCommerceInfo((CommerceTypes) iI).getChar());
	}

	aacSymbols.push_back(std::vector<wchar_t>());
	aiMaxNumRows.push_back(8); // There are 26 rows of 25 icons each from the start of religions to the start of the generic symbols, 23 to the beginning of property symbols
	for (int iI = 0; iI < GC.getNumReligionInfos(); iI++)
	{
		aacSymbols[aacSymbols.size() - 1].push_back((wchar_t) GC.getReligionInfo((ReligionTypes) iI).getChar());
		aacSymbols[aacSymbols.size() - 1].push_back((wchar_t) GC.getReligionInfo((ReligionTypes) iI).getHolyCityChar());
	}
	for (int iI = 0; iI < GC.getNumCorporationInfos(); iI++)
	{
		aacSymbols[aacSymbols.size() - 1].push_back((wchar_t) GC.getCorporationInfo((CorporationTypes) iI).getChar());
		aacSymbols[aacSymbols.size() - 1].push_back((wchar_t) GC.getCorporationInfo((CorporationTypes) iI).getHeadquarterChar());
	}
	// TB: Invisibility symbols
	aacSymbols.push_back(std::vector<wchar_t>());
	aiMaxNumRows.push_back(1); // There is 1 row of 25 icons each from the start of invisibility symbols to the start of the property symbols
	for (int iI = 0; iI < GC.getNumInvisibleInfos(); iI++)
	{
		aacSymbols[aacSymbols.size() - 1].push_back((wchar_t) GC.getInvisibleInfo((InvisibleTypes) iI).getChar());
	}

	// AIAndy: Property symbols
	aacSymbols.push_back(std::vector<wchar_t>());
	aiMaxNumRows.push_back(3); // There are 3 rows of 25 icons each from the start of property symbols to the start of the generic symbols
	for (int iI = 0; iI < GC.getNumPropertyInfos(); iI++)
	{
		aacSymbols[aacSymbols.size() - 1].push_back((wchar_t) GC.getPropertyInfo((PropertyTypes) iI).getChar());
	}

	aacSymbols.push_back(std::vector<wchar_t>());
	aiMaxNumRows.push_back(2);
	for (int iI = 0; iI < MAX_NUM_SYMBOLS; iI++)
	{
		aacSymbols[aacSymbols.size() - 1].push_back((wchar_t) gDLL->getSymbolID(iI));
	}

	aacSymbols.push_back(std::vector<wchar_t>());
	aiMaxNumRows.push_back((GC.getNumBonusInfos() / 25) + 1);
	for (int iI = 0; iI < GC.getNumBonusInfos(); iI++)
	{
		int iChar = GC.getBonusInfo((BonusTypes) iI).getChar();
		aacSymbols[aacSymbols.size() - 1].push_back((wchar_t) iChar);
	}

}

void CvGameTextMgr::assignFontIds(int iFirstSymbolCode, int iPadAmount)
{
	PROFILE_EXTRA_FUNC();
	int iCurSymbolID = iFirstSymbolCode;  // first symbol code = 8483
	int i;

	// set yield symbols
	for (i = 0; i < NUM_YIELD_TYPES; i++)
	{
		GC.getYieldInfo((YieldTypes) i).setChar(iCurSymbolID);
		++iCurSymbolID;
	}

	do
	{
		++iCurSymbolID;
	} while (iCurSymbolID % iPadAmount != 0);

	//8500

	// set commerce symbols
	for (i = 0; i < NUM_COMMERCE_TYPES; i++)
	{
		GC.getCommerceInfo((CommerceTypes) i).setChar(iCurSymbolID);
		++iCurSymbolID;
	}

	do
	{
		++iCurSymbolID;
	} while (iCurSymbolID % iPadAmount != 0);

	//8525
	if (NUM_COMMERCE_TYPES < iPadAmount)
	{
		do
		{
			++iCurSymbolID;
		} while (iCurSymbolID % iPadAmount != 0);
	}

	//8550
	for (i = 0; i < GC.getNumReligionInfos(); i++)
	{
		GC.getReligionInfo((ReligionTypes) i).setChar(iCurSymbolID);
		++iCurSymbolID;
		GC.getReligionInfo((ReligionTypes) i).setHolyCityChar(iCurSymbolID);
		++iCurSymbolID;
	}
	//int iRel = i; //138
	//8826
	for (i = 0; i < GC.getNumCorporationInfos(); i++)
	{
		GC.getCorporationInfo((CorporationTypes) i).setChar(iCurSymbolID);
		++iCurSymbolID;
		GC.getCorporationInfo((CorporationTypes) i).setHeadquarterChar(iCurSymbolID);
		++iCurSymbolID;
	}
	//int iCorp = i;//138
	//9102
	do
	{
		++iCurSymbolID;
	} while (iCurSymbolID % iPadAmount != 0);
	//9125
	if (2 * (GC.getNumReligionInfos() + GC.getNumCorporationInfos()) < iPadAmount)
	{
		do
		{
			++iCurSymbolID;
		} while (iCurSymbolID % iPadAmount != 0);
	}

	int iSavePosition=iCurSymbolID;
	int propertyBaseID = iSavePosition;
	// AIAndy: Property symbols
	for (i = 0; i < GC.getNumPropertyInfos(); i++)
	{
		int propertyID = propertyBaseID + GC.getPropertyInfo((PropertyTypes) i).getFontButtonIndex();
		GC.getPropertyInfo((PropertyTypes) i).setChar(propertyID);
		//++iCurSymbolID;
	}

// modified Sephi
// Symbol loading adjusted to WoC.

	// set bonus symbols
	int invisBaseID = iSavePosition -23;
	//++iCurSymbolID;
	for (i = 0; i < GC.getNumInvisibleInfos(); i++)
	{
		int invisID = invisBaseID + GC.getInvisibleInfo((InvisibleTypes)i).getFontButtonIndex();
		GC.getInvisibleInfo((InvisibleTypes) i).setChar(invisID);
		//++iCurSymbolID;
	}

	// set bonus symbols
	int bonusBaseID = iSavePosition + 125;
	//++iCurSymbolID;
	for (i = 0; i < GC.getNumBonusInfos(); i++)
	{
		int bonusID = bonusBaseID + GC.getBonusInfo((BonusTypes) i).getArtInfo()->getFontButtonIndex();
		GC.getBonusInfo((BonusTypes) i).setChar(bonusID);
		//++iCurSymbolID;
	}
	// 9206
	iCurSymbolID=iSavePosition+125;
	iCurSymbolID-=(MAX_NUM_SYMBOLS);
	do
	{
		--iCurSymbolID;
	} while (iCurSymbolID % iPadAmount != 0);

// modified Sephi
	// set extra symbols
	for (i=0; i < MAX_NUM_SYMBOLS; i++)
	{
		gDLL->setSymbolID(i, iCurSymbolID);
		++iCurSymbolID;
	}
} // 9226

void CvGameTextMgr::getCityDataForAS(std::vector<CvWBData>& mapCityList, std::vector<CvWBData>& mapBuildingList, std::vector<CvWBData>& mapAutomateList)
{
	PROFILE_EXTRA_FUNC();
	CvPlayer& kActivePlayer = GET_PLAYER(GC.getGame().getActivePlayer());

	CvWString szHelp;
	int iCost = kActivePlayer.getAdvancedStartCityCost(true);
	if (iCost > 0)
	{
		szHelp = gDLL->getText("TXT_WORD_CITY");
		szHelp += gDLL->getText("TXT_KEY_AS_UNREMOVABLE");
		mapCityList.push_back(CvWBData(0, szHelp, ARTFILEMGR.getInterfaceArtInfo("INTERFACE_BUTTONS_CITYSELECTION")->getPath()));
	}

	iCost = kActivePlayer.getAdvancedStartPopCost(true);
	if (iCost > 0)
	{
		szHelp = gDLL->getText("TXT_KEY_WB_AS_POPULATION");
		mapCityList.push_back(CvWBData(1, szHelp, ARTFILEMGR.getInterfaceArtInfo("INTERFACE_ANGRYCITIZEN_TEXTURE")->getPath()));
	}

	iCost = kActivePlayer.getAdvancedStartCultureCost(true);
	if (iCost > 0)
	{
		szHelp = gDLL->getText("TXT_KEY_ADVISOR_CULTURE");
		szHelp += gDLL->getText("TXT_KEY_AS_UNREMOVABLE");
		mapCityList.push_back(CvWBData(2, szHelp, ARTFILEMGR.getInterfaceArtInfo("CULTURE_BUTTON")->getPath()));
	}

	CvWStringBuffer szBuffer;
	for (int i = 0; i < GC.getNumBuildingInfos(); i++)
	{
		const BuildingTypes eBuilding = static_cast<BuildingTypes>(i);
		if (GC.getBuildingInfo(eBuilding).getFreeStartEra() == NO_ERA || GC.getGame().getStartEra() < GC.getBuildingInfo(eBuilding).getFreeStartEra())
		{
			// Building cost -1 denotes unit which may not be purchased
			iCost = kActivePlayer.getAdvancedStartBuildingCost(eBuilding, true);
			if (iCost > 0)
			{
				szBuffer.clear();
				setBuildingHelp(szBuffer, eBuilding, false);
				mapBuildingList.push_back(CvWBData(eBuilding, szBuffer.getCString(), GC.getBuildingInfo(eBuilding).getButton()));
			}
		}
	}

	szHelp = gDLL->getText("TXT_KEY_ACTION_AUTOMATE_BUILD");
	mapAutomateList.push_back(CvWBData(0, szHelp, ARTFILEMGR.getInterfaceArtInfo("INTERFACE_AUTOMATE")->getPath()));
}

void CvGameTextMgr::getUnitDataForAS(std::vector<CvWBData>& mapUnitList)
{
	PROFILE_EXTRA_FUNC();
	CvPlayer& kActivePlayer = GET_PLAYER(GC.getGame().getActivePlayer());

	CvWStringBuffer szBuffer;
	for(int i = 0; i < GC.getNumUnitInfos(); i++)
	{
		// Unit cost less than 1 denotes unit which may not be purchased
		if (kActivePlayer.getAdvancedStartUnitCost((UnitTypes) i, true) > 0)
		{
			szBuffer.clear();
			setUnitHelp(szBuffer, (UnitTypes) i);

			if (GC.getDefineINT("ADVANCED_START_MAX_UNITS_PER_CITY") >= 0 && GC.getUnitInfo((UnitTypes) i).isMilitarySupport())
			{
				szBuffer.append(NEWLINE);
				szBuffer.append(gDLL->getText("TXT_KEY_WB_AS_MAX_UNITS_PER_CITY", GC.getDefineINT("ADVANCED_START_MAX_UNITS_PER_CITY")));
			}
			mapUnitList.push_back(CvWBData((UnitTypes) i, szBuffer.getCString(), kActivePlayer.getUnitButton((UnitTypes) i)));
		}
	}
}

void CvGameTextMgr::getImprovementDataForAS(std::vector<CvWBData>& mapImprovementList, std::vector<CvWBData>& mapRouteList)
{
	PROFILE_EXTRA_FUNC();
	const CvPlayer& kActivePlayer = GET_PLAYER(GC.getGame().getActivePlayer());

	CvWStringBuffer szBuffer;
	for (int i = 0; i < GC.getNumRouteInfos(); i++)
	{
		const RouteTypes eRoute = (RouteTypes) i;
		if (eRoute != NO_ROUTE)
		{
			// Route cost -1 denotes route which may not be purchased
			const int iCost = kActivePlayer.getAdvancedStartRouteCost(eRoute, true);
			if (iCost > 0)
			{
				szBuffer.clear();
				setRouteHelp(szBuffer, eRoute);
				mapRouteList.push_back(CvWBData(eRoute, szBuffer.getCString(), GC.getRouteInfo(eRoute).getButton()));
			}
		}
	}

	for (int i = 0; i < GC.getNumImprovementInfos(); i++)
	{
		const ImprovementTypes eImprovement = (ImprovementTypes) i;
		if (eImprovement != NO_IMPROVEMENT)
		{
			// Improvement cost -1 denotes Improvement which may not be purchased
			const int iCost = kActivePlayer.getAdvancedStartImprovementCost(eImprovement, true);
			if (iCost > 0)
			{
				szBuffer.clear();
				setImprovementHelp(szBuffer, eImprovement);
				mapImprovementList.push_back(CvWBData(eImprovement, szBuffer.getCString(), GC.getImprovementInfo(eImprovement).getButton()));
			}
		}
	}
}

void CvGameTextMgr::getVisibilityDataForAS(std::vector<CvWBData>& mapVisibilityList)
{
	// Unit cost -1 denotes unit which may not be purchased
	const int iCost = GET_PLAYER(GC.getGame().getActivePlayer()).getAdvancedStartVisibilityCost();
	if (iCost > 0)
	{
		CvWString szHelp = gDLL->getText("TXT_KEY_WB_AS_VISIBILITY");
		szHelp += gDLL->getText("TXT_KEY_AS_UNREMOVABLE", iCost);
		mapVisibilityList.push_back(CvWBData(0, szHelp, ARTFILEMGR.getInterfaceArtInfo("INTERFACE_TECH_LOS")->getPath()));
	}
}

void CvGameTextMgr::getTechDataForAS(std::vector<CvWBData>& mapTechList)
{
	mapTechList.push_back(CvWBData(0, gDLL->getText("TXT_KEY_WB_AS_TECH"), ARTFILEMGR.getInterfaceArtInfo("INTERFACE_BTN_TECH")->getPath()));
}

void CvGameTextMgr::getUnitDataForWB(std::vector<CvWBData>& mapUnitData)
{
	PROFILE_EXTRA_FUNC();
	CvWStringBuffer szBuffer;
	for (int i = 0; i < GC.getNumUnitInfos(); i++)
	{
		szBuffer.clear();
		setUnitHelp(szBuffer, (UnitTypes)i);
		mapUnitData.push_back(CvWBData(i, szBuffer.getCString(), GC.getUnitInfo((UnitTypes)i).getButton()));
	}
}

void CvGameTextMgr::getBuildingDataForWB(bool bStickyButton, std::vector<CvWBData>& mapBuildingData)
{
	PROFILE_EXTRA_FUNC();
	int iCount = 0;
	if (!bStickyButton)
	{
		mapBuildingData.push_back(CvWBData(iCount++, GC.getMissionInfo(MISSION_FOUND).getDescription(), GC.getMissionInfo(MISSION_FOUND).getButton()));
	}

	CvWStringBuffer szBuffer;
	for (int i=0; i < GC.getNumBuildingInfos(); i++)
	{
		szBuffer.clear();
		setBuildingHelp(szBuffer, (BuildingTypes)i, false);
		mapBuildingData.push_back(CvWBData(iCount++, szBuffer.getCString(), GC.getBuildingInfo((BuildingTypes)i).getButton()));
	}
}

void CvGameTextMgr::getTerrainDataForWB(std::vector<CvWBData>& mapTerrainData, std::vector<CvWBData>& mapFeatureData, std::vector<CvWBData>& mapPlotData, std::vector<CvWBData>& mapRouteData)
{
	PROFILE_EXTRA_FUNC();
	CvWStringBuffer szBuffer;

	for (int i = 0; i < GC.getNumTerrainInfos(); i++)
	{
		if (!GC.getTerrainInfo((TerrainTypes)i).isGraphicalOnly())
		{
			szBuffer.clear();
			setTerrainHelp(szBuffer, (TerrainTypes)i);
			mapTerrainData.push_back(CvWBData(i, szBuffer.getCString(), GC.getTerrainInfo((TerrainTypes)i).getButton()));
		}
	}

	for (int i = 0; i < GC.getNumFeatureInfos(); i++)
	{
		for (int k = 0; k < GC.getFeatureInfo((FeatureTypes)i).getArtInfo()->getNumVarieties(); k++)
		{
			szBuffer.clear();
			setFeatureHelp(szBuffer, (FeatureTypes)i);
			mapFeatureData.push_back(CvWBData(i + GC.getNumFeatureInfos() * k, szBuffer.getCString(), GC.getFeatureInfo((FeatureTypes)i).getArtInfo()->getVariety(k).getVarietyButton()));
		}
	}

	mapPlotData.push_back(CvWBData(0, gDLL->getText("TXT_KEY_WB_PLOT_TYPE_MOUNTAIN"), ARTFILEMGR.getInterfaceArtInfo("WORLDBUILDER_PLOT_TYPE_MOUNTAIN")->getPath()));
	mapPlotData.push_back(CvWBData(1, gDLL->getText("TXT_KEY_WB_PLOT_TYPE_HILL"), ARTFILEMGR.getInterfaceArtInfo("WORLDBUILDER_PLOT_TYPE_HILL")->getPath()));
	mapPlotData.push_back(CvWBData(2, gDLL->getText("TXT_KEY_WB_PLOT_TYPE_PLAINS"), ARTFILEMGR.getInterfaceArtInfo("WORLDBUILDER_PLOT_TYPE_PLAINS")->getPath()));
	mapPlotData.push_back(CvWBData(3, gDLL->getText("TXT_KEY_WB_PLOT_TYPE_OCEAN"), ARTFILEMGR.getInterfaceArtInfo("WORLDBUILDER_PLOT_TYPE_OCEAN")->getPath()));

	for (int i = 0; i < GC.getNumRouteInfos(); i++)
	{
		mapRouteData.push_back(CvWBData(i, GC.getRouteInfo((RouteTypes)i).getDescription(), GC.getRouteInfo((RouteTypes)i).getButton()));
	}
	mapRouteData.push_back(CvWBData(GC.getNumRouteInfos(), gDLL->getText("TXT_KEY_WB_RIVER_PLACEMENT"), ARTFILEMGR.getInterfaceArtInfo("WORLDBUILDER_RIVER_PLACEMENT")->getPath()));
}

void CvGameTextMgr::getTerritoryDataForWB(std::vector<CvWBData>& mapTerritoryData)
{
	PROFILE_EXTRA_FUNC();
	for (int i = 0; i < MAX_PLAYERS; i++)
	{
		CvWString szName = gDLL->getText("TXT_KEY_MAIN_MENU_NONE");
		CvString szButton = GC.getCivilizationInfo(GET_PLAYER(BARBARIAN_PLAYER).getCivilizationType()).getButton();

		if (GET_PLAYER((PlayerTypes) i).isEverAlive())
		{
			szName = GET_PLAYER((PlayerTypes)i).getName();
			szButton = GC.getCivilizationInfo(GET_PLAYER((PlayerTypes)i).getCivilizationType()).getButton();
		}
		mapTerritoryData.push_back(CvWBData(i, szName, szButton));
	}
}


void CvGameTextMgr::getTechDataForWB(std::vector<CvWBData>& mapTechData)
{
	PROFILE_EXTRA_FUNC();
	CvWStringBuffer szBuffer;
	for (int i=0; i < GC.getNumTechInfos(); i++)
	{
		szBuffer.clear();
		setTechHelp(szBuffer, (TechTypes) i);
		mapTechData.push_back(CvWBData(i, szBuffer.getCString(), GC.getTechInfo((TechTypes) i).getButton()));
	}
}

void CvGameTextMgr::getPromotionDataForWB(std::vector<CvWBData>& mapPromotionData)
{
	PROFILE_EXTRA_FUNC();
	CvWStringBuffer szBuffer;
	for (int i=0; i < GC.getNumPromotionInfos(); i++)
	{
		szBuffer.clear();
		setPromotionHelp(szBuffer, (PromotionTypes) i, false);
		mapPromotionData.push_back(CvWBData(i, szBuffer.getCString(), GC.getPromotionInfo((PromotionTypes) i).getButton()));
	}
}

/*
void CvGameTextMgr::getTraitDataForWB(std::vector<CvWBData>& mapTraitData) const
{
	CvWStringBuffer szBuffer;
	for (int i=0; i < GC.getNumTraitInfos(); i++)
	{
		szBuffer.clear();
		setTraitHelp(szBuffer, (TraitTypes) i);
		mapTraitData.push_back(CvWBData(i, szBuffer.getCString(), GC.getTraitInfo((TraitTypes) i).getButton()));
	}
}
*/

void CvGameTextMgr::getBonusDataForWB(std::vector<CvWBData>& mapBonusData)
{
	PROFILE_EXTRA_FUNC();
	CvWStringBuffer szBuffer;
	for (int i=0; i < GC.getNumBonusInfos(); i++)
	{
		szBuffer.clear();
		setBonusHelp(szBuffer, (BonusTypes)i);
		mapBonusData.push_back(CvWBData(i, szBuffer.getCString(), GC.getBonusInfo((BonusTypes) i).getButton()));
	}
}

void CvGameTextMgr::getImprovementDataForWB(std::vector<CvWBData>& mapImprovementData)
{
	PROFILE_EXTRA_FUNC();
	CvWStringBuffer szBuffer;
	for (int i=0; i < GC.getNumImprovementInfos(); i++)
	{
		const CvImprovementInfo& kInfo = GC.getImprovementInfo((ImprovementTypes) i);
		if (!kInfo.isGraphicalOnly())
		{
			szBuffer.clear();
			setImprovementHelp(szBuffer, (ImprovementTypes) i);
			mapImprovementData.push_back(CvWBData(i, szBuffer.getCString(), kInfo.getButton()));
		}
	}
}

/*
void CvGameTextMgr::getRouteDataForWB(std::vector<CvWBData>& mapRouteData) const
{
	CvWStringBuffer szBuffer;
	for (int i=0; i < GC.getNumRouteInfos(); i++)
	{
		const CvRouteInfo& kInfo = GC.getRouteInfo((RouteTypes) i);
		if (!kInfo.isGraphicalOnly())
		{
			szBuffer.clear();
			setRouteHelp(szBuffer, (RouteTypes) i);
			mapRouteData.push_back(CvWBData(i, szBuffer.getCString(), kInfo.getButton()));
		}
	}
}
*/

void CvGameTextMgr::getReligionDataForWB(bool bHolyCity, std::vector<CvWBData>& mapReligionData)
{
	PROFILE_EXTRA_FUNC();
	for (int i = 0; i < GC.getNumReligionInfos(); ++i)
	{
		const CvReligionInfo& kInfo = GC.getReligionInfo((ReligionTypes) i);
		CvWString strDescription = kInfo.getDescription();
		if (bHolyCity)
		{
			strDescription = gDLL->getText("TXT_KEY_WB_HOLYCITY", strDescription.GetCString());
		}
		mapReligionData.push_back(CvWBData(i, strDescription, kInfo.getButton()));
	}
}


void CvGameTextMgr::getCorporationDataForWB(bool bHeadquarters, std::vector<CvWBData>& mapCorporationData)
{
	PROFILE_EXTRA_FUNC();
	for (int i = 0; i < GC.getNumCorporationInfos(); ++i)
	{
		const CvCorporationInfo& kInfo = GC.getCorporationInfo((CorporationTypes) i);
		CvWString strDescription = kInfo.getDescription();
		if (bHeadquarters)
		{
			strDescription = gDLL->getText("TXT_KEY_CORPORATION_HEADQUARTERS", strDescription.GetCString());
		}
		mapCorporationData.push_back(CvWBData(i, strDescription, kInfo.getButton()));
	}
}


void CvGameTextMgr::buildCanPassPeaksString(CvWStringBuffer &szBuffer, TechTypes eTech, bool bList, bool bPlayerContext)
{
	if (GC.getTechInfo(eTech).isCanPassPeaks() && (!bPlayerContext || !(GET_TEAM(GC.getGame().getActiveTeam()).isCanPassPeaks())))
	{
		if (bList)
		{
			szBuffer.append(NEWLINE);
		}
		szBuffer.append(gDLL->getText("TXT_KEY_CAN_PASS_PEAKS"));
	}
}

void CvGameTextMgr::buildMoveFastPeaksString(CvWStringBuffer &szBuffer, TechTypes eTech, bool bList, bool bPlayerContext)
{
	if (GC.getTechInfo(eTech).isMoveFastPeaks() && (!bPlayerContext || !(GET_TEAM(GC.getGame().getActiveTeam()).isMoveFastPeaks())))
	{
		if (bList)
		{
			szBuffer.append(NEWLINE);
		}
		szBuffer.append(gDLL->getText("TXT_KEY_MOVE_FAST_PEAKS"));
	}
}

void CvGameTextMgr::buildCanFoundOnPeaksString(CvWStringBuffer &szBuffer, TechTypes eTech, bool bList, bool bPlayerContext)
{
	if (GC.getTechInfo(eTech).isCanFoundOnPeaks() && (!bPlayerContext || !(GET_TEAM(GC.getGame().getActiveTeam()).isCanFoundOnPeaks())))
	{
		if (bList)
		{
			szBuffer.append(NEWLINE);
		}
		szBuffer.append(gDLL->getText("TXT_KEY_CAN_FOUND_ON_PEAKS"));
	}
}

void CvGameTextMgr::buildCanRebaseAnywhereString(CvWStringBuffer &szBuffer, TechTypes eTech, bool bList, bool bPlayerContext)
{
	if (GC.getDefineINT("MAX_AIRLIFT_RANGE") > 0)
	{
		if (GC.getTechInfo(eTech).isRebaseAnywhere() && (!bPlayerContext || !(GET_TEAM(GC.getGame().getActiveTeam()).isRebaseAnywhere())))
		{
			if (bList)
			{
				szBuffer.append(NEWLINE);
			}
			szBuffer.append(gDLL->getText("TXT_KEY_CAN_REBASE_ANYWHERE"));
		}
	}
}


/*
	+50% from Buildings
	+25% from Wonders
	+10% from resources
	+25% from Civics
	+25% from Culture
	+10% from Terrain
	=======================
	Base Defense: 100%
	=======================
	Percent Siege Damaged: 25%
	Siege Damage 25%
	Current Defense: 75%
	=======================
	Base Bombard Defense: 60%
	=======================
	* Walls: +30%
*/
void CvGameTextMgr::getDefenseHelp(CvWStringBuffer &szBuffer, CvCity& city)
{
	PROFILE_EXTRA_FUNC();
	FAssertMsg(NO_PLAYER != city.getOwner(), "City must have an owner");

	CvWString szTempBuffer;

	// Buildings
	int iBuildingDefense = 0;
	int iBombardDefense = 0;
	int iWonderDefense = 0;
	int iResourceDefense = 0;

	foreach_(const BuildingTypes eType, city.getHasBuildings())
	{
		if (!city.isDisabledBuilding(eType))
		{
			const CvBuildingInfo& building = GC.getBuildingInfo(eType);

			if (isLimitedWonder(eType))
			{
				iWonderDefense += building.getDefenseModifier();
			}
			else iBuildingDefense += building.getDefenseModifier();

			iBombardDefense += building.getBombardDefenseModifier();

			for (int iJ = GC.getNumBonusInfos() - 1; iJ > -1; iJ--)
			{
				if (city.hasBonus((BonusTypes)iJ))
				{
					iResourceDefense += building.getBonusDefenseChanges(iJ);
				}
			}
		}
	}
	int iBaseRate = 0;
	bool bFirst = false;
	if (iBuildingDefense != 0)
	{
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_BUILDING_DEFENSE_HOVER", iBuildingDefense));
		iBaseRate += iBuildingDefense;
		bFirst = true;
	}

	int iCivicDefense = 0;
	for (int iJ = 0; iJ < GC.getNumCivicOptionInfos(); iJ++)
	{
		const CivicTypes eCivic = GET_PLAYER(city.getOwner()).getCivics((CivicOptionTypes)iJ);
		if (GC.getCivicInfo(eCivic).getExtraCityDefense() != 0)
		{
			iCivicDefense += GC.getCivicInfo(eCivic).getExtraCityDefense();
		}
	}

	int iTraitDefense = 0;
	for (int iJ = 0; iJ < GC.getNumTraitInfos(); iJ++)
	{
		TraitTypes eTrait = (TraitTypes)iJ;
		if (GET_PLAYER(city.getOwner()).hasTrait(eTrait))
		{
			iBombardDefense += GC.getTraitInfo(eTrait).getBombardDefense();
			if (GC.getTraitInfo(eTrait).getCityDefenseBonus() != 0)
			{
				iTraitDefense += GC.getTraitInfo(eTrait).getCityDefenseBonus();
			}
		}
	}

	iWonderDefense += GET_PLAYER(city.getOwner()).getCityDefenseModifier() - iCivicDefense - iTraitDefense;
	if (iWonderDefense != 0)
	{
		if (bFirst) szBuffer.append(NEWLINE);
		else bFirst = true;

		szBuffer.append(gDLL->getText("TXT_KEY_MISC_WONDER_DEFENSE_HOVER", iWonderDefense));
		iBaseRate += iWonderDefense;
	}
	if (iResourceDefense != 0)
	{
		if (bFirst) szBuffer.append(NEWLINE);
		else bFirst = true;

		szBuffer.append(gDLL->getText("TXT_KEY_MISC_RESOURCE_DEFENSE_HOVER", iResourceDefense));
		iBaseRate += iResourceDefense;
	}

	if (iCivicDefense != 0)
	{
		if (bFirst) szBuffer.append(NEWLINE);
		else bFirst = true;

		szBuffer.append(gDLL->getText("TXT_KEY_MISC_CIVIC_DEFENSE_HOVER", iCivicDefense));
		iBaseRate += iCivicDefense;
	}

	if (iTraitDefense != 0)
	{
		if (bFirst) szBuffer.append(NEWLINE);
		else bFirst = true;

		szBuffer.append(gDLL->getText("TXT_KEY_MISC_TRAIT_DEFENSE_HOVER", iTraitDefense));
		iBaseRate += iTraitDefense;
	}

	const int iCultureDefense = city.getNaturalDefense() - iBuildingDefense;
	if (iCultureDefense > 0)
	{
		if (bFirst) szBuffer.append(NEWLINE);
		else bFirst = true;

		szBuffer.append(gDLL->getText("TXT_KEY_MISC_CULTURE_DEFENSE_HOVER", iCultureDefense));
		iBaseRate += iCultureDefense;
	}

	FAssertMsg(iBaseRate == city.getTotalDefense(false), CvString::format("Actual: %d; displayed: %d; Building Def: %d", city.getTotalDefense(false), iBaseRate, city.getBuildingDefense()));

	if (iBaseRate != 0)
	{
		if (iBaseRate > 0)
		{
			szBuffer.append(DOUBLE_SEPARATOR);
		}
		// If iBaseRate isn't zero we definitely already added stuff above
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_TOTAL_DEFENSE_HOVER", iBaseRate));
	}
	{
		const int iTerrainDefense = std::max(0, city.plot()->defenseModifier(GET_PLAYER(city.getOwner()).getTeam(), false, true));
		if (iTerrainDefense != 0)
		{
			if (bFirst) szBuffer.append(NEWLINE);
			else bFirst = true;

			szBuffer.append(gDLL->getText("TXT_KEY_MISC_TERRAIN_DEFENSE_HOVER", iTerrainDefense));
			iBaseRate += iTerrainDefense;
		}
		if (iBaseRate > 0)
		{
			szBuffer.append(DOUBLE_SEPARATOR);
		}
		if (city.getDefenseDamage() != 0)
		{
			if (bFirst) szBuffer.append(NEWLINE);
			else bFirst = true;

			szBuffer.append(gDLL->getText("TXT_KEY_MISC_DEFENSE_DAMAGE_PERCENT_HOVER", city.getDefenseDamage()));
		}

		const int iDefenseDamage = (iBaseRate - iTerrainDefense) * city.getDefenseDamage() / 100;
		if (iDefenseDamage != 0)
		{
			if (bFirst) szBuffer.append(NEWLINE);
			else bFirst = true;

			szBuffer.append(gDLL->getText("TXT_KEY_MISC_DEFENSE_DAMAGE_HOVER", iDefenseDamage));
		}
		if (iBaseRate != 0)
		{
			// If iBaseRate isn't zero we definitely already added stuff above
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_MISC_CURRENT_DEFENSE_HOVER", (iBaseRate - iDefenseDamage)));
		}
	}
	if (city.getExtraMinDefense() != 0)
	{
		szBuffer.append(DOUBLE_SEPARATOR);
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_MIN_DEFENSE_HOVER", city.getExtraMinDefense()));
	}

	if (city.getMinimumDefenseLevel() > 0)
	{
		szBuffer.append(DOUBLE_SEPARATOR);
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_MINIMUM_DEFENSE_LEVEL_HOVER", city.getMinimumDefenseLevel()));
	}

	if (city.getExtraBuildingDefenseRecoverySpeedModifier() != 0)
	{
		szBuffer.append(DOUBLE_SEPARATOR);
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_BUILDING_RECOVERY_HOVER", city.getExtraBuildingDefenseRecoverySpeedModifier(), city.getModifiedBuildingDefenseRecoverySpeedCap()));
	}

	if (city.getExtraCityDefenseRecoverySpeedModifier() != 0)
	{
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_CITY_RECOVERY_HOVER", city.getExtraCityDefenseRecoverySpeedModifier()));
	}

	if (iBombardDefense != 0)
	{
		szBuffer.append(DOUBLE_SEPARATOR);
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_BUILDING_BOMBARD_DEFENSE_HOVER", iBombardDefense));
	}

	bFirst = true;
	for (int iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
	{
		if (city.getUnitCombatDefenseAgainstModifierTotal((UnitCombatTypes)iI) != 0)
		{
			if (bFirst)
			{
				szBuffer.append(DOUBLE_SEPARATOR);
				bFirst = false;
			}
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_MISC_DEFENSE_AGAINST_UNIT_COMBAT_HOVER", city.getUnitCombatDefenseAgainstModifierTotal((UnitCombatTypes)iI), GC.getUnitCombatInfo((UnitCombatTypes)iI).getTextKeyWide()));
		}
	}

	for (int iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
	{
		if (city.getUnitCombatExtraStrength((UnitCombatTypes)iI) != 0)
		{
			if (bFirst)
			{
				szBuffer.append(DOUBLE_SEPARATOR);
				bFirst = false;
			}
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_MISC_DEFENSE_UNIT_COMBAT_HOVER", GC.getUnitCombatInfo((UnitCombatTypes)iI).getTextKeyWide(), city.getUnitCombatExtraStrength((UnitCombatTypes)iI)));
		}
	}

	if (city.getExtraLocalDynamicDefense() != 0)
	{
		szBuffer.append(DOUBLE_SEPARATOR);
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_BUILDING_DYNAMIC_DEFENSE_HOVER", city.getExtraLocalDynamicDefense()));
	}

	if (city.getExtraRiverDefensePenalty() != 0)
	{
		szBuffer.append(DOUBLE_SEPARATOR);
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_BUILDING_RIVER_DEFENSE_HOVER", city.getExtraRiverDefensePenalty()));
	}

	if (city.getEspionageDefenseModifier() != 0)
	{
		szBuffer.append(DOUBLE_SEPARATOR);
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_BUILDING_ESPIONAGE_DEFENSE_HOVER", city.getEspionageDefenseModifier()));
	}

	if (city.getExtraInsidiousness() != 0)
	{
		szBuffer.append(DOUBLE_SEPARATOR);
		szBuffer.append(NEWLINE);
		szTempBuffer.Format(L"%.1f", city.getExtraInsidiousness() / 10.0f);
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_BUILDING_INSIDIOUSNESS_HOVER", szTempBuffer.GetCString()));
	}

	if (city.getInvestigationTotal() != 0)
	{
		szBuffer.append(DOUBLE_SEPARATOR);
		szBuffer.append(NEWLINE);
		szTempBuffer.Format(L"%.1f", city.getInvestigationTotal() / 10.0f);
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_BUILDING_INVESTIGATION_HOVER", szTempBuffer.GetCString()));
	}

	{
		const int iNumCrim = city.plot()->getNumCriminals();
		if (iNumCrim > 0)
		{
			szBuffer.append(DOUBLE_SEPARATOR);
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_MISC_CRIMINAL_COUNT_DEFENSE_HOVER", iNumCrim));
		}
	}

	if (city.getExtraLocalRepel() != 0)
	{
		szBuffer.append(DOUBLE_SEPARATOR);
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_LOCAL_REPEL_HOVER", city.getExtraLocalRepel()));
	}

	for (int iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
	{
		if (city.getUnitCombatRepelAgainstModifierTotal((UnitCombatTypes)iI) != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_MISC_REPEL_AGAINST_UNIT_COMBAT_HOVER", city.getUnitCombatRepelAgainstModifierTotal((UnitCombatTypes)iI), GC.getUnitCombatInfo((UnitCombatTypes)iI).getTextKeyWide()));
		}
	}

	for (int iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
	{
		if (city.getUnitCombatRepelModifierTotal((UnitCombatTypes)iI) != 0)
		{
			szBuffer.append(NEWLINE);
			szBuffer.append(gDLL->getText("TXT_KEY_MISC_REPEL_UNIT_COMBAT_HOVER", GC.getUnitCombatInfo((UnitCombatTypes)iI).getTextKeyWide(), city.getUnitCombatRepelModifierTotal((UnitCombatTypes)iI)));
		}
	}

	if (GC.getGame().isOption(GAMEOPTION_UNSUPPORTED_ZONE_OF_CONTROL) && city.isZoneOfControl())
	{
		szBuffer.append(DOUBLE_SEPARATOR);
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_ZOC_HOVER"));
	}

	if (city.getAdjacentDamagePercent())
	{
		szBuffer.append(DOUBLE_SEPARATOR);
		szBuffer.append(NEWLINE);
		szBuffer.append(gDLL->getText("TXT_KEY_MISC_ADJ_DMG_HOVER", city.getAdjacentDamagePercent()));
	}

	bFirst = true;
	for (int iJ = 0; iJ < GC.getNumBuildingInfos(); iJ++)
	{
		const BuildingTypes eBuilding = static_cast<BuildingTypes>(iJ);
		if (city.isActiveBuilding(eBuilding))
		{
			continue;
		}
		const CvBuildingInfo& building = GC.getBuildingInfo(eBuilding);
		if (!building.isDamageAttackerCapable()
		|| building.getDamageAttackerChance() <= 0
		|| building.getDamageToAttacker() <= 0)
		{
			continue;
		}
		if (building.isDamageAllAttackers())
		{
			if (bFirst)
			{
				szBuffer.append(DOUBLE_SEPARATOR);
				bFirst = false;
			}
			szBuffer.append(NEWLINE);

			if (building.isDamageToAttackerIgnoresArmor())
			{
				szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_DAMAGE_ALL_ATTACKER_ARMOR_EXEMPT", building.getDamageAttackerChance(), building.getDamageToAttacker()));
			}
			else szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_DAMAGE_ALL_ATTACKER", building.getDamageAttackerChance(), building.getDamageToAttacker()));
		}
		else
		{
			for (int iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
			{
				const UnitCombatTypes eUnitCombat = static_cast<UnitCombatTypes>(iI);
				if (city.canDamageAttackingUnitCombat(eUnitCombat)
				&& building.isMayDamageAttackingUnitCombatType(eUnitCombat))
				{
					if (bFirst)
					{
						szBuffer.append(DOUBLE_SEPARATOR);
						szBuffer.append(NEWLINE);
						szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_DAMAGE_ATTACKER_START", GC.getUnitCombatInfo(eUnitCombat).getTextKeyWide()));
						bFirst = false;
					}
					else szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_DAMAGE_ATTACKER_MIDDLE", GC.getUnitCombatInfo(eUnitCombat).getTextKeyWide()));
				}
			}
			if (!bFirst)
			{
				if (building.isDamageToAttackerIgnoresArmor())
				{
					szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_DAMAGE_ATTACKER_END_ARMOR_EXEMPT", building.getDamageAttackerChance(), building.getDamageToAttacker()));
				}
				else szBuffer.append(gDLL->getText("TXT_KEY_BUILDINGHELP_DAMAGE_ATTACKER_END", building.getDamageAttackerChance(), building.getDamageToAttacker()));
			}
		}
	}

	if (city.getOwner() == GC.getGame().getActivePlayer()
	&& getBugOptionBOOL("MiscHover__BuildingAdditionalDefense", true, "BUG_BUILDING_ADDITIONAL_DEFENSE_HOVER"))
	{
		setBuildingAdditionalDefenseHelp(szBuffer, city, DOUBLE_SEPARATOR);
	}
}

bool CvGameTextMgr::setBuildingAdditionalDefenseHelp(CvWStringBuffer &szBuffer, const CvCity& city, const CvWString& szStart, bool bStarted)
{
	PROFILE_EXTRA_FUNC();
	CvWString szLabel;

	for (int i = 0; i < GC.getNumBuildingInfos(); i++)
	{
		const BuildingTypes eBuilding = static_cast<BuildingTypes>(i);
		if (city.canConstruct(eBuilding, false, false, false))
		{
			const int iChange = city.getAdditionalDefenseByBuilding(eBuilding);
			if (iChange != 0)
			{
				if (!bStarted)
				{
					szBuffer.append(szStart);
					bStarted = true;
				}
				szLabel.Format(SETCOLR L"%s" ENDCOLR, TEXT_COLOR("COLOR_BUILDING_TEXT"), GC.getBuildingInfo(eBuilding).getDescription());
				setResumableValueChangeHelp(szBuffer, szLabel, L": ", L"", iChange, gDLL->getSymbolID(DEFENSE_CHAR), true, true);
			}
		}
	}
	return bStarted;
}

void CvGameTextMgr::setEmploymentHelp(CvWStringBuffer &szBuffer, CvCity& city)
{
	PROFILE_EXTRA_FUNC();
	FAssertMsg(NO_PLAYER != city.getOwner(), "City must have an owner");

	bool bFirst = true;
	foreach_(const BuildingTypes eTypeX, city.getHasBuildings())
	{
		if (GC.getBuildingInfo(eTypeX).getNumPopulationEmployed() > 0
		&& !city.isReligiouslyLimitedBuilding(eTypeX)
		&& !city.isDisabledBuilding(eTypeX))
		{
			if (!bFirst) szBuffer.append(NEWLINE);
			szBuffer.append(CvWString::format(L"%s: %d %c", GC.getBuildingInfo(eTypeX).getDescription(), GC.getBuildingInfo(eTypeX).getNumPopulationEmployed(), gDLL->getSymbolID(CITIZEN_CHAR)));
			bFirst = false;
		}
	}
	szBuffer.append(DOUBLE_SEPARATOR);
	szBuffer.append(NEWLINE);
	szBuffer.append(gDLL->getText("TXT_KEY_MISC_TOTAL_EMPLOYED", city.getNumPopulationEmployed()));
	szBuffer.append(CvWString::format(L" %c", gDLL->getSymbolID(CITIZEN_CHAR)));
}


void CvGameTextMgr::setFlagHelp(CvWStringBuffer &szBuffer)
{
	CvGame& GAME = GC.getGame();
	CvPlayer& player = GET_PLAYER(GAME.getActivePlayer());

	szBuffer.append(CvWString::format(SETCOLR L"%s\n", TEXT_COLOR("COLOR_HIGHLIGHT_TEXT"), player.getCivilizationDescription()));

	szBuffer.append(CvWString::format(SETCOLR L"Caveman2Cosmos %S\n" ENDCOLR, TEXT_COLOR("COLOR_YELLOW"), GC.getDefineSTRING("C2C_VERSION")));

	if (GAME.getNumHumanPlayers() > 1)
	{
		szBuffer.append(CvWString::format(SETCOLR L"%s\n" ENDCOLR, TEXT_COLOR("COLOR_MAGENTA"), gDLL->getText("TXT_KEY_SETTINGS_DIFFICULTY_PLAYER", GC.getHandicapInfo(player.getHandicapType()).getTextKeyWide()).GetCString()));
	}
	szBuffer.append(CvWString::format(SETCOLR L"%s" ENDCOLR, TEXT_COLOR("COLOR_MAGENTA"), gDLL->getText("TXT_KEY_SETTINGS_DIFFICULTY_GAME", GC.getHandicapInfo(GAME.getHandicapType()).getTextKeyWide()).GetCString()));

	// Traits
	szBuffer.append(NEWLINE L"==============================" NEWLINE);
	parsePlayerTraits(szBuffer, GAME.getActivePlayer());

	// Properties
	CvWStringBuffer szPeekBuffer;
	player.getProperties()->buildDisplayString(szPeekBuffer);

	if (!szPeekBuffer.isEmpty())
	{
		szBuffer.append(NEWLINE L"==============================" NEWLINE);
		szBuffer.append(szPeekBuffer);
		szPeekBuffer.clear();
	}
	GET_TEAM(player.getTeam()).getProperties()->buildDisplayString(szPeekBuffer);

	if (!szPeekBuffer.isEmpty())
	{
		szBuffer.append(NEWLINE L"==============================" NEWLINE);
		szBuffer.append(szPeekBuffer);
		szPeekBuffer.clear();
	}
	GAME.getProperties()->buildDisplayString(szPeekBuffer);

	if (!szPeekBuffer.isEmpty())
	{
		szBuffer.append(NEWLINE L"==============================" NEWLINE);
		szBuffer.append(szPeekBuffer);
		szPeekBuffer.clear();
	}
}


void CvGameTextMgr::buildMaintenanceModifiersString(CvWStringBuffer &szBuffer, TechTypes eTech, bool bList)
{
	if (GC.getTechInfo(eTech).getMaintenanceModifier() != 0)
	{
		if (bList)
		{
			szBuffer.append(NEWLINE);
		}
		szBuffer.append(gDLL->getText("TXT_KEY_TECHHELP_MAINT_MOD", GC.getTechInfo(eTech).getMaintenanceModifier()));
	}

	if (GC.getTechInfo(eTech).getDistanceMaintenanceModifier() != 0)
	{
		if (bList)
		{
			szBuffer.append(NEWLINE);
		}
		szBuffer.append(gDLL->getText("TXT_KEY_TECHHELP_DISTANCE_MAINT_MOD", GC.getTechInfo(eTech).getDistanceMaintenanceModifier()));
	}

	if (GC.getTechInfo(eTech).getNumCitiesMaintenanceModifier() != 0)
	{
		if (bList)
		{
			szBuffer.append(NEWLINE);
		}
		szBuffer.append(gDLL->getText("TXT_KEY_TECHHELP_NUM_CITIES_MAINT_MOD", GC.getTechInfo(eTech).getNumCitiesMaintenanceModifier()));
	}

	if (GC.getTechInfo(eTech).getCoastalDistanceMaintenanceModifier() != 0)
	{
		if (bList)
		{
			szBuffer.append(NEWLINE);
		}
		szBuffer.append(gDLL->getText("TXT_KEY_COASTAL_DISTANCE_MAINT_MOD", GC.getTechInfo(eTech).getCoastalDistanceMaintenanceModifier()));
	}
}

void CvGameTextMgr::getGameObjectName(CvWString &szString, GameObjectTypes eObject) const
{
	switch (eObject)
	{
		case GAMEOBJECT_GAME:
			szString.append(gDLL->getText("TXT_WORD_GAME"));
			break;
		case GAMEOBJECT_TEAM:
			szString.append(gDLL->getText("TXT_WORD_TEAM"));
			break;
		case GAMEOBJECT_PLAYER:
			szString.append(gDLL->getText("TXT_WORD_PLAYER"));
			break;
		case GAMEOBJECT_CITY:
			szString.append(gDLL->getText("TXT_WORD_CITY"));
			break;
		case GAMEOBJECT_UNIT:
			szString.append(gDLL->getText("TXT_WORD_UNIT"));
			break;
		case GAMEOBJECT_PLOT:
			szString.append(gDLL->getText("TXT_WORD_PLOT"));
			break;
	}
}

void CvGameTextMgr::buildGameObjectRelationString(CvWStringBuffer& szBuffer, GameObjectTypes eObject, RelationTypes eRelation, int iData) const
{
	if ((eObject == NO_GAMEOBJECT) || (eRelation == NO_RELATION))
		return;
	CvWString szObject;
	getGameObjectName(szObject, eObject);

	switch (eRelation)
	{
		case RELATION_ASSOCIATED:
			szBuffer.append(szObject);
			break;

		case RELATION_TRADE:
			szBuffer.append(gDLL->getText("TXT_KEY_RELATION_TRADE"));
			break;

		case RELATION_NEAR:
			szBuffer.append(gDLL->getText("TXT_KEY_RELATION_NEAR", szObject.c_str(), iData));
			break;

		case RELATION_SAME_PLOT:
			szBuffer.append(szObject);
			break;

		case RELATION_WORKING:
			if (eObject == GAMEOBJECT_CITY)
			{
				szBuffer.append(gDLL->getText("TXT_KEY_RELATION_WORKING_CITY"));
			}
			else
			{
				szBuffer.append(gDLL->getText("TXT_KEY_RELATION_WORKING_PLOT"));
			}
			break;
	}
}
